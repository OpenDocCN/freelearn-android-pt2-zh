["```kt\n    @Override\n    public EngineOptions onCreateEngineOptions() {\n      return new EngineOptions(true,\n        ScreenOrientation.LANDSCAPE_SENSOR, \n        new FillResolutionPolicy(), \n        new Camera(0, 0, 800, 480))\n        .setWakeLockOptions(WakeLockOptions.SCREEN_ON);\n    }\n    @Override\n    public void onCreateResources(OnCreateResourcesCallback\n        pOnCreateResourcesCallback) {\n      pOnCreateResourcesCallback.onCreateResourcesFinished();\n    }\n    @Override\n    public void onCreateScene(OnCreateSceneCallback \n        pOnCreateSceneCallback) {\n      Scene mScene = new Scene();\n      mScene.setBackground(new Background(0.9f,0.9f,0.9f));\n      pOnCreateSceneCallback.onCreateSceneFinished(mScene);\n    }\n    @Override\n    public void onPopulateScene(Scene pScene, \n        OnPopulateSceneCallback pOnPopulateSceneCallback) {\n      pOnPopulateSceneCallback.onPopulateSceneFinished();\n    }\n    ```", "```kt\n    public final ArrayList<ManagedStandardTexture> loadedTextures = \n      new ArrayList<ManagedStandardTexture>();\n    public class ManagedStandardTexture {\n      public ITextureRegion textureRegion;\n      public String name;\n      public ManagedStandardTexture(String pName, \n          final ITextureRegion pTextureRegion) {\n        name = pName;\n        textureRegion = pTextureRegion;\n      }\n      public void removeFromMemory() {\n        loadedTextures.remove(this);\n        textureRegion.getTexture().unload();\n        textureRegion = null;\n        name = null;\n      }\n    }\n    ```", "```kt\n    public ITextureRegion getTextureRegion(TextureOptions \n          pTextureOptions, String pFilename) {\n      loadAndManageTextureRegion(pTextureOptions,pFilename);\n      return loadedTextures.get(\n        loadedTextures.size()-1).textureRegion;\n    }\n    public void loadAndManageTextureRegion(TextureOptions \n          pTextureOptions, String pFilename) {\n      AssetBitmapTextureAtlasSource cSource = \n        AssetBitmapTextureAtlasSource.create(\n        this.getAssets(), pFilename);  \n      BitmapTextureAtlas TextureToLoad = \n        new BitmapTextureAtlas(mEngine.getTextureManager(), \n          cSource.getTextureWidth(), \n          cSource.getTextureHeight(), \n          pTextureOptions);\n      TextureRegion TextureRegionToLoad = \n        BitmapTextureAtlasTextureRegionFactory.\n          createFromAsset(TextureToLoad, this, \n            pFilename, 0, 0);     \n      TextureToLoad.load();\n      loadedTextures.add(new ManagedStandardTexture(\n        pFilename.substring(\n          pFilename.lastIndexOf(\"/\")+1, \n          pFilename.lastIndexOf(\".\")),\n        TextureRegionToLoad));\n    }\n    ```", "```kt\n    public void loadAllTextureRegionsInFolders(TextureOptions \n        pTextureOptions, String... pFolderPaths) {\n      String[] listFileNames;\n      String curFilePath;\n      String curFileExtension;\n      for (int i = 0; i < pFolderPaths.length; i++)\n        try {\n          listFileNames = this.getAssets().\n            list(pFolderPaths[i].substring(0, \n            pFolderPaths[i].lastIndexOf(\"/\")));\n          for (String fileName : listFileNames) {\n            curFilePath = \n              pFolderPaths[i].concat(fileName);\n            curFileExtension = \n              curFilePath.substring(\n              curFilePath.lastIndexOf(\".\"));\n            if(curFileExtension.\n              equalsIgnoreCase(\".png\")\n              || curFileExtension.\n              equalsIgnoreCase(\".bmp\")\n              || curFileExtension.\n              equalsIgnoreCase(\".jpg\"))\n              loadAndManageTextureRegion(\n                pTextureOptions, \n                curFilePath);\n          }\n        } catch (IOException e) {\n          System.out.print(\"Failed to load textures\n            from folder!\");\n          e.printStackTrace();\n          return;\n        }\n    }\n    ```", "```kt\n    public void unloadAllTextures() {\n      for(ManagedStandardTexture curTex : loadedTextures) {\n        curTex.removeFromMemory();\n        curTex=null;\n        loadedTextures.remove(curTex);\n      }\n      System.gc();\n    }\n\n    public ITextureRegion getLoadedTextureRegion(String pName) {\n      for(ManagedStandardTexture curTex : loadedTextures)\n        if(curTex.name.equalsIgnoreCase(pName))\n          return curTex.textureRegion;\n      return null;\n    }\n    ```", "```kt\n    this.loadAllTextureRegionsInFolders(TextureOptions.BILINEAR, \"gfx/FolderToLoad/\");\n    ```", "```kt\n    pScene.attachChild(new Sprite(144f, 240f, \n      getLoadedTextureRegion(\"Coin1\"), \n      this.getVertexBufferObjectManager()));\n    pScene.attachChild(new Sprite(272f, 240f, \n      getLoadedTextureRegion(\"Coin5\"), \n      this.getVertexBufferObjectManager()));\n    pScene.attachChild(new Sprite(400f, 240f, \n      getLoadedTextureRegion(\"Coin10\"), \n      this.getVertexBufferObjectManager()));\n    pScene.attachChild(new Sprite(528f, 240f, \n      getLoadedTextureRegion(\"Coin50\"), \n      this.getVertexBufferObjectManager()));\n    pScene.attachChild(new Sprite(656f, 240f, \n      getLoadedTextureRegion(\"Coin100\"), \n      this.getVertexBufferObjectManager()));\n    ```", "```kt\n    @Override\n    public EngineOptions onCreateEngineOptions() {\n      return new EngineOptions(true,\n        ScreenOrientation.LANDSCAPE_SENSOR, \n        new FillResolutionPolicy(), \n        new Camera(0, 0, 800, 480))\n        .setWakeLockOptions(WakeLockOptions.SCREEN_ON);\n    }\n    @Override\n    public void onCreateResources(OnCreateResourcesCallback\n        pOnCreateResourcesCallback) {\n      pOnCreateResourcesCallback.onCreateResourcesFinished();\n    }\n    @Override\n    public void onCreateScene(OnCreateSceneCallback \n        pOnCreateSceneCallback) {\n      Scene mScene = new Scene();\n      mScene.setBackground(new Background(0.9f,0.9f,0.9f));\n      pOnCreateSceneCallback.onCreateSceneFinished(mScene);\n    }\n    @Override\n    public void onPopulateScene(Scene pScene, \n        OnPopulateSceneCallback pOnPopulateSceneCallback) {\n      pOnPopulateSceneCallback.onPopulateSceneFinished();\n    }\n    ```", "```kt\n    BitmapTextureAtlas texturedMeshT = new BitmapTextureAtlas(\n      this.getTextureManager(), 512, 128, \n      TextureOptions.REPEATING_BILINEAR);\n    ITextureRegion texturedMeshTR = \n      BitmapTextureAtlasTextureRegionFactory.\n      createFromAsset(texturedMeshT, this, \"gfx/dirt.png\", 0, 0);\n    texturedMeshT.load();\n    float[] meshTriangleVertices = {\n        24.633111f,37.7835047f,-0.00898f,113.0324447f,\n        -24.610162f,37.7835047f,0.00387f,-37.7900953f,\n        -103.56176f,37.7901047f,103.56176f,37.7795047f,\n        0.00387f,-37.7900953f,-39.814736f,-8.7311953f,\n        -64.007044f,-83.9561953f,64.00771f,-83.9621953f,\n        39.862562f,-8.7038953f,0.00387f,-37.7900953f};\n    float[] meshBufferData = new float[TexturedMesh.VERTEX_SIZE * \n      (meshTriangleVertices.length/2)];\n    for( int i = 0; i < meshTriangleVertices.length/2; i++) {\n      meshBufferData[(i * TexturedMesh.VERTEX_SIZE) + \n        TexturedMesh.VERTEX_INDEX_X] = \n        meshTriangleVertices[i*2];\n      meshBufferData[(i * TexturedMesh.VERTEX_SIZE) + \n        TexturedMesh.VERTEX_INDEX_Y] = \n        meshTriangleVertices[i*2+1];\n    }\n    TexturedMesh starTexturedMesh = new TexturedMesh(400f, 225f, \n      meshBufferData, 12, DrawMode.TRIANGLES, texturedMeshTR, \n      this.getVertexBufferObjectManager());\n    pScene.attachChild(starTexturedMesh);\n    ```", "```kt\n    @Override\n    public EngineOptions onCreateEngineOptions() {\n      EngineOptions engineOptions = new EngineOptions(true, \n        ScreenOrientation.LANDSCAPE_SENSOR, \n        new FillResolutionPolicy(), \n        new Camera(0, 0, 800, 480))\n        .setWakeLockOptions(WakeLockOptions.SCREEN_ON);\n      engineOptions.getRenderOptions().setDithering(true);\n      return engineOptions;\n    }\n    @Override\n    public void onCreateResources(OnCreateResourcesCallback \n        pOnCreateResourcesCallback) {\n      pOnCreateResourcesCallback.onCreateResourcesFinished();\n    }\n    @Override\n    public void onCreateScene(OnCreateSceneCallback \n        pOnCreateSceneCallback) {\n      Scene mScene = new Scene();\n      mScene.setBackground(new Background(0.8f,0.8f,0.8f));\n      pOnCreateSceneCallback.onCreateSceneFinished(mScene);\n    }\n    @Override\n    public void onPopulateScene(Scene pScene, OnPopulateSceneCallback \n        pOnPopulateSceneCallback) {\n      pScene.setOnSceneTouchListener(this);\n      pOnPopulateSceneCallback.onPopulateSceneFinished();\n    }\n    @Override\n    public boolean onSceneTouchEvent(Scene pScene, \n        TouchEvent pSceneTouchEvent) {\n      return true;\n    }\n    ```", "```kt\n    Static final float CHARACTER_START_X = 400f;\n    static final float CHARACTER_START_Y = 128f;\n    static final float SHADOW_OFFSET_X = 0f;\n    static final float SHADOW_OFFSET_Y = -64f;\n    static final float SHADOW_MAX_ALPHA = 0.75f;\n    static final float SHADOW_MIN_ALPHA = 0.1f;\n    static final float SHADOW_MAX_ALPHA_HEIGHT = 200f;\n    static final float SHADOW_MIN_ALPHA_HEIGHT = 0f;\n    static final float SHADOW_START_X = CHARACTER_START_X + SHADOW_OFFSET_X;\n    static final float SHADOW_START_Y = CHARACTER_START_Y + SHADOW_OFFSET_Y;\n    static final float CHARACTER_SHADOW_Y_DIFFERENCE = \n      CHARACTER_START_Y - SHADOW_START_Y;\n    static final float SHADOW_ALPHA_HEIGHT_DIFFERENCE = \n      SHADOW_MAX_ALPHA_HEIGHT - SHADOW_MIN_ALPHA_HEIGHT;\n    static final float SHADOW_ALPHA_DIFFERENCE = \n      SHADOW_MAX_ALPHA - SHADOW_MIN_ALPHA;\n    Sprite shadowSprite;\n    Sprite characterSprite;\n    ```", "```kt\n    public void updateShadowAlpha() {\n      shadowSprite.setAlpha(MathUtils.bringToBounds(\n        SHADOW_MIN_ALPHA, SHADOW_MAX_ALPHA, \n        SHADOW_MAX_ALPHA - ((((characterSprite.getY()-\n        CHARACTER_SHADOW_Y_DIFFERENCE)-SHADOW_START_Y) / \n        SHADOW_ALPHA_HEIGHT_DIFFERENCE) * \n        SHADOW_ALPHA_DIFFERENCE)));\n    }\n    ```", "```kt\n    if(pSceneTouchEvent.isActionDown() || \n        pSceneTouchEvent.isActionMove()) {\n      characterSprite.setPosition(\n        pSceneTouchEvent.getX(), \n        Math.max(pSceneTouchEvent.getY(), \n          CHARACTER_START_Y));\n    }\n    ```", "```kt\n    BitmapTextureAtlas characterTexture = \n      new BitmapTextureAtlas(this.getTextureManager(), 128, 256, \n        TextureOptions.BILINEAR);\n    TextureRegion characterTextureRegion = \n      BitmapTextureAtlasTextureRegionFactory.createFromAsset(\n        characterTexture, this, \"gfx/character.png\", 0, 0);\n    characterTexture.load();\n    BitmapTextureAtlas shadowTexture = \n      new BitmapTextureAtlas(this.getTextureManager(), 256, 128, \n        TextureOptions.BILINEAR);\n    TextureRegion shadowTextureRegion = \n      BitmapTextureAtlasTextureRegionFactory.createFromAsset(\n        shadowTexture, this, \"gfx/shadow.png\", 0, 0);\n    shadowTexture.load();\n    shadowSprite = new Sprite(SHADOW_START_X, SHADOW_START_Y, \n      shadowTextureRegion,this.getVertexBufferObjectManager());\n    characterSprite = new Sprite(CHARACTER_START_X, CHARACTER_START_Y, \n      characterTextureRegion,this.getVertexBufferObjectManager()) \n      {\n      @Override\n      public void setPosition(final float pX, final float pY) {\n        super.setPosition(pX, pY);\n        shadowSprite.setPosition(\n          pX + SHADOW_OFFSET_X, shadowSprite.getY());\n        updateShadowAlpha();\n      }\n    };\n    pScene.attachChild(shadowSprite);\n    pScene.attachChild(characterSprite);\n    updateShadowAlpha();\n    ```", "```kt\n    @Override\n    public Engine onCreateEngine(final EngineOptions pEngineOptions) {\n      return new FixedStepEngine(pEngineOptions, 60);\n    }\n    @Override\n    public EngineOptions onCreateEngineOptions() {\n      return new EngineOptions(true, \n        ScreenOrientation.LANDSCAPE_SENSOR, \n        new FillResolutionPolicy(), \n        new Camera(0, 0, 800, 480)\n        ).setWakeLockOptions(WakeLockOptions.SCREEN_ON);\n    }\n    @Override\n    public void onCreateResources(OnCreateResourcesCallback \n        pOnCreateResourcesCallback) {\n      pOnCreateResourcesCallback.onCreateResourcesFinished();\n    }\n    @Override\n    public void onCreateScene(OnCreateSceneCallback \n        pOnCreateSceneCallback) {\n      Scene mScene = new Scene();\n      mScene.setBackground(new Background(0.9f,0.9f,0.9f));\n      pOnCreateSceneCallback.onCreateSceneFinished(mScene);\n    }\n    @Override\n    public void onPopulateScene(Scene pScene, OnPopulateSceneCallback \n        pOnPopulateSceneCallback) {\n      pOnPopulateSceneCallback.onPopulateSceneFinished();\n    }\n    ```", "```kt\n    FixedStepPhysicsWorld mPhysicsWorld = \n      new FixedStepPhysicsWorld(60, \n      new Vector2(0,-SensorManager.GRAVITY_EARTH*2f), \n      false, 8, 3); \n    pScene.registerUpdateHandler(mPhysicsWorld);\n    Rectangle platformRect = new Rectangle(400f, 200f, 250f, 20f, \n      this.getVertexBufferObjectManager());\n    platformRect.setColor(0f, 0f, 0f);\n    final FixtureDef platformFixtureDef = \n      PhysicsFactory.createFixtureDef(20f, 0f, 1f);\n    final Body platformBody = PhysicsFactory.createBoxBody( \n      mPhysicsWorld, platformRect, BodyType.KinematicBody, \n      platformFixtureDef);\n    mPhysicsWorld.registerPhysicsConnector(\n      new PhysicsConnector(platformRect, platformBody));\n    pScene.attachChild(platformRect);\n    float platformRelativeMinX = -200f;\n    float platformRelativeMaxX = 200f;\n    final float platformVelocity = 3f;\n    final float platformMinXWorldCoords = \n      (platformRect.getX() + platformRelativeMinX) / \n      PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT;\n    final float platformMaxXWorldCoords = \n      (platformRect.getX() + platformRelativeMaxX) / \n      PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT;\n    platformBody.setLinearVelocity(platformVelocity, 0f);\n    ```", "```kt\n    pScene.registerUpdateHandler(new IUpdateHandler() {\n      @Override\n      public void onUpdate(float pSecondsElapsed) {\n        if(platformBody.getWorldCenter().x > \n            platformMaxXWorldCoords) {\n          platformBody.setTransform(\n            platformMaxXWorldCoords,\n            platformBody.getWorldCenter().y,\n            platformBody.getAngle());\n          platformBody.setLinearVelocity(\n            -platformVelocity, 0f);\n        } else if(platformBody.getWorldCenter().x < \n            platformMinXWorldCoords) {\n          platformBody.setTransform(\n            platformMinXWorldCoords,\n            platformBody.getWorldCenter().y,\n            platformBody.getAngle());\n          platformBody.setLinearVelocity(\n            platformVelocity, 0f);\n        }\n      }\n      @Override\n      public void reset() {}\n    });\n    ```", "```kt\n    Rectangle boxRect = new Rectangle(400f, 240f, 60f, 60f, \n      this.getVertexBufferObjectManager());\n    boxRect.setColor(0.2f, 0.2f, 0.2f);\n    FixtureDef boxFixtureDef = \n      PhysicsFactory.createFixtureDef(200f, 0f, 1f);\n    mPhysicsWorld.registerPhysicsConnector(\n      new PhysicsConnector(boxRect,\n        PhysicsFactory.createBoxBody( mPhysicsWorld, boxRect, \n        BodyType.DynamicBody, boxFixtureDef)));\n    pScene.attachChild(boxRect);\n    ```", "```kt\n    @Override\n    public Engine onCreateEngine(final EngineOptions pEngineOptions) {\n      return new FixedStepEngine(pEngineOptions, 60);\n    }\n    @Override\n    public EngineOptions onCreateEngineOptions() {\n      return new EngineOptions(true, \n        ScreenOrientation.LANDSCAPE_SENSOR,\n        new FillResolutionPolicy(), \n        new Camera(0, 0, 800, 480))\n        .setWakeLockOptions(WakeLockOptions.SCREEN_ON);\n    }\n    @Override\n    public void onCreateResources(OnCreateResourcesCallback \n        pOnCreateResourcesCallback) {\n      pOnCreateResourcesCallback.onCreateResourcesFinished();\n    }\n    @Override\n    public void onCreateScene(OnCreateSceneCallback \n        pOnCreateSceneCallback) {\n      Scene mScene = new Scene();\n      mScene.setBackground(new Background(0.9f,0.9f,0.9f));\n      pOnCreateSceneCallback.onCreateSceneFinished(mScene);\n    }\n    @Override\n    public void onPopulateScene(Scene pScene, OnPopulateSceneCallback \n        pOnPopulateSceneCallback) {\n      pOnPopulateSceneCallback.onPopulateSceneFinished();\n    }\n    ```", "```kt\n    public void createBridge(Body pGroundBody,\n        final float[] pLeftHingeAnchorPoint, \n        final float pRightHingeAnchorPointX, \n        final int pNumSegments, \n        final float pSegmentsWidth, \n        final float pSegmentsHeight,\n        final float pSegmentDensity, \n        final float pSegmentElasticity,\n        final float pSegmentFriction, \n        IEntity pScene, PhysicsWorld pPhysicsWorld, \n        VertexBufferObjectManager \n          pVertexBufferObjectManager) {\n      final Rectangle[] BridgeSegments = \n        new Rectangle[pNumSegments];\n      final Body[] BridgeSegmentsBodies = new Body[pNumSegments];\n      final FixtureDef BridgeSegmentFixtureDef =\n        PhysicsFactory.createFixtureDef(\n        pSegmentDensity, pSegmentElasticity, \n        pSegmentFriction);\n      final float BridgeWidthConstant = pRightHingeAnchorPointX – \n        pLeftHingeAnchorPoint[0] + pSegmentsWidth;\n      final float BridgeSegmentSpacing = (\n        BridgeWidthConstant / (pNumSegments+1) – \n        pSegmentsWidth/2f);\n      for(int i = 0; i < pNumSegments; i++) {\n\n      }\n    }\n    ```", "```kt\n    BridgeSegments[i] = new Rectangle(\n      ((BridgeWidthConstant / (pNumSegments+1))*i) + \n        pLeftHingeAnchorPoint[0] + BridgeSegmentSpacing, \n      pLeftHingeAnchorPoint[1]-pSegmentsHeight/2f,\n      pSegmentsWidth, pSegmentsHeight, \n      pVertexBufferObjectManager);\n    BridgeSegments[i].setColor(0.97f, 0.75f, 0.54f);\n    pScene.attachChild(BridgeSegments[i]);\n    BridgeSegmentsBodies[i] = PhysicsFactory.createBoxBody(\n      pPhysicsWorld, BridgeSegments[i], BodyType.DynamicBody, \n      BridgeSegmentFixtureDef);\n    BridgeSegmentsBodies[i].setLinearDamping(1f);\n    pPhysicsWorld.registerPhysicsConnector(\n      new PhysicsConnector(BridgeSegments[i], \n        BridgeSegmentsBodies[i]));\n    final RevoluteJointDef revoluteJointDef = new RevoluteJointDef();\n    if(i==0) {\n      Vector2 anchorPoint = new Vector2(\n        BridgeSegmentsBodies[i].getWorldCenter().x – \n          (BridgeSegmentSpacing/2 + pSegmentsWidth/2)/ \n          PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT, \n        BridgeSegmentsBodies[i].getWorldCenter().y);\n      revoluteJointDef.initialize(pGroundBody, \n        BridgeSegmentsBodies[i], anchorPoint);\n    } else {\n      Vector2 anchorPoint = new Vector2(\n        (BridgeSegmentsBodies[i].getWorldCenter().x + \n          BridgeSegmentsBodies[i-1]\n          .getWorldCenter().x)/2, \n        BridgeSegmentsBodies[i].getWorldCenter().y);\n      revoluteJointDef.initialize(BridgeSegmentsBodies[i-1], \n        BridgeSegmentsBodies[i], anchorPoint);\n    }\n    pPhysicsWorld.createJoint(revoluteJointDef);\n    if(i==pNumSegments-1) {\n      Vector2 anchorPoint = new Vector2(BridgeSegmentsBodies[i].getWorldCenter().x + (BridgeSegmentSpacing/2 + pSegmentsWidth/2)/PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT, BridgeSegmentsBodies[i].getWorldCenter().y);\n      revoluteJointDef.initialize(pGroundBody, BridgeSegmentsBodies[i], anchorPoint);\n      pPhysicsWorld.createJoint(revoluteJointDef);\n    }\n    ```", "```kt\n    final FixedStepPhysicsWorld mPhysicsWorld = new FixedStepPhysicsWorld(60, new Vector2(0,-SensorManager.GRAVITY_EARTH), false, 8, 3);\n    pScene.registerUpdateHandler(mPhysicsWorld);\n\n    FixtureDef groundFixtureDef = PhysicsFactory.createFixtureDef(0f, 0f, 0f);\n    Body groundBody = PhysicsFactory.createBoxBody(mPhysicsWorld, 0f, 0f, 0f, 0f, BodyType.StaticBody, groundFixtureDef);\n\n    createBridge(groundBody, new float[] {0f,240f}, 800f, 16, 40f, 10f, 4f, 0.1f, 0.5f, pScene, mPhysicsWorld, this.getVertexBufferObjectManager());\n\n    Rectangle boxRect = new Rectangle(100f,400f,50f,50f,this.getVertexBufferObjectManager());\n    FixtureDef boxFixtureDef = PhysicsFactory.createFixtureDef(25f, 0.5f, 0.5f);\n    mPhysicsWorld.registerPhysicsConnector(new PhysicsConnector(boxRect, PhysicsFactory.createBoxBody(mPhysicsWorld, boxRect, BodyType.DynamicBody, boxFixtureDef)));\n    pScene.attachChild(boxRect);\n    ```"]