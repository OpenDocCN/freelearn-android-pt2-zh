- en: Chapter 11. Implementing In-App Purchases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In-App Purchase is an optional feature that developers can use to embed a
    store directly within an app. Sometimes, you may want to extend some features
    in your current game to keep your consumers interested in playing. Here''s your
    chance, and possibly, more revenue in your pocket!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter is only concerned with In-App Purchases in the Apple iTunes Store
    for the iOS platform. Android developers who want to implement In-App Purchases
    in their apps can refer to for reference. The set up for In-App Purchase is done
    in a similar fashion for iOS and Android. There are, however, some differences
    that need to be set up in your `build.settings` file and code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application interface used here is frequently updated. However, you will
    be able to perform all the steps irrespective of the interface you're using.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumable, nonconsumable, and subscription purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring purchased items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing Corona's store module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and testing In-App Purchases on a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready, set, go!
  prefs: []
  type: TYPE_NORMAL
- en: The wonders of In-App Purchase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of implementing In-App Purchase is to add an in-app payment functionality
    to collect payment for enhanced functionality or additional content usable in
    your game. The following are options of incorporating this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: A game that offers new level packs to play outside the default content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A freemium game that allows you to purchase virtual currency to create or build
    new assets during game play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding additional characters or special power ups to enhance game elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some examples that can be implemented with In-App Purchases.
  prefs: []
  type: TYPE_NORMAL
- en: In-App Purchases allow users to purchase additional content within an application.
    The App Store manages transaction information only. Developers cannot use the
    App Store to deliver content. So, either you bundle content with your app when
    you ship it (it will be unlocked on purchase), or you have to work out your own
    system to download the data, if you wish to deliver content.
  prefs: []
  type: TYPE_NORMAL
- en: Types of In-App Purchases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several In-App Purchase types that you can apply in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more information on In-App Purchases on the Apple website at [https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html](https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumable**: These are products that must be purchased each time the user
    needs that item. They''re typically one-time services, such as money in an app
    where you need to pay for supplies to build structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonconsumable**: These are products that only need to be purchased once by
    the user. These could be additional level packs in a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto-renewing subscriptions**: These are products that allow the user to
    purchase in-app content for a set duration of time. An example of an auto-renewable
    subscription would be a magazine or newspaper that takes advantage of the auto-renewing
    functionality built into iOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free subscriptions**: These are used to put free subscription content in
    Newsstand. Once a user signs up for a free subscription, it will be available
    on all devices associated with that user''s Apple ID. Note that free subscriptions
    do not expire and can only be offered in Newsstand-enabled apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-renewing subscriptions**: Similar to auto-renewable subscriptions, these
    are non-renewing subscriptions that require a user to renew each time the subscription
    is due to expire. Your app must contain code that recognizes when the expiration
    occurs. It must also prompt the user to purchase a new subscription. An auto-renewable
    subscription eliminates these steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corona's store module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying In-App Purchases in your application can be a little mind-boggling
    and tedious process. Integrating it with Corona requires calling the store module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The store module is already incorporated to the Corona API, similar to Facebook
    and Game Network. You can find more information on Corona's store module at [http://docs.coronalabs.com/daily/guide/monetization/IAP/index.html](http://docs.coronalabs.com/daily/guide/monetization/IAP/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: store.init()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `store.init()` function must be called when handling store transactions
    to your app. It activates In-App Purchases and allows you to receive callbacks
    with the listener function you specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only parameter here is `listener`. It's a function that handles transaction
    callback events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following blocks determine the transaction states that can occur during
    an In-App Purchase. The four different states are purchased, restored, cancelled,
    and failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: event.transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `event.transaction` object contains the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transaction object supports the following read-only properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"state"`: This is a string containing the state of the transaction. Valid
    values are `"purchased"`, `"restored"`, `"cancelled"`, and `"failed"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"productIdentifier"`: This is the product identifier associated with the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"receipt"`: This is a unique receipt returned from the App Store. It is returned
    as a hexadecimal string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"signature"`: This is a string used to verify the purchase. For Google Play,
    it is returned by `"inapp_signature"`. In iOS, it returns `nil`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"identifier"`: This is a unique transaction identifier returned from the App
    Store. It is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"date"`: This is the date the transaction occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"originalReceipt"`: This is a unique receipt returned from the App Store from
    the original purchase attempt. It is mostly relevant in the case of a restore.
    It is returned as a hexadecimal string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"originalIdentifier"`: This is a unique transaction identifier returned from
    the Store from the original purchase attempt. This is mostly relevant in the case
    of a restore. It is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"originalDate"`: This is the date of the original transaction. It is mostly
    relevant in the case of a restore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"errorType"`: This is the type of error that occurred when the state is `"failed"`
    (a string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"errorString"`: This is a descriptive error message of what went wrong in
    the `"failed"` case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: store.loadProducts()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `store.loadProducts()` function retrieves information about items available
    for sale. This includes the price of each item, a name, and a description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Its parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrayOfProductIdentifiers`: This is an array with each element containing
    a string of the product ID of the In-App product you want to know about'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listener`: This is a callback function that is invoked when the store finishes
    retrieving the product information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following block displays the list of products that are available in the
    app. Information about the product can be retrieved from the `loadProductsCallback()`
    function and determines whether it is valid or invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: event.products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a requested list of products is returned by `store.loadProducts()`, the
    array of product information can be accessed through the `event.products` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Product information, such as title, description, price, and the product identifier,
    is contained in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entry in the `event.products` array supports the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This is the localized name of the item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This is the localized description of the item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price`: This is the price of an item (as a number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`productIdentifier`: This is the product identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: event.invalidProducts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `store.loadProducts()` returns its requested list of products, any products
    you requested that are not available for sale will be returned in an array. You
    can access the array of invalid products through the `event.invalidProducts` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a Lua array containing the product identifier string requested from
    `store.loadProducts()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: store.canMakePurchases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `store.canMakePurchases` function returns true if purchases are allowed,
    and false otherwise. Corona's API can check whether purchasing is possible. iOS
    devices provide a setting that disables purchasing. This can be used to avoid
    purchasing apps accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: store.purchase()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `store.purchase()` function initiates a purchase transaction on a provided
    list of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will send purchase requests to the store. The listener specified
    in `store.init()` will be invoked when the store finishes processing the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Its only parameter is `arrayOfProducts`, an array specifying the products you
    want to buy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: store.finishTransaction()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function notifies the App Store that a transaction is complete.
  prefs: []
  type: TYPE_NORMAL
- en: After you finish handling a transaction, you must call `store.finishTransaction()`
    on the transaction object. If you don't do this, the App Store will think your
    transaction was interrupted and will attempt to resume it on the next application
    launch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transaction: The `transaction` object belonging to the transaction you want
    to mark as finished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: store.restore()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any previously purchased items that have been wiped clean from a device or
    upgraded to a new device can be restored on the user''s account without paying
    for the product again. The `store.restore()` API initiates this process. Transactions
    can be restored by the `transactionCallback` listener, which is registered with
    `store.init()`. The transaction state will be `"restored"` and your app may then
    make use of the `"originalReceipt"`, `"originalIdentifier"`, and `"originalDate"`
    fields of the transaction object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The block will run through the `transactionCallback()` function and determine
    whether a product has been previously purchased from the application. If the result
    is true, `store.restore()` will initiate the process of retrieving the product
    without asking the user to pay for it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create an In-App Purchase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before reading on, make sure you know how to create an App ID and Distribution
    Provisioning Profile from the iOS Provisioning Portal. Also, make sure you know
    how to manage new applications in iTunes Connect. If you''re unsure, refer to
    [Chapter 10](ch10.html "Chapter 10. Optimizing, Testing, and Shipping Your Games"),
    *Optimizing, Testing, and Shipping Your Games*, for more information. Here are
    the things that need to be ready in your app before creating an In-App Purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: A Distribution Certificate already made for your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An explicit App ID for your application, for example, `com.companyname.appname`.
    Do not substitute a wildcard character (asterisk: "*"). The Bundle ID needs to
    be completely unique in order to use the In-App Purchase function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ad hoc Distribution Provisioning Profile (used to test In-App Purchases).
    When you're ready to submit an app with In-App Purchase, an App Store Distribution
    Provisioning Profile is required.![Create an In-App Purchase](img/9343OT_11_01.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application information must be set up in iTunes Connect. You do not need
    to get your binary uploaded to create or test In-App Purchases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that you have an iOS Paid Applications contract in effect with Apple.
    If you don't, you'll need to request it in **Contracts, Tax, and Banking** located
    on the iTunes Connect home page. You will need to provide your banking and tax
    information in order to offer In-App Purchases in your apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – creating the In-App Purchase in iTunes Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be implementing an In-App Purchase through iTunes Connect and create
    a scenario in a sample application that will call a transaction. Let''s create
    the Product ID that will be used in our In-App Purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to iTunes Connect. On the home page, select **Manage Your Applications**.
    Select the application you plan to add an In-App Purchase to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you're on the app summary page, click on the **Manage In-App Purchases**
    button and then click on the **Create New** button in the top-left corner.![Time
    for action – creating the In-App Purchase in iTunes Connect](img/9343OT_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be brought to a page that shows you a summary of the types of In-App
    Purchases that you can create. For this example, **Non-Consumable** is selected.
    We'll be creating a product that needs to be purchased only once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next page is the area where you fill in the information about the product.
    The information applies to consumable, nonconsumable, and non-renewing subscription
    In-App Purchases. Fill the **Reference Name** and **Product ID** fields for your
    product. The Product ID needs to be a unique identifier and can be any alphanumeric
    sequence of letters and numbers (for example, `com.companyname.appname.productid`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Auto-renewing subscriptions require you to generate a shared secret. If you
    are to use auto-renewing subscriptions in your app, then on the **Manage in-App
    Purchases** page, click on the **View or generate a shared secret** link. You
    will be brought to a page to generate the shared secret. Click on the **Generate**
    button. The shared secret will display a string of 32 randomly generated alphanumeric
    characters. When you choose auto-renewing subscriptions, the difference from the
    other In-App Purchase types is that you have to choose the duration between auto-renewals
    of your product. For more information on auto-renewing subscriptions, go to [http://developer.apple.com/library/ios/iTunesConnectGuide](http://developer.apple.com/library/ios/iTunesConnectGuide).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – creating the In-App Purchase in iTunes Connect](img/9343OT_11_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the **Add Language** button. Select the language that will be used
    for the In-App Purchase. Add a display name for your product and a short description
    about it. When you're done, click on the **Save** button.![Time for action – creating
    the In-App Purchase in iTunes Connect](img/9343OT_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Pricing and Availability**, ensure that **Yes** is selected for **Cleared
    for Sale**. In the **Price Tier** drop-down menu, select the price you plan to
    sell your In-App Purchase for. In this example, **Tier 1** is selected. In **Screenshot
    for Review**, you'll need to upload a screenshot of your In-App Purchase. If you're
    testing on an ad hoc build, the screenshot is not necessary. Once you're ready
    for distribution, the screenshot is required so that the In-App Purchase can be
    reviewed upon submittal. Click on the **Save** button when done.![Time for action
    – creating the In-App Purchase in iTunes Connect](img/9343OT_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a summary of the In-App Purchase that you created on the next page.
    Click on the **Done** button if all of the information looks correct.![Time for
    action – creating the In-App Purchase in iTunes Connect](img/9343OT_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a new In-App Purchase is a very simple process. The information contained
    in the Product ID is what will be called upon during a transaction. Managing the
    type of In-App Purchase entirely depends on what type of product you want to sell
    in your game. This example demonstrates the purpose of taking a nonconsumable
    product that represents purchasing/unlocking a new level in a game. This is a
    common scenario for users who to want to sell level packs.
  prefs: []
  type: TYPE_NORMAL
- en: Your application does not have to be completed to test In-App Purchases. All
    that is required is to have your application information set up in iTunes Connect
    so that you can manage the features of In-App Purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using the Corona store module to create an In-App Purchase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have set up our Product ID for our In-App Purchase in iTunes Connect,
    we can implement it in our app to purchase the product we''re going to sell. A
    sample menu app of Breakout was created to demonstrate how to purchase levels
    within an application. The app contains two levels in the level select screen.
    The first is available by default. The second is locked and can only be unlocked
    by purchasing it for $0.99\. We''re going create a level select screen so that
    it acts in that manner:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chapter 11` folder, copy the `Breakout In-App Purchase Demo` project
    folder to your desktop. You can download the project files accompanying this book
    from the Packt Publishing website. You will notice that the configuration, libraries,
    assets, and `.lua` files needed are included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `levelselect.lua` file and save it to the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the scene with the following variables and saving/loading functions.
    The most important variable of all is `local store = require("store")`, which
    calls the store module for In-App Purchases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `create()` event and remove the `"mainmenu"`, `"level1"`, and `"level2"`
    scenes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the `show()` event and an array that contains a string of **Product
    ID** set as an In-App Purchase in iTunes Connect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a local blank table for `validProducts` and `invalidProducts`. Create a
    local function called `unpackValidProducts()` that checks valid and invalid Product
    IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a local function called `loadProductsCallback()` with an `event` parameter.
    Set up the handler to receive product information with print statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a local function called `transactionCallback()` with an `event` parameter.
    Add several cases of results that are supposed to occur for every `transaction.state`
    event. When the store is done with the transaction, call `store.finishTransaction(event.transaction)`
    before the end of the function. Set up a another local function called `setUpStore()`
    with an `event` parameter to call `store.loadProducts(listOfProducts, loadProductsCallback)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the display objects for the background and level **1** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the level **2** button placement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the local `onBuyLevel2Touch(event)` function and create an `if` statement
    to check `event.phase == ended and level2Unlocked ~= tonumber(loadedLevel2Unlocked)`
    so that the scene changes to `mainmenu.lua`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the same `if` statement, create a local function called `buyLevel2()`
    with a `product` parameter to call the `store.purchase()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `elseif` statement to check when level 2 has been purchased and unlocked,
    once the transaction has been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate the In-App Purchase with `store.init()` and call `transactionCallback()`
    as the parameter. Also call `setupMyStore()` with a timer set at 500 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the **Close** UI button and a local function called `onCloseTouch()`
    with an event parameter. Have the function transition scenes to `loadmainmenu.lua`
    upon release of the **Close** button. Close the `enterScene()` event with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `hide()` and `destroy()` events. Within the `hide()` event, cancel
    the `menuTimer` timer. Add all the event listeners for the scene events and `return
    scene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and run the project in the Corona simulator. When you select the
    **Play** button, you will notice a **1** button and a **Locked** button on the
    level select screen. When you press the **Locked** button, it calls the store
    to make a transaction. You will notice a print statement in the terminal that
    displays what **Product ID** is being referred to for purchase. Full In-App Purchase
    features cannot be tested in the simulator. You will have to create a distribution
    build and upload it on an iOS device to initiate a purchase in the store.![Time
    for action – using the Corona store module to create an In-App Purchase](img/9343OT_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we used the `saveValue()` and `loadValue()` functions from
    BeebeGames Class to implement how our locked level will go from locked to unlocked
    mode using movie clips as buttons. The array in `local listOfProducts` displays
    **Product ID** in a string format. The Product ID in this example needs to be
    a nonconsumable In-App Purchase type and has to be an existing one in iTunes Connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unpackValidProducts()` function checks how many valid and invalid items
    are in the In-App Purchase. The `loadProductsCallback()` function receives the
    product information in the store. The `transactionCallback(event)` function checks
    every state: `"purchased"`, `"restored"`, `"cancelled"`, and `"failed"`. When
    a `"purchased"` state is achieved within the In-App Purchase, the `saveValue()`
    function is called to change the value of `level2.data`. When the transaction
    is completed, `store.finishTransaction(event.transaction)` needs to be called
    to tell the store that you are done with your purchase.'
  prefs: []
  type: TYPE_NORMAL
- en: The `setupMyStore(event)` function calls `store.loadProducts(listOfProducts,
    loadProductsCallback)` and checks the available Product ID (or IDs) in the application.
    The event is handled once `store.init(transactionCallback)` is initialized and
    `setupMyStore()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `onBuyLevel2Touch(event)` function allows us to check when an In-App Purchase
    has been made for the locked level. When the user is able to purchase and when
    they accept the In-App Purchase, the transaction is processed and the value of
    `level2Unlocked` will match that of `tonumber(loadedLevel2Unlocked)`. The `buyLevel2(product)`
    function validates the purchased item with `store.purchase()` once the Product
    ID returns valid.
  prefs: []
  type: TYPE_NORMAL
- en: After the In-App Purchase, the screen transitions to the main menu to allow
    the **Locked** button to change to the level **2** button. Once the button has
    changed to frame 2, level 2 is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – handling multiple Product IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to create an In-App Purchase for one product, try adding
    more than one product to the same application. The scenarios are open ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More levels for purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variety of characters the user can play as if your game has a main character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New background scenes for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you handle new products for your store is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Testing In-App Purchases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would want to ensure that the purchases work correctly. Apple provides a
    sandbox environment that allows you to test your app In-App Purchases. The sandbox
    environment uses the same model as the App Store, but does not process actual
    payments. Transactions return as if payments were processed successfully. It is
    a requirement to test In-App Purchases in a sandbox environment before submitting
    them for a review by Apple.
  prefs: []
  type: TYPE_NORMAL
- en: When testing in the sandbox environment, you'll need to create a separate user
    test account that is different from your current iTunes Connect account. Using
    your current account is not allowed for testing your store in the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: User test accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you're logged in to your iTunes Connect account, you'll have to select
    the **Manage Users** link from the Home page. Select **Test User** on the **Select
    User Type** page. Add a new user and ensure that the test account uses an e-mail
    address that is not associated with any other Apple account. All test accounts
    should only be used in the test environment when testing In-App Purchases. Click
    on the **Save** button when all of the information is filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Once your user test account is created, you'll have to make sure that you've
    signed out of your Apple account in the **Store** settings of your device. This
    will keep non-test accounts from being used when testing In-App Purchases. You're
    only allowed to sign in to your user test account when prompted in the In-App
    Purchase sandbox to test your application. Do not sign in to your test account
    before the application is launched. This will prevent it from invalidating your
    test account.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – testing the In-App Purchase with the Breakout In-App Purchase
    Demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can test an In-App Purchase on an iOS device, make sure that you
    have a test user account in iTunes Connect. Also, make sure that you''ve created
    a distribution build using an ad hoc Distribution Provisioning Profile for the
    app to test In-App Purchase''s features. If you followed all the earlier steps
    in this chapter, testing a purchase through the store will work accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Corona simulator, create a distribution build of the Breakout In-App
    Purchase Demo. Once the build has been compiled, upload the build on your iOS
    device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep your device connected to your machine and launch Xcode. From the toolbar,
    go to **Windows** | **Organizer**. Once you're in **Organizer**, select the device
    that is connected in the **Devices** section and then select **Console**. This
    will allow you to check the console output of your device to catch debug messages
    from your code (that is, print statements) and any application crashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before launching the application, you'll need to select the **Settings** icon
    on your device. Scroll up until you see the **Store** icon and select it.![Time
    for action – testing the In-App Purchase with the Breakout In-App Purchase Demo](img/9343OT_11_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign out of your iTunes Store account if you're logged in, so that you can test
    In-App Purchases in the sandbox environment.![Time for action – testing the In-App
    Purchase with the Breakout In-App Purchase Demo](img/9343OT_11_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the Breakout In-App Purchase Demo from your device. Select the **Play**
    button and then select the **Locked** button. The screen will transition back
    to the main menu, and a window will pop up to confirm your In-App Purchase. Press
    **OK** to continue with the purchase.![Time for action – testing the In-App Purchase
    with the Breakout In-App Purchase Demo](img/9343OT_11_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be greeted with another window to sign in with your Apple ID.
    This is where you will log in with the test user account you created in iTunes
    Connect. Do not sign in with your actual Apple account that was used to log in
    to iTunes Connect.![Time for action – testing the In-App Purchase with the Breakout
    In-App Purchase Demo](img/9343OT_11_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've logged in, select the **Play** button again. You will notice that
    the **2** button has been unlocked. When you select it, you will have access to
    that scene.![Time for action – testing the In-App Purchase with the Breakout In-App
    Purchase Demo](img/9343OT_11_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the app and refer to the console. You will notice the output from the device
    and some familiar print statements from your code. The console log displays the
    Product ID used for the In-App Purchase and informs you whether it is valid and
    whether the transaction is successful.![Time for action – testing the In-App Purchase
    with the Breakout In-App Purchase Demo](img/9343OT_11_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to ensure that the In-App Purchase actually worked, delete the application
    from your device and log out of your user test account. Upload the same build
    on your device—there's no need to create a new one. Launch the application and
    run the In-App Purchase again. Log in using the same user test account. You should
    receive a pop-up window that mentions that you've already purchased the product,
    and asks you whether you want to download it again for free. Receiving a notification
    means your In-App Purchase was successful.![Time for action – testing the In-App
    Purchase with the Breakout In-App Purchase Demo](img/9343OT_11_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to follow the In-App Purchase test steps properly. To make sure
    you're getting accurate results in the sandbox environment, signing out of your
    Apple account from the **Store** settings is the key to this entire process.
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch the application and call the store function by pressing the
    Locked button, you will notice the display name and price of the In-App Purchase.
    It should match with what you created in iTunes Connect, if you have implemented
    it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When you log in by using the test user account you created in iTunes Connect,
    the transaction should go through without any errors, assuming that there are
    no server issues on Apple's side or connection problems on the device. Level 2
    on the level select screen will be unlocked and accessible. Congratulations! You
    have created an In-App Purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – using other In-App Purchase types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Breakout In-App Purchase Demo, we focused more on nonconsumable In-App
    Purchases. Try integrating consumable, auto-renewing, or non-renewing subscriptions
    with your own apps.
  prefs: []
  type: TYPE_NORMAL
- en: Apps that feature consumable products are games that require currency to buy
    or build things in a free-to-play environment. Subscription products can be focused
    towards games that are never-ending and are constantly updated with new levels
    or games that may require an online server to interact in a multiplayer environment.
    See what you can come up with!
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – all about In-App Purchases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What are nonconsumable purchases?
  prefs: []
  type: TYPE_NORMAL
- en: Products that only need to be purchased once by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Products that need to be purchased each time the user needs the item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Products that allow the user to purchase content for a set duration of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A subscription that requires a user to renew each time it expires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What is true about testing In-App Purchases?
  prefs: []
  type: TYPE_NORMAL
- en: You need to be logged in to your account at all times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your Apple account is used to test In-App Purchases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login to your user test account when prompted in In-App Purchase sandbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What type of Provisioning Profile must be used to test In-App Purchases?
  prefs: []
  type: TYPE_NORMAL
- en: Development Provisioning Profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ad Hoc Distribution Provisioning Profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: App Store Distribution Provisioning Profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can finally see the light at the end of the tunnel. By now, you should have
    an idea on how to implement In-App Purchases in your games. It is a very lengthy
    process to organize, set up the code, and test accurate purchases in the sandbox
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following were taught in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up product IDs for In-App Purchases in iTunes Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing purchase items using Corona's store module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding test user accounts in iTunes Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing In-App Purchases on a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grasping the concept of In-App Purchasing can take some time. It is best to
    study the sample code and review the functions pertaining to Corona's store module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check out Apple''s *In-App Purchase Programming Guide* at: [https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf)
    and the In-App Purchases in the API Reference section of Corona Labs site: for
    more references pertaining to this topic.'
  prefs: []
  type: TYPE_NORMAL
- en: After 11 chapters, we have reached the end of this book. You now have obtained
    enough knowledge to create your own applications to sell in the Apple App Store
    or Google Play Store. Hopefully all the information you have acquired has been
    helpful. I look forward to hearing about the games you have developed using Corona
    SDK!
  prefs: []
  type: TYPE_NORMAL
