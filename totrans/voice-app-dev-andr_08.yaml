- en: Chapter 8. Dialogs with Virtual Personal Assistants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you will learn how to design and develop three types of **Virtual
    Personal Assistant** (**VPA**); a conversational companion that can chat about
    a range of everyday topics, a specialist VPA that provides answers to **Frequently
    Asked Questions** (**FAQs**) in the domain of Type 2 diabetes, and a conversational
    companion enhanced with the ability to execute search queries, control device
    apps, and make calls to web services.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have an understanding of what is required
    to develop each type of VPA.
  prefs: []
  type: TYPE_NORMAL
- en: The technology of VPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VPAs are generally able to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with web services to retrieve information and perform transactions;
    either through search queries, by linking to knowledge bases such as Knowledge
    Graph, or by engaging in transactional dialogs as well as launching and managing
    apps on the device, such as contacts, calendar, SMS, or clock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engaging in conversation with the user about random topics, for example, answering
    questions such as *where do you live?*, *how old are you?*, *what languages do
    you speak?*, or *what sort of music do you like?*. The VPA is expected to provide
    some sort of response to every question so as to be able to keep the conversation
    going even if it does not have a proper answer to the question.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VoiceLaunch` app presented in [Chapter 4](ch04.html "Chapter 4. Simple
    Voice Interactions"), *Simple Voice Interactions* shows how to launch an app on
    a device, while the `MusicBrain` app presented in [Chapter 5](ch05.html "Chapter 5. Form-filling
    Dialogs"), *Form-filling Dialogs* shows how to implement a transactional dialog
    using form-filling. The multimodal app presented in [Chapter 7](ch07.html "Chapter 7. Multilingual
    and Multimodal Dialogs"), *Multilingual and Multimodal Dialogs* showed unimodal
    as well as multimodal dialogs. However, these apps perform a single task, whereas
    a VPA performs a range of different tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge for a VPA is to determine from the user's utterance what task
    the user is requesting. Looking at the data flow in the following figure, we know
    how to use speech recognition to determine the words that the user has spoken
    ([Chapter 3](ch03.html "Chapter 3. Speech Recognition"), *Speech Recognition*),
    and how to give a response, given a string of words to speak ([Chapter 2](ch02.html
    "Chapter 2. Text-to-Speech Synthesis"), *Text-To-Speech Synthesis*). Now, we need
    to figure out the intention behind the words spoken by the user and put together
    the words to be spoken by the TTS. Determining the user's intention can be done
    using techniques from spoken language understanding, as shown in [Chapter 6](ch06.html
    "Chapter 6. Grammars for Dialog"), *Grammars for Dialog*, although in this chapter
    we will look at an alternative technique. Providing the words to be spoken by
    the TTS will be explained when we look at how responses are generated by the dialog
    management component.
  prefs: []
  type: TYPE_NORMAL
- en: '![The technology of VPA](img/5297_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Determining the user's intention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine the following user inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I would like to book a flight to London.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What''s the weather forecast for tomorrow?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Set my alarm for 7.30 tomorrow.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What sort of a computer are you?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose we wish to map these inputs on to the four functions listed in the dialog
    management box in the previous figure. How can we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to use a statistical classification system to classify open-ended
    user input into a fixed set of classes, as illustrated in the statistical grammar
    in [Chapter 6](ch06.html "Chapter 6. Grammars for Dialog"), *Grammars for Dialog*.
    This is the approach taken in large scale commercial systems. For example, a troubleshooting
    application might take inputs such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I can''t access my e-mail*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I can''t get on to the Internet*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*There''s a little icon that says no Internet access*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although these inputs are phrased differently, they could all be classified
    as problems to do with Internet connectivity. Creating such a statistical classification
    system involves collecting a large set of relevant utterances and determining
    a fixed set of classes. Features such as the occurrence of particular keywords
    or phrases are identified that can predict the assignment of an utterance to a
    particular class and machine learning techniques would be employed to train the
    classifier. For example, the occurrence of phrases such as *access my e-mail*
    or *get on the Internet* could be taken as features that indicate the class *problem
    with Internet connection*.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of this approach are robustness and coverage. As the matching
    is statistical, it is possible to classify input that might not match a category
    exactly. Thus, ungrammatical input or input that can be expressed in different
    ways can still be assigned to a class. Handcrafting a grammar to classify such
    open-ended input would be a daunting task as in this case, the matching would
    have to be exact.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of statistical text classification is that a large sample of utterances
    is required to train the system since there are so many different ways to say
    something. In a large system, tens of thousands of typical utterances might need
    to be collected and annotated to provide adequate coverage. This is an expensive
    process; although once a system has been trained, it will generally produce accurate
    results.
  prefs: []
  type: TYPE_NORMAL
- en: A second approach, which would be feasible in situations where the input is
    more constrained and predictable, would be to write grammars to perform the classification,
    using the techniques illustrated in [Chapter 6](ch06.html "Chapter 6. Grammars
    for Dialog"), *Grammars for Dialog*, and setting the output of the parsing to
    be an assignment to one of the relevant classes along with associated values.
    For example, in the case of a command to set an alarm, assigning the output to
    the device's alarm function and extracting the time and date. However, the problem
    of coverage also arises with handcrafted grammars and additional rules would have
    to be continually added to deal with inputs that cannot be parsed with the existing
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: A third approach, is to match the input against predefined patterns. This approach
    has been deployed successfully in the implementation of a number of commercially
    available chatbots and VPAs. The downside is that initially a large number of
    patterns have to be created to match all the possible inputs, with the same problem
    of potential lack of coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Making an appropriate response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app''s response to the user''s input varies according to the user intention
    that has been identified, which can be broadly classified into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: For form-filling dialogs, the dialog has to be initiated and several rounds
    of system-user interaction may be required to fill the necessary slots in the
    dialog's frame, as shown in [Chapter 5](ch05.html "Chapter 5. Form-filling Dialogs"),
    *Form-filling Dialogs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of web services, the response will be a call to the web service
    involved and some text will be extracted to be spoken by the TTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For tasks involving the activation of features on the device, such as placing
    a call or setting an alarm, the command is executed and some text is extracted
    to be spoken by the TTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the task is conversation, the VPA provides a conversational response
    which is generated by the Pandorabots chatbot system for the apps presented in
    this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pandorabots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandorabots is a free open source-based web service that enables developers
    to create and host chatbots on the web (see [http://www.pandorabots.com/](http://www.pandorabots.com/)).
    Currently, more than 221,000 chatbots are hosted, covering a range of languages.
    There is also a premium service for commercial development. Many VPAs on mobile
    devices have been created using Pandorabots. These include Voice Actions by Pannous
    (also known as Jeannie), Skyvi, Iris, and Pandorabot's own CallMom app. CallMom
    can perform the same sorts of tasks as other VPAs, but also includes a learning
    feature so that it can learn personal preferences and contacts, and can be taught
    to correct speech recognition errors.
  prefs: []
  type: TYPE_NORMAL
- en: ALICE 2.0 is one of the chatbot personalities available in the `CallMom` app.
    Its predecessor ALICE, originally developed in 1995 by Dr. Richard S. Wallace,
    has won numerous awards in chatbot competitions, including the Loebner prize that
    is awarded to the chatbot, which in an annual competition is considered by judges
    to be the most human-like. Three of the four finalists in the 2013 Loebner competition
    used the Pandorabots technology. Much of the knowledge in the original ALICE was
    hard-wired and has now become obsolete. For example, the response to *Who is the
    Prime Minister of England?* has not been updated from the original response *Tony
    Blair*. ALICE 2.0 overcomes these shortcomings by obtaining its factual information
    from external services, as do other VPAs such as Siri. More information about
    Pandorabots and chatbots in general can be found at the Pandorabots website and
    at the ALICE A.I. Foundation site ([www.alicebot.org](http://www.alicebot.org)),
    founded by Wallace to promote the development of **Artificial Intelligence Markup
    Language** (**AIML**) and chatbot technology in general.
  prefs: []
  type: TYPE_NORMAL
- en: AIML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AIML is an XML-based language used to specify the conversational behaviors
    of chatbots. The basic unit in AIML is `category`, which consists of a `pattern`
    and a `template` attribute. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the user's input is matched against the pattern `WHAT ARE YOU`
    and the response provided in the template is generated. By using many thousands
    of categories and wild cards to enable more flexible pattern matching, quite sophisticated
    conversations can be produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wild cards are used to match a string of one or more words in the input. Here
    is a simple example of the wildcard `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, any input starting with `ABBA` will match this category, resulting
    in the output `They were a great band in the 70's`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are often several different ways of saying the same thing and rather
    than listing each as a pattern or template pair, the `<srai>` tag (meaning symbolic
    reduction) can be used, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the input `HOW DID YOU GET YOUR NAME` is treated in meaning to be the same
    as `WHAT DOES ALICE STAND FOR`, and the `<srai>` tag indicates that they should
    both have the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no pattern that matches the input; in other words, the bot does
    not understand what has been said to it; the ultimate default category applies.
    For this category, the pattern is `*` and the default response is `I have no answer
    for that`. The art of bot programming is to provide a series of responses in the
    ultimate default category that helps to keep the conversation going. For example,
    *tell me more about yourself* should cause the user to say something for which
    there will probably be a matching pattern. The ultimate default category can also
    be used to catch input that is not predicted by any pattern and process it to
    determine if it can be handled in some other way. For example, it could be sent
    to a search engine or an online knowledge source to get a response.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching is performed using a matching algorithm that conducts a graph
    search through the categories. The text in the AIML patterns is first tidied up
    by removing unnecessary punctuations, converting to upper case, and expanding
    contractions such as I'll to I will.
  prefs: []
  type: TYPE_NORMAL
- en: As far as templates are concerned, in addition to specifying the text of the
    response, it is also possible to perform simple computations. For example, values
    of properties, which are constants referring to properties of the bot, such as
    `age`, `name`, or `location`, can be retrieved. There are methods for dealing
    with predicates also, which are variables set during a conversation for items
    such as the topic of the conversation, or how to deal with the use of pronouns
    to refer to a particular word. These computations help to make the conversation
    more natural.
  prefs: []
  type: TYPE_NORMAL
- en: A more comprehensive coverage of AIML is beyond the scope of this book. Full
    documentation can be found at the Pandorabots website ([www.pandorabots.com](http://www.pandorabots.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Using oob tag to add additional functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `<oob>` tag is a recent addition to AIML that supports usage on mobile
    devices. OOB stands for out of band, a term taken from engineering to refer to
    a conversation on a separate, hidden channel. In AIML, `<oob>` tags can be used
    to send commands to the device, for example, to place a call, send a text message,
    launch an app, and so on. The content of the tag is not a part of the response
    received by the user, so items such as URLs, app names, and other keywords can
    be included here to be extracted and treated as desired in the Android code. Here
    are a few examples of patterns using the `<oob>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if the bot does not find a match for the user's input in its
    AIML files, the response is marked as `<search>`. The content of the search query
    is `<star/>`, the value of which is the words spoken in the input. The code to
    carry out this stage for this and the following examples can be found in `VPALib`
    in the code bundle (`sandra.libs.vpa.vpalib`). The text located outside the `<oob>`
    tag can be used for other purposes; in these apps, it is sent to TTS and used
    for the spoken output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how the input `WIKIPEDIA` sets up the launch of
    the URL for Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the matched input `GMAIL` sets up the launch of Google
    mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The VPALib library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a library that contains the code which connects with Pandorabots.
    Any app that wants to incorporate an agent just has to deal with the interface
    aspects, such as the GUI appearance and the control of the speech recognition
    and synthesis.
  prefs: []
  type: TYPE_NORMAL
- en: The `VPALib` library uses `ASRLib`, `TTSLib`, and `XMLLib` to manage speech
    recognition, speech synthesis, and asynchronous tasks when retrieving web contents
    (you can see it if you check the `libs` folder in the `VPALib` project). This
    way, it can focus on the code required to manage the VPA behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The main class in the VPALib library is the `Bot` class, which sends queries
    to the Pandorabots website, parses the results, and carries out the corresponding
    actions on the device.
  prefs: []
  type: TYPE_NORMAL
- en: When a new bot is created, we must specify an ID to the constructor. This is
    the ID in the Pandorabots site (for example, `d7b695cf0e344c0a` for Jack). Also,
    we can specify its topic of specialization. For example, if the bot is specialized
    for providing information about the NFL, the string `NFL` is used to carry out
    web searches. So, if the user asks for games, the bot searches for NFL games,
    and not any kind of games.
  prefs: []
  type: TYPE_NORMAL
- en: The `initiateQuery` method sends a text corresponding to the user input, to
    the bot on the Pandorabots site. This process involves inserting `%20` for spaces
    in the query, as the values posted need to be form-URL encoded, creating the query
    and sending it as a background asynchronous task to Pandorabots, using the `XMLLib`
    folder described in [Chapter 5](ch05.html "Chapter 5. Form-filling Dialogs"),
    *Form-filling Dialogs*.
  prefs: []
  type: TYPE_NORMAL
- en: The results from `AsyncTask` are processed in the `processXMLContents()` method.
    The output from the response that comes back from Pandorabots is parsed using
    `XMLPullParser` in a similar way to how we parsed `VXML` ([Chapter 5](ch05.html
    "Chapter 5. Form-filling Dialogs"), *Form-filling Dialogs*) or `XML` grammar files
    ([Chapter 6](ch06.html "Chapter 6. Grammars for Dialog"), *Grammars for Dialog*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The response either includes `<oob>` tags or does not. If it does not, the
    only task for the bot is to parse and synthesize the response. For this, it must
    extract the message contained within the `<that>` tag. Here is an example of the
    outcome of `AsyncTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the method would invoke the TTS engine to synthetize `C, Java,
    Lisp, SETL and English`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The gender of Google's TTS voices cannot be programmatically selected. We have
    used the UK English voice, which is currently male, but it might be possible that
    the gender selected for the VPA does not match the voice in the user's device.
    Currently, this can only be resolved by using other TTS engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `<oob>` tags are present, we assume that they have been marked up in the
    AIML file with one of the tags: `<search>`, `<launch>`, `<url>`, and `<dial>`.
    When `<search>` is encountered, the `googleQuery` method is invoked, which launches
    a query in Google search engines. When `<launch>` is encountered, the `launchApp`
    method is invoked that launches an app in the device. Similarly, the `launchUrl`
    method is invoked when the `<url>` tag is encountered to open the specified web
    page. Finally, when `<dial>` is processed, it invokes the `placePhoneCall` method,
    which dials a number.'
  prefs: []
  type: TYPE_NORMAL
- en: The `launchApp` and `launchUrl` methods are similar to those introduced in [Chapter
    4](ch04.html "Chapter 4. Simple Voice Interactions"), *Simple Voice Interactions*,
    except that there the code was more complex as it used similarity functions. The
    methods shown in this chapter have been kept simpler in order to focus on the
    use of `<oob>` tags as a technique for recognizing these commands within the user's
    input.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, it is up to the developer to decide whether to mark up the different
    functions in AIML and then process them or whether to employ a different method
    for recognizing whether the output is text to be spoken or a command to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pandorabot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The apps that will be described in the following sections use AIML code provided
    on the Pandorabots site. Thus, the first step we must take is to register for
    an account in the Pandorabots website.
  prefs: []
  type: TYPE_NORMAL
- en: Once registered, enter the site and click on the **Create a Pandorabot** option.
    This will open a page where you will be asked to name your bot (we called ours
    `Jack`). Select your startup AIML from a number of choices, including an option
    of **No initial content, the Pandorabot starts with no knowledge**. For the purposes
    of this example, select one of the AIML sets (for example, **Dr Wallace's A.L.I.C.E
    – March 2002**). This will take you to a page for your Pandorabot where you can
    explore a number of options.
  prefs: []
  type: TYPE_NORMAL
- en: To see the AIML files, click on **AIML** and then on any of the files listed.
    This will give an idea of the large number of categories that can be used to provide
    conversational responses.
  prefs: []
  type: TYPE_NORMAL
- en: To try out the bot with the pre-existing AIML, click on Train and then ask questions
    to see what responses the bot gives. This will bring up a training page indicating
    the AIML file where a match has been found for your input as well as various other
    options that help to refine the bot. The pre-existing AIML files cannot be modified
    but any new categories will be stored in a file called `update.aiml`.
  prefs: []
  type: TYPE_NORMAL
- en: To enable your bot to be available for others to use, you must publish it (or
    republish, if you have made any changes to the AIML code). Return to the home
    page of your bot and click on **Publish**. This will load a page showing the location
    of your bot.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on this link will open a page that is available publicly to anyone
    who has access to the link, letting them interact with your bot. In this way,
    you can collect further data from interactions with the bot and view them in log
    files, enabling you to further refine the bot's responses.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will provide an interface that runs on an Android device
    and uses speech to interact with the bot. It will be important to note the **botid**,
    as this will be required when connecting to your bot from your Android program.
  prefs: []
  type: TYPE_NORMAL
- en: Sample VPAs – Jack, Derek, and Stacy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate the use of `VPALib`, we have developed three bots: Jack, Derek,
    and Stacy. As can be observed in their respective packages (see the code bundle),
    they have the same structure; a main activity that implements ASR and TTS and
    creates an instance of the bot, and a simple graphical interface. This shows the
    convenience of having a library that deals with the connection to Pandorabots.
    The main difference is in their corresponding AIML files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The links in Pandorabots for the bots are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jack: [http://www.pandorabots.com/pandora95cf0e344c0a/talk?botid=d7b695cf0e344c0a](http://www.pandorabots.com/pandora/talk?botid=d7b695cf0e344c0a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Derek: [http://www.pandorabots.com/pandora/talk?botid=a80ce25abe3](http://www.pandorabots.com/pandora/talk?botid=a80ce25abe3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacy:[http://www.pandorabots.com/pandora/talk?botid=e257c70bae346e98](http://www.pandorabots.com/pandora/talk?botid=e257c70bae346e98)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interfaces for Jack and Derek are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample VPAs – Jack, Derek, and Stacy](img/5297_08_02_corrected.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jack is a general-purpose VPA, while Derek is a specialized VPA. Specialized
    VPAs perform tasks such as providing customer service or answering customer queries.
    The VPA's knowledge base is encoded in AIML as a set of question-response pairs,
    similar to FAQs. We have developed a rudimentary set of questions in AIML about
    Type 2 diabetes. Derek can answer questions about topics such as symptoms, causes,
    treatment, risks to children, and complications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacy has the same AIML files as Jack but in addition, has a file containing
    categories with `<oob>` tags to perform a small selection of functions such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending a search term to DBPedia, obtaining a response, and speaking it. If
    no text is available from DBPedia, the search term is sent to Google search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a web page (Wikipedia or Facebook).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching an app on the device (clock, calendar, phone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code to perform these functions can be found in `VPALib` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the `Jack.java` (`Jack` project) and `Derek.java` (`Derek` project)
    files how the `Bot` class is instantiated differently. In the case of Jack, it
    is without `specializedTopic`, while in the case of Derek, it is `Type 2 diabetes`,
    using the two alternative constructors of the `Bot` class (`VPALib` project).
  prefs: []
  type: TYPE_NORMAL
- en: After running the `Derek` app a few times, it will soon become apparent that
    misrecognitions of your spoken input result in the bot responding with the default
    response `I have no answer for that`. This is likely to become annoying after
    a few times but there is also the problem that a potentially valid query is lost
    because the recognized words do not match any of the patterns in the AIML code.
    For example, in one interaction with Derek we said *what are the risks to my children*
    and the app returned the recognition result `what other risks children`, which
    did not match any of our patterns. It would have been more productive to have
    extracted the useful parts of this phrase, `risks` and `children`, and combine
    them with the term `Type 2 diabetes`, to send an expanded search query which would
    be more likely to find a relevant result. This has been implemented by using a
    category in the AIML code containing an `<oob>` tag that links with a function
    in `VPALib`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These examples demonstrate some of the functions that can be performed by a
    VPA using the Pandorabots conversational engine and `<oob>` tags as a resource.
    Other functions can be added too (for a complete list of `<oob>` tags with examples,
    see [https://code.google.com/p/aiml-en-us-pandorabots-callmom/wiki/CallMomOOBTags](https://code.google.com/p/aiml-en-us-pandorabots-callmom/wiki/CallMomOOBTags)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some limitations to this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: For general conversational interaction, there should to be sufficient default
    responses to handle cases when there is no match for the input. This is not a
    serious problem as there are lots of examples in the pre-existing AIML code that
    can be used or adapted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of specialized VPAs, it might not be sufficient to use the rather
    adhoc procedure of sending unmatched input to a search engine, even if the query
    is expanded, as in the previous example, where the words `Type 2 diabetes` were
    added to the search query. This approach relies very much on the search engine
    coming back with a list of URLs that fit in with the user's query and on the search
    text reflecting accurately the user's intended query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `<oob>` tags depends on creating patterns that correctly match the
    user's input. For example, the user should say something like *calendar*, *Gmail*,
    or some other keyword to indicate which device function is intended. These patterns
    in the AIML code have to be closely linked to the Java code that makes use of
    them. A library that implements this would be a useful addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The approach does not generalize easily for websites. For example, each website,
    such as Wikipedia, has to be coded separately as a pattern in a category in AIML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more sophisticated and scalable method for determining the user's intention
    could be to use the types of grammar illustrated in [Chapter 6](ch06.html "Chapter 6. Grammars
    for Dialog"), *Grammars for Dialog*. A handcrafted grammar could be designed to
    recognize key words or phrases in the input, or an appropriate statistical grammar
    could be developed to handle the input more robustly. Input that is not extracted
    in this way could then be treated as conversational input and passed to a resource
    such as AIML.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these issues are being addressed by the Pandorabots team but the solutions
    are not currently available as open source code. New developments will be posted
    on the website for the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have seen how to develop different types of VPAs using the
    resources provided by the Pandorabots chatbot technology. Based on the apps described
    here, you should now be able to design and develop VPAs for your own purposes.
    Some suggestions for how to build on these examples and to include more of the
    techniques described throughout the book are presented in [Chapter 9](ch09.html
    "Chapter 9. Taking it Further"), *Taking it Further*.
  prefs: []
  type: TYPE_NORMAL
