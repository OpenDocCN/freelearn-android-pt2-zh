- en: Chapter 9. Web Services with Push Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern mobile applications are defined by their network connectivity. A mobile
    app that does not interact with a web server is both a rare find and potentially
    a boring application. In this book, we'll use the **Windows Azure** cloud platform
    to implement a server-side backend for our XamSnap application. We'll use a feature
    called **Azure Functions**, which is an excellent fit as a simple backend for
    our application and can send push notifications via **Azure Notification Hubs**.
    Once we are done with this chapter, our XamSnap sample application will be much
    closer to being a real application and will allow its users to interact with one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The services offered by Windows Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your Azure account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions as a backend for XamSnap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a real web service for XamSnap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing client-side code for calling Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Apple Push Notification service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications with Google Cloud Messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Windows Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Azure is an excellent cloud platform released by Microsoft in 2010\.
    Azure provides both **Infrastructure as a Service** (**IaaS**) and **Platform
    as a Service** (**PaaS**) for building modern web applications and services. This
    means that it provides you the access directly to virtual machines within which
    you can deploy any operating system or software of your choice. This is known
    as IaaS. Azure also provides multiple platforms for building applications, such
    as **Azure Web Apps** or **SQL Azure**. These platforms are known as PaaS, since
    you deploy your software at a high level and do not have to deal directly with
    virtual machines or manage software upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over the following more common services provided by Windows Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual Machines**: Azure provides you the access to virtual machines of
    all sizes. You can install practically any operating system of your choice; there
    are many premade distributions to choose from within Azure''s gallery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Apps**: You can deploy any type of website that will run in Microsoft
    **IIS**, from ASP .NET sites to **PHP** or **Node.js**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Azure**: This is a cloud-based version of Microsoft SQL Server, which
    is a fully featured **RDMS** (**Regional Database Management System**) for storing
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile Apps**: This is a simple platform for building web services for mobile
    apps. It uses **SQL Azure** for backend storage and a simple JavaScript scripting
    system based on Node.js for adding business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Functions**: The first product of Windows Azure supporting the new
    "serverless" architecture that is becoming today''s new buzzword. You can develop
    simple APIs, background jobs, webhooks, and so on in a variety of languages directly
    in the web browser. Azure will automatically scale your function based on incoming
    requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: Azure provides **blob storage**, a method for storing binary files
    and **table storage**, which is a **NoSQL** solution for persisting data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service bus**: This is a cloud-based solution for creating queues to facilitate
    communication between other cloud services. It also includes notification hubs
    as a simple way to provide push notifications to mobile apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification Hubs**: A simple way to send push notifications to different
    platforms such as Android, iOS, and Windows devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DocumentDB**: A fully featured NoSQL data storage comparable to other NoSQL
    databases such as **MongoDB**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HDInsight**: A version of Apache Hadoop running in Windows Azure for managing
    extremely large data sets, which also could be called big data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these services, there are many more and new ones actively being developed.
    We will use Azure Functions, and also leverage Azure Storage Tables, to build
    our web service for XamSnap. You can visit [http://windowsazure.com](http://windowsazure.com)
    for a full rundown of pricing and services offered.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we chose to demonstrate a solution using Windows Azure as a web
    service backend for XamSnap, since it is complementary with C#, Visual Studio,
    and other Microsoft tools. However, there are many more choices out there besides
    Azure, which you may want to look at. Choosing Xamarin does not limit the types
    of web service your applications can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Firebase**: This service by Google provides a product similar to that of
    Azure Mobile Apps, complete with data storage and push notifications. You can
    get more information at [https://firebase.google.com](https://firebase.google.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Urban airship**: This service provides push notifications for mobile apps
    across multiple platforms. You can get more information at [http://urbanairship.com](http://urbanairship.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Web Services**: This service is a complete cloud solution that is
    equivalent to Windows Azure. It has everything you need to deploy applications
    in the cloud with total virtual machine support. There is also a feature called
    **AWS Mobile Hub**, tailored specifically for mobile development. You can get
    more information at [http://aws.amazon.com](http://aws.amazon.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can develop your own web services with on-premises web servers
    or inexpensive hosting services using the languages and technologies of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your Azure account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start developing with Windows Azure, you can subscribe to a free one-month
    trial along with $200 in free Azure credit. To go along with this, many of its
    services have free tiers that give you lower performance versions. So, if your
    trial expires, you can continue your development at little or no cost, depending
    on the services you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by navigating to [http://azure.microsoft.com/en-us/free](http://azure.microsoft.com/en-us/free)
    and then carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Start Free** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in with a Windows Live ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For security purposes, verify your account via your phone or a text message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the payment information. This is only used if you exceed your spending
    limits. You won't accidentally spend beyond budget by developing your app-it is
    not common to accidentally spend money until real users are interacting with your
    services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **I agree** to the policies and click on **Sign Up**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the final setting and click on **Submit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all the required information is entered correctly, you will now finally have
    access to your Azure account. You can click the **PORTAL** link in the top-right
    corner of the page to access your account. In the future, you can manage your
    Azure services at [http://portal.azure.com](http://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure Portal uses a set of panels named blades, to quickly navigate and
    drill deeper into more detailed information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your Azure account](img/image00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This concludes your sign up for Windows Azure. It is pretty simple compared
    to the Apple and Google Play developer programs. Feel free to play around, but
    don't be too worried about spending money. Azure has free versions of most services
    and also delivers a good amount of bandwidth for free. You can get more information
    on pricing at [http://azure.microsoft.com/en-us/pricing](http://azure.microsoft.com/en-us/pricing).
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are a lot of misconceptions about Windows Azure being expensive.
    You can do all of your development for an application on the free tier without
    spending a dime. When putting applications into production, you can easily scale
    up or down on the number of VM instances to keep your costs under control. In
    general, you will not be spending much money if you do not have a lot of users.
    Likewise, you should be earning plenty of revenue if you happen to have lots of
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the server side of XamSnap, we'll use Azure Functions along with Azure Storage
    Tables to provide backend storage to the application. Azure Functions is a simple
    solution to accelerate development for server-side applications that can leverage
    all features of Windows Azure. We will use the standard `HttpClient` class found
    in the .NET base class library for interacting with the service from C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few neat features of Azure Functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can write functions in a variety of programming languages such as JavaScript,
    C#, Python, and PHP, as well as some scripting languages such as Batch, Bash,
    and PowerShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions integrates with Visual Studio Team Services, Bitbucket, and
    GitHub for **Continuous Integration** (**CI**) scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set up authentication easily with Azure Active Directory, Windows Live
    ID, Facebook, Google, and Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be triggered via HTTP, a schedule or timer, Azure Queue, and so
    on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Functions is truly serverless and can scale dynamically for large volumes
    of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see why using Azure Functions is a good choice for simple mobile applications.
    The benefits of accelerated development and the many features it provides are
    a great fit for our XamSnap sample application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigating to your account at [http://portal.azure.com](http://portal.azure.com)
    and perform the following steps to create an Azure Function:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the plus button in the top-left of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Compute** | **Function App** through the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a domain URL of your choice, such as `yourname-xamsnap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose subscription to place the services under.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an existing **Resource Group**, or create a new one named `xamsnap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a **Dynamic****App Service** plan to get started. If you already have
    an App service plan, you can use an existing one with **Classic** mode instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an existing **Storage Account** or create a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review your final settings and hit the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The management portal will display progress, and it could take a few seconds
    to create your Azure Function App instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple Hello World function to see things working:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your Function App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Quickstart**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Webhook + API** with C# selected then hit **Create this function**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Azure Portal will give you a quick tour, which you can skip if desired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the bottom and click **Run** to see your Azure Function in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When completed, you should see output in the log window and a successful HTTP
    request with the output of `Hello Azure`. You should see something similar to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Azure Functions](img/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating and calling Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin setting up our backend for XamSnap, we need to create a login function.
    We also need to implement the `IWebService` interface used by the rest of the
    application. Because of our MVVM architecture, we should be able to replace the
    fake service that is being used currently without changing any of the layers sitting
    above it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the Azure Portal, select your Function App instance, and perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **New Function** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Empty - C#** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `login` as the function name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Integrate** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **HTTP** trigger and output with the default settings and hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **Azure Table Storage** output, change the table name to `users`, and
    hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s write some code for our function, switch to the **Develop** section
    and add the following code as a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we added a reference to the Azure Storage SDK. This is built-in and available
    to Azure Functions, we will be using it later. Next, we added a few using statements
    and a constant. We created a static function that handles the inputs and outputs
    we defined earlier. `req` is the HTTP input and `outputTable` is the Azure table
    output. `log` is a `TraceWriter` available for debugging and logging purposes.
    Finally, we used built-in methods to read the POST data into `username` and `password`
    variables for use in our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to fill in the rest of our functionality. Place this code at
    the bottom of the function we started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize what we did in the preceding C#:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we hashed the incoming password with a function we'll add later. Note
    that Azure Functions have built-in authentication features that would be great
    for production apps. For our sample app, we are at least taking a measure to not
    store passwords into our database as plain text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we used the Azure Storage SDK to check for an existing user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no results, we go ahead and create a new user. The partition key
    and row key are concepts in Azure table storage. In most scenarios, you choose
    a key to partition your data, such as a state or zip code, and the row key is
    a unique key. For this sample, we are just using a constant value for the partition
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, we compare the hashed passwords and return a success.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the passwords do not match, we return an unauthorized error code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, we just need a little more code to define the `Hash` function and
    the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We used the built-in SHA-256 hashing algorithm found in the `System.Security`
    namespace. It is at least a bit more secure that the commonly broken MD5 hash.
    We also declared the `User` class as a table entity with one additional column
    containing the hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, just make sure you click on the **Save** button to apply your changes.
    Azure Functions also has the option of providing source control for your scripts
    via several source control providers. Feel free to take advantage of this feature
    if you want to make changes to the script in your favorite editor locally instead
    of the website editor. You should be able to test the function passing sample
    JSON as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For complete documentation for the Azure Storage SDK, make sure you check out
    MSDN at [https://msdn.microsoft.com/en-us/library/azure/mt347887.aspx](https://msdn.microsoft.com/en-us/library/azure/mt347887.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Using HttpClient in C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our server-side changes complete, the next step is to implement our new
    service in our XamSnap iOS and Android applications. Luckily, as we used an interface
    named `IWebService`, all we need to do is implement that interface to get it working
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start setting up our service in our iOS application by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `XamSnap.Core` project that we created earlier in the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `Azure` folder within the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class named `AzureWebService.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and implement `IWebService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `IWebService` in your code and select **Refactor** | **Implement
    Interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A line will appear; press **Enter** to insert the method stubs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When this setup is complete, your class will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to add a reference to the JSON .NET library. To do this, we will
    use NuGet to add the library. Right-click on the `XamSnap.Core` project and select
    **Add** | **Add Packages** and install Json .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s modify our `AzureWebService.cs` file. We will make the following
    changes to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We defined some using statements and a few variables we will using throughout
    this class. Make sure you fill in the proper URL for your Azure Function App.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s write some helper methods to make calling web requests easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is implementing the basics for calling a RESTful endpoint
    in C#. First, we serialize the object to JSON and create a `StringContent` object
    with a header declaring that it is JSON. We format the URL with the `code` parameter,
    which is a simple security mechanism that is on by default for Azure Functions.
    Next, we call a POST request to the server and call `EnsureSuccessStatusCode`
    in order to throw an exception for failed requests. Lastly, we added a second
    method that parses the response from JSON into C# objects. Some of our Azure Functions
    will return data, so we will need this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement our first method, `Login`, in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is fairly straightforward, because of the helper methods we've already
    set up. We merely have to pass in our function name, its key, and the object representing
    the JSON we want to pass to the HTTP request. You can find the key needed under
    **Function URL** in the **Develop** section in the Azure Portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `AppDelegate.cs` file to set up our new service and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now if you compile and run your application upon login, your app should successfully
    call your Azure Function and insert a new user into Azure Table Storage.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking for a quick way to manage Azure Tables, Microsoft has released
    a free tool called Azure Storage Explorer. It is available for both Mac OS X and
    Windows can be found at [http://storageexplorer.com](http://storageexplorer.com).
    A second option is the **Cloud Explorer** in Visual Studio that is available if
    you install the Azure SDK for .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several more methods we need to implement for our `IWebService` implementation.
    Let's begin by adding two more Azure Functions for getting a list of a users'
    friends and adding a friend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the Azure Portal and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **New Function** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Empty - C#** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `friends` as the function name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Integrate** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **HTTP** trigger and output with the default settings and hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **Azure Table Storage** input, change the table name to `friends`, and
    hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat these steps for a second function named `addfriend`, except make **Azure
    Table Storage** an output instead of input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s implement the `friends` Azure Function with the following C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit simpler than our `login` function. Azure Functions have the option
    to use different types of parameters than the `CloudTable` we used earlier. When
    using `IQueryable` we can merely write a LINQ expression to pull out the data
    we need for this function: a list of friends for the specified user. We plan on
    storing the user''s name as the `PartitionKey` and the friend''s name as the `RowKey`.
    We then can merely return these values in the HTTP response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `addfriend` function with the following C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just as before with the `login` function, we use a `CloudTable` to add a row
    to an Azure Storage Table. Just as before, we handle the possibility of blank
    input and return the same status code the Azure Storage SDK returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s modify `AzureWebService.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are calling the helper methods we created earlier in the chapter to easily
    handle HTTP input and output to our Azure Functions. Make sure to use the proper
    key for each Azure Function. You may want to use a tool to insert or seed some
    test data into the `friends` Azure Storage table for our Azure Function to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to make three more Azure Functions for handling conversations
    and messages. Return to the Azure Portal and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **New Function** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Empty - C#** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `conversations` as the function name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Integrate** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **HTTP** trigger and output with the default settings and hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **Azure Table Storage** input, change the table name to `friends`, and
    hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat these steps for a second function named `messages` with a table name
    of `messages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat these steps for a third function named `sendmessage`, except make **Azure
    Table Storage** an output instead of input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The C# code for the `conversations` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code is nearly identical to our `friends` function we wrote earlier. However,
    we need to define a `Conversation` class to add an extra column to our table beyond
    the default `RowKey` and `PartitionKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the following C# code for the `messages` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this should be very straightforward for what we did for our `friends`
    and `conversations` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, let''s add the following code for the `sendmessage` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function is close to what we did with `addfriend`. Later in the chapter,
    we will send push notifications in this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going further, let''s implement the rest of our `IWebService` interface.
    It can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Each method here in our client-side code is pretty simple and very similar
    to what we did to call the other Azure Functions. `SendMessage` is the only thing
    we had to do that was new: generate a unique message ID for new messages.'
  prefs: []
  type: TYPE_NORMAL
- en: This completes our implementation of `IWebService`. If you run the application
    at this point, it will function exactly as before with the exception that the
    app is actually talking to a real web server. New messages will get persisted
    in Azure Storage Tables, and our Azure Functions will handle the custom logic
    that we need. Feel free to play around with our implementation; you might discover
    some features of Azure Functions that will work great with your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, another good exercise would be to set up `AzureWebService` in
    our Android application. You should be able to swap out the `ServiceContainer.Register`
    call in your `Application` class. Everything will function exactly like on iOS.
    Isn't cross-platform development great?
  prefs: []
  type: TYPE_NORMAL
- en: Using the Apple Push Notification service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing push notifications with Azure Notification Hubs on iOS is very
    simple to set up from Azure's perspective. The most complicated part is working
    through Apple's process of creating certificates and provisioning profiles in
    order to configure your iOS application. Before continuing, make sure you have
    a valid iOS Developer Program account, as you will not be able to send push notifications
    without it. If you are unfamiliar with the concept of push notifications, take
    a look at Apple's documentation at [http://tinyurl.com/XamarinAPNS](http://tinyurl.com/XamarinAPNS).
  prefs: []
  type: TYPE_NORMAL
- en: 'To send push notifications, you need to set up the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An explicit App ID registered with Apple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A provisioning profile targeting that App ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A certificate for your server to trigger the push notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple provides both a development and production certificate, which you can
    use to send push notifications from your server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your provision profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by navigating to [http://developer.apple.com/account](http://developer.apple.com/account),
    and carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Identifiers** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button in the top-right corner of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a description, such as `XamSnap`, for the bundle ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your bundle ID under the **Explicit App ID** section. This should match
    the bundle ID you set up in your `Info.plist` file, for example, `com.yourcompanyname.xamsnap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **App Services**, be sure to check **Push Notifications**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review your final settings and hit **Submit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will create an explicit app ID similar to what we can see in the following
    screenshot, which we can use for sending push notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your provision profile](img/image00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For push notifications, we have to use a profile with an explicit App ID that
    is not a development certificate. Now let''s set up a provisioning profile:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Development** link under **Provisioning Profiles** on the right-hand
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button in the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **iOS App Development** and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the App ID we just created and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the developer and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the devices you will be using and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name for the profile and click on **Generate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the profile and install it, or open **XCode** and use the sync button
    in **Preferences** | **Accounts**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When finished, you should arrive at a success web page that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your provision profile](img/image00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a certificate for push notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we perform the following steps to set up the certificate our server needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Development** link under **Certificates** on the right-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button in the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **Apple Push Notifications service SSL (Sandbox)** and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your App ID as before and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new certificate signing request as per Apple's instructions. You may
    also refer to [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Deploying and
    Testing on Devices"), *Deploying and Testing on Devices*, or locate the `*.certSigningRequest`
    file from before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the signing request file and click on **Generate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Download**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file to import the certificate into **Keychain**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the certificate in **Keychain**. It will be titled **Apple Development
    iOS Push Services** and will contain your bundle ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the certificate and export it somewhere on your filesystem. Enter
    a password that you would remember.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create the certificate we need to send push notifications to our users
    from an Azure Notification Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the Azure Portal and perform the following steps to create an Azure
    Notification Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the resource group where your **Azure Function App** is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button to add a new service to the resource group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a **Notification Hub Name** and **Namespace** such as `xamsnap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the desired data center and resource group are selected and click
    on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All that remains is to return to the Azure Portal and upload the certificate
    from your Azure Notification Hub. You can find this setting under **Notification
    Services** | **Apple (APNS)** | **Upload Certificate**, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a certificate for push notifications](img/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This upload concludes the configuration we need from Apple's side.
  prefs: []
  type: TYPE_NORMAL
- en: Making client-side changes for push notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let's return to our `XamSnap.iOS` project in Xamarin Studio to make the
    necessary changes on the client side for push notifications. We will need to add
    a few new classes to our shared code to start with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our XamSnap PCL project, create a new interface named `INotificationService`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to call `Start` after login completes. In `LoginViewModel.cs`,
    add the following lines after a successful login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s implement this interface in a new class in our iOS project named
    `AppleNotificationService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We need to define a `CultureInfo` object for use later and need two private
    variables for our notification hub and the name of the currently logged in user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `Start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We stored the user's name in a member variable and then called the native iOS
    APIs to set up registration for remote notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to implement the `SetToken` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a new notification hub if needed. Make sure to replace `yourconnection`
    with a real connection string that only has **Listen** access. This can be found
    in the Azure Portal under **Settings** | **Access Policies** | **DefaultListenSharedAccessSignature**.
    Following that, we declared an iOS template that takes uses the `message` variable
    in the proper format for iOS push notifications. This is a feature of notification
    hubs that enabled cross-platform push notifications. Finally, we registered the
    device token with the notification hub, logging any errors that might occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to make a few iOS-specific changes to `AppDelegate.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We implemented a couple of important methods in the preceding code snippet.
    `DidRegisterUserNotificationSettings` is a callback for when the user accepts
    the iOS permission popup. `RegisteredForRemoteNotifications` will occur when Apple
    successfully returns a device token from its servers. We pass the device token
    through the `INotificationService` to the Azure Notification Hub. We also implemented
    `FailedToRegisterForRemoteNotifications` just to report any errors that might
    occur throughout the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add a small modification to register our `INotificationService`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sending push notifications from the server-side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have successfully configured iOS for push notifications, it is now
    time to actually send them from our `sendmessage` Azure Function. Azure Functions
    support notification hubs out of the box, but at the time of writing it was not
    possible to use them as an output and specify a tag targeting a specific user.
    Luckily, Azure Functions are just C# code, so we can easily leverage the Azure
    Notification Hub SDK to manually send push notifications from code. Let's switch
    to the Azure Portal and make the remaining changes on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a few statements at the top to include the Azure Notification
    Hub SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add a quick method for sending push notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace `yourconnection` with a valid connection string with both
    **Send** and **Listen** permissions. By default, you can use the one named **DefaultFullSharedAccessSignature**
    in the Azure Portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to actually send the push notification when the Azure Function
    is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To test push notifications, deploy the application and log in with the secondary
    user. After logging in, you can just background the app with the home button.
    Next, log in with the primary user on your iOS simulator and send a message. You
    should receive a push notification, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending push notifications from the server-side](img/image00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having some trouble getting things working, try sending test notifications
    from the Azure Portal under your notification hub and then **TroubleShooting**
    | **Test Send**. You can send test notifications with the native format or the
    custom template format we use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Google Cloud Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already set up everything we need in the shared code and on Azure,
    setting up push notifications for Android will be a lot less work at this point
    of time. To continue, you will need a Google account with a verified e-mail address;
    however, I would recommend using an account registered with **Google Play**, if
    you have one. You can refer to the full documentation on **Google Cloud Messaging**
    (**GCM**) at [https://developers.google.com/cloud-messaging/](https://developers.google.com/cloud-messaging/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Google Cloud Messaging requires that Google APIs be installed on the
    Android device and that the Android OS be at least Version 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by navigating to [http://cloud.google.com/console](http://cloud.google.com/console),
    then and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Create Project** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an appropriate project name, such as `XamSnap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Agree to the **Terms of Service**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating your first project, you may have to verify the mobile number associated
    with your account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the **Project Number** field on the **Overview** page. We will need this
    number later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our project widget on the **Dashboard** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Google Cloud Messaging](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can continue with our setup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Use Google APIs** widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Library** and search for **Google Cloud Messaging for Android**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Enable** button at the top to enable the service. You may have
    to accept another agreement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Go to Credentials** that will appear in a warning tip at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **What credentials do I need?** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Restrict Key**, choose **IP Addresses**, and enter **0.0.0.0/0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the key to your clipboard for later and click **Save.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the Azure Portal and navigate to the **Notification Services** | **Google
    (GCM)** section in your Azure Notification Hub instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the API key in the **API Key** field and click on **Save**. Note that
    the first time, it may take the Google Console up to five minutes for the key
    to be valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This completes our set up on Azure's side. We will need to get a couple open-source
    libraries for Xamarin.Android apps. First, install **Xamarin.Azure.NotificationHubs.Android**
    from NuGet, and then install **Google Cloud Messaging Client** from the Xamarin
    Component store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new class called `Constants.cs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Fill out the `ProjectId` value with the project number found earlier on the
    **Overview** page of your Google Cloud Console. `ConnectionString` and `HubName`
    should be the exact same as what was entered for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up some permissions to support push notifications in our
    application. Above the namespace declaration in this file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You could also make these changes in our `AndroidManifest.xml` file; however,
    using C# attributes can be better since it gives the ability to use code completion
    while typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create another new class named `PushBroadcastReceiver.cs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `PushBroadcastReceiver.cs` class sets up `BroadcastReceiver`, which is Android's
    native way for different applications to talk with one another. For more information
    on the topic, checkout the Android documentation on the subject at [http://developer.android.com/reference/android/content/BroadcastReceiver.html.](http://developer.android.com/reference/android/content/BroadcastReceiver.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create one last class named `PushHandlerService.cs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, right-click on `GcmServiceBase` and choose **Refactor** | **Implement
    abstract members**. Next, let''s implement each member one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code is very similar to what we did on iOS. We merely have to
    send the `registrationId` value to `INotificationService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to write the following code when the message is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code will actually pull out the values from the notification and display
    them in the notification center of the Android device. We used the built-in resource
    for `SymActionEmail` to display an e-mail icon in the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we just need to implement two more abstract methods. For now, let''s
    just use `Console.WriteLine` to report these events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Down the road, you should consider removing registrations from Azure when `OnUnRegistered`
    is called. Occasionally, a user's `registrationId` will change, so this is the
    place where your application is notified of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to implement `INotificationService` for Android. Begin by creating
    a new file named `GoogleNotificationService.cs` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `Application.cs` and add the following line to register our new
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you repeat the steps for testing push notifications on iOS, you should
    be able to send a push notification to our Android app. Even better, you should
    be able to send push notifications across platforms, since an iOS user could send
    a message to an Android user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Google Cloud Messaging](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we went over what Windows Azure provides: Infrastructure as
    a Service and Platform as a Service. We set up a free Windows Azure account and
    set up an Azure Function App instance. We implemented the client-side code for
    making requests against our Azure Functions. Lastly, we implemented push notifications
    for iOS using Azure Notification Hubs to consolidate messages going to iOS devices
    via the Apple Push Notification service and Android via Google Cloud Messaging.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Functions, we were able to get by without writing too much server-side
    code. In the next chapter, we'll explore how to use third-party libraries with
    Xamarin. This includes everything from the Xamarin Component Store to using native
    Objective-C or Java libraries.
  prefs: []
  type: TYPE_NORMAL
