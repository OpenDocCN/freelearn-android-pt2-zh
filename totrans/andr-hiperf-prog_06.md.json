["```kt\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```", "```kt\n<uses-permission \nandroid:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```", "```kt\nConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);\nTelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\nNetworkInfo activeNetwork = cm.getActiveNetworkInfo();\n\nswitch (activeNetwork.getType()) {\n    case (ConnectivityManager.TYPE_WIFI):\n        // apply standard latency strategy\n        break;\n    case (ConnectivityManager.TYPE_MOBILE): {\n        switch (tm.getNetworkType()) {\n            case (TelephonyManager.NETWORK_TYPE_LTE):\n                // apply higher latency strategy\n                break;\n            case (TelephonyManager.NETWORK_TYPE_GPRS):\n                // apply lower latency strategy\n                break;\n            default:\n                break;\n        }\n        break;\n    }\n    default:\n        break;\n}\n```", "```kt\npublic class TransferQueue {\n    private Queue<Request> queue;\n\n    public void addRequest(Request request) {\n        queue.add(request);\n    }\n\n    public void execute() {\n        //Iteration over the queue for executions\n    }\n}\n```", "```kt\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    try {\n        File httpCacheDir = new File(getCacheDir(), \"http\");\n        long httpCacheSize = 0;\n        HttpResponseCache.install(httpCacheDir, httpCacheSize);\n    } catch (IOException e) {\n        Log.i(getClass().getName(), \"HTTP response cache installation failed:\" + e);\n    }\n}\n```", "```kt\nprotected void onStop() {\n    super.onStop();\n    HttpResponseCache cache = HttpResponseCache.getInstalled();\n    if (cache != null) {\n        cache.flush();\n    }\n}\n```", "```kt\nconnection.addRequestProperty(\"Cache-Control\", POLICY);\n```", "```kt\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nlong lastModified = conn.getHeaderFieldDate(\"Last-Modified\", currentTime);\n\nif (lastModified < lastUpdateTime) {\n    // Skip\n} else {\n    // Update\n}\n```", "```kt\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.addRequestProperty(\"If-Modified-Since\", lastCheckTime);\n\ntry {\n    int statusCode = conn.getResponseCode();\n    switch (statusCode) {\n        case 200:\n            // Content has been modified\n            // Update cached content\n            // Update cached lastCheckedTime in cache\n            break;\n        case 304:\n            // Content has not been modified\n            // Get cached content\n            break;\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```", "```kt\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.setIfModifiedSince(lastCheckTime);\n\n// status code check...\n```", "```kt\npublic class Backoff {\n    private static final int BASE_DURATION = 1000;\n    private static final int[] BACK_OFF = new int[]{1, 2, 4, 8, 16, 32, 64};\n\n    public static InputStream execute(String urlString) {\n        for (int attempt = 0; attempt < BACK_OFF.length; attempt++) {\n            try {\n                URL url = new URL(urlString);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.connect();\n                return connection.getInputStream();\n            } catch (SocketTimeoutException | SSLHandshakeException e) {\n                try {\n                    Thread.sleep(BACK_OFF[attempt] * BASE_DURATION);\n                } catch (InterruptedException ex) {\n                    throw new RuntimeException(ex);\n                }\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return null;\n    }\n}\n```", "```kt\nHttpRequest request = null;\n//request initialization...\nExponentialBackOff backoff = ExponentialBackOff.builder()\n        .setInitialIntervalMillis(1000)\n        .setMaxElapsedTimeMillis(10000)\n        .setMaxIntervalMillis(10000)\n        .setMultiplier(1.5)\n        .setRandomizationFactor(0.5)\n        .build();\nrequest.setUnsuccessfulResponseHandler(new HttpBackOffUnsuccessfulResponseHandler(backoff));\nHttpResponse httpResponse = request.execute();\n//response handling...\n```", "```kt\npublic class Authenticator extends AbstractAccountAuthenticator {\n\n    public Authenticator(Context context) {\n        super(context);\n    }\n\n    @Override\n    public Bundle editProperties(AccountAuthenticatorResponse response, String accountType){return null;}\n\n    @Override\n    public Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options){return null;}\n\n    @Override\n    public Bundle confirmCredentials(AccountAuthenticatorResponse response, Account account, Bundle options){return null;}\n\n    @Override\n    public Bundle getAuthToken(AccountAuthenticatorResponse response, Account account, String authTokenType, Bundle options){return null;}\n\n    @Override\n    public String getAuthTokenLabel(String authTokenType) {return null;}\n\n    @Override\n    public Bundle updateCredentials(AccountAuthenticatorResponse response, Account account, String authTokenType, Bundle options){return null;}\n\n    @Override\n    public Bundle hasFeatures(AccountAuthenticatorResponse response, Account account, String[] features){return null;}\n}\n```", "```kt\npublic class AuthenticatorService extends Service {\n\n    private Authenticator mAuthenticator;\n    @Override\n    public void onCreate() {\n        mAuthenticator = new Authenticator(this);\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mAuthenticator.getIBinder();\n    }\n}\n```", "```kt\n<account-authenticator\n\n    android:accountType=\"accountExample\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:smallIcon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"/>\n```", "```kt\n<service\n    android:name=\".syncmanager.AuthenticatorService\">\n    <intent-filter>\n        <action android:name=\"android.accounts.AccountAuthenticator\"/>\n    </intent-filter>\n    <meta-data\n        android:name=\"android.accounts.AccountAuthenticator\"\n        android:resource=\"@xml/authenticator\" />\n</service>\n```", "```kt\npublic class SyncAdapter extends AbstractThreadedSyncAdapter {\n    ContentResolver contentResolver;\n\n    public SyncAdapter(Context context, boolean autoInitialize) {\n        super(context, autoInitialize);\n        contentResolver = context.getContentResolver();\n    }\n\n    public SyncAdapter(Context context, boolean autoInitialize, boolean allowParallelSyncs) {\n        super(context, autoInitialize, allowParallelSyncs);\n        contentResolver = context.getContentResolver();\n    }\n\n    @Override\n    public void onPerformSync(Account account, Bundle extras, String authority, ContentProviderClient provider, SyncResult syncResult) {\n        // code to execute the transfer...\n    }\n}\n```", "```kt\npublic class SyncAdapterService extends Service {\n    private static SyncAdapter syncAdapter = null;\n    private static final Object lock = new Object();\n\n    @Override\n    public void onCreate() {\n        synchronized (lock) {\n            if (syncAdapter == null) {\n                syncAdapter = new SyncAdapter(getApplicationContext(), true);\n            }\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return syncAdapter.getSyncAdapterBinder();\n    }\n}\n```", "```kt\n<sync-adapter\n\n    android:contentAuthority=\"authorityExample\"\n    android:accountType=\"accountExample\"\n    android:userVisible=\"false\"\n    android:supportsUploading=\"false\"\n    android:allowParallelSyncs=\"false\"\n    android:isAlwaysSyncable=\"true\"/>\n```", "```kt\n<service\n    android:name=\".syncmanager.SyncAdapterService\"\n    android:exported=\"true\"\n    android:process=\":sync\">\n    <intent-filter>\n        <action android:name=\"android.content.SyncAdapter\"/>\n    </intent-filter>\n    <meta-data android:name=\"android.content.SyncAdapter\"\n        android:resource=\"@xml/syncadapter\" />\n</service>\n```", "```kt\nConnectionManager.getRestrictedBackgroundStatus()\n```", "```kt\nConnectivityManager connectionManager = (ConnectivityManager)\n        getSystemService(Context.CONNECTIVITY_SERVICE);\n// Checks if the active network is a metered one\nif (connectionManager.isActiveNetworkMetered()) {\n    // Checks user's Data Saver preference.\n    switch (connectionManager.getRestrictBackgroundStatus()) {\n        case RESTRICT_BACKGROUND_STATUS_ENABLED:\n            // Data Saver is enabled and, then, the application shouldn't use the network in background\n            break;\n        case RESTRICT_BACKGROUND_STATUS_WHITELISTED:\n            // Data Saver is enabled, but the application is //whitelisted. The application should limit //the network request while the Data Saver //is enabled even if the application is whitelisted\n            break;\n        case RESTRICT_BACKGROUND_STATUS_DISABLED:\n            // Data Saver is disabled\n            break;\n    }\n} else {\n    // The active network is not a metered one.\n    // Any network request can be done\n}\n```", "```kt\npublic class DataSaverActivity extends Activity  {\n    private BroadcastReceiver dataSaverPreferenceReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            ConnectivityManager connectionManager = (ConnectivityManager)\n                    getSystemService (Context.CONNECTIVITY_SERVICE);\n            // Checks if the active network is a metered one\n            if (connectionManager.isActiveNetworkMetered()) {\n                // Checks user's Data Saver preference.\n                switch (connectionManager. getRestrictBackgroundStatus()) {\n                    case RESTRICT_BACKGROUND_STATUS_ENABLED:\n                        // Data Saver is enabled and, then, the //application shouldn't use the //network in background\n                        break;\n                    case RESTRICT_BACKGROUND_STATUS_WHITELISTED:\n                        // Data Saver is enabled, but the //application is whitelisted. The //application should limit the network //request while the Data Saver //is enabled even if the application //is whitelisted\n                        break;\n                    case RESTRICT_BACKGROUND_STATUS_DISABLED:\n                        // Data Saver is disabled\n                        break;\n                }\n            } else {\n                // The active network is not a metered one.\n                // Any network request can be done\n            }\n        }\n    };\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        IntentFilter filter = new IntentFilter(ConnectivityManager. ACTION_RESTRICT_BACKGROUND_CHANGE);\n        registerReceiver(dataSaverPreferenceReceiver, filter);\n    }\n\n    ...\n\n}\n```", "```kt\npublic class MyGcmTaskService extends GcmTaskService {\n    public static final String MY_TASK = \"myTask\";\n\n    @Override\n    public int onRunTask(TaskParams taskParams) {\n        switch (taskParams.getTag()) {\n            case MY_TASK:\n                //task code...\n                if (success)\n                    return GcmNetworkManager.RESULT_SUCCESS;\n                else\n                    return GcmNetworkManager.RESULT_RESCHEDULE;\n        }\n        return GcmNetworkManager.RESULT_SUCCESS;\n    }\n}\n```", "```kt\n<service\n    android:name=\".MyGcmTaskService\"\n    android:exported=\"true\"\n    android:permission=\"com.google.android.gms.permission. BIND_NETWORK_TASK_SERVICE\">\n    <intent-filter>\n        <action android:name=\"com.google.android.gms.gcm. ACTION_TASK_READY\" />\n    </intent-filter>\n</service>\n```", "```kt\nGcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(getApplicationContext());\n```", "```kt\n    OneoffTask task = new OneoffTask.Builder()\n            .setService(MyGcmTaskService.class)\n            .setTag(MyGcmTaskService.MY_TASK)\n            .setExecutionWindow(0, 1000L)\n            .build();\n    ```", "```kt\n    PeriodicTask task = new PeriodicTask.Builder()\n            .setService(MyGcmTaskService.class)\n            .setTag(MyGcmTaskService.MY_TASK)\n            .setPeriod(5L)\n            .build();\n    ```", "```kt\nmGcmNetworkManager.schedule(task);\n```", "```kt\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n    ```", "```kt\nemulator -netspeed <speed>\n\n```", "```kt\nnetwork speed <speed>\n\n```", "```kt\nemulator -netdelay <delay>\n\n```", "```kt\nnetwork delay <delay>\n\n```"]