- en: Chapter 4. Intents for Mobile Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 移动组件的意图
- en: 'In the last chapter, we discussed the categories of intents and how different
    categories are used. We also discussed the pros and cons of categories such as
    implicit intents and explicit intents. But besides the theory regarding the intents
    that we have been discussing until now, it''s time to discuss some applications
    of intents with a more practical approach. In this chapter, we will discuss the
    mobile components that are commonly found in all Android phones. And we will see
    how those mobile components can be accessed and used very easily via intents.
    Android provides a vast collection of libraries and features through which a developer
    can utilize mobile components. This is as easy as a walk in the park. This chapter
    mainly includes four different categories of components: visual components such
    as camera, communication components such as Wi-Fi and Bluetooth, media components
    such as video and audio recording, speech recognition and text-to-speech conversion,
    and finally, motion components such as proximity sensor. The following topics
    will be discussed in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了意图的分类以及不同类别意图的使用方法。我们还讨论了隐式意图和显式意图等类别的优缺点。但是，除了我们至今讨论的关于意图的理论之外，现在是我们讨论一些更实用的意图应用的时候了。在本章中，我们将讨论所有安卓手机中常见的移动组件，并了解如何通过意图非常容易地访问和使用这些移动组件。安卓提供了丰富的库和功能，开发者可以利用这些来使用移动组件，这就像在公园里散步一样简单。本章主要包括四类不同的组件：视觉组件如摄像头，通信组件如Wi-Fi和蓝牙，媒体组件如视频和音频录制、语音识别以及文本到语音转换，最后是运动组件，如接近传感器。本章将讨论以下主题：
- en: Common mobile components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见移动组件
- en: Components and intents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件与意图
- en: Communication components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信组件
- en: Using Bluetooth through intents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过意图使用蓝牙
- en: Using Wi-Fi through intents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过意图使用Wi-Fi
- en: Media components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体组件
- en: Taking pictures and recording video through intents
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过意图拍照和录制视频
- en: Speech recognition using intents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图进行语音识别
- en: Role of intents in text-to-speech conversion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图在文本到语音转换中的作用
- en: Motion components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动组件
- en: Proximity alerts through intents
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过意图设置接近提醒
- en: The concepts and structures of intents, as discussed in the previous chapters,
    are the prerequisites for understanding this chapter and the later chapters. If
    you don't have a basic understanding of these things, we would recommend you to
    read [Chapter 2](ch02.html "Chapter 2. Introduction to Android Intents"), *Introduction
    to Android Intents* and [Chapter 3](ch03.html "Chapter 3. Intent and Its Categorization"),
    *Intents and Its Categorization* in order to move forward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及后续章节的理解需要依赖于前几章中讨论的意图的概念和结构。如果你对这些内容没有基本的了解，我们建议你阅读[第2章](ch02.html "第2章.
    安卓意图简介")，*安卓意图简介*和[第3章](ch03.html "第3章. 意图及其分类")，*意图及其分类*，以便继续深入学习。
- en: Common mobile components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见移动组件
- en: Due to the open source nature of the Android operating system, many different
    companies such as HTC and Samsung ported the Android OS on their devices with
    many different functionalities and styles. Each Android phone is unique in some
    way or the other and possesses many unique features and components different from
    other brands and phones. But there are some components that are found to be common
    in all the Android phones.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安卓操作系统的开源性质，许多不同的公司如HTC和三星在他们的设备上移植了具有许多不同功能和风格的安卓操作系统。每款安卓手机在某种程度上都是独一无二的，拥有许多与其他品牌和手机不同的独特功能和组件。但在所有安卓手机中，有一些组件是共通的。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We are using two key terms here: components and features. **Component** is
    the hardware part of an Android phone, such as camera, Bluetooth and so on. And
    **Feature** is the software part of an Android phone, such as the SMS feature,
    E-mail feature, and so on. This chapter is all about hardware components, their
    access, and their use through intents.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了两个关键术语：组件和功能。**组件**是安卓手机的硬件部分，如摄像头、蓝牙等。而**功能**是安卓手机的软件部分，如短信功能、电子邮件功能等。本章全部关于硬件组件，以及如何通过意图访问和使用这些组件。
- en: 'These common components can be generally used and implemented independently
    of any mobile phone or model. And there is no doubt that intents are the best
    asynchronous messages to activate these Android components. These intents are
    used to trigger the Android OS when some event occurs and some action should be
    taken. Android, on the basis of the data received, determines the receiver for
    the intent and triggers it. Here are a few common components found in each Android
    phone:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通用组件可以独立于任何手机或型号进行普遍使用和实现。毫无疑问，意图是激活这些Android组件的最佳异步消息。这些意图用于在发生某些事件时应采取某些操作时触发Android操作系统。Android根据接收到的数据，确定意图的接收者并触发它。以下是每部Android手机中都存在的几个常见组件：
- en: The Wi-Fi component
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wi-Fi组件
- en: Each Android phone comes with a complete support of the Wi-Fi connectivity component.
    The new Android phones having Android Version 4.1 and above support the Wi-Fi
    Direct feature as well. This allows the user to connect to nearby devices without
    the need to connect with a hotspot or network access point.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每部Android手机都配备了完整的Wi-Fi连接组件支持。具有Android版本4.1及以上的新Android手机还支持Wi-Fi Direct功能。这使得用户无需连接热点或网络接入点即可连接到附近的设备。
- en: The Bluetooth component
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝牙组件
- en: An Android phone includes Bluetooth network support that allows the users of
    Android phones to exchange data wirelessly in low range with other devices. The
    Android application framework provides developers with the access to Bluetooth
    functionality through Android Bluetooth APIs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Android手机包括蓝牙网络支持，允许Android手机用户与其他设备在低范围内无线交换数据。Android应用程序框架为开发者提供了通过Android蓝牙API访问蓝牙功能的方法。
- en: The Cellular component
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蜂窝组件
- en: No mobile phone is complete without a cellular component. Each Android phone
    has a cellular component for mobile communication through SMS, calls, and so on.
    The Android system provides very high, flexible APIs to utilize telephony and
    cellular components to create very interesting and innovative apps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 没有手机是不完整的，每个Android手机都有一个用于通过短信、通话等进行移动通信的蜂窝组件。Android系统提供了非常高级、灵活的API来利用电话和蜂窝组件创建非常有趣和创新的应用程序。
- en: Global Positioning System (GPS) and geo-location
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球定位系统（GPS）和地理位置
- en: GPS is a very useful but battery-consuming component in any Android phone. It
    is used for developing location-based apps for Android users. Google Maps is the
    best feature related to GPS and geo-location. Developers have provided so many
    innovative apps and games utilizing Google Maps and GPS components in Android.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GPS是任何Android手机中非常有用但耗电的组件。它用于为Android用户开发基于位置的应用程序。谷歌地图是与GPS和地理位置相关的最佳功能。开发者已经提供了许多利用谷歌地图和Android中的GPS组件的创新应用程序和游戏。
- en: The Geomagnetic field component
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地磁场组件
- en: Geomagnetic field component is found in most Android phones. This component
    is used to estimate the magnetic field of an Android phone at a given point on
    the Earth and, in particular, to compute magnetic declination from the North.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 地磁场组件在大多数Android手机中都可以找到。此组件用于估计在地球给定点的Android手机的磁场，特别是计算从北磁偏角。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The geomagnetic field component uses the **World Magnetic Model** produced by
    United States National Geospatial-Intelligence Agency. The current model that
    is being used for the geomagnetic field is valid until 2015\. Newer Android phones
    will have the newer version of the geomagnetic field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 地磁场的组件使用由美国国家地理空间情报局生产的**世界磁模**。目前用于地磁场的模型有效期至2015年。较新的Android手机将拥有地磁场的新版本。
- en: Sensor components
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传感器组件
- en: 'Most Android devices have built-in sensors that measure motion, orientation,
    environment conditions, and so on. These sensors sometimes act as the brains of
    the app. For example, they take actions on the basis of the mobile''s surrounding
    (weather) and allow users to have an automatic interaction with the app. These
    sensors provide raw data with high precision and accuracy for measuring the respective
    sensor values. For example, gravity sensor can be used to track gestures and motions,
    such as tilt, shake, and so on, in any app or game. Similarly, a temperature sensor
    can be used to detect the mobile temperature, or a geomagnetic sensor (as introduced
    in the previous section) can be used in any travel application to track the compass
    bearing. Broadly, there are three categories of sensors in Android: motion, position,
    and environmental sensors. The following subsections discuss these types of sensors
    briefly.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Android设备内置有测量运动、方向、环境条件等的传感器。这些传感器有时充当应用的大脑。例如，它们根据手机的周围环境（天气）采取行动，并允许用户与应用自动互动。这些传感器为测量相应传感器值提供高精度和准确性的原始数据。例如，重力传感器可以用于在任何应用或游戏中追踪手势和动作，如倾斜、震动等。同样，温度传感器可以用来检测手机温度，或者如前所述的地磁传感器可以在任何旅行应用中使用来追踪指南针方位。总的来说，Android中有三大类传感器：运动传感器、位置传感器和环境传感器。以下小节将简要讨论这些类型的传感器。
- en: Motion sensors
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运动传感器
- en: Motion sensors let the Android user monitor the motion of the device. There
    are both hardware-based sensors such as accelerometer, gyroscope, and software-based
    sensors such as gravity, linear acceleration, and rotation vector sensors. Motion
    sensors are used to detect a device's motion including tilt effect, shake effect,
    rotation, swing, and so on. If used properly, these effects can make any app or
    game very interesting and flexible, and can prove to provide a great user experience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运动传感器允许Android用户监控设备的运动。既有基于硬件的传感器，如加速度计、陀螺仪，也有基于软件的传感器，如重力、线性加速度和旋转矢量传感器。运动传感器用于检测设备的运动，包括倾斜效果、震动效果、旋转、摆动等。如果使用得当，这些效果可以使任何应用或游戏变得非常有趣和灵活，并能证明提供极佳的用户体验。
- en: Position sensors
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置传感器
- en: The two position sensors, geomagnetic sensor and orientation sensor, are used
    to determine the position of the mobile device. Another sensor, the proximity
    sensor, lets the user determine how close the face of a device is to an object.
    For example, when we get any call on an Android phone, placing the phone on the
    ear shuts off the screen, and when we hold the phone back in our hands, the screen
    display appears automatically. This simple application uses the proximity sensor
    to detect the ear (object) with the face of the device (the screen).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两个位置传感器，地磁传感器和方向传感器，用于确定移动设备的位置。另一个传感器，近距离传感器，允许用户确定设备的面部与物体的距离有多近。例如，当我们在Android手机上接到任何电话时，将手机放在耳朵上会关闭屏幕，当我们把手机拿回手中时，屏幕显示会自动出现。这个简单的应用使用近距离传感器来检测耳朵（物体）与设备面部（屏幕）的接触。
- en: Environmental sensors
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境传感器
- en: These sensors are not used much in Android apps, but used widely by the Android
    system to detect a lot of little things. For example, the temperature sensor is
    used to detect the temperature of the phone, and can be used in saving the battery
    and mobile life.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传感器在Android应用中使用不多，但被Android系统广泛用于检测许多小事物。例如，温度传感器用于检测手机的温度，并可用于节省电池和延长手机寿命。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, the Samsung Galaxy S4 Android phone has been
    launched. The phone has shown a great use of environmental gestures by allowing
    users to perform actions such as making calls by no-touch gestures such as moving
    your hand or face in front of the phone.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，三星Galaxy S4 Android手机已经发布。该手机通过允许用户通过无需触摸的手势，如移动手或脸在手机前执行操作，展现了环境手势的极大使用，例如拨打电话。
- en: Components and intents
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件和意图
- en: Android phones contain a large number of components and features. This becomes
    beneficial to both Android developers and users. Android developers can use these
    mobile components and features to customize the user experience. For most components,
    developers get two options; either they extend the components and customize those
    according to their application requirements, or they use the built-in interfaces
    provided by the Android system. We won't read about the first choice of extending
    components as it is beyond the scope of this book. However, we will study the
    other option of using built-in interfaces for mobile components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android手机包含大量的组件和功能。这对Android开发者和用户都有利。Android开发者可以使用这些移动组件和功能来定制用户体验。对于大多数组件，开发者有两个选择；他们可以扩展组件并根据应用程序需求进行定制，或者使用Android系统提供的内置接口。由于扩展组件超出了本书的范围，我们不会讨论第一个选择。但是，我们将研究使用移动组件的内置接口的另一种选择。
- en: 'Generally, to use any mobile component from our Android app, the developers
    send intents to the Android system and then Android takes the action accordingly
    to call the respective component. As we have discussed earlier, intents are asynchronous
    messages sent to the Android OS to perform any functionality. Most of the mobile
    components can be triggered by intents just by using a few lines of code and can
    be utilized fully by developers in their apps. In the following sections of this
    chapter, we will see few components and how they are used and triggered by intents
    with practical examples. We have divided the components in three ways: communication
    components, media components, and motion components. Now, let''s discuss these
    components in the following sections.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了从我们的Android应用程序中使用任何移动组件，开发者会向Android系统发送意图，然后Android根据意图调用相应的组件。正如我们之前所讨论的，意图是发送给Android操作系统的异步消息，以执行任何功能。大多数移动组件只需使用几行代码就可以通过意图触发，并且开发者可以在他们的应用程序中充分利用这些组件。在本章的以下部分，我们将通过实际示例看到一些组件以及如何通过意图使用和触发它们。我们将组件分为三种方式：通信组件、媒体组件和运动组件。现在，让我们在以下各节中讨论这些组件。
- en: Communication components
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信组件
- en: Any mobile phone's core purpose is communication. Android phones provide a lot
    of features other than communication features. Android phones contain SMS/MMS,
    Wi-Fi, and Bluetooth for communication purposes. This chapter focuses on the hardware
    components; so, we will discuss only Wi-Fi and Bluetooth in this chapter. The
    Android system provides built-in APIs to manage and use Bluetooth devices, settings,
    discoverability, and much more. It offers full network APIs not only for Bluetooth
    but also for Wi-Fi, hotspots, configuring settings, Internet connectivity, and
    much more. More importantly, these APIs and components can be used very easily
    by writing few lines of code through intents. We will start by discussing Bluetooth,
    and how we can use Bluetooth through intents in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何手机的核心用途都是通信。除了通信功能外，Android手机还提供了许多其他功能。Android手机包含用于通信目的的短信/彩信、Wi-Fi和蓝牙。本章关注硬件组件；因此，我们将在本章中仅讨论Wi-Fi和蓝牙。Android系统提供了内置API来管理和使用蓝牙设备、设置、可发现性等。它不仅为蓝牙，也为Wi-Fi、热点、配置设置、互联网连接等提供了完整的网络API。更重要的是，通过意图编写少量代码，可以非常容易地使用这些API和组件。我们将从讨论蓝牙开始，在下一节中，我们将介绍如何通过意图使用蓝牙。
- en: Using Bluetooth through intents
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过意图使用蓝牙
- en: Bluetooth is a communication protocol that is designed for short-range, low-bandwidth,
    peer-to-peer communication. In this section, we will discuss how to interact and
    communicate with local Bluetooth devices and how we can communicate with the nearby,
    remote devices using Bluetooth. Bluetooth is a very low-range protocol, but it
    can be used to transmit and receive data such as files, media, and so on. As of
    Android 2.1, only paired devices can communicate with each other via Bluetooth
    devices due to encryption of the data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙是一种通信协议，旨在实现短距离、低带宽的点对点通信。在本节中，我们将讨论如何与本地蓝牙设备进行交互和通信，以及如何通过蓝牙与附近的远程设备进行通信。蓝牙是一种非常短距离的协议，但可以用来传输和接收文件、媒体等数据。由于数据加密，截至Android
    2.1版本，只有配对的设备才能通过蓝牙设备相互通信。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bluetooth APIs and libraries became available from Android 2.0 Version (SDK
    API Level 5). It should also be noted that not all Android phones will necessarily
    include the Bluetooth hardware.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 2.0版本（SDK API级别5）开始，蓝牙API和库变得可用。还应该注意的是，并非所有Android手机都必然包含蓝牙硬件。
- en: The Bluetooth API provided by the Android system is used to perform a lot of
    actions related to Bluetooth that includes turning the Bluetooth on/off, pairing
    with nearby devices, communicating with other Bluetooth devices, and much more.
    But, not all of these actions can be performed through intents. We will discuss
    only those actions that can be performed through intents. These actions include
    setting the Bluetooth On/Off from our Android app, tracking the Bluetooth adapter
    state, and making our device discoverable for a small time. The actions that can't
    be performed through intents include sending data and files to other Bluetooth
    devices, pairing with other devices, and so on. Now, let's explain these actions
    one by one in the following sections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统提供的蓝牙API用于执行许多与蓝牙相关的操作，包括打开/关闭蓝牙、与附近设备配对、与其他蓝牙设备通信等等。但并非所有这些操作都可以通过意图执行。我们将仅讨论那些可以通过意图执行的操作。这些操作包括从我们的安卓应用中设置蓝牙的开启/关闭、跟踪蓝牙适配器状态以及使我们的设备在短时间内可被发现。无法通过意图执行的操作包括向其他蓝牙设备发送数据和文件、与其他设备配对等。接下来，让我们在以下各节中逐一解释这些操作。
- en: Some Bluetooth API classes
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一些蓝牙API类
- en: In this section, we will discuss some classes from the Android Bluetooth API
    that are used in all Android apps using Bluetooth. Understanding these classes
    will help the developers understand the following examples more easily.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论安卓蓝牙API中一些在所有使用蓝牙的安卓应用中都会用到的类。理解这些类将帮助开发者更容易理解以下示例。
- en: BluetoothDevice
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BluetoothDevice
- en: 'This class represents each remote device with which the user is communicating.
    This class is a thin wrapper for the Bluetooth hardware of the phone. To perform
    the operations on the object of this class, developers have to use the `BluetoothAdapter`
    class. The objects of this class are immutable. We can get `BluetoothDevice` by
    calling `BluetoothAdapter.getRemoteDevice(String macAddress)` and passing the
    MAC address of any device. Some important methods of this class are:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表与用户通信的每个远程设备。这个类是对手机蓝牙硬件的薄封装。要对此类的对象执行操作，开发者必须使用`BluetoothAdapter`类。这个类的对象是不可变的。我们可以通过调用`BluetoothAdapter.getRemoteDevice(String
    macAddress)`并传递任何设备的MAC地址来获取`BluetoothDevice`。这个类的一些重要方法包括：
- en: '`BluetoothDevice.getAddress()`: It returns the MAC address of the current device.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BluetoothDevice.getAddress()`: 它返回当前设备的MAC地址。'
- en: '`BluetoothDevice.getBondState()`: It returns the bonding state of the current
    device, such as not bonded, bonding, or bonded.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BluetoothDevice.getBondState()`: 该方法返回当前设备的绑定状态，例如未绑定、正在绑定或已绑定。'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **MAC address** is a string of 12 characters represented in the form of
    xx:xx:xx:xx:xx:xx. For example, 00:11:22:AA:BB:CC.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAC地址**是一个由12个字符组成的字符串，以xx:xx:xx:xx:xx:xx的格式表示。例如，00:11:22:AA:BB:CC。'
- en: BluetoothAdapter
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BluetoothAdapter
- en: This class represents the current device on which our Android app is running.
    It should be noted that the `BluetoothAdapter` class represents the current device,
    and the `BluetoothDevice` class represents the other devices that can or cannot
    bonded with our device. This class is a singleton class and cannot be instantiated.
    To get the object of this class, we can use the `BluetoothAdapter.getDefaultAdapter()`
    method. To perform any action related to Bluetooth communication, this class is
    the main starting point for it. Some of the methods of this class include `BluetoothAdapter.getBondedDevices()`,
    which returns all paired devices, `BluetoothAdapter.startDiscovery()`, which searches
    for all discoverable devices nearby, and so on. There is a method called `startLeScan(BluetoothAdapter.LeScanCallback
    callback)` that is used to receive a callback whenever a device is discovered.
    This method was introduced in API Level 18.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表当前运行我们安卓应用的设备。需要注意的是，`BluetoothAdapter`类代表当前设备，而`BluetoothDevice`类代表其他可能与我们的设备配对或未配对的设备。这个类是一个单例类，不能被实例化。要获取这个类的对象，我们可以使用`BluetoothAdapter.getDefaultAdapter()`方法。要执行与蓝牙通信相关的任何操作，这个类是主要的起点。这个类的一些方法包括`BluetoothAdapter.getBondedDevices()`，它返回所有已配对的设备，`BluetoothAdapter.startDiscovery()`，它搜索附近所有可发现的设备等等。还有一个名为`startLeScan(BluetoothAdapter.LeScanCallback
    callback)`的方法，用于在发现设备时接收回调。这个方法在API级别18中引入。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the methods in the `BluetoothAdapter` and `BluetoothDevice` classes
    require the `BLUETOOTH` permission, and some require the `BLUETOOTH_ADMIN` permission
    as well. So, when using these classes in your app, don't forget to add these permissions
    in your Android manifest file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`BluetoothAdapter` 和 `BluetoothDevice` 类中的某些方法需要 `BLUETOOTH` 权限，有些还需要 `BLUETOOTH_ADMIN`
    权限。因此，当在您的应用中使用这些类时，不要忘记在Android清单文件中添加这些权限。'
- en: So far, we have discussed some Bluetooth classes in the Android OS along with
    some of the methods in those classes. In the next section, we will develop our
    first Android app that will ask the user to turn on the Bluetooth.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Android OS中的一些蓝牙类以及这些类中的某些方法。在下一节中，我们将开发我们的第一个Android应用，它将要求用户打开蓝牙。
- en: Turning on the Bluetooth app
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开蓝牙应用
- en: To perform any Bluetooth action, Bluetooth must first be turned on. So, in this
    section, we will develop an Android app that will ask the user to turn on the
    Bluetooth device if it is not already on. The user can accept it and the Bluetooth
    will be turned on, or the user can also reject it. In the latter case, the application
    will continue and the Bluetooth will remain in the off state. It would be great
    to say that this action can be performed very easily using intents. Let's see
    how we can do this by looking at the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行任何蓝牙操作，必须先打开蓝牙。因此，在本节中，我们将开发一个Android应用，如果蓝牙设备尚未打开，它会要求用户打开蓝牙设备。用户可以接受并打开蓝牙，或者用户也可以拒绝。在后一种情况下，应用程序将继续运行，而蓝牙将保持关闭状态。可以说，使用意图可以非常容易地执行此操作。让我们通过查看代码来看看如何做到这一点。
- en: First, create an empty Android project in your favourite IDE. We have developed
    it in Android Studio. At the time of writing this book, the project is in the
    Preview Mode, and its beta launch is expected soon. Now, we will modify a few
    files from the project to make our Android Bluetooth app. We will modify two files.
    Let's see those files in the following sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您喜欢的IDE中创建一个空的Android项目。我们是在Android Studio中开发的。在撰写这本书的时候，项目处于预览模式，预计不久将进行测试版发布。现在，我们将修改项目中的几个文件，以创建我们的Android蓝牙应用。我们将修改两个文件。让我们在以下章节中看看这些文件。
- en: The MainActivity.java file
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MainActivity.java 文件
- en: 'This class represents the main activity of our Android app. The following code
    is implemented in this class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表我们Android应用的主活动。以下代码是在此类别中实现的：
- en: '![The MainActivity.java file](img/9639_04_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java文件](img/9639_04_01.jpg)'
- en: In our activity, we have declared a constant value with the name `BLUETOOTH_REQUEST_CODE`.
    This constant is used as a request code or request unique identifier in the communication
    between our app and the Android system. When we request the Android OS to perform
    some action, we pass any request code. Then, the Android system performs the action
    and returns the same request code back to us. After comparing our request code
    with Android's request code, we get to know about the action that has been performed.
    If the code doesn't match, it means that this action is for some other request.
    It is not our request. In the `onCreate()` method, we set the layout of the activity
    by calling the `setContentView()` method. And then, we perform our real task in
    the next few lines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的活动中，我们声明了一个名为 `BLUETOOTH_REQUEST_CODE` 的常量值。这个常量作为请求代码或请求唯一标识符，在我们的应用与Android系统之间的通信中使用。当我们请求Android操作系统执行某些操作时，我们会传递任何请求代码。然后，Android系统执行操作并将相同的请求代码返回给我们。通过比较我们的请求代码与Android的请求代码，我们就可以知道已执行的操作。如果代码不匹配，则意味着此操作是针对其他请求的，不是我们的请求。在
    `onCreate()` 方法中，我们通过调用 `setContentView()` 方法设置活动的布局。然后，在接下来的几行中，我们执行实际的任务。
- en: We create a string `enableBT` that gets the value of the `ACTION_REQUEST_ENABLE`
    method that pertains to the `BluetoothAdapter` class. This string is passed in
    the intent constructor to tell the intent that it is meant to enable the Bluetooth
    device. Like the Bluetooth-enable request string, the Android OS also contains
    many other requests for various actions such as Wi-Fi, Sensors, Camera, and more.
    In this chapter, we will learn about a few request strings. After creating the
    request string, we create our intent and pass the request string to it. And then,
    we start our intent by passing it in the `startActivityForResult()` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个字符串`enableBT`，它获取与`BluetoothAdapter`类相关的`ACTION_REQUEST_ENABLE`方法的值。这个字符串在意图构造函数中传递，以告诉意图它的目的是启用蓝牙设备。与蓝牙启用请求字符串一样，安卓操作系统还包含许多其他请求，用于各种动作，如Wi-Fi、传感器、相机等。在本章中，我们将了解一些请求字符串。在创建请求字符串之后，我们创建我们的意图，并将请求字符串传递给它。然后，我们通过在`startActivityForResult()`方法中传递它来启动我们的意图。
- en: 'One thing to note here is that in the previous chapters, we used the `startActivity()`
    method instead of the `startActivityForResult()` method. Basically, the `startActivity()`
    method just starts any activity that is passed through intents, but the `startActivityForResult()`
    method starts any activity, and after performing some action, it returns to the
    original activity and presents the results of the action. So, in this example,
    we called the activity that requests the Android system to enable the Bluetooth
    device. The Android system performs the action and asks the user whether it should
    enable the device or not. Then, the Android system returns the result to the original
    activity that started the intent earlier. To get any result from other activities
    to our activity, we override the `onActivityResult()` method. This method is called
    after returning from other activities. The method contains three parameters: `requestCode`,
    `resultCode`, and `dataIntent`. The `requestCode` parameter is an integer value
    and contains the request code value of the request provided by the developer.
    The `resultCode` parameter is the result of the action. It tells the developer
    whether the action has been performed successfully with a positive response or
    with a negative response. The `dataIntent` object contains the original calling-intent
    data, such as which activity started the intent and all the related information.
    Now, let''s see our overridden method in detail. We have first checked whether
    `requestCode`, our request code, is `BLUETOOTH_REQUEST_CODE`, or not. If both
    are the same, we have compared the result code to check whether our result is
    okay or not. If it is okay, it means that Bluetooth has been enabled; so, we display
    a toast notifying the user about it, and if the result is not okay, that means
    Bluetooth has not been enabled. Here also we notify the user by displaying a toast.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在之前的章节中，我们使用了`startActivity()`方法，而没有使用`startActivityForResult()`方法。基本上，`startActivity()`方法仅通过意图启动任何活动，但`startActivityForResult()`方法启动任何活动，在执行某些操作后，它会返回到原始活动并呈现操作结果。因此，在这个例子中，我们调用了请求安卓系统启用蓝牙设备的活动。安卓系统执行操作并询问用户是否应该启用设备。然后，安卓系统将结果返回给之前启动意图的原始活动。为了从其他活动获取任何结果到我们的活动，我们重写了`onActivityResult()`方法。此方法在从其他活动返回后调用。该方法包含三个参数：`requestCode`、`resultCode`和`dataIntent`。`requestCode`参数是一个整数值，包含开发者提供的请求代码值。`resultCode`参数是操作的结果。它告诉开发者操作是否已成功执行，是正面响应还是负面响应。`dataIntent`对象包含原始调用意图数据，例如哪个活动启动了意图以及所有相关信息。现在，让我们详细看看我们重写的方法。我们首先检查`requestCode`，我们的请求代码，是否为`BLUETOOTH_REQUEST_CODE`。如果两者相同，我们比较结果代码以检查我们的结果是否正常。如果正常，这意味着蓝牙已被启用；因此，我们显示一个通知用户关于它的吐司，如果结果不正常，这意味着蓝牙尚未启用。这里我们也通过显示吐司来通知用户。
- en: This was the activity class that performs the core functionality of our Bluetooth-enabling
    app. Now, let's see the Android manifest file in the following section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是执行我们蓝牙启用应用核心功能的活动类。现在，让我们在下一节中看看Android的清单文件。
- en: The AndroidManifest.xml file
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: 'The AndroidManifest.xml file contains all the necessary settings and preferences
    for the app. The following is the code contained in this manifest file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件包含应用的所有必要设置和偏好。以下是此清单文件中包含的代码：
- en: '![The AndroidManifest.xml file](img/9639_04_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_04_02.jpg)'
- en: 'Any Android application that uses the Bluetooth device must have the permission
    of Bluetooth usage. So, to provide the permission to the user, the developer declares
    the `<uses-permission>` tag in the Android manifest file and writes the necessary
    permissions. As shown in the code, we have provided two permissions: `android.permission.BLUETOOTH`
    and `android.permission.BLUETOOTH_ADMIN`. For most Bluetooth-enabled apps, only
    the `BLUETOOTH` permission does most of the work. The `BLUETOOTH_ADMIN` permission
    is only for those apps that use Bluetooth admin settings such as making the device
    discoverable, searching for other devices, pairing, and so on. When the user first
    installs the application, he is provided with details about which permissions
    are needed for the app. If the user accepts and grants the permissions to the
    app, the app gets installed; otherwise, the user can''t install the app. The rest
    of the file is the same as in the other examples in the book.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用蓝牙设备的Android应用都必须有使用蓝牙的权限。因此，为了向用户提供权限，开发者会在Android清单文件中声明`<uses-permission>`标签，并写入必要的权限。如代码所示，我们提供了两个权限：`android.permission.BLUETOOTH`和`android.permission.BLUETOOTH_ADMIN`。对于大多数启用蓝牙的应用，仅`BLUETOOTH`权限就可以完成大部分工作。`BLUETOOTH_ADMIN`权限仅适用于那些使用蓝牙管理设置的应用，例如使设备可被发现、搜索其他设备、配对等。当用户首次安装应用程序时，他会收到有关应用程序需要哪些权限的详细信息。如果用户接受并授予应用权限，应用将被安装；否则，用户无法安装应用。文件的其余部分与书中其他示例中的相同。
- en: 'After discussing the Android manifest and activity files, we would test our
    project by compiling and running it. When we run the project, we should see the
    screens as shown in the following screenshots:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了Android清单和活动文件之后，我们将通过编译和运行项目来测试我们的项目。当我们运行项目时，我们应该看到如下截图所示的屏幕：
- en: '![The AndroidManifest.xml file](img/9639_04_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_04_03.jpg)'
- en: Enabling Bluetooth App
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 启用蓝牙应用
- en: As the app starts, the user is presented with a dialog to enable or disable
    the Bluetooth device. If the user chooses **Yes**, the Bluetooth is turned on,
    and a toast updates the status by displaying the status of the Bluetooth.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动时，用户会看到一个对话框，以启用或禁用蓝牙设备。如果用户选择**是**，蓝牙将被打开，并且一个提示会通过显示蓝牙状态来更新状态。
- en: Tracking the Bluetooth adapter state
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跟踪蓝牙适配器状态
- en: In the previous example, we saw how we can turn on the Bluetooth device just
    by passing the intent of the Bluetooth request to the Android system in just a
    few lines. But enabling and disabling the Bluetooth are time-consuming and asynchronous
    operations. So, instead of polling the state of the Bluetooth adapter, we can
    use a broadcast receiver for the state change. In this example, we will see how
    we can track the Bluetooth state using intents in a broadcast receiver.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何仅通过将蓝牙请求的意图传递给Android系统，在几行代码内打开蓝牙设备。但是启用和禁用蓝牙是耗时的异步操作。因此，我们可以使用广播接收器来监听状态变化，而不是轮询蓝牙适配器的状态。在这个示例中，我们将看到如何使用广播接收器中的意图来跟踪蓝牙状态。
- en: This example is the extension of the previous example, and we will use the same
    code and add a new code to it. Let's look at the code now. We have three files,
    `MainActivity.java`, `BluetoothStateReceiver.java`, and `AndroidManifest.xml`.
    Let's discuss these files one by one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是之前示例的扩展，我们将使用相同的代码并添加新的代码。现在让我们看看代码。我们有三个文件，`MainActivity.java`，`BluetoothStateReceiver.java`和`AndroidManifest.xml`。让我们逐一讨论这些文件。
- en: The MainActivity.java file
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MainActivity.java文件
- en: 'This class represents the main activity of our Android app. The following code
    is implemented in this class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示我们Android应用的主活动。以下代码在这个类中实现：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the code, it is clear that the code is almost the same as in the previous
    example. The only difference is that we have added one line after setting the
    content view of the activity. We called the `registerReceiver()` method that registers
    any broadcast receiver with the Android system programmatically. We can also register
    the receivers via XML by declaring them in the Android manifest file. A broadcast
    receiver is used to receive the broadcasts sent from the Android system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，这段代码与之前的示例几乎相同。唯一的区别是在设置活动的内容视图后，我们增加了一行代码。我们调用了`registerReceiver()`方法，它以编程方式向Android系统注册任何广播接收器。我们也可以通过在Android清单文件中声明它们，通过XML注册接收器。广播接收器用于接收来自Android系统的广播。
- en: While performing general actions such as turning the Bluetooth on, turning the
    Wi-Fi on/off and so on, the Android system sends broadcast notifications that
    can be used by developers to detect the state changes in the mobile. There are
    two types of broadcasts. Normal broadcasts are completely asynchronous. The receivers
    of these broadcasts run in a disorderly manner, and multiple receivers can receive
    broadcasts at the same time. These broadcasts are more efficient as compared to
    the other type of broadcasts that are ordered broadcasts. Ordered broadcasts are
    sent to one receiver at a time. As each receiver receives the results, it passes
    the results to the next receiver or completely aborts the broadcast. In this case,
    other receivers don't receive the broadcast.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行诸如打开蓝牙、打开/关闭Wi-Fi等常规操作时，安卓系统会发送广播通知，开发者可以利用这些通知来检测手机状态的变化。有两种类型的广播。正常广播是完全异步的。这些广播的接收者以无序的方式运行，多个接收者可以同时接收广播。与另一种类型的有序广播相比，这些广播更有效。有序广播一次发送给一个接收者。每个接收者收到结果后，它会将结果传递给下一个接收者或完全终止广播。在这种情况下，其他接收者不会收到广播。
- en: Although the `Intent` class is used for sending and receiving broadcasts, the
    intent broadcast is a completely different mechanism and is separate from the
    intents used in the `startActivity()` method. There is no way for the broadcast
    receiver to see or capture the intents used with the `startActivity()` method.
    The main difference between these two intent mechanisms is that the intents used
    in the `startActivity()` method perform the foreground operation that the user
    is currently engaged in. However, the intent used with the broadcast receivers
    performs some background operations that the user is not aware of.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Intent`类用于发送和接收广播，但意图广播是一种完全不同的机制，并且与`startActivity()`方法中使用的意图是分开的。广播接收器无法查看或捕获与`startActivity()`方法一起使用的意图。这两种意图机制之间的主要区别在于，`startActivity()`方法中使用的意图执行用户当前正在进行的前台操作。然而，与广播接收器一起使用的意图执行一些用户不知道的后台操作。
- en: In our activity code, we used the `registerReceiver()` method to register an
    object of our customized broadcast receiver defined in the `BluetoothStateReceiver`
    class, and we passed an intent filter `BluetoothAdapter.ACTION_STATE_CHANGED`
    according to the type of the receiver. This state tells the intent filter that
    our object of the broadcast receiver is used in detecting the Bluetooth state
    change in the app. After the Register receiver, we created an intent passing `BluetoothAdapter.ACTION_REQUEST_ENABLE`,
    telling the app to turn on the Bluetooth. Finally, we start our action by calling
    `startActivityForResult()`, and we compare the results in the `onActivityResult()`
    method to see whether the Bluetooth is turned on or not. You can read about these
    processes in the previous example of this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的活动代码中，我们使用了`registerReceiver()`方法来注册在`BluetoothStateReceiver`类中定义的自定义广播接收器对象，并且我们根据接收器的类型传递了一个意图过滤器`BluetoothAdapter.ACTION_STATE_CHANGED`。这个状态告诉意图过滤器，我们的广播接收器对象用于检测应用中蓝牙状态的变化。注册接收器后，我们创建了一个意图，传递`BluetoothAdapter.ACTION_REQUEST_ENABLE`，告诉应用打开蓝牙。最后，我们通过调用`startActivityForResult()`启动我们的操作，并在`onActivityResult()`方法中比较结果，以查看是否打开了蓝牙。你可以在本章的上一示例中阅读这些过程。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: When you register the receiver in the `onCreate()` or `onResume()` method of
    the activity, you should unregister it in the `onPause()` or `onDestroy()` method.
    The advantage of this approach is that you won't receive any broadcasts when the
    app is paused or closed, and this can decrease Android's unnecessary overhead
    operations resulting in a better battery life.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在活动的`onCreate()`或`onResume()`方法中注册接收器时，你应在`onPause()`或`onDestroy()`方法中注销它。这种方法的好处是，当应用暂停或关闭时，你不会收到任何广播，这可以减少安卓不必要的开销操作，从而提高电池寿命。
- en: Now, let's see the code of our customized broadcast receiver class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们自定义的广播接收器类的代码。
- en: The BluetoothStateReceiver.java file
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: BluetoothStateReceiver.java文件
- en: 'This class represents our customized broadcast receiver that tracks the state
    change in the Bluetooth device. The following code shows the implementation of
    the file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示我们的自定义广播接收器，用于跟踪蓝牙设备的状态变化。以下代码显示了该文件的实现：
- en: '![The BluetoothStateReceiver.java file](img/9639_04_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![BluetoothStateReceiver.java文件](img/9639_04_05.jpg)'
- en: Just as we did for activities and services, to create a custom broadcast receiver,
    we extend from the `BroadcastReceiver` class and override methods to declare the
    custom behavior. We have overridden the `onReceive()` method and performed the
    main functionality of tracking the Bluetooth device status in this method. First,
    we will create a string variable to store the string value of the current state.
    To retrieve the string value, we have used `BluetoothAdapter.EXTRA_STATE`. Now,
    we can pass this value in the `get()` method of the intent to get our required
    data. As our states are integers and also extras, we have called `Intent.getIntExtra()`
    and passed our required string in it along with its default value as `-1`. Now,
    as we have got the current state code, we can compare these codes with the pre-defined
    codes in `BluetoothAdapter` to see the state of the Bluetooth device. There are
    four predefined states.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对活动和服务的操作一样，要创建自定义广播接收器，我们需要从`BroadcastReceiver`类继承并重写方法以声明自定义行为。我们重写了`onReceive()`方法，并在该方法中执行了跟踪蓝牙设备状态的主要功能。首先，我们将创建一个字符串变量来存储当前状态的字符串值。为了获取字符串值，我们使用了`BluetoothAdapter.EXTRA_STATE`。现在，我们可以将这个值传递给意图的`get()`方法来获取我们需要的数据。由于我们的状态是整数并且也是额外的信息，我们调用了`Intent.getIntExtra()`并在其中传递了我们需要的字符串以及默认值`-1`。现在，既然我们已经得到了当前状态码，我们可以将这些码与`BluetoothAdapter`中预定义的码进行比较，以查看蓝牙设备的状态。有四个预定义的状态。
- en: '`STATE_TURNING_ON`: This state notifies the user that the Bluetooth turn-on
    operation is in progress.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATE_TURNING_ON`：此状态通知用户蓝牙正在打开的操作正在进行中。'
- en: '`STATE_ON`: This state notifies the user that Bluetooth has already been turned
    on.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATE_ON`：此状态通知用户蓝牙已经打开。'
- en: '`STATE_TURNING_OFF`: This state notifies the user that the Bluetooth device
    is being turned off.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATE_TURNING_OFF`：此状态通知用户蓝牙设备正在关闭。'
- en: '`STATE_OFF`: This state notifies the user that the Bluetooth has been turned
    off.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATE_OFF`：此状态通知用户蓝牙已经关闭。'
- en: We compare our state with these constants, and display a toast according to
    the result we get.The Android manifest file is the same as in the previous example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前状态与这些常量进行比较，并根据得到的结果显示提示信息。Android的清单文件与之前的示例相同。
- en: 'Thus, in a nutshell, we discussed how we can enable the Bluetooth device and
    ask the user to turn it on or off through intents. We also saw how to track the
    state of the Bluetooth operations using intents in the broadcast receiver and
    displaying the toasts. The following screenshots show the application demo:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，我们讨论了如何启用蓝牙设备，并通过意图让用户打开或关闭它。我们还看到了如何在广播接收器中使用意图跟踪蓝牙操作的状态并显示提示信息。以下屏幕截图显示了应用程序的演示：
- en: '![The BluetoothStateReceiver.java file](img/9639_04_06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![BluetoothStateReceiver.java文件](img/9639_04_06.jpg)'
- en: Enabling the Bluetooth app
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 启用蓝牙应用
- en: Being discoverable
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置为可发现
- en: So far, we have only been interacting with Bluetooth by turning it on or off.
    But, to start communication via Bluetooth, one's device must be discoverable to
    start pairing. We will not create any example for this application of intents,
    but we will only explain how this can be done via intents. To turn on Bluetooth,
    we used the `BluetoothAdapter.ACTION_REQUEST_ENABLE` intent. We passed the intent
    in the `startActivityForResult()` method and checked the result in the `onActivityResult()`
    method. Now, to make the device discoverable, we can pass the `BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE`
    string in the intent. And then, we pass this intent in the `startActivityForResult()`
    method, and track the result in the `onActivityResult()` method to compare the
    results.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅通过打开或关闭与蓝牙进行交互。但是，要通过蓝牙开始通信，一个设备必须设置为可发现以开始配对。我们不会为此意图的应用创建任何示例，但只会解释如何通过意图完成这一操作。要打开蓝牙，我们使用了`BluetoothAdapter.ACTION_REQUEST_ENABLE`意图。我们将意图传递给`startActivityForResult()`方法，并在`onActivityResult()`方法中检查结果。现在，要使设备可发现，我们可以在意图中传递`BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE`字符串。然后，我们将此意图传递给`startActivityForResult()`方法，并在`onActivityResult()`方法中跟踪结果以比较结果。
- en: 'The following code snippet shows the intent-creation process for making a device
    discoverable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了使设备可发现的意图创建过程：
- en: '![Being discoverable](img/9639_04_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![设置为可发现](img/9639_04_07.jpg)'
- en: In the code, you can see that there is nothing new that hasn't been discussed
    earlier. Only the intent action string type has been changed, and the rest is
    the same. This is the power of intents; you can do almost anything with just a
    few lines of code in a matter of minutes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你可以看到没有什么新内容是没有在之前讨论过的。只是意图动作字符串类型发生了变化，其余部分保持不变。这就是意图的力量；你只需用几分钟和几行代码就可以完成几乎任何事情。
- en: Monitoring the discoverability modes
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监控可发现性模式
- en: 'As we tracked the state changes of Bluetooth, we can also monitor the discoverability
    mode using exactly the same method explained earlier in this chapter. We have
    to create a customized broadcast receiver by extending the `BroadcastReceiver`
    class. In the `onReceive()` method, we will get two extra strings: `BluetoothAdapter.EXTRA_PREVIOUS_SCAN_MODE`,
    and `BluetoothAdapter.EXTRA_SCAN_MODE`. Then, we pass those strings in the `Intent.getIntExtra()`
    method to get the integer values for the mode, and then we compare these integers
    with the predefined modes to detect our mode. The following code snippet shows
    the code sample:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们追踪蓝牙状态变化一样，我们也可以使用本章前面介绍的确切方法来监控可发现性模式。我们必须通过扩展`BroadcastReceiver`类来创建一个自定义的广播接收器。在`onReceive()`方法中，我们将得到两个额外的字符串：`BluetoothAdapter.EXTRA_PREVIOUS_SCAN_MODE`和`BluetoothAdapter.EXTRA_SCAN_MODE`。然后，我们将这些字符串传递给`Intent.getIntExtra()`方法以获取模式的整数值，然后我们将这些整数与预定义的模式进行比较以检测我们的模式。下面的代码片段展示了代码示例：
- en: '![Monitoring the discoverability modes](img/9639_04_08.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![监控可发现性模式](img/9639_04_08.jpg)'
- en: Communication via Bluetooth
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过蓝牙进行通信
- en: The Bluetooth communication APIs are just wrappers around the standard **RFCOMM**,
    the standard Bluetooth radio frequency communications protocol. To communicate
    with other Bluetooth devices, they must be paired with each other. We can carry
    out a bidirectional communication via Bluetooth using the `BluetoothServerSocket`
    class that is used to establish a listening socket for initiating a link between
    devices and `BluetoothSocket` that is used to create a new client socket to listen
    to the Bluetooth server socket. This new client socket is returned by the server
    socket once a connection is established. We will not discuss how Bluetooth is
    used in communication because it is beyond the scope of this book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙通信API只是围绕标准的**RFCOMM**（标准蓝牙射频通信协议）的封装。为了与其他蓝牙设备通信，它们必须配对。我们可以使用`BluetoothServerSocket`类通过蓝牙进行双向通信，该类用于建立监听套接字以启动设备间的链接，以及`BluetoothSocket`用于创建一个新的客户端套接字来监听蓝牙服务器套接字。一旦建立连接，服务器套接字就会返回这个新的客户端套接字。我们将不讨论蓝牙在通信中的使用，因为这超出了本书的范围。
- en: Using Wi-Fi through intents
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过意图使用Wi-Fi
- en: Today, the era of the Internet and its vast usage in mobile phones have made
    worldwide information available on the go. Almost every Android phone user expects
    an optimal use of the Internet from all apps. It becomes the developer's responsibility
    to add Internet access in the app. For example, when users use your apps, they
    would like to share the use and their activities performed in your app, such as
    completing any level of a game or reading any article from any news app, with
    their friends on various social networks, or by sending messages and so on. So,
    if users don't get connected through your app to the Internet, social platforms,
    or worldwide information, then the app becomes too limited and maybe boring.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网时代，以及其在手机上的广泛应用，使得全球信息触手可及。几乎每一位安卓手机用户都期望所有应用能充分利用互联网。因此，为应用添加互联网接入成为了开发者的责任。例如，当用户使用你的应用时，他们可能会想要与朋友分享在应用中的活动，如完成一个游戏关卡或阅读新闻应用中的文章，通过各种社交网络分享，或者发送短信等等。所以，如果用户不能通过你的应用连接到互联网、社交平台或全球信息，那么这个应用就会变得非常局限，甚至可能令人感到无聊。
- en: 'To perform any activity that uses the Internet, we first have to deal with
    Internet connectivity itself, such as whether the phone has any active connection.
    In this section, we will see how we can access Internet connectivity through our
    core topic—the intents. Like Bluetooth, we can do much work through intents related
    to Internet connectivity. We will implement three main examples: to check the
    Internet status of a phone, to pick any available Wi-Fi network, and to open the
    Wi-Fi settings. Let''s start our first example of checking the Internet connectivity
    status of a phone using intents.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行任何使用互联网的活动，我们首先必须处理互联网连接本身，比如手机是否有任何活动的连接。在本节中，我们将了解如何通过我们的核心主题——意图——访问互联网连接。像蓝牙一样，我们可以通过意图完成许多与互联网连接相关的任务。我们将实现三个主要示例：检查手机的互联网状态、选择任何可用的Wi-Fi网络以及打开Wi-Fi设置。让我们开始第一个示例，使用意图检查手机的互联网连接状态。
- en: Checking the Internet connectivity status
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查互联网连接状态
- en: Before we start coding our example, we need to know some important things. Any
    Android phone connected to the Internet can have any type of connection. Mobile
    phones can be connected using data connection to the Internet or it can be any
    open or secured Wi-Fi. Data connection is called mobile connection, and is connected
    via the mobile network provided by the SIM and service providers. In this example,
    we will detect whether the mobile phone is connected to any network or not, and
    if it is connected, which type of network it is connected to. Let's implement
    the code now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写示例代码之前，我们需要了解一些重要的事情。任何连接到互联网的Android手机都可能拥有任何类型的连接。手机可以通过数据连接连接到互联网，也可以是任何开放的或安全的Wi-Fi。数据连接被称为移动连接，通过SIM卡和服务提供商提供的移动网络连接。在这个例子中，我们将检测手机是否连接到任何网络，如果连接了，它连接的是哪种类型的网络。现在让我们实现代码。
- en: 'There are two main files that perform the functionality of the app: `NetworkStatusReceiver.java`
    and `AndroidManifest.xml`. You might be wondering about the `MainActivity.java`
    file. In the following example, this file is not used because of the requirements
    of the app. What we are going to do in this example is that whenever the Internet
    connectivity status of a phone is changed, such as the Wi-Fi is turned on or off,
    this app will display a toast showing the status. The app will be performing its
    work in the background; so, activity and layouts are not needed in this app. Now,
    let''s explain these files one by one:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的文件负责应用程序的功能：`NetworkStatusReceiver.java`和`AndroidManifest.xml`。你可能对`MainActivity.java`文件感到好奇。在以下示例中，由于应用程序的需求，这个文件没有被使用。我们在这个例子中要实现的功能是，无论手机的互联网连接状态如何改变，比如Wi-Fi开启或关闭，这个应用程序都会显示一个吐司来展示状态。该应用将在后台执行其工作，因此不需要活动和布局。现在，让我们逐一解释这些文件：
- en: The NetworkStatusReceiver.java file
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NetworkStatusReceiver.java文件
- en: 'This class represents our customized broadcast receiver that tracks the state
    change in the network connectivity of the device. The following code shows the
    implementation of the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示我们自定义的广播接收器，用于跟踪设备网络连接状态的变化。以下代码展示了该文件的实现：
- en: '![The NetworkStatusReceiver.java file](img/9639_04_09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![NetworkStatusReceiver.java文件](img/9639_04_09.jpg)'
- en: Just as we did for activities and services, to create a custom broadcast receiver,
    we extend from the `BroadcastReceiver` class and override methods to declare the
    custom behavior. We have overridden the `onReceive()` method, and we are performing
    the main functionality of tracking the Wi-Fi device status in this method. We
    have registered this receiver in the Android manifest file as a network status
    change, and we will discuss that file in the next section. This `onReceive()`
    method is called only when the network status is changed. So, we first display
    a toast stating that the network connectivity status has changed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对活动和服务的处理一样，要创建自定义广播接收器，我们需要从`BroadcastReceiver`类继承并重写方法以声明自定义行为。我们重写了`onReceive()`方法，并在该方法中执行了跟踪Wi-Fi设备状态的主要功能。我们已经在Android清单文件中将此接收器注册为网络状态更改，我们将在下一节讨论该文件。这个`onReceive()`方法只在网络状态改变时被调用。因此，我们首先显示一个吐司，声明网络连接状态已改变。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It must be noted that any broadcast receiver cannot be passed using `this` in
    the context parameter of `Toast` as we used to do in the `Activity` class because
    the `BroadcastReceiver` class doesn't extend the `Context` class like the `Activity`
    class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，任何广播接收器都不能在`Toast`的上下文参数中使用`this`来传递，就像我们在`Activity`类中所做的那样，因为`BroadcastReceiver`类没有像`Activity`类那样扩展`Context`类。
- en: We have already notified the user about the network status changes, but we still
    have not notified the user about which change has occurred. So, at this point,
    our intent object becomes handy. It contains all the information and data of the
    network in the form of `extra` objects. Recalling from the previous chapters,
    `extra` is an object of the `Bundle` class. We create a local `Bundle` reference
    and store the intent `extra` objects in it by calling the `getExtras()` method.
    Along with it, we also store the no connectivity `extra` object in a `boolean`
    variable. `EXTRA_NO_CONNECTIVITY` is the lookup key for a `boolean` variable that
    indicates whether there is a complete lack of network connectivity, that is, whether
    any network is available, or not. If this value is true, it means that there is
    no network available.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通知了用户关于网络状态的变化，但我们还没有通知用户具体发生了哪种变化。因此，在这个时候，我们的意图对象变得非常有用。它包含了网络的所有信息和数据，以`extra`对象的形式存在。回顾前面的章节，`extra`是`Bundle`类的一个对象。我们创建一个本地的`Bundle`引用，并通过调用`getExtras()`方法将意图的`extra`对象存储在其中。同时，我们还将在一个`boolean`变量中存储无连接的`extra`对象。`EXTRA_NO_CONNECTIVITY`是一个`boolean`变量的查找键，用于指示是否完全缺乏网络连接，即是否有任何网络可用。如果这个值为真，意味着没有网络可用。
- en: After storing our required `extra` objects, we need to check whether the `extra`
    objects are available or not. So, we have checked the `extra` objects with null,
    and if the `extra` objects are available, we extract more network information
    from these `extra` objects. In the Android system, the developer is told about
    the data of interest in the form of constant strings. So, we first get our constant
    string of network information, which is `EXTRA_NETWORK_INFO`. We store it in a
    string variable, and then we use it as a key value parameter in the `get()` method
    of the `extra` objects. The `Bundle.get()` method returns an `Object` type of
    the object, and we need to typecast it to our required class. We are looking for
    network information; so, we are using the `NetworkInfo` class object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储了我们需要的`extra`对象之后，我们需要检查`extra`对象是否存在。因此，我们用null检查了`extra`对象，如果`extra`对象可用，我们会从中提取更多的网络信息。在Android系统中，开发者会以常量字符串的形式被告知感兴趣的数据。所以，我们首先获取我们网络信息的常量字符串，即`EXTRA_NETWORK_INFO`。我们将其存储在一个字符串变量中，然后将其作为`extra`对象的`get()`方法的键值参数使用。`Bundle.get()`方法返回一个`Object`类型的对象，我们需要将其类型转换为所需的类。我们正在寻找网络信息，因此我们使用`NetworkInfo`类对象。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `Intent.EXTRA_NETWORK_INFO` string was deprecated in API Level 14\. Since
    `NetworkInfo` can vary based on the **User ID** (**UID**), the application should
    always obtain the network information through the `getActiveNetworkInfo()` or
    `getAllNetworkInfo()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_NETWORK_INFO`字符串在API级别14中已被弃用。由于`NetworkInfo`可以根据**用户ID**（**UID**）而有所不同，应用程序应始终通过`getActiveNetworkInfo()`或`getAllNetworkInfo()`方法获取网络信息。'
- en: We have got all our values and data of interest; now, we will compare and check
    the data to find the connectivity status. We check whether this `NetworkInfo`
    data is `null` or not. If it is not `null`, we check whether the network is connected
    by checking the value from the `getState()` method of `NetworkInfo`. The `NetworkInfo.State`
    state that represents the coarse-grained network state is an enum. If the `NetworkInfo.State`
    enum is equal to `NetworkInfo.State.CONNECTED`, it means that the phone is connected
    to any network. Remember that we still don't know which type of network we are
    connected to. We can find the type of network by calling the `NetworkInfo.getTypeName()`
    method. This method will return `Mobile` or `Wi-Fi` in the respective cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了我们感兴趣的所有值和数据；现在，我们将比较并检查数据以找到连接状态。我们检查这个`NetworkInfo`数据是否为`null`。如果不是`null`，我们通过检查`NetworkInfo`的`getState()`方法的值来确认网络是否已连接。`NetworkInfo.State`枚举表示粗粒度的网络状态。如果`NetworkInfo.State`枚举等于`NetworkInfo.State.CONNECTED`，意味着手机已连接到任何网络。请记住，我们仍然不知道我们连接的是哪种类型的网络。我们可以通过调用`NetworkInfo.getTypeName()`方法来找到网络的类型。此方法将根据相应的情况返回`Mobile`或`Wi-Fi`。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Coarse-grained network state is mostly used in apps rather than `DetailedState`.
    The difference between these two states'' mapping is that the coarse-grained network
    only shows four states: `CONNECTING`, `CONNECTED`, `DISCONNECTING`, and `DISCONNECTED`.
    However, `DetailedState` shows other states for more details, such as `IDLE`,
    `SCANNING`, `AUTHENTICATING`, `UNAVAILABLE`, `FAILED`, and the other four coarse-grained
    states.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 粗粒度的网络状态在应用中比`DetailedState`使用得更广泛。这两种状态映射之间的区别在于，粗粒度网络只显示四种状态：`CONNECTING`（连接中）、`CONNECTED`（已连接）、`DISCONNECTING`（断开中）和`DISCONNECTED`（已断开）。然而，`DetailedState`提供了更多细节的状态，例如`IDLE`（空闲）、`SCANNING`（扫描中）、`AUTHENTICATING`（认证中）、`UNAVAILABLE`（不可用）、`FAILED`（失败）以及前面提到的四种粗粒度状态。
- en: The rest is an `if`-`else` block checking the state of the network and showing
    the relative toasts of status on the screen. Overall, we first extracted our `extra`
    objects from intent, stored them in local variables, extracted network info from
    extras, checked the state, and finally displayed the info in the form of toasts.
    Now, we will discuss the Android manifest file in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的部分是一个`if`-`else`代码块，用于检查网络状态并在屏幕上显示相应的状态提示。总的来说，我们首先从意图中提取了`extra`对象，将它们存储在局部变量中，从额外信息中提取网络信息，检查状态，并最终以提示信息的形式显示出来。接下来，我们将在下一节讨论Android的清单文件。
- en: The AndroidManifest.xml file
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: As we have used a broadcast receiver in our application to detect the network
    connectivity status, it is necessary to register and unregister the broadcast
    receiver in the app. In our manifest file, we have performed two main tasks. First,
    we have added the permissions of accessing the network state. We have used `android.permissions.ACCESS_NETWORK_STATE`.
    Second, we have registered our receiver in the app using the receiver tag and
    added the name of the class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用中使用了一个广播接收器来检测网络连接状态，因此有必要在应用中注册和注销广播接收器。在我们的清单文件中，我们执行了两项主要任务。首先，我们添加了访问网络状态的权限，使用了`android.permissions.ACCESS_NETWORK_STATE`。其次，我们使用接收器标签注册了我们的接收器，并添加了类的名称。
- en: 'Also, we have added the intent filters. These intent filters define the purpose
    of the receiver, such as what type of data should be received from the system.
    We have used the `android.net.conn.CONNECTIVITY_CHANGE` filter action for detecting
    the network connectivity change broadcast. There is nothing new in this file other
    than these two, and the rest of the code is the same as we have discussed in the
    previous chapters. The following is the code implementation of the file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们添加了意图过滤器。这些意图过滤器定义了接收器的目的，比如应该从系统接收哪种类型的数据。我们使用了`android.net.conn.CONNECTIVITY_CHANGE`过滤器动作来检测网络连接变化广播。除了这两点之外，这个文件中没有新的内容，其余代码与我们在前面章节中讨论的一致。以下是该文件的代码实现：
- en: '![The AndroidManifest.xml file](img/9639_04_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_04_10.jpg)'
- en: 'Summarizing the details of the preceding app, we created a customized broadcast
    receiver, and defined our custom behavior of network change, that is, displaying
    toasts, and then we registered our receiver in the manifest file along with the
    declarations of the required permissions. The following screenshots show a simple
    demo of the app when turning the Wi-Fi on in the phone:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面应用的细节，我们创建了一个自定义的广播接收器，并定义了网络变化的自定义行为，即显示提示信息，然后在清单文件中注册了我们的接收器，并声明了所需的权限。以下截图显示了在手机开启Wi-Fi时应用的一个简单演示：
- en: '![The AndroidManifest.xml file](img/9639_04_11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_04_11.jpg)'
- en: The Network Change Status app
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 网络状态变化应用
- en: In the previous screenshot, we can see that when we turn the Wi-Fi on, the app
    displays a toast saying that the network status has changed. And after that toast,
    it displays the change; in our case, the Wi-Fi is connected. You might be wondering
    about the role of intents in this app. This app was not possible without using
    intents. The first use of intents was in registering the receiver in the manifest
    file to filter it for network status change. The other use of intents was in the
    receiver when we have received the update and we want to know the change. So,
    we used the intents and extracted the data from it in the form of `extra` objects
    and used it for our purpose. We didn't create our own intents in this example;
    instead, we only used the provided intents. In our next example, we will create
    our own intents and use them to open the Wi-Fi settings from our app.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到当开启Wi-Fi时，应用会显示一个提示框告知网络状态已改变。提示框之后，它会显示变化；在我们的案例中，Wi-Fi已连接。你可能会好奇在这个应用中意图（intents）的作用。没有使用意图，这个应用是不可能实现的。首先在清单文件中使用意图来注册接收器，以便筛选网络状态变化。另一个意图的使用是在接收器中，当我们收到更新并想知道变化时。因此，我们使用了意图，并以`extra`对象的形式从中提取数据，用于我们的目的。在这个例子中，我们没有创建自己的意图；而是仅使用了提供的意图。在下一个例子中，我们将创建自己的意图，并使用它们从应用中打开Wi-Fi设置。
- en: Opening the Wi-Fi Settings app
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开Wi-Fi设置应用
- en: 'Until now, we have only used intents for network and Wi-Fi purposes. In this
    example, we are going to create intent objects and use it in our app. In the previous
    app example, we detected the network change status of the phone and displayed
    it on the screen. In this example, we will add a button in the same app. On clicking
    on or tapping the button, the app will open the Wi-Fi settings. And the user can
    turn the Wi-Fi on or off from there. As the user performs any action, the app
    will display the network status change on the screen. For the network status,
    we used the `NetworkStatusReceiver.java` and `AndroidManifest.xml` files. Now,
    let''s open the same project and change our `MainActivity.java` and `layout_main.xml`
    files to add a button and its functionality to them. Let''s see these two files
    one by one:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅将意图用于网络和Wi-Fi目的。在这个例子中，我们将创建意图对象并在我们的应用中使用它。在之前的示例应用中，我们检测了手机的 network
    change 状态并在屏幕上显示。在这个例子中，我们将在同一个应用中添加一个按钮。点击或轻触按钮，应用将打开Wi-Fi设置。用户可以从那里打开或关闭Wi-Fi。当用户执行任何操作时，应用将在屏幕上显示网络状态变化。对于网络状态，我们使用了`NetworkStatusReceiver.java`和`AndroidManifest.xml`文件。现在，让我们打开同一个项目，并更改我们的`MainActivity.java`和`layout_main.xml`文件，为它们添加一个按钮及其功能。让我们逐一看看这两个文件：
- en: The activity_main.xml file
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`activity_main.xml`文件'
- en: 'This file is a visual layout of our main activity file. We will add a button
    view in this XML file. The code implementation of the file is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是我们主活动文件的视觉布局。我们将在这个XML文件中添加一个按钮视图。该文件的代码实现如下：
- en: '![The activity_main.xml file](img/9639_04_12.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![`activity_main.xml`文件](img/9639_04_12.jpg)'
- en: We have added a button in the layout with the view ID of `btnWifiSettings`.
    We will use this ID to get the button View in the layout file. We have already
    discussed the layouts in the previous chapters. Let's now see our main activity
    file that will use this layout as the visual content.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在布局中添加了一个按钮，其视图ID为`btnWifiSettings`。我们将使用这个ID在布局文件中获取按钮视图。我们已经在之前的章节中讨论过布局。现在，让我们看看将使用此布局作为视觉内容的主活动文件。
- en: The MainActivity.java file
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`MainActivity.java`文件'
- en: 'This file represents the main activity file as a launcher point of the app.
    We will implement our button''s core functionality in this file. The code implementation
    of the file is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件表示作为应用启动点的活动主文件。我们将在本文件中实现我们按钮的核心功能。该文件的代码实现如下：
- en: '![The MainActivity.java file](img/9639_04_13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![`MainActivity.java`文件](img/9639_04_13.jpg)'
- en: As discussed many times, we have extended our class from the `Activity` class,
    and we have overridden the `onCreate()` method of the class. After calling the
    super method, we have first referenced our layout file (explained in the previous
    section) using the `setContentView()` method and passed the layout ID as the parameter.
    After getting the layout file, we have extracted our Wi-Fi settings button from
    the layout by calling the `findViewById()` method. Remember, we set the button
    View's ID to `btnWifiSettings`; so, we will pass this ID in the method as an argument.
    We stored the referenced file of our button in a local `Button object.reference`
    object. Now, we will set `View.OnClickListener` of the local button to perform
    our tasks on a button click. We have passed an anonymous object of `OnClickListener`
    in the `button.setOnClickListener()` method, and overridden the `onClick()` method
    of the anonymous object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前多次讨论的那样，我们从`Activity`类扩展了我们的类，并覆盖了类的`onCreate()`方法。在调用超类方法之后，我们首先使用`setContentView()`方法引用了我们的布局文件（在上一节中解释），并将布局ID作为参数传递。在获取布局文件之后，我们通过调用`findViewById()`方法从布局中提取了我们的Wi-Fi设置按钮。记住，我们将按钮视图的ID设置为`btnWifiSettings`；因此，我们将此ID作为参数在方法中传递。我们在一个本地`Button
    object.reference`对象中存储了按钮的引用文件。现在，我们将设置本地按钮的`View.OnClickListener`，以在按钮点击时执行我们的任务。我们在`button.setOnClickListener()`方法中传递了一个`OnClickListener`的匿名对象，并覆盖了匿名对象的`onClick()`方法。
- en: 'Until now, we have only performed some initial steps to create a setup for
    our app. Now, let''s focus on opening the Wi-Fi settings task. We will create
    an `Intent` object, and we have to pass a constant string ID to tell the intent
    about what to start. We will use the `Settings.ACTION_WIFI_SETTINGS` constant
    that shows the settings to allow the configuration of the Wi-Fi. After creating
    the `Intent` object, we will pass it in the `startActivity()` method to open the
    activity containing the Wi-Fi settings. It is that simple with no rocket science
    at all. When we run the app, we will have something similar to the following screenshots:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 至今为止，我们仅完成了创建应用设置的一些初始步骤。现在，让我们集中精力打开Wi-Fi设置任务。我们将创建一个`Intent`对象，并且必须传递一个常量字符串ID来告诉意图要启动什么。我们将使用`Settings.ACTION_WIFI_SETTINGS`常量，它展示了允许配置Wi-Fi的设置。创建`Intent`对象后，我们将在`startActivity()`方法中传递它，以打开包含Wi-Fi设置的活动。这非常简单，完全没有火箭科学那么复杂。当我们运行这个应用时，我们将看到与以下截图类似的内容：
- en: '![The MainActivity.java file](img/9639_04_14.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java文件](img/9639_04_14.jpg)'
- en: Opening the Wi-Fi Settings app
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Wi-Fi设置应用
- en: As seen from the preceding screenshot, when we click or tap the Wi-Fi Settings
    button, it will open the Wi-Fi settings screen of the Android phone. On changing
    the settings, such as turning on the Wi-Fi, it will display the toasts to show
    the updated changes and network status.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如从前面的截图中所见，当我们点击或轻触Wi-Fi设置按钮时，它将打开Android手机的Wi-Fi设置屏幕。在更改设置时，比如打开Wi-Fi，它将显示吐司通知来展示更新的更改和网络状态。
- en: We have finished discussing the communication components using intents, in which
    we used Bluetooth and Wi-Fi via intents and saw how these can be used in various
    examples and applications. Now, we will discuss how the media components can be
    used via intents and what we can do for media components in the following sections.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用意图进行通信的组件，在其中我们通过意图使用了蓝牙和Wi-Fi，并看到了它们在各种示例和应用中的使用方法。现在，我们将讨论如何通过意图使用媒体组件，以及我们在以下各节中可以为媒体组件做些什么。
- en: Media components
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体组件
- en: The preceding section was all about communication components. But the difference
    between old phones and the new smartphones is the media capability, such as high-definition
    audio-video features. And the multimedia capabilities of mobile phones have become
    a more significant consideration to many consumers. Fortunately, the Android system
    provides multimedia API's for many features such as playing and recording a wide
    range of image, audio, and video formats both locally and streamed. If we describe
    the media components in simple words, this topic can only be covered in a fully
    dedicated chapter, and it is beyond the scope of this book. We will only discuss
    those media components that can be triggered, used, and accessed through intents.
    The components to be discussed in this section include using intents to take pictures,
    using intents to record video, speech recognition using intents, and the role
    of intents in text-to-speech conversion. The first three topics use intents to
    perform the actions; but the last topic of text-to-speech conversion doesn't use
    intents on a complete basis. We will also develop a sample application to see
    the intents in action. Let's discuss these topics one by one in the following
    subsections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Using intents to take pictures
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today, almost every phone has a digital camera component. The popularity of
    digital cameras embedded within mobile phones has caused their prices to drop
    along with their size. Android phones also include digital cameras varying from
    3.2 megapixels to 32 megapixels. From the development perspective, pictures can
    be taken via many different methods. The Android system has also provided the
    APIs for camera control and pictures, but we will only be focusing on one method
    that uses intents in it. This is the easiest way to take pictures in Android development,
    and contains no more than few lines of code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We will first create a layout with the image View and button. Then, in the `Activity`
    class, we will get the references of our views from the layout file, and set the
    click listener of the button. On clicking the button, we will create the intent
    of the capture image, and start another activity as a child class. After getting
    the result, we will display that captured image in our image View.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with the basic empty Hello World project ready, we will change three files
    and add our code to it. The files are `activity_main.xml`, `MainActivity.java`,
    and `AndroidManifest.xml`. Let''s explain the changes in each file one by one:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This file represents the visual layout for the file. We will add an `ImageView`
    tag to show the captured image and a `Button` tag to take a picture and trigger
    the camera. The code implementation of the file is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_04_15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: As you can see in the code, we have placed an `ImageView` tag in the relative
    layout with the ID of `imageView1`. This ID will be used in the main activity
    file to extract the view from the layout to use in the Java file. We have placed
    the view in the horizontal centre of the layout by assigning the value `true`
    in the `android:layout_centerHorizontal` tag. Initially, we have set a default
    image of our app's launcher icon to our image View. Below the image View, we have
    placed a button View. On tapping the button, the camera will be started. The button's
    ID is set to `btnTakePicture` by the `android:layout_below` tag below the image
    View layout. This relativity is the main advantage of the relative layouts as
    compared to linear layouts. So now, let's have a look at the activity of the app
    that performs the main functionality and uses this layout as a visual part as
    well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java file
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This file represents the main launching activity of the app. This file uses
    the `layout_main.xml` file as the visual part, and it is extended from the `Activity`
    class. The code implementation of the file is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java file](img/9639_04_16.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: We start our class by overriding the `onCreate()` method of the activity. We
    set the visual layout of the activity to the `activity_main.xml` layout by calling
    the `setContentView()` method. Now, as the layout is set, we can get references
    to the views in the layout file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We create two fields in the class; `takenImage` of the `ImageView` class to
    be used to show the captured image and `imageButton` of the `Button` class to
    be used to trigger the camera by clicking on it. The `onClick()` method will be
    called when the button is tapped/clicked. So, we will define our camera-triggering
    code in this method. So, in this method, we are creating an instance of the `Intent`
    class, and we are passing the `MediaStore.ACTION_IMAGE_CAPTURE` constant in the
    constructor. This constant will tell Android that the intent is for the purpose
    of image capture, and Android will start the camera on starting this intent. If
    a user has installed more than one camera app, Android will present a list of
    all valid camera apps, and the user can choose any to take the image.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: After creating an intent instance, we pass this intent object in the `startActivityForResult()`
    method. In our picture-capturing app, clicking on the button will start another
    activity of the camera. And when we close the camera activity, it will come back
    to the original activity of our app and give us some result of the captured picture.
    So, to get the result in any activity, we have to override the `onActivityResult()`
    method. This method is called when the parent activity is started after the child
    activity is completed. When this method is called, it means that we have used
    the camera and are now back to our parent activity. If the result is successful,
    we can display the captured image in the image View.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: First, we can learn whether this method is called after the camera or if another
    action has happened. For this purpose, we have to compare the `requestCode` parameter
    of the method. Remember, when calling the `startActivityForResult()` method, we
    passed the `TAKE_IMAGE_CODE` constant as the other parameter. This is the request
    code to be compared to.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: After that, to check the result, we can see the `resultCode` parameter of the
    method. As we used this code for the camera picture intent, we will compare our
    `resultCode` with the `RESULT_OK` constant. After the success of both conditions,
    we can conclude that we have received our image. So, we use the intent to get
    our image data by calling the `getExtras().get()` method. This will give us the
    `Object` type of data. We further typecast it to `Bitmap` to prepare it for `ImageView`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `setImageBitmap` method to set the new bitmap to our image
    View. If you run the code, you will see an icon image and a button. After clicking
    on the button, the camera will be started. When you take the picture, the app
    will crash and shut down. You can see it in the following screenshots:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java file](img/9639_04_17.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: The app crashed after taking a picture
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why the crash occurred. We forgot to mention one thing;
    whenever any app uses the camera, we have to add the `uses-feature` tag in our
    manifest file to tell the app that it will use the camera feature. Let's see our
    Android manifest file to understand the `uses-feature` tag.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This file defines all the settings and features to be used in our app. There
    is only one new thing that we haven''t seen. The code implementation of the file
    is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_04_18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: You can see that we have added the `uses-feature` tag, and we have assigned
    `android.hardware.camera` in the `android:name` property. This tag tells the app
    about the camera usage in it, and the Android OS gives our app the permission
    to use the external camera.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding this line in the manifest file and running the code, you will
    see something similar to the following screenshot if you have more than one camera
    app in your phone:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_04_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Taking pictures through the intents app
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, you can see that the user is asked to choose the camera,
    and when a picture is taken, the image is shown in the app.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: When we summarized the code, we first created a layout with image View and button.
    Then, in the `Activity` class, we got the references of our views from the layout
    file, and set the click listener of the button. After clicking on the button,
    we created the intent of capture image, and started another activity as the child
    activity. After getting the result, we displayed that captured image in our image
    View. It was as easy as a walk in the park. In the next section, we will see how
    we can record video using intents.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Using intents to record video
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we have already seen how to take pictures using intents. In this
    section, we will see how we can record video using intents. We will not discuss
    the whole project in this section. The procedure to record videos using intents
    is almost the same as taking pictures with few minor changes. We will only discuss
    those changes in this section. Now, let's see how the app works to record video.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change that we have done is in our layout file. We removed the image
    View section, and have placed the `VideoView` tag. The following code implementation
    shows that tag:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Using intents to record video](img/9639_04_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'You can see that everything is the same as it was in `ImageView`. Now, as we
    have changed image view to video view in our layout, we have to change that in
    our activity as well. Just as we did for `ImageView`, we will create a field object
    of `VideoView`, and get the reference in our `onCreate()` method of the activity.
    The following code sample shows the field object of `VideoView` line:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Using intents to record video](img/9639_04_21.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Everything is the same, and we have already discussed it. Now, in our `onClick()`
    method, we will see how we send the intent that triggers the video recording.
    The code implementation to be put on the `onClick()` method to send an intent
    is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Using intents to record video](img/9639_04_22.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: You can see that we have created an intent object, and instead of passing `MediaStore.ACTION_IMAGE_CAPTURE`,
    we have passed `MediaStore.ACTION_VIDEO_CAPTURE` in the constructor of the intent.
    Also, we have put an `extra` object in the intent by calling the `putExtra()`
    method. We have put the `extra` object defining the video quality as `high` by
    assigning the `MediaStore.EXTRA_VIDEO_QUALITY` value to `1`. Then, we pass the
    intent in the `startActivityForResult()` method again to start the camera activity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change is in the `onActivityResult()` method when we get the video
    from the intent. The following code shows some sample code to get the video and
    pass it in the `VideoView` tag and play it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Using intents to record video](img/9639_04_23.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: In the case of taking a picture, we restored raw data from the intent, typecasted
    it to `Bitmap`, and then set our `ImageView` to `Bitmap`. But here, in case of
    recording a video, we are only getting the URI of the video. The `Uri` object
    declares the reference of data in the mobile phone. We get the URI of the video,
    and set it in our `VideoView` using the `setVideoURI()` method. Finally, we play
    the video by calling the `VideoView.start()` method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: From these sections, you can see how easy it is to use the intents to capture
    images or record videos. Through intents, we are using the already built-in camera
    or camera apps. If we want our own custom camera to capture images and videos,
    we have to use the Camera APIs of Android.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `MediaPlayer` class to play video, audio, and so on. The `MediaPlayer`
    class contains methods like `start()`, `stop()`, `seekTo()`, `isLooping()`, `setVolume()`,
    and much more. To record a video, we can use the `MediaRecorder` class. This class
    contains methods including `start()`, `stop()`, `release()`, `setAudioSource()`,
    `setVideoSource()`, `setOutputFormat()`, `setAudioEncoder()`, `setVideoEncoder()`,
    `setOutputFile()`, and much more.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are using `MediaRecorder` APIs in your app, don't forget to add the
    permissions of `android.premission.RECORD_AUDIO` and `android.permission.RECORD_VIDEO`
    in your manifest file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: To take pictures without using intents, we can use the `Camera` class. This
    class includes the methods `open()`, `release()`, `startPreview()`, `stopPreview()`,
    `takePicture()`, and much more.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are using Camera APIs in your app, don't forget to add the permissions
    of `android.premission.CAMERA` in your manifest file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have used visual media components for videos and pictures using
    intents. In the next section, we will use audio components of a phone using intents.
    We will see how we can use the speech recognition and text-to-speech supports
    using intents in the next sections.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Speech recognition using intents
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Smartphones introduced voice recognition that became a very big achievement
    for disabled people. Android introduced speech recognition in API Level 3 in Version
    1.5\. Android supports voice input and speech recognition using the `RecognizerIntent`
    class. Android''s default keyboard contains a button with a microphone icon on
    it. This allows the user to speak instead of typing a text. It uses the speech-recognition
    API for this purpose. The following screenshot shows the keyboard with the microphone
    button on it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Speech recognition using intents](img/9639_04_24.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Android's default keyboard with the microphone button
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a sample application that will have a button
    and text field. After clicking on the button, Android's standard voice-input dialog
    will be displayed, and the user will be asked to speak something. The app will
    try to recognize whatever the user speaks and type it in the text field. We will
    start by creating an empty project in the Android Studio or any other IDE, and
    we will modify two files in it. Let's start with our layout file in the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This file represents the visual content of the app. We will add the text field
    and button view in this file. The code implementation of the file is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_04_25.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have placed an `EditText` field. We have set `android:inputType`
    to `textMultiLine` to type the text in multiple lines. Below the text field, we
    have added a `Button` view with an ID of `btnRecognize`. This button will be used
    to start the speech-recognition activity when it is tapped or clicked on. Now,
    let's discuss the main activity file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java file
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This file represents the main activity of the project. The code implementation
    of the file is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java file](img/9639_04_26.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: As usual, we override the `onCreate()` method, and get our button reference
    from the layout set by the `setContentView()` method. We set the button's listener
    to this class, and in the activity, we implement `OnClickListener` along with
    overriding the `onClick()` method. In the `onClick()` method, we create an intent
    object and pass `RecognizerIntent.ACTION_RECOGNIZE_SPEECH` as an action string
    in the constructor. This constant will tell Android that the intent is for speech-recognition
    purpose. Then, we have to add some `extra` objects to provide more information
    to Android about the intent and speech recognition. The most important `extra`
    object to be added is `RecognizerIntent.EXTRA_LANGUAGE_MODEL`. This informs the
    recognizer about which speech model to use when recognizing speech. The recognizer
    uses this extra to fine-tune the results with more accuracy. This `extra` method
    is required and must be provided when calling the speech-recognizer intent. We
    have passed the `RecognizerInent.ACTION_LANGUAGE_MODEL_FREE_FORM` model for speech.
    This is a language model based on a free-form speech recognition. Now, we have
    some optional `extra` objects that help the recognizer with more accurate results.
    We have added `extra` of `RecognizerIntent.EXTRA_PROMPT` and passed some string
    value in it. This will notify the user that speech recognition has been started.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the `RecognizerIntent.EXTRA_MAX_RESULTS` extra and set its value
    as `1`. Speech recognition's accuracy always varies. So, the recognizer will try
    to recognize with more accuracy. So, it creates different results with different
    accuracies and maybe different meanings. So, through this extra, we can tell the
    recognizer about how many results we are interested in. In our app, we have put
    it as `1`. So, that means the recognizer will provide us with only one result.
    There is no guarantee that this result will be accurate enough; that's why it
    is recommended to pass a value greater than `1`. For a simple case, you can pass
    a value upto `5`. Remember, the greater the value you pass, the more time will
    it take to recognize it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we put our last optional `extra` of language. We pass `Locale.ENGLISH`
    as the value of the `RecognizerIntent.EXTRA_LANGUAGE` extra. This will tell the
    recognizer about the language of the speech. So, the recognizer didn't have to
    detect the language, this results in more accuracy in speech recognition.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The speech-recognition engine may not be able to understand all the languages
    available in the `Locale` class. Also, it is not necessary that all the devices
    will support speech recognition.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: After adding all the `extra` objects, we have ensured that our intent object
    is ready. We pass it in the `startActivityForResult()` method with `requestCode`
    as `1`. When this method is called, a standard voice-recognition dialog is shown
    with the prompt message that we had given. After we finish speaking, our parent
    activity's `onActivityResult()` method is called. We first check whether `requestCode`
    is `1` or not so that we can be sure that this is our result of speech recognition.
    After that, we will check `resultCode` to see whether the result was okay or not.
    After successful results, we will get an array list of strings containing all
    the words recognized by the recognizer. We can get these words' lists by calling
    the `getStringArrayListExtra()` method and passing `RecognizerIntent.EXTRA_RESULTS`.
    This list is only returned when `resultCode` is okay; otherwise, we will get a
    null value. After wrapping up the speech-recognition stuff, we can now set the
    text value to the result. For that, we first extract the `EditText` view from
    the layout, and set our result to the value of the text field by calling the `setText()`
    method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An active Internet connection is required to run speech recognition. The speech-recognition
    process is executed on the servers of Google. An Android phone takes the voice
    input, sends it to Google Servers, and it is processed there for recognition.
    After recognition, Google sends the results back to the Android phone, the phone
    informs the user about the results, and the cycle is complete.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you will see something similar to the following screenshots:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java file](img/9639_04_27.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Speech recognition using intents
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In the image, you can see that after clicking on the **Recognize** button, a
    standard voice-input dialog is shown. On speaking something, we will return back
    to our parent activity, and after recognizing the speech, it will print all the
    text in the text field.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in text-to-speech conversion
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we discussed how the Android system can recognize our
    speech and perform actions such as controlling the mobile phone via speech commands.
    We also developed a simple speech-to-text example using intents. This section
    is the opposite of the previous section. In this section, we will discuss how
    the Android system can convert our text into a beautiful voice narration. We can
    call it text-to-speech conversion. Android introduced the **Text-To-Speech** (**TTS**)
    **Conversion** engine in Version 1.6 API Level 4\. We can use this API to produce
    speech from within our application, thus allowing our app to talk with our users.
    And if we add speech recognition, it will be like talking with our application.
    Text-to-speech conversion requires preinstalled language packs, and due to the
    lack of storage space on mobile phones, it is not necessary that the phone will
    have any language packs already installed in it. So, while creating any app using
    the text-to-speech engine, it is a good practice to check whether the language
    packs are installed or not.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t use text-to-speech conversion using intents. We can only use it through
    the text-to-speech engine called TTS. But, there is a minor role of intents in
    text-to-speech conversion. Intents are used only to check whether the language
    packs are preinstalled or not. So, creating any app that uses text-to-speech will
    first have to use intents to check the language packs'' installation status. That''s
    the role of intents in text-to-speech conversion. Let''s look at the sample code
    of checking the language packs'' installation state:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in text-to-speech conversion](img/9639_04_28.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we will do for text-to-speech conversion is to check the language
    packs. In the code, we can see that we are creating an intent object. And we are
    passing the `Engine.ACTION_CHECK_TTS_DATA` constant that will tell the system
    that the intent will check the text-to-speech (TTS) data and language packs. We
    are then passing the intent in the `startActivityForResult()` method along with
    the `VAL_TTS_DATA` constant value used as `requestCode`. Now, if the language
    packs are installed and everything is okay, we will get `resultCode` as `RESULT_OK`
    in the `onActivityResult()` method. So, if the result is okay, we can use text-to-speech
    conversion. So, let''s see the code sample for the `onActivityResult()` method,
    as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in text-to-speech conversion](img/9639_04_29.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'So, we first check `requestCode` of our passed code. Then, we check `resultCode`
    to `Engine.CHECK_VOICE_DATA_PASS`. This constant is used to tell whether voice
    data is available or not. If we have data available in our phone, we can do our
    text-to-speech conversion there. Otherwise, it is clear that we have to install
    voice data first before doing the text-to-speech conversion. You will be pleased
    to know that installing voice data is also very easy; it uses intents for this
    purpose. The following code snippet shows how to install voice data using intents:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in text-to-speech conversion](img/9639_04_30.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'We created an intent object and passed `Engine.ACTION_INSTALL_TTS_DATA` in
    the constructor. This constant will tell Android that the intent is for the installation
    of text-to-speech language packs'' data. And then, we pass the intent into the
    `startActivity()` method to start installation. After the language pack''s installation,
    we have to create an object of the `TextToSpeech` class and call its `speak()`
    method when we want to do some text-to-speech conversion. The following is the
    code implementation showing how to use the object of the `TextToSpeech` class
    in the `onActivityResult()` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As seen in the code, after the successful installation of the language data
    packs, we have created an instance of `TextToSpeech` and passed an anonymous `OnInitListener`
    object. We have implemented the `onInit()` method. This method will set the initial
    settings of the `TextToSpeech` object. If the status is a success, we are setting
    the language, speech rate, and finally, we are calling the `speak()` method. In
    this method, we passed a string of characters, and Android will read these letters
    aloud.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Concluding the whole topic, the role of intents in text-to-speech conversion
    is of checking and installing voice-data packs. Intents don't contribute directly
    to text-to-speech conversion, but they just set the initial setup for text-to-speech
    conversion.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: With text-to-speech conversion, we have finished the discussions on media components.
    In media components, we discussed taking pictures, recording videos, speech recognition,
    and text-to-speech conversion. In the next section, we will discuss motion components
    and see how intents play a role in these components.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Motion components
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Motion components in an Android phone include many different types of sensors
    that perform many different tasks and actions. In this section, we will discuss
    motion and position sensors such as accelerometer, geomagnetic sensor, orientation
    sensor, and proximity sensor. All these sensors play a role in the motion and
    position of the Android phone. We will discuss only those sensors that use intents
    to get triggered. We have only one such sensor that uses intents and that is the
    proximity sensor. Let's discuss it in the following section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Intents and proximity alerts
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before learning about the role of intents in proximity alerts, we will discuss
    what proximity alerts are and how these can be useful in various applications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: What are proximity alerts?
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The proximity sensor lets the user determine how close the device is to an
    object. It''s often useful when your application reacts when a phone''s screen
    moves towards or away from any specific object. For example, when we get any incoming
    call on an Android phone, placing the phone on the ear shuts off the screen and
    holding it back in the hands switches the screen on automatically. This application
    is using proximity alerts to detect the distance between the ear and the proximity
    sensor of the device. The following figure shows it in the visual format:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![What are proximity alerts?](img/9639_04_32.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Another example can be when our phone has been idle for a while and its screen
    is switched off, it will vibrate if we have some missed calls or give notifications
    hinting us to check our phone. This can also be done using proximity sensors.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Proximity sensors use proximity alerts that detect the distance between the
    sensor of the phone and any object. These alerts let your application set triggers
    that are fired when a user is moved within or beyond a set distance from a geographic
    location. We will not discuss all the details for the use of proximity alerts
    in this section, but we will only cover some basic information and the role of
    intents in using proximity alerts. For example, we set a proximity alert for a
    given coverage area. We select a point in the form of longitude and latitude,
    a radius around that point in meters, and some expiry time for the alert. Now,
    after using proximity alerts, an alert will fire if the device crosses that boundary.
    It can be either that the device moves from outside to within the radius or it
    moves from inside the radius to beyond it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in proximity alerts
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When proximity alerts are triggered, they fire intents. We will use a `PendingIntent`
    object to specify the intent to be fired. Let''s see some code sample of the application
    of the distance that we discussed in the earlier section in the following implementation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in proximity alerts](img/9639_04_33.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we are implementing the very first step to use proximity
    alerts in our app. First of all, we create a proximity alert that can be done
    through `PendingIntent`. We define the name of the alert as `DISTANCE_PROXIMITY_ALERT`,
    and then get the location manager service by calling the `getSystemService()`
    method of the current activity we have written the code in. We then set some random
    values for latitude, longitude, radius, and expiration to infinity. It should
    be remembered that these values can be set to any depending on the type of application
    you are creating.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Now comes our most important part of creating the proximity alert. We create
    the intent, and we pass our own alert name in the constructor to create our own
    intent. Then, we create an object of `PendingIntent` by getting a broadcast intent
    using the `getBroadcast()` method. Finally, we are adding the proximity alert
    in our location manager service by calling the `addProximityAlert()` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet has only created the alert and set initial values for it.
    Now, assume that we have completely finished our distance app. So, whenever our
    device passes the boundary that we specified in the app or gets inside it, `LocationManager`
    will detect that we have crossed the boundary, and it will fire an intent having
    an extra value of `LocationManager.KEY_PROXIMITY_ENTERING`. This value is a Boolean
    value. If it''s value is `true` it means we have entered into the boundary, and
    if it is `false`, we have left the boundary. To receive this intent, we will create
    a broadcast receiver and perform the action. The following code snippet shows
    the sample implementation of the receiver:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the code, you can see that we are getting the extra value of `LocationManager.KEY_PROXIMITY_ENTERING`
    using the `getBooleanExtra()` method. We compare the value and display the toast
    accordingly. It was quite easy as you can see. But, like all the receivers, this
    receiver will not work until it is registered in `AndroidManifest.xml` or via
    code in Java. The java code for registering the receiver is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in proximity alerts](img/9639_04_35.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: There is nothing to explain here except that we are calling the `registerReceiver()`
    method of the `Activity` class. We will discuss `IntentFilter` in more detail
    in the following chapters.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, intents play a minor role in getting proximity alerts. Intents
    are only used to tell the Android OS about the type of proximity alert that has
    been added, when it is fired, and what information should be included in it so
    that the developers can use it in their apps.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the common mobile components found in almost all
    Android phones. These components include the Wi-Fi component, Bluetooth, Cellular,
    Global Positioning System, geomagnetic field, motion sensors, position sensors,
    and environmental sensors. Then, we discussed the role of intents with these components.
    To explain that role in more detail, we used intents for Bluetooth communication,
    turning Bluetooth on/off, making a device discoverable, turning Wi-Fi turn on/off,
    and opening Wi-Fi settings. We also saw how we can take pictures, record videos,
    do speech recognition, and text-to-speech conversion via intents. In the end,
    we saw how we can use the proximity sensor through intents.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how intents can be used in transferring data
    between activities, services, and other mobile components.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
