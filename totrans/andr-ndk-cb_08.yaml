- en: Chapter 8. Porting and Using the Existing Libraries with Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Porting a library as a shared library module with the Android NDK build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting a library as a static library module with the Android NDK build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting a library with its existing build system using the Android NDK toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a library as a prebuilt library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a library in multiple projects with import-module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting a library that requires RTTI, exception, and STL support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many C/C++ libraries for the Desktop computing world. These libraries
    can save us a huge amount of effort if we can reuse them on an Android platform.
    Android NDK makes this possible. In this chapter, we will discuss how to port
    the existing libraries to Android with NDK.
  prefs: []
  type: TYPE_NORMAL
- en: We will first introduce how to build libraries with the Android NDK build system.
    We can build a library as a static library module or a shared library module.
    The differences between the two will be discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the Android NDK toolchain as a standalone cross compiler, which
    is covered next. We will then describe how to use the compiled libraries as prebuilt
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: We often use the same library in multiple Android projects. We can use the **import-module**
    feature to link to the same library module to multiple projects while maintaining
    a single copy of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Many C++ libraries require STL, C++ exceptions, and **Run-Time Type Information**
    (**RTTI**) supports, which are not available with the Android default C++ runtime
    library. We will illustrate how to enable these supports by using the popular
    `boost` library as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Porting a library as a shared library module with the Android NDK build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will discuss how to port an existing library as a shared library
    with the Android NDK build system. We will use the open source `libbmp` library
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the *Building an Android NDK application at
    the command line* recipe in [Chapter 3](ch03.html "Chapter 3. Build and Debug
    NDK Applications"), *Build and Debug NDK Applications*, before going through this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create our sample Android project that
    demonstrates porting the libbmp library as a shared library:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `PortingShared` with native support. Set
    the package name as `cookbook.chapter8.portingshared`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, if you want more
    detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingshared`
    package. This Java file simply loads the shared library `.bmp` and `PortingShared`,
    and calls the native method `naCreateABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `libbmp` library from [http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list),
    and extract the archive file. Create a folder named `libbmp` under the `jni` folder,
    and copy the `src/bmpfile.c` and `src/bmpfile.h` files from the extracted folder
    to the `libbmp` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the following code from `bmpfile.h` if you are using NDK r8 and below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code changes for `bmpfile.h` are only necessary for Android NDK r8 and
    below. Compiling the library will return an error `"error: redefinition of typedef
    ''uint8_t''`". This is a bug in the NDK build system as the `uint8_t` definition
    is enclosed by the `#ifndef` preprocessor. It has been fixed since NDK r8b, and
    we don''t need to change the code if we''re using r8b and above.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `Android.mk` file under the `libbmp` folder to compile `libbmp` as
    a shared library `libbmp.so`. The content of this `Android.mk` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another folder named `libbmptest` under the `jni` folder. Add the `mylog.h`
    and `PortingShared.c` files under it. `PortingShared.c` implements the native
    method `naCreateABmp`, which uses functions defined in the `libbmp` library to
    create a bitmap image and save it to `/sdcard/test_shared.bmp`. You will need
    to change directory if the `/sdcard` directory is not available on your devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another `Android.mk` file under the `libbmptest` folder to compile the
    `PortingShared.c` file as another shared library `libPortingShared.so`. The content
    of this `Android.mk` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project. A bitmap file `test_shared.bmp` should be
    created at the `sdcard` folder of the Android device. We can use the following
    command to get the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a `.bmp` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample project demonstrates how to port the `libbmp` code as a shared library
    and use it in the native code `PortingShared.c`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared library**: A shared library can be shared by multiple executables
    and libraries. The Android native code is usually compiled as shared libraries
    and loaded by the Java code. In fact, the Android build system only packages shared
    libraries into the application''s `apk` file. Therefore, we must provide at least
    one shared library to contain our native code.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can still use static libraries to generate shared libraries, as we will see
    in the *Porting a library as static library module with Android NDK build system*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample project builds two shared libraries, namely `libbmp.so` and `libPortingShared.so`.
    We can find these libraries under the `libs` folder of the project. `libPortingShared.so`
    depends on `libbmp.so`, since `PortingShared.c` calls functions defined in the
    `libbmp` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Java file, we need to load `libbmp.so` before `libPortingShared.so`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Understand the Android.mk files**: Android NDK provides an easy-to-use build
    system, which frees us from writing makefiles. However, we still need to provide
    some basic inputs to the system through `Android.mk` and `Application.mk`. We
    only discuss `Android.mk` in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Android.mk` file is a GNU makefile fragment that describes the sources
    to the Android build system. The sources are grouped into modules. Each module
    is a static or shared library. The Android NDK provides a few predefined variables
    and macros. Here, we will briefly describe the ones used in this recipe. We will
    introduce more predefined variables and macros in subsequent recipes and you can
    also refer to Android NDK `docs/ANDROID-MK.html` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '`CLEAR_VARS`: This variable points to a script, which undefines nearly all
    module description variables except `LOCAL_PATH`. We must include it before every
    new module, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BUILD_SHARED_LIBRARY`: This variable points to a build script, which determines
    how to build a shared library from the sources listed, based on the module description.
    We must have `LOCAL_MODULE` and `LOCAL_SRC_FILES` defined when including this
    variable, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Including it will generate a shared library `lib$(LOCAL_MODULE).so`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`my-dir`: This must be evaluated by using `$(call <macro>)`. The `my-dir` macro
    returns the path of the last included makefile, which is usually the directory
    containing the current `Android.mk` file. It is typically used to define the `LOCAL_PATH`,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`all-subdir-makefiles`: This macro returns a list of `Android.mk` files located
    in all subdirectories of the current `my-dir` path. In our example, we used this
    macro in the `Android.mk` file under the `jni`, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will include the two `Android.mk` files under `libbmp` and `libbmptest`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`LOCAL_PATH`: This is a module description variable, which is used to locate
    the path to the sources. It is usually used with the `my-dir` macro, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LOCAL_MODULE`: This is a module description variable, which defines the name
    of our module. Note that it must be unique among all module names and must not
    contain any space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_SRC_FILES`: This is a module description variable, which lists out the
    sources used to build the module. Note that the sources should be relative to
    `LOCAL_PATH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_C_INCLUDES`: This is an optional module description variable, which
    provides a list of the paths that will be appended to the include search path
    at compilation. The paths should be relative to the NDK root directory. In `Android.mk`,
    under the `libbmptest` folder of our sample project, we used this variable as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LOCAL_SHARED_LIBRARIES`: This is an optional module description variable,
    which provides a list of the shared libraries the current module depends on. In
    `Android.mk`, under the `libbmptest` folder of our sample project, we used this
    variable to include the `libbmp.so` shared library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LOCAL_LDLIBS`: This is an optional module description variable, which provides
    a list of linker flags. It is useful to pass the system libraries with the `-l`
    prefix. In our sample project, we used it to link the system log library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the preceding description, it is now fairly easy to understand the three
    `Android.mk` files used in our sample project. `Android.mk` under `jni` simply
    includes another two `Android.mk` files. `Android.mk` under the `libbmp` folder
    compiles the `libbmp` sources as a shared library `libbmp.so`, and `Android.mk`
    under the `libbmptest` folder compiles `PortingShared.c` as the `libPortingShared.so`
    shared library, which depends upon the `libbmp.so` library.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to use a shared library in the native code, as we have demonstrated
    in the *Programming with dynamic linker library at Android NDK* recipe in [Chapter
    6](ch06.html "Chapter 6. Android NDK Multithreading"), *Other Android NDK API*.
  prefs: []
  type: TYPE_NORMAL
- en: Porting a library as a static library module with the Android NDK build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe discussed how to port a library as a shared library module
    with the `libbmp` library as an example. In this recipe, we will demonstrate how
    to port the `libbmp` library as a static library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the *Building an Android NDK application at
    the command line* recipe in [Chapter 3](ch03.html "Chapter 3. Build and Debug
    NDK Applications"), *Build and Debug NDK Applications*, before going through this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create our sample Android project that
    demonstrates porting the `libbmp` library as a static library:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `PortingStatic` with native support. Set
    the package name as `cookbook.chapter8.portingstatic`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, if you want more
    detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingstatic`
    package. This Java file simply loads the shared library `PortingStatic`, and calls
    the native method `naCreateABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow step 3 of the *Porting a library as shared library module with the Android
    NDK build system* recipe to download the `libbmp` library and make changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `Android.mk` file under the `libbmp` folder to compile `libbmp` as
    a static library `libbmp.a`. The content of this `Android.mk` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create another folder `libbmptest` under the `jni` folder. Add the `mylog.h`
    and `PortingStatic.c` files to it. Note that the code for it is the same as the
    `naCreateABmp` method in previous chapter except that the `.bmp` file name is
    changed from `test_shared.bmp` to `test_static.bmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another `Android.mk` file under the `libbmptest` folder to compile the
    `PortingStatic.c` file as a shared library `libPortingStatic.so`. The content
    of this `Android.mk` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project. A bitmap file `test_static.bmp` should be
    created at the `sdcard` folder of the Android device. We can use the following
    command to get the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is the same as the `test_static.bmp` file used in the previous recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the sample project, we build `libbmp` as a static library `libbmp.a`, which
    can be found under `obj/local/armeabi/ folder`. We called the functions defined
    in `libbmp` in the native code `PortingStatic.c`.
  prefs: []
  type: TYPE_NORMAL
- en: A **static library** is simply an archive of object files compiled from the
    source code. They are built as files ending with "`.a`" suffix at Android NDK.
    A static library is copied into a targeted executable or library at build time
    by a compiler or linker. At Android NDK, static libraries are only used to build
    the shared libraries, because only shared libraries are packaged into the `apk`
    file for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sample project builds a static library `libbmp.a` and a shared library
    `libPortingStatic.so`. The `libPortingStatic.so` shared library is located under
    the `libs/armeabi` folder, and will be copied to the application''s `apk` file.
    The `libbmp.a` library is used to build the `libPortingStatic.so` shared library.
    If you examine the symbols of the `libPortingStatic.so` library with the Eclipse
    project explorer, you will find that the symbols for the functions defined at
    `libbmp` are included. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1505_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The functions `bmp_create`, `bmp_destroy`, and so on, are defined in `libbmp`
    and are included in the shared library `libPortingStatic.so`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Java code, we will need to load the shared library with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Understand the Android.mk files**: The previous recipe already describes
    most of the predefined variables and macros used in the three `Android.mk` files
    in this recipe. Therefore, we only cover the ones that we have not seen in the
    previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUILD_STATIC_LIBRARY`: The variable points to a build script which will collect
    the information about the module and determine how to build a static library from
    the sources. The module built is usually listed in `LOCAL_STATIC_LIBRARIES` of
    another module. This variable is normally included in `Android.mk` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our sample project, we include this variable in the `Android.mk` file, under
    `jni/libbmp` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`LOCAL_STATIC_LIBRARIES`: This is a module description variable, which provides
    a list of static libraries the current module should be linked to. It only makes
    sense in shared library modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our project, we used this variable to link to the `libbmp.a` static library,
    as shown in the `Android.mk` file under the `jni/libbmptest/` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LOCAL_WHOLE_STATIC_LIBRARIES`: This is a variant of the `LOCAL_STATIC_LIBRARIES`
    variable. It indicates that the static libraries listed should be linked as whole
    archives. This will force all object files from the static libraries to be added
    to the current shared library module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static versus shared**: Now that you have seen how to port an existing library
    as either a static or shared library, you may ask which one is better. The answer,
    as you might have expected, depends on our needs.'
  prefs: []
  type: TYPE_NORMAL
- en: When you port a big library and only use a small portion of the functions provided
    by the library, then a static library is a good option. The Android NDK build
    system can resolve the dependencies at build time and only copy the parts that
    are used in the final shared library. This means a smaller library size and subsequently
    smaller `apk` file size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we need to force the entire static library to be built into the final
    shared library (for example, there are circular dependencies among several static
    libraries). We can use the `LOCAL_WHOLE_STATIC_LIBRARIES` variable at `Android.mk`
    or the "`--whole-archive`" linker flag.
  prefs: []
  type: TYPE_NORMAL
- en: When you port a library, which will be used by several Android apps, then shared
    library is a better choice. Suppose you want to build two Android apps, a video
    player and a video editor. Both apps will need a third-party `codec` library,
    which you can port to Android with NDK. In this case, you can port the library
    as a shared library in a separate `apk` file (for example, MX Player puts the
    `codecs` library in separate `apk` files) and the two apps can load the same library
    at runtime. This means that the users only need to download the library once to
    use both the apps.
  prefs: []
  type: TYPE_NORMAL
- en: Another case in which you may need the shared library is that a library `L`
    is used in multiple shared libraries. If `L` is a static library, each shared
    library will include a copy of its code and cause problems because of code duplication
    (for example, duplicated global variables).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have actually ported a library as a static library with Android NDK build
    system before. Recall how we ported `libpng` as a static library in the *Managing
    assets at Android NDK* recipe in [Chapter 5](ch05.html "Chapter 5. Android Native
    Application API"), *Android Native Application API*.
  prefs: []
  type: TYPE_NORMAL
- en: Porting a library with its existing build system using the Android NDK toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous two recipes discussed how to port a library with the Android NDK
    build system. However, a lot of open source projects have their own build systems
    and sometimes it is troublesome to list out all sources in the `Android.mk` file.
    Fortunately, the Android NDK toolchain can also be used as a standalone cross
    compiler and we can use the cross compiler in an open source project's existing
    build system. This recipe will discuss how to port a library with its existing
    build system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create our sample project, which demonstrates
    porting the open source `libbmp` library with its existing build system:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named PortingWithBuildSystem with native support.
    Set the package name as `cookbook.chapter8.portingwithbuildsystem`. Please refer
    to the *Loading native libraries and registering native methods* recipe of [Chapter
    2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*, if
    you want more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingwithbuildsystem`
    package. This Java file simply loads the shared library `PortingWithBuildSystem`,
    and calls the native method `naCreateABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `libbmp` library from [http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)
    and extract the archive file to the `jni` folder. This will create a folder `libbmp-0.1.3`
    under the `jni` folder with the following content:![How to do it...](img/1505_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow step 3 of the *Porting a library as shared library module with Android
    NDK build system* recipe to update `src/bmpfile.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a bash shell script file `build_android.sh` under the `libbmp-0.1.3` folder
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the execute permission to the `build_android.sh` file with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At a command line shell, go to the `libbmp-0.1.3` directory, and enter the
    following command to build the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The build will fail with the following errors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_08_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This is because the `config.guess` and `config.sub` scripts under the `libbmp-0.1.3`
    folder are out of date (the first line of these two files indicate that the timestamp
    is `2009-08-19`). We will need copies of the scripts with timestamps `2010-05-20`
    or later. The `config.guess` script can be found at [http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.guess](http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.guess)
    and `config.sub` can be found at [http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.sub](http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.sub).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try executing the `build_android.sh` script again. This time it finishes successfully.
    We should be able to find the `libbmp.a` static library under the `jni/libbmp-0.1.3/lib`
    folder and `bmpfile.h` under the `jni/libbmp-0.1.3/include` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the existing open source libraries can be built with the shell command
    "`./configure; make; make install`". In our sample project, we wrote a `build_android.sh`
    script to execute the three steps with the Android NDK cross compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a list of things we should consider when porting a library
    with the Android NDK cross compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select the appropriate toolchain**: Based on the CPU architecture (ARM, x86
    or MIPS) of our targeted devices, you need to choose the corresponding toolchain.
    The following toolchains are available under the `toolchains` folder of Android
    NDK r8d:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**For ARM-based devices**: `arm-linux-androideabi-4.4.3`, `arm-linux-androideabi-4.6`,
    `arm-linux-androideabi-4.7`, and `arm-linux-androideabi-clang3.1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For MIPS-based devices**: `mipsel-linux-android-4.4.3`, `mipsel-linux-android-4.6`,
    `mipsel-linux-android-4.7`, and `mipsel-linux-android-clang3.1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For x86-based devices**: `x86-4.4.3`, `x86-4.6`, `x86-4.7`, and `x86-clang3.1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select the sysroot**: Based on the Android native API level and CPU architecture
    we want to target, you will need to choose the appropriate sysroot. The compiler
    will look for headers and libraries under the `sysroot` directory at compilation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The path to `sysroot` follows this format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`$NDK` refers to the Android NDK root folder, `<level>` refers to the Android
    API level, and `<arch>` indicates the CPU architecture. In your `build_android.sh`
    script, `SYSROOT` is defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Specify the cross compiler**: The library''s existing build system usually
    has a way for us to specify the cross compiler. It is usually through a configuration
    option or an environment variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `libbmp`, we can enter the "`./configure --help`" command to see how to
    set the compiler. The `compiler` command is specified through the environment
    variable `CC`, while the environment variables `CFLAGS` and `LDFLAGS` are used
    to specify the compiler flags and linker flags. In your `build_android.sh` script,
    these three environment variables are set as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The "`-mthumb`" compiler flag indicates that you will use the thumb instruction
    set rather than the ARM instruction set. The "`-wl, --fix-cortex-a8`" linker flag
    is required to route around a CPU bug in some Cortex-A8 implementations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Specify the output locations for the header files and library binary**: You
    will usually want to place the library under `jni/<library folder>/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of `libbmp`, the library binary is installed under the `PREFIX/lib`
    folder and the header file is installed under the `EPREFIX/include` folder. Therefore,
    we set `PREFIX` and `EPREFIX` to `jni/libbmp-0.1.3` by passing the following options
    to configure the script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Make and install the library**: You can simply execute "`make; make install;`"
    to build and install the library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your `build_android.sh` script, we have disabled shared library. If you remove
    the line "`--disable-shared \`", the build will generate both the shared library
    (`libbmp.so`) and the static library (`libbmp.a`) under the `jni/libbmp-0.1.3/lib/`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In your sample project, we used the NDK toolchain directly. This method has
    a serious limitation that you won't be able to use any C++ STL function, and C++
    exceptions and RTTI are not supported. Android NDK actually allows you to create
    a customized toolchain installation with the script `$NDK/build/tools/make-standalone-toolchain.sh`.
    Suppose you're targeting Android API level 8; you can use the following command
    to install the toolchain at the `/tmp/my-android-toolchain` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use this toolchain by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the installed toolchain will have a few libraries (`libgnustl_shared.so`,
    `libstdc++.a`, and `libsupc++.a`) under the `/tmp/my-android-toolchain/arm-linux-androideabi/lib/`
    folder. You can link against these libraries to enable exceptions, RTTI, and STL
    functions support. We will further discuss exception and STL support in the *Porting
    a library which requires RTTI* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: More information about using the Android toolchain as a standalone compiler
    can be found at Android NDK in `docs/STANDALONE-TOOLCHAIN.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a library as a prebuilt library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe described how to build an existing library with its own
    build system. We obtained a compiled static library `libbmp.a` of the open source
    `libbmp` library. This recipe will discuss how to use a prebuilt library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps build an Android NDK application which uses prebuilt library.
    Note that the sample project is based on what we have done in the previous recipe.
    If you have not gone through previous recipe, you should do it now.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PortingWithBuildSystem` project that you created in previous recipe.
    Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingwithbuildsystem`
    package. This Java file simply loads the shared library `PortingWithBuildSystem`,
    and calls the native method `naCreateABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `mylog.h` and `PortingWithBuildSystem.c` files under it. `PortingWithBuildSystem.c`
    implements the native method `naCreateABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `Android.mk` file under the `jni` folder to compile `PortingWithBuildSystem.c`
    as a shared library `libPortingWithBuildSystem.so`. The content of this `Android.mk`
    file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project. A bitmap file `test_bs_static.bmp` should
    be created at the `sdcard` folder of the Android device. We can use the following
    command to get the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The file is the same as `test_static.bmp` shown in the *Porting a library as
    shared library module with Android NDK build system* recipe of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two common use cases for prebuilt libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to use a library from a third-party developer and only the library
    binary is provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have already built a library and want to use the library without recompiling
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your sample project belongs to the second case. Let''s look at the things to
    consider when using a prebuilt library in Android NDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declare a prebuilt library module**: In Android NDK, a build module can either
    be a static or shared library. You have seen how a module is declared with source
    code. It is similar when a module is based on a prebuilt library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'i. **Declare the module name**: This is done with the `LOCAL_MODULE` module
    description variable. In your sample project, define the module name with the
    following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ii. **List the source for the prebuilt library**: You will provide the path
    of the prebuilt library to the `LOCAL_SRC_FILES` variable. Note that the path
    is relative to `LOCAL_PATH`. In your sample project, list the path to the `libbmp.a`
    static library as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'iii. **Export the library headers**: This is done through the `LOCAL_EXPORT_C_INCLUDES`
    module description variable. The variable ensures that any modules that depend
    on the prebuilt library module will have the path to the library headers appended
    to `LOCAL_C_INCLUDES` automatically. Note that this step is optional, as we can
    also explicitly add the path to library headers to any modules that depend on
    the prebuilt library module. However, it is a better practice to export the headers
    instead of adding the path on every module that depends on the prebuilt library
    module.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In your sample project, export the library headers with the following line
    in the `Android.mk` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'iv. **Export the compiler and/or linker flags**: This can be done with `LOCAL_EXPORT_CFLAGS`,
    `LOCAL_EXPORT_CPPFLAGS`, and `LOCAL_EXPORT_LDLIBS`. This step is also optional
    and we won''t use them in your sample project. You can refer to `docs/ANDROID-MK.html`
    at Android NDK for more detailed information about these module description variables.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'v. **Declare a build type**: You will need to include `PREBUILT_SHARED_LIBRARY`
    for the shared prebuilt library and `PREBUILT_STATIC_LIBRARY` for the static prebuilt
    library. In your sample project, use the following line to declare that you want
    to build a prebuilt static library module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Use the prebuilt library module**: Once you have the prebuilt library module
    in place, you can simply list the module name in the `LOCAL_STATIC_LIBRARIES`
    or `LOCAL_SHARED_LIBRARIES` declaration of any module that depends on the prebuilt
    library. This is shown in your sample project''s `Android.mk` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Prebuilt library for debugging**: It is recommended by Android NDK that you
    provide the prebuilt library binaries that contain debug symbols, to facilitate
    debugging with `ndk-gdb`. When you package the library into an `apk` file, a stripped
    version created by Android NDK (at the project''s `libs/<abi>/` folder) will be
    used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't discuss how to generate the debug version of a library because it depends
    on how the library is built. Normally, the library documentation will contain
    instructions of how to generate a debug build. If you're building the library
    using GCC directly, then you can refer to [http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html)
    for various options for debugging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a library in multiple projects with import-module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may often need to use a library in multiple projects. You can put the library
    in each of the project's `jni` folders and build them separately. However, it
    is troublesome to maintain multiple copies of the same library. For example, when
    there is a new release of the library and you want to update the library, you
    will have to update each copy of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android NDK provides a feature to allow us maintain a library module
    outside a NDK project's main source tree and import the module with simple commands
    in the `Android.mk` file. Let's discuss how to import a module in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to declare and import a module outside of
    a project''s `jni` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `ImportModule` with native support. Set
    the package name as `cookbook.chapter8.importmodule`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface* for more detailed
    instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.importmodule`
    package. This Java file simply loads the shared library `ImportModule`, and calls
    the native method `naCreat``eABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `libbmp` library from [http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)
    and extract the archive file. Create a folder named `modules` under the project
    and a folder `libbmp-0.1.3` under the `modules` folder. Copy the `src/bmpfile.c`
    and `src/bmpfile.h` files from the extracted folder to the `libbmp-0.1.3` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow step 3 of the *Porting a library as shared library module with Android
    NDK build system* recipe to update `src/bmpfile.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `Android.mk` file under the `libbmp-0.1.3` folder to compile `libbmp`
    as a static library `libbmp.a`. The content of this `Android.mk` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `mylog.h` and `ImportModule.c` files to it. `ImportModule.c` implements
    the native method `naCreateABmp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `Android.mk` file under the `jni` folder to compile `ImportModule.c`
    as a shared library `libImportModule.so`. The content of this `Android.mk` file
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project. A bitmap file `test_bs_static.bmp` should
    be created at the `sdcard` folder of the Android device. You can use the following
    command to get the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The file is the same as `test_static.bmp`, as shown in the *Porting a library
    as shared library module with Android NDK build system* recipe of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your sample project, you created a module outside the `jni` folder of the
    project and then imported the module for building the shared library `libImportModule.so`.
    The following steps should be performed when you declare and import a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declare the import module**: There is nothing special in declaring an import
    module. Since an import module is usually used by multiple NDK projects, it is
    a good practice to export the header files (with `LOCAL_EXPORT_C_INCLUDES`), compiler
    flags (`LOCAL_EXPORT_CFLAGS` or `LOCAL_EXPORT_CPPFLAGS`), and linker flags (`LOCAL_EXPORT_LDLIBS`)
    when declaring the import module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our sample project, you declared an import static library module `libbmp`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Decide the place to put the import module**: The Android NDK build system
    will search the paths defined in `NDK_MODULE_PATH` for the import modules. By
    default, the `sources` folder of the Android NDK directory is appended to `NDK_MODULE_PATH`.
    Therefore, you can simply place our import module folder under the `sources` folder
    and the Android NDK build system will be able to find it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can place the import module folder anywhere and append the
    path to `NDK_MODULE_PATH`. In our sample project, place the import the `libbmp`
    module in the `modules` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Append the import path**: This is not needed when placing the import module
    folder under the `sources` directory of Android NDK. Otherwise, you will need
    to tell the Android NDK build system where the import modules are, by appending
    the path to `NDK_MODULE_PATH`. The `import-add-path` macro is provided by NDK
    to help you to append the path.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your sample project, you appended the `modules` folder to `NDK_MODULE_PATH`
    with the following line at `jni/Android.mk`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Import the module**: Android NDK provides a macro `import-module` to import
    a module. This macro accepts a relative path to the import module''s folder where
    the `Android.mk` file of the import module is located. The Android NDK build system
    will search for all the paths defined at `NDK_MODULE_PATH` for the import module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your sample project, you imported the module with the following line at
    the `jni/Android.mk` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The NDK build system will search for the `libbmp-0.1.3/Android.mk` file at all
    `NDK_MODULE_PATH` directories for the import modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use the module**: Using an import module is just like using any other library
    module. You will need to link to the library by listing it at `LOCAL_STATIC_LIBRARIES`
    for the static library import module and `LOCAL_SHARED_LIBRARIES` for the shared
    library import module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more information about how to import modules, you can refer to `docs/IMPORT-MODULE.html`
    at Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Porting a library that requires RTTI, exception, and STL support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android platform provides a C++ runtime library at `/system/lib/libstdc++.so`.
    This default runtime library does not provide C++ exception and RTTI. The support
    for a standard C++ library is also limited. Fortunately, Android NDK provides
    alternatives to the default C++ runtime library, which makes porting of a large
    number of existing libraries that require exception, RTTI, and STL support, possible.
    This recipe discusses how to port a C++ library that requires RTTI, exception,
    and STL support. You will widely use the `boost` library as an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to build and use the `boost` library for Android
    NDK:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a customized Android toolchain with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should install the toolchain at the `/tmp/my-android-toolchain` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an Android application named `PortingBoost` with native support. Set
    the package name as `cookbook.chapter8.portingboost`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface* for more detailed
    instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingboost`
    package. This Java file simply loads the shared library `PortingBoost`, and calls
    the native method `naExtractSubject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the boost library from [http://sourceforge.net/projects/boost/files/boost/](http://sourceforge.net/projects/boost/files/boost/).
    In this recipe, you will build the `boost` library 1.51.0\. Extract the downloaded
    archive file to the `jni` folder. This will create a folder named `boost_1_51_0`
    under the `jni` folder as follows:![How to do it...](img/1505_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a command line shell, go to the `boost_1_51_0` directory. Enter the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `user-config.jam` file under the `jni/boost_1_51_0/tools/build/v2`
    folder. Append the following content to the end of the file. You can refer to
    [http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html](http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html)
    for more information about boost configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try building the `boost` library with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will execute the `boost` build in the background. You can monitor
    the build output by using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The build will take some time to finish. It will fail to build some targets.
    We can examine the errors in the `log.txt` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first error is that the `sys/statvfs.h` file is not found. You can fix
    this by updating the `libs/filesystem/src/operations.cpp` file. The updated parts
    are highlighted as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second error is that the `bzlib.h` file is not found. This is because `bzip`
    is available on Android. You can disable `bzip` by adding the following line at
    the top of `jni/boost_1_51_0/tools/build/v2/user-config.jam`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third error is that `PAGE_SIZE` is not declared in this scope. You can
    fix this by adding the following line to `boost_1_51_0/boost/thread/thread.hpp`
    and `boost_1_51_0/boost/thread/pthread/thread_data.hpp`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try building the library again with the same command in step 5\. This time the
    library will build successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `mylog.h` and `PortingBoost.cpp` files under the `jni` folder. The
    `PortingBoost.cpp` file contains the implementation for the native method `naExtractSubject`.
    The function will match each line of the input string `pInputStr` with a regular
    expression using the `boost` library''s `regex_match` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Application.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the project. You can monitor the logcat output with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the logcat output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_08_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your sample project, you first built the boost library using the Android
    toolchain as a standalone compiler. You then used the `regex` library from `boost`
    as a prebuilt module. Note that the `boost` library requires support for C++ exceptions
    and STL. Let's discuss how to enable support for these features at Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: '**C++ runtime at Android NDK**: By default, Android comes with a minimal C++
    runtime library `at /system/lib/libstdc++.so`. The library does not support most
    C++ standard library functions, C++ exceptions, and RTTI. Fortunately, Android
    NDK comes with additional C++ runtime libraries that we can use. The following
    table summarizes the features provided by different runtime libraries at NDK r8:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | C++ standard library | C++ exceptions | C++ RTTI |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **system** | minimal | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| **gabi++** | minimal | No (yes if NDK r8d or later) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **stlport** | yes | No (yes if NDK r8d or later) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **gnustl** | yes | yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C++ exceptions have been added to `gabi++` and `stlport` since Android NDK
    r8d.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system library refers to the default value that comes with the Android
    system. There is only a minimal C++ standard library support, and no C++ exceptions
    and RTTI. The C++ headers supported include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`gabi++` is a runtime library, which supports RTTI in addition to the C++ functions
    provided by the system default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stlport` provides a complete set of C++ standard library headers and RTTI.
    However, C++ exception is not supported. In fact, Android NDK `stlport` is based
    on `gabi++`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gnustl` is the GNU standard C++ library. It comes with a complete set of C++
    headers, and supports C++ exceptions and RTTI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The shared library file `gnustl` is named as `libgnustl_shared.so` instead of
    `libstdc++.so` in other platforms. This is because the name `libstdc++.so` is
    used by the system default C++ runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Android NDK build system allows us to specify the C++ library runtime to
    link to the `Application.mk` file. Based on the library type (shared or static)
    and which runtime to use, we can define `APP_STL` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Static library | Shared library |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **gabi++** | `gabi++_static` | `gabi++_shared` |'
  prefs: []
  type: TYPE_TB
- en: '| **stlport** | `stlport_static` | `stlport_shared` |'
  prefs: []
  type: TYPE_TB
- en: '| **gnustl** | `gnustl_static` | `gnustl_shared` |'
  prefs: []
  type: TYPE_TB
- en: 'In your sample project, add the following line in `Application.mk` to use the
    `gnustl` static library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can only link a static C++ library into a single shared library. If a project
    uses multiple shared libraries and all libraries link to a static C++ library,
    each shared library will include a copy of the library's code in its binary. This
    will cause some problems, because some global variables used by the C++ runtime
    library are duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: The sources, headers, and binaries of these libraries can be found at the `sources/cxx-stl`
    folder of Android NDK. You can also refer to `docs/CPLUSPLUS-SUPPORT.html` for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enable the C++ exception support**: By default, all C++ sources are compiled
    with `-fno-exceptions`. In order to enable C++ exceptions, you will need to choose
    a C++ library, which supports exceptions (`gnustl_static` or `gnustl_shared`),
    and do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At `Android.mk`, add exceptions to `LOCAL_CPP_FEATURES` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At `Android.mk`, add `-fexceptions` to `LOCAL_CPPFLAGS` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At `Application.mk`, add the following line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Enable the C++ RTTI support**: By default, C++ sources are compiled with
    `-fno-rtti`. In order to enable the RTTI support, you will need to use a C++ library,
    which supports RTTI, and do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At `Android.mk`, add `rtti` to `LOCAL_CPP_FEATURES` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At `Android.mk`, add `-frtti` to `LOCAL_CPPFLAGS` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At `Application.mk`, add -`frtti` to `APP_CPPFLAGS` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
