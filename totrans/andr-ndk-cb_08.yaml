- en: Chapter 8. Porting and Using the Existing Libraries with Android NDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 使用Android NDK移植和使用现有库
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Porting a library as a shared library module with the Android NDK build system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK构建系统将库作为共享库模块移植
- en: Porting a library as a static library module with the Android NDK build system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK构建系统将库作为静态库模块移植
- en: Porting a library with its existing build system using the Android NDK toolchain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK工具链移植使用现有构建系统的库
- en: Using a library as a prebuilt library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库作为预构建库使用
- en: Using a library in multiple projects with import-module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个项目中使用 import-module 引入库
- en: Porting a library that requires RTTI, exception, and STL support
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植需要RTTI、异常和STL支持的库
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: There are many C/C++ libraries for the Desktop computing world. These libraries
    can save us a huge amount of effort if we can reuse them on an Android platform.
    Android NDK makes this possible. In this chapter, we will discuss how to port
    the existing libraries to Android with NDK.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面计算领域有许多C/C++库。如果我们能在Android平台上重用它们，这些库可以为我们节省大量的努力。Android NDK使这成为可能。在本章中，我们将讨论如何使用NDK将现有库移植到Android。
- en: We will first introduce how to build libraries with the Android NDK build system.
    We can build a library as a static library module or a shared library module.
    The differences between the two will be discussed in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍如何使用Android NDK构建系统构建库。我们可以将库构建为静态库模块或共享库模块。本章将讨论这两种方式的区别。
- en: We can also use the Android NDK toolchain as a standalone cross compiler, which
    is covered next. We will then describe how to use the compiled libraries as prebuilt
    modules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将Android NDK工具链作为独立的交叉编译器使用，这将在下一节介绍。然后，我们将描述如何使用编译后的库作为预构建模块。
- en: We often use the same library in multiple Android projects. We can use the **import-module**
    feature to link to the same library module to multiple projects while maintaining
    a single copy of the library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在多个Android项目中使用同一个库。我们可以使用 **import-module** 功能将相同的库模块链接到多个项目，同时保持库的单个副本。
- en: Many C++ libraries require STL, C++ exceptions, and **Run-Time Type Information**
    (**RTTI**) supports, which are not available with the Android default C++ runtime
    library. We will illustrate how to enable these supports by using the popular
    `boost` library as an example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多C++库需要STL、C++异常和**运行时类型信息**（**RTTI**）的支持，这些在Android默认的C++运行时库中是不可用的。我们将通过使用流行的
    `boost` 库作为示例，说明如何启用这些支持。
- en: Porting a library as a shared library module with the Android NDK build system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android NDK构建系统将库作为共享库模块移植
- en: This recipe will discuss how to port an existing library as a shared library
    with the Android NDK build system. We will use the open source `libbmp` library
    as an example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将讨论如何使用Android NDK构建系统将现有库作为一个共享库进行移植。我们将以开源的 `libbmp` 库为例。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Readers are recommended to read the *Building an Android NDK application at
    the command line* recipe in [Chapter 3](ch03.html "Chapter 3. Build and Debug
    NDK Applications"), *Build and Debug NDK Applications*, before going through this
    one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 建议读者在阅读本节之前先阅读[第3章](ch03.html "第3章. 构建和调试NDK应用程序")中的*在命令行构建Android NDK应用程序*食谱，*构建和调试NDK应用程序*。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to create our sample Android project that
    demonstrates porting the libbmp library as a shared library:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建我们的示例Android项目，演示如何将 libbmp 库作为共享库进行移植：
- en: Create an Android application named `PortingShared` with native support. Set
    the package name as `cookbook.chapter8.portingshared`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, if you want more
    detailed instructions.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PortingShared` 的Android应用程序，并具有本地支持。将包名设置为 `cookbook.chapter8.portingshared`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章. Java本地接口")中的*加载本地库和注册本地方法*食谱，*Java Native Interface*。
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingshared`
    package. This Java file simply loads the shared library `.bmp` and `PortingShared`,
    and calls the native method `naCreateABmp`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cookbook.chapter8.portingshared` 包下添加一个Java文件 `MainActivity.java`。这个Java文件简单加载共享库
    `.bmp` 和 `PortingShared`，并调用本地方法 `naCreateABmp`。
- en: Download the `libbmp` library from [http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list),
    and extract the archive file. Create a folder named `libbmp` under the `jni` folder,
    and copy the `src/bmpfile.c` and `src/bmpfile.h` files from the extracted folder
    to the `libbmp` folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)下载`libbmp`库，并解压存档文件。在`jni`文件夹下创建一个名为`libbmp`的文件夹，并将提取的文件夹中的`src/bmpfile.c`和`src/bmpfile.h`文件复制到`libbmp`文件夹。
- en: 'Remove the following code from `bmpfile.h` if you are using NDK r8 and below:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是NDK r8及以下版本，请从`bmpfile.h`中删除以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add the following line of code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下代码行：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code changes for `bmpfile.h` are only necessary for Android NDK r8 and
    below. Compiling the library will return an error `"error: redefinition of typedef
    ''uint8_t''`". This is a bug in the NDK build system as the `uint8_t` definition
    is enclosed by the `#ifndef` preprocessor. It has been fixed since NDK r8b, and
    we don''t need to change the code if we''re using r8b and above.'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '对`bmpfile.h`的代码更改仅适用于Android NDK r8及以下版本。编译库将返回错误`"error: redefinition of typedef
    ''uint8_t''"`。这是NDK构建系统中的一个错误，因为`uint8_t`的定义被`#ifndef`预处理指令包围。从NDK r8b开始，这个问题已被修复，如果我们使用r8b及以上版本，则无需更改代码。'
- en: 'Create an `Android.mk` file under the `libbmp` folder to compile `libbmp` as
    a shared library `libbmp.so`. The content of this `Android.mk` file is as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libbmp`文件夹下创建一个`Android.mk`文件，以将`libbmp`编译为共享库`libbmp.so`。此`Android.mk`文件的内容如下：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create another folder named `libbmptest` under the `jni` folder. Add the `mylog.h`
    and `PortingShared.c` files under it. `PortingShared.c` implements the native
    method `naCreateABmp`, which uses functions defined in the `libbmp` library to
    create a bitmap image and save it to `/sdcard/test_shared.bmp`. You will need
    to change directory if the `/sdcard` directory is not available on your devices:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建另一个名为`libbmptest`的文件夹。在其下添加`mylog.h`和`PortingShared.c`文件。`PortingShared.c`实现了本地方法`naCreateABmp`，该方法使用`libbmp`库中定义的函数来创建位图图像并将其保存到`/sdcard/test_shared.bmp`。如果您的设备上没有`/sdcard`目录，您需要更改目录：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create another `Android.mk` file under the `libbmptest` folder to compile the
    `PortingShared.c` file as another shared library `libPortingShared.so`. The content
    of this `Android.mk` file is as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libbmptest`文件夹下创建另一个`Android.mk`文件，以将`PortingShared.c`文件编译为另一个共享库`libPortingShared.so`。此`Android.mk`文件的内容如下：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建一个`Android.mk`文件，内容如下：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AndroidManifest.xml`文件添加`WRITE_EXTERNAL_STORAGE`权限，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build and run the Android project. A bitmap file `test_shared.bmp` should be
    created at the `sdcard` folder of the Android device. We can use the following
    command to get the file:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目。在Android设备的`sdcard`文件夹中应创建一个位图文件`test_shared.bmp`。我们可以使用以下命令获取该文件：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is a `.bmp` file:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是`.bmp`文件：
- en: '![How to do it...](img/1505_08_01.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_08_01.jpg)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The sample project demonstrates how to port the `libbmp` code as a shared library
    and use it in the native code `PortingShared.c`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目演示了如何将`libbmp`代码作为共享库进行移植并在本地代码`PortingShared.c`中使用。
- en: '**Shared library**: A shared library can be shared by multiple executables
    and libraries. The Android native code is usually compiled as shared libraries
    and loaded by the Java code. In fact, the Android build system only packages shared
    libraries into the application''s `apk` file. Therefore, we must provide at least
    one shared library to contain our native code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享库**：共享库可以被多个可执行文件和库共享。Android本地代码通常被编译为共享库并由Java代码加载。实际上，Android构建系统只将共享库打包到应用程序的`apk`文件中。因此，我们必须至少提供一个共享库来包含我们的本地代码。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can still use static libraries to generate shared libraries, as we will see
    in the *Porting a library as static library module with Android NDK build system*
    recipe.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用静态库来生成共享库，正如我们将在*将库作为静态库模块与Android NDK构建系统*的配方中看到的那样。
- en: Our sample project builds two shared libraries, namely `libbmp.so` and `libPortingShared.so`.
    We can find these libraries under the `libs` folder of the project. `libPortingShared.so`
    depends on `libbmp.so`, since `PortingShared.c` calls functions defined in the
    `libbmp` library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例项目构建了两个共享库，分别是`libbmp.so`和`libPortingShared.so`。我们可以在项目的`libs`文件夹下找到这些库。`libPortingShared.so`依赖于`libbmp.so`，因为`PortingShared.c`调用了`libbmp`库中定义的函数。
- en: 'In our Java file, we need to load `libbmp.so` before `libPortingShared.so`,
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java文件中，我们需要在`libPortingShared.so`之前加载`libbmp.so`，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Understand the Android.mk files**: Android NDK provides an easy-to-use build
    system, which frees us from writing makefiles. However, we still need to provide
    some basic inputs to the system through `Android.mk` and `Application.mk`. We
    only discuss `Android.mk` in this recipe.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解Android.mk文件**：Android NDK 提供了一个易于使用的构建系统，使我们免于编写makefile。然而，我们仍然需要通过`Android.mk`和`Application.mk`向系统提供一些基本输入。本节仅讨论`Android.mk`。'
- en: The `Android.mk` file is a GNU makefile fragment that describes the sources
    to the Android build system. The sources are grouped into modules. Each module
    is a static or shared library. The Android NDK provides a few predefined variables
    and macros. Here, we will briefly describe the ones used in this recipe. We will
    introduce more predefined variables and macros in subsequent recipes and you can
    also refer to Android NDK `docs/ANDROID-MK.html` for more information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`文件是一个GNU makefile片段，它向Android构建系统描述源文件。源文件被分组到模块中。每个模块都是一个静态或共享库。Android
    NDK提供了一些预定义的变量和宏。这里，我们将简要介绍本节中使用的那些。我们将在后续的菜谱中介绍更多预定义的变量和宏，你也可以参考Android NDK的`docs/ANDROID-MK.html`获取更多信息。'
- en: '`CLEAR_VARS`: This variable points to a script, which undefines nearly all
    module description variables except `LOCAL_PATH`. We must include it before every
    new module, as follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLEAR_VARS`：此变量指向一个脚本，它取消定义几乎所有模块描述变量，除了`LOCAL_PATH`。我们必须在每个新模块之前包含它，如下所示：'
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`BUILD_SHARED_LIBRARY`: This variable points to a build script, which determines
    how to build a shared library from the sources listed, based on the module description.
    We must have `LOCAL_MODULE` and `LOCAL_SRC_FILES` defined when including this
    variable, as follows:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_SHARED_LIBRARY`：此变量指向一个构建脚本，它根据模块描述确定如何从列出的源构建共享库。包含此变量时，我们必须定义`LOCAL_MODULE`和`LOCAL_SRC_FILES`，如下所示：'
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Including it will generate a shared library `lib$(LOCAL_MODULE).so`.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含它将生成共享库`lib$(LOCAL_MODULE).so`。
- en: '`my-dir`: This must be evaluated by using `$(call <macro>)`. The `my-dir` macro
    returns the path of the last included makefile, which is usually the directory
    containing the current `Android.mk` file. It is typically used to define the `LOCAL_PATH`,
    as follows:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-dir`：必须使用`$(call <macro>)`来评估它。`my-dir`宏返回最后一个包含的makefile的路径，这通常是包含当前`Android.mk`文件的目录。它通常用于定义`LOCAL_PATH`，如下所示：'
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`all-subdir-makefiles`: This macro returns a list of `Android.mk` files located
    in all subdirectories of the current `my-dir` path. In our example, we used this
    macro in the `Android.mk` file under the `jni`, as follows:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all-subdir-makefiles`：此宏返回当前`my-dir`路径下所有子目录中的`Android.mk`文件列表。在我们的示例中，我们在`jni`目录下的`Android.mk`文件中使用了这个宏，如下所示：'
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will include the two `Android.mk` files under `libbmp` and `libbmptest`.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将包含`libbmp`和`libbmptest`目录下的两个`Android.mk`文件。
- en: '`LOCAL_PATH`: This is a module description variable, which is used to locate
    the path to the sources. It is usually used with the `my-dir` macro, as follows:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PATH`：这是一个模块描述变量，用于定位源文件的路径。它通常与`my-dir`宏一起使用，如下所示：'
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`LOCAL_MODULE`: This is a module description variable, which defines the name
    of our module. Note that it must be unique among all module names and must not
    contain any space.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`：这是一个模块描述变量，用于定义我们模块的名称。请注意，它必须在所有模块名称中唯一，并且不能包含任何空格。'
- en: '`LOCAL_SRC_FILES`: This is a module description variable, which lists out the
    sources used to build the module. Note that the sources should be relative to
    `LOCAL_PATH`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`：这是一个模块描述变量，用于列出构建模块时使用的源文件。注意，这些源文件应该是相对于`LOCAL_PATH`的路径。'
- en: '`LOCAL_C_INCLUDES`: This is an optional module description variable, which
    provides a list of the paths that will be appended to the include search path
    at compilation. The paths should be relative to the NDK root directory. In `Android.mk`,
    under the `libbmptest` folder of our sample project, we used this variable as
    follows:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_C_INCLUDES`：这是一个可选的模块描述变量，它提供将附加到编译时包含搜索路径的路径列表。这些路径应该是相对于NDK根目录的。在我们的示例项目的`libbmptest`文件夹下的`Android.mk`中，我们使用这个变量如下：'
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`LOCAL_SHARED_LIBRARIES`: This is an optional module description variable,
    which provides a list of the shared libraries the current module depends on. In
    `Android.mk`, under the `libbmptest` folder of our sample project, we used this
    variable to include the `libbmp.so` shared library:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SHARED_LIBRARIES`：这是一个可选的模块描述变量，提供当前模块依赖的共享库列表。在`libbmptest`文件夹下的`Android.mk`中，我们使用这个变量来包含`libbmp.so`共享库：'
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`LOCAL_LDLIBS`: This is an optional module description variable, which provides
    a list of linker flags. It is useful to pass the system libraries with the `-l`
    prefix. In our sample project, we used it to link the system log library:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_LDLIBS`：这是一个可选的模块描述变量，提供链接器标志列表。它用于传递带有`-l`前缀的系统库。在我们的示例项目中，我们使用它来链接系统日志库：'
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the preceding description, it is now fairly easy to understand the three
    `Android.mk` files used in our sample project. `Android.mk` under `jni` simply
    includes another two `Android.mk` files. `Android.mk` under the `libbmp` folder
    compiles the `libbmp` sources as a shared library `libbmp.so`, and `Android.mk`
    under the `libbmptest` folder compiles `PortingShared.c` as the `libPortingShared.so`
    shared library, which depends upon the `libbmp.so` library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的描述，现在可以很容易地理解我们示例项目中使用的三个`Android.mk`文件。`jni`下的`Android.mk`简单地包含了另外两个`Android.mk`文件。`libbmp`文件夹下的`Android.mk`将`libbmp`源代码编译为共享库`libbmp.so`，而`libbmptest`文件夹下的`Android.mk`将`PortingShared.c`编译为依赖于`libbmp.so`库的`libPortingShared.so`共享库。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: It is possible to use a shared library in the native code, as we have demonstrated
    in the *Programming with dynamic linker library at Android NDK* recipe in [Chapter
    6](ch06.html "Chapter 6. Android NDK Multithreading"), *Other Android NDK API*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在本地代码中使用共享库，正如我们在[第6章](ch06.html "第6章。Android NDK多线程")的*使用Android NDK动态链接库进行编程*食谱中演示的那样，*其他Android
    NDK API*。
- en: Porting a library as a static library module with the Android NDK build system
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android NDK构建系统将库作为静态库模块移植
- en: The previous recipe discussed how to port a library as a shared library module
    with the `libbmp` library as an example. In this recipe, we will demonstrate how
    to port the `libbmp` library as a static library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个食谱讨论了如何将库作为共享库模块移植，以`libbmp`库为例。在本食谱中，我们将展示如何将`libbmp`库作为静态库移植。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Readers are recommended to read the *Building an Android NDK application at
    the command line* recipe in [Chapter 3](ch03.html "Chapter 3. Build and Debug
    NDK Applications"), *Build and Debug NDK Applications*, before going through this
    one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 建议读者在阅读本食谱之前，先阅读[第3章](ch03.html "第3章。构建和调试NDK应用程序")的*在命令行构建Android NDK应用程序*食谱，*构建和调试NDK应用程序*。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to create our sample Android project that
    demonstrates porting the `libbmp` library as a static library:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建我们的示例Android项目，演示如何将`libbmp`库作为静态库移植：
- en: Create an Android application named `PortingStatic` with native support. Set
    the package name as `cookbook.chapter8.portingstatic`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, if you want more
    detailed instructions.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PortingStatic`的具有本地支持的Android应用程序。将包名设置为`cookbook.chapter8.portingstatic`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章。Java本地接口")的*加载本地库和注册本地方法*食谱，*Java Native Interface*。
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingstatic`
    package. This Java file simply loads the shared library `PortingStatic`, and calls
    the native method `naCreateABmp`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter8.portingstatic`包下添加一个Java文件`MainActivity.java`。这个Java文件简单地加载共享库`PortingStatic`，并调用本地方法`naCreateABmp`。
- en: Follow step 3 of the *Porting a library as shared library module with the Android
    NDK build system* recipe to download the `libbmp` library and make changes.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第3步的*使用Android NDK构建系统将库作为共享库模块移植*食谱下载`libbmp`库并进行修改。
- en: 'Create an `Android.mk` file under the `libbmp` folder to compile `libbmp` as
    a static library `libbmp.a`. The content of this `Android.mk` file is as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libbmp`文件夹下创建一个`Android.mk`文件，以编译`libbmp`为静态库`libbmp.a`。这个`Android.mk`文件的内容如下：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create another folder `libbmptest` under the `jni` folder. Add the `mylog.h`
    and `PortingStatic.c` files to it. Note that the code for it is the same as the
    `naCreateABmp` method in previous chapter except that the `.bmp` file name is
    changed from `test_shared.bmp` to `test_static.bmp`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建另一个文件夹`libbmptest`。向其中添加`mylog.h`和`PortingStatic.c`文件。注意，它的代码与之前章节中的`naCreateABmp`方法相同，只是`.bmp`文件名从`test_shared.bmp`更改为`test_static.bmp`。
- en: 'Create another `Android.mk` file under the `libbmptest` folder to compile the
    `PortingStatic.c` file as a shared library `libPortingStatic.so`. The content
    of this `Android.mk` file is as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libbmptest`文件夹下创建另一个`Android.mk`文件，以编译`PortingStatic.c`文件作为共享库`libPortingStatic.so`。这个`Android.mk`文件的内容如下：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create an `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建一个`Android.mk`文件，内容如下：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AndroidManifest.xml`文件添加`WRITE_EXTERNAL_STORAGE`权限，如下所示：
- en: '[PRE20]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Build and run the Android project. A bitmap file `test_static.bmp` should be
    created at the `sdcard` folder of the Android device. We can use the following
    command to get the file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目。应该在Android设备的`sdcard`文件夹中创建位图文件`test_static.bmp`。我们可以使用以下命令获取该文件：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This file is the same as the `test_static.bmp` file used in the previous recipe.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件与上一个食谱中使用的`test_static.bmp`文件相同。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the sample project, we build `libbmp` as a static library `libbmp.a`, which
    can be found under `obj/local/armeabi/ folder`. We called the functions defined
    in `libbmp` in the native code `PortingStatic.c`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例项目中，我们将`libbmp`构建为静态库`libbmp.a`，可以在`obj/local/armeabi/`文件夹下找到。我们在本地代码`PortingStatic.c`中调用了在`libbmp`中定义的函数。
- en: A **static library** is simply an archive of object files compiled from the
    source code. They are built as files ending with "`.a`" suffix at Android NDK.
    A static library is copied into a targeted executable or library at build time
    by a compiler or linker. At Android NDK, static libraries are only used to build
    the shared libraries, because only shared libraries are packaged into the `apk`
    file for deployment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态库**仅仅是从源代码编译的对象文件的归档。在Android NDK中，它们被构建为以"`.a`"后缀结尾的文件。静态库在构建时由编译器或链接器复制到目标可执行文件或库中。在Android
    NDK中，静态库仅用于构建共享库，因为只有共享库会被打包到`apk`文件中以便部署。'
- en: 'Our sample project builds a static library `libbmp.a` and a shared library
    `libPortingStatic.so`. The `libPortingStatic.so` shared library is located under
    the `libs/armeabi` folder, and will be copied to the application''s `apk` file.
    The `libbmp.a` library is used to build the `libPortingStatic.so` shared library.
    If you examine the symbols of the `libPortingStatic.so` library with the Eclipse
    project explorer, you will find that the symbols for the functions defined at
    `libbmp` are included. This is shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例项目构建了一个静态库`libbmp.a`和一个共享库`libPortingStatic.so`。`libPortingStatic.so`共享库位于`libs/armeabi`文件夹下，将被复制到应用程序的`apk`文件中。`libbmp.a`库用于构建`libPortingStatic.so`共享库。如果你使用Eclipse项目资源管理器检查`libPortingStatic.so`库的符号，你会发现`libbmp`中定义的函数的符号被包含在内。以下截图展示了这一点：
- en: '![How it works...](img/1505_08_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1505_08_02.jpg)'
- en: The functions `bmp_create`, `bmp_destroy`, and so on, are defined in `libbmp`
    and are included in the shared library `libPortingStatic.so`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`bmp_create`、`bmp_destroy`等在`libbmp`中定义，并包含在共享库`libPortingStatic.so`中。
- en: 'In our Java code, we will need to load the shared library with the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java代码中，我们需要使用以下代码加载共享库：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Understand the Android.mk files**: The previous recipe already describes
    most of the predefined variables and macros used in the three `Android.mk` files
    in this recipe. Therefore, we only cover the ones that we have not seen in the
    previous recipe:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解 Android.mk 文件**：上一个食谱已经描述了在这三个`Android.mk`文件中使用的预定义变量和宏的大部分内容。因此，我们只涉及那些在上一个食谱中没有看到的内容：'
- en: '`BUILD_STATIC_LIBRARY`: The variable points to a build script which will collect
    the information about the module and determine how to build a static library from
    the sources. The module built is usually listed in `LOCAL_STATIC_LIBRARIES` of
    another module. This variable is normally included in `Android.mk` as follows:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_STATIC_LIBRARY`：该变量指向一个构建脚本，该脚本将收集模块的信息并确定如何从源代码构建静态库。通常在另一个模块的`LOCAL_STATIC_LIBRARIES`中列出构建的模块。这个变量通常在`Android.mk`中如下包含：'
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our sample project, we include this variable in the `Android.mk` file, under
    `jni/libbmp` folder.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们在`jni/libbmp`文件夹下的`Android.mk`文件中包含了这个变量。
- en: '`LOCAL_STATIC_LIBRARIES`: This is a module description variable, which provides
    a list of static libraries the current module should be linked to. It only makes
    sense in shared library modules.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_STATIC_LIBRARIES`：这是一个模块描述变量，它提供当前模块应链接到的静态库列表。它只在共享库模块中有意义。'
- en: In our project, we used this variable to link to the `libbmp.a` static library,
    as shown in the `Android.mk` file under the `jni/libbmptest/` folder.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们使用这个变量链接到`libbmp.a`静态库，如`jni/libbmptest/`文件夹下的`Android.mk`文件所示。
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`LOCAL_WHOLE_STATIC_LIBRARIES`: This is a variant of the `LOCAL_STATIC_LIBRARIES`
    variable. It indicates that the static libraries listed should be linked as whole
    archives. This will force all object files from the static libraries to be added
    to the current shared library module.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_WHOLE_STATIC_LIBRARIES`：这是`LOCAL_STATIC_LIBRARIES`变量的一个变体。它指示列出的静态库应该作为完整的归档链接。这将强制将静态库中的所有对象文件添加到当前的共享库模块中。'
- en: '**Static versus shared**: Now that you have seen how to port an existing library
    as either a static or shared library, you may ask which one is better. The answer,
    as you might have expected, depends on our needs.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态库与共享库**：现在你已经了解了如何将现有库作为静态库或共享库移植，你可能会问哪个更好。答案可能如你所料，取决于我们的需求。'
- en: When you port a big library and only use a small portion of the functions provided
    by the library, then a static library is a good option. The Android NDK build
    system can resolve the dependencies at build time and only copy the parts that
    are used in the final shared library. This means a smaller library size and subsequently
    smaller `apk` file size.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移植一个大型库，并且只使用了库提供的一小部分功能时，静态库是一个好的选择。Android NDK构建系统可以在构建时解决依赖关系，并且只将最终共享库中使用的那部分复制。这意味着库的大小更小，相应的`apk`文件大小也更小。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Sometimes, we need to force the entire static library to be built into the final
    shared library (for example, there are circular dependencies among several static
    libraries). We can use the `LOCAL_WHOLE_STATIC_LIBRARIES` variable at `Android.mk`
    or the "`--whole-archive`" linker flag.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要强制将整个静态库构建到最终的共享库中（例如，几个静态库之间存在循环依赖）。我们可以在`Android.mk`中使用`LOCAL_WHOLE_STATIC_LIBRARIES`变量或"`--whole-archive`"链接器标志。
- en: When you port a library, which will be used by several Android apps, then shared
    library is a better choice. Suppose you want to build two Android apps, a video
    player and a video editor. Both apps will need a third-party `codec` library,
    which you can port to Android with NDK. In this case, you can port the library
    as a shared library in a separate `apk` file (for example, MX Player puts the
    `codecs` library in separate `apk` files) and the two apps can load the same library
    at runtime. This means that the users only need to download the library once to
    use both the apps.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要移植一个将被多个Android应用使用的库时，共享库是一个更好的选择。假设你想要构建两个Android应用，一个是视频播放器，一个是视频编辑器。这两个应用都需要一个第三方`codec`库，你可以使用NDK将其移植到Android上。在这种情况下，你可以将库作为一个共享库单独放在一个`apk`文件中（例如，MX
    Player将`codecs`库放在单独的`apk`文件中），这样两个应用可以在运行时加载同一个库。这意味着用户只需下载一次库就可以使用这两个应用。
- en: Another case in which you may need the shared library is that a library `L`
    is used in multiple shared libraries. If `L` is a static library, each shared
    library will include a copy of its code and cause problems because of code duplication
    (for example, duplicated global variables).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能需要共享库的情况是，一个库`L`被多个共享库使用。如果`L`是一个静态库，每个共享库将包含其代码的副本，并因代码重复（例如，重复的全局变量）而造成问题。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We have actually ported a library as a static library with Android NDK build
    system before. Recall how we ported `libpng` as a static library in the *Managing
    assets at Android NDK* recipe in [Chapter 5](ch05.html "Chapter 5. Android Native
    Application API"), *Android Native Application API*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们之前使用Android NDK构建系统将一个库作为静态库移植过。回想一下我们在[第5章](ch05.html "第5章. Android原生应用API")的*在Android
    NDK上管理资产*菜谱中，如何将`libpng`作为静态库移植的。
- en: Porting a library with its existing build system using the Android NDK toolchain
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android NDK工具链移植带有现有构建系统的库
- en: The previous two recipes discussed how to port a library with the Android NDK
    build system. However, a lot of open source projects have their own build systems
    and sometimes it is troublesome to list out all sources in the `Android.mk` file.
    Fortunately, the Android NDK toolchain can also be used as a standalone cross
    compiler and we can use the cross compiler in an open source project's existing
    build system. This recipe will discuss how to port a library with its existing
    build system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个食谱讨论了如何使用Android NDK构建系统移植库。然而，许多开源项目都有自己的构建系统，有时在`Android.mk`文件中列出所有源文件会很麻烦。幸运的是，Android
    NDK工具链也可以作为一个独立的交叉编译器使用，我们可以将交叉编译器用在开源项目的现有构建系统中。这个食谱将讨论如何使用现有的构建系统移植库。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to create our sample project, which demonstrates
    porting the open source `libbmp` library with its existing build system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建我们的示例项目，该项目展示了如何使用现有的构建系统移植开源`libbmp`库：
- en: Create an Android application named PortingWithBuildSystem with native support.
    Set the package name as `cookbook.chapter8.portingwithbuildsystem`. Please refer
    to the *Loading native libraries and registering native methods* recipe of [Chapter
    2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*, if
    you want more detailed instructions.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为PortingWithBuildSystem的Android应用程序，并支持本地原生代码。将包名设置为`cookbook.chapter8.portingwithbuildsystem`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章. Java本地接口")的*加载本地库和注册本地方法*食谱，*Java Native Interface*。
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingwithbuildsystem`
    package. This Java file simply loads the shared library `PortingWithBuildSystem`,
    and calls the native method `naCreateABmp`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter8.portingwithbuildsystem`包下添加一个Java文件`MainActivity.java`。这个Java文件简单地加载共享库`PortingWithBuildSystem`，并调用本地方法`naCreateABmp`。
- en: Download the `libbmp` library from [http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)
    and extract the archive file to the `jni` folder. This will create a folder `libbmp-0.1.3`
    under the `jni` folder with the following content:![How to do it...](img/1505_08_03.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)下载`libbmp`库，并将归档文件解压到`jni`文件夹。这将在`jni`文件夹下创建一个`libbmp-0.1.3`文件夹，内容如下：![如何操作...](img/1505_08_03.jpg)
- en: Follow step 3 of the *Porting a library as shared library module with Android
    NDK build system* recipe to update `src/bmpfile.h`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照食谱*将库作为共享库模块与Android NDK构建系统一起移植*的第3步，更新`src/bmpfile.h`。
- en: 'Add a bash shell script file `build_android.sh` under the `libbmp-0.1.3` folder
    with the following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libbmp-0.1.3`文件夹下添加一个bash shell脚本文件`build_android.sh`，内容如下：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the execute permission to the `build_android.sh` file with the following
    command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为`build_android.sh`文件添加执行权限：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At a command line shell, go to the `libbmp-0.1.3` directory, and enter the
    following command to build the library:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行终端，转到`libbmp-0.1.3`目录，输入以下命令来构建库：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The build will fail with the following errors:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建将会因为以下错误而失败：
- en: '![How to do it...](img/1505_08_04.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_08_04.jpg)'
- en: This is because the `config.guess` and `config.sub` scripts under the `libbmp-0.1.3`
    folder are out of date (the first line of these two files indicate that the timestamp
    is `2009-08-19`). We will need copies of the scripts with timestamps `2010-05-20`
    or later. The `config.guess` script can be found at [http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.guess](http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.guess)
    and `config.sub` can be found at [http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.sub](http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.sub).
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为`libbmp-0.1.3`文件夹下的`config.guess`和`config.sub`脚本过时了（这两个文件的第一行表明时间戳是`2009-08-19`）。我们需要时间戳为`2010-05-20`或之后的脚本副本。可以在[http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.guess](http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.guess)找到`config.guess`脚本，在[http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.sub](http://gcc.gnu.org/svn/gcc/branches/cilkplus/config.sub)找到`config.sub`脚本。
- en: Try executing the `build_android.sh` script again. This time it finishes successfully.
    We should be able to find the `libbmp.a` static library under the `jni/libbmp-0.1.3/lib`
    folder and `bmpfile.h` under the `jni/libbmp-0.1.3/include` folder.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试执行`build_android.sh`脚本。这次它成功完成了。我们应当在`jni/libbmp-0.1.3/lib`文件夹下找到`libbmp.a`静态库，在`jni/libbmp-0.1.3/include`文件夹下找到`bmpfile.h`。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Many of the existing open source libraries can be built with the shell command
    "`./configure; make; make install`". In our sample project, we wrote a `build_android.sh`
    script to execute the three steps with the Android NDK cross compiler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现有的开源库可以通过shell命令"`./configure; make; make install`"来构建。在我们的示例项目中，我们编写了一个`build_android.sh`脚本来使用Android
    NDK交叉编译器执行这三个步骤。
- en: 'The following are a list of things we should consider when porting a library
    with the Android NDK cross compiler:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们使用Android NDK交叉编译器移植库时应该考虑的事项列表：
- en: '**Select the appropriate toolchain**: Based on the CPU architecture (ARM, x86
    or MIPS) of our targeted devices, you need to choose the corresponding toolchain.
    The following toolchains are available under the `toolchains` folder of Android
    NDK r8d:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择合适的工具链**：根据我们目标设备（ARM、x86或MIPS）的CPU架构，你需要选择相应的工具链。以下工具链可在Android NDK r8d的`toolchains`文件夹下找到：'
- en: '**For ARM-based devices**: `arm-linux-androideabi-4.4.3`, `arm-linux-androideabi-4.6`,
    `arm-linux-androideabi-4.7`, and `arm-linux-androideabi-clang3.1`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于基于ARM的设备**：`arm-linux-androideabi-4.4.3`，`arm-linux-androideabi-4.6`，`arm-linux-androideabi-4.7`，以及`arm-linux-androideabi-clang3.1`'
- en: '**For MIPS-based devices**: `mipsel-linux-android-4.4.3`, `mipsel-linux-android-4.6`,
    `mipsel-linux-android-4.7`, and `mipsel-linux-android-clang3.1`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于基于MIPS的设备**：`mipsel-linux-android-4.4.3`，`mipsel-linux-android-4.6`，`mipsel-linux-android-4.7`，以及`mipsel-linux-android-clang3.1`'
- en: '**For x86-based devices**: `x86-4.4.3`, `x86-4.6`, `x86-4.7`, and `x86-clang3.1`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于基于x86的设备**：`x86-4.4.3`，`x86-4.6`，`x86-4.7`，以及`x86-clang3.1`'
- en: '**Select the sysroot**: Based on the Android native API level and CPU architecture
    we want to target, you will need to choose the appropriate sysroot. The compiler
    will look for headers and libraries under the `sysroot` directory at compilation.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择sysroot**：根据我们想要针对的Android原生API级别和CPU架构，你需要选择合适的sysroot。编译器在编译时会查找`sysroot`目录下的头文件和库。'
- en: 'The path to `sysroot` follows this format:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sysroot`的路径遵循以下格式：'
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`$NDK` refers to the Android NDK root folder, `<level>` refers to the Android
    API level, and `<arch>` indicates the CPU architecture. In your `build_android.sh`
    script, `SYSROOT` is defined as follows:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$NDK`指的是Android NDK的根目录，`<level>`指的是Android API级别，`<arch>`表示CPU架构。在你的`build_android.sh`脚本中，`SYSROOT`定义如下： '
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Specify the cross compiler**: The library''s existing build system usually
    has a way for us to specify the cross compiler. It is usually through a configuration
    option or an environment variable.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指定交叉编译器**：库现有的构建系统通常有一种方法让我们指定交叉编译器。这通常是通过配置选项或环境变量来实现的。'
- en: 'In `libbmp`, we can enter the "`./configure --help`" command to see how to
    set the compiler. The `compiler` command is specified through the environment
    variable `CC`, while the environment variables `CFLAGS` and `LDFLAGS` are used
    to specify the compiler flags and linker flags. In your `build_android.sh` script,
    these three environment variables are set as follows:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`libbmp`中，我们可以输入"`./configure --help`"命令来了解如何设置编译器。`compiler`命令是通过环境变量`CC`指定的，而环境变量`CFLAGS`和`LDFLAGS`用于指定编译器标志和链接器标志。在你的`build_android.sh`脚本中，这三个环境变量如下设置：
- en: '[PRE30]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The "`-mthumb`" compiler flag indicates that you will use the thumb instruction
    set rather than the ARM instruction set. The "`-wl, --fix-cortex-a8`" linker flag
    is required to route around a CPU bug in some Cortex-A8 implementations.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"`-mthumb`"编译器标志表示你将使用thumb指令集而不是ARM指令集。"`-wl, --fix-cortex-a8`"链接器标志是为了绕过某些Cortex-A8实现中的CPU错误。'
- en: '**Specify the output locations for the header files and library binary**: You
    will usually want to place the library under `jni/<library folder>/`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指定头文件和库二进制文件的输出位置**：你通常希望将库放在`jni/<library folder>/`下。'
- en: 'In the case of `libbmp`, the library binary is installed under the `PREFIX/lib`
    folder and the header file is installed under the `EPREFIX/include` folder. Therefore,
    we set `PREFIX` and `EPREFIX` to `jni/libbmp-0.1.3` by passing the following options
    to configure the script:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`libbmp`的情况下，库二进制文件安装在`PREFIX/lib`文件夹下，头文件安装在`EPREFIX/include`文件夹下。因此，我们通过向配置脚本传递以下选项，将`PREFIX`和`EPREFIX`设置为`jni/libbmp-0.1.3`：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Make and install the library**: You can simply execute "`make; make install;`"
    to build and install the library.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建并安装库**：你可以简单地执行"`make; make install;`"来构建和安装库。'
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In your `build_android.sh` script, we have disabled shared library. If you remove
    the line "`--disable-shared \`", the build will generate both the shared library
    (`libbmp.so`) and the static library (`libbmp.a`) under the `jni/libbmp-0.1.3/lib/`
    folder.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`build_android.sh`脚本中，我们已经禁用了共享库。如果你删除了这行"`--disable-shared \`"，构建将在`jni/libbmp-0.1.3/lib/`文件夹下生成共享库（`libbmp.so`）和静态库（`libbmp.a`）。
- en: In your sample project, we used the NDK toolchain directly. This method has
    a serious limitation that you won't be able to use any C++ STL function, and C++
    exceptions and RTTI are not supported. Android NDK actually allows you to create
    a customized toolchain installation with the script `$NDK/build/tools/make-standalone-toolchain.sh`.
    Suppose you're targeting Android API level 8; you can use the following command
    to install the toolchain at the `/tmp/my-android-toolchain` folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的示例项目中，我们直接使用了NDK工具链。这种方法有一个严重的限制，即你不能使用任何C++ STL函数，且C++异常和RTTI不支持。实际上，Android
    NDK允许你使用脚本`$NDK/build/tools/make-standalone-toolchain.sh`创建一个自定义的工具链安装。假设你的目标是Android
    API级别8；你可以使用以下命令在`/tmp/my-android-toolchain`文件夹中安装工具链。
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can then use this toolchain by using the following commands:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来使用这个工具链：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the installed toolchain will have a few libraries (`libgnustl_shared.so`,
    `libstdc++.a`, and `libsupc++.a`) under the `/tmp/my-android-toolchain/arm-linux-androideabi/lib/`
    folder. You can link against these libraries to enable exceptions, RTTI, and STL
    functions support. We will further discuss exception and STL support in the *Porting
    a library which requires RTTI* recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，安装的工具链将在`/tmp/my-android-toolchain/arm-linux-androideabi/lib/`文件夹下拥有几个库（`libgnustl_shared.so`、`libstdc++.a`和`libsupc++.a`）。你可以链接这些库以启用异常、RTTI和STL函数支持。我们将在*需要RTTI的库移植*配方中进一步讨论异常和STL支持。
- en: More information about using the Android toolchain as a standalone compiler
    can be found at Android NDK in `docs/STANDALONE-TOOLCHAIN.html`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将Android工具链作为独立编译器使用的更多信息，请参见Android NDK中的`docs/STANDALONE-TOOLCHAIN.html`。
- en: Using a library as a prebuilt library
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将库作为预构建库使用
- en: The previous recipe described how to build an existing library with its own
    build system. We obtained a compiled static library `libbmp.a` of the open source
    `libbmp` library. This recipe will discuss how to use a prebuilt library.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个配方描述了如何使用自己的构建系统构建现有库。我们获得了开源`libbmp`库的编译静态库`libbmp.a`。这个配方将讨论如何使用预构建库。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps build an Android NDK application which uses prebuilt library.
    Note that the sample project is based on what we have done in the previous recipe.
    If you have not gone through previous recipe, you should do it now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤构建了一个使用预构建库的Android NDK应用程序。请注意，示例项目基于我们之前配方的操作。如果你还没有完成之前的配方，现在应该去做。
- en: Open the `PortingWithBuildSystem` project that you created in previous recipe.
    Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingwithbuildsystem`
    package. This Java file simply loads the shared library `PortingWithBuildSystem`,
    and calls the native method `naCreateABmp`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你在之前配方中创建的`PortingWithBuildSystem`项目。在`cookbook.chapter8.portingwithbuildsystem`包下添加一个Java文件`MainActivity.java`。这个Java文件只是加载共享库`PortingWithBuildSystem`，并调用本地方法`naCreateABmp`。
- en: Add the `mylog.h` and `PortingWithBuildSystem.c` files under it. `PortingWithBuildSystem.c`
    implements the native method `naCreateABmp`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录下添加`mylog.h`和`PortingWithBuildSystem.c`文件。`PortingWithBuildSystem.c`实现了本地方法`naCreateABmp`。
- en: 'Create an `Android.mk` file under the `jni` folder to compile `PortingWithBuildSystem.c`
    as a shared library `libPortingWithBuildSystem.so`. The content of this `Android.mk`
    file is as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建一个`Android.mk`文件，以编译`PortingWithBuildSystem.c`作为共享库`libPortingWithBuildSystem.so`。此`Android.mk`文件的内容如下：
- en: '[PRE34]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加`WRITE_EXTERNAL_STORAGE`权限，如下所示：
- en: '[PRE35]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Build and run the Android project. A bitmap file `test_bs_static.bmp` should
    be created at the `sdcard` folder of the Android device. We can use the following
    command to get the file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目。应该在Android设备的`sdcard`文件夹中创建位图文件`test_bs_static.bmp`。我们可以使用以下命令来获取该文件：
- en: '[PRE36]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The file is the same as `test_static.bmp` shown in the *Porting a library as
    shared library module with Android NDK build system* recipe of this chapter.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该文件与本章中*将库作为共享库模块与Android NDK构建系统*的配方中显示的`test_static.bmp`文件相同。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'There are two common use cases for prebuilt libraries:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 预构建库有两种常见用例：
- en: You want to use a library from a third-party developer and only the library
    binary is provided
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想使用第三方开发者的库，而只提供了库的二进制文件
- en: You have already built a library and want to use the library without recompiling
    it
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经构建了一个库，并希望在不重新编译的情况下使用该库
- en: 'Your sample project belongs to the second case. Let''s look at the things to
    consider when using a prebuilt library in Android NDK:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你的示例项目属于第二种情况。让我们看看在Android NDK中使用预构建库时需要考虑的事项：
- en: '**Declare a prebuilt library module**: In Android NDK, a build module can either
    be a static or shared library. You have seen how a module is declared with source
    code. It is similar when a module is based on a prebuilt library.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**声明一个预构建库模块**：在Android NDK中，构建模块可以是静态库或共享库。你已经看到了如何用源代码声明一个模块。当模块基于预构建的库时，声明方式类似。'
- en: 'i. **Declare the module name**: This is done with the `LOCAL_MODULE` module
    description variable. In your sample project, define the module name with the
    following line:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: i. **声明模块名称**：这是通过`LOCAL_MODULE`模块描述变量完成的。在你的示例项目中，使用以下行定义模块名称：
- en: '[PRE37]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'ii. **List the source for the prebuilt library**: You will provide the path
    of the prebuilt library to the `LOCAL_SRC_FILES` variable. Note that the path
    is relative to `LOCAL_PATH`. In your sample project, list the path to the `libbmp.a`
    static library as follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ii. **列出预构建库的源代码**：你需要将预构建库的路径提供给`LOCAL_SRC_FILES`变量。注意，该路径是相对于`LOCAL_PATH`的。在你的示例项目中，以下列方式列出`libbmp.a`静态库的路径：
- en: '[PRE38]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'iii. **Export the library headers**: This is done through the `LOCAL_EXPORT_C_INCLUDES`
    module description variable. The variable ensures that any modules that depend
    on the prebuilt library module will have the path to the library headers appended
    to `LOCAL_C_INCLUDES` automatically. Note that this step is optional, as we can
    also explicitly add the path to library headers to any modules that depend on
    the prebuilt library module. However, it is a better practice to export the headers
    instead of adding the path on every module that depends on the prebuilt library
    module.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iii. **导出库头文件**：这是通过`LOCAL_EXPORT_C_INCLUDES`模块描述变量完成的。该变量确保任何依赖预构建库模块的模块都会自动将库头文件的路径追加到`LOCAL_C_INCLUDES`中。注意，这一步是可选的，因为我们可以显式地将库头文件的路径添加到任何依赖预构建库模块的模块中。然而，最好是将头文件导出，而不是将路径添加到每个依赖预构建库模块的模块中。
- en: 'In your sample project, export the library headers with the following line
    in the `Android.mk` file:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的示例项目中，通过在`Android.mk`文件中添加以下行来导出库头文件：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'iv. **Export the compiler and/or linker flags**: This can be done with `LOCAL_EXPORT_CFLAGS`,
    `LOCAL_EXPORT_CPPFLAGS`, and `LOCAL_EXPORT_LDLIBS`. This step is also optional
    and we won''t use them in your sample project. You can refer to `docs/ANDROID-MK.html`
    at Android NDK for more detailed information about these module description variables.'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iv. **导出编译器和/或链接器标志**：这可以通过`LOCAL_EXPORT_CFLAGS`、`LOCAL_EXPORT_CPPFLAGS`和`LOCAL_EXPORT_LDLIBS`来完成。这一步也是可选的，我们在你的示例项目中不会使用它们。你可以参考Android
    NDK中的`docs/ANDROID-MK.html`获取关于这些模块描述变量的更详细信息。
- en: 'v. **Declare a build type**: You will need to include `PREBUILT_SHARED_LIBRARY`
    for the shared prebuilt library and `PREBUILT_STATIC_LIBRARY` for the static prebuilt
    library. In your sample project, use the following line to declare that you want
    to build a prebuilt static library module:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'v. **声明构建类型**：对于共享预构建库，你需要包含`PREBUILT_SHARED_LIBRARY`，对于静态预构建库，需要包含`PREBUILT_STATIC_LIBRARY`。在你的示例项目中，使用以下行来声明你想要构建一个预构建的静态库模块： '
- en: '[PRE40]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Use the prebuilt library module**: Once you have the prebuilt library module
    in place, you can simply list the module name in the `LOCAL_STATIC_LIBRARIES`
    or `LOCAL_SHARED_LIBRARIES` declaration of any module that depends on the prebuilt
    library. This is shown in your sample project''s `Android.mk` file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用预构建的库模块**：一旦你有了预构建的库模块，你只需在任何依赖该预构建库的模块的`LOCAL_STATIC_LIBRARIES`或`LOCAL_SHARED_LIBRARIES`声明中列出模块名称即可。这在你的示例项目的`Android.mk`文件中有展示：'
- en: '[PRE41]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Prebuilt library for debugging**: It is recommended by Android NDK that you
    provide the prebuilt library binaries that contain debug symbols, to facilitate
    debugging with `ndk-gdb`. When you package the library into an `apk` file, a stripped
    version created by Android NDK (at the project''s `libs/<abi>/` folder) will be
    used.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用于调试的预构建库**：Android NDK建议你提供包含调试符号的预构建库二进制文件，以便使用`ndk-gdb`进行调试。当你将库打包进`apk`文件时，将使用Android
    NDK创建的剥离版本（位于项目的`libs/<abi>/`文件夹中）。'
- en: Tip
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We don't discuss how to generate the debug version of a library because it depends
    on how the library is built. Normally, the library documentation will contain
    instructions of how to generate a debug build. If you're building the library
    using GCC directly, then you can refer to [http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html)
    for various options for debugging.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不讨论如何生成库的调试版本，因为这取决于库是如何构建的。通常，库的文档将包含如何生成调试构建的说明。如果您直接使用GCC构建库，那么您可以参考[http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html)了解各种调试选项。
- en: Using a library in multiple projects with import-module
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用import-module在多个项目中使用库
- en: You may often need to use a library in multiple projects. You can put the library
    in each of the project's `jni` folders and build them separately. However, it
    is troublesome to maintain multiple copies of the same library. For example, when
    there is a new release of the library and you want to update the library, you
    will have to update each copy of the library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能经常需要在多个项目中使用同一个库。您可以将库放入每个项目的`jni`文件夹中并分别构建它们。然而，维护同一库的多个副本是件麻烦事。例如，当库有新版本发布，您想要更新库时，您将不得不更新每个库副本。
- en: Fortunately, Android NDK provides a feature to allow us maintain a library module
    outside a NDK project's main source tree and import the module with simple commands
    in the `Android.mk` file. Let's discuss how to import a module in this recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android NDK提供了一个功能，允许我们在NDK项目的主源代码树之外维护一个库模块，并通过在`Android.mk`文件中使用简单的命令导入该模块。让我们讨论一下如何在此配方中导入一个模块。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to declare and import a module outside of
    a project''s `jni` folder:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何在项目的`jni`文件夹之外声明和导入一个模块：
- en: Create an Android application named `ImportModule` with native support. Set
    the package name as `cookbook.chapter8.importmodule`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface* for more detailed
    instructions.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ImportModule`的具有本地支持的Android应用程序。将包名设置为`cookbook.chapter8.importmodule`。请参考[第2章](ch02.html
    "Chapter 2. Java Native Interface")，*Java Native Interface*中的*加载本地库和注册本地方法*的配方，以获取更详细的说明。
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.importmodule`
    package. This Java file simply loads the shared library `ImportModule`, and calls
    the native method `naCreat``eABmp`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter8.importmodule`包下添加一个Java文件`MainActivity.java`。这个Java文件仅加载共享库`ImportModule`，并调用本地方法`naCreateABmp`。
- en: Download the `libbmp` library from [http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)
    and extract the archive file. Create a folder named `modules` under the project
    and a folder `libbmp-0.1.3` under the `modules` folder. Copy the `src/bmpfile.c`
    and `src/bmpfile.h` files from the extracted folder to the `libbmp-0.1.3` folder.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://code.google.com/p/libbmp/downloads/list](http://code.google.com/p/libbmp/downloads/list)下载`libbmp`库并提取归档文件。在项目下创建一个名为`modules`的文件夹，并在`modules`文件夹下创建一个`libbmp-0.1.3`文件夹。将提取的文件夹中的`src/bmpfile.c`和`src/bmpfile.h`文件复制到`libbmp-0.1.3`文件夹。
- en: Follow step 3 of the *Porting a library as shared library module with Android
    NDK build system* recipe to update `src/bmpfile.h`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第3步*使用Android NDK构建系统将库作为共享库模块移植*的配方更新`src/bmpfile.h`。
- en: 'Create an `Android.mk` file under the `libbmp-0.1.3` folder to compile `libbmp`
    as a static library `libbmp.a`. The content of this `Android.mk` file is as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`libbmp-0.1.3`文件夹下创建一个`Android.mk`文件，以编译静态库`libbmp.a`的`libbmp`。这个`Android.mk`文件的内容如下：
- en: '[PRE42]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Add the `mylog.h` and `ImportModule.c` files to it. `ImportModule.c` implements
    the native method `naCreateABmp`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加`mylog.h`和`ImportModule.c`文件。`ImportModule.c`实现了本地方法`naCreateABmp`。
- en: 'Create an `Android.mk` file under the `jni` folder to compile `ImportModule.c`
    as a shared library `libImportModule.so`. The content of this `Android.mk` file
    is as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建一个`Android.mk`文件，以编译共享库`libImportModule.so`的`ImportModule.c`。这个`Android.mk`文件的内容如下：
- en: '[PRE43]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `WRITE_EXTERNAL_STORAGE` permission to the `AndroidManifest.xml` file
    as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AndroidManifest.xml`文件添加`WRITE_EXTERNAL_STORAGE`权限，如下所示：
- en: '[PRE44]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Build and run the Android project. A bitmap file `test_bs_static.bmp` should
    be created at the `sdcard` folder of the Android device. You can use the following
    command to get the file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目。应该在Android设备的`sdcard`文件夹中创建一个位图文件`test_bs_static.bmp`。您可以使用以下命令获取该文件：
- en: '[PRE45]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The file is the same as `test_static.bmp`, as shown in the *Porting a library
    as shared library module with Android NDK build system* recipe of this chapter.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该文件与本章中的*使用Android NDK构建系统将库作为共享库模块移植*的配方中显示的`test_static.bmp`相同。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'In your sample project, you created a module outside the `jni` folder of the
    project and then imported the module for building the shared library `libImportModule.so`.
    The following steps should be performed when you declare and import a module:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的示例项目中，您在项目的`jni`文件夹外部创建了一个模块，然后导入该模块以构建共享库`libImportModule.so`。在声明和导入模块时，应执行以下步骤：
- en: '**Declare the import module**: There is nothing special in declaring an import
    module. Since an import module is usually used by multiple NDK projects, it is
    a good practice to export the header files (with `LOCAL_EXPORT_C_INCLUDES`), compiler
    flags (`LOCAL_EXPORT_CFLAGS` or `LOCAL_EXPORT_CPPFLAGS`), and linker flags (`LOCAL_EXPORT_LDLIBS`)
    when declaring the import module.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**声明导入模块**：声明导入模块时没有什么特别的。由于导入模块通常被多个NDK项目使用，因此在声明导入模块时，导出头文件（使用`LOCAL_EXPORT_C_INCLUDES`）、编译器标志（`LOCAL_EXPORT_CFLAGS`或`LOCAL_EXPORT_CPPFLAGS`）和链接器标志（`LOCAL_EXPORT_LDLIBS`）是一个好习惯。'
- en: In our sample project, you declared an import static library module `libbmp`.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，您声明了一个导入的静态库模块`libbmp`。
- en: '**Decide the place to put the import module**: The Android NDK build system
    will search the paths defined in `NDK_MODULE_PATH` for the import modules. By
    default, the `sources` folder of the Android NDK directory is appended to `NDK_MODULE_PATH`.
    Therefore, you can simply place our import module folder under the `sources` folder
    and the Android NDK build system will be able to find it.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**决定放置导入模块的位置**：Android NDK构建系统将在`NDK_MODULE_PATH`中定义的路径中搜索导入模块。默认情况下，Android
    NDK目录的`sources`文件夹会添加到`NDK_MODULE_PATH`中。因此，您只需将导入模块文件夹放在`sources`文件夹下，Android
    NDK构建系统就能找到它。'
- en: Alternatively, you can place the import module folder anywhere and append the
    path to `NDK_MODULE_PATH`. In our sample project, place the import the `libbmp`
    module in the `modules` folder.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以将导入模块文件夹放在任何地方，并将路径追加到`NDK_MODULE_PATH`。在我们的示例项目中，将导入的`libbmp`模块放在`modules`文件夹中。
- en: '**Append the import path**: This is not needed when placing the import module
    folder under the `sources` directory of Android NDK. Otherwise, you will need
    to tell the Android NDK build system where the import modules are, by appending
    the path to `NDK_MODULE_PATH`. The `import-add-path` macro is provided by NDK
    to help you to append the path.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**追加导入路径**：当将导入模块文件夹放置在Android NDK的`sources`目录下时，这不需要。否则，您需要通过向`NDK_MODULE_PATH`追加路径来告诉Android
    NDK构建系统导入模块的位置。`import-add-path`宏由NDK提供，以帮助您追加路径。'
- en: 'In your sample project, you appended the `modules` folder to `NDK_MODULE_PATH`
    with the following line at `jni/Android.mk`:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您的示例项目中，您通过在`jni/Android.mk`中的以下这行代码将`modules`文件夹追加到`NDK_MODULE_PATH`：
- en: '[PRE46]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Import the module**: Android NDK provides a macro `import-module` to import
    a module. This macro accepts a relative path to the import module''s folder where
    the `Android.mk` file of the import module is located. The Android NDK build system
    will search for all the paths defined at `NDK_MODULE_PATH` for the import module.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导入模块**：Android NDK提供了一个`import-module`宏来导入一个模块。这个宏接受一个相对路径，指向导入模块文件夹，该文件夹中包含导入模块的`Android.mk`文件。Android
    NDK构建系统将在`NDK_MODULE_PATH`中定义的所有路径中搜索导入模块。'
- en: 'In your sample project, you imported the module with the following line at
    the `jni/Android.mk` file:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您的示例项目中，您通过在`jni/Android.mk`文件中以下这行代码导入了模块：
- en: '[PRE47]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The NDK build system will search for the `libbmp-0.1.3/Android.mk` file at all
    `NDK_MODULE_PATH` directories for the import modules.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NDK构建系统将在所有`NDK_MODULE_PATH`目录中搜索导入模块的`libbmp-0.1.3/Android.mk`文件。
- en: '**Use the module**: Using an import module is just like using any other library
    module. You will need to link to the library by listing it at `LOCAL_STATIC_LIBRARIES`
    for the static library import module and `LOCAL_SHARED_LIBRARIES` for the shared
    library import module.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用该模块**：使用导入模块就像使用其他任何库模块一样。您需要通过在`LOCAL_STATIC_LIBRARIES`中列出静态库导入模块，在`LOCAL_SHARED_LIBRARIES`中列出共享库导入模块来进行链接。'
- en: For more information about how to import modules, you can refer to `docs/IMPORT-MODULE.html`
    at Android NDK.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何导入模块的更多信息，您可以参考Android NDK中的`docs/IMPORT-MODULE.html`。
- en: Porting a library that requires RTTI, exception, and STL support
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植需要RTTI、异常和STL支持的库。
- en: The Android platform provides a C++ runtime library at `/system/lib/libstdc++.so`.
    This default runtime library does not provide C++ exception and RTTI. The support
    for a standard C++ library is also limited. Fortunately, Android NDK provides
    alternatives to the default C++ runtime library, which makes porting of a large
    number of existing libraries that require exception, RTTI, and STL support, possible.
    This recipe discusses how to port a C++ library that requires RTTI, exception,
    and STL support. You will widely use the `boost` library as an example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台在`/system/lib/libstdc++.so`提供了一个C++运行时库。这个默认的运行时库不提供C++异常处理和RTTI，对标准C++库的支持也有限。幸运的是，Android
    NDK提供了对默认C++运行时库的替代方案，这使得大量需要异常处理、RTTI和STL支持的现有库的移植成为可能。本食谱讨论如何移植一个需要RTTI、异常处理和STL支持的C++库。你会广泛使用`boost`库作为例子。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to build and use the `boost` library for Android
    NDK:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何为Android NDK构建和使用`boost`库：
- en: 'Install a customized Android toolchain with the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装自定义的Android工具链：
- en: '[PRE48]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This should install the toolchain at the `/tmp/my-android-toolchain` folder.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在`/tmp/my-android-toolchain`文件夹中安装工具链。
- en: Create an Android application named `PortingBoost` with native support. Set
    the package name as `cookbook.chapter8.portingboost`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface* for more detailed
    instructions.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PortingBoost`的具有本地支持的Android应用程序。将包名设置为`cookbook.chapter8.portingboost`。更详细的说明，请参考[第2章](ch02.html
    "Chapter 2. Java Native Interface")，*Java Native Interface*中的*加载本地库和注册本地方法*食谱。
- en: Add a Java file `MainActivity.java` under the `cookbook.chapter8.portingboost`
    package. This Java file simply loads the shared library `PortingBoost`, and calls
    the native method `naExtractSubject`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter8.portingboost`包下添加一个Java文件`MainActivity.java`。这个Java文件简单地加载共享库`PortingBoost`，并调用本地方法`naExtractSubject`。
- en: Download the boost library from [http://sourceforge.net/projects/boost/files/boost/](http://sourceforge.net/projects/boost/files/boost/).
    In this recipe, you will build the `boost` library 1.51.0\. Extract the downloaded
    archive file to the `jni` folder. This will create a folder named `boost_1_51_0`
    under the `jni` folder as follows:![How to do it...](img/1505_08_05.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://sourceforge.net/projects/boost/files/boost/](http://sourceforge.net/projects/boost/files/boost/)下载boost库。在这个食谱中，你将构建`boost`库1.51.0。将下载的归档文件解压到`jni`文件夹中。这将创建一个名为`boost_1_51_0`的文件夹在`jni`文件夹下，如下所示：![如何操作...](img/1505_08_05.jpg)
- en: 'In a command line shell, go to the `boost_1_51_0` directory. Enter the following
    command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行终端，进入`boost_1_51_0`目录。输入以下命令：
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Edit the `user-config.jam` file under the `jni/boost_1_51_0/tools/build/v2`
    folder. Append the following content to the end of the file. You can refer to
    [http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html](http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html)
    for more information about boost configuration:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/boost_1_51_0/tools/build/v2`目录下的`user-config.jam`文件。在文件末尾添加以下内容。关于boost配置的更多信息，你可以参考[http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html](http://www.boost.org/boost-build2/doc/html/bbv2/overview/configuration.html)：
- en: '[PRE50]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Try building the `boost` library with the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用以下命令构建`boost`库：
- en: '[PRE51]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This command will execute the `boost` build in the background. You can monitor
    the build output by using the following command:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令将在后台执行`boost`构建。你可以使用以下命令监控构建输出：
- en: '[PRE52]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The build will take some time to finish. It will fail to build some targets.
    We can examine the errors in the `log.txt` file.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建完成需要一些时间。有些目标构建可能会失败。我们可以通过`log.txt`文件检查错误。
- en: 'The first error is that the `sys/statvfs.h` file is not found. You can fix
    this by updating the `libs/filesystem/src/operations.cpp` file. The updated parts
    are highlighted as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个错误是找不到`sys/statvfs.h`文件。你可以通过更新`libs/filesystem/src/operations.cpp`文件来修复这个问题。更新的部分如下所示：
- en: '[PRE53]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The second error is that the `bzlib.h` file is not found. This is because `bzip`
    is available on Android. You can disable `bzip` by adding the following line at
    the top of `jni/boost_1_51_0/tools/build/v2/user-config.jam`:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个错误是找不到`bzlib.h`文件。这是因为Android上可用`bzip`。你可以在`jni/boost_1_51_0/tools/build/v2/user-config.jam`文件顶部添加以下行来禁用`bzip`：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The third error is that `PAGE_SIZE` is not declared in this scope. You can
    fix this by adding the following line to `boost_1_51_0/boost/thread/thread.hpp`
    and `boost_1_51_0/boost/thread/pthread/thread_data.hpp`:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个错误是 `PAGE_SIZE` 在此作用域中没有声明。您可以通过在 `boost_1_51_0/boost/thread/thread.hpp`
    和 `boost_1_51_0/boost/thread/pthread/thread_data.hpp` 中添加以下行来修复此问题：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Try building the library again with the same command in step 5\. This time the
    library will build successfully.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第 5 步的相同命令再次尝试构建库。这次库将成功构建。
- en: 'Add the `mylog.h` and `PortingBoost.cpp` files under the `jni` folder. The
    `PortingBoost.cpp` file contains the implementation for the native method `naExtractSubject`.
    The function will match each line of the input string `pInputStr` with a regular
    expression using the `boost` library''s `regex_match` method:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加 `mylog.h` 和 `PortingBoost.cpp` 文件。`PortingBoost.cpp` 文件包含本地方法
    `naExtractSubject` 的实现。该函数将使用 `boost` 库的 `regex_match` 方法，将输入字符串 `pInputStr` 的每一行与正则表达式匹配：
- en: '[PRE56]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加一个 `Android.mk` 文件，内容如下：
- en: '[PRE57]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add an `Application.mk` file under the `jni` folder with the following content:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加一个 `Application.mk` 文件，内容如下：
- en: '[PRE58]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Build and run the project. You can monitor the logcat output with the following
    command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。您可以使用以下命令监控 logcat 输出：
- en: '[PRE59]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is a screenshot of the logcat output:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是 logcat 输出的截图：
- en: '![How to do it...](img/1505_08_06.jpg)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_08_06.jpg)'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: In your sample project, you first built the boost library using the Android
    toolchain as a standalone compiler. You then used the `regex` library from `boost`
    as a prebuilt module. Note that the `boost` library requires support for C++ exceptions
    and STL. Let's discuss how to enable support for these features at Android NDK.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的示例项目中，首先使用 Android 工具链作为独立编译器构建了 boost 库。然后，您将 `boost` 中的 `regex` 库作为预构建模块使用。注意，`boost`
    库需要支持 C++ 异常和 STL。让我们讨论如何在 Android NDK 上启用这些特性的支持。
- en: '**C++ runtime at Android NDK**: By default, Android comes with a minimal C++
    runtime library `at /system/lib/libstdc++.so`. The library does not support most
    C++ standard library functions, C++ exceptions, and RTTI. Fortunately, Android
    NDK comes with additional C++ runtime libraries that we can use. The following
    table summarizes the features provided by different runtime libraries at NDK r8:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android NDK 中的 C++ 运行时**：默认情况下，Android 带有一个最小的 C++ 运行时库位于 `/system/lib/libstdc++.so`。该库不支持大多数
    C++ 标准库函数、C++ 异常和 RTTI。幸运的是，Android NDK 提供了额外的 C++ 运行时库供我们使用。以下表格总结了 NDK r8 中不同运行时库提供的特性：'
- en: '|   | C++ standard library | C++ exceptions | C++ RTTI |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|   | C++ 标准库 | C++ 异常 | C++ RTTI |'
- en: '| --- | --- | --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **system** | minimal | No | No |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **system** | 最小化 | 否 | 否 |'
- en: '| **gabi++** | minimal | No (yes if NDK r8d or later) | Yes |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **gabi++** | 最小化 | 否（NDK r8d 或更高版本为是） | 是 |'
- en: '| **stlport** | yes | No (yes if NDK r8d or later) | Yes |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **stlport** | 是 | 否（NDK r8d 或更高版本为是） | 是 |'
- en: '| **gnustl** | yes | yes | Yes |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **gnustl** | 是 | 是 | 是 |'
- en: Note
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The C++ exceptions have been added to `gabi++` and `stlport` since Android NDK
    r8d.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Android NDK r8d 开始，`gabi++` 和 `stlport` 中增加了 C++ 异常支持。
- en: 'The system library refers to the default value that comes with the Android
    system. There is only a minimal C++ standard library support, and no C++ exceptions
    and RTTI. The C++ headers supported include the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 系统库指的是随 Android 系统默认提供的值。这里只支持最小的 C++ 标准库，并且不支持 C++ 异常和 RTTI。支持的 C++ 头文件包括以下内容：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`gabi++` is a runtime library, which supports RTTI in addition to the C++ functions
    provided by the system default.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gabi++` 是一个运行时库，除了支持系统默认提供的 C++ 函数外，还支持 RTTI。'
- en: '`stlport` provides a complete set of C++ standard library headers and RTTI.
    However, C++ exception is not supported. In fact, Android NDK `stlport` is based
    on `gabi++`.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stlport` 提供了一套完整的 C++ 标准库头文件和 RTTI，但不支持 C++ 异常。实际上，Android NDK 的 `stlport`
    是基于 `gabi++` 的。'
- en: '`gnustl` is the GNU standard C++ library. It comes with a complete set of C++
    headers, and supports C++ exceptions and RTTI.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnustl` 是 GNU 标准的 C++ 库。它附带了一套完整的 C++ 头文件，并支持 C++ 异常和 RTTI。'
- en: Tip
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The shared library file `gnustl` is named as `libgnustl_shared.so` instead of
    `libstdc++.so` in other platforms. This is because the name `libstdc++.so` is
    used by the system default C++ runtime.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 共享库文件 `gnustl` 命名为 `libgnustl_shared.so`，而不是在其他平台上使用的 `libstdc++.so`。这是因为名称
    `libstdc++.so` 被系统默认的 C++ 运行时使用。
- en: 'The Android NDK build system allows us to specify the C++ library runtime to
    link to the `Application.mk` file. Based on the library type (shared or static)
    and which runtime to use, we can define `APP_STL` as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 构建系统允许我们在`Application.mk`文件中指定要链接的 C++ 库运行时。根据库类型（共享或静态）以及要使用的运行时，我们可以如下定义`APP_STL`：
- en: '|   | Static library | Shared library |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|   | 静态库 | 共享库 |'
- en: '| --- | --- | --- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **gabi++** | `gabi++_static` | `gabi++_shared` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **gabi++** | `gabi++_static` | `gabi++_shared` |'
- en: '| **stlport** | `stlport_static` | `stlport_shared` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **stlport** | `stlport_static` | `stlport_shared` |'
- en: '| **gnustl** | `gnustl_static` | `gnustl_shared` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **gnustl** | `gnustl_static` | `gnustl_shared` |'
- en: 'In your sample project, add the following line in `Application.mk` to use the
    `gnustl` static library:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的示例项目中，在`Application.mk`中添加以下行，以使用`gnustl`静态库：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can only link a static C++ library into a single shared library. If a project
    uses multiple shared libraries and all libraries link to a static C++ library,
    each shared library will include a copy of the library's code in its binary. This
    will cause some problems, because some global variables used by the C++ runtime
    library are duplicated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能将静态 C++ 库链接到一个共享库中。如果一个项目使用多个共享库，并且所有库都链接到静态 C++ 库，每个共享库都会在其二进制文件中包含该库代码的副本。这会导致一些问题，因为
    C++ 运行时库使用的一些全局变量会被重复。
- en: The sources, headers, and binaries of these libraries can be found at the `sources/cxx-stl`
    folder of Android NDK. You can also refer to `docs/CPLUSPLUS-SUPPORT.html` for
    more information.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的源代码、头文件和二进制文件可以在 Android NDK 的`sources/cxx-stl`文件夹中找到。你也可以参考`docs/CPLUSPLUS-SUPPORT.html`获取更多信息。
- en: '**Enable the C++ exception support**: By default, all C++ sources are compiled
    with `-fno-exceptions`. In order to enable C++ exceptions, you will need to choose
    a C++ library, which supports exceptions (`gnustl_static` or `gnustl_shared`),
    and do one of the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**启用 C++ 异常支持**：默认情况下，所有 C++ 源文件都是使用`-fno-exceptions`编译的。为了启用 C++ 异常，你需要选择一个支持异常的
    C++ 库（`gnustl_static`或`gnustl_shared`），并执行以下操作之一：'
- en: 'At `Android.mk`, add exceptions to `LOCAL_CPP_FEATURES` as follows:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Android.mk`中，将异常添加到`LOCAL_CPP_FEATURES`中，如下所示：
- en: '[PRE62]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At `Android.mk`, add `-fexceptions` to `LOCAL_CPPFLAGS` as follows:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Android.mk`中，将`-fexceptions`添加到`LOCAL_CPPFLAGS`中，如下所示：
- en: '[PRE63]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At `Application.mk`, add the following line:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Application.mk`中，添加以下行：
- en: '[PRE64]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Enable the C++ RTTI support**: By default, C++ sources are compiled with
    `-fno-rtti`. In order to enable the RTTI support, you will need to use a C++ library,
    which supports RTTI, and do one of the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**启用 C++ RTTI 支持**：默认情况下，C++ 源文件是使用`-fno-rtti`编译的。为了启用 RTTI 支持，你需要使用一个支持 RTTI
    的 C++ 库，并执行以下操作之一：'
- en: 'At `Android.mk`, add `rtti` to `LOCAL_CPP_FEATURES` as follows:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Android.mk`中，将`rtti`添加到`LOCAL_CPP_FEATURES`中，如下所示：
- en: '[PRE65]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'At `Android.mk`, add `-frtti` to `LOCAL_CPPFLAGS` as follows:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Android.mk`中，将`-frtti`添加到`LOCAL_CPPFLAGS`中，如下所示：
- en: '[PRE66]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'At `Application.mk`, add -`frtti` to `APP_CPPFLAGS` as follows:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Application.mk`中，将`-frtti`添加到`APP_CPPFLAGS`中，如下所示：
- en: '[PRE67]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
