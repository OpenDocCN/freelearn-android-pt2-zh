["```kt\npackage com.packt.rrafols.draw; \n\nimport android.content.Context; \nimport android.opengl.GLSurfaceView; \nimport android.util.AttributeSet; \n\npublic class GLDrawer extends GLSurfaceView { \n    private GLRenderer glRenderer; \n\n    public GLDrawer(Context context, AttributeSet attributeSet) { \n        super(context, attributeSet); \n    } \n} \n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<LinearLayout  \n\n    android:id=\"@+id/activity_main\" \n    android:layout_width=\"match_parent\" \n    android:layout_height=\"match_parent\" \n    android:orientation=\"vertical\" \n    android:padding=\"@dimen/activity_vertical_margin\" \n    tools:context=\"com.packt.rrafols.draw.MainActivity\"> \n\n<TextView \n        android:layout_width=\"match_parent\" \n        android:layout_height=\"100dp\" \n        android:background=\"@android:color/background_light\" \n        android:gravity=\"center_vertical|center_horizontal\" \n        android:text=\"@string/filler_text\"/> \n\n<com.packt.rrafols.draw.GLDrawer \n        android:layout_width=\"match_parent\" \n        android:layout_height=\"100dp\"/> \n\n<TextView \n        android:layout_width=\"match_parent\" \n        android:layout_height=\"100dp\" \n        android:background=\"@android:color/background_light\" \n        android:gravity=\"center_vertical|center_horizontal\" \n        android:text=\"@string/filler_text\"/> \n</LinearLayout> \n```", "```kt\nclass GLRenderer implements GLSurfaceView.Renderer { \n    @Override \n    public void onSurfaceCreated(GL10 gl, EGLConfig config) { \n\n    } \n\n    @Override \n    public void onSurfaceChanged(GL10 gl, int width, int height) { \n\n    } \n\n    @Override \n    public void onDrawFrame(GL10 gl) { \n        gl.glClearColor(1.f, 0.f, 0.f, 1.f); \n        gl.glClear(GL10.GL_COLOR_BUFFER_BIT); \n    } \n} \n```", "```kt\nprivate GLRenderer glRenderer;\npublic GLDrawer(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n    glRenderer = new GLRenderer()\n    setRenderer(glRenderer);\n} \n```", "```kt\n<application> \n    .... \n<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" /> \n    ... \n</application> \n```", "```kt\npublic GLDrawer(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n    setEGLContextClientVersion(2);\n    glRenderer = new GLRenderer(); \n    setRenderer(glRenderer); \n} \n```", "```kt\nprivate float quadCoords[] = { \n    -1.f, -1.f, 0.0f, \n    -1.f,  1.f, 0.0f, \n     1.f,  1.f, 0.0f, \n     1.f, -1.f, 0.0f \n }; \n```", "```kt\nprivate short[] index = { \n    0, 1, 2, \n    0, 2, 3 \n}; \n```", "```kt\nByteBuffer vbb = ByteBuffer.allocateDirect(quadCoords.length * (Float.SIZE / 8)); \nvbb.order(ByteOrder.nativeOrder()); \n\nvertexBuffer = vbb.asFloatBuffer(); \nvertexBuffer.put(quadCoords); \nvertexBuffer.position(0); \n```", "```kt\nByteBuffer ibb = ByteBuffer.allocateDirect(index.length * (Short.SIZE / 8)); \nibb.order(ByteOrder.nativeOrder()); \n\nindexBuffer = ibb.asShortBuffer(); \nindexBuffer.put(index); \nindexBuffer.position(0); \n```", "```kt\n// Source: \n// https://developer.android.com/training/graphics/opengl/draw.html \npublic static int loadShader(int type, String shaderCode){ \n\n    // create a vertex shader type (GLES20.GL_VERTEX_SHADER) \n    // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) \n    int shader = GLES20.glCreateShader(type); \n\n    // add the source code to the shader and compile it \n    GLES20.glShaderSource(shader, shaderCode); \n    GLES20.glCompileShader(shader); \n\n    return shader; \n} \n```", "```kt\nprivate void initShaders() { \n    int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode); \n    int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode); \n\n    shaderProgram = GLES20.glCreateProgram(); \n    GLES20.glAttachShader(shaderProgram, vertexShader); \n    GLES20.glAttachShader(shaderProgram, fragmentShader); \n    GLES20.glLinkProgram(shaderProgram); \n} \n```", "```kt\n// Source: \n// https://developer.android.com/training/graphics/opengl/draw.html \nprivate final String vertexShaderCode = \n        // This matrix member variable provides a hook to manipulate \n        // the coordinates of the objects that use this vertex shader \n\"uniform mat4 uMVPMatrix;\" + \n\"attribute vec4 vPosition;\" + \n\"void main() {\" + \n        // The matrix must be included as a modifier of gl_Position. \n        // Note that the uMVPMatrix factor *must be first* in order \n        // for the matrix multiplication product to be correct. \n\"  gl_Position = uMVPMatrix * vPosition;\" + \n\"}\"; \n```", "```kt\nprivate final String fragmentShaderCode = \n\"precision mediump float;\" + \n\"uniform vec4 vColor;\" + \n\"void main() {\" + \n\"  gl_FragColor = vColor;\" + \n\"}\"; \n```", "```kt\n@Override \npublic void onSurfaceChanged(GL10 unused, int width, int height) { \n    GLES20.glViewport(0, 0, width, height); \n\n    float ratio = (float) width / height; \n    Matrix.frustumM(mProjectionMatrix, 0, -ratio * 2, ratio * 2, -2, 2,\n    3, 7); \n} \n```", "```kt\n@Override \npublic void onDrawFrame(GL10 unused) { \n\n    ... \n\n    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix,\n    0); \n\n    int mMVPMatrixHandle = GLES20.glGetUniformLocation(shaderProgram,\n    \"uMVPMatrix\"); \n    GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix,\n    0); \n\n    ... \n\n} \n```", "```kt\nuniform mat4 uMVPMatrix; \n```", "```kt\nfloat color[] = { 0.2f, 0.2f, 0.9f, 1.0f }; \n\n... \n\nint colorHandle = GLES20.glGetUniformLocation(shaderProgram, \"vColor\"); \nGLES20.glUniform4fv(colorHandle, 1, color, 0); \n```", "```kt\nint positionHandle = GLES20.glGetAttribLocation(shaderProgram, \"vPosition\"); \n\nGLES20.glVertexAttribPointer(positionHandle, 3, \n        GLES20.GL_FLOAT, false, \n        3 * 4, vertexBuffer); \n```", "```kt\nGLES20.glEnableVertexAttribArray(positionHandle); \n\nGLES20.glDrawElements( \n       GLES20.GL_TRIANGLES, index.length, \n       GLES20.GL_UNSIGNED_SHORT, indexBuffer); \n\nGLES20.glDisableVertexAttribArray(positionHandle); \n```", "```kt\nfloat color[] = { \n        1.0f, 0.2f, 0.2f, 1.0f, \n        0.2f, 1.0f, 0.2f, 1.0f, \n        0.2f, 0.2f, 1.0f, 1.0f, \n        1.0f, 1.0f, 1.0f, 1.0f, \n}; \n```", "```kt\nprivate FloatBuffer colorBuffer; \n\n... \n\nByteBuffer cbb = ByteBuffer.allocateDirect(color.length * (Float.SIZE / 8)); \ncbb.order(ByteOrder.nativeOrder()); \n\ncolorBuffer = cbb.asFloatBuffer(); \ncolorBuffer.put(color); \ncolorBuffer.position(0); \n```", "```kt\nprivate final String vertexShaderCode = \n\"uniform mat4 uMVPMatrix;\" + \n\"attribute vec4 vPosition;\" + \n\"attribute vec4 aColor;\" + \n\"varying vec4 vColor;\" + \n\"void main() {\" + \n\"  gl_Position = uMVPMatrix * vPosition;\" + \n\"  vColor = aColor;\" + \n\"}\"; \n```", "```kt\nprivate final String fragmentShaderCode = \n\"precision mediump float;\" + \n\"varying vec4 vColor;\" + \n\"void main() {\" + \n\"  gl_FragColor = vColor;\" + \n\"}\"; \n```", "```kt\nint colorHandle = GLES20.glGetAttribLocation(shaderProgram, \"aColor\"); \nGLES20.glVertexAttribPointer(colorHandle, 4, \n        GLES20.GL_FLOAT, false, \n        4 * 4, colorBuffer); \n```", "```kt\nGLES20.glEnableVertexAttribArray(colorHandle); \nGLES20.glEnableVertexAttribArray(positionHandle); \nGLES20.glDrawElements( \n        GLES20.GL_TRIANGLES, index.length, \n        GLES20.GL_UNSIGNED_SHORT, indexBuffer); \n\nGLES20.glDisableVertexAttribArray(positionHandle); \nGLES20.glDisableVertexAttribArray(colorHandle); \n```", "```kt\nprivate float quadCoords[] = { \n       -1.f, -1.f, -1.0f, \n       -1.f,  1.f, -1.0f, \n        1.f,  1.f, -1.0f, \n        1.f, -1.f, -1.0f, \n\n       -1.f, -1.f,  1.0f, \n       -1.f,  1.f,  1.0f, \n        1.f,  1.f,  1.0f, \n        1.f, -1.f,  1.0f \n}; \n```", "```kt\nprivate short[] index = { \n        0, 1, 2,        // front \n        0, 2, 3,        // front \n        4, 5, 6,        // back \n        4, 6, 7,        // back \n        0, 4, 7,        // top \n        0, 3, 7,        // top \n        1, 5, 6,        // bottom \n        1, 2, 6,        // bottom \n        0, 4, 5,        // left \n        0, 1, 5,        // left \n        3, 7, 6,        // right \n        3, 2, 6         // right \n}; \n```", "```kt\nfloat color[] = { \n        1.0f, 0.2f, 0.2f, 1.0f, \n        0.2f, 1.0f, 0.2f, 1.0f, \n        0.2f, 0.2f, 1.0f, 1.0f, \n        1.0f, 1.0f, 1.0f, 1.0f, \n\n        1.0f, 1.0f, 0.2f, 1.0f, \n        0.2f, 1.0f, 1.0f, 1.0f, \n        1.0f, 0.2f, 1.0f, 1.0f, \n        0.2f, 0.2f, 0.2f, 1.0f \n}; \n```", "```kt\nprivate float angle = 0.f; \n... \nMatrix.setLookAtM(mViewMatrix, 0, \n        0, 0, -4, \n        0f, 0f, 0f, \n        0f, 1.0f, 0.0f); \n\nMatrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0); Matrix.rotateM(mMVPMatrix, 0, angle, 1.f, 1.f, 1.f);\n```", "```kt\nprivate long startTime; \n... \n@Override \npublic void onSurfaceCreated(GL10 unused, EGLConfig config) { \n    initBuffers(); \n    initShaders(); \n    startTime = SystemClock.elapsedRealtime();\n} \n```", "```kt\nangle = ((float) SystemClock.elapsedRealtime() - startTime) * 0.02f; \n```", "```kt\nGLES20.glEnable(GLES20.GL_DEPTH_TEST);\nGLES20.glEnableVertexAttribArray(colorHandle); \nGLES20.glEnableVertexAttribArray(positionHandle); \nGLES20.glDrawElements( \n        GLES20.GL_TRIANGLES, index.length, \n        GLES20.GL_UNSIGNED_SHORT, indexBuffer); \n\nGLES20.glDisableVertexAttribArray(positionHandle); \nGLES20.glDisableVertexAttribArray(colorHandle); GLES20.glDisable(GLES20.GL_DEPTH_TEST);\n```", "```kt\nprivate float texCoords[] = { \n        1.f, 1.f, \n        1.f, 0.f, \n        0.f, 0.f, \n        0.f, 1.f, \n\n        1.f, 1.f, \n        1.f, 0.f, \n        0.f, 0.f, \n        0.f, 1.f, \n}; \n```", "```kt\nByteBuffer tbb = ByteBuffer.allocateDirect(texCoords.length * (Float.SIZE / 8)); \ntbb.order(ByteOrder.nativeOrder()); \n\ntexBuffer = tbb.asFloatBuffer(); \ntexBuffer.put(texCoords); \ntexBuffer.position(0); \n```", "```kt\nprivate int loadTexture(int resId) { \n    final int[] textureIds = new int[1]; \n    GLES20.glGenTextures(1, textureIds, 0); \n\n    if (textureIds[0] == 0) return -1; \n\n    // do not scale the bitmap depending on screen density \n    final BitmapFactory.Options options = new BitmapFactory.Options(); \n    options.inScaled = false; \n\n    final Bitmap textureBitmap =\n    BitmapFactory.decodeResource(getResources(), resId, options); \n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureIds[0]); \n\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST); \n\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST); \n\n    GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE); \n\n    GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE); \n\n    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, textureBitmap, 0); \n    textureBitmap.recycle(); \n\n    return textureIds[0]; \n} \n```", "```kt\nprivate final String vertexShaderCode = \n\"uniform mat4 uMVPMatrix;\" + \n\"attribute vec4 vPosition;\" + \n\"attribute vec2 aTex;\" + \n\"varying vec2 vTex;\" + \n\"void main() {\" + \n\"  gl_Position = uMVPMatrix * vPosition;\" + \n\"  vTex = aTex;\" + \n\"}\"; \n```", "```kt\nprivate final String fragmentShaderCode = \n\"precision mediump float;\" + \n\"uniform sampler2D sTex;\" + \n\"varying vec2 vTex;\" + \n\"void main() {\" + \n\"  gl_FragColor = texture2D(sTex, vTex);\" + \n\"}\"; \n```", "```kt\n@Override \npublic void onSurfaceCreated(GL10 unused, EGLConfig config) { \n    initBuffers(); \n    initShaders(); \n\n    textureId = loadTexture(R.drawable.texture); \n\n    startTime = SystemClock.elapsedRealtime(); \n} \n```", "```kt\nint texCoordHandle = GLES20.glGetAttribLocation(shaderProgram, \"aTex\"); \nGLES20.glVertexAttribPointer(texCoordHandle, 2, \n        GLES20.GL_FLOAT, false, \n        0, texBuffer); \n```", "```kt\nint texHandle = GLES20.glGetUniformLocation(shaderProgram, \"sTex\"); \nGLES20.glActiveTexture(GLES20.GL_TEXTURE0); \nGLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); \nGLES20.glUniform1i(texHandle, 0); \n```", "```kt\npublic class WavefrontObjParser { \n    public static void parse(Context context, String name, ParserListener listener) { \n        WavefrontObjParserHelper helper = new WavefrontObjParserHelper(context, name, listener); \n        helper.start(); \n    } \n\n    public interface ParserListener { \n        void parsingSuccess(Scene scene); \n        void parsingError(String message); \n    } \n} \n```", "```kt\nclass WavefrontObjParserHelper extends Thread { \n    private String name; \n    private WavefrontObjParser.ParserListener listener; \n    private Context context; \n\n    WavefrontObjParserHelper(Context context, String name,\n    WavefrontObjParser.ParserListener listener) { \n        this.context = context; \n        this.name = name; \n        this.listener = listener; \n    } \n\n```", "```kt\npublic void run() { \n        try { \n\n            InputStream is = context.getAssets().open(name); \n            BufferedReader br = new BufferedReader(new\n            InputStreamReader(is)); \n\n            Scene scene = new Scene(); \n            Object3D obj = null; \n\n            String str; \n            while ((str = br.readLine()) != null) { \n                if (!str.startsWith(\"#\")) { \n                    String[] line = str.split(\"\"); \n\n                    if(\"o\".equals(line[0])) { \n                        if (obj != null) obj.prepare(); \n                        obj = new Object3D(); \n                        scene.addObject(obj); \n\n                    } else if(\"v\".equals(line[0])) { \n                        float x = Float.parseFloat(line[1]); \n                        float y = Float.parseFloat(line[2]); \n                        float z = Float.parseFloat(line[3]); \n                        obj.addCoordinate(x, y, z); \n                    } else if(\"f\".equals(line[0])) { \n\n                        int a = getFaceIndex(line[1]); \n                        int b = getFaceIndex(line[2]); \n                        int c = getFaceIndex(line[3]); \n\n                        if (line.length == 4) { \n                            obj.addFace(a, b, c); \n                        } else { \n                            int d = getFaceIndex(line[4]); \n                            obj.addFace(a, b, c, d); \n                        } \n                    } else { \n                        // skip \n                    } \n                } \n            } \n            if (obj != null) obj.prepare(); \n            br.close(); \n\n            if (listener != null) listener.parsingSuccess(scene); \n        } catch(Exception e) { \n            if (listener != null) listener.parsingError(e.getMessage()); \n            e.printStackTrace(); \n        } \n    } \n```", "```kt\nInputStream is = context.getAssets().open(name); \nBufferedReader br = new BufferedReader(new InputStreamReader(is)); \n```", "```kt\nprivate static int getFaceIndex(String face) { \n    if(!face.contains(\"/\")) { \n        return Integer.parseInt(face) - 1; \n    } else { \n        return Integer.parseInt(face.split(\"/\")[0]) - 1; \n    } \n} \n```", "```kt\npublic class Scene { \n    private ArrayList<Object3D> objects; \n\n    public Scene() { \n        objects = new ArrayList<>(); \n    } \n\n    public void addObject(Object3D obj) { \n        objects.add(obj); \n    } \n\n    public ArrayList<Object3D> getObjects() { \n        return objects; \n    } \n\n    public void render(int shaderProgram, String posAttributeName,\n    String colAttributeName) { \n        GLES20.glEnable(GLES20.GL_DEPTH_TEST); \n\n        for (int i = 0; i < objects.size(); i++) { \n            objects.get(i).render(shaderProgram, posAttributeName,\n            colAttributeName); \n        } \n\n        GLES20.glDisable(GLES20.GL_DEPTH_TEST); \n    } \n} \n\n```", "```kt\npublic void prepare() { \n    if (coordinateList.size() > 0 && coordinates == null) { \n        coordinates = new float[coordinateList.size()]; \n        for (int i = 0; i < coordinateList.size(); i++) { \n            coordinates[i] = coordinateList.get(i); \n        } \n    } \n\n    if (indexList.size() > 0 && indexes == null) { \n        indexes = new short[indexList.size()]; \n        for (int i = 0; i < indexList.size(); i++) { \n            indexes[i] = indexList.get(i); \n        } \n    } \n\n    colors = new float[(coordinates.length/3) * 4]; \n    for (int i = 0; i < colors.length/4; i++) { \n        float intensity = (float) (Math.random() * 0.5 + 0.4); \n        colors[i * 4    ] = intensity; \n        colors[i * 4 + 1] = intensity; \n        colors[i * 4 + 2] = intensity; \n        colors[i * 4 + 3] = 1.f; \n    } \n\n    ByteBuffer vbb = ByteBuffer.allocateDirect(coordinates.length *\n   (Float.SIZE / 8)); \n    vbb.order(ByteOrder.nativeOrder()); \n\n    vertexBuffer = vbb.asFloatBuffer(); \n    vertexBuffer.put(coordinates); \n    vertexBuffer.position(0); \n\n    ByteBuffer ibb = ByteBuffer.allocateDirect(indexes.length *\n   (Short.SIZE / 8)); \n    ibb.order(ByteOrder.nativeOrder()); \n\n    indexBuffer = ibb.asShortBuffer(); \n    indexBuffer.put(indexes); \n    indexBuffer.position(0); \n\n    ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length * \n    (Float.SIZE / 8)); \n    cbb.order(ByteOrder.nativeOrder()); \n\n    colorBuffer = cbb.asFloatBuffer(); \n    colorBuffer.put(colors); \n    colorBuffer.position(0); \n\n    Log.i(TAG, \"Loaded obj with \" + coordinates.length + \" vertices &\"\n    + (indexes.length/3) + \" faces\"); \n} \n\n```", "```kt\npublic void render(int shaderProgram, String posAttributeName, String colAttributeName) { \n    int positionHandle = GLES20.glGetAttribLocation(shaderProgram,\n    posAttributeName); \n    GLES20.glVertexAttribPointer(positionHandle, 3, \n            GLES20.GL_FLOAT, false, \n            3 * 4, vertexBuffer); \n\n    int colorHandle = GLES20.glGetAttribLocation(shaderProgram,\n    colAttributeName); \n    GLES20.glVertexAttribPointer(colorHandle, 4, \n            GLES20.GL_FLOAT, false, \n            4 * 4, colorBuffer); \n\n    GLES20.glEnableVertexAttribArray(colorHandle); \n    GLES20.glEnableVertexAttribArray(positionHandle); \n    GLES20.glDrawElements( \n            GLES20.GL_TRIANGLES, indexes.length, \n            GLES20.GL_UNSIGNED_SHORT, indexBuffer); \n\n    GLES20.glDisableVertexAttribArray(positionHandle); \n    GLES20.glDisableVertexAttribArray(colorHandle); \n} \n```", "```kt\n// source: http://nehe.gamedev.net/article/replacement_for_gluperspective/21002/ \n\nprivate static void perspectiveFrustrum(float[] matrix, float fov, float aspect, float zNear, float zFar) { \n    float fH = (float) (Math.tan( fov / 360.0 * Math.PI ) * zNear); \n    float fW = fH * aspect; \n\n    Matrix.frustumM(matrix, 0, -fW, fW, -fH, fH, zNear, zFar); \n} \n```", "```kt\n@Override \npublic void onDrawFrame(GL10 unused) { \n    angle = ((float) SystemClock.elapsedRealtime() - startTime) *\n    0.02f; \n    GLES20.glClearColor(1.0f, 0.0f, 0.0f, 1.0f); \n    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | \n    GLES20.GL_DEPTH_BUFFER_BIT); \n\n    if (scene != null) { \n        Matrix.setLookAtM(mViewMatrix, 0, \n                0, 0, -4, \n                0f, 0f, 0f, \n                0f, 1.0f, 0.0f); \n\n        Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0,\n        mViewMatrix, 0); \n        Matrix.rotateM(mMVPMatrix, 0, angle, 0.8f, 2.f, 1.f); \n\n        GLES20.glUseProgram(shaderProgram); \n\n        int mMVPMatrixHandle = GLES20.glGetUniformLocation(shaderProgram, \"uMVPMatrix\"); \n        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false,\n        mMVPMatrix, 0); \n\n        scene.render(shaderProgram, \"vPosition\", \"aColor\"); \n    } \n} \n```"]