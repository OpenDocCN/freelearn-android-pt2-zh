- en: 'Chapter 2. Interaction Experience: Multitouch, Gestures, and Other Input'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting supported device input types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting whether or not a device supports multitouch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying specific gesture support for common interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to zoom a display object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to pan a display object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to swipe a display object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to rotate a display object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing raw touchpoint data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom gesture based upon touchpoint data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating the Android long-press interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking the virtual keyboard programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to Android soft-key interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to trackball and D-Pad events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to interface with a device through touch and gestures is one of
    the stand-out features of mobile computing and the Flash platform has full support
    for both multitouch and gestures on Android. This chapter will cover different
    ways of intercepting and reacting to user interaction whether it be through simple
    touch points or complex gestures, along with more traditional physical and virtual
    keyboard input. Making good use of this is essential to a smooth experience on
    mobile Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: All of the recipes in this chapter are represented as pure ActionScript 3 classes
    and are not dependent upon external libraries or the Flex framework. Therefore,
    we will be able to use these examples in any IDE we wish.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting supported device input types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variety of input types are available across Android devices and depending
    upon the project we are working on, we may need to verify that any particular
    device supports the intended modes of user interaction. Fortunately, there are
    a number of ActionScript classes to assist us in discovering device capabilities
    in regard to user input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to use internal classes to detect whether or not multitouch is
    supported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project in order to check various
    input types across devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will simply go through and check the data returned from invoking a
    number of properties off of these classes. In the case of the following example,
    we are performing this within the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Flash platform runtimes are able to report certain device capabilities when
    invoked. The data reported will allow us to tailor the user experience, based
    upon what sort of input types are detected by the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here follows a basic rundown of the four input types that can be reported upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flash.system.Capabilities.touchscreenType`'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking this method will return a `String` constant of `FINGER, STYLUS`, or
    `NONE`. It informs us whether some sort of direct screen interaction is available
    on the device, and if so, what sort. In the case of Android devices, this will
    always return `FINGER`.
  prefs: []
  type: TYPE_NORMAL
- en: '`flash.ui.Mouse.supportsCursor`'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking this method will return a `Boolean` of `true` or `false`. It simply
    informs us whether a persistent mouse cursor is available on the device. In the
    case of Android devices, this will most likely always return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '`flash.ui.Keyboard.physicalKeyboardType`'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking this method will return a `String` constant of `ALPHANUMERIC, KEYPAD`,
    or `NONE`. It informs us whether some sort of dedicated physical keyboard is available
    on the device, and if so, what sort. In the case of Android devices, this will
    most likely always return `NONE`, even though certain Android models do have a
    physical keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '`flash.ui.Keyboard.hasVirtualKeyboard`'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking this method will return a `Boolean` of `true` or `false`. It simply
    informs us whether a virtual (software) keyboard is available on the device. In
    the case of Android devices, this will most likely always return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting whether or not a device supports multitouch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing projects which target the Android operating system, it is always
    a good idea to make sure that multitouch is actually supported on the device.
    In the case of an Android phone, this will probably always be the case, but what
    about a Google TV or AIR for TV device? Many of these are also Android-based yet
    most televisions do not have any touch control whatsoever. Never assume the capabilities
    of any device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to use internal classes to detect whether or not multitouch is
    supported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, simply invoke `Multitouch.supportsGestureEvents` and `Multitouch.supportsTouchEvents`
    to check each of these capabilities as demonstrated in the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of these properties will return a `Boolean` value of `true` or `false`,
    indicating device support as shown here:![How to do it...](img/1420_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Detecting whether the device supports either touch or gesture events will determine
    how much freedom you, as a developer, have in refining the user experience. If
    either of these items returns as false, then it is up to you to provide (if possible)
    an alternative way for the user to interact with the application. This is normally
    done through `Mouse` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Touch events:** Basic interactions such as a single finger tap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gesture events:** More complex interpretations of user interaction such as
    pinch, zoom, swipe, pan, and so forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that while a specific device may support either gesture
    events or touch events, when using Flash Platform tools, we must set the `Multitouch.inputMode`
    to one or the other specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying specific gesture support for common interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with Android devices, touch and gestures are the main mechanisms
    with which the user interacts with the device. If we want to use some of the predefined
    gestures in Flash Player and AIR, we can do so in the following manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To discover which specific gestures are supported on a device, perform the
    following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the specific input mode for the multitouch APIs to support gestures with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoking `Multitouch.supportedGestures` will return a `Vector` of `String`
    objects naming all the supported gestured exposed to Flash on the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can then look for a specific gesture or set of gestures to listen for, or
    fall back to other interaction events if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can perform all of these necessary functions within a single method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flash player and AIR do a marvelous job of distilling information to essential
    details for an Android developer. Knowing which particular gestures are supported
    on a device will allow us to tailor event interactions on our applications and
    provide fallback interactions when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example class, we also provide a check to be sure there are at least
    some gestures supported through `Multitouch.supportedGestures`. Chances are, if
    the device does provide gesture support, we will want to provide a warning to
    the user explaining that the application will not perform optimally because of
    hardware limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the more common gestures such as zoom, swipe, rotate, and pan, which
    are included in the `flash.events.TransformGestureEvent` package, there are additional,
    yet less common gestures such as two-finger tap, found in the `flash.events.GestureEvent`
    and `flash.events.PressAndTapGestureEvent` classes. These will all be referenced
    by `Multitouch.supportedGestures` if available on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Using gestures to zoom a display object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pinching and pulling are gestures that are often used on touch screens that
    support multitouch input. Bringing two fingers closer together will shrink an
    object, while spreading two fingers apart makes the object larger on the device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up listeners for zoom gesture events in
    order to scale the `Shape` appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `Shape` object, upon which we will perform the gestures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, construct a method to handle the creation of our `Sprite` and add it to
    the `DisplayList:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    the `MultitouchInputMode.TOUCH_POINT` constant and register anevent listener for
    the `GESTURE_ZOOM` event. In this case, the `onZoom` method will fire whenever
    the application detects a zoom gesture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To use the accepted behavior of pinch and zoom, we can adjust the scale of objects
    on stage based upon the scale factor returned by our event listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example, we are listening for the `TransformGestureEvent.GESTURE_ZOOM` event in
    order to set the scale of our `Shape` object. By multiplying the current scale
    properties by the scale values reported through our event, we can adjust the scale
    of our object based upon this gesture.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note here that we are drawing our square in such a way that the `Shape` registration
    point is located in the center of the visible `Shape`. It is important that we
    do this, as the `DisplayObject` will scale up and down, based upon the registration
    point and transform point.
  prefs: []
  type: TYPE_NORMAL
- en: When using the drawing tools in Flash Professional, be sure to set the registration
    point of your `MovieClip` symbol to be centered in order for this to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_ZOOM` is just one of a set of four primary transform
    gestures available to us when working with the Flash Platform runtimes and Android
    devices. Reference the following recipes for a complete overview of these gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using gestures to pan a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using gestures to swipe a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using gestures to rotate a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to pan a display object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Panning a `DisplayObject` is accomplished by touching the screen with two fingers
    simultaneously, and then moving both fingers across the screen in the direction
    we want to pan the object. This is normally used upon an object that occupies
    more real estate than the screen affords, or an object that has been zoomed in
    so far that only a portion of it is visible on the screen at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up listeners for pan gesture events in order
    to scale the `Shape` appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `Shape` object which we will perform the gestures upon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList`. We have made extra effort to be sure our `Shape` is much larger
    than the screen so that it can be panned effectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener for the `GESTURE_PAN` event. In this case, the
    `onPan` method will fire whenever the application detects a zoom gesture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now respond to the data being returned by our pan event. In this case,
    we are simply shifting the x and y positions of our `Shape` based upon the pan
    offset data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example we are listening for the `TransformGestureEvent.GESTURE_PAN` event in
    order to shift the x and y position of our `Shape` object. By adjusting the coordinates
    of our `Shape` through the reported offset data, we can adjust the position of
    our object in a way that the user expects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that this is often a difficult gesture to perform on certain devices (As
    you must touch the screen with two fingers, simultaneously), and that other devices
    may not even support it. For a fallback, we can always use the `startDrag()` and
    `stopDrag()` methods to simulate a pan.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_PAN` is just one of a set of four primary transform
    gestures available to us when working with the Flash Platform runtimes and Android
    devices. Reference the following recipes for a complete overview of these gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using Gestures to Zoom a DisplayObject*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Gestures to Swipe a Display Object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Gestures to Rotate a Display Object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to swipe a display object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swipe is one of the most common gestures on Android devices, and with good reason.
    Whether flipping through a series of photographs, or simply moving between states
    in an application, the swipe gesture is something users have come to expect. A
    swipe gesture is accomplished by simply touching the screen and swiping up, down,
    left, or right across the screen quickly in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up a listener for swipe gesture events in
    order to move the `Shape` instance against the bounds of our screen in accordance
    with the direction of swipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `Shape` object which we will perform the gestures upon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener for `TransformGestureEvent.GESTURE_SWIPE` events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now respond to the data being returned by our swipe event. In this case,
    we are simply shifting the x and y position of our `Shape` based upon the swipe
    offset data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example we are listening for the `TransformGestureEvent.GESTURE_SWIPE` event in
    order to shift the x and y position of our `Shape` object. By adjusting the coordinates
    of our `Shape` through the reported offset data, we can adjust the position of
    our object in a way that the user expects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see through this example that the `offsetX` and `offsetY` values returned
    by our event listener will each either be 1 or -1\. This makes it very simple
    for us to determine which direction the swipe has registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swipe up:** offsetY = -1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swipe down:** offsetY = 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swipe left:** offsetX = -1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swipe right:** offsetX = 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When reacting to swipe events, it may be a good idea to provide a bit of transition
    animation, either by using built in tweening mechanisms, or an external tweening
    engine. There are many great tweening engines for ActionScript freely available
    as open source software. The use of these engines along with certain gestures
    can provide a more pleasant experience for the user of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might consider the following popular tweening engines for use in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TweenLite:** [http://www.greensock.com/tweenlite/](http://www.greensock.com/tweenlite/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**GTween:** [http://www.gskinner.com/libraries/gtween/](http://www.gskinner.com/libraries/gtween/)'
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_SWIPE` is just one of a set of four primary
    transform gestures available to us when working with the Flash Platform runtimes
    and Android devices. Reference the following recipes for a complete overview of
    these gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using gestures to zoom a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using gestures to pan a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using gestures to rotate a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gestures to rotate a display object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rotation is performed by holding two fingers at different points on an object,
    and then moving one finger around the other in a clockwise or counter clockwise
    motion. This results in the rotation of the object on screen. Rotation can be
    used alongside the pan and zoom gestures to provide full control to the user over
    an image or other `DisplayObject`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example draws a square within a `Shape` object using the `Graphics` API,
    adds it to the `Stage`, and then sets up a listener for `Rotate` gesture events
    in order to appropriately rotate the `Shape` instance around its registration
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `Shape` object which we will perform the gestures upon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener for the `GESTURE_ROTATE` event. In this case, the
    `onRotate` method will fire whenever the application detects a rotation gesture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now respond to the data being returned by our rotate event. In this
    case, we are simply assigning the `rotation` value returned from our event listener
    to the `rotation` parameter of our `Shape` in order to perform the appropriate
    rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are setting our `Multitouch.inputMode` to gestures through `MultitouchInputMode.GESTURE`,
    we are able to listen for and react to a host of predefined gestures. In this
    example we are listening for the `TransformGestureEvent.GESTURE_ROTATE` event
    in order to assign the returned `rotation` value to our `Shape` object.
  prefs: []
  type: TYPE_NORMAL
- en: There is really no further calculation to make upon this data in most cases,
    but we could perform more advanced rotation interactions by allowing (for instance)
    the rotation of one `DisplayObject` to affect the rotation of an additional `DisplayObject`,
    or even multiple `DisplayObjects` on the `Stage`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note here that we are drawing our square in such a way that the `Shape` registration
    point is located in the center of the visible `Shape`. It is important that we
    do this, as the `DisplayObject` will rotate based upon the registration point
    and transform point.
  prefs: []
  type: TYPE_NORMAL
- en: When using the drawing tools in Flash Professional, be sure to set the registration
    point of your `MovieClip` symbol to be centered in order for this to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_ROTATE` is just one of a set of four primary
    transform gestures available to us when working with the Flash Platform runtimes
    and Android devices. Reference the following recipes for a complete overview of
    these gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using gestures to zoom a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using gestures to pan a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using gestures to swipe a display object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing raw touchpoint data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the predefined gestures that are baked into Flash Player and AIR are
    not enough for certain application interactions. This recipe will demonstrate
    how to access raw touch data reported by the operating system through Flash Player
    or AIR APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To read raw touch data in your project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    We will also register a set of listeners for `TouchEvent` data in the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To clear out our `TextField` after each touch interaction ends, we will construct
    the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then read the various properties from the touch event to interpret in
    some way. Events such as pressure, coordinates, size, and more can be derived
    from the event object that is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each touch point that is registered in the device has a number of specific properties
    associated with it. By registering a set of listeners to detect these interactions,
    we can read this data and the application can react appropriately. In our example,
    we are simply exposing these values via `TextField`, but this would be the exact
    data we would need to build a pressure-sensitive gaming mechanic or some other
    custom gesture.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on a device that allows more than one touchpoint, we will be able
    to read the data from both touchpoints using the same listener. Multiple touchpoints
    are differentiated by location on the stage and by `touchPointID`. We would use
    these IDs to differentiate between touchpoints when devising complex gestures,
    or simply when we have the need to keep track of each touchpoint in a precise
    way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that while `Multitouch.inputMode` is set to `MultitouchInputMode.TOUCH_POINT`
    that we will not be able to take advantage of the predefined gestures that Flash
    Player and AIR make available through the simplified gesture API. Setting the
    `Multitouch.inputMode` to `MultitouchInputMode.GESTURE` will allow us to take
    advantage of common, predefined gesture events within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom gesture based upon touchPoint data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using raw touch data, we can define custom gestures to develop unique interactions
    used in our application. We do this by making calculations based upon data delivered
    through raw touch events.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will create a diagonal swipe gesture that can have four
    separate values returned which let us know the direction of a diagonal swipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object to allow visible text output
    upon the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will set up two additional objects to help track our gestures, a `Shape`
    called `drawArea` to draw out the gestures through the graphics API, and `trackBeginObject`,
    which is a simple object we can use to preserve our beginning touch coordinates
    to compare with the coordinates of our touch end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat,` and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will set up our `Shape` within which we will draw out gestures using
    the `Graphics` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    In this example, we will register a set of listeners to detect touch movement
    on the `Stage`. This will serve to provide visual feedback for our gesture tracking
    and also preserve our beginning touch coordinates to compare with the coordinates
    of our touch end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will also initialize out tracking `Object` through this same method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Construct a method called `touchBegin` to initialize the beginning of our gesture
    and preserve coordinate data for later comparison. We will make sure that the
    touchpoint being registered is the first touchpoint of what could be multiple
    by testing against the `TouchEvent.isPrimaryTouchPoint` boolean property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct another method called `touchMove` to accept the touch movement data
    and draw out our visual feedback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct a final method called `touchEnd` to compare the end touch data coordinates
    with what we preserved at the beginning through our `trackBeginObject` and then
    determine what sort of gesture it is. In this case, we output the results as a
    `String` to a `TextField`, previously created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have access to all of the raw touchpoint data, we can track the life cycle
    of a touch interaction from beginning to end with the help of regular ActionScript
    elements such as `Object, Vector`, or `Array` instances. Based upon the data tracked,
    such as coordinate position, touch pressure, and so forth, we can make calculations
    and determine whether or not the interaction qualifies as the gesture we are looking
    to track.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our preceding example, we are being fairly loose with our determination
    of a qualifying gesture. To be more stringent, we could also calculate the distance
    of different touch points and even track the time from touch begin to touch end
    to be sure the gesture is exactly what we are looking for, and therefor intentional
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are actually quite a few gesture libraries that we can use as alternatives
    to those built into the Flash Player and AIR runtimes. Performing a quick web
    search should allow us access to these libraries, many of which are free open
    source software. The most popular 3rd party gesture library is `Gesture Works`,
    which can be downloaded from [http://gestureworks.com/](http://gestureworks.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Emulating the Android long-press interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most useful interactions built into the Android operating system
    is the long press. This is achieved when a user taps a specific area and holds
    for a few seconds without releasing. While neither Flash Player nor AIR for Android
    have the long-press interaction as part of the multitouch gesture events library,
    it is fairly simple to emulate this interaction through either runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will emulate the Android long-press interaction through use of an ActionScript
    `Timer` object along with the use of `TouchPoint` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `Sprite` object which we will perform the long-press upon, as well
    as a `Timer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up out `Timer` object to measure the amount of time it should take to register
    a long-press; in this case, 1000 milliseconds. Additionally, we will now register
    a listener to detect when the `Timer` cycle has completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, construct a method to handle the creation of our `Sprite` and add it to
    the `DisplayList:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    To emulate a long-press, we must start a timer at each instance of a touch interaction
    through `TouchEvent.TOUCH_BEGIN`. The `Timer` will be stopped whenever a `TouchEvent.TOUCH_END`
    or some other touch cancelling event is fired, resetting our "long-press".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Construct a method to modify our `Sprite` upon the start of our touch interaction.
    We will scale the `Sprite` slightly and change the alpha property to indicate
    that something has activated. At this point, we begin measuring the long-press
    through our `Timer:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Timer` is set to complete after 1000 milliseconds, once fired. Upon this
    trigger, we can then perform whatever action is necessary within the application.
    In this case, we are making our `Sprite` dragable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method for a touch end should stop our `Timer` and cancel any drag events
    occurring with our `Sprite`. Here, we also rest the `scale` and `alpha` of our
    `Sprite` to return it to a rest state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting gesture will affect our visual object in the following way:![How
    to do it...](img/1420_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Illustrations provided by Gestureworks (www.gestureworks.com).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our example requires a one second press and hold to trigger a function invocation,
    which causes a `Shape` object to become draggable across the `Stage`. This is
    accomplished by listening for a `TOUCH_BEGIN` event, then monitoring a `Timer`
    to decide whether this is an intentional long-press interaction. If one second
    goes by without a `TOUCH_END` event, then we make the `Shape` draggable. We have
    modified the scale and opacity of the `Shape` once the `Timer` is triggered to
    indicate that it now a draggable object. Releasing the `Shape` will complete the
    interaction.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common uses of the long-press are to perform a repositioning of certain
    visual elements, as we have done here, or to invoke a menu operation as Android
    users are very comfortable with using this sort of interaction on their devices.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the virtual keyboard programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, simply giving focus to a text input field will invoke the virtual
    keyboard. Losing focus will dismiss the virtual keyboard. Perhaps we require our
    application to do this without user interaction, or immediately when entering
    a certain application state for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We configure a `Shape` to toggle the Android virtual keyboard on and off through
    a `Tap` touch event assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare a `Shape` alongside a `TextField` and `TextFormat` object. These will
    be used for interaction and visual feedback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, construct a method to handle the creation of our `Sprite` and add it to
    the `DisplayList`. Tapping this `Sprite` will allow us to invoke or hide the virtual
    keyboard. We will also construct a `TextField` and associated `TextFormat` object
    within the `Sprite` to allow us to provide stateful messages to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant
    and register an event listener on the `DisplayObject`, which will be used to trigger
    the activation and deactivation of the Android virtual keyboard. In this case,
    a `TouchEvent.TOUCH_TAP` event. A touch tap is the touch equivalent of a mouse
    click event. We can also register a number of listeners for a set of virtual keyboard
    events. In order for a `DisplayObject` to be able to invoke the virtual keyboard,
    we will need to set its `needsSoftKeyboard` property to `true`. The `SoftKeyboardEvent`
    listeners we register here are optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make use of the `SoftKeyboardEvent` listeners defined in the preceding point,
    we must create a variety of methods to execute once each activity is detected.
    In this way, we can monitor, interact with, or even prevent certain events from
    firing by intercepting the virtual keyboard while in the midst of activating,
    or detecting when the virtual keyboard has completed activation or deactivation
    completely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To invoke the virtual keyboard, we simply invoke `requestSoftKeyboard()on` the
    `DisplayObject`, whose `needsSoftKeyboard` property has been set to `true`. Here,
    we are checking to see whether `needsSoftKeyboard` is set to true or not, and
    toggling this property based upon that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To dismiss the virtual keyboard, the user will need to tap upon a `DisplayObject`,
    whose `needsSoftKeyboard` property has been set to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result will appear similar to the following:![How to do it...](img/1420_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to invoke the Android virtual keyboard through ActionScript, we must
    set an interactive `DisplayObjects.needsSoftKeyboard` property to `true`. This
    will allow us to register a tap touch listener and invoke `requestSoftKeyboard()`
    upon the tap touch event being fired, revealing the virtual keyboard on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Touching any `DisplayObject` whose `needsSoftKeyboard` property is set to `false`
    (the default state), will dismiss the virtual keyboard. In our preceding example,
    we switch this property from `true` to `false` in order to make the `DisplayObject`
    function as a toggle control.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is not necessary to use the `SoftKeyboardEvent` class to activate or
    dismiss the Android virtual keyboard through ActionScript, it is included in the
    example class as it allows us to respond to such events with an additional set
    of listener functions.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to Android soft-key interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AIR for Android does not include support for invoking the native operating system
    options menu that often appears at the bottom of the screen. However, there are
    ways of simulating the native behaviour, which we will explore in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The normal behaviour of the `back` button, on Android, is to step back through
    the application states until we arrive back home. A further press of the `back`
    button will exit the application. By default, AIR for Android applications behave
    in this way as well. If we want to override this default behaviour, we must set
    up a mechanism to intercept this interaction and then prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can respond to soft-key events through standard ActionScript event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object to allow visible output upon
    the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to set an event listener on the `Stage` to respond to keyboard
    presses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will then write a switch/case statement in our `keyDown` method that will
    perform different actions in response to specific soft-key events. In this case,
    we output the name of a specific menu item to our `TextField:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We register listeners for these Android device soft-keys just as we would for
    a physical or virtual keyboard in ActionScript. If developing Android applications
    using AIR for Android, we also have access to the `BACK, MENU`, and `SEARCH` constants
    through the `Keyboard` class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a keyboard `keyDown` listener and then responding to specific key
    values through a switch/case statement allows us to respond to the interaction
    appropriately. For instance, if the `MENU` soft-key interaction is detected, we
    can reveal an options menu.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also a `HOME` soft-key on Android devices. This key press cannot be
    captured through ActionScript as it exists solely to return the user to the Android
    home screen from any opened application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must use the `keyDown` event when we want to cancel the default Android behavior
    of the `BACK` key because the `keyUp` event will fire too late and not be caught
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to trackball and D-Pad events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Android devices have additional physical inputs that we can take advantage
    of. For instance, the Motorola Droid has a slider keyboard, which includes a directional
    D-pad and the HTC Nexus One has a built-in trackball control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can respond to trackball and D-pad events through standard ActionScript event
    listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare a `Shape` alongside a `TextField` and `TextFormat` object. These will
    be used for interaction and visual feedback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, construct a method to handle the creation of our `Shape` and add it to
    the `DisplayList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set an event listener on the `Stage` to respond to keyboard presses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we simply need to write a switch/case statement that will perform different
    actions in response to D-pad/trackball events. In this case, we change the position
    of our `Shape` and output the `keyCode` to a `TextField:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_02_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We register listeners for these special controls just as we would the `Keyboard.UP,
    Keyboard.DOWN, Keyboard.LEFT, Keyboard.RIGHT`, and `Keyboard.ENTER` keys for any
    physical keyboard. In this example, we are shifting the target `Shape` in each
    direction and rest the location based upon the D-pad/trackball being pressed.
    We are also outputting the `keyCode` value to a text field.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that most Android devices do not have such specialized
    input mechanisms. If we do register events mapped to these keys, we should always
    supply and alternative as well.
  prefs: []
  type: TYPE_NORMAL
