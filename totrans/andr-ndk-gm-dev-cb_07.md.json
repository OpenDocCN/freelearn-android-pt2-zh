["```kt\n    private static final int MOTION_MOVE = 0;\n    private static final int MOTION_UP   = 1;\n    private static final int MOTION_DOWN = 2;\n    private static final int MOTION_START = -1;\n    private static final int MOTION_END   = -2;\n    ```", "```kt\n    @Override public boolean onTouchEvent( MotionEvent event )\n    {\n    ```", "```kt\n      SendMotion( MOTION_START, 0, 0, false, MOTION_MOVE );\n    ```", "```kt\n      int E = event.getAction() & MotionEvent.ACTION_MASK;\n      int nPointerID = event.getPointerId((event.getAction() &MotionEvent.ACTION_POINTER_INDEX_MASK) >>MotionEvent.ACTION_POINTER_INDEX_SHIFT );\n      try\n      {\n    ```", "```kt\n        int x = (int)event.getX(), y = (int)event.getY();\n        int cnt = event.getPointerCount();\n    ```", "```kt\n        if ( E == MotionEvent.ACTION_DOWN )\n        {\n          for ( int i = 0; i != cnt; i++ )\n            SendMotion( event.getPointerId(i),(int)event.getX(i),(int)event.getY(i),true, MOTION_DOWN );\n        }\n    ```", "```kt\n        if ( E == MotionEvent.ACTION_UP ||E == MotionEvent.ACTION_CANCEL )\n        {\n          SendMotion( MOTION_END, 0, 0, false, MOTION_UP );\n          return E <= MotionEvent.ACTION_MOVE;\n        }\n    ```", "```kt\n        int maskedEvent = event.getActionMasked();\n        if ( maskedEvent== MotionEvent.ACTION_POINTER_DOWN )\n        {\n          for ( int i = 0; i != cnt; i++ )\n            SendMotion( event.getPointerId(i),(int)event.getX(i),(int)event.getY(i),true, MOTION_DOWN );\n        }\n        if ( maskedEvent == MotionEvent.ACTION_POINTER_UP )\n        {\n          for ( int i = 0; i != cnt ; i++ )\n            SendMotion( event.getPointerId(i),(int)event.getX(i),(int)event.getY(i),i != nPointerID, MOTION_UP );\n          SendMotion( nPointerID,(int)event.getX(nPointerID),(int)event.getY(nPointerID),false, MOTION_MOVE );\n        }\n    ```", "```kt\n        if ( E == MotionEvent.ACTION_MOVE )\n        {\n          for ( int i = 0; i != cnt; i++ )\n            SendMotion(event.getPointerId(i),(int)event.getX(i),(int)event.getY(i),true, MOTION_MOVE );\n        }\n      }\n    ```", "```kt\n      SendMotion( MOTION_END, 0, 0, false, MOTION_MOVE );\n      return E <= MotionEvent.ACTION_MOVE;\n    }\n    ```", "```kt\n    public native static void SendMotion( int PointerID, int x, int y,\n      boolean Pressed, int Flag );\n    ```", "```kt\n    >Install driver.cmd\n    ```", "```kt\n    #if !defined(_MSC_VER)\n    #define SM_DIGITIZER            94\n    #define SM_MAXIMUMTOUCHES       95\n    #define TOUCHEVENTF_DOWN        0x0001\n    #define TOUCHEVENTF_MOVE        0x0002\n    #define TOUCHEVENTF_UP          0x0004\n    #define TOUCHEVENTF_PRIMARY     0x0010\n    #define WM_TOUCH                0x0240\n    ```", "```kt\n    typedef struct _TOUCHINPUT {\n      LONG x, y;\n      HANDLE hSource;\n      DWORD dwID, dwFlags, wMask, dwTime;\n      ULONG_PTR dwExtraInfo;\n      DWORD cxContact, cyContact;\n    } TOUCHINPUT,*PTOUCHINPUT;\n    #endif\n    ```", "```kt\n    typedef BOOL (WINAPI *CloseTouchInputHandle_func)(HANDLE);\n    typedef BOOL (WINAPI *Get_func)(HANDLE, UINT, PTOUCHINPUT, int);\n    typedef BOOL (WINAPI *RegisterTouch_func)(HWND, ULONG);\n    typedef BOOL (WINAPI *UnregisterTouch_func)(HWND);\n    static CloseTouch_func CloseTouchInputHandle_Ptr = NULL;\n    static Get_func GetTouchInputInfo_Ptr = NULL;\n    static RegisterTouch_func RegisterTouchWindow_Ptr = NULL;\n    static UnregisterTouch_func UnregisterTouchWindow_Ptr =NULL;\n    ```", "```kt\n    static bool LoadTouchFuncs()\n    {\n      if ( !CloseTouchInputHandle_Ptr )\n      {\n        HMODULE hUser = LoadLibraryA( \"user32.dll\" );\n        CloseTouchInputHandle_Ptr =(CloseTouchInputHandle_func)GetProcAddress( hUser, \"CloseTouchInputHandle\" );\n        GetTouchInputInfo_Ptr = ( GetTouchInputInfo_func )GetProcAddress( hUser, \"GetTouchInputInfo\" );\n        RegisterTouchWindow_Ptr = (RegisterTouchWindow_func)GetProcAddress( hUser, \"RegisterTouchWindow\" );\n        UnregisterTouchWindow_Ptr =(UnregisterTouchWindow_func)GetProcAddress( hUser, \"UnregisterTouchWindow\" );\n      }\n      return ( RegisterTouchWindow_Ptr != NULL );\n    }\n    ```", "```kt\n    static POINT GetTouchPoint(HWND hWnd, const TOUCHINPUT& ti)\n    {\n      POINT pt;\n      pt.x = ti.x / 100;\n      pt.y = ti.y / 100;\n      ScreenToClient( hWnd, &pt );\n      return pt;\n    }\n    ```", "```kt\n    case WM_TOUCH:\n    {\n      unsigned int NumInputs = (unsigned int)wParam;\n      if ( NumInputs < 1 ) { break; }\n      TOUCHINPUT* ti = new TOUCHINPUT[NumInputs];\n      DWORD Res = GetTouchInputInfo_Ptr((HANDLE)lParam, NumInputs, ti, sizeof(TOUCHINPUT));\n      double EventTime = Env_GetSeconds();\n      if ( !Res ) { break; }\n    ```", "```kt\n      for (unsigned int i = 0; i < NumInputs ; ++i)\n      {\n        POINT touch_pt = GetTouchPoint(Window, ti[i]);\n        vec2 Coord(touch_pt.x / ImageWidth,touch_pt.y / ImageHeight);\n        sTouchPoint pt(ti[i].dwID, Coord,MOTION_MOVE, EventTime);\n        if (ti[i].dwFlags & TOUCHEVENTF_DOWN)pt.FFlag = MOTION_DOWN;\n        if (ti[i].dwFlags & TOUCHEVENTF_UP)\n          pt.FFlag = MOTION_UP;\n        Viewport_UpdateTouchPoint(pt);\n      }\n    ```", "```kt\n      CloseTouchInputHandle_Ptr((HANDLE)lParam);\n      delete[] ti;\n    ```", "```kt\n      Viewport_ClearReleasedPoints();\n    ```", "```kt\n      Viewport_UpdateCurrentGesture();\n      break;\n    }\n    ```", "```kt\n    std::list<sTouchPoint> g_TouchPoints;\n    ```", "```kt\n    struct sTouchPoint\n    {\n      int FID;\n      vec2 FPoint;\n      int FFlag;\n      double FTimeStamp;\n      sTouchPoint(int ID, const vec2& C, int flag, doubletstamp):\n        FID(ID), FPoint(c), FFlag(flag), FTimeStamp(tstamp) {}\n    ```", "```kt\n      inline bool IsPressed() const\n      {\n        return (FFlag == MOTION_MOVE) || (FFlag ==MOTION_DOWN);\n      }\n    };\n    ```", "```kt\n    void Viewport_UpdateTouchPoint(const sTouchPoint& pt)\n    {\n      std::list<sTouchPoint>::iterator foundIt =FTouchPoints.end();\n      for ( auto it = FTouchPoints.begin(); it != foundIt;++it )\n      {\n        if ( it->FID == pt.FID )\n        {\n          foundIt = it;\n          break;\n        }\n      }\n      switch ( pt.FFlag )\n      {\n        case MOTION_DOWN:\n          if ( foundIt == FTouchPoints.end() )\n            FTouchPoints.push_back( pt );\n        case MOTION_UP:\n        case MOTION_MOVE:\n          if ( foundIt != FTouchPoints.end() )\n            *foundIt = pt;\n          break;\n      }\n    }\n    ```", "```kt\n    void Viewport_ClearReleasedPoints()\n    {\n      auto first = FTouchPoints.begin();\n      auto result = first;\n      for ( ; first != FTouchPoints.end() ; ++first )\n        if ( first->FFlag != MOTION_UP ) *result++ = *first;\n      FTouchPoints.erase( result, FTouchPoints.end() );\n    }\n    ```", "```kt\n    void Viewport_UpdateCurrentGesture()\n    {\n      Viewport_ProcessMotion( MOTION_START,vec2(), false, MOTION_MOVE );\n      auto j = FTouchPoints.begin();\n      for ( ; j != FTouchPoints.end(); ++j )\n        Viewport_ProcessMotion( j->FID, j->FPoint,j->IsPressed(), j->FFlag );\n      Viewport_ProcessMotion( MOTION_END, vec2(), false,MOTION_MOVE );\n    }\n    ```", "```kt\ncase WM_CREATE:\n...\ng_TouchEnabled = false;\nBYTE DigitizerStatus = (BYTE)GetSystemMetrics( SM_DIGITIZER );\nif ( (DigitizerStatus & (0x80 + 0x40)) != 0 )\n{\n  BYTE nInputs = (BYTE)GetSystemMetrics( SM_MAXIMUMTOUCHES );\n  if ( LoadTouchFuncs() )\n  {\n    if ( !RegisterTouchWindow_Ptr(h, 0) )\n    {\n      LOGI( \"Enabled, num points: %d\\n\", (int)nInputs );\n      g_TouchEnabled = true;\n      break;\n    }\n  }\n}\n```", "```kt\n    class iGestureResponder\n    {\n    public:\n    ```", "```kt\n      virtual void Event_UpdateGesture( const sMotionData& Data ) {}\n    ```", "```kt\n      virtual void Event_PointerChanged(int PtrID,const vec2& Pnt, bool Pressed) {}\n      virtual void Event_PointerMoved(int PtrID, const vec2&const vec2& Pnt){}\n    ```", "```kt\n      virtual void Event_Fling( const sTouchPoint& Down,const sTouchPoint& Up ) {}\n    ```", "```kt\n      virtual void Event_Drag( const sTouchPoint& Down,const sTouchPoint& Current ) {}\n    ```", "```kt\n      virtual void Event_PinchStart( const sTouchPoint& Initial1,const sTouchPoint& Initial2 ) {}\n      virtual void Event_Pinch( const sTouchPoint& Initial1,const sTouchPoint& Initial2,const sTouchPoint& Current1,const sTouchPoint& Current2 ) {}\n      virtual void Event_PinchStop( const sTouchPoint& Initial1,const sTouchPoint& Initial2,const sTouchPoint& Current1,const sTouchPoint& Current2 ) {};\n    };\n    ```", "```kt\n      iGestureResponder* g_Responder;\n    ```", "```kt\n    struct sMotionData\n    {\n      sMotionData(): FTouchPoints() {};\n      void Clear() { FTouchPoints.clear(); };\n      size_t GetNumTouchPoints() const { returnFTouchPoints.size(); }\n      const sTouchPoint& GetTouchPoint( size_t Idx )    const {return FTouchPoints[Idx]; }\n      vec2 GetTouchPointPos(size_t i) const { returnFTouchPoints[i].FPoint; }\n      int GetTouchPointID(size_t i)  const { returnFTouchPoints[i].FID; }\n      void AddTouchPoint( const sTouchPoint& TouchPoint )\n      {\n        for ( size_t i = 0; i != FTouchPoints.size(); i++ )\n          if ( FTouchPoints[i].FID == TouchPoint.FID )\n          {\n            FTouchPoints[i] = TouchPoint;\n            return;\n          }\n        FTouchPoints.push_back( TouchPoint );\n      }\n    private:\n      std::vector<sTouchPoint> FTouchPoints;\n    };\n    ```", "```kt\n    sMotionData                 FMotionData;\n    RingBuffer<sMotionData>     FPrevMotionData(5);\n    bool FMotionDataValid = false;\n    bool FMoving = false;\n    bool FFlingWasValid = false;\n    bool FPinchZoomValid = false;\n    bool FPinchZoomWasValid = false;\n    ```", "```kt\n    sTouchPoint FInitialPoint( 0, LVector2(), MOTION_MOVE, 0.0 );\n    sTouchPoint FCurrentPoint( 0, LVector2(), MOTION_MOVE, 0.0 );\n    sTouchPoint FInitialPoint1, FInitialPoint2;\n    sTouchPoint FCurrentPoint1, FCurrentPoint2;\n    float FZoomFactor = 1.0f;\n    float FInitialDistance = 1.0f;\n    LVector2 FInitialCenter, FCurrentCenter;\n    ```", "```kt\n      float FlingStartSensitivity = 0.2f;\n    ```", "```kt\n      float FlingThresholdSensitivity = 0.1f;\n    ```", "```kt\n    template <typename T> class RingBuffer\n    {\n    public:\n      explicit RingBuffer(size_t Num): FBuffer(Num) { clear(); }\n      inline void clear() { FCount = FHead  = 0; }\n      inline void push_back( const T& Value )\n      {\n        if ( FCount < FBuffer.size() ) FCount++;\n        FBuffer[ FHead++ ] = Value;\n        if ( FHead == FBuffer.size() ) FHead = 0;\n      }\n    ```", "```kt\n      inline T* prev(size_t i)\n      { return (i >= FCount) ? NULL: &FBuffer[AdjustIndex(i)]; }\n    private:\n      std::vector<T> FBuffer;\n    ```", "```kt\n      size_t FHead;\n      size_t FCount;\n    ```", "```kt\n      inline int ModInt( int a, int b )\n      { int r = a % b; return ( r < 0 ) ? r+b : r; }\n    ```", "```kt\n      inline size_t AdjustIndex( size_t i ) const\n      {\n        return (size_t)ModInt( (int)FHead - (int)i - 1,(int)FBuffer.size() );\n      }\n    };\n    ```", "```kt\n    void GestureHandler_SendMotion( int ContactID, eMotionFlagFlag,LVector2 Pos, bool Pressed )\n    {\n      if ( ContactID == MOTION_START )\n      {\n        FMotionDataValid = false;\n        FMotionData.Clear();\n        return;\n      }\n      if ( ContactID == MOTION_END )\n      {\n        FMotionDataValid = true;\n        UpdateGesture();\n        g_Responder->Event_UpdateGesture( FMotionData );\n        if ( sMotionData* P = FPrevMotionData.prev(0) )\n        {\n          if ( P->GetNumTouchPoints() !=FMotionData.GetNumTouchPoints() )FPrevMotionData.push_back( FMotionData );\n        }\n        else\n        {\n          FPrevMotionData.push_back( FMotionData );\n        }\n        return;\n      }\n    ```", "```kt\n      if ( Pressed )\n        FMotionData.AddTouchPoint( sTouchPoint( ContactID, Pos,MOTION_DOWN, Env_GetSeconds() ) );\n    ```", "```kt\n      switch ( Flag )\n      {\n        case MOTION_MOVE:\n          g_Responder->Event_PointerMoved( ContactID, Pos );\n          break;\n        case MOTION_UP:\n        case MOTION_DOWN:\n          g_Responder->Event_PointerChanged( ContactID, Pos,Flag == MOTION_DOWN );\n          break;\n      }\n    }\n    ```", "```kt\n    void UpdateGesture()\n    {\n      const sTouchPoint& Pt1 = FInitialPoint;\n      const sTouchPoint& Pt2 = FCurrentPoint;\n      g_Responder->Event_UpdateGesture( FMotionData );\n    ```", "```kt\n      if ( IsDraggingValid() )\n      {\n        if ( GetPositionDelta().Length() >FlingThresholdSensitivity )\n        {\n          g_Responder->Event_Drag( Pt1, Pt2 );\n          FFlingWasValid = true;\n        }\n      }\n    else if ( FFlingWasValid )\n      {\n        if ( GetPositionDelta().Length() >FlingStartSensitivity )\n          g_Responder->Event_Fling( Pt1, Pt2 );\n        else\n          g_Responder->Event_Drag( Pt1, Pt2 );\n        FFlingWasValid = false;\n      }\n      if ( IsPinchZoomValid() )\n      {\n        if ( FPinchZoomWasValid )\n          g_Responder->Event_Pinch( FInitialPoint1,FInitialPoint2, FCurrentPoint1,FCurrentPoint2 );\n        else\n          g_Responder->Event_PinchStart( FInitialPoint1,FInitialPoint2 );\n        FPinchZoomWasValid = true;\n      }\n      else if ( FPinchZoomWasValid )\n      {\n        FPinchZoomWasValid = false;\n        g_Responder->Event_PinchStop( FInitialPoint1,FInitialPoint2, FCurrentPoint1, FCurrentPoint2 );\n      }\n    }\n    ```", "```kt\n    static vec2 GetPositionDelta()\n    { return FCurrentPoint.FPoint - FInitialPoint.FPoint; }\n    ```", "```kt\n    static bool IsDraggingValid()\n    {\n      if ( FMotionDataValid && FMotionData.GetNumTouchPoints() == 1&& FMotionData.GetTouchPointID( 0 ) == 0 )\n      {\n        if ( !FMoving )\n        {\n          FMoving       = true;\n          FInitialPoint = FMotionData.GetTouchPoint( 0 );\n          return false;\n        }\n        FCurrentPoint = FMotionData.GetTouchPoint( 0 );\n      }\n      else\n      {\n      FMoving = false;\n      }\n      return FMoving;\n    }\n    ```", "```kt\n    static bool IsPinchZoomValid()\n    {\n      if (FMotionDataValid && FMotionData.GetNumTouchPoints() == 2 )\n      {\n        const sTouchPoint& Pt1 = FMotionData.GetTouchPoint(0);\n        const sTouchPoint& Pt2 = FMotionData.GetTouchPoint(1);\n        const LVector2& Pos1(FMotionData.GetTouchPointPos(0));\n        const LVector2& Pos2(FMotionData.GetTouchPointPos(1));\n        float NewDistance = (Pos1 - Pos2).Length();\n        if ( FPinchZoomValid )\n        {\n          FZoomFactor    = NewDistance / FInitialDistance;\n          FCurrentPoint1 = Pt1;\n          FCurrentPoint2 = Pt2;\n          FCurrentCenter = ( Pos1 + Pos2 ) * 0.5f;\n        }\n        else\n        {\n          FInitialDistance = NewDistance;\n          FPinchZoomValid  = true;\n          FZoomFactor      = 1.0f;\n          FInitialPoint1   = Pt1;\n          FInitialPoint2   = Pt2;\n          FInitialCenter = ( Pos1 + Pos2 ) * 0.5f;\n          return false;\n        }\n      }\n      else\n      {\n        FPinchZoomValid = false;\n        FZoomFactor     = 1.0f;\n      }\n      return FPinchZoomValid;\n    }\n    ```", "```kt\n    struct sBitmapButton\n    {\n      vec4 FColour;\n      int FIndex;\n    };\n    ```", "```kt\n    struct sBitmapAxis\n    {\n      float FRadius;\n      vec2 FPosition;\n      int FAxis1, FAxis2;\n      vec4 Fcolour;\n    };\n    ```", "```kt\n    class ScreenJoystick\n    {\n      std::vector<sBitmapButton> FButtonDesc;\n      std::vector<sBitmapAxis> FAxisDesc;\n    ```", "```kt\n      std::vector<float> FAxisValue;\n      std::vector<bool> FKeyValue;\n    ```", "```kt\n      unsigned char* FMaskBitmap;\n    ```", "```kt\n      sBitmapButton* FPushedButtons[MAX_TOUCH_CONTACTS];\n      sBitmapAxis*   FPushedAxis[MAX_TOUCH_CONTACTS];\n    ```", "```kt\n      ScreenJoystick(): FMaskBitmap( NULL ) {}\n      virtual ~ScreenJoystick() {}\n    ```", "```kt\n      void InitKeys()\n      {\n        FKeyValue.resize( FButtonDesc.size() );\n        if ( FKeyValue.size() > 0 )\n        {\n          for (size_t j = 0 ; j < FKeyValue.size() ; j++ )\n            FKeyValue[j] = false;\n    }\n        FAxisValue.resize( FAxisDesc.size() * 2 );\n        if ( FAxisValue.size() > 0 )\n        {\n          memset( &FAxisValue[0], 0, FAxisValue.size() *sizeof( float ) );\n        }\n        Restart();\n      }\n    ```", "```kt\n      void Restart()\n      {\n        memset( &FPushedAxis[0], 0, sizeof(sBitmapAxis*) *MAX_TOUCH_CONTACTS );\n        memset( &FPushedButtons[0], 0, sizeof(sBitmapButton*) *MAX_TOUCH_CONTACTS );\n      }\n    ```", "```kt\n      void SetKeyState( int KeyIdx, bool Pressed )\n      {\n        if ( KeyIdx < 0 || KeyIdx >= ( int )FKeyValue.size() )\n      { return; }\n        FKeyValue[KeyIdx] = Pressed;\n      }\n      void SetAxisValue( int AxisIdx, float Val )\n      {\n        if ( ( AxisIdx < 0 ) ||AxisIdx >= (int)FAxisValue.size() )\n      { return; }\n        FAxisValue[AxisIdx] = Val;\n      }\n    ```", "```kt\n      bool IsPressed( int KeyIdx ) const\n      {\n        return ( KeyIdx < 0 ||KeyIdx >= ( int )FKeyValue.size() ) ?false : FKeyValue[KeyIdx];\n      }\n      float GetAxisValue( int AxisIdx ) const\n      {\n        return ( ( AxisIdx < 0 ) ||AxisIdx >= ( int )FAxisValue.size() ) ?0.0f : FAxisValue[AxisIdx];\n      }\n    ```", "```kt\n      sBitmapButton* GetButtonForColour( const vec4& Colour )const\n      {\n        for ( size_t k = 0 ; k < FButtonDesc.size(); k++ )\n        {\n          float Distance = (FButtonDesc[k]->FColour –Colour).Length();\n          if ( Distance < 0.1f ) return FButtonDesc[k];\n        }\n        return NULL;\n      }\n\n      sBitmapAxis* GetAxisForColour( const vec4& Colour ) const\n      {\n        for ( size_t k = 0 ; k < FAxisDesc.size(); k++ )\n        {\n          float Distance = (FButtonDesc[k]->FColour –Colour).Length();\n          if ( Distance < 0.1f ) return FAxisDesc[k];\n        }\n        return NULL;\n      }\n    ```", "```kt\n      void ReadAxis( sBitmapAxis* Axis, const vec2& Pos )\n      {\n        if ( !Axis ) { return; }\n    ```", "```kt\n        float v1 = ( (Axis->FPosition - Pos).x/Axis->FRadius);\n        float v2 = (-(Axis->FPosition - Pos).y/Axis->FRadius);\n        this->SetAxisValue( Axis->FAxis1, v1 );\n        this->SetAxisValue( Axis->FAxis2, v2 );\n      }\n      vec4 GetColourAtPoint( const vec2& Pt ) const\n      {\n        if ( !FMaskBitmap ) { return vec4( -1 ); }\n        int x = (int)(Pt.x * 512.0f);\n        int y = (int)(Pt.y * 512.0f);\n        int Ofs = (y * 512 + x) * 3;\n        float r = (float)FMaskBitmap[Ofs + 0] / 255.0f;\n        float g = (float)FMaskBitmap[Ofs + 1] / 255.0f;\n        float b = (float)FMaskBitmap[Ofs + 2] / 255.0f;\n        return vec4( b, g, r, 0.0f );\n      }\n    ```", "```kt\n    void HandleTouch( int ContactID, const vec2& Pos, bool Pressed,\n      eMotionFlag Flag )\n    {\n    ```", "```kt\n      if ( ContactID == MOTION_START )\n      {\n        for ( size_t i = 0; i != MAX_TOUCH_CONTACTS; i++ )\n        {\n          if ( FPushedButtons[i] )\n          {\n            this->SetKeyState(\n              FPushedButtons[i]->FIndex, false );\n            FPushedButtons[i] = NULL;\n          }\n          if ( FPushedAxis[i] )\n          {\n            this->SetAxisValue(\n              FPushedAxis[i]->FAxis1, 0.0f );\n            this->SetAxisValue(\n              FPushedAxis[i]->FAxis2, 0.0f );\n            FPushedAxis[i] = NULL;\n          }\n        }\n        return;\n      }\n      if ( ContactID == MOTION_END ) { return; }\n      if ( ContactID < 0 || ContactID >= MAX_TOUCH_CONTACTS )\n      { return; }\n    ```", "```kt\n      if ( Flag == MOTION_DOWN || Flag == MOTION_MOVE )\n      {\n        vec4 Colour = GetColourAtPoint( Pos );\n        sBitmapButton* Button = GetButtonForColour( Colour );\n        sBitmapAxis*     Axis = GetAxisForColour( Colour );\n    ```", "```kt\n        if ( Button && Pressed )\n        {\n          int Idx = Button->FIndex;\n          this->SetKeyState( Idx, true );\n          FPushedButtons[ContactID] = Button;\n        }\n    ```", "```kt\n        if ( Axis && Pressed )\n        {\n          this->ReadAxis( Axis,  Pos );\n          FPushedAxis[ContactID] = Axis;\n        }\n      }\n    }\n    ```", "```kt\nScreenJoystick g_Joystick;\n```", "```kt\n  float A_Y = 414.0f / 512.0f;\n\n  sBitmapAxis B_Left;\n  B_Left.FAxis1 = 0;\n  B_Left.FAxis2 = 1;\n  B_Left.FPosition = vec2( 55.0f / 512.f, A_Y );\n  B_Left.FRadius = 40.0f / 512.0f;\n  B_Left.FColor = vec4( 0.75f, 0.75f, 0.75f, 0.0f );\n\n  sBitmapButton B_Fire;\n  B_Fire.FIndex = ID_BUTTON_THRUST;\n  B_Fire.FColor = vec4( 0 );\n  g_Joystick.FAxisDesc.push_back( B_Left );\n  g_Joystick.FButtonDesc.push_back( B_Fire );\n```", "```kt\n  g_Joystick.InitKeys();\n  g_Joystick.Restart();\n```", "```kt\n    class TextRenderer\n    {\n      // Local instance of the library (for thread-safeexecution)\n      FT_Library FLibrary;\n      // Cache manager\n      FTC_Manager FManager;\n      // Glyph cache\n      FTC_ImageCache FImageCache;\n      // Character map cache\n      FTC_CMapCache FCMapCache;\n    ```", "```kt\n      // List of available font faces\n      std::vector<std::string> FFontFaces;\n      // Handle for the current font face\n      FT_Face FFace;\n      // List of loaded font files to prevent multiple filereads\n      std::map<std::string, void*> FAllocatedFonts;\n      // List of initialized font face handles\n      std::map<std::string, FT_Face> FFontFaceHandles;\n    ```", "```kt\n      bool FMaskMode;\n    ```", "```kt\n    void InitFreeType()\n    {\n      LoadFT();\n      FT_Init_FreeTypePTR( &FLibrary );\n      FTC_Manager_NewPTR(FLibrary,0,0,0,\n        FreeType_Face_Requester, this, &FManager);\n      FTC_ImageCache_NewPTR( FManager, &FImageCache );\n      FTC_CMapCache_NewPTR( FManager, &FCMapCache );\n    }\n    ```", "```kt\n    void StopFreeType()\n    {\n      FreeString();\n      auto p = FAllocatedFonts.begin();\n      for ( ; p!= FAllocatedFonts.end() ; p++ )\n        delete[] ( char* )( p->second );\n      FFontFaces.clear();\n      FTC_Manager_DonePTR( FManager );\n      FT_Done_FreeTypePTR( FLibrary );\n    }\n    ```", "```kt\n    void FreeString()\n    {\n      for ( size_t i = 0 ; i < FString.size() ; i++ )\n        if ( FString[i].FCacheNode != NULL )\n          FTC_Node_UnrefPTR(FString[i].FCacheNode,FManager);\n      FString.clear();\n    }\n    ```", "```kt\n    TextRenderer(): FLibrary( NULL ), FManager( NULL ),FImageCache( NULL ), FCMapCache( NULL )\n    {\n      InitFreeType();\n      FMaskMode = false;\n    }\n    virtual ~clTextRenderer() { StopFreeType(); }\n    ```", "```kt\n    FT_ErrorLoadFontFile( const std::string& File )\n    {\n      if ( FAllocatedFonts.count( File ) > 0 ) { return 0; }\n      char* Data = NULL;\n      int DataSize;\n      ReadFileData( File.c_str(), &Data, DataSize );\n      FT_Face TheFace;\n    ```", "```kt\n      FT_Error Result = FT_New_Memory_FacePTR(FLibrary,(FT_Byte*)Data, (FT_Long)DataSize, 0, &TheFace );\n    ```", "```kt\n      if ( Result == 0 )\n      {\n        FFontFaceHandles[File] = TheFace;\n        FAllocatedFonts[File] = ( void* )Data;\n        FFontFaces.push_back( File );\n      }\n      return Result;\n    }\n    ```", "```kt\n    FT_Error FreeType_Face_Requester( FTC_FaceID FaceID,FT_Library Library, FT_Pointer RequestData, FT_Face* Face )\n    {\n    #ifdef _WIN64\n      long long int Idx = (long long int)FaceID;\n      int FaceIdx = (int)(Idx & 0xFF);\n    #else\n      int FaceIdx = reinterpret_cast< int >(FaceID);\n    #endif\n      if ( FaceIdx < 0 ) { return 1; }\n      TextRenderer* Renderer = ( TextRenderer* )RequestData;\n      std::string File = Renderer ->FFontFaces[FaceIdx];\n      FT_Error Result = Renderer ->LoadFontFile( File );\n      *Face = (Result == 0) ?\n      Renderer->FFontFaceHandles[File] : NULL;\n      return Result;\n    }\n    ```", "```kt\n    FT_Face GetSizedFace( int FontID, int Height )\n    {\n      FTC_ScalerRec Scaler;\n      Scaler.face_id = IntToID(FontID);\n      Scaler.height = Height;\n      Scaler.width = 0;\n      Scaler.pixel = 1;\n      FT_Size SizedFont;\n      if ( !FTC_Manager_LookupSizePTR(FManager, &Scaler,&SizedFont) ) return NULL;\n      if ( FT_Activate_SizePTR( SizedFont ) != 0 ) { returnNULL; }\n      return SizedFont->face;\n    }\n    ```", "```kt\n    struct sFTChar\n    {\n      // UCS2 character, suitable for FreeType\n      FT_UInt FChar;\n      // Internal character index\n      FT_UInt FIndex;\n      // Handle for the rendered glyph\n      FT_Glyph FGlyph;\n      // Fixed-point character advance and character size\n      FT_F26Dot6 FAdvance, FWidth;\n      // Cache node for this glyph\n      FTC_Node FCacheNode;\n      // Default parameters\n      sFTChar(): FChar(0), FIndex((FT_UInt)(-1)), FGlyph(NULL),FAdvance(0), FWidth(0), FCacheNode( NULL ) { }\n    };\n    ```", "```kt\n    bool DecodeUTF8( const char* InStr )\n    {\n      FIndex = 0;\n      FBuffer = InStr;\n      FLength = ( int )strlen( InStr );\n      FString.clear();\n      int R = DecodeNextUTF8Char();\n      while ( ( R != UTF8_LINE_END ) && ( R != UTF8_DECODE_ERROR ) )\n      {\n        sFTChar Ch;\n        Ch.FChar    = R;\n        FString.push_back( Ch );\n        R = DecodeNextUTF8Char();\n      }\n      return ( R != UTF8_DECODE_ERROR );\n    }\n    ```", "```kt\n    int DecodeNextUTF8Char()\n    {\n      // the first byte of the character and the result\n      int c, r;\n      if ( FIndex >= FLength )\n        return FIndex == FLength ?UTF8_LINE_END : UTF8_DECODE_ERROR;\n      c = NextUTF8();\n      if ( ( c & 0x80 ) == 0 ) { return c; }\n      if ( ( c & 0xE0 ) == 0xC0 )\n      {\n        int c1 = ContUTF8();\n        if ( c1 < 0 ) { return UTF8_DECODE_ERROR; }\n        r = ( ( c & 0x1F ) << 6 ) | c1;\n        return r >= 128 ? r : UTF8_DECODE_ERROR;\n      }\n      if ( ( c & 0xF0 ) == 0xE0 )\n      {\n        int c1 = ContUTF8(), c2 = ContUTF8();\n        if ( c1 < 0 || c2 < 0 ) { return UTF8_DECODE_ERROR; }\n        r = ( ( c & 0x0F ) << 12 ) | ( c1 << 6 ) | c2;\n        return r>=2048&&(r<55296||r>57343)?r:UTF8_DECODE_ERROR;\n      }\n      if ( ( c & 0xF8 ) == 0xF0 )\n      {\n        int c1 = ContUTF8(), c2 = ContUTF8(), c3 = ContUTF8();\n        if (c1 < 0||c2 < 0||c3< 0) { return UTF8_DECODE_ERROR; }\n        r = (( c & 0x0F ) << 18) | (c1 << 12) | (c2 << 6) | c3;\n        return r>=65536 && r<=1114111 ? r: UTF8_DECODE_ERROR;\n      }\n      return UTF8_DECODE_ERROR;\n    }\n    ```", "```kt\n      static const int UTF8_LINE_END = 0;\n      static const int UTF8_DECODE_ERROR = -1;\n    ```", "```kt\n      std::vector<sFTChar> FString;\n    ```", "```kt\n      int FIndex, FLength;\n    ```", "```kt\n      const char* FBuffer;\n      int  FByte;\n    ```", "```kt\n      inline int NextUTF8()\n      {\n        return ( FIndex >= FLength ) ?\n          UTF8_LINE_END : ( FBuffer[FIndex++] & 0xFF );\n      }\n    ```", "```kt\n      inline int ContUTF8()\n      {\n        int c = NextUTF8();\n        return ( ( c & 0xC0 ) == 0x80 ) ?\n          ( c & 0x3F ) : UTF8_DECODE_ERROR;\n      }\n    ```", "```kt\n    void CalculateLineParameters(int* Width, int* MinY, int* MaxY, int* BaseLine ) const\n    {\n    ```", "```kt\n      int StrMinY = -1000, StrMaxY = -1000;\n      if ( FString.empty() )\n        StrMinY = StrMaxY = 0;\n    ```", "```kt\n      int SizeX = 0;\n    ```", "```kt\n      for ( size_t i = 0 ; i != FString.size(); i++ )\n      {\n        if ( FString[i].FGlyph == NULL ) { continue; }\n        auto Glyph = ( FT_BitmapGlyph )FString[i].FGlyph;\n        SizeX += FString[i].FAdvance;\n        int Y = Glyph->top;\n        int H = Glyph->bitmap.rows;\n        if ( Y     > StrMinY ) { StrMinY = Y; }\n        if ( H - Y > StrMaxY ) { StrMaxY = H - Y; }\n      }\n      if ( Width    ) { *Width = ( SizeX >> 6 ); }\n      if ( BaseLine ) { *BaseLine = StrMaxY; }\n      if ( MinY     ) { *MinY = StrMinY; }\n      if ( MaxY     ) { *MaxY = StrMaxY; }\n    }\n    ```", "```kt\n    clPtr<Bitmap> RenderTextWithFont( const std::string& Str,\n    \tint FontID, int FontHeight,\n    \tunsigned int Color, bool LeftToRight )\n    {\n    ```", "```kt\n      if ( !LoadTextStringWithFont(Str, FontID, FontHeight) )\n      { return NULL; }\n    ```", "```kt\n      int W, Y, MinY, MaxY;\n      CalculateLineParameters( &W, &MinY, &MaxY, &Y );\n      clPtr<Bitmap> Result = new Bitmap( W, MaxY + MinY);\n    ```", "```kt\n      RenderLineOnBitmap( TextString, FontID, FontHeight,\n        LeftToRight ? 0 : W - 1, \tMinY, Color, LeftToRight,Result );\n      return Result;\n    }\n    ```", "```kt\n    bool LoadStringWithFont(const std::string& S, int ID, intHeight )\n    {\n      if ( ID < 0 ) { return false; }\n    ```", "```kt\n      FFace = GetSizedFace( ID, Height );\n      if ( FFace == NULL ) { return false; }\n      bool UseKerning = FT_HAS_KERNING( Face );\n    ```", "```kt\n      DecodeUTF8( S.c_str() );\n      for ( size_t i = 0, count = FString.size(); i != count;i++ )\n      {\n        sFTChar& Char = FString[i];\n        FT_UInt ch = Char.FChar;\n        Char.FIndex = ( ch != '\\r' && ch != '\\n' ) ?GetCharIndex(ID, ch) : -1;\n    ```", "```kt\n        Char.FGlyph = ( Char.FIndex != -1 ) ?GetGlyph( ID, Height, ch,FT_LOAD_RENDER, &Char.FCacheNode ) : NULL;\n        if ( !Char.FGlyph || Char.FIndex == -1 ) continue;\n    ```", "```kt\n        SetAdvance( Char );\n    ```", "```kt\n        if (i > 0 && UseKerning) Kern(FString[i - 1], Char);\n      }\n      return true;\n    }\n    ```", "```kt\n    void SetAdvance( sFTChar& Char )\n    {\n      Char.FAdvance = Char.FWidth = 0;\n      if ( !Char.FGlyph ) { return; }\n    ```", "```kt\n      Char.FAdvance = Char.FGlyph->advance.x >> 10;\n      FT_BBox bbox;\n      FT_Glyph_Get_CBoxPTR( Char.FGlyph,FT_GLYPH_BBOX_GRIDFIT, &bbox );\n      Char.FWidth = bbox.xMax;\n      if ( Char.FWidth == 0 && Char.FAdvance != 0 )\n        { Char.FWidth = Char.FAdvance; }\n      }\n    void Kern( sFTChar& Left, const sFTChar& Right )\n    {\n      if ( Left.FIndex == -1 || Right.FIndex == -1 )\n        { return; }\n      FT_Vector Delta;\n      FT_Get_KerningPTR( FFace, Left.FIndex, Right.FIndex,FT_KERNING_DEFAULT, &Delta );\n      Left.FAdvance += Delta.x;\n    }\n    ```", "```kt\n    void RenderLineOnBitmap( const std::string& S,int FontID, int FontHeight, int StartX, int Y,unsigned int C, bool LeftToRight, const clPtr<Bitmap>&Out )\n    {\n      LoadStringWithFont( S, FontID, FontHeight );\n      int x = StartX << 6;\n      for ( size_t j = 0 ; j != FString.size(); j++ )\n      {\n        if ( FString[j].FGlyph != 0 )\n        {\n          auto Glyph = (FT_BitmapGlyph) FString[j].FGlyph;\n          int in_x = (x>>6);\n          in_x  += (LeftToRight ? 1 : -1) * BmpGlyph->left;\n          if ( !LeftToRight )\n          {\n            in_x += BmpGlyph->bitmap.width;\n            in_x = StartX + ( StartX - in_x );\n          }\n          DrawGlyph( Out, &BmpGlyph->bitmap, in_x, Y -BmpGlyph->top, Color );\n        }\n        x += FString[j].FAdvance;\n      }\n    }\n    ```", "```kt\n    void DrawGlyph (const clPtr<Bitmap>& Out, FT_Bitmap* Bmp,int X0, int Y0, unsigned int Color )\n    {\n      unsigned char* Data = Out->FBitmapData;\n      int W = Out->FWidth;\n      int Width = W - X0;\n      if ( Width > Bmp->width ) { Width = Bmp->width; }\n      for ( int Y = Y0 ; Y < Y0 + Bmp->rows ; ++Y )\n      {\n        unsigned char* Src = Bmp->buffer + (Y-Y0)*Bmp->pitch;\n        if ( FMaskMode )\n        {\n          for ( int X = X0 + 0 ; X < X0 + Width ; X++ )\n          {\n            int Int = *Src++;\n            unsigned char Col = (Int & 0xFF);\n            for(int j = 0 ; j < 4 ; j++)\n              Data[(Y * W + X) * 4 + j]=  Col;\n          }\n        }\n        else\n        {\n          for ( int X = X0 + 0 ; X < X0 + Width ; X++ )\n          {\n            unsigned int Col = MultColor(Color, *Src++);\n            if ( Int > 0 )\n              { ((unsigned int*)Data)[Y * W + X] = Col; }\n          }\n        }\n      }\n    }\n    ```", "```kt\n    unsigned int MultColor( unsigned int C, unsigned int Mult )\n    { return (Mult << 24) | C; }\n    ```", "```kt\nTextRenderer txt;\nint fnt = txt.GetFontHandle(\"some_font.ttf\");\n```", "```kt\nchar text[] = { 'D','i','r','e',0xC3,0xA7,0xC3,0xA3,'o',0 };\nauto bmp = \n  txt.RenderTextWithFont(text, fnt, 24, 0xFFFFFFFF, true);\n```", "```kt\n    Hello~Привет\n    Good Bye~Пока\n    ```", "```kt\n    std::map<std::string, std::string> g_Translations;\n    …\n    g_Translations[\"Original phrase\"] = \"Translation\"\n    ```", "```kt\n    std::string g_LocaleName;\n    ```", "```kt\n    std::string LocalizeString( const std::string& Str ) const\n    {\n      auto i = g_Translations.find( Str );\n      return (i != g_Translations.end()) ? i->second : Str;\n    }\n    ```", "```kt\n    void LoadLocale()\n    {\n      g_Translations.clear();\n      const std::string FileName( g_LocalePath + \"/Localizer-\"+ g_LocaleName + \".txt\" );\n      if ( !g_FS->FileExists( FileName ) ) { return; }\n      auto Stream = g_FS->CreateReader( FileName );\n      while ( !Stream->Eof() )\n      {\n        std::string L = Stream->ReadLine();\n        size_t Pos = L.find( \"~\" );\n        if ( Pos == std::string::npos ) { continue; }g_Translations[ L.substr(0, Pos) ] = L.substr(Pos + 1);\n      }\n    }\n    ```", "```kt\n    const std::string g_LocalePath = \"Localizer\";\n    ```", "```kt\n  PrintString( LocalizeString( \"Some text\") );\n```", "```kt\nimport java.util.Locale;\n…\nprivate static void SetLocale()\n{\n```", "```kt\n  String Lang    = Locale.getDefault().getLanguage();\n  SetLocaleName( Lang );\n}\n```", "```kt\nJNIEXPORT void JNICALL\nJava_ com_packtpub_ndkcookbook_app14_App14Activity_SetLocaleName(\n  JNIEnv* env, jobject obj, jstring LocaleName )\n{\ng_LocaleName = ConvertJString( env, LocaleName );\n}\n```", "```kt\n  char Buf[9];\n  GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SISO639LANGNAME,Buf, sizeof(Buf) );\n  g_LocaleName = std::string( Buf );\n```"]