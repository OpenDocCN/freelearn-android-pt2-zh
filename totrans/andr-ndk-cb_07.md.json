["```kt\n    void naDemoJniGraphics(JNIEnv* pEnv, jclass clazz, jobject pBitmap) {\n      int lRet, i, j;\n      AndroidBitmapInfo lInfo;\n      void* lBitmap;\n      //1\\. retrieve information about the bitmap\n      if ((lRet = AndroidBitmap_getInfo(pEnv, pBitmap, &lInfo)) < 0) {\n        return;\n      }\n      if (lInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {\n        return;\n      }\n      //2\\. lock the pixel buffer and retrieve a pointer to it\n      if ((lRet = AndroidBitmap_lockPixels(pEnv, pBitmap, &lBitmap)) < 0) {\n        LOGE(1, \"AndroidBitmap_lockPixels() failed! error = %d\", lRet);\n      }\n      //3\\. manipulate the pixel buffer\n      unsigned char *pixelBuf = (unsigned char*)lBitmap;\n      for (i = 0; i < lInfo.height; ++i) {\n        for (j = 0; j < lInfo.width; ++j) {\n        unsigned char *pixelP = pixelBuf + i*lInfo.stride + j*4;\n        *pixelP = (unsigned char)0x00;\t//remove R component\n    //    *(pixelP+1) = (unsigned char)0x00;\t//remove G component\n    //    *(pixelP+2) = (unsigned char)0x00;\t//remove B component\n    //    LOGI(1, \"%d:%d:%d:%d\", *pixelP, *(pixelP+1), *(pixelP+2), *(pixelP+3));}\n      }\n      //4\\. unlock the bitmap\n      AndroidBitmap_unlockPixels(pEnv, pBitmap);\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := JNIGraphics\n    LOCAL_SRC_FILES := JNIGraphics.cpp\n    LOCAL_LDLIBS := -llog -ljnigraphics\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    LOCAL_LDLIBS += -ljnigraphics\n    ```", "```kt\n    int AndroidBitmap_getInfo(JNIEnv* env, jobject jbitmap, AndroidBitmapInfo* info);\n    ```", "```kt\n    typedef struct {\n    uint32_t    width;\n    \tuint32_t    height;\n    uint32_t    stride;\n    int32_t     format;\n    uint32_t    flags; \n    } AndroidBitmapInfo;\n    ```", "```kt\n    int AndroidBitmap_lockPixels(JNIEnv* env, jobject jbitmap, void** addrPtr);\n    ```", "```kt\n    int AndroidBitmap_unlockPixels(JNIEnv* env, jobject jbitmap);\n    ```", "```kt\n    void naDLDemo(JNIEnv* pEnv, jclass clazz) {\n      void *handle;\n      double (*sqrt)(double);\n      const char *error;\n      handle = dlopen(\"libm.so\", RTLD_LAZY);\n      if (!handle) {\n        LOGI(1, \"%s\\n\", dlerror());\n        return;\n      }\n      dlerror();    /* Clear any existing error */\n      *(void **) (&sqrt) = dlsym(handle, \"sqrt\");\n      if ((error = dlerror()) != NULL)  {\n        LOGI(1, \"%s\\n\", error);\n        return;\n      }\n      LOGI(1, \"%f\\n\", (*sqrt)(2.0));\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := DynamicLinker\n    LOCAL_SRC_FILES := DynamicLinker.cpp\n    LOCAL_LDLIBS := -llog -ldl\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time DynamicLinker:I *:S\n    ```", "```kt\nLOCAL_LDLIBS := -ldl\n```", "```kt\nvoid*        dlopen(const char*  filename, int flag);\nint          dlclose(void*  handle);\nconst char*  dlerror(void);\nvoid*        dlsym(void*  handle, const char*  symbol);\nint          dladdr(const void* addr, Dl_info *info);\n```", "```kt\ntypedef struct {\n   const char *dli_fname;  \n   void       *dli_fbase;  \n   const char *dli_sname;  \n   void       *dli_saddr;  \n} Dl_info;\n```", "```kt\n    void compressUtil(unsigned long originalDataLen) {\n      int rv;\n      int compressBufBound = compressBound(originalDataLen);\n      compressedBuf = (unsigned char*) malloc(sizeof(unsigned char)*compressBufBound);\n      unsigned long compressedDataLen = compressBufBound;\n      rv = compress2(compressedBuf, &compressedDataLen, dataBuf, originalDataLen, 6);\n      if (Z_OK != rv) {\n        LOGE(1, \"compression error\");\n        free(compressedBuf);\n        return;\n      }\n      unsigned long decompressedDataLen = S_BUF_SIZE;\n      rv = uncompress(decompressedBuf, &decompressedDataLen, compressedBuf, compressedDataLen);\n      if (Z_OK != rv) {\n        LOGE(1, \"decompression error\");\n        free(compressedBuf);\n        return;\n      }\n      if (0 == memcmp(dataBuf, decompressedBuf, originalDataLen)) {\n        LOGI(1, \"decompressed data same as original data\");\n      }   //free resource\n      free(compressedBuf);\n    }\n    ```", "```kt\n    void naCompressAndDecompress(JNIEnv* pEnv, jclass clazz) {\n      unsigned long originalDataLen = getOriginalDataLen();\n      LOGI(1, \"---------data with repeated bytes---------\")\n      generateOriginalData(originalDataLen);\n      compressUtil(originalDataLen);\n      LOGI(1, \"---------data with random bytes---------\")\n      generateOriginalDataRandom(originalDataLen);\n      compressUtil(originalDataLen);\n    }\n    ```", "```kt\n    int writeToFile() {\n      gzFile file;\n      file = gzopen(\"/sdcard/test.gz\", \"w6\");\n      if (NULL == file) {\n        LOGE(1, \"cannot open file to write\");\n        return 0;\n      }\n      const char* dataStr = \"hello, Android NDK!\";\n      int bytesWritten = gzwrite(file, dataStr, strlen(dataStr));\n      gzclose(file);\n      return bytesWritten;\n    }\n    ```", "```kt\n    void readFromFile(int pBytesToRead) {\n      gzFile file;\n      file = gzopen(\"/sdcard/test.gz\", \"r6\");\n      if (NULL == file) {\n        LOGE(1, \"cannot open file to read\");\n        return;\n      }\n      char readStr[100];\n      int bytesRead = gzread(file, readStr, pBytesToRead);\n      gzclose(file);\n      LOGI(1, \"%d: %s\", bytesRead, readStr);\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := ZlibDemo\n    LOCAL_SRC_FILES := ZlibDemo.cpp GzFileDemo.cpp\n    LOCAL_LDLIBS := -llog -lz\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time ZlibDemo:I *:S\n    ```", "```kt\n    uLong compressBound(uLong sourceLen);\n    ```", "```kt\n    int compress2(Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);\n    ```", "```kt\n    int uncompress(Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);\n    ```", "```kt\n    gzFile gzopen(const char *path, const char *mode);\n    ```", "```kt\n    int gzwrite(gzFile file, voidpc buf, unsigned len);\n    ```", "```kt\n    int ZEXPORT    gzclose(gzFile file);\n    ```", "```kt\n    int gzread(gzFile file, voidp buf, unsigned len);\n    ```", "```kt\nLOCAL_LDLIBS := -lz\n```", "```kt\n    jboolean createAudioRecorder() {\n       SLresult result;\n       SLDataLocator_IODevice loc_dev = {SL_DATALOCATOR_IODEVICE, SL_IODEVICE_AUDIOINPUT, SL_DEFAULTDEVICEID_AUDIOINPUT, NULL};\n       SLDataSource audioSrc = {&loc_dev, NULL};\n       SLDataLocator_AndroidSimpleBufferQueue loc_bq = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 1};\n       SLDataFormat_PCM format_pcm = {SL_DATAFORMAT_PCM, 1, SL_SAMPLINGRATE_16,\n           SL_PCMSAMPLEFORMAT_FIXED_16, SL_PCMSAMPLEFORMAT_FIXED_16,\n           SL_SPEAKER_FRONT_CENTER, SL_BYTEORDER_LITTLEENDIAN};\n       SLDataSink audioSnk = {&loc_bq, &format_pcm};\n       const SLInterfaceID id[1] = {SL_IID_ANDROIDSIMPLEBUFFERQUEUE};\n       const SLboolean req[1] = {SL_BOOLEAN_TRUE};\n       result = (*engineEngine)->CreateAudioRecorder(engineEngine, &recorderObject, &audioSrc,\n               &audioSnk, 1, id, req);\n         result = (*recorderObject)->Realize(recorderObject, SL_BOOLEAN_FALSE);\n       result = (*recorderObject)->GetInterface(recorderObject, SL_IID_RECORD, &recorderRecord);\n       result = (*recorderObject)->GetInterface(recorderObject, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &recorderBufferQueue);\n       result = (*recorderBufferQueue)->RegisterCallback(recorderBufferQueue, bqRecorderCallback, NULL);\n       return JNI_TRUE;\n    }\n    ```", "```kt\n    void startRecording() {\n       SLresult result;\n       recordF = fopen(\"/sdcard/test.pcm\", \"wb\");\n       result = (*recorderRecord)->SetRecordState(recorderRecord, SL_RECORDSTATE_STOPPED);\n       result = (*recorderBufferQueue)->Clear(recorderBufferQueue);\n       recordCnt = 0;\n       result = (*recorderBufferQueue)->Enqueue(recorderBufferQueue, recorderBuffer,\n               RECORDER_FRAMES * sizeof(short));\n       result = (*recorderRecord)->SetRecordState(recorderRecord, SL_RECORDSTATE_RECORDING);\n    }\n    ```", "```kt\n    void bqRecorderCallback(SLAndroidSimpleBufferQueueItf bq, void *context) {\n       int numOfRecords = fwrite(recorderBuffer, sizeof(short), RECORDER_FRAMES, recordF);\n       fflush(recordF);\n       recordCnt++;\n       SLresult result;\n       if (recordCnt*5 < RECORD_TIME) {\n        result = (*recorderBufferQueue)->Enqueue(recorderBufferQueue, recorderBuffer,\n            RECORDER_FRAMES * sizeof(short));\n       } else {\n        result = (*recorderRecord)->SetRecordState(recorderRecord, SL_RECORDSTATE_STOPPED);\n        if (SL_RESULT_SUCCESS == result) {\n          fclose(recordF);\n        }\n       }\n    }\n    ```", "```kt\n    void createBufferQueueAudioPlayer() {\n       SLresult result;\n       SLDataLocator_AndroidSimpleBufferQueue loc_bufq = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 1};\n       SLDataFormat_PCM format_pcm = {SL_DATAFORMAT_PCM, 1, SL_SAMPLINGRATE_16,\n           SL_PCMSAMPLEFORMAT_FIXED_16, SL_PCMSAMPLEFORMAT_FIXED_16,\n           SL_SPEAKER_FRONT_CENTER, SL_BYTEORDER_LITTLEENDIAN};\n       SLDataSource audioSrc = {&loc_bufq, &format_pcm};\n       SLDataLocator_OutputMix loc_outmix = {SL_DATALOCATOR_OUTPUTMIX, outputMixObject};\n       SLDataSink audioSnk = {&loc_outmix, NULL};\n       const SLInterfaceID ids[3] = {SL_IID_BUFFERQUEUE, SL_IID_EFFECTSEND, SL_IID_VOLUME};\n       const SLboolean req[3] = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE};\n       result = (*engineEngine)->CreateAudioPlayer(engineEngine, &bqPlayerObject, &audioSrc, &audioSnk, 3, ids, req);\n       result = (*bqPlayerObject)->Realize(bqPlayerObject, SL_BOOLEAN_FALSE);\n       result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_PLAY, &bqPlayerPlay);\n       result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_BUFFERQUEUE,\n               &bqPlayerBufferQueue);\n       result = (*bqPlayerBufferQueue)->RegisterCallback(bqPlayerBufferQueue, bqPlayerCallback, NULL);\n       result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_EFFECTSEND,\n               &bqPlayerEffectSend);\n       result = (*bqPlayerObject)->GetInterface(bqPlayerObject, SL_IID_VOLUME, &bqPlayerVolume);\n    }\n    ```", "```kt\n    jboolean startPlaying() {\n      SLresult result;\n      recordF = fopen(\"/sdcard/test.pcm\", \"rb\");\n      noMoreData = 0;\n      int numOfRecords = fread(recorderBuffer, sizeof(short), RECORDER_FRAMES, recordF);\n      if (RECORDER_FRAMES != numOfRecords) {\n        if (numOfRecords <= 0) {\n          return JNI_TRUE;\n        }\n        noMoreData = 1;\n      }   \n    result = (*bqPlayerBufferQueue)->Enqueue(bqPlayerBufferQueue, recorderBuffer, RECORDER_FRAMES * sizeof(short));\n      result = (*bqPlayerPlay)->SetPlayState(bqPlayerPlay, SL_PLAYSTATE_PLAYING);\n      return JNI_TRUE;\n    }\n    ```", "```kt\n    void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bq, void *context) {\n       if (!noMoreData) {\n            SLresult result;\n    int numOfRecords = fread(recorderBuffer, sizeof(short), RECORDER_FRAMES, recordF);\n      if (RECORDER_FRAMES != numOfRecords) {\n        if (numOfRecords <= 0) {\n          noMoreData = 1;\n          (*bqPlayerPlay)->SetPlayState(bqPlayerPlay, SL_PLAYSTATE_STOPPED);\n          fclose(recordF);\n          return;\n        }\n        noMoreData = 1;\n      } \n      result = (*bqPlayerBufferQueue)->Enqueue(bqPlayerBufferQueue, recorderBuffer,  RECORDER_FRAMES * sizeof(short));\n       } else {\n         (*bqPlayerPlay)->SetPlayState(bqPlayerPlay, SL_PLAYSTATE_STOPPED);\n         fclose(recordF);\n       }\n    }\n    ```", "```kt\n    void naCreateEngine(JNIEnv* env, jclass clazz) {\n       SLresult result;\n       result = slCreateEngine(&engineObject, 0, NULL, 0, NULL, NULL);\n       result = (*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE);\n       result = (*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineEngine);\n       const SLInterfaceID ids[1] = {SL_IID_ENVIRONMENTALREVERB};\n       const SLboolean req[1] = {SL_BOOLEAN_FALSE};\n       result = (*engineEngine)->CreateOutputMix(engineEngine, &outputMixObject, 1, ids, req);\n       result = (*outputMixObject)->Realize(outputMixObject, SL_BOOLEAN_FALSE);\n       result = (*outputMixObject)->GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB,\n               &outputMixEnvironmentalReverb);\n       if (SL_RESULT_SUCCESS == result) {\n            result = (*outputMixEnvironmentalReverb)->SetEnvironmentalReverbProperties(\n                   outputMixEnvironmentalReverb, &reverbSettings);\n       }\n    }\n    ```", "```kt\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\"/>\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"></uses-permission>\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := OpenSLESDemo\n    LOCAL_SRC_FILES := OpenSLESDemo.cpp record.c play.c\n    LOCAL_LDLIBS := -llog\n    LOCAL_LDLIBS    += -lOpenSLES\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time OpenSLESDemo:I *:S\n    ```", "```kt\nSLresult (*CreateAudioPlayer) (\nSLEngineItf self,\nSLObjectItf * pPlayer,\nSLDataSource *pAudioSrc,\nSLDataSink *pAudioSnk,\nSLuint32 numInterfaces,\nconst SLInterfaceID * pInterfaceIds,\nconst SLboolean * pInterfaceRequired\n);\n```", "```kt\nconst SLInterfaceID ids[3] = {SL_IID_BUFFERQUEUE, SL_IID_EFFECTSEND, SL_IID_VOLUME};\nconst SLboolean req[3] = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE,  SL_BOOLEAN_TRUE};\nresult = (*engineEngine)->CreateAudioPlayer(engineEngine, &bqPlayerObject, &audioSrc, &audioSnk, 3, ids, req);\n```", "```kt\n#include <SLES/OpenSLES.h>\n```", "```kt\n#include <SLES/OpenSLES_Android.h>\n```", "```kt\nLOCAL_LDLIBS += libOpenSLES\n```", "```kt\n    void naCreateEngine(JNIEnv* env, jclass clazz) {\n       XAresult res;\n       res = xaCreateEngine(&engineObject, 0, NULL, 0, NULL, NULL);\n       res = (*engineObject)->Realize(engineObject, XA_BOOLEAN_FALSE);\n       res = (*engineObject)->GetInterface(engineObject, XA_IID_ENGINE, &engineEngine);\n       res = (*engineEngine)->CreateOutputMix(engineEngine, &outputMixObject, 0, NULL, NULL);\n       res = (*outputMixObject)->Realize(outputMixObject, XA_BOOLEAN_FALSE);\n    }\n    ```", "```kt\n    jboolean naCreateStreamingMediaPlayer(JNIEnv* env, jclass clazz, jstring filename) {\n       XAresult res;\n       const char *utf8FileName = (*env)->GetStringUTFChars(env, filename, NULL);\n       file = fopen(utf8FileName, \"rb\");\n       XADataLocator_AndroidBufferQueue loc_abq = { XA_DATALOCATOR_ANDROIDBUFFERQUEUE, NB_BUFFERS };\n       XADataFormat_MIME format_mime = {XA_DATAFORMAT_MIME, XA_ANDROID_MIME_MP2TS, XA_CONTAINERTYPE_MPEG_TS };\n       XADataSource dataSrc = {&loc_abq, &format_mime};\n       XADataLocator_OutputMix loc_outmix = { XA_DATALOCATOR_OUTPUTMIX, outputMixObject };\n       XADataSink audioSnk = { &loc_outmix, NULL };\n       XADataLocator_NativeDisplay loc_nd = {XA_DATALOCATOR_NATIVEDISPLAY,       \n               (void*)theNativeWindow, NULL};\n       XADataSink imageVideoSink = {&loc_nd, NULL};\n       XAboolean required[NB_MAXAL_INTERFACES] = {XA_BOOLEAN_TRUE, XA_BOOLEAN_TRUE};\n       XAInterfaceID iidArray[NB_MAXAL_INTERFACES] = {XA_IID_PLAY, XA_IID_ANDROIDBUFFERQUEUESOURCE};\n       res = (*engineEngine)->CreateMediaPlayer(engineEngine, &playerObj, &dataSrc, NULL,   &audioSnk, &imageVideoSink, NULL, NULL, NB_MAXAL_INTERFACES, iidArray, required );\n       (*env)->ReleaseStringUTFChars(env, filename, utf8FileName);\n       res = (*playerObj)->Realize(playerObj, XA_BOOLEAN_FALSE);\n       res = (*playerObj)->GetInterface(playerObj, XA_IID_PLAY, &playerPlayItf);\n       res = (*playerObj)->GetInterface(playerObj, XA_IID_ANDROIDBUFFERQUEUESOURCE, &playerBQItf);\n       res = (*playerBQItf)->SetCallbackEventsMask(playerBQItf, XA_ANDROIDBUFFERQUEUEEVENT_PROCESSED);\n       res = (*playerBQItf)->RegisterCallback(playerBQItf, AndroidBufferQueueCallback, NULL);\n       if (!enqueueInitialBuffers(JNI_FALSE)) {\n           return JNI_FALSE;\n       }\n       res = (*playerPlayItf)->SetPlayState(playerPlayItf, XA_PLAYSTATE_PAUSED);\n       res = (*playerPlayItf)->SetPlayState(playerPlayItf, XA_PLAYSTATE_PLAYING);\n       return JNI_TRUE;\n    }\n    ```", "```kt\n    XAresult AndroidBufferQueueCallback(XAAndroidBufferQueueItf caller, void *pCallbackContext, void *pBufferContext,  void *pBufferData, XAuint32 dataSize,  XAuint32 dataUsed, const XAAndroidBufferItem *pItems, XAuint32 itemsLength) {\n       XAresult res;\n       int ok;\n       ok = pthread_mutex_lock(&mutex);\n       if (discontinuity) {\n           if (!reachedEof) {\n               res = (*playerBQItf)->Clear(playerBQItf);\n               rewind(file);\n                (void) enqueueInitialBuffers(JNI_TRUE);\n           }\n           discontinuity = JNI_FALSE;\n           ok = pthread_cond_signal(&cond);\n           goto exit;\n       }\n       if ((pBufferData == NULL) && (pBufferContext != NULL)) {\n           const int processedCommand = *(int *)pBufferContext;\n           if (kEosBufferCntxt == processedCommand) {\n               goto exit;\n           }\n       }\n       if (reachedEof) {\n           goto exit;\n       }\n       size_t nbRead;\n       size_t bytesRead;\n       bytesRead = fread(pBufferData, 1, BUFFER_SIZE, file);\n       if (bytesRead > 0) {\n           if ((bytesRead % MPEG2_TS_PACKET_SIZE) != 0) {\n               LOGI(2, \"Dropping last packet because it is not whole\");\n           }\n           size_t packetsRead = bytesRead / MPEG2_TS_PACKET_SIZE;\n           size_t bufferSize = packetsRead * MPEG2_TS_PACKET_SIZE;\n           res = (*caller)->Enqueue(caller, NULL, pBufferData, bufferSize, NULL, 0);\n       } else {\n           XAAndroidBufferItem msgEos[1];\n           msgEos[0].itemKey = XA_ANDROID_ITEMKEY_EOS;\n           msgEos[0].itemSize = 0;\n           res = (*caller)->Enqueue(caller, (void *)&kEosBufferCntxt, NULL, 0, msgEos, sizeof(XAuint32)*2);\n           reachedEof = JNI_TRUE;\n       }\n    exit:\n       ok = pthread_mutex_unlock(&mutex);\n       return XA_RESULT_SUCCESS;\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := OpenMAXSLDemo\n    LOCAL_SRC_FILES := OpenMAXSLDemo.c\n    LOCAL_LDLIBS := -llog\n    LOCAL_LDLIBS    += -landroid\n    LOCAL_LDLIBS    += -lOpenMAXAL\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb push NativeMedia.ts /sdcard/\n    ```", "```kt\n#include <OMXAL/OpenMAXAL.h>\n```", "```kt\n#include <OMXAL/OpenMAXAL_Android.h>\n```", "```kt\nLOCAL_LDLIBS += libOpenMAXAL\n```"]