- en: Chapter 13. Getting to Enforcing Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an engineer, you''re handed some Android device, and the requirement is
    to apply SE for Android controls to the device to enhance its security posture.
    So far, we have seen all the pieces that need to be configured and how they work
    to enable such a system. In this chapter, we''ll take all the skills covered to
    get our UDOO in enforcing mode. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Run, evaluate, and respond to audit logs from CTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop secure policy for the UDOO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch to enforcing mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating to SEPolicy master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many changes to the `sepolicy` directory have occurred in the AOSP `master`
    branch since the 4.3 release. At the time of this writing, the `master` branch
    of the `external/sepolicy` project was on Git commit SHA `b5ffb`. The authors
    recommend attempting to use the most recent commit. However, for illustrative
    purposes, we will show you how to optionally check out commit `b5ffb` so you can
    accurately follow the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you''ll need to clone the `external/sepolicy` project. In these instructions,
    we assume your working directory has the UDOO sources contained in the `./udoo`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to follow the examples in this chapter precisely, you''ll need
    to check out commit `b5ffb` with the following command. If you skip it, you will
    end up using the latest commit in the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll replace the UDOO 4.3 sepolicy with what we just acquired from Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can remove the `.git` folder from the newly copied sepolicy
    with the following command, but this is not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, copy the `audit.te` file and restore it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, restore the `auditd` commit from the NSA Bitbucket `seandroid`
    repository. For your reference, it's commit SHA `d270aa3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, remove all references to `setool` from `udoo/build/core/Makefile`.
    This command will help you locate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Purging the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, our UDOO is messy, so let''s reflash it, including the data
    directory, and start afresh. We want to have only the code and the `init` script
    changes, without the additional sepolicy. Then we can author a policy properly
    and apply all the techniques and tools we''ve encountered. We''ll start by resetting
    to a state analogous to the completion of [Chapter 4](ch04.html "Chapter 4. Installation
    on the UDOO"), *Installation on the UDOO*. However, the major difference is we
    need to build a `userdebug` version rather than an engineering (`eng`) version
    for CTS. The version is selected in the setup script, which ultimately calls `lunch`.
    To build this version, execute the following commands from the UDOO workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Flash the system, boot to the SD card, and wipe `userdata` with the following
    commands, assuming the SD card is inserted into the host and `userdata` is not
    mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Setting up CTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must pass CTS if your organization seeks Android branding. However, even
    if you don't, it's a good idea to run these tests to help ensure a device will
    be compliant with applications. Based on your security goals and desires, you
    may fail portions of CTS if you're not seeking Android branding. For our case,
    we're looking at CTS as a way to exercise the system and uncover policy issues
    that prevent the proper functioning of the UDOO. Its source is located in the
    `cts/` directory, but we recommend downloading the binary directly from Google.
    You can get more information and the CTS binary itself from [https://source.android.com/compatibility/cts-intro.html](https://source.android.com/compatibility/cts-intro.html)
    and [https://source.android.com/compatibility/android-cts-manual.pdf](https://source.android.com/compatibility/android-cts-manual.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Download the CTS 4.3 binary from the **Downloads** tab. Then select the CTS
    binary. The **Compatibility Definition Document** (**CDD**) is also worth reading.
    It covers the high-level details of CTS and compatibility requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download CTS from [https://source.android.com/compatibility/downloads.html](https://source.android.com/compatibility/downloads.html)
    and extract it. Select the CTS version that matches your Android version. If you
    don''t know which version your device is running, you can always check the `ro.build.version.release`
    property from the UDOO with `getprop ro.build.version.release`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running CTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CTS exercises many components on the device and helps test various parts
    of the system. A good, general policy should allow proper functioning of Android
    and pass CTS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the directions in the Android CTS user manual to set up your device
    (see *Section 3.3*, *Setting up your device*). Typically, you will see some failures
    if you don''t follow all the steps precisely, as you may not have the access or
    the capabilities to acquire all the resources needed. However, CTS will still
    exercise some code paths. At a minimum, we recommend getting the media files copied
    and Wi-Fi active. Once your device is set up, ensure `adb` is active and initiate
    the testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests take many hours to execute, so be patient; but you can check the
    status of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Plug in speakers to enjoy the sounds from the media tests and ringtones! Also,
    CTS reboots the device. If your ADB session is not restored after rebooting, ADB
    may not execute any tests. Use the `--disable-reboot` option when running the
    `cts-tf > run cts --plan CTS --disable-reboot` plan.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we'll consider the CTS results. Although we expect some failures, we
    also expect the problem will not get worse when we go to enforcing mode. Second,
    we'll look at the audit logs. Let's pull both of these files from the device.
  prefs: []
  type: TYPE_NORMAL
- en: CTS test results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CTS creates a test results directory each time it is run. CTS is indicating
    the directory name but not the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The location is mentioned by the CTS manual and can be found under the extracted
    CTS directory in `repository/results`, typically at `android-cts/repository/results`.
    The test directories contain an XML test report, `testResult.xml`. This can be
    opened in most web browsers. It has a nice overview of the tests and details of
    all executed tests. The `pass:fail` ratio is our baseline. The authors had 18,736
    pass, and only 53 fail, which is fairly good considering half of those are feature
    issues, such as no Bluetooth or returning true for camera support.
  prefs: []
  type: TYPE_NORMAL
- en: Audit logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the audit logs to address deficiencies in our policy. Pull these
    off the device using the standard `adb pull` commands we have used throughout
    the book. Since this is a `userdebug` build and default `adb` terminals are shell
    `uid` (not root), start `adb` as root with `adb root`. `su` is also available
    on `userdebug` builds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may get an error saying `/data/misc/audit/audit.log` does not exist. The
    solution is to run `adb` as root via the `adb root` command. Also, when running
    this command, it may hang. Just go to settings, disable, and then enable **USB
    Debugging** under **Developer Options**. Then kill the `adb-root` command and
    verify you have root by running `adb shell`. Now you should be a root user again.
  prefs: []
  type: TYPE_NORMAL
- en: Authoring device policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run both `audit.log` and `audit.old` through `audit2allow` to see what's going
    on. The output of `audit2allow` is grouped by source domain. Rather than going
    through it all, we will highlight the unusual cases, starting with the interpreted
    results of `audit2allow`. Assuming you are in the audit log directory, perform
    `cat audit.* | audit2allow | less`. Any policy work will be done in the device-specific
    UDOO sepolicy directory.
  prefs: []
  type: TYPE_NORMAL
- en: adbd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are our `adbd` denials as filtered through `audit2allow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The denials in the `adbd` domain are quite strange. The first thing that caught
    our eye was the `execute` on `/dev/ashmem`, which is a character driver. Typically,
    this is only needed for Dalvik JIT. Looking at the raw audits (`cat audit.* |
    grep adbd | grep execute`), we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Something with the process `comm` field of the compiler is executing on `ashmem`.
    Our guess is it has something to do with Dalvik, but why is it in the `adbd` domain?
    Also, why is `adbd` writing to the input device? All this is strange behavior.
    Typically, when you see things like this, it''s because the children didn''t end
    up in the proper domain. Run this command to check the domains and confirm our
    suspicions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run `adb shell ps -Z | grep adbd` to see which things were running
    in the `adb` domain, further confirming our suspicions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ps` command should not be running in the `adbd` context; it should be
    running in `shell`. This confirmed that `shell` is not in the right domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to check is the context on the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The base policy defines a domain transition when `adbd` loads the shell using
    `exec` to go to the shell domain. This is defined in the `adbd.te` external sepolicy
    as `domain_auto_trans(adbd, shell_exec, shell)`.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, an incorrect label has been applied to shell, so let's look at `file_contexts`
    in the external sepolicy to find out why.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The two dashes mean that only regular files will be labeled and symbolic links
    will be skipped. We probably don't want to label the symlink, but rather the `mksh`
    destination. Do this by adding a custom `file_contexts` entry to the device UDOO
    sepolicy and adding the file to the `BOARD_SEPOLICY_UNION` config. In `file_contexts`,
    add `/system/bin/mksh -- u:object_r:shell_exec:s0`, and in `sepolicy.mk`, add
    `BOARD_SEPOLICY_UNION += file_contexts`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout the remainder of the chapter, whenever you create or modify policy
    files (for example, context files or `*.te` files), don't forget to add them to
    `BOARD_SEPOLICY_UNION` in `sepolicy.mk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a fairly fatal issue with the policy and `adbd`, we won''t worry
    about the denials for now, with the exception of the unlabeled. Whenever one encounters
    an unlabeled file, it should be addressed. The `avc` denial that caused this is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is mounted at `/device` and Android mounts are typically at `/`,
    we should look at the mount table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Typically, mount commands are in the init scripts following a `mkdir`, or in
    an `fstab` file with the init built-in, `mount_all`. A quick search for `device`
    and `mkdir` in `init.rc` finds nothing, but we do find it in `fstab.freescale`.
    The device is read-only, so we should be able to give it a type, label it with
    file contexts, and apply the `getattr` domain to its directory class. Since it's
    read-only and empty, nobody should need more permissions. Looking at the `make_sd.sh`
    script, we notice that partition 7 of the block device is the `vender` directory.
    This is a misspelling of the common vendor directory that OEMs place proprietary
    blobs in. We place file types in `file.te` and the domain allow rules in `domain.te`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `file.te`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In `domain.te`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In `file_contexts`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If this directory is not empty, you must manually run `restorecon -R` on it
    to label existing files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pull the audit logs multiple times from the UDOO, you may also end up
    with denials showing that you did so, as `adbd` will not be able to access them.
    You may see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule comes from the end of the test when you `adb pull`ed the audit logs.
    We can safely `dontaudit` this and add a `neverallow` to ensure it doesn''t accidentally
    get allowed. The audit logs contain information a malware writer could use to
    navigate through the policy, and this information should be protected. In a device
    `sepolicy` folder, add an `adbd.te` file and union it in the `sepolicy.mk` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `adbd.te`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In `auditd.te`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If `auditd.te` is still in `external/sepolicy`, move it to `device/fsl/udoo/sepolicy`
    along with all dependent types.
  prefs: []
  type: TYPE_NORMAL
- en: The `neverallow` entries show you how to use the compliment, `~`, and set difference,
    `-`, operators for strong assertions or brevity. The first `neverallow` starts
    with domain, and all process types (domains) are members of the domain attribute.
    We prevent access through set difference, leaving the set that must never have
    access. We then compliment the access vector set to allow only `getattr` or `stat`
    on the logs. The second `neverallow` uses compliment to ensure `system_server`
    is limited to read operations.
  prefs: []
  type: TYPE_NORMAL
- en: bootanim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bootanim` domain is assigned to the boot animation service that presents
    splash screens on boot, typically the carrier''s branding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Anything touching the `init` domain is a red flag. Here, `bootanim` connects
    to an init Unix domain socket. This is a part of the property system, and we can
    see that after connecting, it writes to the property socket. The socket object
    and its URI are separate. In this case, it''s the filesystem, but it could be
    an anonymous socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `log_device` is deprecated in new versions of Android and replaced with
    `logd`. However, we are backporting a new master sepolicy to 4.3, so we must support
    this. The patch that removed support is at [https://android-review.googlesource.com/#/c/108147/](https://android-review.googlesource.com/#/c/108147/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than apply a reverse patch to the external sepolicy, we can just add
    the rules to our device policy in a `domain.te` file. We can safely allow these
    using the proper macros and styles in the device UDOO `sepolicy` folder. In `bootanim.te`,
    add `unix_socket_connect(bootanim, property, init)`, and in `domain.te`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: debuggerd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The log device denial was addressed under `bootanim` by adding the allow rules
    for all domains to use `log_device`. The `system_data_file:sock_file write` is
    strange. In most circumstances, you''ll almost never want to allow a cross-domain
    write, but this is special. Look at the raw denial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The denial is on `ndebugsocket`. Grepping for this uncovers a named type transition,
    which policy version 23 does not support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have to change the code to set the proper context or just allow it, which
    we will. We won't grant additional permissions because it never asked for open,
    and we're crossing domains. Preventing file opens across domains is ideal, as
    the only way to get this file descriptor is through an IPC call into the owning
    domain. In `debuggerd.te`, add `allow debuggerd system_data_file:sock_file write;`.
  prefs: []
  type: TYPE_NORMAL
- en: drmserver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is taken care of by `domain.te` rules, so we have nothing to do here.
  prefs: []
  type: TYPE_NORMAL
- en: dumpstate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The denial to `init:binder call` on `dumpstate` is strange because `init` doesn''t
    use binder. Some process must stay in the init domain. Let''s check our process
    listing for init:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `zygote` and `com.android.phone` should not be running as `init`. This
    must be a labeling error on the `app_process` file, which is the zygote. The `ls
    -laZ /system/bin/app_process` command reveals `u:object_r:system_file:s0 app_process`,
    so add an entry to `file_contexts` to correct this. We can find the label to use
    in `zygote.te` in the base sepolicy defined as the `zygote_exec` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In `file_contexts`, add `/system/bin/app_process u:object_r:zygote_exec:s0`.
  prefs: []
  type: TYPE_NORMAL
- en: installd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The added `domain.te` rules handle `installd`.
  prefs: []
  type: TYPE_NORMAL
- en: keystore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The log device is taken care of by the `domain.te` rules. Let''s look at the
    raw `app_data_file` denial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Categories are defined in the contexts. This means MLS support is activated
    for `app domains`. In the `seapp_contexts` base sepolicy, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: MLS separation of application data is still under development and didn't work
    on 4.3, so we can disable this. We can just declare them in a device-specific
    `seapp_contexts` file. In `seapp_contexts`, add `user=_app domain=untrusted_app
    type=app_data_file` and `user=_app seinfo=platform domain=platform_app type=app_data_file`.
    In 4.3, any changes to context on data require a factory reset. The 4.4 version
    added smart relabel capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: mediaserver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The log device was addressed in the `domain.te` rules. We'll skip `init` and
    `adbd` too, since their issues were triggered by improper process domains. It's
    important not to add allow rules blindly, as most of the work for existing domains
    can be handled with small label changes or a few rules.
  prefs: []
  type: TYPE_NORMAL
- en: netd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The log device denial of `netd` was addressed by `domain.te`. However, we should
    scrutinize anything requesting a capability. When granting capabilities, the policy
    author needs to be very careful. If a domain is granted the ability to load a
    system module and that domain or module binary itself is compromised, it could
    lead to the injection of malware into the kernel via loadable modules. However,
    `netd` needs loadable kernel module support to support some cards. Add the allow
    rule to a file called `netd.te` in the device UDOO sepolicy. In `netd.te`, add
    `allow netd self:capability sys_module;`.
  prefs: []
  type: TYPE_NORMAL
- en: rild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is taken care of by `domain.te` rules, so we have nothing to do here.
  prefs: []
  type: TYPE_NORMAL
- en: servicemanager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Again, the log device was handled in `domain.te`. We'll skip `init`, since its
    issues were triggered by improper process domains.
  prefs: []
  type: TYPE_NORMAL
- en: surfaceflinger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Again, the log device was handled in `domain.te`. We'll skip `init` too, since
    its issues were triggered by improper process domains.
  prefs: []
  type: TYPE_NORMAL
- en: system_server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `log_device` is taken care of by `domain.te`, and `init` and `adbd` are
    polluted, we will only address the Dalvik cache denial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The external sepolicy seandroid-4.3 branch allowed `domain.te:allow domain dalvikcache_data_file:file
    r_file_perms;`. Writes were allowed by `system_app` with `system_app.te:allow
    system_app dalvikcache_data_file:file { write setattr };`. We should be able to
    grant this write access because there may be a need to update its Dalvik cache
    file. In `domain.te`, add `allow domain dalvikcache_data_file:file r_file_perms;`,
    and in `system_server.te`, add `allow system_server dalvikcache_data_file:file
    { write setattr };`.
  prefs: []
  type: TYPE_NORMAL
- en: toolbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, one should not write to `sysfs`. Now look at the raw denial for
    the offending `sysfs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: From here, we properly label `/sys/module/usbtouchscreen/parameters/calibration`.
    We place an entry in `file_contexts` to label `sysfs`, declare a type in `file.te`,
    and allow `toolbox` access to it. In `file.te`, add `type sysfs_touchscreen_calibration,
    fs_type, sysfs_type, mlstrustedobject;`, and in `file_contexts`, add `/sys/module/usbtouchscreen/parameters/calibration
    -- u:object_r:sysfs_touchscreen_calibration:s0`, and in `toolbox.te`, add `allow
    toolbox sysfs_touchscreen_calibration:file w_file_perms;`.
  prefs: []
  type: TYPE_NORMAL
- en: untrusted_app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`untrusted_app` had many denials. Considering the domain labeling issues, we
    won''t address most of these now. However, you should look out for mislabeled
    and unlabeled target files. While searching the denial logs as interpreted by
    `audit2allow`, the following was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `chr_file` device, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we need to label `/dev/.coldboot_done`, `/dev/rfkill` properly,
    and `/dev/mxs_viim`. `/dev/rfkill` should be labeled in line with what the 4.3
    policy had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `/dev/mxs_viim` device seems to be a globally accessible GPU. We recommend
    a thorough review of the source code, but for now, we will label it as `gpu_device`.
    `/dev/.coldboot_done` is created by `ueventd` when the `coldboot` process completes.
    If `ueventd` is restarted, it skips the coldboot. We don't need to label this.
    This denial is caused by the source domain MLS on a target file that is not a
    subset of the categories of the source and does not have the `mlstrustedsubject`
    attribute; it should go away when we drop MLS support from apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `file_contexts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: vold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Again, the log device was handled in `domain.te`.
  prefs: []
  type: TYPE_NORMAL
- en: watchdogd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw denials from watchdog paint in interesting portrait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A file is created and unlinked by `watchdog`, which keeps a handle to an anonymous
    file. No filesystem reference exists after the unlink, but the file descriptor
    is valid and only `watchdog` can use it. In this case, we can just allow watchdog
    this rule. In `watchdogd.te`, add `allow watchdogd device:chr_file create_file_perms;`.
    This rule, however, causes a `neverallow` violation in the base policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `neverallow` rule is in the `domain.te` base policy as `neverallow { domain
    -init -ueventd -recovery } device:chr_file { open read write };`. For such a simple
    change, we'll just modify the base sepolicy to `neverallow { domain -init -ueventd
    -recovery -watchdogd } device:chr_file { open read write };`.
  prefs: []
  type: TYPE_NORMAL
- en: wpa
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the log device was handled in `domain.te`. The system data accesses
    need further investigation, starting with the raw denials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The offending file was located using `ls -laR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This socket is created by the `wpa_supplicant` itself. Relabeling it without
    type transitions is impossible, so we have to allow it. In `wpa.te`, add `allow
    wpa system_data_file:dir rw_dir_perms;` and `allow wpa system_data_file:sock_file
    create_file_perms;`. The unlabeled device has already been dealt with; it was
    on `rfkill`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Second policy pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After loading the drafted policy, the device still has denials on boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: All of these denials should be investigated because they target sensitive types,
    `tcontext` specifically.
  prefs: []
  type: TYPE_NORMAL
- en: init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The raw denials for `init` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'These occur before `init` remounts `/` as read-only. We can safely allow these,
    and since `init` is running unconfined, we can just add it to `init.te`. We could
    add the `allow` rule to the unconfined set, but since that is going away, let''s
    minimize the permission only to `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unconfined is not completely unconfined. Rules get stripped from this domain
    as AOSP moves closer to zero unconfined domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this, however, causes another `neverallow` to fail. We can modify `external/sepolicy
    domain.te` to bypass this. Change the `neverallow` from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to modify `neverallow` entries to build, you will fail CTS. The
    proper approach is to remove this behavior from `init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we need to see what is loaded with `exec` without a domain transition,
    causing the `execute_no_trans` denial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: To resolve this, we can relabel `magd` with its own type and place it in its
    own unconfined domain. A `neverallow` in the base policy forces us to move each
    executable into its own domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `magd.te`, add it to `BOARD_SEPOLICY_UNION`, and add the
    following contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Also update `file_contexts` to contain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the steps that were done for `magd` for `rfkill`. Just replace `magd`
    with `rfkill` in the preceding example. Later testing revealed an entry-point
    denial where the source context was `init_shell` and the target was `rfkill_exec`.
    After adding the shell rules, it was discovered that `rfkill` is loaded using
    `exec` from the `init_shell` domain, so let's also add `domain_auto_trans(init_shell,
    rfkill_exec, rfkill)` to the `rfkill.te` file. Additionally grouped with this
    discovery was `rfkill` attempting to open, read, and write `/dev/rfkill`. So we
    must label `/dev/rfkill` with `rfkill_device`, `allow rfkill` access to it, and
    append `allow rfkill rfkill_device:chr_file rw_file_perms;` to the `rfkill.te`
    file. Create a new file to declare this device type, called `device.te`, and add
    `type rfkill_device, dev_type;`. After that, label it with `file_contexts` by
    adding `/dev/rfkill u:object_r:rfkill_device:s0`.
  prefs: []
  type: TYPE_NORMAL
- en: shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first shell denial we will evaluate is the denial on `entrypoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Since we did not label `mksh`, we need to label it now. We can create an unconfined
    domain for shells spawned by `init` to end up in the `init_shell` domain. The
    console still ends up in the `shell` domain via an explicit `seclabel`, and other
    invocations end up as `init_shell`. Create a new file, `init_shell.te`, and add
    it to `BOARD_SEPOLICY_UNION`.
  prefs: []
  type: TYPE_NORMAL
- en: init_shell.te
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `file_contexts` to include this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will handle shell access to the raw device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a mislabeled `tty`, so we can label this as a `tty_device`. Add
    the following entry to the file contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Field trials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, rebuild the source tree, wipe the data filesystem, flash, and
    re-run CTS. Repeat this until all denials are addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're done with CTS and internal QA trials, we recommend performing a
    field trial with the device in permissive mode. During this period, you should
    be gathering the logs and refining policy. If the domains are not stable, you
    can declare them as permissive in the policy file and still put the device in
    enforcing mode; enforcing some domains is better than enforcing none.
  prefs: []
  type: TYPE_NORMAL
- en: Going enforcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can pass the enforcing mode either using `bootloader` (which will not be
    covered here) or with the `init.rc` script early in boot time. You can do this
    right after `setcon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this statement is compiled into the `init.rc` script, it can only be undone
    with a subsequent build and a reflash of `boot.img`. You can check this by running
    the `getenforce` command. Also, as an interesting test, you can try to run the
    `reboot` command from the root serial console and watch it fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, all of your previous understanding of the system was used to
    develop real SE for Android policy for a brand new device. You are now empowered
    with the knowledge of how to write SELinux policy for Android, where and how the
    components of the system work, and how to port and enable these features on various
    Android platforms. Since this is a fairly new feature that influences many system
    interactions, issues that will require code changes as well as policy changes
    will arise. Understanding both is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: As policy authors and security personnel in general, the responsibility to secure
    the system rests on our shoulders. In most organizations, you're required to work
    in the dark. However, if you can, do as much work and ask as many questions as
    you want to in the mailing list, and never accept the status quo. The SE for Android
    and AOSP projects welcome all to contribute, and by contributing, you will help
    make the project better and enhance the feature sets for all.
  prefs: []
  type: TYPE_NORMAL
