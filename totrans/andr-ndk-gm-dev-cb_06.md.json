["```kt\n    struct sLGLAPI\n    {\n      sLGLAPI() { memset( this, 0, sizeof( *this ) ); };\n    …Win32 defines skipped here…\n      PFNGLACTIVETEXTUREPROC       glActiveTexture;\n      PFNGLATTACHSHADERPROC        glAttachShader;\n      PFNGLBINDATTRIBLOCATIONPROC  glBindAttribLocation;\n    …\n    ```", "```kt\n    sLGLAPI* LGL3;\n    ```", "```kt\n    void OnDrawFrame()\n    {\n      LGL3->glClearColor( 1.0, 0.0, 0.0, 0.0 );\n      LGL3->glClear( GL_COLOR_BUFFER_BIT );\n    }\n    ```", "```kt\n    void Emulate_glClearDepth( double Depth )\n    {\n      glClearDepthf( static_cast<float>( Depth ) );\n    }\n    ```", "```kt\n    void Emulate_glPolygonMode( GLenum, GLenum )\n    {\n      // not supported\n    }\n    ```", "```kt\nvoid GetAPI( sLGLAPI* API ) const\n{\n  API->glActiveTexture = &glActiveTexture;\n  API->glAttachShader = &glAttachShader;\n  API->glBindAttribLocation = &glBindAttribLocation;\n…\n```", "```kt\n  API->glClearDepth = &Emulate_glClearDepth;\n  API->glBindFragDataLocation = &Emulate_glBindFragDataLocation;\n…\n```", "```kt\n#include <stdlib.h>\n#include \"LGL.h\"\nsLGLAPI* LGL3 = NULL;\nvoid OnDrawFrame()\n{\n  LGL3->glClearColor( 1.0, 0.0, 0.0, 0.0 );\n  LGL3->glClear( GL_COLOR_BUFFER_BIT );\n}\n```", "```kt\n>ndk-build\n>ant copy-common-media debug\n\n```", "```kt\nW/GLView  ( 3581): creating OpenGL ES 2.0 context\nI/App13   ( 3581): SurfaceSize: 1196 x 720\n```", "```kt\nHGLRC CreateContext( sLGLAPI* LGL3, HDC DeviceContext,int VersionMajor, int VersionMinor )\n{\n  HGLRC RenderContext = 0;\n```", "```kt\n  if ( LGL3->wglCreateContextAttribsARB )\n  {\n    const int Attribs[] =\n    {\n      WGL_CONTEXT_MAJOR_VERSION_ARB, VersionMajor,\n      WGL_CONTEXT_MINOR_VERSION_ARB, VersionMinor,\n      WGL_CONTEXT_LAYER_PLANE_ARB, 0,\n      WGL_CONTEXT_FLAGS_ARB,\n      WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,\n      WGL_CONTEXT_PROFILE_MASK_ARB,\n      WGL_CONTEXT_CORE_PROFILE_BIT_ARB,\n      0 // zero marks the end of values\n    };\n    RenderContext = LGL3->wglCreateContextAttribsARB(DeviceContext, 0, Attribs );\n  }\n  else\n  {\n```", "```kt\n        RenderContext = LGL3->lglCreateContext(DeviceContext );\n      }\n      return RenderContext;\n    }\n    ```", "```kt\n    HGLRC CreateContextFull( sLGLAPI* LGL3, HDC DeviceContext,int BitsPerPixel, int ZBufferBits, int StencilBits,int Multisample, int VersionMajor, int VersionMinor )\n    {\n      bool FormatSet = ChooseAndSetPixelFormat( LGL3,DeviceContext,BitsPerPixel, ZBufferBits, StencilBits, Multisample );\n      if ( !FormatSet ) return 0;\n      HGLRC RenderContext = CreateContext( LGL3,DeviceContext, VersionMajor, VersionMinor );\n      if ( !RenderContext ) return 0;\n      if ( !MakeCurrent( LGL3, DeviceContext, RenderContext ) )\n      { return 0; }\n      Reload( LGL3 );\n      return RenderContext;\n    }\n    ```", "```kt\n    bool ChooseAndSetPixelFormat( sLGLAPI* LGL3, HDCDeviceContext,int BitsPerPixel, int ZBufferBits, int StencilBits,int Multisample )\n    {\n      PIXELFORMATDESCRIPTOR PFD;\n      memset( &PFD, 0, sizeof( PFD ) );\n      PFD.nSize        = sizeof( PIXELFORMATDESCRIPTOR );\n      PFD.nVersion     = 1;\n      PFD.dwFlags = PFD_DRAW_TO_WINDOW |\n                    PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;\n      PFD.iPixelType = PFD_TYPE_RGBA;\n      PFD.cColorBits = static_cast<BYTE>(BitsPerPixel & 0xFF);\n      PFD.cDepthBits = static_cast<BYTE>(ZBufferBits & 0xFF);\n      PFD.cStencilBits = static_cast<BYTE>(StencilBits & 0xFF);\n      PFD.iLayerType = PFD_MAIN_PLANE;\n      GLint PixelFormat = 0;\n    ```", "```kt\n      if ( LGL3->wglChoosePixelFormatARB )\n      {\n        const int Attribs[] =\n        {\n          WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,WGL_SUPPORT_OPENGL_ARB, GL_TRUE,WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,WGL_DOUBLE_BUFFER_ARB , GL_TRUE,WGL_PIXEL_TYPE_ARB    , WGL_TYPE_RGBA_ARB,WGL_COLOR_BITS_ARB    , BitsPerPixel,WGL_DEPTH_BITS_ARB    , ZBufferBits,WGL_STENCIL_BITS_ARB  , StencilBits,WGL_SAMPLE_BUFFERS_ARB, GL_TRUE,WGL_SAMPLES_ARB       , Multisample,0 // zero marks the end of values\n        };\n        GLuint Count = 0;\n        LGL3->wglChoosePixelFormatARB( DeviceContext,Attribs, NULL, 1, &PixelFormat, &Count );\n        if ( !PixelFormat )\n        {\n          PixelFormat = ::ChoosePixelFormat(\n            DeviceContext, &PFD );\n        }\n        return ::SetPixelFormat( DeviceContext,PixelFormat, NULL );\n      }\n    ```", "```kt\n      if ( !PixelFormat )\n      {\n        PixelFormat = ::ChoosePixelFormat(DeviceContext, &PFD);\n      }\n      return ::SetPixelFormat( DeviceContext,\n        PixelFormat, &PFD );\n    }\n    ```", "```kt\nvoid LGL::clGLExtRetriever::Reload( sLGLAPI* LGL3 )\n{\n  if ( !FLibHandle ) FLibHandle =\n    (void*)::LoadLibrary( \"opengl32.dll\" );\n  LGL3->lglGetProcAddress = ( PFNwglGetProcAddress )\n    ::GetProcAddress( (HMODULE)FLibHandle, \"wglGetProcAddress\" );\n  LGL3->lglCreateContext = ( PFNwglCreateContext )\n    ::GetProcAddress( (HMODULE)FLibHandle, \"wglCreateContext\" );\n  LGL3->lglGetCurrentContext = ( PFNwglGetCurrentContext )\n    ::GetProcAddress( (HMODULE)FLibHandle,\"wglGetCurrentContext\");\n  LGL3->lglMakeCurrent = ( PFNwglMakeCurrent )\n    ::GetProcAddress( (HMODULE)FLibHandle, \"wglMakeCurrent\" );\n  LGL3->lglDeleteContext = ( PFNwglDeleteContext )\n    ::GetProcAddress( (HMODULE)FLibHandle, \"wglDeleteContext\" );\n  GetAPI( LGL3 );\n}\n```", "```kt\nvoid LGL::clGLExtRetriever::GetAPI( sLGLAPI* API ) const\n{\n  API->glActiveTexture = ( PFNGLACTIVETEXTUREPROC )GetGLProc( API, \"glActiveTexture\" );\n  API->glAttachShader = ( PFNGLATTACHSHADERPROC )GetGLProc( API, \"glAttachShader\" );\n…\n```", "```kt\n>make all\n\n```", "```kt\nUsing glCreateContext()\nUsing wglCreateContextAttribsARB()\nOpenGL version: 3.2.0\nOpenGL renderer: GeForce GTX 560/PCIe/SSE2\nOpenGL vendor: NVIDIA Corporation\n```", "```kt\n    public class GLView extends GLSurfaceView\n    {\n      …\n    ```", "```kt\n      private void init( int depth, int stencil )\n      {\n        this.getHolder().setFormat( PixelFormat.RGB_888 );\n        setEGLContextFactory( new ContextFactory() );\n        setEGLConfigChooser(new ConfigChooser( 8, 8, 8, 0, depth, stencil ) );\n        setRenderer( new Renderer() );\n      }\n    ```", "```kt\n      private static class ContextFactory implementsGLSurfaceView.EGLContextFactory\n      {\n        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;\n        public EGLContext createContext( EGL10 egl,EGLDisplay display, EGLConfig eglConfig )\n        {\n          int[] attrib_list = { EGL_CONTEXT_CLIENT_VERSION 2,EGL10.EGL_NONE };\n          EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT,attrib_list );\n          return context;\n        }\n        public void destroyContext( EGL10 egl,EGLDisplay display, EGLContext context )\n        {\n          egl.eglDestroyContext( display, context );\n        }\n      }\n    ```", "```kt\n      private static class ConfigChooser implementsGLSurfaceView.EGLConfigChooser\n      {\n        public ConfigChooser( int r, int g, int b, int a,int depth, int stencil )\n    …\n        private static int EGL_OPENGL_ES2_BIT = 4;\n    ```", "```kt\n        private static int[] s_configAttribs2 =\n        {\n          EGL10.EGL_RED_SIZE, 5,EGL10.EGL_GREEN_SIZE, 6,EGL10.EGL_BLUE_SIZE, 5,EGL10.EGL_ALPHA_SIZE, 0,EGL10.EGL_DEPTH_SIZE, 16,EGL10.EGL_STENCIL_SIZE, 0,EGL10.EGL_SAMPLE_BUFFERS, 0,EGL10.EGL_SAMPLES, 0,EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,EGL10.EGL_NONE, EGL10.EGL_NONE\n        };\n        public EGLConfig chooseConfig( EGL10 egl,EGLDisplay display )\n        {\n          int[] num_config = new int[1];\n          egl.eglChooseConfig( display, s_configAttribs2,null, 0, num_config );\n          int numConfigs = num_config[0];\n          …\n    ```", "```kt\n          EGLConfig[] configs = new EGLConfig[numConfigs];\n          egl.eglChooseConfig( display, s_configAttribs2,configs, numConfigs, num_config );\n    ```", "```kt\n          return chooseConfig( egl, display, configs );\n        }\n\n        public EGLConfig chooseConfig( EGL10 egl,EGLDisplay display, EGLConfig[] configs )\n        {\n          for ( EGLConfig config : configs )\n          {\n    ```", "```kt\n            int d = findConfigAttrib( egl, display,config, EGL10.EGL_DEPTH_SIZE,   0 );\n            int s = findConfigAttrib( egl, display,config, EGL10.EGL_STENCIL_SIZE, 0 );\n    ```", "```kt\n            if ( d < mDepthSize || s < mStencilSize )\n            {\n              continue;\n            }\n    ```", "```kt\n            int r = findConfigAttrib( egl, display,config, EGL10.EGL_RED_SIZE,   0 );\n            int g = findConfigAttrib( egl, display,config, EGL10.EGL_GREEN_SIZE, 0 );\n            int b = findConfigAttrib( egl, display,config, EGL10.EGL_BLUE_SIZE,  0 );\n            int a = findConfigAttrib( egl, display,config, EGL10.EGL_ALPHA_SIZE, 0 );\n            if ( r == mRedSize && g == mGreenSize &&b == mBlueSize && a == mAlphaSize )\n            {\n              return config;\n            }\n          }\n          return null;\n        }\n    ```", "```kt\n        private int findConfigAttrib( EGL10 egl,EGLDisplay display, EGLConfig config,int attribute, int defaultValue )\n        {\n          if ( egl.eglGetConfigAttrib( display,config, attribute, mValue ) )\n          {\n            return mValue[0];\n          }\n          return defaultValue;\n        }\n    …\n      }\n    ```", "```kt\n      private static class Rendererimplements GLSurfaceView.Renderer\n      {\n        public void onDrawFrame( GL10 gl )\n        {\n          App13Activity.DrawFrame();\n        }\n        public void onSurfaceChanged( GL10 gl,int width, int height )\n        {\n          App13Activity.SetSurfaceSize( width, height );\n        }\n        public void onSurfaceCreated( GL10 gl,EGLConfig config )\n        {\n         App13Activity.SetSurface(App13Activity.m_View.getHolder().getSurface() );\n        }\n      }\n    }\n    ```", "```kt\npublic static native void SetSurface( Surface surface );\npublic static native void SetSurfaceSize(\n int width, int height );\npublic static native void DrawFrame();\n```", "```kt\nJNIEXPORT void JNICALL\nJava_com_packtpub_ndkcookbook_app13_App13Activity_SetSurface(\nJNIEnv* env, jclass clazz, jobject javaSurface )\n{\n  if ( LGL3 ) { delete( LGL3 ); }\n```", "```kt\n  LGL3 = new sLGLAPI;\n  LGL::clGLExtRetriever* OpenGL;\n  OpenGL = new LGL::clGLExtRetriever;\n  OpenGL->Reload( LGL3 );\n  delete( OpenGL );\n}\nJNIEXPORT void JNICALLJava_com_packtpub_ndkcookbook_app13_App13Activity_SetSurfaceSize(JNIEnv* env, jclass clazz, int Width, int Height )\n{\n```", "```kt\n  g_Width  = Width;\n  g_Height = Height;\n}\nJNIEXPORT void JNICALLJava_com_packtpub_ndkcookbook_app13_App13Activity_DrawFrame(JNIEnv* env, jobject obj )\n{\n```", "```kt\n  OnDrawFrame();\n}\n```", "```kt\n<uses-feature android:glEsVersion=\"0x00020000\"/>\n```", "```kt\nLOCAL_LDLIBS += -lGLESv2\n```", "```kt\n    // vertex shader\n    #version 150 core\n    uniform mat4 in_ModelViewProjectionMatrix;\n    in vec4 in_Vertex;\n    in vec2 in_TexCoord;\n    out vec2 Coords;\n    void main()\n    {\n      Coords = in_TexCoord;\n      gl_Position = in_ModelViewProjectionMatrix * in_Vertex;\n    }\n\n    // fragment shader\n    #version 150 core\n    in vec2 Coords;\n    uniform sampler2D Texture0;\n    out vec4 out_FragColor;\n    void main()\n    {\n      out_FragColor = texture( Sampler0, Coords );\n    }\n    ```", "```kt\n    // vertex shader\n    #version 100\n    precision highp float;\n    uniform mat4 in_ModelViewProjectionMatrix;\n    attribute vec4 in_Vertex;\n    attribute vec2 in_TexCoord;\n    varying vec2 Coords;\n    void main()\n    {\n      Coords = in_TexCoord;\n      gl_Position = in_ModelViewProjectionMatrix * in_Vertex;\n    }\n\n    // fragment shader\n    #version 100\n    precision highp float;\n    uniform sampler2D Texture0;\n    varying vec2 Coords;\n    void main()\n    {\n      gl_FragColor = texture2D( Texture0, Coords );\n    }\n    ```", "```kt\n    #if defined( USE_OPENGL_3 )\n    std::string ShaderStr = \"#version 150 core\\n\";\n    #else\n    std::string ShaderStr = \"#version 100\\n\";\n    ShaderStr += \"precision highp float;\\n\";\n    ShaderStr += \"#define USE_OPENGL_ES_2\\n\";\n    ShaderCodeUsed = Str_ReplaceAllSubStr( ShaderCodeUsed,\n      \"texture(\", \"texture2D(\" );\n    if ( Target == GL_VERTEX_SHADER )\n    {\n        ShaderCodeUsed = Str_ReplaceAllSubStr( ShaderCodeUsed,\"in \", \"attribute \" );\n        ShaderCodeUsed = Str_ReplaceAllSubStr( ShaderCodeUsed,\"out \", \"varying \" );\n    }\n    if ( Target == GL_FRAGMENT_SHADER )\n    {\n        ShaderCodeUsed = Str_ReplaceAllSubStr( ShaderCodeUsed,\"out vec4 out_FragColor;\", \"\" );\n        ShaderCodeUsed = Str_ReplaceAllSubStr( ShaderCodeUsed,\"out_FragColor\", \"gl_FragColor\" );\n        ShaderCodeUsed = Str_ReplaceAllSubStr( ShaderCodeUsed,\"in \", \"varying \" );\n    }\n    #endif\n    ```", "```kt\nGLuint Shader = LGL3->glCreateShader( Target );\nconst char* Code = ShaderStr.c_str();\nLGL3->glShaderSource( Shader, 1, &Code, NULL );\nLOGI( \"Compiling shader for stage: %X\\n\", Target );\nLGL3->glCompileShader( Shader );\n```", "```kt\nif ( !CheckStatus( Shader, GL_COMPILE_STATUS,\"Failed to compile shader:\" ) )\n{\n  LGL3->glDeleteShader( Shader );\n  return OldShaderID;\n}\nif ( OldShaderID ) LGL3->glDeleteShader( OldShaderID );\nreturn Shader;\n```", "```kt\nbool clGLSLShaderProgram::RelinkShaderProgram()\n{\n  GLuint ProgramID = LGL3->glCreateProgram();\n  FVertexShaderID = AttachShaderID( GL_VERTEX_SHADER,FVertexShader, FVertexShaderID );\n  if ( FVertexShaderID ) LGL3->glAttachShader( ProgramID,FVertexShaderID );\n  FFragmentShaderID = AttachShaderID( GL_FRAGMENT_SHADER,FFragmentShader, FFragmentShaderID );\n  if ( FFragmentShaderID ) LGL3->glAttachShader( ProgramID,FFragmentShaderID );\n  BindDefaultLocations( ProgramID );\n  LGL3->glLinkProgram( ProgramID );\n```", "```kt\n  if ( !CheckStatus( ProgramID, GL_LINK_STATUS,\"Failed to link program\\n\" ) )\n  {\n    LOGI( \"Error during shader program relinking\\n\" );\n    return false;\n  }\n  LGL3->glDeleteProgram( FProgramID );\n  FProgramID = ProgramID;\n  RebindAllUniforms();\n  return true;\n}\n```", "```kt\nvoid clGLSLShaderProgram::BindDefaultLocations( GLuint ID )\n{\n```", "```kt\nLGL3->glBindAttribLocation( ID, L_VS_VERTEX, \"in_Vertex\" );\nLGL3->glBindAttribLocation( ID, L_VS_TEXCOORD,\"in_TexCoord\" );\nLGL3->glBindAttribLocation( ID, L_VS_NORMAL, \"in_Normal\" );\nLGL3->glBindAttribLocation( ID, L_VS_COLORS,  \"in_Color\" ); \nLGL3->glBindFragDataLocation( ID, 0, \"out_FragColor\" );\nLGL3->glUniform1i(LGL3->glGetUniformLocation( ID, \"Texture0\" ), 0 );\n}\n```", "```kt\nvoid clGLSLShaderProgram::RebindAllUniforms()\n{\n  Bind();\n  FUniforms.clear();\n  GLint ActiveUniforms;\n  char Buff[256];\n  LGL3->glGetProgramiv( FProgramID,GL_ACTIVE_UNIFORMS, &ActiveUniforms );\n  for ( int i = 0; i != ActiveUniforms; ++i )\n  {\n    GLsizei Length;\n    GLint   Size;\n    GLenum  Type;\n    LGL3->glGetActiveUniform( FProgramID, i,sizeof( Buff ), &Length, &Size, &Type, Buff );\n    std::string Name( Buff, Length );\n    sUniform Uniform( Name );\n    Uniform.FLocation = LGL3->glGetUniformLocation(FProgramID, Name.c_str() );\n    FUniforms.push_back( Uniform );\n  }\n}\n```", "```kt\nstruct sUniform\n{\npublic:\n  explicit sUniform( const std::string& Name )\n  : FName( Name ), FLocation( -1 ) {}\n  sUniform( int Location, const std::string& Name )\n  : FName( Name ), FLocation( Location ) {}\n  std::string FName;\n  int         FLocation;\n};\n```", "```kt\nconst int L_VS_VERTEX   = 0;\nconst int L_VS_TEXCOORD = 1;\nconst int L_VS_NORMAL   = 2;\nconst int L_VS_COLORS   = 3; \nconst int L_VS_TOTAL_ATTRIBS = L_VS_COLORS + 1;\n```", "```kt\n    const int VEC_COMPONENTS[ L_VS_TOTAL_ATTRIBS ] = { 3, 2, 3, 4 };\n    ```", "```kt\n    class clVertexAttribs: public iObject\n    {\n    public:\n      clVertexAttribs();\n      clVertexAttribs( size_t Vertices );\n      void   SetActiveVertexCount( size_t Count ){ FActiveVertexCount = Count; }\n      size_t GetActiveVertexCount() const{ return FActiveVertexCount; }\n    ```", "```kt\n      const std::vector<const void*>& EnumerateVertexStreams();\n    ```", "```kt\n      void Restart( size_t ReserveVertices );\n      void EmitVertexV( const LVector3& Vec );\n      void EmitVertex( float X, float Y, float Z ){ EmitVertexV( LVector3(X,Y,Z) ); };\n      void SetTexCoord( float U, float V, float W ){ SetTexCoordV( LVector2(U,V) ); };\n      void SetTexCoordV( const LVector2& V );\n      void SetNormalV( const LVector3& Vec );\n      void SetColorV( const LVector4& Vec );\n    ```", "```kt\n    public:\n      // position X, Y, Z\n      std::vector<LVector3> FVertices;\n      // texture coordinate U, V\n      std::vector<LVector2> FTexCoords;\n      // normal in object space\n      std::vector<LVector3> FNormals;\n      // RGBA color\n      std::vector<LVector4> FColors;\n    …\n    };\n    ```", "```kt\nclPtr<clVertexAttribs> CreateTriangle2D( float vX, float vY,float dX, float dY, float Z );\nclPtr<clVertexAttribs> CreateRect2D( float X1, float Y1, float X2,float Y2, float Z, bool FlipTexCoordsVertical,int Subdivide );\nclPtr<clVertexAttribs> CreateAxisAlignedBox( const LVector3& Min,const LVector3& Max );\nclPtr<clVertexAttribs> CreatePlane( float SizeX, float SizeY,int SegmentsX, int SegmentsY, float Z );\n```", "```kt\nclPtr<clVertexAttribs> clGeomServ::CreateTriangle2D( float vX,\n float vY, float dX, float dY, float Z )\n{\n clPtr<clVertexAttribs> VA = new clVertexAttribs();\n```", "```kt\n VA->Restart( 3 );\n VA->SetNormalV( LVector3( 0, 0, 1 ) );\n VA->SetTexCoord( 1, 1, 0 );\n VA->EmitVertexV( LVector3( vX   , vY   , Z ) );\n VA->SetTexCoord( 1, 0, 0 );\n VA->EmitVertexV( LVector3( vX   , vY - dY, Z ) );\n VA->SetTexCoord( 0, 1, 0 );\n VA->EmitVertexV( LVector3( vX + dX, vY   , Z ) );\n return VA;\n}\n```", "```kt\n    class clGLVertexArray: public iObject\n    {\n    public:\n      clGLVertexArray();\n      virtual ~clGLVertexArray();\n      void Draw( bool Wireframe ) const;\n      void SetVertexAttribs(const clPtr<clVertexAttribs>&Attribs);\n    private:\n      void Bind() const;\n      GLuint FVBOID;\n      GLuint FVAOID;\n    ```", "```kt\n      std::vector<const void*> FAttribVBOOffset;\n    ```", "```kt\n      std::vector<const void*> FEnumeratedStreams;\n      clPtr<clVertexAttribs> FAttribs;\n    };\n    ```", "```kt\n    void clGLVertexArray::SetVertexAttribs( constclPtr<clVertexAttribs>& Attribs )\n    {\n      FAttribs = Attribs;\n      FEnumeratedStreams = FAttribs->EnumerateVertexStreams();\n    ```", "```kt\n      LGL3->glDeleteBuffers( 1, &FVBOID );\n      size_t VertexCount = FAttribs->FVertices.size();\n      size_t DataSize = 0;\n      for ( int i = 0; i != L_VS_TOTAL_ATTRIBS; i++ )\n      {\n        FAttribVBOOffset[ i ] = ( void* )DataSize;\n    ```", "```kt\n        DataSize += FEnumeratedStreams[i] ?sizeof( float ) * L_VS_VEC_COMPONENTS[ i ] *\n          VertexCount : 0;\n      }\n      LGL3->glGenBuffers( 1, &FVBOID );\n      LGL3->glBindBuffer( GL_ARRAY_BUFFER, FVBOID );\n      LGL3->glBufferData( GL_ARRAY_BUFFER, DataSize,NULL, GL_STREAM_DRAW );\n    ```", "```kt\n      for ( int i = 0; i != L_VS_TOTAL_ATTRIBS; i++ )\n      {\n        LGL3->glBufferSubData( GL_ARRAY_BUFFER,(GLintptrARB)FAttribVBOOffset[ i ],FAttribs->GetActiveVertexCount() *sizeof( float ) * L_VS_VEC_COMPONENTS[ i ],FEnumeratedStreams[ i ] );\n      }\n    ```", "```kt\n    #if !defined( ANDROID )\n      LGL3->glBindVertexArray( FVAOID );\n      Bind();\n      LGL3->glBindVertexArray( 0 );\n    #endif\n    }\n    ```", "```kt\nvoid clGLVertexArray::Bind() const\n{\n  LGL3->glBindBuffer( GL_ARRAY_BUFFER, FVBOID );\n  LGL3->glVertexAttribPointer( L_VS_VERTEX,L_VS_VEC_COMPONENTS[ 0 ], GL_FLOAT, GL_FALSE, 0,FAttribVBOOffset[ 0 ] );\n  LGL3->glEnableVertexAttribArray( L_VS_VERTEX );\n\n  for ( int i = 1; i < L_VS_TOTAL_ATTRIBS; i++ )\n  {\n    LGL3->glVertexAttribPointer( i,L_VS_VEC_COMPONENTS[ i ],GL_FLOAT, GL_FALSE, 0,FAttribVBOOffset[ i ] );\n\n    FAttribVBOOffset[ i ] ?LGL3->glEnableVertexAttribArray( i ) :LGL3->glDisableVertexAttribArray( i );\n  }\n}\n```", "```kt\nvoid clGLVertexArray::Draw( bool Wireframe ) const\n{\n#if !defined( ANDROID )\n  LGL3->glBindVertexArray( FVAOID );\n#else\n  Bind();\n#endif\n  LGL3->glDrawArrays( Wireframe ? GL_LINE_LOOP : GL_TRIANGLES,0, static_cast<GLsizei>(FAttribs->GetActiveVertexCount() ) );\n}\n```", "```kt\n    class clGLTexture\n    {\n    public:\n      clGLTexture();\n      virtual ~clGLTexture();\n      void    Bind( int TextureUnit ) const;\n      void    LoadFromBitmap( const clPtr<clBitmap>& B );\n    private:\n      GLuint         FTexID;\n      GLenum         FInternalFormat;\n      GLenum         FFormat;\n    }\n    ```", "```kt\n    void clGLTexture::Bind( int TextureUnit ) const\n    {\t\n      LGL3->glActiveTexture( GL_TEXTURE0 + TextureUnit );\n      LGL3->glBindTexture( GL_TEXTURE_2D, FTexID );\n    }\n    ```", "```kt\n    void clGLTexture::LoadFromBitmap( const clPtr<clBitmap>& B )\n    {\n      if ( !FTexID ) LGL3->glGenTextures( 1, &FTexID );\n      ChooseInternalFormat( B->FBitmapParams, &FFormat,&FInternalFormat );\n      Bind( 0 );\n      LGL3->glTexParameteri( GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n      LGL3->glTexParameteri( GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n    ```", "```kt\n    #if defined( ANDROID )\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE );\n      LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE );\n    #else\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,GL_CLAMP_TO_BORDER );\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,GL_CLAMP_TO_BORDER );\n    #endif\n      LGL3->glTexImage2D( GL_TEXTURE_2D, 0, FInternalFormat,B->GetWidth(), B->GetHeight(), 0, FFormat,GL_UNSIGNED_BYTE, B->FBitmapData );\n    }\n    ```", "```kt\n    bool ChooseInternalFormat( const sBitmapParams& BMPRec,\n    GLenum* Format, GLenum* InternalFormat )\n    {\n      if ( BMPRec.FBitmapFormat == L_BITMAP_BGR8 )\n      {\n    #if defined( ANDROID )\n        *InternalFormat = GL_RGB;\n        *Format = GL_RGB;\n    #else\n        *InternalFormat = GL_RGB8;\n        *Format = GL_BGR;\n    #endif\n      }\n    ```", "```kt\n      if ( BMPRec.FBitmapFormat == L_BITMAP_BGRA8 )\n      {\n    #if defined( ANDROID )\n        *InternalFormat = GL_RGBA;\n        *Format = GL_RGBA;\n    #else\n        *InternalFormat = GL_RGBA8;\n        *Format = GL_BGRA;\n    #endif\n      }\n      return false;\n    }\n    ```", "```kt\n  clPtr<clBitmap> Bmp = clBitmap::LoadImg(g_FS->CreateReader(\"test.bmp\") );\n  Texture = new clGLTexture();\n  Texture->LoadFromBitmap( Bmp );\n```", "```kt\n    class clCanvas\n    {\n    public:\n      clCanvas();\n      virtual ~clCanvas() {};\n      void Rect2D( float X1, float Y1,float X2, float Y2, const LVector4& Color );\n      void TexturedRect2D( float X1, float Y1,float X2, float Y2,const LVector4& Color,const clPtr<clGLTexture>& Texture );\n      clPtr<clGLVertexArray> GetFullscreenRect() const\n      { return FRectVA; }\n    ```", "```kt\n    private:\n      clPtr<clVertexAttribs> FRect;\n      clPtr<clGLVertexArray> FRectVA;\n      clPtr<clGLSLShaderProgram> FRectSP;\n      clPtr<clGLSLShaderProgram> FTexRectSP;\n    };\n    ```", "```kt\n    clCanvas::clCanvas()\n    {\n      FRect = clGeomServ::CreateRect2D( 0.0f, 0.0f,1.0f, 1.0f, 0.0f, false, 1 );\n      FRectVA = new clGLVertexArray();\n      FRectVA->SetVertexAttribs( FRect );\n      FRectSP = new clGLSLShaderProgram( RectvShaderStr,RectfShaderStr );\n      FTexRectSP = new clGLSLShaderProgram( RectvShaderStr,\n        TexRectfShaderStr );\n    }\n    ```", "```kt\n       uniform vec4 u_RectSize;\n       in vec4 in_Vertex;\n       in vec2 in_TexCoord;\n       out vec2 Coords;\n       void main()\n       {\n          Coords = in_TexCoord;\n          float X1 = u_RectSize.x;\n          float Y1 = u_RectSize.y;\n          float X2 = u_RectSize.z;\n          float Y2 = u_RectSize.w;\n          float Width  = X2 - X1;\n          float Height = Y2 - Y1;\n          vec4 VertexPos = vec4( X1 + in_Vertex.x * Width,Y1 + in_Vertex.y * Height,in_Vertex.z, in_Vertex.w ) *vec4( 2.0, -2.0, 1.0, 1.0 ) +vec4( -1.0, 1.0, 0.0, 0.0 );\n          gl_Position = VertexPos;\n       }\n    ```", "```kt\n    uniform vec4 u_Color;\n    out vec4 out_FragColor;\n    in vec2 Coords;\n    void main()\n    {\n      out_FragColor = u_Color;\n    }\n    ```", "```kt\n    uniform vec4 u_Color;\n    out vec4 out_FragColor;\n    in vec2 Coords;\n    uniform sampler2D Texture0;\n    void main()\n    {\n      out_FragColor = u_Color * texture( Texture0, Coords );\n    }\n    ```", "```kt\n    void clCanvas::TexturedRect2D(\n     float X1, float Y1,\n     float X2, float Y2,\n     const LVector4& Color,\n     const clPtr<clGLTexture>& Texture )\n    {\n      LGL3->glDisable( GL_DEPTH_TEST );\n      Texture->Bind(0);\n      FTexRectSP->Bind();\n      FTexRectSP->SetUniformNameVec4Array(\n        \"u_Color\", 1, Color );\n      FTexRectSP->SetUniformNameVec4Array(\n        \"u_RectSize\", 1, LVector4( X1, Y1, X2, Y2 ) );\n      LGL3->glBlendFunc(\n        GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );\n      LGL3->glEnable( GL_BLEND );\n      FRectVA->Draw( false );\n      LGL3->glDisable( GL_BLEND );\n    }\n    ```", "```kt\nCanvas->Rect2D( 0.1f, 0.1f, 0.5f, 0.5f, vec4( 1, 0, 1, 0.5f ) );\n```"]