- en: Chapter 7. Intent Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intent filters are the advanced step to understand the minor significant details
    of Android Intents. In this chapter, we will take a look at the basics of intent
    filters and how they can be used effectively in an Android application. The chapter
    also deals with various kinds of tests that an intent should pass before it is
    delivered to the desired component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intent filters can be found inside the `AndroidManifest.xml` file, under the
    `activity` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Intent object and its categorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what intent filters are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what intent tests are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an intent filter for a particular task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intent object and its categorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intent objects come with a whole lot of information. This bundle of information
    will help the component to extract knowledge from it. For example, what kind of
    action should be taken on the data that is coming with the intent object; similarly,
    there is the information that is about the Android system. This information about
    the Android system is required when the system doesn't know the component that
    will handle the upcoming intent.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a better understanding about the example mentioned in the preceding
    paragraph, consider a scenario in which the intent is transferred in order to
    start a movie. In this case, the operating system must know which software is
    needed to perform this action.
  prefs: []
  type: TYPE_NORMAL
- en: The categories contained in the Android intent object are discussed in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Component name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The intent object contains information about the component name which will be
    handling the data. Mostly, this component consists of the full class name. For
    example, `com.app.demoactivity.MyActivity` or `com.example.demoactivity.MainActivity`.
    This information about the component is optional for the intent object. If it
    is known to the intent object, Android will divert the data handling towards that
    particular component; if it is unknown, Android will identify what the best component
    is to handle this event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The package part of the component name isn't necessarily the same as the project
    name in the `AndroidManifest.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The component name is set by `setComponent()` or `setClassName()` methods that
    are provided by the Android APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Intent resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android intents are categorized into two parts (as described in [Chapter 3](ch03.html
    "Chapter 3. Intent and Its Categorization"), *Intent and Its Categorization* ),
    **implicit intents** and **explicit intents**. For explicit intents, not assigning
    a component name to it does not cause any problems as the component has to be
    included in the intent object, and then Android will automatically direct the
    explicit intent towards the described component.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in implicit intents, if the component name is not given to
    the Android system, it will direct it automatically towards all the possible applications
    that can handle this incoming intent. This action will only take place if the
    intent has an intent filter, otherwise Android will not direct it. This term is
    called **Android intent resolution**; it is when you need not define the component
    for implicit intent, and it will automatically show a list of all the possible
    applications that can receive this intent.
  prefs: []
  type: TYPE_NORMAL
- en: Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Action is a string that describes the action to to be taken on an intent. For
    example, `ACTION_CALL`, `ACTION_BATTERY_LOW`, and `ACTION_SCREEN_ON`. You can
    find various other constants for actions at [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html).
    You can also make your own intent actions, but make sure to add the project name
    before it, for example, `com.example.myproject.SHOW_CONTACT`. The custom action
    is required when the developer wants to make an event that has not been previously
    added to Android SDK. This requirement can also occur when the developer wants
    to trigger/check an action which is closely related to that application only.
    Hence, it is not present in Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`com.example.XXX` is the package name that is discouraged by Java and Android
    application development. It makes sure that the use of this package is mostly
    due to understanding the purpose of it in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: Action normally tells you how your intent is structured, especially the data
    and the extras. It is like a phenomenon of methods, where there are arguments
    and it returns values. It is a good practice to always use your action name as
    specifically as possible, and tightly couple them with the intent. Intent action
    can be set by using the Android API's method `setAction()`, and you can get it
    by using the `getAction()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the predefined constants for the intent action are given in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constants | Component relation | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_CALL` | Activity | Initiate a phone call |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_EDIT` | Activity | Display data from the user to edit |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_MAIN` | Activity | Start up as an initial activity with no data input
    and no returned output |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_SYNC` | Activity | Synchronized data on the server with the data
    on a mobile device |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_BATTERY_LOW` | Broadcast receiver | A warning that the battery is
    low |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_HEADSET_PLUG` | Broadcast receiver | A headset is plugged into the
    device |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_SCREEN_ON` | Broadcast receiver | The screen has turned on |'
  prefs: []
  type: TYPE_TB
- en: Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android intents, different types of actions are taken on the basis of the
    different types of data that are provided. Data is one of the fundamental parts
    on Android intents, especially in the implicit category. Let us look at some examples
    in order to have a better understanding of how to use data with its relevant action
    in Android intents.
  prefs: []
  type: TYPE_NORMAL
- en: Use of data in ACTION_EDIT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider an example of `ACTION_EDIT`. Whenever we call this action into intent,
    it is obvious that the edit functionality is to be implemented in a sort of the
    document. This document path is to be given in the form of a URI, which will then
    be handled by the Android intent. This URI is basically the part of the data that
    we put inside the intent object.
  prefs: []
  type: TYPE_NORMAL
- en: '`ACTION_EDIT` can be used in a scenario where a developer wants to open the
    default Android''s **Add new contact** screen in which the developer expects the
    user to edit. In this case, the intent which is called to open the **Add new contact**
    screen should have the `ACTION_EDIT` action defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Use of data in ACTION_CALL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider another example of `ACTION_CALL`. This action is used when we need
    to perform the call functionality through intent. So, in order to complete the
    task, we need to provide a telephone number by referencing it using a `tel://`
    URI. This is the part of the data set that is to be provided with the intent so
    that Android may know on what data does it need to perform the dialling functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Use of data in ACTION_VIEW
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving towards our third example, that is `ACTION_VIEW`. In most cases, when
    this action is called, there is a website linked to it via a URI. This helps Android
    to understand the data on which the view action is to be performed. Normally,
    with `ACTION_VIEW` action, an `http://` URI is attached, so that Android may process
    the functionality of viewing any web page.
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is the additional information given to the intent in order to know the best
    kind of component required to perform that specific intent. For example, if there
    is a webpage that we want to view using `ACTION_VIEW` action, we can specify its
    category as `CATEGORY_BROWSABLE`, in order to let Android know that the data associated
    with the intent is safe and can easily be executed using the Android browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some constants of categories that can be easily used in any Android program
    are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constants | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_BROWSABLE` | The activity is safe to be executed on an Android
    browser using the data associated with the intent. |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_GADGET` | The activity is associated with another activity that
    is hosted by any Android gadget. |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_HOME` | The activity displays the home screen, or it is the first
    screen that the user sees when the **Home** button is pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_LAUNCHER` | The category of a particular activity is launcher,
    which means it is going to be the top of the stack activity. |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_PREFERENCE` | The destination activity is from the preference panel.
    |'
  prefs: []
  type: TYPE_TB
- en: Extras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we had a good look in the extras feature and how can
    we can use it with intents. Just like the data, some extras are bound with the
    intent that is to be launched. For example, the `ACTION_HEADSET_PLUG` action has
    the extra "State" to indicate whether your headphones are connected to the cell
    phone or not.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are parallel to those for bundle objects. So, the extras can be
    installed and read as a bundle using the `putExtras()` and `getExtras()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Intent filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this moment, we have a perfect understanding of Android intents and its implementation.
    Android intents are responsible for telling Android that a certain event has occurred,
    it is also used to give additional data on which a certain action should be taken.
    But how would Android know which component can facilitate the execution of any
    intent? For this, the concept of Intent filters comes in. Intent filters identify
    which component can react to a particular call to activities, services or broadcast
    intents.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, intent filters are given to an activity or a service via `AndroidManifest.xml`
    file that consists of action, data, and category tests. In the case of broadcast
    receiver, intent filters can also be defined via code, dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an implicit intent, it is necessary for it to pass all the three tests
    in order to deliver it to the particular component. Now, there can be two conditions
    based on these cases: one is when the intent does not pass any one of the tests,
    the intent will not be passed to the component. The other case is, when it has
    got its tests passed, it will directly be handed over to the respective component.
    In the first case, there is an exception that if it does not pass the test, it
    can be handed over to the next intent filter of the same activity. By this, it
    will be possible that it might be executed as per the expectation.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can have multiple intent filters inside one activity in the `AndroidManifest.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A normal XML tag of an activity having an intent filter inside looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intent filters](img/9639_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the code, it consists of one activity tag which has everything
    inside it. This activity consists of only one intent filter that has two main
    components in it: **action** and **category**. The action to be taken at the execution
    of this intent is `android.intent.action.MAIN`, by calling this action any previous
    reference to the activity is removed, and the activity is executed with a fresh
    start. With this, the category is set as `android.intent.category.LAUNCHER`; this
    shows that the activity that is written inside the `AndroidManifest` file is the
    launcher''s `activity` tag. That means, it is the first activity to be launched
    once the application is executed. If there are two or more activities described
    as launcher in the `AndroidManifest.xml` file, the Android operating system will
    ask the user which activity to start with.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`<intent-filter>` is part of the `AndroidManifest.xml` file and not of the
    Java code, because the information it contains is required before the project
    application is launched. For example, the category is to be determined if it is
    a launcher activity or not, before the start of the project application. As the
    `AndroidManifest.xml` file is executed before the start of the project application
    in order to extract the information about the project, intent filters are part
    of this file. The only exception is in the case of broadcast intent, in which
    the information can be modified dynamically from the Java code and not from the
    `AndroidManifest.xml` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple intent filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is not a compulsion that any Android activity may have only one intent filter.
    One activity may incorporate various intent filters which occupy many sub components
    such as category, data, and actions. Take a look at the following screenshot which
    shows the two intent filters present with different types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling multiple intent filters](img/9639_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The explanation of the code mentioned in the preceding screenshot will be covered
    in the upcoming topics of this chapter. For the time being, it is important to
    know the implementation of various intent filters inside an activity.
  prefs: []
  type: TYPE_NORMAL
- en: Test components of an intent filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filters are the representative of action, data, and category field of an intent
    object. Whenever an implicit intent is called, it is tested against these filters
    in order to get executed. If that intent does not fulfill any one of the test
    components, it will not be executed, or rather, it will be directed to a separate
    intent filter of the same activity (if it exists).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to have a proper understanding of the intent filters, we need
    to go through a step-by-step evaluation of each test component associated with
    the intent filter. There are three test components present:'
  prefs: []
  type: TYPE_NORMAL
- en: Action test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Action describes what kind of action is to be executed by the coming intent.
    The `AndroidManifest.xml` file determines the requirements that are to be fulfilled
    by the incoming intent. If any intent is unable to match the specified action
    in the `AndroidManifest.xml` file, it will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action test is basically a test that is executed by the information given inside
    the manifest file of the project. All the action components are defined inside
    the `<intent-filter>` tags, and then matched in order to execute the intent. In
    the following screenshot, you can see how the `intent-filter` tag looks while
    having action tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Action test](img/9639_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code given in the preceding screenshot, there are three actions listed
    inside the `intent-filter` tags. These action tests will be determined by the
    Android operating system if the incoming intent is be able to do these actions.
    There are three tests listed in the preceding code, descriptions of which you
    can see in the table given in the *Action* section. The following two conditions
    are to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is no action written inside the `intent-filter` tags, the Android operating
    system will refuse to process the intent as there is nothing available for matching.
  prefs: []
  type: TYPE_NORMAL
- en: If the `intent-filter` tag contains more than one action, but there is no action
    listed in the incoming intent, the intent will go through with it without any
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Writing conventions for <action>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are certain conventions that Android follows while defining the actions.
    It should be kept in mind, for default actions we have to use the predefined constants
    that are given in the Android API. In the Android library, it is a convention
    that every action string starts with `ACTION_`, after which the real action name
    is written. For example, `ACTION_MAIN`, `ACTION_TIME_ZONE_CHANGED`, and `ACTION_WEB_SEARCH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when it comes to the convention that is required to mention this
    string inside the `AndroidManifest.xml` file, Android follows the `android.intent.action.STRING`
    pattern. In this statement, the word *STRING* is replaced by the particular action
    that is to be matched but without the word *ACTION*. In order to understand the
    given statement, take the example of the `ACTION_MAIN` constant. If we want to
    mention it inside the `AndroidManifest.xml` file, we will not write `ACTION_`,
    instead we will write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing conventions for <action>](img/9639_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is the same case with `ACTION_EDIT`, which enables the Android to edit any
    document whose reference is given in the URI. We will write the code, shown in
    the following screenshot, to make it understandable in the `AndroidManifest.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing conventions for <action>](img/9639_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When it comes to the custom action, the action is defined by the user and not
    the Android API. There is a best practice that before writing it always starts
    with your package name in order to keep it unique. For example, if you want to
    make an action called `HIDE_OBJECTS`, you will have to write code, as shown in
    the following screenshot, in your XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing conventions for <action>](img/9639_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Category test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to pass the category test, it is necessary that the incoming intent
    category should be matched with at least one of the categories mentioned inside
    the `<category>` tag in `AndroidManifest.xml`. If an intent object is created
    without any knowledge of the category in it, it should always pass, no matter
    what categories are defined in the manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that if we want to move between one activity to another using
    the `startActivity()` method, it is necessary that the activity that is willing
    to receive the implicit intent must have one default category mentioned in the
    `AndroidManifest.xml` file, which is `CATEGORY_DEFAULT` (as mentioned in Android
    API).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the same as writing the convention for action, the category should be
    written as `android.intent.category.DEFAULT`, without mentioning the `CATEGORY_`
    string in `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although, this is not the case with launcher category; it is an exception.
    We mention `android.intent.category.LAUNCHER` in the launcher activity tags. The
    representation of the category test is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Category test](img/9639_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the code given in the preceding screenshot, there are two categories mentioned.
    The first category is `android.intent.category.DEFAULT`, which is because this
    particular activity is all set to receive the implicit intent. The other category
    that is mentioned in the manifest file is `android.intent.category.BROWSABLE`,
    which enables this activity to browse through the native Android browser present
    in the phone or any other applications that are for browsing websites.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the launcher activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up the launcher activity is primarily a part of the category. In this,
    we need to make sure that we completely understand the exception of the launcher
    activity with respect to intent. Since it is known that launcher activity is the
    one which is started just after the application is started for the first time,
    we can now move forward with its concept in category. The `DEFAULT` category is
    used if it is known that the activity will receive some implicit intent, but on
    the other hand, the `LAUNCHER` activity is the one that was started for the first
    time in any application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sense, no launcher activity can be a default one at the same time.
    The result concludes that no activity can have `android.intent.category.DEFAULT`
    and `android.intent.category.LAUNCHER` at the same time in `AndroidManifest.xml`.
    The launcher activity presented in the manifest looks like the code shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In code given in the preceding screenshot, the activity `com.example.android.application.MyList`
    is the launcher activity that will produce a list at the start of the application.
    Since this is the main entry point of the application, we provide `ACTION_MAIN`
    as the action in the manifest. While you can see the second tag, the category
    that is provided is given the name of `android.intent.category.LAUNCHER`.
  prefs: []
  type: TYPE_NORMAL
- en: Data test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data tags are mentioned in order to facilitate the action taken on the executed
    activity. That is the reason why there can be multiple data tags inside one `<activity>`
    tag. The `<data>` tag consists of the information on a specific URI or MIME media
    type. For example, an activity may have the data tags, shown in the following
    screenshot, in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data test](img/9639_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the code given in the preceding screenshot, the intent filter contains two
    data tags. In each one of them, the MIME media type that is given under the `android:mimeType`
    attribute is the one that specifies the data format supported by the activity
    for a certain action. The `video/avi` value describes the video format of `.avi`
    files, which is supported by the activity. Similarly, if there is a need for mentioning
    the audio file type, we can use `audio/mpeg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible that we put an asterisk after the video or audio MIME Type.
    For example, see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data test](img/9639_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code is the same as the previous one, apart from the `video/*` and `audio/*`
    MIME types. The asterisk indicates that all possible subtypes of them are supported
    by this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are some points that we need to make sure of:'
  prefs: []
  type: TYPE_NORMAL
- en: An intent object that does not contain any particular information about URI
    will only pass through the `intent-filter` tag if, and only if, there is no information
    of data is provided in the `AndroidManifest.xml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An intent object that only contains the URI but not the data MIME type will
    only be passed if, and only if, it is matched with the URI specified in the filter
    and there is no filter specified for the data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An intent object that only contains the MIME type, but not the URI, will only
    be passed if, and only if, it is matched with the MIME type specified in the filter
    and there is no filter specified for the URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case where an intent object contains the URI, as well as the MIME type,
    it will only be passed if they are matched with the corresponding values of intent-filters
    specified in `AndroidManifest.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical representation of the <data> tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `<data>` tag contains many attributes in order to make it complete information.
    The following syntax contains all the attributes that can be defined in the `<data>`
    tag, which will increase the knowledge of the activity while the processing of
    intent is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Typical representation of the <data> tag](img/9639_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code given in the preceding screenshot, there are various attributes
    which are all optional, yet they are more mutually dependent on one another. The
    list of the optional attributes is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scheme`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pathPrefix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pathPattern`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's talk about their dependencies with one another. If the scheme is
    not mentioned in the data tag, no URI will remain valid after that. Similarly,
    if the host element is not defined, all the path tags and host tag values will
    be voided.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a detailed look at the intent filter and intent object.
    We saw the basic building blocks of the intent object, in which we define elements
    in the Java code, and on the other hand there are intent filters, which give knowledge
    to the Android OS about the activities present inside the application. We learned
    how `intent-filters` tags do their work by matching the incoming intent object
    and its attribute. Then, they decide whether or not the intent should be executed
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a look on the action, data, and category, and how these work. How
    different data, categories, and actions are incorporated within a single activity
    in different intent filters, and what the main mechanism is if there are various
    filter choices available. We also looked at some writing conventions, the typical
    way of writing a launcher activity in the Android Manifest and how many MIME types
    are incorporated over when the data is valid for different subtypes of a format.
    In the next chapter, we will see how intents can be used with broadcast receivers,
    their practical examples, and the kind of issues that can arise because of them.
  prefs: []
  type: TYPE_NORMAL
