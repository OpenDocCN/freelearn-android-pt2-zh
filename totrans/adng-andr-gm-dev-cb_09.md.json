["```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <wallpaper \n        android:settingsActivity=\"com.Live.Wallpaper.Extension.Example.LiveWallpaperSettings\"\n        android:thumbnail=\"@drawable/ic_launcher\"/>\n    ```", "```kt\n    <uses-feature android:name=\"android.software.live_wallpaper\" />\n\n    <application android:icon=\"@drawable/ic_launcher\" >\n        <service\n            android:name=\".LiveWallpaperExtensionService\"\n            android:enabled=\"true\"\n            android:icon=\"@drawable/ic_launcher\"\n            android:label=\"@string/service_name\"\n            android:permission=\"android.permission.BIND_WALLPAPER\" >\n            <intent-filter android:priority=\"1\" >\n                <action android:name=\"android.service.wallpaper.WallpaperService\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.service.wallpaper\"\n                android:resource=\"@xml/wallpaper\" />\n        </service>\n\n        <activity\n            android:name=\".LiveWallpaperSettings\"\n            android:exported=\"true\"\n            android:icon=\"@drawable/ic_launcher\"\n            android:label=\"@string/live_wallpaper_settings\"\n            android:theme=\"@android:style/Theme.Black\" >\n        </activity>\n    ```", "```kt\n    // Return the saved value for the mParticleSpeed variable\n    public int getParticleSpeed(){\n      return -mParticleSpeed;\n    }\n\n    // Save the mParticleSpeed value to the wallpaper's preference file\n    public void setParticleSpeed(int pParticleSpeed){\n      this.mParticleSpeed = pParticleSpeed;\n      this.mSharedPreferencesEditor.putInt(PARTICLE_SPEED_KEY, mParticleSpeed);\n      this.mSharedPreferencesEditor.commit();\n    }\n    ```", "```kt\n// OnProgressChanged represents a movement on the slider\n  @Override\n  public void onProgressChanged(SeekBar seekBar, int progress,\n      boolean fromUser) {\n    // Set the mParticleSpeed depending on the SeekBar's position(progress)\n    mParticleSpeed = progress;\n```", "```kt\n@Override\nprotected void onPause() {\n  // onPause(), we save the current value of mParticleSpeed to the preference file.\n  // Anytime the wallpaper's lifecycle is executed, the mParticleSpeed value is loaded\n  LiveWallpaperPreferences.getInstance().setParticleSpeed(mParticleSpeed);\n  super.onPause();\n}\n```", "```kt\n  private int mParticleSpeed;\n\n  // These ratio variables will be used to keep proper scaling of entities\n  // regardless of the screen orientation\n  private float mRatioX;\n  private float mRatioY;\n```", "```kt\n@Override\npublic void onSurfaceChanged(GLState pGLState, int pWidth, int pHeight) {\n\n  if(pWidth > pHeight){\n      mRatioX = 1;\n      mRatioY = 1;\n    } else {\n      mRatioX = ((float)pHeight) / pWidth;\n      mRatioY = ((float)pWidth) / pHeight;\n    }\n\n    super.onSurfaceChanged(pGLState, pWidth, pHeight);\n  }\n```", "```kt\n  // speed set by the preferences...\n  if(currentVelocityY != mParticleSpeed){\n    // Adjust the particle's velocity to the proper value\n    particlePhysicsHandler.setVelocityY(mParticleSpeed);\n  }\n```", "```kt\n  // If the particle's scale is not equal to the current ratio\n  if(entity.getScaleX() != mRatioX){\n    // Re-scale the particle to better suit the current screen ratio\n    entity.setScale(mRatioX, mRatioY);\n  }\n```", "```kt\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```", "```kt\n    this.mMessagePool.registerMessage(ServerMessages.SERVER_MESSAGE_ADD_POINT, AddPointServerMessage.class);\n    this.mMessagePool.registerMessage(ClientMessages.CLIENT_MESSAGE_ADD_POINT, AddPointClientMessage.class);  \n    ```", "```kt\n    if (pSceneTouchEvent.getAction() == TouchEvent.ACTION_MOVE) {\n      if (mServer != null) {\n\n        if(mClient != null){\n          // Obtain a ServerMessage object from the mMessagePool\n          AddPointServerMessage message = (AddPointServerMessage) MultiplayerExtensionExample.this.mMessagePool.obtainMessage(ServerMessages.SERVER_MESSAGE_ADD_POINT);\n          // Set up the message with the device's ID, touch coordinates and draw color\n          message.set(SERVER_ID, pSceneTouchEvent.getX(), pSceneTouchEvent.getY(), mClient.getDrawColor());\n          // Send the client/server's draw message to all clients\n          mServer.sendMessage(message);\n          // Recycle the message back into the message pool\n          MultiplayerExtensionExample.this.mMessagePool.recycleMessage(message);\n        return true;\n        }\n        // If device is running as a client...\n      } else if(mClient != null){\n        /* Similar to the message sending code above, except\n         * in this case, the client is *not* running as a server.\n         * This means we have to first send the message to the server\n         * via a ClientMessage rather than ServerMessage\n         */\n        AddPointClientMessage message = (AddPointClientMessage) MultiplayerExtensionExample.this.mMessagePool.obtainMessage(ClientMessages.CLIENT_MESSAGE_ADD_POINT);\n        message.set(CLIENT_ID, pSceneTouchEvent.getX(), pSceneTouchEvent.getY(), mClient.getDrawColor());\n        mClient.sendMessage(message);\n        MultiplayerExtensionExample.this.mMessagePool.recycleMessage(message);\n\n        return true;\n      }  \n    }\n    ```", "```kt\n    mServer = new MultiplayerServer(SERVER_PORT);\n    mServer.initServer();\n\n    // or...\n\n    mClient = new MultiplayerClient(mServerIP,SERVER_PORT, mEngine, mScene);\n    mClient.initClient();\n    ```", "```kt\n    @Override\n    protected void onDestroy() {\n      // Terminate the client and server socket connections\n      // when the application is destroyed\n      if (this.mClient != null)\n        this.mClient.terminate();\n\n      if (this.mServer != null)\n        this.mServer.terminate();\n      super.onDestroy();\n    }\n    ```", "```kt\n    // Create the SocketServer, specifying a port, client listener and \n    // a server state listener (listeners are implemented in this class)\n    MultiplayerServer.this.mSocketServer = new SocketServer<SocketConnectionClientConnector>(\n        MultiplayerServer.this.mServerPort,\n        MultiplayerServer.this, MultiplayerServer.this) {\n\n          // Handle client connection here...\n    };\n    ```", "```kt\n      // Called when a new client connects to the server...\n    @Override\n    protected SocketConnectionClientConnector newClientConnector(\n      SocketConnection pSocketConnection)\n      throws IOException {\n        // Create a new client connector from the socket connection\n        final SocketConnectionClientConnector clientConnector = new       SocketConnectionClientConnector(pSocketConnection);\n\n        // Register the client message to the new client\n      clientConnector.registerClientMessage(ClientMessages.CLIENT_MESSAGE_ADD_POINT, AddPointClientMessage.class, new IClientMessageHandler<SocketConnection>(){\n\n        // Handle message received by the server...\n        @Override\n        public void onHandleMessage(â€©        ClientConnector<SocketConnection> pClientConnector,\n            IClientMessage pClientMessage)\n            throws IOException {\n          // Obtain the client message\n          AddPointClientMessage incomingMessage = (AddPointClientMessage) pClientMessage;\n\n          // Create a new server message containing the contents of the message received\n          // from a client\n          AddPointServerMessage outgoingMessage = new AddPointServerMessage(incomingMessage.getID(), incomingMessage.getX(), incomingMessage.getY(), incomingMessage.getColorId());\n\n          // Reroute message received from client to all other clients\n          sendMessage(outgoingMessage);\n        }\n      });\n\n      // Return the new client connector\n      return clientConnector;\n    }\n    ```", "```kt\n    // Start the server once it's initialized\n    MultiplayerServer.this.mSocketServer.start();\n    ```", "```kt\n    // Send broadcast server message to all clients\n    public void sendMessage(ServerMessage pServerMessage){\n      try {\n        this.mSocketServer.sendBroadcastServerMessage(pServerMessage);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n    ```", "```kt\n    // Terminate the server socket and stop the server thread\n    public void terminate(){\n      if(this.mSocketServer != null)\n      this.mSocketServer.terminate();\n    }\n    ```", "```kt\n    // Create the socket with the specified Server IP and port\n    Socket socket = new Socket(MultiplayerClient.this.mServerIP, MultiplayerClient.this.mServerPort);\n    // Create the socket connection, establishing the input/output stream\n    SocketConnection socketConnection = new SocketConnection(socket);\n    // Create the server connector with the specified socket connection\n    // and client connection listener\n    MultiplayerClient.this.mServerConnector = new SocketConnectionServerConnector(socketConnection, MultiplayerClient.this);\n    ```", "```kt\n    // obtain the class casted server message\n    AddPointServerMessage message = (AddPointServerMessage) pServerMessage;\n\n    // Create a new Rectangle (point), based on values obtained via the server\n    // message received\n    Rectangle point = new Rectangle(message.getX(), message.getY(), 3, 3, mEngine.getVertexBufferObjectManager());\n\n    // Obtain the color id from the message\n    final int colorId = message.getColorId();\n    ```", "```kt\n    // Member variables to be read in from the server and sent to clients\n    private int mID;\n    private float mX;\n    private float mY;\n    private int mColorId;\n    ```", "```kt\n    // Apply the read data to the message's member variables\n    @Override\n    protected void onReadTransmissionData(DataInputStream pDataInputStream)\n        throws IOException {\n      this.mID = pDataInputStream.readInt();\n      this.mX = pDataInputStream.readFloat();\n      this.mY = pDataInputStream. readFloat();\n      this.mColorId = pDataInputStream.readInt();\n    }\n\n    // Write the message's member variables to the output stream\n    @Override\n    protected void onWriteTransmissionData(\n        DataOutputStream pDataOutputStream) throws IOException {\n      pDataOutputStream.writeInt(this.mID);\n      pDataOutputStream.writeFloat(this.mX);\n      pDataOutputStream.writeFloat(this.mY);\n      pDataOutputStream.writeInt(mColorId);\n    }\n    ```", "```kt\n  // write method\n  pDataOutputStream.writeInt(this.mID);\n  pDataOutputStream.writeFloat(this.mX);\n  pDataOutputStream.writeFloat(this.mY);\n  pDataOutputStream.writeInt(this.mColorId);\n\n  // read method\n  this.mID = pDataInputStream.readInt();\n  this.mX = pDataInputStream.readFloat();\n  this.mY = pDataInputStream. readFloat();\n  this.mColorId = pDataInputStream.readInt();\n```", "```kt\n    // Create a new buildable bitmap texture atlas to build and contain texture regions\n    BuildableBitmapTextureAtlas bitmapTextureAtlas = new BuildableBitmapTextureAtlas(mEngine.getTextureManager(), 1024, 1024, TextureOptions.BILINEAR);\n    ```", "```kt\n    // Create a low-res (32x32) texture region of svg_image.svg\n    mLowResTextureRegion = SVGBitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, this, \"svg_image.svg\", 32,32);\n\n    // Create a med-res (128x128) texture region of svg_image.svg\n    mMedResTextureRegion = SVGBitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, this, \"svg_image.svg\", 128, 128);\n\n    // Create a high-res (256x256) texture region of svg_image.svg\n    mHiResTextureRegion = SVGBitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, this, \"svg_image.svg\", 256,256);    \n    ```", "```kt\nfloat mScaleFactor = 1;\n\n// Obtain the device display metrics (dpi)\nDisplayMetrics displayMetrics = this.getResources().getDisplayMetrics();\n\nint deviceDpi = displayMetrics.densityDpi;\n\nswitch(deviceDpi){\ncase DisplayMetrics.DENSITY_LOW:\n  // Scale factor already set to 1\n  break;\n\ncase DisplayMetrics.DENSITY_MEDIUM:\n  // Increase scale to a suitable value for mid-size displays\n  mScaleFactor = 1.5f;\n  break;\n\ncase DisplayMetrics.DENSITY_HIGH:\n  // Increase scale to a suitable value for larger displays\n  mScaleFactor = 2;\n  break;\n\ncase DisplayMetrics.DENSITY_XHIGH:\n  // Increase scale to suitable value for largest displays\n  mScaleFactor = 2.5f;\n  break;\n\ndefault:\n  // Scale factor already set to 1\n  break;\n}\n\nSVGBitmapTextureAtlasTextureRegionFactory.setScaleFactor(mScaleFactor);\n```", "```kt\n  mLowResTextureRegion = SVGBitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, this, \"svg_image.svg\", 32,32);\n```", "```kt\n    ISVGColorMapper svgColorMapper = new ISVGColorMapper(){\n      @Override\n      public Integer mapColor(final Integer pColor) {\n        // If the path contains no color channels, return null\n        if(pColor == null) {\n          return null;\n        }\n\n        // Obtain color values from 0-255\n        int alpha = Color.alpha(pColor);\n        int red = Color.red(pColor);\n        int green = Color.green(pColor);\n        int blue = Color.blue(pColor);\n\n        // If the SVG image's color values equal red, or ARGB{0,255,0,0}\n        if(red == 255 && green == 0 && blue == 0){\n          // Return a pure blue color\n          return Color.argb(0, 0, 0, 255);\n\n        // If the SVG image's color values equal green, or ARGB{0,0,255,0}\n        } else if(red == 0 && green == 255 && blue == 0){\n          // Return a pure white\n          return Color.argb(0, 255, 255, 255);\n\n        // If the SVG image's color values equal blue, or ARGB{0,0,0,255}\n        } else if(red == 0 && green == 0 && blue == 255){\n          // Return a pure blue color\n          return Color.argb(0, 0, 0, blue);\n\n        // If the SVG image's color values are white, or ARGB{0,254,254,254}\n        } else if(red == 254 && blue == 254 && green == 254){\n          // Return a pure red color\n          return Color.argb(0, 255, 0, 0);\n\n        // If our \"custom color\" conditionals do not apply...\n        } else {\n\n          // Return the SVG image's default color values\n          return Color.argb(alpha, red, green, blue);\n        }\n      }\n    };\n\n    // Create an SVG texture region\n    mSVGTextureRegion = SVGBitmapTextureAtlasTextureRegionFactory.createFromAsset(bitmapTextureAtlas, this, \"color_mapping.svg\", 256,256, svgColorMapper); \n    ```", "```kt\n    // If the SVG image's color values equal red, or ARGB{0,255,0,0}\n    } else if(red == 255 && green == 0 && blue == 0){\n      // Return a pure blue color\n      return Color.argb(0, 0, 0, 255);\n\n    // If the SVG image's color values equal green, or ARGB{0,0,255,0}\n    }\n```", "```kt\n    // If our \"custom color\" conditionals do not apply...\n    } else {\n      // Return the SVG image's default color values\n      return Color.argb(alpha, red, green, blue);\n    }\n```", "```kt\n    } else if(red == 0 && green == 0 && blue == 255){\n      // Return a pure blue color\n      return Color.argb(0, 255, 255, 0);\n       }\n```"]