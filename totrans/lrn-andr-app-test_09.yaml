- en: Chapter 9. Alternative Testing Tactics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章.替代测试策略
- en: Up to this point, we have analyzed the most common and accessible tactics to
    implement testing in our projects. However, there are a few missing pieces in
    our puzzle, which we'll hope to cover in this final chapter. The Android ecosystem
    is always moving forward, with the advent of Android Studio and Gradle. The toolbox
    for testing is also always being added too. In this area, we'll look at some third-party
    libraries that can help us expand our testing framework; such as Robolectric for
    Android testing on the JVM, as well as potential bleeding edge and future developments,
    like Fork; imagine threading for your tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分析了在项目中实施测试的最常见和最易获取的策略。然而，在我们的拼图中还缺少一些部分，我们希望在这最后一章中涵盖。随着Android
    Studio和Gradle的出现，Android生态系统一直在向前发展。测试工具箱也总是在增加。在这一领域，我们将研究一些第三方库，它们可以帮助我们扩展测试框架；例如在JVM上为Android测试的Robolectric，以及像Fork这样的潜在前沿和未来开发；想象一下为你的测试提供线程。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Jacoco code coverage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jacoco代码覆盖率
- en: Robotium
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robotium
- en: Testing on host's JVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在宿主JVM上进行测试
- en: Robolectric
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robolectric
- en: Fest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fest
- en: Spoon/Fork
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spoon/Fork
- en: Code coverage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Perhaps Android's Achilles' heel would be the lack of documentation, and the
    number of places you have to visit to get the complete version of what you are
    trying to find, or what's even worse, in many cases the official documentation
    is incorrect, or has not been updated to match the current release. The documentation
    for the new Gradle build system is very sparse on the ground, and this is where
    most people start when trying to read up on code coverage; so let's light up a
    few dark corners.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或许Android的阿基里斯之踵就是文档的缺乏，以及为了找到完整版本的内容，你需要访问许多地方，或者更糟糕的是，在许多情况下，官方文档是错误的，或者没有更新以匹配当前版本。新Gradle构建系统的文档非常稀少，这正是大多数人尝试阅读代码覆盖率内容时的起点；那么，让我们点亮一些黑暗的角落。
- en: Code coverage is a measure used in software testing that describes the amount
    of source code that was actually tested by the test suite, and to what degree,
    following some criteria. As code coverage inspects the code directly, it is therefore
    a form of white box testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是软件测试中使用的一种度量，它描述了测试套件实际测试的源代码量，以及根据某些标准的程度。由于代码覆盖率直接检查代码，因此它是一种白盒测试形式。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: White-box testing (also known as clear box testing, glass box testing, transparent
    box testing, and structural testing), is a method of testing software that tests
    internal structures or workings of an application, as opposed to its functionality
    (say black-box testing).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试（也称为透明盒测试、玻璃盒测试、结构测试），是一种测试软件的方法，它测试应用程序的内部结构或工作原理，而不是其功能（例如黑盒测试）。
- en: From the several tools available, providing code coverage analysis for Java
    we are using Jacoco, an open-source toolkit for measuring and reporting Java code
    coverage that is supported by the Android project. The infrastructure to start
    using it for your own projects is already there, therefore, minimizing the effort
    needed to implement it. Jacoco supersedes the EMMA code coverage tool, while taking
    knowledge from lessons learned in this endeavor, and being built by the same team.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多可用于提供Java代码覆盖率分析的工具体中，我们选择了Jacoco，这是一个开源工具包，用于测量和报告Java代码覆盖率，并由Android项目提供支持。启动自己的项目使用它的基础设施已经就绪，因此，实现它所需的工作量最小化。Jacoco取代了EMMA代码覆盖率工具，同时吸取了这一努力中学到的知识，并由同一团队构建。
- en: Jacoco distinguishes itself from other tools by going after a distinctive feature
    combination; support for large-scale enterprise software development, while keeping
    individual developer's work fast and iterative. This is fundamental in a project
    the size of Android, and Jacoco shines at its best, providing code coverage for
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Jacoco通过独特的功能组合与其他工具区分开来；支持大规模企业软件开发，同时保持单个开发者的工作快速和迭代。这对于像Android这样规模的项目来说至关重要，Jacoco在这方面表现得最为出色，为它提供了代码覆盖率。
- en: Jacoco features
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jacoco特性
- en: 'Java, the Android Gradle plugin and the Gradle build system, all have native
    support for Jacoco. From the latest Jacoco version available at this book''s release,
    paraphrasing its documentation, the most distinctive set of features are the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java、Android Gradle插件和Gradle构建系统，都对Jacoco有原生支持。从本书发布时最新的Jacoco版本来看，引用其文档，最独特的功能集如下：
- en: Jacoco can instrument classes for coverage either offline (before they are loaded)
    or on the fly (using an instrumenting application classloader).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jacoco 可以在离线（加载之前）或动态（使用检测应用程序类加载器）为覆盖率对类进行检测。
- en: 'Supported coverage types: class, method, line, branch, and instruction. Jacoco
    can detect when a single source code line is covered only partially.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的覆盖率类型：类、方法、行、分支和指令。Jacoco 可以检测到单个源代码行是否仅被部分覆盖。
- en: Coverage stats are aggregated at method, class, package, and "all classes" levels.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖率统计数据在方法、类、包和“所有类”级别进行汇总。
- en: 'Output report types: plain text, HTML, XML. All report types support drill-down
    to a user-controlled detail depth. The HTML report supports source code linking.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出报告类型：纯文本、HTML、XML。所有报告类型都支持根据用户控制的详细深度进行下钻。HTML 报告支持源代码链接。
- en: Output reports can highlight items with coverage levels, below user-provided
    thresholds.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出报告可以突出显示低于用户提供的阈值的覆盖率项。
- en: Coverage data obtained in different instrumentation or test runs can be merged
    together.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的检测或测试运行中获取的覆盖率数据可以合并在一起。
- en: Jacoco does not require access to the source code and degrades gracefully with
    decreasing amounts of debug information available in the input classes.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jacoco 不需要访问源代码，并且随着输入类中可用的调试信息减少，其性能会优雅地降级。
- en: Jacoco is relatively fast; the runtime overhead of added instrumentation is
    small (5 to 20%), and the bytecode instrumentor itself is very fast (mostly limited
    by file I/O speed). Memory overhead is a few hundred bytes per Java class.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jacoco 相对较快；添加检测的开销很小（5到20%），字节码检测器本身非常快（主要受文件 I/O 速度限制）。每个 Java 类的内存开销是几百字节。
- en: Temperature converter code coverage
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 温度转换器代码覆盖率
- en: 'The Android Gradle plugin has support for Jacoco code coverage out of the box.
    The setup involves selecting which build flavor you want to obtain coverage reports
    for, and selecting your Jacoco version. We want to instrument our `debug` flavor
    so that we can have coverage without affecting release code. Under the `android`
    closure, add these lines to your `android/build.gradle` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Android Gradle 插件开箱即支持 Jacoco 代码覆盖率。设置涉及选择您想要获取覆盖率报告的构建版本，并选择您的 Jacoco 版本。我们希望对
    `debug` 版本进行检测，这样可以在不影响发布代码的情况下获得覆盖率。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Jacoco version does not actually have to be added here, however, the version
    of Jacoco shipping with Android is currently behind the latest release. The latest
    version of the Jacoco coverage library can be found on their GitHub page at [https://github.com/jacoco/jacoco](https://github.com/jacoco/jacoco)
    or Maven central. Therefore, it is recommended that you make the version explicit.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里并不需要添加 Jacoco 的版本信息，但是目前随 Android 附带的 Jacoco 版本落后于最新版本。可以在他们的 GitHub 页面
    [https://github.com/jacoco/jacoco](https://github.com/jacoco/jacoco) 或 Maven 中央仓库找到最新版本的
    Jacoco 覆盖率库。因此，建议明确指定版本。
- en: Generating code coverage analysis report
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成代码覆盖率分析报告
- en: You will need to have an emulator running as Jacoco instruments your android
    tests, and these are run on a device so an emulator is appropriate. When the tests
    are complete, a code coverage report is generated on the device and then pulled
    to your local machine. If you choose to use a real device instead of an emulator,
    it will need to be rooted. Otherwise this pull of the reports will fail with a
    `Permission Denied` exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要让模拟器运行，因为 Jacoco 会检测您的 Android 测试，这些测试在设备上运行，因此使用模拟器是合适的。测试完成后，设备上会生成一个代码覆盖率报告，然后将其拉取到您的本地机器上。如果您选择使用真实设备而不是模拟器，那么设备需要获得root权限。否则，报告拉取会因
    `Permission Denied` 异常而失败。
- en: 'Run code coverage from the command line as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行代码覆盖率如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can use this command if you have multiple flavors:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个构建版本，也可以使用以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This following message verifies that our tests have been run and the coverage
    data is retrieved:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息验证了我们的测试已经运行，并且覆盖率数据已被检索：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This has created the report files inside the `/app/build/outputs/reports/coverage/debug/`
    directory. If you use multiple flavors, your path will be slightly different.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `/app/build/outputs/reports/coverage/debug/` 目录中创建报告文件。如果您使用多个构建版本，您的路径会略有不同。
- en: Now before we go any further, if you haven't realized yet, we have not only
    been generating the report for the Android app module, but we also have code in
    our Java `core` module. Let's create a report for this as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，如果您还没有意识到，我们不仅为 Android 应用模块生成了报告，我们的 Java `core` 模块中也有代码。我们也为这个模块创建一个报告。
- en: 'With Gradle having support for Jacoco, we only need to apply the Jacoco plugin
    to our `code/build.gradle` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gradle支持Jacoco，我们只需将Jacoco插件应用到我们的`code/build.gradle`文件中：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: More configurations are possible with the same closure that we are using for
    our Android module. Details of properties that can be changed are found on the
    Gradle Jacoco plugin website at [http://gradle.org/docs/current/userguide/jacoco_plugin.html](http://gradle.org/docs/current/userguide/jacoco_plugin.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与我们Android模块相同的闭包，可以进行更多配置。可以在Gradle Jacoco插件网站找到可更改属性的详细信息，网址为[http://gradle.org/docs/current/userguide/jacoco_plugin.html](http://gradle.org/docs/current/userguide/jacoco_plugin.html)。
- en: 'Now, if you run the `./gradlew` command tasks, you should see a new Gradle
    task that is generated, `jacocoTestReport`. Run this task to generate code coverage
    for our core module:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行`./gradlew`命令任务，你应该会看到一个新生成的Gradle任务，`jacocoTestReport`。运行此任务为我们的核心模块生成代码覆盖率：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This has created the report files inside the `/core/build/reports/jacoco/test/`
    directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这已在`/core/build/reports/jacoco/test/`目录内创建了报告文件。
- en: Excellent! Now we have code coverage reports for both our `app` code and our
    `core` code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们既有`app`代码的覆盖率报告，也有`core`代码的覆盖率报告。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: It is possible to take both of these reports and merge them into one file. You
    will most likely have to work with the XML output to do this. This is left as
    a task for the reader but take a look on the Jacoco website and the Gradle plugin
    site for hints (it has been done before).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将这两个报告合并为一个文件。你可能需要处理XML输出才能完成此操作。这留给读者作为一个任务，但可以在Jacoco网站和Gradle插件网站上寻找提示（这已经有人做过了）。
- en: Let's open the `app` modules `index.html` to display the coverage analysis report.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`app`模块的`index.html`来显示覆盖率分析报告。
- en: '![Generating code coverage analysis report](img/00045.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![生成代码覆盖率分析报告](img/00045.jpeg)'
- en: The information presented in the report includes coverage metrics in a way that
    allows drilling down into data, in a top-down fashion, starting with all classes,
    and going all the way to the level of individual methods and source lines (in
    the HTML report).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 报告中呈现的信息包括覆盖率指标，这种方式允许以自上而下的方式深入数据，从所有类开始，一直到单个方法和源代码行（在HTML报告中）。
- en: The fundamental component of code coverage in Jacoco is the basic block; all
    other types of coverage are derived from the basic block coverage in some way.
    Line coverage is mostly used to link to the source code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jacoco中代码覆盖率的基本组成部分是基本块；所有其他类型的覆盖率都是从基本块覆盖率派生出来的。行覆盖率主要用于链接到源代码。
- en: 'This table describes the important pieces of information in the Jacoco coverage
    report:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此表描述了Jacoco覆盖率报告中的重要信息：
- en: '| Label | Description |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Element | The name of the class or package. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 类或包的名称。 |'
- en: '| Missed Instructions, Coverage | A visual indicator showing the number of
    instructions not covered by tests (in red), next to the percentage of instructions
    covered by tests. Example: `if(x = 1 && y = 2)` would be two instructions but
    one line of code. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 未覆盖指令，覆盖率 | 一个视觉指示器，显示未通过测试覆盖的指令数量（红色显示），以及通过测试覆盖的指令百分比。例如：`if(x = 1 && y
    = 2)`将是两个指令但一行代码。 |'
- en: '| Missed Branches, Coverage | A visual indicator of the number of branches
    not covered by tests (in red), next to the percentage of branches covered. Think
    of an if/else statement as two branches.The number of branches in a method is
    a good measure of its complexity. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 未覆盖分支，覆盖率 | 一个视觉指示器，显示未通过测试覆盖的分支数量（红色显示），以及覆盖的分支百分比。将if/else语句视为两个分支。一个方法中的分支数量是衡量其复杂度的一个好指标。
    |'
- en: '| Missed, Cxty | The number of complex paths (cyclomatic complexity) missed,
    next to the total complexity. A complexity path is defined as a sequence of bytecode
    instructions, without any jumps or jump targets. Adding a branch to the code (an
    `if` statement) would add two pathways (true or false), thus making the complexity
    increase by 1\. However, adding an instruction (`x = 1;`) would not increase the
    complexity. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 未覆盖，Cxty | 未覆盖的复杂路径（循环复杂度）数量，以及总的复杂度。一个复杂路径定义为一系列字节码指令，其中不包含任何跳转或跳转目标。在代码中添加一个分支（如一个`if`语句）将增加两个路径（真或假），因此复杂度会增加1。然而，添加一个指令（如`x
    = 1;`）不会增加复杂度。 |'
- en: '| Missed, Lines | The number of lines not executed by any test, next to the
    total number of lines. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 未覆盖，行数 | 任何测试未执行的行数，以及总行数。 |'
- en: '| Missed, Methods | The number of methods missed, next to the total number
    of methods. This is a basic Java method that is composed by a given number of
    basic paths. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 未覆盖，方法 | 未覆盖的方法数量，以及总方法数量。这是一个由给定数量的基本路径组成的基本Java方法。 |'
- en: '| Missed, Classes | The number of classes without a single test, next to the
    total number of classes. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 未覆盖，类 | 没有进行任何测试的类数量，以及总类数量。 |'
- en: We can drill-down from the package to classes, to specific methods, and the
    lines covered are presented in green, uncovered ones appear in red, while partially
    covered ones are in yellow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从包深入到类，再到具体的方法，覆盖的行以绿色显示，未覆盖的行以红色显示，而部分覆盖的行以黄色显示。
- en: 'This is an example of the report for the **core/** `TemperatureConverter` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对**core/** `TemperatureConverter`类的报告示例：
- en: '![Generating code coverage analysis report](img/00046.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![生成代码覆盖率分析报告](img/00046.jpeg)'
- en: In this report, we can see that the class `TemperatureConverter` is not 100%
    covered. When we look into the code, it is the constructor that is never tested.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这份报告中，我们可以看到类`TemperatureConverter`的测试覆盖率并不是100%。当我们查看代码时，发现是构造函数从未被测试过。
- en: Do you know why? Think for a moment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道为什么吗？请思考一下。
- en: Yes, because a private constructor is never called. This is a utility class
    that is not supposed to be instantiated at all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，因为私有构造函数从未被调用。这是一个不应该被实例化的工具类。
- en: If you can imagine creating a new class with just a static method, you don't
    often create the private constructor; it would be left as the non-visible default
    public constructor. In this case, I have been rather diligent and wrote this private
    constructor, because I was a good boy scout at the time (and still am!).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够想象创建一个只有一个静态方法的类，你通常不会创建私有构造函数；它会保留为不可见的默认公共构造函数。在这种情况下，我相当勤勉地编写了这个私有构造函数，因为当时我是一个好童子军（现在仍然是！）。
- en: We can see here not only how this analysis is helping us to test our code and
    find potential bugs, but also to improve the design.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这种分析不仅帮助我们测试代码和查找潜在的bug，还可以改进设计。
- en: Once we consider this private constructor as a sensible piece of code not to
    be running tests upon, we can see now that even though the class is not yet 100
    percent covered and thus not green, we can be assured that this constructor won't
    be invoked from any other class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们认为这个私有构造函数是一段不需要运行测试的合理代码，现在我们可以看到，尽管类还没有达到100%的覆盖率，因此不是绿色的，但我们确信这个构造函数不会被其他任何类调用。
- en: 'I think a very important lesson here is; *100 percent code coverage does not
    have to be your goal*. Understanding your domain and the architecture of your
    application allows you to make much more reachable and realistic estimates for
    the amount of code coverage that:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这里的一个非常重要的教训是；*100%的代码覆盖率不应该是你的目标*。理解你的领域和应用程序的架构，可以让你对代码覆盖率的估计更加可达和现实。
- en: Gives you the confidence to change code without repercussions
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你有信心改变代码而不会产生副作用。
- en: Gives you belief that the product you were asked to deliver, is the product
    you have created
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你相信，你被要求交付的产品，是你已经创建的产品。
- en: Covering the exceptions
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖异常情况。
- en: 'Continuing with our examination of the coverage report will lead us to discover
    another block that is not exercised by our current tests. The block in question
    is the last catch in the following try-catch block in `app/TemperatureConverterActivity`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 继续检查覆盖率报告，我们会发现另一个未被当前测试执行的代码块。这个问题出现在`app/TemperatureConverterActivity`中的以下try-catch块的最后一个catch中：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First things first, why are we catching generic `Exception`? Let's make this
    more specific to the error we are expecting to handle. That way we don't handle
    exceptions we aren't expecting, and also if someone reads the code they will know
    explicitly what we are trying to do here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为什么要捕获通用的`Exception`？让我们将其更具体地针对我们期望处理的错误。这样我们就不会处理那些我们不期望的异常，而且如果有人阅读代码，他们会明确知道我们在这里试图做什么。
- en: 'Now we know what code is causing us not to have full test coverage, we know
    what tests to write to throw this exception and update our test suite and our
    Jacoco report:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了导致我们测试覆盖率不全的代码，我们知道要编写哪些测试来抛出这个异常，并更新我们的测试套件和Jacoco报告。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should provide a test, or better a pair of tests, one for each temperature
    unit that given an invalid temperature verifies that the error is displayed. The
    following is the test in `TemperatureConverterActivityTests` for the Celsius case,
    and you can easily convert it to provide the Fahrenheit case:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该提供一个测试，或者更好的是，对于每个温度单位都有一对测试，给定一个无效温度，验证错误是否显示。以下是 `TemperatureConverterActivityTests`
    中的针对摄氏度情况的测试，你可以轻松地将其转换为提供华氏度情况：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We request the focus for the field under test. As we did before, we should achieve
    this by using a Runnable on the UI thread otherwise we will receive an exception.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求对测试字段进行焦点定位。像之前一样，我们应该通过在 UI 线程上使用 Runnable 来实现这一点，否则我们将收到异常。
- en: Then set the invalid temperature and retrieve the error message to verify that
    it is not null. Running the end-to-end process again, we can attest that the path
    is now covered, giving us total coverage as intended.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置无效温度并获取错误信息以验证它不为空。再次运行端到端流程，我们可以证实现在该路径已覆盖，实现了我们预期的完全覆盖。
- en: This is the iterative process you should follow to change as much as possible
    of the code to green. As was said before, when the line of code is not green,
    as long as you have considered the options and are still confident in changing
    other code while this path is untested, then that is ok.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你应该遵循的迭代过程，尽可能将代码改为绿色。如前所述，只要代码行不是绿色的，只要你考虑过选项并且仍然自信在未测试的路径中改变其他代码，那么这是可以的。
- en: Introducing Robotium
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Robotium
- en: One component of the vast emerging robotic fauna is Robotium ([http://robotium.org](http://robotium.org)),
    a test framework created to simplify the writing of tests, requiring minimal knowledge
    of the application under test. Robotium is mainly oriented to writing powerful
    and robust automatic black-box test cases for Android applications. It can cover
    function, system, and acceptance test scenarios, even spanning multiple Android
    activities of the same application automatically. Robotium can also be used to
    test applications that we don't have the source code for, or even pre-installed
    applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多新兴的机器人生态中，Robotium ([http://robotium.org](http://robotium.org)) 是一个旨在简化测试编写的测试框架，它要求对被测应用有最少的了解。Robotium
    主要定位于为 Android 应用编写强大且健壮的自动黑盒测试用例。它可以覆盖功能测试、系统测试和验收测试场景，甚至可以自动跨越同一应用中的多个 Android
    活动。Robotium 也可以用来测试我们没有源代码的应用，甚至是预装的应用。
- en: Let's put Robotium to work creating some new tests for `TemperatureConverter`.
    To keep our tests organized, we create a new package named `com.blundell.tut.robotium`
    in our `TemperatureConverter` project, under the `androidTest` directory. We will
    initially be testing `TemperatureConverterActivity`, it is reasonable to call
    it `TemperatureConverterActivityTests,` even though we already have a class with
    the same name in another package also extending `ActivityInstrumentationTestCase2`.
    After all, this class will contain tests for this same Activity too.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Robotium 为 `TemperatureConverter` 创建一些新的测试。为了使我们的测试更有条理，我们在 `TemperatureConverter`
    项目的 `androidTest` 目录下创建了一个名为 `com.blundell.tut.robotium` 的新包。我们最初将测试 `TemperatureConverterActivity`，将其命名为
    `TemperatureConverterActivityTests` 是合理的，尽管我们在另一个包中已经有了一个同名且也扩展了 `ActivityInstrumentationTestCase2`
    的类。毕竟，这个类也将包含对此同一 Activity 的测试。
- en: Adding Robotium
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Robotium
- en: 'Let''s add Robotium to our project, we''ll only be using it in test cases and
    so it should go on the `testcase` classpath. As of this writing, the latest version
    of Robotium is 5.2.1\. In `app/build.gradle`, we add the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中添加 Robotium，我们只会在测试用例中使用它，所以它应该放在 `testcase` 类路径上。在撰写本文时，Robotium 的最新版本是
    5.2.1。在 `app/build.gradle` 中，我们添加以下内容：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating the test cases
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试用例
- en: From the previous chapters, we know that if we are creating test cases for an
    Activity that should run connected to the system infrastructure, we should base
    it on `ActivityInstrumentationTestCase2`, and that is what we are going to do.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节中我们知道，如果我们正在为需要连接到系统基础设施的 Activity 创建测试用例，我们应该基于 `ActivityInstrumentationTestCase2`，这也是我们将要做的。
- en: The testFahrenheitToCelsiusConversion() test
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 Fahrenheit 到 Celsius 转换的 testFahrenheitToCelsiusConversion()
- en: 'More or less the test cases have the same structure as other Instrumentation-based
    tests. The main difference is that we need to instantiate Robotium''s Solo in
    the test `setUp(),` and clean up Robotium in the `tearDown()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试用例的结构与其他基于 Instrumentation 的测试类似。主要区别在于我们需要在测试的 `setUp()` 中实例化 Robotium
    的 Solo，并在 `tearDown()` 中清理 Robotium：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To instantiate Solo, we have to pass a reference to the `Instrumentation` class
    and to the Activity under test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化 Solo，我们必须传递对 `Instrumentation` 类和被测 Activity 的引用。
- en: On the other hand, to clean up Solo we should call the `finishOpenedActivities()`
    method. This will finalize Solo and then finish our Activity, and we then invoke
    `super.tearDown()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了清理 Solo，我们应该调用 `finishOpenedActivities()` 方法。这将结束 Solo 并完成我们的 Activity，然后我们调用
    `super.tearDown()`。
- en: 'Solo provides a variety of methods to drive UI tests and some assertions. Let''s
    start by re-implementing the `testFahrenheitToCelsiusConversion()` that we previously
    implemented using the conventional approach, but in this case using Solo facilities:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Solo 提供了多种方法来驱动UI测试和一些断言。让我们从重新实现之前使用传统方法实现的 `testFahrenheitToCelsiusConversion()`
    测试方法开始，但这次使用 Solo 的设施：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is pretty similar, however, the first difference you may have noticed
    is that in this case we are not getting references to the UI elements as we previously
    did in the `setUp()` method, using `findViewById()` to locate the view. However,
    we are using one of the biggest advantages of Solo, which is locating the views
    for us using some criteria. In this case, the criterion is the order in which
    the EditText appears. The `solo.clearEditText(int index)` method expects an integer
    index of the position on the screen starting from `0`. Consequently, we should
    add these constants to the test case, just like in our user interface the Celsius
    field is on top, and Fahrenheit beneath:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常相似，然而，你可能注意到的第一个不同之处是，在这种情况下，我们没有像之前在 `setUp()` 方法中那样获取UI元素的引用，使用 `findViewById()`
    来定位视图。然而，我们正在使用 Solo 的最大优势之一，它使用某些标准为我们定位视图。在这种情况下，标准是 EditText 出现的顺序。`solo.clearEditText(int
    index)` 方法期望一个从 `0` 开始的屏幕位置的整数索引。因此，我们应该将这些常量添加到测试用例中，就像在我们的用户界面中，摄氏度字段在顶部，华氏度在下方：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The other Robotium methods follow the same convention, and we are supplying
    these constants when necessary. This test is very similar to the one in `com.blundell.tut.TemperatureConverterActivityTest,`
    but you may have noticed that there is a subtle difference. Robotium is located
    at a much higher level and we don't have to worry about as many internals or implementation
    details; for example, when in our previous test we invoked `celciusInput.requestFocus()`
    to trigger the conversion mechanism, here we just simulate what the user does
    and issue a `solo.clickOnEditText(CELSIUS)`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 Robotium 方法遵循相同的约定，我们在必要时提供这些常量。这个测试与 `com.blundell.tut.TemperatureConverterActivityTest`
    中的测试非常相似，但你可能已经注意到有一个微妙的区别。Robotium 位于更高的层次，我们不必担心许多内部或实现细节；例如，在我们之前的测试中，我们调用
    `celciusInput.requestFocus()` 来触发转换机制，而在这里，我们只需模拟用户的行为并发出 `solo.clickOnEditText(CELSIUS)`。
- en: We simplified the test sensibly, but the biggest advantage of using Solo is
    yet to come.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们合理地简化了测试，但使用 Solo 的最大优势尚未到来。
- en: Testing between Activities
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在活动之间进行测试
- en: As Robotium is situated at a much higher level, and we don't deal with implementation
    details, it is not our problem if a new Activity is launched when we click on
    an Android widget; we only treat this case from the UI perspective.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Robotium位于更高层次，并且我们不处理实现细节，如果点击Android小部件时启动了新的Activity，这并不是我们的问题；我们仅从UI的角度处理这种情况。
- en: Here, I am going to discuss some functionality theoretically. This has not yet
    been created and is left up to the user as a further step, if you so wish.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将从理论上讨论一些功能。这尚未创建，留给用户作为进一步步骤，如果你愿意的话。
- en: Now that we have a working temperature converter, it would be nice if we could
    let the user decide up to how many decimal places they want to see a conversion.
    Allowing the user to change this option, via an Android Dialog, sounds like a
    sensible option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有一个工作的温度转换器，如果我们能让用户决定他们想要看到的小数位数，那就太好了。通过Android对话框让用户更改此选项听起来是一个明智的选择。
- en: Our purpose is to change the value of decimal places preference to five, and
    verify that the change actually took place. Because of the high level of Robotium,
    this test is readable and understandable without actually having the functionality
    implemented. This is an example of a BDD approach to implement this feature.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是将小数位数偏好值更改为五位，并验证更改确实发生了。由于 Robotium 的高层次，这个测试在没有实际实现功能的情况下也是可读和可理解的。这是实现此功能的一种BDD方法的例子。
- en: 'The following code snippet illustrates the details of the test:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了测试的细节：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are no gory details about how shared preferences and options menus are
    implemented. We only test its functionality. We start by pressing the **MENU**
    key and clicking on **Preferences**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于共享首选项和选项菜单如何实现，这里没有详细的介绍。我们只测试它的功能性。我们从按下**菜单**键并点击**首选项**开始。
- en: Wow, we just specified the menu item title and that's it!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们刚刚指定了菜单项标题，就完成了！
- en: The new Activity has started, but we don't have to worry about that implementation
    detail. We continue and click on **Decimal** **places**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 新的活动已经启动，但我们不必担心那个实现细节。我们继续点击 **小数位数**。
- en: We verify that some field containing a number, the prior value of this preference,
    appeared. Do you remember what I said about regular expressions? They always come
    in handy in one way or another, to match any decimal integer number (any digit
    followed by zero or more digits). Then, we clear the field and verify that it
    was in fact cleared.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证是否出现了一些包含数字的字段，即此首选项的前一个值。还记得我说的正则表达式吗？它们总会在某种程度上派上用场，来匹配任何十进制整数（任意数字后跟零个或多个数字）。然后，我们清除字段并验证它确实被清除了。
- en: We enter the string, representing the number we want to use as a preference,
    5 in this case. Click on the **OK** button and the preference is saved.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入希望用作首选项的数字字符串，在这个例子中是5。点击**确定**按钮，首选项即被保存。
- en: Finally, we need to verify that it actually happened. The same procedure is
    used to get the menu and the field. Finally, we verify that the actual number
    is already there.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要验证它实际上是否已经发生。使用相同的程序来获取菜单和字段。最后，我们验证实际的数字是否已经存在。
- en: 'You may wonder where `DECIMAL_PLACES` come from. We previously defined `CELSIUS`
    and `FAHRENHEIT` index constants for the fields on the screen, and this is the
    same case, because this will be the third EditText we should define in our class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇 `DECIMAL_PLACES` 来自哪里。我们之前为屏幕上的字段定义了 `CELSIUS` 和 `FAHRENHEIT` 索引常量，这也是同样的情况，因为这将是我们类中应该定义的第三个
    EditText。
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tests can be run from your IDE or the command line, according to your preferences.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以根据你的喜好从 IDE 或命令行运行。
- en: Testing on the host's JVM
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在宿主的 JVM 上进行测试
- en: We left this subject for the end of this chapter, as it seems this is the *Holy
    Grail* of the Android platform.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个主题留到了本章的末尾，因为这看起来像是 Android 平台的*圣杯*。
- en: Android is based on a virtual machine named **Dalvik**, after a village in Iceland,
    optimized for mobile resources with limited capabilities such as constrained amount
    of memory and processor speed. Thus representative of a mobile device but certainly
    a very different environment than our memory rich and speedy host computers, typically
    having plenty of memory and processor speed to enjoy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Android 基于一个名为 **Dalvik** 的虚拟机，以冰岛的一个村庄命名，该虚拟机针对的是资源有限的移动设备，如内存和处理速度有限。因此，它代表了移动设备，但与我们的内存丰富、速度快的宿主计算机环境肯定大不相同，后者通常拥有充足的内存和处理速度来享受。
- en: Ordinarily, we run our applications and tests on an emulator or device. These
    targets have a much slower real or emulated CPU. Thus, running our tests is a
    time-consuming activity, mainly when our project starts to grow. Applying Test-driven
    Development techniques compels us to run hundreds of tests to verify every change
    we introduced.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在模拟器或设备上运行我们的应用程序和测试。这些目标有一个更慢的真实或模拟 CPU。因此，运行我们的测试是一个耗时的活动，特别是当我们的项目开始增长时。应用测试驱动开发技术迫使我们运行数百个测试来验证我们引入的每一项更改。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noticing that this technique can be used only as a workaround during
    the development process to speed things up, and it should never replace final
    testing on the real platform, as incompatibilities between the Dalvik and JavaSE
    runtime may affect the accuracy of the tests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这项技术只能在开发过程中作为权宜之计来提高速度，绝不能替代在真实平台上的最终测试，因为 Dalvik 和 JavaSE 运行时之间的不兼容可能会影响测试的准确性。
- en: We are half way there already with the creation of our core module. Now we are
    in the Java world and free to run our tests on the JVM (and use JUnit4, coming
    to an Android near you soon). There is one-way dependency from the `app` Android
    module to the core Java module. Allowing us to free ourselves from the shackles
    of Android testing, encumbrance when running tests in the `core` module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了核心模块创建的一半工作。现在我们处于 Java 世界，可以在 JVM 上自由运行我们的测试（很快就可以在附近的 Android 上使用 JUnit4）。`app`
    Android 模块对核心 Java 模块有一个单向依赖。这使得我们可以摆脱 Android 测试的束缚，在 `core` 模块中运行测试时不受其拖累。
- en: Later, we should find out a method that allows us to intercept the standard
    compilation-dexing-running on an emulator or a device sequence, and be able to
    run Android on our host computer directly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们应该找出一种方法，允许我们拦截在模拟器或设备上标准编译-dexing-运行的序列，并能够直接在我们的主机电脑上运行安卓。
- en: Comparing the performance gain
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较性能提升。
- en: A quick reminder about the speed gain when running these Java-only tests compared
    to Android instrumentation tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，与安卓仪器测试相比，运行这些仅Java的测试所获得的速度提升。
- en: The distinction is evident. There is no emulator start up, or any device communication,
    and therefore the speed gain is important. Analyzing the evidence, we can find
    out these differences.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 区别很明显。没有模拟器的启动，或者任何设备通信，因此速度的提升是重要的。通过分析证据，我们可以找出这些差异。
- en: Running all tests in my development computer takes 0.005 seconds; with some
    tests taking so little time that they are not even accounted for, and are displayed
    as 0.000 seconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的开发电脑上运行所有测试需要0.005秒；有些测试耗时如此之少，以至于它们甚至没有被计算在内，显示为0.000秒。
- en: If I move these tests to our app module, and run the same tests on the emulator,
    this makes the huge difference evident. These same tests took 0.443 seconds to
    run, almost 100 times more, and that's a huge difference if you consider hundreds
    of tests running, tens of times a day.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将这些测试移动到我们的应用模块，并在模拟器上运行相同的测试，这将使巨大的差异变得明显。这些相同的测试运行了0.443秒，几乎慢了100倍，如果你考虑到每天要运行数百次测试，这是一个巨大的差异。
- en: It is also good to notice that other advantages exist, besides the speed gain,
    and they are the availability of years of Java, tooling, library, and plugin creation,
    including several mock frameworks and code analysis tools.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，除了速度提升之外，还有其他优势，包括多年来的Java工具、库和插件创建，包括多个模拟框架和代码分析工具。
- en: Adding Android to the picture
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将安卓纳入考虑范围
- en: We intentionally left Android outside our picture. Let's analyze what happens
    if we include a simple Android test inside `core`. Remember that for an Android
    test to compile `android.jar` from the SDK, it should also be added to the modules'
    libraries.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意将安卓排除在考虑范围之外。让我们分析一下，如果在`core`中包含一个简单的安卓测试会发生什么。请记住，为了编译来自SDK的`android.jar`，安卓测试也应该被添加到模块的库中。
- en: 'And here is what we obtain:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们得到的结果：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding the `android.jar` to the class path for core is slightly awkward and
    longwinded. It is not something that is done by default. This is a good thing
    as it stops us accidentally using Android-specific classes when writing code inside
    core.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将`android.jar`添加到core的类路径稍微有些不协调且冗长。这不是默认会做的事情。这是一个好事，因为它阻止我们在编写核心代码时意外使用安卓特定的类。
- en: 'The reason is that `android.jar` provides only the API, not the implementation.
    All methods have the same implementation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于`android.jar`只提供了API，而不是实现。所有方法都有相同的实现：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we want to circumvent this limitation to test some classes outside of the
    Android operating system, we should create an `android.jar` that mocks every class.
    However, we would also find problems for subclasses of Android classes, like `TemperatureConverterApplication`.
    This would be a daunting task and a significant amount of work, so we should look
    for another solution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要绕过这个限制，以在安卓操作系统之外测试某些类，我们应该创建一个模拟每个类的`android.jar`。然而，我们也会发现对于安卓类的子类，如`TemperatureConverterApplication`，存在问题。这将是一项艰巨的任务，并且需要大量的工作，所以我们应该寻找另一个解决方案。
- en: Introducing Robolectric
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Robolectric
- en: '**Robolectric** ([http://robolectric.org](http://robolectric.org)) is a unit
    test framework that intercepts the loading of Android classes and rewrites the
    method bodies. Robolectric re-defines Android methods so they return default values,
    such as `null`, `0`, or `false`. If available, it forwards method calls to shadow
    objects, mimicking Android behavior.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Robolectric**（[http://robolectric.org](http://robolectric.org)）是一个单元测试框架，它拦截安卓类的加载并重写方法体。Robolectric重新定义了安卓方法，使它们返回默认值，如`null`、`0`或`false`。如果可能，它会将方法调用转发给影子对象，模仿安卓行为。'
- en: A large number of shadow objects are provided, but this is far from complete
    coverage, however, it is improving constantly. This should also lead you to treat
    it as an evolving open source project, for which you should be ready to contribute
    to make it better, but also to depend on it with caution because you may discover
    that what you need for your tests has not been implemented yet. This is not in
    any way to diminish its existing prospects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了大量的阴影对象，但这远未完全覆盖，然而，它正在不断改进。这也应该让你将其视为一个不断发展的开源项目，你应当准备好为使其更好而贡献，但也应谨慎依赖它，因为你可能会发现你测试所需的功能尚未实现。这绝不是为了贬低它现有的前景。
- en: Installing Robolectric
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Robolectric
- en: 'Robolectric can be installed by using the latest Robolectric JAR from the Maven
    central repository. At the time of this writing, the latest available is version
    2.4:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 Maven 中央仓库中的最新 Robolectric JAR 来安装 Robolectric。在撰写本文时，最新的可用版本是 2.4：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Usually, adding a dependency is as simple as this one line, however, with Robolectric
    a bit of jiggery pokery is needed for it to work with the Gradle build types.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，添加依赖项只需这一行代码，但是，对于 Robolectric 来说，需要一些小技巧才能使其与 Gradle 构建类型一起工作。
- en: 'First, Robolectric tests require their own module to run in. This is nothing
    new. Create a new Java module, we''ll call it `robolectric-tests`. Keep the package
    the same as always `com.blundell.tut`. Now, we have to modify the `robolectric-tests/build.gradle,`
    so we can hook Robolectric in place of the `android.jar`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Robolectric 测试需要在其自己的模块中运行。这并不是什么新鲜事。创建一个新的 Java 模块，我们称之为 `robolectric-tests`。包名保持不变，始终为
    `com.blundell.tut`。现在，我们必须修改 `robolectric-tests/build.gradle`，以便我们可以用 Robolectric
    替换 `android.jar`：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a big chunk of configuration to take in, let's break it down into steps.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大块需要理解的配置，让我们将其分解成步骤。
- en: Firstly, we define the module name for our Android application, and then we
    name the flavor that we will want to test against.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的 Android 应用定义模块名称，然后命名我们将要测试的版本。
- en: The `EvaluationDependsOn` class tells Gradle to ensure that our application
    module is evaluated before our tests, this stops any strange errors from order
    of execution quirks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`EvaluationDependsOn` 类告诉 Gradle 在执行我们的测试之前确保我们的应用程序模块被评估，这避免了因执行顺序的怪癖而出现任何奇怪的错误。'
- en: Next, we apply the java plugin as per normal convention for a Java project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照 Java 项目的正常约定应用 java 插件。
- en: The dependencies closure is where we add all of the Android dependencies to
    our classpath. First, we add the selected build variant of our module, `debug`,
    then the classpath and its dependencies, also ensuring we have system dependencies
    from our Android plugin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项闭包是我们将所有 Android 依赖项添加到我们的类路径中的地方。首先，我们添加模块的选定构建变体 `debug`，然后是类路径及其依赖项，同时确保我们有来自
    Android 插件的系统依赖项。
- en: Lastly, we apply JUnit4 and Robolectric as test dependencies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 JUnit4 和 Robolectric 作为测试依赖项应用。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, if you have multiple product flavors and build types, then this configuration
    needs the full build variant adding to the script. It would be pretty straightforward
    to amend this build script.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你有多个产品版本和构建类型，那么这个配置需要将完整的构建变体添加到脚本中。修改这个构建脚本将会非常简单直接。
- en: Adding resources
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加资源
- en: 'When you run your tests, Robolectric attempts to look up your `AndroidManifest.xml`
    so it can find resources for your application, and know about your target SDK
    version, among other properties. With the current Robolectric version and our
    choice of using a separate module, Robolectric cannot find your resources or your
    Android manifest. You can still write tests and get feedback without this optional
    step, but you may find some strangeness when accessing classes that use resources;
    for example, `R.string.hello_world,` and will get messages like this in your console:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行测试时，Robolectric 尝试查找你的 `AndroidManifest.xml` 以便它能为你的应用程序找到资源，并了解你的目标 SDK
    版本等其他属性。由于当前 Robolectric 版本和我们对单独模块的选择，Robolectric 无法找到你的资源或你的 Android 清单。即使没有这一可选步骤，你仍然可以编写测试并获得反馈，但当你访问使用资源的类时，可能会遇到一些奇怪的现象；例如，`R.string.hello_world,`
    在你的控制台可能会看到这样的信息：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This can be fixed by doing as it says with an `@Config` annotation, or creating
    a custom test runner that specifies the manifest location or as we choose to do
    here, creating a configuration file and adding it to your classpath. Inside the
    `robolectric-tests` module, create the folder `/src/test/resources,` and create
    a file `org.robolectric.Config.properties`. This will contain our Android manifest
    location; it will also contain our minimum SDK version, as we don''t state this
    in our manifest. It will have these contents:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`@Config`注解按其说明操作，或者创建一个自定义测试运行器指定清单位置，或者像我们在这里选择的做法一样，创建一个配置文件并将其添加到你的类路径中，可以解决这个问题。在`robolectric-tests`模块内，创建文件夹`/src/test/resources`，并创建一个文件`org.robolectric.Config.properties`。这将包含我们的Android清单位置；它还将包含我们的最小SDK版本，因为我们在清单中没有声明这一点。它将包含以下内容：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Robolectric attempts to look up your minimum SDK inside the `AndroidManifest.xml`.
    However, with the Gradle build system you do not declare it here, but declare
    it in the `app/build.gradle`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Robolectric尝试在`AndroidManifest.xml`中查找你的最小SDK。但是，在使用Gradle构建系统时，你不在那里声明，而是在`app/build.gradle`中声明。
- en: We are now set up and ready to create some Robolectric tests!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置好并准备编写一些Robolectric测试！
- en: Writing some tests
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一些测试
- en: 'We will get acquainted with Robolectric by reproducing some of the tests we
    wrote before. One good example can be re-writing the `EditNumber` tests. Let''s
    create a new `EditNumberTests` class, this time in the newly created project,
    and copy the tests from the `EditNumberTests` class in the `TemperatureConverterTest`
    project:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过复现之前编写的一些测试来熟悉Robolectric。一个好的例子是重写`EditNumber`测试。让我们在新建的项目中创建一个新的`EditNumberTests`类，并从`TemperatureConverterTest`项目中的`EditNumberTests`类复制测试：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are highlighting the most important changes. The first one is to specify
    the test runner JUnit that will delegate the processing of the tests to, by using
    the annotation `@RunWith`. In this case, we need to use `RobolectricTestRunner.class`
    as the runner. Then we create an `EditText` class, using a Robolectric Context,
    as this is a class that couldn't be instantiated without some help. Finally, a
    `DELTA` value is specified in `testGetNumber` as `assertEquals` since, the floating
    point number requires it in JUnit 4\. Additionally, we added the `@Test` annotation
    to mark the method as tests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调最重要的变化。第一个是指定测试运行器JUnit的注解`@RunWith`，这将委托测试处理。在这种情况下，我们需要使用`RobolectricTestRunner.class`作为运行器。然后我们使用Robolectric上下文创建一个`EditText`类，因为这是一个没有帮助就无法实例化的类。最后，在`testGetNumber`中指定了`DELTA`值，因为JUnit
    4中的浮点数需要它。此外，我们添加了`@Test`注解以将方法标记为测试。
- en: The other test methods that existed in the original `EditNumberTests` cannot
    be implemented, or simply fail for a variety of reasons. For example, as we mentioned
    before, Robolectric classes return default values, such as `null`, `0`, `false`,
    and so on, and this is the case for `Editable.Factory.getInstance(),` which returns
    null and causes the test to fail; because there is no other way of creating an
    `Editable` object, we are at a dead end.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 原始`EditNumberTests`中存在的其他测试方法无法实现，或者由于各种原因简单地失败。例如，正如我们之前提到的，Robolectric类返回默认值，如`null`、`0`、`false`等，`Editable.Factory.getInstance()`也是如此，它返回null并导致测试失败；因为没有其他创建`Editable`对象的方法，我们陷入了僵局。
- en: Similarly, the `InputFilter` that `EditNumber` sets is non functional. It is
    futile to create a test that expects some behavior.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`EditNumber`设置的`InputFilter`是非功能的。创建一个期望某些行为的测试是徒劳的。
- en: The alternative to these shortcomings would be to create `Shadow` classes, but
    this requires alteration of the Robolectric source and the creation of `Robolectric.shadowOf()`
    methods. This procedure is described in the documentation that you may follow,
    if you are interested in applying this approach to your tests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺点的替代方法是创建`Shadow`类，但这需要修改Robolectric源代码并创建`Robolectric.shadowOf()`方法。如果你有兴趣将这种方法应用于你的测试，可以遵循文档中描述的此过程。
- en: Having identified these issues, we can proceed to run the tests, and they will
    run in the host's JVM with no need to start or communicate with an emulator or
    device.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 识别出这些问题后，我们可以继续运行测试，它们将在宿主的JVM中运行，无需启动或与模拟器或设备通信。
- en: Google's march on shadows
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌对阴影的进军
- en: For some reason, Google does not *like* Robolectric, they've never acknowledged
    that it works, or never said that it's a solution to a problem. If they ignore
    the solution, then that means the problem of slow running tests doesn't exist,
    right. They seem to feel that Robolectric detracts from Android, and so have kind
    of publicly given it the cold shoulder. Surreptitiously pushing it away by ignoring
    its existence, that is up until now.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，谷歌并不*喜欢* Robolectric，他们从未承认它有效，也从未说过它是解决问题的方案。如果他们忽视这个解决方案，那么意味着缓慢运行的测试问题不存在，对吧。他们似乎觉得Robolectric有损于Android，因此在某种程度上公开地对其冷淡。通过忽略其存在来暗中排挤它，直到现在。
- en: Google has created exactly what we said before, an `android.jar` file with default
    method implementations. This means no more `stub!` errors when accessing a method.
    Further, they have removed all of the `final` modifiers from classes, allowing
    mocking Frameworks to have a field day. Unfortunately, at the time of this writing
    it is undocumented. No surprise! I don't want to give usage steps, as while undocumented
    these will be changing rapidly. However, what I will say is, if Google got this
    right, then it means for the testing scenario described previously, Robolectric
    is out of the window, and we can use the standard Android testing SDKs. The same
    principles will apply, and so I think it's still valuable if you understand how
    Robolectric works. You can apply this understanding to the future that I cannot.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌创建了一个与我们之前所说的完全一样的 `android.jar` 文件，其中包含了默认方法实现。这意味着在访问方法时不再出现 `stub!` 错误。此外，他们已经从所有类中移除了
    `final` 修饰符，让模拟框架有了很大的发挥空间。不幸的是，在撰写本文时，这个功能尚未记录在案。不足为奇！我不想给出使用步骤，因为虽然未记录在案，但这些内容会迅速变化。然而，我要说的是，如果谷歌做对了这件事，那么对于之前描述的测试场景，Robolectric就不再需要，我们可以使用标准的Android测试SDK。同样的原则将适用，因此我认为如果你了解Robolectric的工作原理，这仍然是有价值的。你可以将这种理解应用到未来，而我不能。
- en: Introducing Fest
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Fest
- en: Another weapon for our testing arsenal is better testing assertions. Have you
    noticed how sometimes stacktraces for failed tests are really unfriendly and/or
    mystically wrong? They give you little information about the real failure and
    you end up confused, having to read the entire source to fathom out how to fix
    the problem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试武器库中的另一个工具是更好的测试断言。你有没有注意到，有时失败的测试堆栈跟踪非常不友好和/或神秘地错误？它们没有提供关于实际失败的有用信息，你最终会感到困惑，不得不阅读整个源代码以弄清楚如何解决问题。
- en: 'As an example, look at this assertion:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个断言为例：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are asserting that a collection of objects after some task has a size of
    three, look at our error message when the test fails:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言在执行某个任务后，对象集合的大小为三个，看看测试失败时的错误信息：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Ok, that kind of makes sense, but it''s a bit abstract. What item is missing
    from our list? I am going to have to run the tests again to find out, or I could
    add a custom error message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有点道理，但有点抽象。我们的列表中缺少哪一项？我得重新运行测试才能找出答案，或者我可以添加一个自定义错误信息：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Giving me the error message:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 给我这样的错误信息：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That error message is much better. It shows I'm missing `C` from my list. However,
    looking back at the assertion, it's getting kind of unreadable. Sometimes, at
    a glance, it might even appear like I am trying to assert whether that initial
    string is equal to the other vars, the parameter ordering does not help at all.
    What if I had another object that doesn't so easily implement `toString`? I would
    need to create more custom code to print a nice error message, probably repeating
    myself quite a lot with boiler plate error messages.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息好多了。它显示我的列表中缺少了 `C`。但是，回顾一下这个断言，它的可读性越来越差。有时，一眼看去，我可能甚至会觉得我在尝试断言初始字符串是否等于其他变量，参数的顺序根本没有帮助。如果我有一个不容易实现
    `toString` 的对象呢？我需要编写更多自定义代码来打印一个友好的错误信息，可能还会重复很多样板错误信息。
- en: 'Stop all that worrying right now! Take a look at how we can do the same assertion
    with Fest:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在立刻停止所有担忧！看看我们如何使用Fest进行同样的断言：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, our error message looks like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的错误信息看起来像这样：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Nice, with no extra effort by us, we get an error message showing us what is
    in the list and how the sizes differentiate. Also looking back at the assertion,
    it's much more readable and even coding it was easier with the fluid interface.
    This improves the readability of our test code, and speeds up debugging and test
    fixing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，我们没有额外付出努力，就得到了一个错误信息，它向我们展示了列表中的内容以及大小是如何区分的。回顾一下这个断言，它的可读性更强了，而且使用流畅的接口编码也变得更容易。这提高了我们测试代码的可读性，加快了调试和测试修复的速度。
- en: 'After doing this change, I came to realize we actually might have wanted to
    test the contents of the List, but due to the encumbrance of the JUnit assertions,
    we were not bothering. Fest to the rescue once more:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个更改之后，我意识到我们实际上可能想要测试列表的内容，但由于 JUnit 断言的负担，我们没有这么做。再次，Fest 来拯救：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Think how we would have had to do that with JUnit assertions, and I think you'll
    appreciate the power of Fest.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 想想如果我们用 JUnit 断言来做这件事，你就会更加欣赏 Fest 的强大。
- en: 'Fest comes in multiple flavors for assertions on different libraries; these
    include the java flavor, as shown previously, and an Android flavor, which allows
    you to do fluid-style interface assertions on Android components, like Views and
    Fragments. Here is an example of JUnit asserting visibility, and then Fest:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Fest 提供了多种断言风格，适用于不同的库；这些包括前面展示的 Java 风格，以及允许你对 Android 组件（如视图和片段）进行流畅式界面断言的
    Android 风格。以下是 JUnit 断言可见性的示例，然后是 Fest：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Adding either library to your project is just another Gradle dependency, the
    latest versions can be found on Maven central. Here is the example for Java fest,
    the latest at the time of writing:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些库添加到你的项目中，只需再添加一个 Gradle 依赖项，最新版本可以在 Maven 中央仓库找到。以下是 Java 版 Fest 的示例，截至撰写本文时的最新版本：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note, that Android Fest has been rebranded into Assert-J and is split into many
    dependencies depending on what you want to test. The assertions will work exactly
    the same way. More information and instructions to add as a dependency can be
    found at [https://github.com/square/assertj-android](https://github.com/square/assertj-android).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Android Fest 已经更名为 Assert-J，并根据你的测试需求拆分为多个依赖项。断言的工作方式将完全相同。更多信息以及作为依赖项添加的说明可以在
    [https://github.com/square/assertj-android](https://github.com/square/assertj-android)
    找到。
- en: Introducing Spoon
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Spoon
- en: Device fragmentation is always talked about around Android and it is something
    you should be considerate of. The number of different devices and form factors
    means you really need to be confident that your application runs well, on all
    the aforementioned. Spoon is right here to help; Spoon ([http://square.github.io/spoon](http://square.github.io/spoon))
    is an open-source project that gives you a test runner that allows instrumentation
    tests to be run on all connected devices in parallel. It also allows you to take
    screenshots as the tests are running. Not only does this speed up your testing
    and feedback cycle, it also allows you to potentially visually see where tests
    went wrong.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 设备碎片化一直是 Android 的话题，这是你应该考虑的问题。不同设备和外形尺寸的数量意味着你真的需要确信你的应用程序在所有上述设备上都能良好运行。Spoon
    正是为了帮助解决这个问题；Spoon ([http://square.github.io/spoon](http://square.github.io/spoon))
    是一个开源项目，提供了一个测试运行器，允许在所有连接的设备上并行运行仪器测试。它还允许你在测试运行时截图。这不仅加快了你的测试和反馈周期，还可能让你直观地看到测试出错的地方。
- en: 'Spoon can be added to your project with this dependency:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加以下依赖关系将 Spoon 加入到你的项目中：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can then take screenshots inside your tests, allowing you to see the state
    of your application when you are also asserting behavior:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在测试中截图，这样在断言行为的同时，你也可以看到应用程序的状态：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you take the screenshot right before your assertion, you can use the screenshots
    to help you determine failures. Another cool feature is Spoon will collate your
    screenshots from one test into an animated GIF. so you can watch the sequence
    of events.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在断言之前立即截图，可以利用这些截图帮助你确定失败的原因。另一个很酷的功能是，Spoon 会将一个测试中的所有截图合成为一张动画 GIF，这样你可以观看事件的发生顺序。
- en: 'Spoon is then run from the command line, using this command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以从命令行运行 Spoon，使用以下命令：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find your APK files inside the `/build/` folder. If you need more information
    of using the APK files in this way, and testing from the command line, take a
    look back at [Chapter 7](part0068_split_000.html#page "Chapter 7. Behavior-driven
    Development"), *Behavior-driven Development*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `/build/` 文件夹中找到你的 APK 文件。如果你需要更多关于这种使用 APK 文件的方式以及从命令行测试的信息，请回顾 [第7章](part0068_split_000.html#page
    "第7章. 行为驱动开发")，*行为驱动开发*。
- en: Introducing Fork
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Fork
- en: Another humorous name for a library, but stick with it reader, this similarity
    is not just a co-incidence. After telling you how amazing Spoon is at speeding
    up your tests by running all your instrumentation tests in parallel on all connected
    devices, well here comes Fork, to tell you that this naïve scheduling (their words
    not mine), is a burden on yourself and your CI. Fork can run your tests even faster!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个带有幽默感的库名称，但读者请继续看下去，这种相似性并非巧合。在告诉了你Spoon如何通过在所有连接的设备上并行运行所有仪器测试来加速你的测试之后，现在来了Fork，它告诉你这种天真的调度（他们的话，非我的）对你和你的CI来说是个负担。Fork能让你更快地运行测试！
- en: Fork increases your tests' speed by introducing a concept called **Device Pools**.
    In simple terms, imagine you had two identical devices, which are two Sony Xperia
    Z1s running Android 5.0\. Fork will take your test suite and split it in half,
    running half the tests on each device. Thus, it saves you 50 percent of the test
    run speed (roughly excluding warm up/setup time).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Fork通过引入一个名为**设备池**的概念来提高你的测试速度。简单来说，想象一下你有两个完全相同的设备，都是运行Android 5.0的两台索尼Xperia
    Z1。Fork将获取你的测试套件并将其一分为二，在每个设备上运行一半的测试。因此，它能为你节省大约50%的测试运行速度（大致不包括热身/设置时间）。
- en: These device pools come in different flavors for things such as, api level,
    smallest width, tablet devices, or manual pools, where you declare the device
    serial id you want to use. More information about device pools and custom parameters
    for the fork task can be found at [http://goo.gl/cIm6GQ](http://goo.gl/cIm6GQ).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备池有不同的类型，例如api级别、最小宽度、平板设备或手动池，你可以在其中声明你想使用的设备序列号。关于设备池和fork任务的定制参数的更多信息可以在[http://goo.gl/cIm6GQ](http://goo.gl/cIm6GQ)找到。
- en: 'Fork can be used with Gradle, by adding the plugin to your build script and
    applying it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向你的构建脚本中添加插件并应用它，Fork可以与Gradle一起使用：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, you can run fork tests instead of your normal instrumentation tests with
    this command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令运行fork测试，而不是你正常的仪器测试：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have multiple flavors in your project, you can see what fork tasks are
    available with the command: **./gradlew tasks | grep fork**.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目中有多个flavor，你可以使用以下命令查看可用的fork任务：**./gradlew tasks | grep fork**。
- en: Spoon and Fork are powerful tools, and combined now with your knowledge of instrumentation
    tests, unit testing, benchmarking, and code analysis, you can put together a robust,
    informational, and well-rounded test suite, which gives you confidence and agility
    when it comes to writing your Android applications.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Spoon和Fork是强大的工具，现在结合你对仪器测试、单元测试、基准测试和代码分析的知识，你可以构建一个健壮、信息丰富且全面的测试套件，在编写Android应用程序时，这能给你信心和灵活性。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been a little more involved than previous ones, with the sole
    intention of facing realistic situations and state-of-the-art Android testing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章比之前的章节要深入一些，唯一目的是面对现实情况和最先进的Android测试技术。
- en: We started by enabling code coverage through Jacoco, running our tests, and
    obtaining a detailed code coverage analysis report.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过Jacoco启用代码覆盖率，运行我们的测试，并获得详细的代码覆盖率分析报告。
- en: We then used this report to improve our test suite. Writing tests to cover code
    we were not aware had not been tested. This led us to better tests, and in some
    cases improved the design of the project under test.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用这个报告来改进我们的测试套件。编写测试来覆盖我们之前没有意识到的未测试的代码。这使我们得到了更好的测试，有时也改进了被测试项目的设计。
- en: We introduced Robotium, a very useful tool to ease the creation of test cases
    for our Android applications, and we improved some tests with it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了Robotium，这是一个非常有用的工具，可以简化我们Android应用程序测试用例的创建，并且我们用它改进了一些测试。
- en: Then we analyzed one of the hottest topics in Android testing; testing on the
    development host JVM, optimizing, and reducing considerably the time needed to
    run the tests. Something that is highly desirable when we are applying Test-driven
    Development to our process. Within this scope, we analyzed Robolectric and created
    some tests as demonstrations to get you started on these techniques.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们分析了Android测试中一个热门话题；在开发主机JVM上进行测试，优化并显著减少运行测试所需的时间。当我们把测试驱动开发应用到我们的流程中时，这是非常可取的。在这个范围内，我们分析了Robolectric，并创建了一些测试作为演示，让你开始掌握这些技术。
- en: To round off our knowledge, we looked at Fest and some cutlery these can help
    us have more expressive tests, improved feedback, and a more powerful overall
    test suite.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善我们的知识，我们了解了Fest和一些餐具，它们可以帮助我们进行更有表现力的测试，改进反馈，并使整个测试套件更加强大。
- en: We have reached the end of this journey through the available methods and tools
    for Android testing. You should now be much better prepared to start applying
    this to your own projects. The results will be visible as soon as you begin to
    use them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了通过Android测试的可用的方法和工具的旅程的终点。你现在应该为将这些应用到您自己的项目中做好更充分的准备。一旦开始使用它们，效果就会立即显现。
- en: Finally, I hope that you have enjoyed reading this book as much as I did writing
    it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我希望您阅读这本书的乐趣与我写作它时一样多。
- en: Happy testing!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 祝测试愉快！
