- en: Chapter 5. Animating Our Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We''re off to a great start in our mobile game development journey. We have
    already gone through a great deal of programming, from game logic to displaying
    objects on screen. One of the most powerful things about the Corona SDK is that
    any display object can be animated. This is a testament to the flexible graphics
    model that Corona offers.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Animation adds a lot of character to the user experience in a game. This is
    accomplished by generating a sequence of frames that evolve smoothly from frame
    to frame. We''ll be learning this skill and applying it to the new game that we''re
    going to create.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with motion and transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate with image sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a game loop for display objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build our next game framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's animate!
  prefs: []
  type: TYPE_NORMAL
- en: Panda Star Catcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section involves creating our second game called Panda Star Catcher. The
    main character is a panda named Ling Ling, who needs to be launched toward the
    skies and catch as many stars as possible before the timer runs out. The panda
    will be animated and have separate movements for every course of action that is
    applied, such as during the setup before launch and while it's in the air. The
    slingshot mechanics will also be applied to launch Ling Ling into the air. You
    might have seen similar features in games such as *Angry Birds* and *Crush the
    Castle*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get everything moving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have introduced transitions in [Chapter 3](ch03.html "Chapter 3. Building
    Our First Game – Breakout"), *Building Our First Game – Breakout*, and briefly
    touched base with it. Let's go into more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transition library allows you to create animations with only a single line
    of code by allowing you to tween one or more properties of a display object. We
    have discussed the basics of transitions back in [Chapter 3](ch03.html "Chapter 3. Building
    Our First Game – Breakout"), *Building Our First Game – Breakout*.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done through the `transition.to` method, which takes a display object
    and a table that contains the control parameters. The control parameters specify
    the duration of the animation and the final values of properties for the display
    object. The intermediate values for a property are determined by an optional easing
    function, which is also specified as a control parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `transition.to()` method animates a display object's properties over time,
    using the "easing" algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `handle = transition.to( target, params )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return function is an object. The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target`: This is an object that will be the target of the transition. This
    includes display objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: This is a table that specifies the properties of the display object,
    which will be animated, and one or more of the following optional non-animated
    properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.time`: This specifies the duration of the transition in milliseconds.
    By default, the duration is 500 ms (0.5 seconds).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.transition`: By default, this is `easing.linear`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.delay`: This specifies the delay in milliseconds (none by default)
    before the tween begins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.delta`: This is a Boolean that specifies whether non-control parameters
    are interpreted as final ending values or as changes in value. The default is
    `nil`, meaning false.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.onStart`: This is a function or a table listener called before the
    tween begins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.onComplete`: This is a function or a table listener called after the
    tween completes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Easing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easing library is a collection of interpolation functions used by the transition
    library. One example is opening a drawer. The first movement at first is fast
    and then a slow precise movement before it stops. The following are some easing
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`easing.linear(t, tMax, start, delta)`: This defines a constant motion with
    no acceleration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing.inQuad(t, tMax, start, delta)`: This performs a quadratic interpolation
    of animated property values in a transition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing.outQuad(t, tMax, start, delta)`: This starts the motion quickly and
    then decelerates to zero velocity as it executes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing.inOutQuad(t, tMax, start, delta)`: This starts the animation from a
    zero velocity, accelerates, and then decelerates to zero velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing.inExpo(t, tMax, start, delta)`: This starts the motion from zero velocity
    and then accelerates as it executes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing.outExpo(t, tMax, start, delta)`: This starts the motion quickly and
    then decelerates to zero velocity as it executes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing.inOutExpo(t, tMax, start, delta)`: This starts the motion from zero
    velocity, accelerates, and then decelerates to zero velocity using an exponential
    easing equation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create your own easing function to interpolate between a start and
    a final value. The arguments of the function are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t`: This is the time in milliseconds since the transition started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tMax`: This is the duration of the transition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: This is the starting value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delta`: This is the change in value (final value = `start` + `delta`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value of timed functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a function that can be called at a later time can be helpful when organizing
    the timing of your game objects' appearance in an application. The timer library
    will allow us to handle our functions in a timely manner.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The timer function enables you to trigger events at a specific delay (in milliseconds)
    of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: '`timer.performWithDelay(delay, listener [, iterations])`: This invokes the
    listener after a delay in milliseconds and returns a handle to an object that
    you can pass to `timer.cancel()` in order to cancel the timer before it invokes
    the listener. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`timer.cancel(timerId)`: This cancels a timer operation initiated with `timer.performWithDelay()`.
    The parameter is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timerId`: This is an object handle returned by the call to `timer.performWithDelay()`.
    For example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`timer.pause(timerId)`: This pauses a timer object started with `timer.performWithDelay()`.
    The parameter is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timerId`: This is the timer ID object from `timer.performWithDelay()`. For
    example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`timer.resume(timerId)`: This resumes a timer that was paused with `timer.pause(timerId)`.
    The parameter is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timerID`: This the timer ID from `timer.performWithDelay()`. For example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: What are image sheets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Corona SDK includes an image sheet feature to construct animated sprites (also
    known as sprite sheets).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on image sheets, refer to the following link at [http://docs.coronalabs.com/guide/media/imageSheets/index.html](http://docs.coronalabs.com/guide/media/imageSheets/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Image sheets are an efficient way to save texture memory. They are recommended
    for complex character animation or when numerous types of animations are involved.
  prefs: []
  type: TYPE_NORMAL
- en: Image sheets require more coding and have more of an advanced setup. They require
    the construction of a large sheet of animation frames.
  prefs: []
  type: TYPE_NORMAL
- en: It's sprite mania!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image sheets are 2D animations that compile multiple frames into a single texture
    image. This is an efficient way to save on texture memory. It is beneficial for
    mobile devices and minimizes the loading time.
  prefs: []
  type: TYPE_NORMAL
- en: Image sheet API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `graphics.newImageSheet` function creates a new image sheet. Refer to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the number of frames in the image sheet is assumed to be `floor(imageWidth/frameWidth)
    * floor(imageHeight/frameHeight)`. The first frame is placed at the top-left position
    and reads left to right and follows the next row, if applicable. The following
    image sheet has five frames that are 128 x 128 pixels each. The image sheet image
    is 384 pixels x 256 pixels altogether. If it were to be integrated in Corona,
    a sample method would be displayed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Image sheet API](img/9343OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `display.newSprite(imageSheet, sequenceData)` function creates a new sprite
    from an image sheet. A sprite defines the collection of frames that belong to
    the same character or other moving asset, which may then be subdivided into different
    animation sequences for playback. The `sequenceData` parameter is an array of
    animation sequences that you set up. Sequences can be shared between multiple
    sprite objects. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single sequence (consecutive frames):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Single sequence (non-consecutive frames):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Multiple sequences (both consecutive and non-consecutive frames):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`object:pause()`: This pauses the current animation. The frame remains on the
    current displayed frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object:play()`: This plays an animation sequence, starting at the current
    frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object:setFrame()`: This sets the frame in the currently loaded sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object:setSequence()`: This loads an animation sequence by name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game time!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to set up image sheets, let''s try to incorporate
    them into Panda Star Catcher! You can download the project files that accompany
    this book from the Packt Publishing website. There is a project folder called
    `Panda Star Catcher` in the `Chapter 5` folder. It already has the `config.lua`
    and `build.settings` files set up for you. The art assets are included in the
    folder as well. From [Chapters 3](ch03.html "Chapter 3. Building Our First Game
    – Breakout"), *Building our First Game – Breakout* and [Chapter 4](ch04.html "Chapter 4. Game
    Controls"), *Game Controls*, you might have noticed that the build and runtime
    configuration has a similar setup. This tutorial is compatible for both iOS and
    Android devices. The graphics included in the project folder have been designed
    to display properly on both platforms. The welcome screen of the game will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game time!](img/9343OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – setting up the variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off with introducing all the variables needed to run the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a brand new `main.lua` file and add it in the `Panda Star Catcher` project
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s hide the status bar from the devices and set all the variables needed
    in game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We hid the status bar at the start of the application. This is only applicable
    for iOS devices. There are four different groups set up, and all of them play
    an important role in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `gameIsActive` is set as `false`. This enables us to activate properties
    of the application to affect the round when the display objects need to stop animating,
    appear on screen, and become affected by touch events.
  prefs: []
  type: TYPE_NORMAL
- en: The elements for the timer have also been set in the beginning of the code as
    well. Setting `numSeconds` to `30` denotes how long the round will count down
    from, in seconds. `starWidth` and `starHeight` depict the dimensions of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the round
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to load the panda to the game screen before it can launch. The panda
    will transition from the bottom of the screen and move upward on the screen before
    any touch event can occur.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – starting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we need to set the offscreen position for the panda and have it transition
    to its starting launch location, so the user can interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the variables, create a new local function called `startNewRound()`
    and add an `if` statement to initiate the `panda` object into the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new local function called `activateRound()` within `startNewRound()`.
    Set the starting position of the `panda` display object on screen and add `ground:toFront()`,
    so that the ground appears in front of the panda character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another local function called `pandaLoaded()`. Set `gameIsActive` to
    `true` and set the `panda` object''s air and hit properties to `false`. Add `panda:toFront()`
    so that it appears in front of all the other game objects on screen and set the
    body type to `"static"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transition the panda to `y=225` in 1,000 milliseconds. When the tween is completed,
    call the `pandaLoaded()` function using the `onComplete` command. Close the `activateRound()`
    function with `end` and call out to it. Close the `if` statement for `panda` and
    the `startNewRound()` function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – starting the game](img/9343OT_05_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the level is activated, the panda is placed below the ground before it
    is visible to the player. For `pandaLoaded()`, the game is activated by `gameIsActive
    = true`, and the panda is ready for launch by the player. The panda transitions
    from the ground level to an area on the screen where it can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Poof! Be gone!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The panda needs to disappear from the stage after a turn has been made. Instead
    of having it disappear into thin air, we'll be adding a "poof" effect when it
    collides with any object on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – reloading the panda on the stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the panda has been in the air for a certain amount of time or has hit any
    out-of-bounds areas off the screen, it will turn into a cloud of smoke. The panda
    will be replaced with a "poof" image when a collision event occurs with the edge
    of the screen or the ground. The visible properties of the panda have to be turned
    off for the "poof" effect to work. When the collision has been made, the panda
    needs to be reloaded back onto the screen while the game is still activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local function called `callNewRound()`. Include a local variable called
    `isGameOver` and set it to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the current function, create a new local function called `pandaGone()`.
    Add in the new properties for the panda, so it no longer displays on the game
    stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in a new function for the `poof` object called `fadePoof()`. With the `onComplete`
    command, transition with `time` set to `50` and `alpha` set to `1`. Have the `poof`
    object fade out with `time` set to `100` and `alpha` set to `0`. Close the `pandaGone()`
    function and call out to it using `timer.performWithDelay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When `isGameOver` is still `false`, add in a `timer.performWithDelay` method
    for `startNewRound()`. Close the `callNewRound()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new round is called when the panda is no longer displayed on the screen and
    the clock is still counting down. When `isGameOver` is still `false`, then the
    panda reloads by calling `startNewRound()`.
  prefs: []
  type: TYPE_NORMAL
- en: The panda collision occurs through `pandaGone()`. All physical properties become
    inactive by applying `panda.isVisible = false`.
  prefs: []
  type: TYPE_NORMAL
- en: The smoke appears exactly where the panda disappeared. This happens when `poof.x
    = panda.x; poof.y = panda.y`. `poof` becomes visible for a short while through
    `fadePoof()`. Once it has faded, a new round awaits, which sets `waitingForNewRound`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Earning some points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Points are earned when the panda catches any stars in the sky. The game is run
    on a timer, so it is the player's job to catch as many stars as they can, before
    the time runs out. Let's rack up some points!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – tracking the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The score updates through a parameter called `scoreNum` and displays it during
    the game play. The score number is received through `gameScore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function that will be created is called `setScore` with a parameter
    called `scoreNum`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a local variable called `newScore` and set it as `scoreNum`. Set the `gameScore
    = newScore`. Provide an `if` statement for `gameScore`, so that the score during
    game play is set to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `scoreText` display object and make it equal to `gameScore`. Close
    the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For `setScore = function(scoreNum)`, we set a parameter called `scoreNum`. The
    `scoreNum` parameter will update the game score continuously through `local newScore`.
    `newScore` will update through `gameScore`, which provides the basis of the score
    keeping. At the same time, `scoreText` will display the value of `gameScore` during
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: When the game ends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no losers in this game. Everyone wins! You'll still keep your adrenaline
    pumping by trying to catch as many stars as you can before the timer runs out.
    When it's all over, we still need to be notified that the time is up.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying the game over screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to set up the game over screen and have it display the final score
    that the player has achieved at the end of the round:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `callGameOver()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `gameIsActive` as `false` and pause the physics engine. Remove the `panda`
    and `stars` objects from the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the game over objects and insert them into the `hudGroup` group. Use
    the `transition.to` method to display the game over objects on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the final score with a local variable called `newScore`. Set `isVisible`
    to `false` for the `counter` and `scoreText`. Introduce `scoreText` again to display
    the final score in a different location on the device screen. Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – displaying the game over screen](img/9343OT_05_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `callGameOver()` method displays the game over screen when time runs out
    or if all the stars are collected. We have set `gameIsActive` to `false` and paused
    all the physics so the panda cannot be moved with any other screen touches. The
    panda and stars are then removed from the scene. The `shade` and `gameOverDisplay`
    objects are visible through `transition.to`, so it notifies the player that the
    round is over. The final score will display at the end of the round in front of
    the `gameOverDisplay` object.
  prefs: []
  type: TYPE_NORMAL
- en: Background display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The panda needs a general setting of where it's located in the game. Let's set
    the background and ground objects.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the background elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add in the `background` and `ground` display objects to the `drawBackground()`
    function. Insert the objects in the group called `gameGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `background` and `ground` display objects are placed in the function called
    `drawBackground()`. The `ground` object has a customized physical shape that is
    not the same size as the original display object. So if the panda happens to hit
    the ground, it will collide with it but not fall through.
  prefs: []
  type: TYPE_NORMAL
- en: Heads up!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the game can be played, we need a general idea of how to operate the
    controls of the game. Luckily, we'll be adding a help screen that explains how
    to play. The **heads-up display** (**HUD)** needs to be displayed as well, so
    that the player can be updated on the time left on the clock and see how many
    points they have accumulated.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying the timer and score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up the help screen and HUD elements that need to be displayed during
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `hud()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display `helpText` at the start of the game for 10 seconds. Have it transition
    by sliding it to the left and turning visibility to `false`. Add `helpText` to
    the `hudGroup` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display `counter` and `scoreText` near the top of the screen. Add `scoreText`
    to the `hudGroup` group as well. Close the function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `helpText` object appears before the game starts and stays on the main device
    display for 9 seconds and transitions to -320 in the *x* direction in 1 second.
    This happens through `transition.to( helpText, { delay=9000, time=1000, x=-320,
    transition=easing.inOutExpo })`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `counter` object displays `"Time: " .. tostring( numSeconds )`, where `numSeconds`
    denotes the seconds that are counted down, starting from 30\. It is located near
    the top-left corner of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The `scoreText` object displays `gameScore` and is updated for every star collision
    made. This will be placed on the top-right corner of the screen. All the objects
    in `local hud = function()` are inserted in `hudGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: Time after time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This game has a timer that the player has to work against, in order to catch
    as many stars as possible before it runs out. We're going to start the countdown
    as soon as the help text leaves the stage.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll need to create a couple of functions that activate the countdown and
    also stop at 0 seconds when the game is over:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the timer countdown for the game with a local function called `myTimer()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Increment the seconds for the timer countdown by 1\. With the `counter` text
    object, display the time using `numSeconds`. Print out `numSeconds` to see the
    countdown in the terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `if` statement for when the timer runs out or if all the stars are
    gone. Within the block, cancel the timer and call `callGameOver()` to end the
    round. Close the `myTimer()` function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initiate the `myTimer()` function with a new local function called `startTimer()`.
    This will start the countdown at the beginning of the game play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main timer function is within `myTimer()`. We count down the seconds using
    `numSeconds = numSeconds – 1`. The seconds will update in the `counter` display
    object. `print(numSeconds)` will be updated in the terminal window to see how
    fast the countdown runs inside the code.
  prefs: []
  type: TYPE_NORMAL
- en: When time runs out or all the stars have been collected, an `if` statement is
    created to check if any of the arguments are true. When any statement evaluates
    to true, the timer stops counting down, the panda animation pauses, and the `callGameOver()`
    function is called. This will call the function to display the game over screen.
  prefs: []
  type: TYPE_NORMAL
- en: The timer initiates the countdown through `local startTimer = function()` at
    a rate of 1,000 milliseconds, which is equivalent to 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: It's so glowy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The panda needs another element that will display how much force is required
    to launch it into the sky. We're going to add a subtle glow-like display object
    that will represent this.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the power shot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create a separate function for `powerShot`, so that it can be called
    when the panda is set for launch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the `powerShot` object through a new local function called `createPowerShot()`.
    Insert it in the `gameGroup` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `powerShot` object is created through the `createPowerShot()` function and
    is called when the panda is setting up for launch.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be exciting to see something animated on the screen. Our main character
    will have designated animations for every action applied during the game play.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the panda character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to set up the panda collision event and animate it accordingly, using
    the image sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a local function that will introduce the collision and touch
    events for the panda. We shall call it `createPanda()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the panda collides with the stars, use `onPandaCollision()` with the parameters
    `self` and `event`. Reload `panda` every time a collision occurs with the stars
    or the edge of the screen, by using `callNewRound()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a directional arrow to allow the user to aim for an area to launch the
    panda. Insert it to the `gameGroup` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the image sheet for the panda that has three different animation sequences
    called `"set"`, `"crouch"`, and `"air"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following properties to `panda` before it launches into the air:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up collisions for `panda` using `"collision"` and apply an event listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `poof` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the `panda` and `poof` objects into the `gameGroup` group. Close the
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll need to scroll up to the `activateRound()` function and add the `"set"`
    animation sequence for the panda:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collision events that occur for the panda start with `if event.phase ==
    "began"`. The panda reloads on screen through several cases of `if` statements.
    `event.other.myName == "star"` will call a new round when the panda launches off
    screen towards the right, left, or top sides of the stage.
  prefs: []
  type: TYPE_NORMAL
- en: The image sheet for the panda has three sets of animations. They are called
    `"set"`, `"air"`, and `"crouch"`. There are a total of five frames in the image
    sheet.
  prefs: []
  type: TYPE_NORMAL
- en: The physical properties of the panda are set before launch. The body type is
    set to `"static"` and will change when it's in the air.
  prefs: []
  type: TYPE_NORMAL
- en: The collision event for the panda is called by `panda:addEventListener( "collision",
    panda )`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the image sheet has been set up, the `"set"` animation needs to be
    added in the `activateRound()` function to initiate movement.
  prefs: []
  type: TYPE_NORMAL
- en: Starry skies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stars play a big part in the game. They are the main obstacle that the panda
    has to get past in order to achieve points before the clock runs out.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating star collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Star collisions need to be made and removed from the stage so that points can
    be accumulated for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function for the star collision called `onStarCollision()` and have
    a `self` and `event` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `if` statements that remove the `stars` children from the game screen
    when a collision is made. Increment the score by 500 for each star removed from
    the screen. Close the function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – creating star collisions](img/9343OT_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The star collision occurs on first contact with `if event.phase == "began"`
    and `self.isHit == false`, assuming the star has not been touched by the panda.
    The stars are removed from the screen by `self.parent:remove( self )` and `self
    = nil`. The score is incremented by 500 through `gameScore` and updated to `setScore
    = (scoreNum)`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – tracking the star count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try tracking how many stars the panda catches during game play. The logic is
    similar to how the game score was created. Each star that is caught will have
    to increment by 1 as the count for every collision made. The star count is placed
    within the `onStarCollision()` function. A new function and method will have to
    be created to display the text of the star count, and will have to be updated
    every time the count changes.
  prefs: []
  type: TYPE_NORMAL
- en: Screen touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The panda will have to get across the playing field to reach the stars by creating
    a launch mechanic similar to a slingshot. Force will play a big role in pushing
    the panda upward.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – launching the panda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a touch event for the panda so that it flings toward the stars. The
    `powerShot` object will play a role in helping the player visualize how much power
    needs to be applied to the panda, before it launches into the air.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement touch events for the panda. Create a local function called `onScreenTouch()`
    with an event parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `gameIsActive` initiated, add in an `if` statement for when the touch
    event starts, by using `event.phase ==` `"began"`. During this event, use the
    "crouch" animation set to prepare `panda` for launch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `elseif` statement for when the touch event ends by using `event.phase
    == "ended"`.Create a new local function called `fling()`, which will hold the
    properties of `panda` when it is launched toward the `star` objects. Apply a force
    opposite to where the touch event is dragged. Scale the `powerShot` display object
    outward when the touch event is pulled farther from the character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – launching the panda](img/9343OT_05_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the game is active and the panda has been loaded on the screen, a touch
    event to launch the panda can be initiated. The panda will go from a `"static"`
    physics state to a `"dynamic"` physics state. The `powerShot` display object size
    increases the farther back the panda is pulled by an event touch.
  prefs: []
  type: TYPE_NORMAL
- en: The force from the panda launch is applied by `local fling = function()`. Launch
    force is created by `xForce` and `yForce`. The panda object is propelled by `panda:applyForce(
    xForce, yForce, panda.x, panda.y )`. Notice that the body type changes to `"dynamic"`,
    so gravity can affect the object.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing display objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the round has been set, the display hierarchy of the game objects needs
    to be rearranged. The most important objects are displayed towards the front of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – reordering layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new local function `reorderLayers()` needs to be created to organize the
    display hierarchy of objects on screen during game play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gameGroup`, `hudGroup`, and other display objects are reorganized in the
    display hierarchy of the game screen. The most significant object is set to the
    front, while the least important one is towards the back.
  prefs: []
  type: TYPE_NORMAL
- en: Creating stars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sky background needs to be filled with stars, so that the panda can catch
    as many stars as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating stars in the level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add the layout of the stars in the game and have them moving so as
    to add a little effect to show that they're active. A collision event will need
    to be applied, which would remove them when the panda collides with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `createStars()` and lay out the `star` objects
    in a `for` loop. Add in the `"collision"` event that will be called by `onStarCollision()`
    to remove the stars when they are hit by the panda. Rotate the stars forward and
    backward at 10 seconds and 1,080 and -1,080 degrees each. This will allow the
    stars to rotate three full intervals backward and forward. Create the walls for
    the left and right sides of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number of stars displayed on screen is set by `numOfRows` and `numOfColumns`.
    A `for` loop is made to display each individual star object and is placed in the
    `stars` group. The collision for `star` is detected by an event listener through
    `onStarCollision()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `leftWall` and `rightWall` objects have physical properties as well and
    will take into account the collision detection with the panda.
  prefs: []
  type: TYPE_NORMAL
- en: The stars are animated by `starAnimation()` and `starRotation()`. Each function
    rotates each star object for 10 seconds (10,000 milliseconds), and alternates
    between 1,080 and -1,080 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game starts when the clock starts counting down and the panda is loaded
    on the screen. Once the panda is set on screen, the player needs to aim and launch
    it quickly so that reloading of the panda can occur immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initializing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The physics and the remaining game functions need to be initialized to run the
    game. All game actions need to be delayed until the help screen has left the stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the game by creating a new function called `gameInit()`, which will hold
    the physics properties and activate the display objects on the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in a `Runtime` event listener, using `"touch"` for `onScreenTouch()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Have the level and timer start 10 seconds later so that the user has time to
    read through the help text. Close the function and start the game with `gameInit()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the code is completed! Run the game in the simulator and see for yourself
    how it works. Make sure to check for any typos in your code if errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The round is initialized through `gameInit()`. The physics engine and the remaining
    functions are run at this time. The event listener for `onScreenTouch()` is added
    as well. The `startNewRound()` and `startTimer()` functions initiate 10 seconds
    after launching the application through `timer.performWithDelay`.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – animating graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What is the proper way to pause the animation of an image sheet?
  prefs: []
  type: TYPE_NORMAL
- en: '`object:stop()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object:pause()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object:dispose()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. How do you make an animation sequence loop forever?
  prefs: []
  type: TYPE_NORMAL
- en: '`local sequenceData =`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`local sequenceData =`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`local sequenceData =`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`local sequenceData =`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Q3\. How do you create a new image sheet?
  prefs: []
  type: TYPE_NORMAL
- en: '`myCharacter = display.newSprite(sequenceData)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`myCharacter = display.newSprite(imageSheet, sequenceData)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`myCharacter = sprite.newSpriteSheet("myImage.png", frameWidth, frameHeight)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our second game, Panda Star Catcher, is finally complete! We're now getting
    a great grasp on writing more functions and different types of game logic, and
    we also have animation under our belt! Way to go!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Took a more in-depth look at transitions and applied easing techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understood image sheets and sprite animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a game loop for display objects that have to be reloaded continuously
    on screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied force to a display object that propels it to a designated direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a collision event that switches from one display object to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have pushed through making another game in one whole chapter! Working in
    Corona SDK is so simple and fast to learn. It doesn't even require thousands of
    lines of code to create a simple game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be learning another vital element to create games,
    sound effects, and music! You're in for a treat.
  prefs: []
  type: TYPE_NORMAL
