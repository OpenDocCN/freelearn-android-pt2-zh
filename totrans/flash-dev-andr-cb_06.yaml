- en: 'Chapter 6. Structural Adaptation: Handling Device Layout and Scaling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting useable screen bounds and resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting screen orientation changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling visual elements across devices at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling visual elements based on stage resize in Flash Professional CS5.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing the project panel in Flash Professional CS5.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezing a Flex application to landscape or portrait mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a blank Flex mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a Flex mobile view-based application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a Flex mobile tabbed application with multiple sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a splash screen within a Flex mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the ActionBar within a Flex mobile project for use with ViewNavigator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding the ActionBar Control in a single view for a Flex mobile project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding the ActionBar Control in all views for a Flex mobile project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With such a variety of hardware devices running Android, developing applications
    that look and function properly across different resolutions can be a challenge.
    Thankfully, this is something the Flash platform is well-suited for. Whether using
    the default layout mechanisms as part of the Flex SDK or writing your own layout
    and scaling logic, there are many things to consider.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will look at layout mechanisms when dealing with the Flex
    framework for mobile application development, and also explore a variety of considerations
    for pure ActionScript projects.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting useable screen bounds and resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When producing applications for a desktop or laptop computer, we don't have
    to give too much thought on the actual screen real estate we have to work with,
    or the **Pixels Per Inch(PPI)** resolution for that matter. It can be generally
    assumed that we will have at least a 1024x768 screen to work against, and we can
    be sure that it is a 72 PPI display. With mobile, that it all out the window.
  prefs: []
  type: TYPE_NORMAL
- en: With mobile device displays, our applications can basically be full screen or
    almost full screen; that is, but for the notification bar. These device screens
    can vary in size from just a few pixels, to hundreds. Then we must take into account
    different aspect ratios and the fact that the screen will certainly display 250
    PPI or above. We must have a new set of checks in place to perform application
    layout modifications depending upon the device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At runtime, we can monitor many device capabilities and react by modifying
    our various visual elements across the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `TextField` and `TextFormat` pair to relay text messages
    onto the device display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat`, and
    add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final step is to create a method to gather all of the data we need to make
    any further modifications to our layout or UI components. In this example, we
    are reading both the `Stage.stageHeight` and `Stage.stageWidth` to get the usable
    area. We can contract this with `Capabilities.screenResolutionX` and `Capabilities.screenResolutionY`
    to get the actual display resolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Other important pieces of information are the `Capabilities.touchscreenType`
    to determine whether the touch screen expects a finger or stylus, `Capabilities.pixelAspectRatio`
    to retrieve pixel aspect ratio (though this is generally always 1:1), and most
    importantly that we use `Capabilities.screenDPI` to discover the PPI measurement
    of our display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting application will display as shown in the following screenshot:![How
    to do it…](img/1420_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Through the `flash.display.Stage` and `flash.system.Capabilities` classes, we
    can learn a lot about the particular device display our application is running
    on and have the application react to that in some way. In this example, we are
    outputting the gathered information to a `TextField`, but this data could be also
    used to adjust the location, size, or arrangement of visual elements based on
    `Stage` resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting screen orientation changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As most Android devices have at least two screen orientations, that is, portrait
    and landscape, it is useful when developing for these devices to know what the
    current orientation is in order to properly display application user interface
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will register an event listener on our `Stage` to listen for `StageOrientationEvent`
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `TextField` and `TextFormat` pair to relay text messages
    onto the device display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat`, and
    add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step will be to register an event listener to detect changes in screen
    orientation. We do this by listening for `StageOrientationEvent.ORIENTATION_CHANGE`
    events on the `Stage:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a `StageOrientationEvent.ORIENTATION_CHANGE` event is detected, it will
    invoke a method named `onOrientationChange`. We will create this method and use
    it to write a text constant representing the new orientation to the `TextField`.
    We will also invoke a method to adjust our layout at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will use the `reformLayout` method to adjust any visual components
    on screen to match our new `Stage` dimensions. Here, we simply adjust the sizes
    of our `TextField` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting application will display as shown in the following screenshot:![How
    to do it…](img/1420_06_01_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basically this is a simple event listener that is tied to devices, which have
    a variety of possible orientations. We register an event listener of type `StageOrientationEvent.ORIENTATION_CHANGE`
    on the `Stage` and receive two important pieces of data back: `StageOrientationEvent.beforeOrientation`
    and `StageOrientationEvent.afterOrientation`. The values contained within these
    event results will report device orientation constants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four constants that can possibly be reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StageOrientation.DEFAULT`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StageOrientation.ROTATED_LEFT`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StageOrientation.ROTATED_RIGHT`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StageOrientation.UPSIDE_DOWN`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, these are simply possibilities. There are some devices which do not support
    all four of these constants so we must be cautious and not assume otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are actually a number of ways in which we could detect screen orientation
    changes. One would be to monitor the `Stage.orientation` through a `Timer` and
    react accordingly. Another would involve testing `Accelerometer` values for orientation
    changes. Using `StageOrientationEvent` is the most direct way, however, and supplies
    us with information about both the orientation before and after the event fires,
    which can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For an example of how you might go about a similar task through the `Accelerometer`
    API, have a look at [Chapter 3](ch03.html "Chapter 3. Movement through Space:
    Accelerometer and Geolocation Sensors"), *Movement through Space: Accelerometer
    and Geolocation Sensors.*'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling visual elements across devices at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wide variety of Pixels Per Inch (PPI) measurements and overall screen resolution
    differences across Android devices can make it difficult to make sizing and layout
    decisions when creating visual elements, especially interactive elements, as these
    must be large enough for users to touch with their fingertips easily. It is generally
    accepted that a physical measurement of a half inch square is ideal for proper
    touch. In this recipe, we will demonstrate how to ensure the same physical specifications
    across devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create some visual elements on the screen that are sized to physical
    measurements based upon the detected device display PPI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step will be to declare a number of objects to use in our application.
    We will create three `Shape` objects, which will be used to demonstrate this particular
    layout and sizing technique. We also set up two `Number` objects to hold specific
    measurements for use when determining size and position across the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we must draw out our visual elements onto the `Stage`. As mentioned earlier,
    we are targeting a physical resolution of one half inch as the smallest measurement.
    Therefore, we begin by performing a calculation to determine the representation,
    measured in pixels, of both half inch and one full inch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be creating a box in the upper left, and another in the upper right;
    each will be a half inch square and positioned based upon the available `Stagewidth`
    and `height`. A larger box will be positioned at the very bottom of our screen
    and will extend across the width of the `Stage:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register an event listener of type `StageOrientationEvent.ORIENTATION_CHANGE`
    upon the `Stage`. This will detect device orientation changes and alert us so
    that we may resize and reposition our visual elements appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following method will fire upon each orientation change detected by our
    application. In this case, we do not care so much what our present orientation
    actually is, but will reposition (and resize, when necessary) any visual element
    on the `Stage` to properly reflow the screen. We once again use our numeric measurements
    to perform these actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting application will display similar to what we see in the following
    screenshot:![How to do it…](img/1420_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good trick to sizing visual components is to multiply the reported `Capabilities.screenDPI`
    times whatever physical measurement you want to achieve. For instance, if we want
    to be sure that certain touch elements are exactly half inch in width across devices,
    you can use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we set up some variables, which represent measurements of physical
    half-inch and full-inch calculations, and then apply these upon the creation of
    our elements for layout and sizing. If a change in device orientation is detected,
    we adjust our layout based upon the new `Stage` dimensions and also resize visual
    elements as appropriate. As the two top `Shapes` are half inch squares, we simply
    adjust their `x` and `y` coordinates, but the bottom shape has the additional
    requirement of adjusting its `width` upon every orientation change to fill the
    width of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling visual elements based on stage resize in Flash Professional CS5.5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features introduced in Flash Professional CS5.5 that makes targeting
    various device resolutions easier is the ability for Flash to resize and reposition
    visual elements upon `Stage` resize. This allows us to modify our FLA files targeting
    specific resolutions and devices quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will demonstrate how to employ **Scale content with stage** in order to
    target different screen resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Here we see a demo application laid out at **480x800**, targeting a Nexus S
    device. In the **Properties** panel, click upon the wrench icon next to the **Size**
    controls:![How to do it…](img/1420_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to adjust the display resolution to match that of a Droid2 so we change
    the **Document Settings** to reflect a **480x854** display resolution to match
    this device. Additionally, we can select **Scale content with stage**, which will
    scale our visual elements proportionately:![How to do it…](img/1420_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon hitting the **OK** button, we can see that the `Stage` has resized and
    our visual elements are now centered upon the `Stage`. Since we only adjusted
    the **height** of this application, the layout of the visual elements is repositioned
    according to settings which can be adjusted in **Edit | Preferences | General
    | Scale Content**, where we can choose to **Align top left** or not. Leaving this
    box unselected will center our elements upon rescaling the stage and selecting
    to scale contents, as we can see below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To demonstrate this further, we will resize our `Stage` to match the resolution
    of a fictional Android tablet device. In the **Properties** panel, once again
    click upon the wrench icon next to the **Size** controls:![How to do it…](img/1420_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our fictional tablet has a resolution of **800x1000**, so we will once again
    adjust the width and height settings and select **Scale content with stage** followed
    by a click of the button marked **OK:**![How to do it…](img/1420_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new scaling feature is much more apparent now, and we can even see how much
    our application assets have been scaled by referring to the guides, which were
    originally marking our initial resolution. At this point, we can make any further
    adjustments to our application layout to be sure it appears exactly as we want
    upon the target device:![How to do it…](img/1420_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we wanted to target a number of devices in a visual way, we could construct
    an FLA for each one using this technique, along with a shared codebase. Although
    many devices would be able to use an application generated from the exact same
    `.fla`, it all depends upon target device resolution and how much tweaking we
    want to do for each one.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Flash Professional CS5.5 and above, we now have the added feature of scaling
    content on our `Stage` when we adjust the `Stage` dimensions. This is excellent
    for mobile Android development purposes since there exists such a variety of display
    resolutions across devices. The ability to scale our content allows for rapid
    layout adjustments of FLA documents which, when compiled to `.APK`, target certain
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the scaling of our visual elements will always
    be done in a way that preserves their original aspect ratio. If the new aspect
    ratio differs from the original, there will be further adjustments, which will
    be needed to be made in order to make the layout suitable to whichever device
    we are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: Employing the Project panel in Flash Professional CS5.5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has traditionally been troublesome when attempting to design application
    layout in Flash Professional since it required the manual organization of various
    FLA files, along with some mechanism of synchronizing changes between them in
    code and asset management. Flash Professional CS5.5 attempts to alleviate much
    of this burden with a new Project structure, including the ability to share author
    time Flash Library assets across project documents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will configure a Flash Project, which will allow us to target multiple screen
    resolutions using the same shared asset pool across device-targeted FLAs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Flash Professional project by opening the **Project panel** by
    selecting **Create New | Flash Project** on the welcome screen, or through **File
    | New** | **Flash Project** from the application menu:![How to do it…](img/1420_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Create New Project** panel will appear, allowing us to configure a new
    **Flash Project**. We will provide a **Project name**, define a **Root folder**
    for the project files to reside, and choose a **Player**. In the case of AIR for
    Android, we will want to be sure to choose **AIR 2.6** or the latest version of
    AIR you wish to target:![How to do it…](img/1420_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Flash Project structure allows us to define a number of different FLA documents
    within one project, which target a variety of resolutions and layouts. Here, for
    example, we have created specific documents targeting the Droid, EVO, and Nexus
    One mobile Android devices. In addition to these documents we also have an `AuthortimeSharedAssets.fla`
    file, which is generated for us automatically by Flash Professional. This will
    contain any assets which are shared across our other documents.![How to do it…](img/1420_06_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, as we design and develop our application assets, we can mark each one as
    an author-time shared asset, which can be linked across all of our documents,
    making asset management within this particular project much more organized than
    it would be, otherwise. To mark a **Library** asset as shared, simply click on
    the checkbox next to it:![How to do it…](img/1420_06_12(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While marking a particular asset to be shared across documents in a project
    does make it sharable, we must also be sure to include the **Library** asset within
    the document in question to be able to access it within a particular device document
    at author time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For instance, if we have two `.fla` files that we want to share a MovieClip
    symbol called "RedBall", we will first define "RedBall" in one `.fla`, and mark
    it as shared within that Library. This will place the symbol into our `AuthortimeSharedAssets.fla`
    file, but it will not be available to any other `.fla` until we actually bring
    it into the **Library** of the second `.fla`. At this point, any modifications
    made in either `.fla` will be shared across both because of the shared asset linkage
    in our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AuthortimeSharedAssets.fla` file contains all of the Flash **Library**
    assets that are shared across our multiple FLA files. This allows us to modify
    a shared asset in one file, and have those changes cascade across all project
    documents in which it is used. The ability to define a variety of screen resolution
    layouts through multiple, targeted FLA files allows a designer great flexibility
    when structuring the application user interface. Having all of those interface
    elements linked through this new project structure keeps the work organized and
    clean.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not only does the new Flash Project panel and associated project structure allow
    for author time asset sharing and multi-device targeting through multiple FLA
    files, but the file structure is now totally compatible with Flash Builder. This
    allows developers to start a Flash Project in Flash Professional, and continue
    editing it in Flash Builder by importing the project folder within that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing a Flex application to landscape or portrait mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes desirable to constrain your application layout to a specific
    aspect ratio, landscape, or portrait. When building Android projects using the
    Flex framework, it is a simple matter to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can freeze a particular aspect ratio for our application by modifying the
    AIR application descriptor file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when we define a new Flex mobile project, an application descriptor
    `XML` file is created. This file includes a node dedicated to the application
    `initialWindow` configuration. It will appear similar to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to modify the contents of this node in two ways. First, set the `autoOrients`
    tag to `false`. This will prevent the application from re-orienting itself upon
    device rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will add an `aspectRatio` tag and provide it with one of two values,
    `landscape` or `portrait:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we test this application on our device, even when holding it upright, in
    portrait mode, our application remains locked to landscape:![How to do it…](img/1420_06_13(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application descriptor file is very powerful as it can define many elements
    of our application without even editing any MXML or ActionScript. In this example,
    we are modifying tags within the project `initialWindow` node; setting `autoOrients`
    to false and adding an `aspectRation` tag, setting the aspect ratio of our application
    to `landscape` or `portrait`. Performing these edits will ensure that our application
    runs in a fixed aspect ratio no matter how the device is rotated by the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users of Flash professional CS5.5 will find that they can easily adjust these
    properties through the **AIR for Android Settings** dialog. This can be accessed
    from either the **Properties** panel or from **File | AIR for Android Settings:**
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/1420_06_14(2).jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will explore the application descriptor file in greater depth within [Chapter
    9](ch09.html "Chapter 9. Manifest Assurance: Security and Android Permissions"),
    *Manifest Assurance: Security and Android Permissions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a blank Flex mobile application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a **Flex Mobile Project** in Flash Builder, there are a number
    of default view and layout controls that come along with it, including the `ActionBar`
    control and `ViewNavigator` container. These are very useful controls for many
    types of projects, but not all will benefit from these extra structures. Sometimes
    it is better to start with a blank project and build from there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to go about defining a blank Flex Mobile Application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a **New Flex Mobile Project** in Flash Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your **Project Location** and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now simply choose **Blank** in the **Application Template** area and proceed
    with your project setup:![How to do it…](img/1420_06_15(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second way is to modify an existing **Flex Mobile Project** to remove certain
    mobile-related structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your mobile project will initially include the following MXML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now modify this in a number of ways. First, change your `ViewNavigatorApplication`
    tags to read as `Application` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove all `View` references in your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Either of these methods will enable a blank Flex Mobile application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/1420_06_16(2).jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What defines whether the `ActionBar` and other mobile-related structures are
    present within a Flex Mobile Project is whether or not the application is of type
    `spark.components.ViewNavigatorApplication` or `spark.components.TabbedViewNavigatorApplication`.
    When using the more traditional `spark.components.Application` for your Flex Mobile
    project, the `ActionBar, TabBar`, and `ViewStack` are no longer present or usable
    within the project.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the structures mentioned above, have a look at the
    next few recipes, which describe ways of working in projects with `ViewNavigator`
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not a good idea to modify a Flex mobile project after working on it for
    some time, as you will most likely be tied deeply into the `ViewStack` at that
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Flex mobile view-based application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view-based Flex mobile application provides us with a number of very useful
    controls and containers that specifically target the mobile application development
    layout and structure. These include an `ActionBar` along the top of the screen,
    and the `ViewNavigator` control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to go about creating a Flex mobile view-based application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a **New Flex Mobile Project** in Flash Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your **Project Location** and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now simply choose **View-Based Application** in the **Application Template**
    area and proceed with your project setup:![How to do it…](img/1420_06_17(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second way is to modify an existing Flex project to add certain mobile-related
    structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Flex project will initially include the following MXML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now modify this in a number of ways. First, change your `Application`
    tags to read as `ViewNavigatorApplication` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `View` MXML file within the current project source folder named `MainHomeView.mxml`
    for this example. In this case, we are creating it within a `views` package in
    our project structure.It is important to realize that every `ViewNavigatorApplication`
    includes any number of individual views. A `View` is a type of Flex container
    that can be managed through the `ViewNavigator` to expose or dismiss various "screens"
    within a mobile Flex application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we must point to the file we just created as the `firstView` property of
    our `ViewNavigatorApplication:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Either of these methods will define a Flex mobile view-based application.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/1420_06_18(2).jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What defines whether the `ActionBar` is present within a Flex mobile project
    is whether or not the application is of type `spark.components.ViewNavigatorApplication`
    (or `spark.components.TabbedViewNavigatorApplication)`. By defining our application
    as a `ViewNavigatorAppplication`, we have access to all of these mobile specific
    structures and controls, including the powerful `ViewNavigator` through which
    we can manage all of our application views.
  prefs: []
  type: TYPE_NORMAL
- en: A View defines a specific "screen" within our application and the user will
    likely switch between many different views while the application is in use. We
    can manage all of these views from the `ViewNavigator`, which automatically preserves
    a view history for us when the application is in use. As a result of this, when
    the user interacts with the Android back button, previous views can be revisited.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Flex mobile tabbed application with multiple sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a mobile Android project using the Flex framework can be as simple
    or as complex as we want it to be. Going one step beyond the `ViewNavigatorApplication`,
    is the `TabbedViewNavigatorApplication`, which includes the ability to have multiple
    sections of content, each with their own `ViewNavigator` and sets of `Views`.
    Defining a `TabbedViewNavigatorApplication` will allow us access to the `TabBar`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to go about configuring a Flex mobile tabbed application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a **New Flex Mobile Project** in Flash Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your **Project Location** and click **Next >**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now simply choose **Tabbed Application** in the **Application Template** area
    and proceed with your project setup:![How to do it…](img/1420_06_19(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second way is to modify an existing Flex project to add certain mobile-related
    structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Flex project will initially include the following MXML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now modify this in a number of ways. First, change your `Application`
    tags to read as `TabbedViewNavigatorApplication` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a set of `View` MXML files within the current project source folder.
    In this case, we are creating them all within a `views` package in our project
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TabOne.mxml:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'TabTwo.mxml:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'TabThree.mxml:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must point to the files we just created by nesting a series of `ViewNavigator`
    declarations within our `TabbedViewNavigatorApplication` structure. Each will
    point to one of the unique `View` MXML files we have just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Either of these methods will define a Flex mobile tabbed application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/1420_06_20(2).jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What defines whether the `TabBar` is present within a Flex Mobile Project is
    whether or not the application is of type `spark.components.TabbedViewNavigatorApplication`.
    When using the more traditional `spark.components.Application` for your Flex mobile
    project, the `TabBar` and `ViewStack` are no longer present or usable within the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note here that when using `TabbedViewNavigator`, each tab
    has its own exclusive `ViewNavigator` each with its own view stack. The `ViewNavigotor`
    instances do not have a mechanism to share data with one another unless drawn
    upon from a separate source, such as a shared data pool, which would be defined
    by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Using a splash screen within a Flex mobile application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adobe AIR for Android is an excellent runtime for building and distributing
    Android applications, but there are some trade-offs in comparison to native development.
    Depending upon the size of your application, it may take a few seconds to load
    everything up for the user. The mobile Flex framework allows us to define a splash
    screen to let the user know that the application is loading once they launch,
    and to add an extra bit of flourish to the entire experience.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will configure our application to display a splash screen while the application
    loading process takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon defining our Flex mobile project, we will need to be sure the `ViewNavigatorApplication`
    or `TabbedViewNavigatorApplication` (depending upon your project) is the currently
    selected MXML tag and enter **Design** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will modify a few settings within the **Common** area of our **Properties**
    panel. Here, browse to an image file to embed a **Splash image** and set the **Splash
    scale mode** to **none, letterbox, stretch**, or **zoom:**![How to do it…](img/1420_06_21(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter **Source view** and the MXML document will appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can, of course, modify any of the settings we have just configured from
    here by pointing to another file to embed or changing the scale mode. We will
    be adding one more property to our main application tag called `splashScreenMinimumDisplayTime`
    and set its value to the minimum duration, in milliseconds, that we want the splash
    screen image to display for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the user runs the application on their device, they will be presented with
    a handsome splash screen identifying the application and letting them know that
    it is now loading:![How to do it…](img/1420_06_22(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting the `splashScreenImage` property on our main application file will
    allow us to display an embedded custom image to the user while our application
    is loading. The addition of a `splashScreenMinimumDisplayTime` property allows
    us to define the minimum length of time (in milliseconds) that our splash screen
    will display for. If the application takes longer than this defined time, the
    splash screen will continue to display as needed. The splash screen also can accept
    a specific scale mode behavior by setting the `splashScreenScaleMode` property:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting `splashScreenScaleMode` to `none` will present our defined image at
    its native resolution without any modification. This is probably unacceptable
    as device screen resolutions vary so greatly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `splashScreenScaleMode` to `letterbox` will fit the splash image into
    the frame defined by the device display resolution, but will display empty padding
    in the areas that the image does not cover.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `splashScreenScaleMode` to `stretch` will stretch the defined image
    into the frame defined by the device display resolution, filling the entire display
    area. Some distortion may occur with this setting as the image may be scaled disproportionately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `splashScreenScaleMode` to `zoom` will fit the splash image into the
    frame defined by the device display resolution without allowing any padding. It
    will fill the entire display area by cropping portions of the image from view.
    This may be undesirable as portions of the image may not be visible to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: a 480x800 pixel image will appear as follows when rendered on a device
    display measuring 320x480:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/1420_06_23(2).jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the ActionBar within a Flex mobile project for use with ViewNavigator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flex mobile `ViewNavigatorApplication` and `TabbedViewNavigatorApplication`
    contain a special control called the `ActionBar`, which contains three editable
    child containers. We can define the contents of these child containers by modifying
    the MXML in our project documents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify the document MXML to customize our `ActionBar` contents. In this example,
    we will define some interactive image controls and provide a rich title image
    across our application `ViewStack:`
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first configure a new Flex mobile project, our main MXML document will
    appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ActionBar` contains three distinct areas within which we can define additional
    controls, they are the `navigationContent, titleContent`, and `actionContent`
    containers.![How to do it…](img/1420_06_24(2).jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will first define a `navigationContent` node within our main application
    MXML. Define a Spark `Image` control within, embedding a navigation image that
    will function as a way for users to get back to the "home" screen of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the `titleContent` container and create an `Image` control within
    it embedding an image used as the title of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, define a `actionContent` node and embed another image within it, just
    as we did for our `navigationContent` container. This will function as a close
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then set up a `script` block in our MXML to contain any functions we
    will be writing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a method within our script block that will return the user to our initial
    `View` when the `navigationContent` child `Image` is pressed by invoking the `ViewNavigator.popToFirstView()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a second method to exit the application when the `actionContent` child
    `Image` is pressed by the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will complete this example by assigning click events to each of our
    interactive `ActionBarImage` controls, registering them with the methods we created
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will also define our two `View` mxml files in such a way that these `ActionBar`
    controls will be clearly functional for this example. The initial `View` will
    include a Button in order to navigate to the secondary `View` using the `ViewNavigator.push()`
    method. When invoking this method, we simply need to pass in a reference to the
    particular the application should enable for the user to interact with. We can
    optionally pass in a second argument, which contains data to feed the `View`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the secondary `View`, a user can either exit the application through clicking
    the `ActionBar` exit `Image`, press the Android back button, or click the `ActionBarhome
    Image` to invoke the `ViewNavigator.popToFirstView()` method and return to the
    initial application state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CustomAction BarHomeView.mxml:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the application upon our device, the **ActionBar** will appear as
    follows:![How to do it…](img/1420_06_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Flex mobile `ActionBar` is an excellent structural element that can be used
    across a variety of mobile Android applications. The three container areas; `navigationContent,
    titleContent`, and `actionContent` behave much like any other Flex container.
    The contents of the `ActionBar` and the functions they perform are really up to
    the application developer and what makes sense for the target user. We must be
    sure to consider the amount of space available to us and how this can change across
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with the `ViewNavigator`, there are a number of important methods
    that mobile developers should be familiar with. We will briefly touch upon them
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '`popToFirstView()` removes all views from the `ViewNavigator` except the bottom
    view, essentially having the application return to the "home" view. `popView()pops`
    the current view off the navigation stack, exposing the previous view to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pushView()pushed` a new view to the top of the `ViewNavigator` navigation
    stack, making it the current view. For this to function, a valid `View` object
    reference must be passed in as an argument of this method.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also manage the view transitions by passing a transition reference through
    as the final argument in any of the `ViewNavigator` methods outlined in the previous
    section. For example, if we wanted to replace the normal sliding transition with
    a cube flipping up, we could do so through these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke a method to create our transition and pass it along as an argument of
    `ViewNavigator.popView()`. When creating our transition, we can define things
    such as duration, the direction of movement, and whether the `ActionBar` control
    is animated along with the view content or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a number of different transition types for us to explore when developing
    mobile Flex projects. This is just an example of how to go about using one of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the ActionBar control in a single view for a Flex mobile project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to use the `ViewNavigator` structure and functionality of the `ViewNavigatorApplication`
    container, but simply want to hide the `ActionBar` in a specific application View.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set the View `actionBarVisible` property to `true`. The following example shows
    how to toggle the `ActionBar` off and on for a particular `View` based on a button
    click:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new Flex mobile view-based application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new MXML file called `MainHomeView.mxml` within a `views` package
    that will define our primary view for this application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a `Button` component within the MXML file we just created, which constitutes
    our `ViewNavigatorApplicationfirstView:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then set up a `script` block in our MXML to contain any functions we
    will be writing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a function called `toggleActionBar` and within it, we will create
    an `if` statement checking whether the `actionBarVisible` property of our `View`
    is `true` or `false`. Depending upon the current `Boolean` value, we will toggle
    to the opposite value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we simply need to create a click event handler on our `Button` component
    to invoke the function just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `Button` will now toggle the `ActionBar` off and on when toggled:![How
    to do it…](img/1420_06_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each `View` of your application has an `actionBarVisible` property. Setting
    `actionBarVisible = false`; will hide the `ActionBar` control for those particular
    `Views` it is set on. This is really quite flexible, as we can turn the `ActionBar`
    control on and off as needed, depending upon which `View` we are currently on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mechanism with which we have removed the `ActionBar` control from our `View`
    is similar to the one with which we can use to remove the `TabBar` from a `TabbedViewNavigatorApplication`
    project by setting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
