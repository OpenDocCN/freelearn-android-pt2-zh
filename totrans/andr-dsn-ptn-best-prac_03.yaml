- en: Chapter 3. Material Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book we have looked at how to represent objects and collections
    of objects by using design patterns to create them and the card view to display
    them. Before we can start to put together a working application, we need to consider
    how a user will input their selections. There are numerous ways to gather information
    from the user on a mobile device, such as menus, buttons, icons, and dialogs.
    Android layouts generally have an application bar (previously known as the action
    bar) that usually sits at the top of the screen just under the status bar and
    layouts that implement material design, very often employ a sliding navigation
    drawer to provide access to an app's top-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case, the use of the support libraries, and in particular the
    **design library**, makes implementing material patterns such as the navigation
    bar remarkably easy, and material design contains visual patterns of its own that
    help encourage best UI practices. In this chapter, we will see how to implement
    the **app-bar**, the **navigation view**, and explore some of the visual patterns
    that material design provides. We will conclude with a quick look at the **singleton
    pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the action bar with an app-bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add action icons with the Asset Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply app-bar actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the app-bar at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a drawer layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add menus and sub-menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply ratio keylines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a drawer listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add fragments to an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the fragment back stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app-bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications have always contained a toolbar at the top of the screen.
    This was traditionally used to provide a title along with access to a top-level
    menu, and was called the action bar. Since Android 5 (API level 21) and the inception
    of material design, it has been possible to replace this with the far more flexible
    app-bar. The app bar allows us to set its color, place it anywhere on the screen,
    and include a wider range of content than its predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Android Studio templates use themes that include the old action bar as
    default, and the first thing we will need to do is remove the old version. To
    see how we remove the old action bar and replace it with a customized app-bar,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Android project using an empty activity template and set your material
    theme using the theme editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `styles.xml` file and edit the `style` definition to match the one
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new XML file alongside `activity_main.xml` and call it `toolbar.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following element to the `activity_main.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, edit the margin values in the `dimens.xml` file as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This toolbar is like any other ViewGroup in that it sits inside the root layout,
    so unlike the original action bar, it is not flush against the edges of the screen.
    This is why we needed to adjust the layout margins. Later, we will employ the
    CoordinatorLayout, which will automate much of this for us, but for now it is
    useful to see how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolbar is now positioned and shaded like the original but has none of
    the content or functions. This can be done in the Java element of the activity
    by editing the `onCreate()` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an error. This is because there are two possible libraries
    that could be imported here. Press **Alt + Enter** and select the support version
    of the Toolbar like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The app-bar](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To save time when working with Java, change the settings so that Java libraries
    are automatically imported when included in code. This is done from the **File**
    | **Settings** menu with **Editor** | **General** | **Auto Import**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the project on an emulator running API 20 or lower will immediately
    demonstrate one of the shortfalls of the AppCompat theme; despite declaring a
    color for our status bar `with colorPrimaryDark`, which works perfectly on API
    21 and higher, here it is still black:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The app-bar](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, this and the absence of natural-looking shadows is a small price to
    pay considering the number of people we can now reach.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have replaced the old-fashioned action bar with a toolbar and set
    it as the app bar (sometimes called a primary toolbar) we can take a closer look
    at how it works and how to apply material-compliant action icons using the Asset
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Image assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite possible to include text menus in the app-bar, but due to the limited
    space, it is more normal to use icons. Android Studio provides access to a collection
    of material icons via its Asset Studio. The following steps demonstrate how to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: From the drawable folder's menu in the project explorer, select **New | Image
    Asset**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select **Action Bar and Tab Icons** as the **Asset Type** and then click
    on the **Clipart** icon and select an icon from the collection of clip art:![Image
    assets](img/image_03_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This image must be trimmed, with 0% padding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a theme depending on whether your toolbar background color is light or
    dark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a suitable name and click on **Next**:![Image assets](img/image_03_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A much larger collection of material icons can be downloaded from the following
    URL: [https://design.google.com/icons](https://design.google.com/icons)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The asset studio automatically creates icons for us across four screen densities
    and places them in the correct folders so that they are deployed on the appropriate
    devices. It even applies the required **54% opaque black** that material design
    uses for icons. All we have to do to include these in our app bar is to add an
    icon property to the appropriate menu item. Later, we will use a navigation drawer
    to provide top-level access, but to see how to use an app-bar, we will add a search
    function. The icon we chose for this is called `ic_action_search`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Action icons are kept in the drawable folders and can be included in our action
    bar by including `items` within menu XML files. Depending on which template you
    used when first creating the project, you may have to add a new directory, `res/menu`,
    and a file called `main.xml` or `menu_main.xml` or whatever you choose as a **New
    | Menu resource file**. Actions can be added like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding example uses a reference to a string resource, and
    so must be accompanied by a definition in the `strings.xml` file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Menu items are automatically included in the app bar, with the title being taken
    from the `string name="app_name"` definition in the strings file. When constructed
    in this fashion, these components are positioned according to material guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the main Java activity and add this field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add these lines to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add the following method to the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should now be able to see our new toolbar on a device or emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying actions](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Being able to add any view we like to a toolbar makes it far more effective
    than the old action bar. We can have more than one at a time and they can even
    be placed elsewhere by applying layout gravity properties. The toolbar even comes
    with its own methods as we saw previously with the title and subtitle. We can
    also add icons and logos with these methods, but before we do so, it would be
    a good idea to explore app bar best practice according to material design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: App bar structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the techniques we have applied here conform to material guidelines
    without us having to do very much other than ensure its height, there will still
    be times when we are replacing the action bar with a custom toolbar layout, and
    we will need to know how to space and position the components. These are slightly
    different for tablets and desktops.
  prefs: []
  type: TYPE_NORMAL
- en: Phones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are just a few simple structural rules to remember when it comes to app
    bars. These cover margins, padding, width, height, and positioning, and they differ
    across platforms and screen orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `layout_height` of an app bar in portrait mode is `56 dp` and `48 dp` in
    landscape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App bars fill either the screen width or the width of their containing column.
    They cannot be divided into two. They have a `layout_width` of `match_parent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An app bar has an `elevation``2 dp` greater than the sheet of material it controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception to the preceding rule is if a card or dialog has its own toolbar,
    then the two can share the same elevation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App bars have padding of exactly `16 dp`. This means the contained icons must
    have no padding or margins of their own and therefore share edges with this margin:![Phones](img/image_03_006.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title text takes its color from your theme's primary text color and icons
    from secondary text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title should be positioned `72 dp` from the left of the toolbar and `20
    dp` from the bottom. This applies even when the toolbar is expanded:![Phones](img/image_03_007.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Title's text size is set with `android:textAppearance="?android:attr/textAppearanceLarge"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When constructing app bars for tablets and desktops, the rules are identical,
    with the following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The toolbar height is always `64 dp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title is indented by `80 dp` and does not move down when the bar is expanded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app bar's padding is `24 dp`, with the exception of the top, where it is
    `20 dp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have succeeded in constructing an app bar according to material guidelines,
    but action icons are of no use if they do not perform an action. In essence, when
    an app-bar assumes action bar functionality, it is really simply an access point
    to a menu. We will return to menus and dialogs later, but for now we will take
    a quick look at how toolbars can be manipulated at runtime with Java code.
  prefs: []
  type: TYPE_NORMAL
- en: The changes that have been made to the old action bar make it an easy and intuitive
    view to place global actions. The space, however, is limited, and for a more complex
    and graphical navigation component, we can turn to the sliding drawer.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation drawer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it is possible to have sliding drawers appear from either side of
    the screen, the navigation drawer should always be on the left and should have
    a higher elevation than all other views apart from the status and navigation bars.
    Think of the navigation drawer as a permanent fixture that spends most of its
    time hidden just off the edge of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The navigation drawer](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prior to the design library, components such as the navigation view had to be
    constructed from other views, and although the library vastly simplifies this
    process and saves us having to implement many material principles by hand, there
    are still several guidelines that we need to be aware of. The best way to appreciate
    these is by building a navigation sliding drawer from scratch. This will involve
    creating the layouts, applying material guidelines regarding component ratios,
    and connecting all this together with code.
  prefs: []
  type: TYPE_NORMAL
- en: Drawer construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will no doubt have noticed when setting up projects that Android Studio
    provides a **Navigation Drawer Activity** template. This creates much of the structure
    we might need and saves quite a bit of work. Once we have decided what features
    our sandwich building app will have, we will use this template. However, it is
    far more instructive to put one together from scratch to see how it works, and
    with this in mind, we will create a drawer layout that requires icons that can
    easily be found via the Asset Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an Android Studio project with a minimum SDK level of 21 or higher and
    provide it with your own customized colors and theme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line to your `styles.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you have the following dependency compiled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are not using the same project we used in the previous section, set up
    an app-bar layout called `toolbar.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `activity_main` and replace the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the root layout here is the **DrawerLayout** as provided by
    the support library. Note the `fitsSystemWindows` property; this is what makes
    the drawer extend up to the top of the screen under the status bar. Having set
    the `statusBarColor` to `android:color/transparent` in the style, the drawer is
    now visible through the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: This effect is not available on devices running Android versions older than
    5.0 (API 21), even with AppCompat, and this will alter the apparent aspect ratio
    of the header and clip any images. To counter this, create an alternative `styles.xml`
    resource that does not set the `fitsSystemWindows` property.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the layout consists of a LinearLayout and the **NavigationView**
    itself. The linear layout contains our app bar and an empty **FrameLayout**. FrameLayouts
    are the simplest of layouts, containing only a single item and generally used
    as a placeholder, which in this case will contain content based on the user's
    selection from the navigation menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from the preceding code, we will need a layout file for the
    header and a menu file for the drawer itself. The `header.xml f`ile should be
    created in the `layout` directory and look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add the following value to the `dimens.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you will see, we will need an image for the header. Here, it is called `header_background`
    and should have an aspect ratio of 4:3.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test this layout on devices with different screen densities, you will
    very soon see that this aspect ratio is not maintained. This can be easily countered
    in a similar way to the manner that we manage image resources, by using configuration
    qualifiers. To do this, follow the simple steps outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new directories for each density range with names such as `values-ldpi`,
    `values-mdpi`, and so on up to `values-xxxhdpi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of the `dimens.xml` file in each folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the value of `header_height` in each file to match that screen density.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The menu file is called `menu_drawer.xml` and should be placed in the `menu`
    directory, which you may need to create as well. Each item has an associated icon,
    and these can all be found in the Asset Studio. The code itself should match the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Most of the metrics of sliding drawers and navigation views such as margins
    and text sizes are taken care of for us thanks to the design library. However,
    the size, position, and color of text on a drawer header are not. Despite sharing
    a background, the text should be thought of as a 56-dp high component in its own
    right. It should have an internal padding of 16-dp and an 8-dp spacing between
    the lines. This, along with the correct text color, size, and weight can be derived
    from the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Ratio keylines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an element such as a sliding drawer fills the entire height of a screen
    and is divided into vertical segments, as our drawer is, between header and content,
    then these divisions can occur only at certain points known as ratio keylines.
    These points are determined by the ratio between the width of the element and
    how far from the top the division occurs. There are six such ratios allowed in
    material layouts, and they are defined as width to height (`width:height`) and
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '16:9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3:2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4:3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1:1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3:4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2:3![Ratio keylines](img/image_03_009.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example here, a 4:3 ratio was chosen, and the width of the drawer is
    256 dp. We could also have produced a header with a 16:9 ratio and set the `layout_height`
    at 144 dp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ratio keylines only relate to the distance from the top of the containing element;
    you cannot have one 16:9 view below another. However, you can place another view
    beneath this if it extends from the bottom of the top view down to another of
    the ratio keylines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ratio keylines](img/image_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activating the drawer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All that remains now is to implement some code in Java to get the layout working.
    This is done through a listener callback method that is called when the user interacts
    with the drawer. The following steps demonstrate how this is achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the MainActivity file and add the following lines in the `onCreate()`
    method to replace the action bar with our toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath this, add these lines to configure the drawer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add this code to set up the navigation view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Activating the drawer](img/image_03_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The preceding Java code allows us to view our drawer on a device or emulator
    but does very little when a navigation item is selected. What we really need to
    do is to actually be taken to another part of the app. This is very simply achieved,
    and we will come to it in a moment. First, there are one or two points in the
    preceding code that require a mention.
  prefs: []
  type: TYPE_NORMAL
- en: The line beginning `ActionBarDrawerToggle` is what causes the hamburger that
    opens the drawer to appear on the app bar, although you can of course open it
    with an inward swipe from the left of the screen. The two string arguments, `openDrawer`
    and `closeDrawer`, are for reasons of accessibility and are read out for users
    who are unable to see the screen clearly. They should say something like Navigation
    drawer opening and Navigation drawer closing. The two callback methods `onDrawerOpened()`
    and `onDrawerClosed()` were left empty here, but demonstrate where these events
    can be intercepted.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `drawerLayout.closeDrawers()` is essential, as otherwise the drawer
    would remain open. Here, we used the debugger to test the output, but ideally
    what we want is for the menu to direct us to another part of the application.
    This is not a difficult task and also provides a good opportunity to introduce
    one of the SDK's most useful and versatile classes, the **fragment**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From what we have learned so far, it would be safe to imagine that separate
    activities would be used for apps with more than one function, and although this
    is often the case it can be an expensive drain on resources and activities always
    fill the entire screen. Fragments operate like mini-activities, in that they have
    both Java and XML definitions and many of the same callbacks and functionality
    that activities do. Unlike activities, fragments are not top level components
    and must reside within a host activity. The advantage of this is that we can have
    more than one fragment per screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to do this, create a new Java class called something like `ContentFragment`
    and complete it as follows, making sure you import the `android.support.v4.app.Fragment`
    rather than the standard version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As for the XML element, create a layout file called `content.xml` and place
    whatever views and widgets you choose inside. All that is needed now is the Java
    code to call it when a navigation item is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.Java` file and replace one of the Debug calls in the
    `switch` statement with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The example we have built here is solely to demonstrate the basic anatomy of
    drawer layouts and navigation views. Clearly, to add any real functionality, we
    would need a fragment for each item in our menu, and the line `transaction.addToBackStack(null);`
    is actually redundant unless we do so. Its function is to ensure that the order
    a user accesses each fragment is recorded by the system in the same way it records
    which activities are used, so that when they press the back key they will return
    to the previous fragment. Without it, they would be returned to the previous application
    and the container activity would be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Right handed drawers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a top-level navigation component, the sliding drawer should only ever slide
    in from the left and should follow the metrics outlined earlier. However, it is
    very easy to have drawers that slide in from the right, and for many secondary
    functions this can be desirable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Right handed drawers](img/image_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Making a sliding drawer appear from the right is simply a matter of setting
    layout gravity, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the traditional navigation view, which should never be wider than the
    screen width minus the height of the primary app-bar, a right-handed drawer can
    extend across the entire screen.
  prefs: []
  type: TYPE_NORMAL
- en: The whole of this chapter has been about UI design, and we have not come across
    any design patterns. We could have used patterns here but chose to concentrate
    on the mechanics of Android UIs. We will see later in the book how useful the
    facade pattern can be to simplify coding a complex menu or layout.
  prefs: []
  type: TYPE_NORMAL
- en: One design pattern that could be introduced almost anywhere is the singleton.
    This is because it can be used almost anywhere and its purpose is to provide a
    global instance of an object.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The singleton is easily the simplest of patterns, but it is also one of the
    most controversial. Many developers think it entirely unnecessary and that declaring
    a class as static performs the same function with less fuss. Although it is true
    that the singleton is widely overused when a static class would be the cleaner
    choice, there are certainly times when one is preferable to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a static class when you want a function performed on a variable you pass
    to it, for example, calculating the discount value on a price variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a singleton pattern when you want a complete object, but only one, and you
    want that object to be available to any part of the program, for example, an object
    representing the individual user currently logged into an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class diagram for the singleton is, as you would imagine, remarkably simple,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The singleton pattern](img/image_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the preceding diagram suggests, the following example will assume we only
    have one user logged into our app at any one time and are going to create a singleton
    object that we can reach from any part of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio provides for singleton creation under the project explorer's
    **New** menu, so we can start there. There are only two steps to this demonstration;
    they are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this class to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the pattern by adding code like the following to the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The singleton can be extremely useful, but it is easy to apply it unnecessarily.
    It is very handy when tasks are asynchronous, such as filing systems, and when
    we want access to its contents from anywhere in the code, such as the user name
    in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever the purpose of an app, users need a familiar way to access it functions.
    The app-bar and navigation drawer are not only easily understood by the user,
    but provide great flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to apply two of the most significant input
    mechanisms available on Android devices and the material patterns that govern
    their appearance. The SDK, and in particular the design library, make coding these
    structure both simple and intuitive. Although different from the design patterns
    we have met so far, material patterns serve a similar function and guide us towards
    better practice.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter continues to look into layout design and explores the tools
    available to us when it comes to putting entire layouts together and how we manage
    to develop for a wide variety of screen shapes and sizes.
  prefs: []
  type: TYPE_NORMAL
