["```kt\nfinal int WIDTH = 800;\nfinal int HEIGHT = 480;\n\n// Create the camera\nCamera mCamera = new Camera(0, 0, WIDTH, HEIGHT);\n```", "```kt\n// We can position the camera anywhere in the game world\nmCamera.setCenter(WIDTH / 2, HEIGHT / 2);\n```", "```kt\n// Move the camera up and to the right by 5 pixels\nmCamera.offsetCenter(5, 5);\n// Move the camera down and to the left by 5 pixels\nmCamera.offsetCenter(-5, -5);\n```", "```kt\nmCamera.getCenterX();\nmCamera.getCenterY();\n```", "```kt\n// Shrink the camera by half its width\nmCamera.set(0, 0, mCamera.getWidth() / 2, mCamera.getHeight());\n```", "```kt\n// Check if entity is visible. true if so, false otherwise\nmCamera.isEntityVisible(entityObject);\n```", "```kt\nmCamera.setChaseEntity(entityObject);\n```", "```kt\nBoundCamera mCamera = new BoundCamera(0, 0, WIDTH, HEIGHT);\n```", "```kt\n// WIDTH = 800;\n// HEIGHT = 480;\n// WIDTH and HEIGHT are equal to the camera's width and height\nmCamera.setBounds(0, 0, WIDTH * 4, HEIGHT);\n\n// We must call this method in order to apply camera bounds\nmCamera.setBoundsEnabled(true);\n```", "```kt\nZoomCamera mCamera = new ZoomCamera(0, 0, WIDTH, HEIGHT);\n```", "```kt\n// Divide the camera width/height by 1.5x (Zoom in)\nmCamera.setZoomFactor(1.5f);\n\n// Divide the camera width and height by 0.5x (Zoom out)\nmCamera.setZoomFactor(0.5f);\n```", "```kt\n// Camera movement speeds\nfinal float maxVelocityX = 10;\nfinal float maxVelocityY = 5;\n// Camera zoom speed\nfinal float maxZoomFactorChange = 5;\n\n// Create smooth camera\nmCamera = new SmoothCamera(0, 0, WIDTH, HEIGHT, maxVelocityX, maxVelocityY, maxZoomFactorChange);\n```", "```kt\n    public class ApplyingPinchToZoom extends BaseGameActivity implements\n        IOnSceneTouchListener, IPinchZoomDetectorListener {\n    ```", "```kt\n    /* Set the scene to listen for touch events using\n    * this activity's listener */\n    mScene.setOnSceneTouchListener(this);\n\n    /* Create and set the zoom detector to listen for \n     * touch events using this activity's listener */\n    mPinchZoomDetector = new PinchZoomDetector(this);\n\n    // Enable the zoom detector\n    mPinchZoomDetector.setEnabled(true);\n    ```", "```kt\n    @Override\n    public boolean onSceneTouchEvent(Scene pScene, TouchEvent pSceneTouchEvent) {\n      // Pass scene touch events to the pinch zoom detector\n      mPinchZoomDetector.onTouchEvent(pSceneTouchEvent);\n      return true;\n    }\n    ```", "```kt\n    /* This method is fired when two fingers press down\n    * on the display */\n    @Override\n    public void onPinchZoomStarted(PinchZoomDetector pPinchZoomDetector,\n        TouchEvent pSceneTouchEvent) {\n      // On first detection of pinch zooming, obtain the initial zoom factor\n      mInitialTouchZoomFactor = mCamera.getZoomFactor();\n    }\n    ```", "```kt\n    @Override\n    public void onPinchZoom(PinchZoomDetector pPinchZoomDetector,\n        TouchEvent pTouchEvent, float pZoomFactor) {\n\n      /* On every sub-sequent touch event (after the initial touch) we offset\n      * the initial camera zoom factor by the zoom factor calculated by\n      * pinch-zooming */\n      final float newZoomFactor = mInitialTouchZoomFactor * pZoomFactor;\n\n      // If the camera is within zooming bounds\n      if(newZoomFactor < MAX_ZOOM_FACTOR && newZoomFactor > MIN_ZOOM_FACTOR){\n        // Set the new zoom factor\n        mCamera.setZoomFactor(newZoomFactor);\n      }\n    }\n    ```", "```kt\n    /* Create the background left texture atlas */\n    BuildableBitmapTextureAtlas backgroundTextureLeft = new BuildableBitmapTextureAtlas(\n        mEngine.getTextureManager(), 800, 480);\n\n    /* Create the background left texture region */\n    mBackgroundLeftTextureRegion = BitmapTextureAtlasTextureRegionFactory\n        .createFromAsset(backgroundTextureLeft, getAssets(),\n            \"background_left.png\");\n\n    /* Build and load the background left texture atlas */\n    try {\n      backgroundTextureLeft\n          .build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(\n              0, 0, 0));\n      backgroundTextureLeft.load();\n    } catch (TextureAtlasBuilderException e) {\n      e.printStackTrace();\n    }\n    ```", "```kt\n    final int halfTextureWidth = (int) (mBackgroundLeftTextureRegion.getWidth() * 0.5f);\n    final int halfTextureHeight = (int) (mBackgroundLeftTextureRegion.getHeight() * 0.5f);\n\n    // Create left background sprite\n    mBackgroundLeftSprite = new Sprite(halfTextureWidth, halfTextureHeight, mBackgroundLeftTextureRegion,\n        mEngine.getVertexBufferObjectManager())\n    ;\n    // Attach left background sprite to the background scene\n    mScene.attachChild(mBackgroundLeftSprite);\n\n    // Create the right background sprite, positioned directly to the right of the first segment\n    mBackgroundRightSprite = new Sprite(mBackgroundLeftSprite.getX() + mBackgroundLeftTextureRegion.getWidth(),\n        halfTextureHeight, mBackgroundRightTextureRegion,\n        mEngine.getVertexBufferObjectManager());\n\n    // Attach right background sprite to the background scene\n    mScene.attachChild(mBackgroundRightSprite);\n    ```", "```kt\n@Override\npublic EngineOptions onCreateEngineOptions() {\n\n  // Create the camera\n  Camera mCamera = new Camera(0, 0, WIDTH, HEIGHT);\n\n  // Create the HUD\n  HUD mHud = new HUD();\n\n  // Attach the HUD to the camera\n  mCamera.setHUD(mHud);\n\n  EngineOptions engineOptions = new EngineOptions(true,\n      ScreenOrientation.LANDSCAPE_FIXED, new FillResolutionPolicy(),\n      mCamera);\n\n  return engineOptions;\n}\n```", "```kt\n  // Create the HUD\n  HUD mHud = new HUD();\n\n  // Attach the HUD to the camera\n  mCamera.setHUD(mHud);\n```", "```kt\n// Position the controller in the bottom left corner of the screen\nfinal float controllerX = mControllerBaseTextureRegion.getWidth();\nfinal float controllerY = mControllerBaseTextureRegion.getHeight();\n\n// Create the controller\nmController = new AnalogOnScreenControl(controllerX, controllerY, mCamera, mControllerBaseTextureRegion, mControllerKnobTextureRegion, 0.1f, mEngine.getVertexBufferObjectManager(), new IAnalogOnScreenControlListener(){\n  /* The following method is called every X amount of seconds,\n  * where the seconds are determined by the pTimeBetweenUpdates\n  * parameter in the controller's constructor  */\n  @Override\n  public void onControlChange(\n      BaseOnScreenControl pBaseOnScreenControl, float pValueX,\n      float pValueY) {\n    mCamera.setCenter(mCamera.getCenterX() + (pValueX * 10), mCamera.getCenterY() + (pValueY * 10));\n    Log.d(\"Camera\", String.valueOf(mCamera.getCenterX()));\n  }\n\n  // Fired when the knob is simply pressed\n  @Override\n  public void onControlClick(\n      AnalogOnScreenControl pAnalogOnScreenControl) {\n    // Do nothing\n  }\n\n});\n\n// Initialize the knob to its center position\nmController.refreshControlKnobPosition();\n\n// Set the controller as a child scene\nmScene.setChildScene(mController);\n```", "```kt\n    /* Create a rectangle on the Scene that will act as a layer */\n    final Rectangle rectangleLayer = new Rectangle(0, HEIGHT * 0.5f, 200, 200, mEngine.getVertexBufferObjectManager()){\n\n      /* Obtain the half width of this rectangle */\n      int halfWidth = (int) (this.getWidth() * 0.5f);\n\n      /* Boolean value to determine whether to pan left or right */\n      boolean incrementX = true;\n\n      @Override\n      protected void onManagedUpdate(float pSecondsElapsed) {\n\n        float currentX = this.getX();\n\n        /* Determine whether or not the layer should pan left or right */\n        if(currentX + halfWidth > WIDTH){\n          incrementX = false;\n        }\n        else if (currentX - halfWidth < 0){\n          incrementX = true;\n        }\n        /* Increment or decrement the layer's position based on incrementX */\n        if(incrementX){\n          this.setX(currentX + 5f);\n        } else {\n          this.setX(currentX - 5f);\n        }\n\n        super.onManagedUpdate(pSecondsElapsed);\n      }\n    };\n\n    rectangleLayer.setColor(0, 0, 1);\n\n    // Attach the layer to the scene\n    mScene.attachChild(rectangleLayer);\n    ```", "```kt\n    /* Create a smaller, second rectangle and attach it to the first */\n    Rectangle rectangle = new Rectangle(0, 0, 50, 50, mEngine.getVertexBufferObjectManager()){\n\n      /* Obtain the coordinates in the middle of the Scene that we will\n       * convert to everytime the parent rectangle moves */\n      final float convertToMidSceneX = WIDTH * 0.5f;\n      final float convertToMidSceneY = HEIGHT * 0.5f;\n\n      @Override\n      protected void onManagedUpdate(float pSecondsElapsed) {\n\n        /* Convert the specified x/y coordinates into Scene coordinates,\n          * passing the resulting coordinates into the convertedCoordinates array */\n        final float convertedCoordinates[] = rectangleLayer.convertSceneCoordinatesToLocalCoordinates(convertToMidSceneX, convertToMidSceneY);\n\n        /* Since the parent is moving constantly, we must adjust this rectangle's\n         * position on every update as well. This will keep in in the center of the \n         * display at all times */\n        this.setPosition(convertedCoordinates[0], convertedCoordinates[1]);\n\n        super.onManagedUpdate(pSecondsElapsed);\n      }\n\n    };\n\n    /* Attach the second rectangle to the first rectangle */\n    rectangleLayer.attachChild(rectangle);\n    ```", "```kt\n      public static final int WIDTH = 400;\n      public static final int HEIGHT = 480;\n\n    /* We'll need two Scene's for the DoubleSceneSplitScreenEngine */\n      private Scene mSceneOne;\n      private Scene mSceneTwo;\n\n      /* We'll also need two Camera's for the DoubleSceneSplitScreenEngine */\n      private SmoothCamera mCameraOne;\n      private SmoothCamera mCameraTwo;\n    ```", "```kt\n    /* Create the first camera (Left half of the display) */\n    mCameraOne = new SmoothCamera(0, 0, WIDTH, HEIGHT, 0, 0, 0.4f){\n      /* During each update to the camera, we will determine whether\n       * or not to set a new zoom factor for this camera */\n      @Override\n      public void onUpdate(float pSecondsElapsed) {\n        final float currentZoomFactor = this.getZoomFactor();\n        if(currentZoomFactor >= MAX_ZOOM_FACTOR){\n          this.setZoomFactor(MIN_ZOOM_FACTOR);\n        }\n        else if(currentZoomFactor <= MIN_ZOOM_FACTOR){\n          this.setZoomFactor(MAX_ZOOM_FACTOR);\n        }\n        super.onUpdate(pSecondsElapsed);\n      }\n    };\n    /* Set the initial zoom factor for camera one*/\n    mCameraOne.setZoomFactor(MAX_ZOOM_FACTOR);\n\n    /* Create the second camera (Right half of the display) */\n    mCameraTwo = new SmoothCamera(0, 0, WIDTH, HEIGHT, 0, 0, 1.2f){\n      /* During each update to the camera, we will determine whether\n       * or not to set a new zoom factor for this camera */\n      @Override\n      public void onUpdate(float pSecondsElapsed) {\n        final float currentZoomFactor = this.getZoomFactor();\n        if(currentZoomFactor >= MAX_ZOOM_FACTOR){\n          this.setZoomFactor(MIN_ZOOM_FACTOR);\n        }\n        else if(currentZoomFactor <= MIN_ZOOM_FACTOR){\n          this.setZoomFactor(MAX_ZOOM_FACTOR);\n        }\n        super.onUpdate(pSecondsElapsed);\n      }\n    };\n    /* Set the initial zoom factor for camera two */\n    mCameraTwo.setZoomFactor(MIN_ZOOM_FACTOR);\n    ```", "```kt\n    /* The first camera is set via the EngineOptions creation, as usual */\n    EngineOptions engineOptions = new EngineOptions(true,\n        ScreenOrientation.LANDSCAPE_FIXED, new FillResolutionPolicy(),\n        mCameraOne);\n\n    /* If users should be able to control each have of the display\n     *  simultaneously with touch events, we'll need to enable \n     *  multi-touch in the engine options */\n    engineOptions.getTouchOptions().setNeedsMultiTouch(true);\n    ```", "```kt\n    @Override\n    public Engine onCreateEngine(EngineOptions pEngineOptions) {\n\n      /* Return the DoubleSceneSplitScreenEngine, passing the pEngineOptions\n      * as well as the second camera object. Remember, the first camera has\n      * already been applied to the engineOptions which in-turn applies the\n      * camera to the engine. */\n      return new DoubleSceneSplitScreenEngine(pEngineOptions, mCameraTwo);\n    }\n    ```", "```kt\n    @Override\n    public void onCreateScene(OnCreateSceneCallback pOnCreateSceneCallback) {\n\n      /* Create and setup the first scene */\n      mSceneOne = new Scene();\n      mSceneOne.setBackground(new Background(0.5f, 0, 0));\n\n      /* In order to keep our camera's and scenes organized, we can\n       * set the Scene's user data to store its own camera */\n      mSceneOne.setUserData(mCameraOne);\n\n      /* Create and setup the second scene */\n      mSceneTwo = new Scene();\n      mSceneTwo.setBackground(new Background(0,0,0.5f));\n\n      /* Same as the first Scene, we set the second scene's user data\n       * to hold its own camera */\n      mSceneTwo.setUserData(mCameraTwo);\n\n      /* We must set the second scene within mEngine object manually.\n       * This does NOT need to be done with the first scene as we will\n       * be passing it to the onCreateSceneCallback, which passes it\n       * to the Engine object for us at the end of onCreateScene()*/\n      ((DoubleSceneSplitScreenEngine) mEngine).setSecondScene(mSceneTwo);\n\n      /* Pass the first Scene to the engine */\n      pOnCreateSceneCallback.onCreateSceneFinished(mSceneOne);\n    }\n    ```", "```kt\n        /* Apply a rectangle to the center of the first scene */\n        Rectangle rectangleOne = new Rectangle(WIDTH * 0.5f, HEIGHT * 0.5f, rectangleDimensions, rectangleDimensions, mEngine.getVertexBufferObjectManager());\n        rectangleOne.setColor(org.andengine.util.adt.color.Color.BLUE);\n        mSceneOne.attachChild(rectangleOne);\n\n        /* Apply a rectangle to the center of the second scene */\n        Rectangle rectangleTwo = new Rectangle(WIDTH * 0.5f, HEIGHT * 0.5f, rectangleDimensions, rectangleDimensions, mEngine.getVertexBufferObjectManager());\n        rectangleTwo.setColor(org.andengine.util.adt.color.Color.RED);\n        mSceneTwo.attachChild(rectangleTwo);\n    ```"]