- en: Chapter 3. Intent and Its Categorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Intents** are asynchronous messages used to activate one Android component
    using another. These intents are used to trigger the Android OS when some event
    has occurred, and some action should be taken. The Android OS, on the basis of
    the data received, determines the receiver for the intent and triggers it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, there are two types of intents: **explicit** and **implicit**. As
    their names suggest, explicit intents trigger specific components of the Android
    OS specified explicitly by the developers. However, implicit intents trigger the
    general components of any category of the Android OS. It''s left to the Android
    OS to decide which component needs to be activated. If there is more than one
    general component, the user is asked to select a component from a list of all
    the components. This feature of the intents in the Android OS makes an application
    more interactive because the other applications and developers can also access
    it. For example, you are developing a picture-editing Android application to edit
    any image, apply filters to it, and so on. So, if the application receives images
    from any source of the Android system, such as an e-mail attachment, gallery images,
    any other image tools, and so on, the application will become more interactive
    and responsive as compared to the application that loads images from the app itself.
    This interaction of the application, whether it is sending an image via e-mail
    or receiving an image in an editing application, is implemented through implicit
    intents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using explicit intents in an Android application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using implicit intents in an Android application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intents and Android late binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of intents and their structure, as discussed in the previous chapter,
    are the prerequisites for understanding this chapter and the chapters that follow.
    If you don't have a basic understanding of these things, read [Chapter 2](ch02.html
    "Chapter 2. Introduction to Android Intents"), *Introduction to Android Intents*,
    in order to move forward.
  prefs: []
  type: TYPE_NORMAL
- en: These two types of intents, namely, explicit and implicit intents, are very
    different in terms of functionality. Let's start with the simplest type of intent
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest type of intent is the explicit intent. When a developer knows
    which component to use and doesn''t want to provide free access to the user, explicit
    intent is the best choice. Here, the developer explicitly specifies the component
    to be triggered in the declaration of the intent. This component can be any activity,
    service, or broadcast receiver. For example, an Android application usually consists
    of more than one activity for a corresponding functionality. In order to navigate
    from one activity to another, an explicit intent is used. The following code snippet
    shows a simple declaration of such an explicit intent that targets activity B
    from activity A:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explicit intents](img/9639_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Intents are instances of the `android.content.Intent` class. The explicit components
    are specified as Java class identifiers, and they are used by the Android OS to
    activate them whenever a developer sends the intent. As explained in the earlier
    chapters, an object of the intent takes two parameters: **context** and **class**.
    The context parameter receives the source context from which the intent is triggered
    to activate other components. The class parameter takes the class object of a
    specific class that is used to specify the target component. In the preceding
    code snippet, an `intent` object takes the `ActivityA` class as the source component
    and `ActivityB` as the target component to be activated. Now, this `intent` object
    declared in the code snippet with the specific component as the target can be
    used anywhere. For example, it can be used for starting `ActivityB` with `ActivityA`
    as the parent activity. The following section describes the uses of explicit intents
    to trigger various components such as activities, services, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Using explicit intents in an Android application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will discuss the various uses of explicit intents in an
    Android application. As discussed earlier, explicit intents can be used in activating
    other components such as activities, services, and broadcast receivers. We will
    talk about two examples of explicit intents; the first one to start one activity
    from another activity, and the other to start a service in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Starting an activity through an explicit intent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any Android application contains at least one or multiple activities. So, in
    the case of multiple activities, navigating between them becomes important for
    a developer. In this section, we will develop an example of two activities in
    which we will start one activity from the other and go back to it after stopping/finishing
    the currently opened activity. The following figure shows a simple prototype of
    the example we are about to develop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting an activity through an explicit intent](img/9639_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As it is clear from the preceding figure, we have two activities: **Main Activity**
    and **Second Activity**. Both the activities have a single button to navigate
    and a title showing the name of the activity. Now, let''s get started with the
    development of our first example. But, in order to start this example, you need
    to build an Android project. You can use Android Studio or Eclipse (as per your
    convenience), but in the case of Eclipse, make sure that you have correctly installed
    the JDK, ADT, and Android SDK along with their compatibility. If you don''t know
    the difference between these IDEs, refer to the first chapter of this book. Creating
    a project in Android Studio has been explained in the previous chapter. Repeating
    those steps will give you a complete Android project with some predefined files
    and folders.'
  prefs: []
  type: TYPE_NORMAL
- en: After creating an empty Android project, we are going to implement the use of
    explicit intents. In the example, we will write or modify many different files
    of various types, such as Java, XML, and so on. Each file has its own purpose
    and performs its own functionality in the example. Let's explore these files one
    by one now.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main file of the project is `MainActivity.java`. The following is the code
    snippet to be implemented in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java class](img/9639_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The applications having more than one activity must have a main activity. This
    main activity defines the starting point of the application. In our example, the
    `MainActivity.java` class is the main activity of the project. To provide a layout
    file to the activity for visual representation, we will call `setContentView(R.layout.activity_main)`
    within the `onCreate()` method of the activity. The `activity_main.xml` file is
    the layout file contained in the `layout` folder of the project directory and
    represents the main screen of the app. After setting the View of the activity,
    we get all the components that will be used in the activity by getting their Views
    from the layout file. To get the View of any component, we will use the `findViewById()`
    method that takes an ID of the View and returns a `View` object that is the type
    casted as per our requirements. In this file, we've got the `View` object of the
    button having the ID, `button1`, in the layout file, and we have the `Button`
    type casted it to and reference it to our button. Any button should have listeners
    for user interaction with the View and customizing the behavior of the View. In
    our file, we only set `View.OnClickListener` for the button to get the clicks/taps
    of the button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two `OnClickListener` classes in the Android SDK. One is in the `View`
    class. It is used for Views such as buttons, text fields, and so on. The other
    is in the `DialogInterface` class and is used for the detection of clicks and
    taps in dialogs. Developers should be careful when importing classes and their
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: We have set the `OnClickListener` object of the button using the `setOnClickListener()`
    method of the `Button` object. We referenced an anonymous listener in the parameter
    of the method, and have overridden the `onClick()` method. In the `onClick()`
    method, we have to provide the behavior that we want to show when a button is
    tapped on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anonymous objects are the objects that have no object name specified by the
    developer. And because of this reason, developers can't access the object directly
    in the code. You can also set the `OnClickListener` object of the View by creating
    the object of the interface and passing it in the `setOnClickListener()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an intent object with `MainActivity` as the source context,
    and the `SecondActivity` class is the target component to be activated. One thing
    to be noted here is that instead of passing the object of `SecondActivity`, we
    have explicitly passed the Java class representation of `SecondActivity`. This
    is how we have declared an explicit intent object. Now, through this intent object,
    we can do many different tasks depending on our requirements, but in our case,
    the options are limited. We have created an explicit intent that contains very
    specific information; so, for that reason, this intent can be used for limited
    purposes only. In this example, the intent is used to start another activity on
    top of a back stack by calling the `startActivity()` method. This method takes
    the parameter of an explicit intent object having the information of the source
    context and target activity.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To declare the intent in a class other than running activities, we can use the
    application context to pass in the context parameter of the intent constructor.
    This can be accessed by the `getApplicationContext()` method.
  prefs: []
  type: TYPE_NORMAL
- en: So, summarizing the functionality of the file here, the file represents the
    starting point of the application that shows a button. On tapping the button,
    the application navigates to another activity. This navigation between activities
    is implemented through an explicit intent object. After implementing the `MainActivity`
    file, let's implement our second activity in the `SecondActivity.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: The SecondActivity.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `SecondActivity.java` class is the destination activity for our explicit
    intent. The following is the code snippet implemented in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SecondActivity.java class](img/9639_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, this class is extended from the `Activity` class, and follows the activity
    lifecycle. It should also override the lifecycle-callback methods as well. In
    the `onCreate()` method, we set the View of the activity by calling the `setContentView()`
    method, and this time, we have passed the `activity_main2.xml` file's reference
    using `R.layout.activity_main2`. This XML file is placed in the `layout` folder
    under `res`. We again get the `View` component of the button from the layout file
    by calling the `findViewById()` method, and we typecast this to `Button`. We then
    set `OnClickListener()` of the button to an anonymous listener, and override the
    `onClick()` method to define the behavior on a button tap. This time, we call
    the `Activity.finish()` method in the `onClick()` method. This method simply pulls
    out the activity on top from the back stack.
  prefs: []
  type: TYPE_NORMAL
- en: As we started `SecondActivity` from `MainActivity`, when we finish `SecondActivity`,
    we will see `MainActivity` again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The back button in Android devices simply calls the `finish()` method for activities
    or the `dismiss()` method for dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create an intent object with the context of `SecondActivity` and
    the target class of `MainActivity.java`. But, this will create a new instance
    of `MainActivity` in the back stack, and will push this on top of `SecondActivity`.
    In that case, we will have two instances of `MainActivity` and one instance of
    `SecondActivity` placed in the middle of these activities in the back stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we set the `android:noHistory` attribute to `true` in the `<activity>` tag
    of `MainActivity` in the `AndroidManifest.xml` file, starting a new instance of
    `MainActivity` will result in an already-created instance to be placed on top
    of the back stack, thus avoiding the creation of a new object. Developers should
    be more careful at the time of creating the app flow and navigation control because
    this type of flow can make loops in the app. This can cause a never-ending app
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: We should note that both activity files, `MainActivity.java` and `SecondActivity.java`,
    contain almost the same code except the button listener of `MainActivity` that
    starts a new activity using explicit intent, and the button listener of `SecondActivity`
    that just pulls back the application by auto-pressing the back button of an Android
    phone.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have learned how an explicit intent can be used to navigate to
    another activity. But, it should be remembered here that both activities were
    using different layout files for visual representation containing the action buttons
    that performed both tasks. It should be noted that the layout files don't play
    any role in the navigation of explicit intents. These files just show the visual
    content of activities to make the user interaction easy. Now, let's focus on those
    layout files.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The activity_main.xml file is the layout file of `MainActivity.java` and is
    written in XML. The following code shows the implementation of the layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the layout file, we have `LinearLayout` and `<Button>` Views within the
    layout. Remember that this button was extracted by the `MainActivity` file after
    setting the View of the activity to `OnClickListener`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The references of all the layouts and Views declared in the XML files are autogenerated
    inside the `R.java` file. In Java, we can use the `R` class and access components
    in a static manner. For example, we could use `R.layout.layout_name` for layout.
    However, in XML, `R` can be accessed by placing `@`. For example, for accessing
    a color, we can use `android:name="@color/my_custom_color"`.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the `activity_main.xml` file, there is `<LinearLayout>` with certain
    parameters regarding `height`, `width`, and `orientation`. As you can see, inside
    the tags of `<LinearLayout>`, the `<Button>` tag that is brought into the code
    of Java through the `findViewById()` method in the activity is declared. This
    tag also comes with certain parameters such as `id`, `width`, `height`, and `text`
    that will appear in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main2.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The activity_main2.xml file layout is a visual representation of the `SecondActivity`
    class. The following code shows this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main2.xml file](img/9639_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This layout is the same as the `activity_main` layout except that the text values
    of buttons are different. This is used in the `SecondActivity.java` class. Again,
    a button is referenced from XML to Java through the `findViewById()` method in
    the activity, and `OnClickListener` is set to define the custom action to be performed
    when a button is tapped on.
  prefs: []
  type: TYPE_NORMAL
- en: No Android application is complete without the `AndroidManifest` file. We have
    already implemented the visual layouts of our example app and also their functionality
    of navigating from one activity to the other, using explicit intents. However,
    when any application has multiple activities, the Android OS must be informed
    about all those activities and their attributes. In order to inform the Android
    OS about how many activity classes are used, the `AndroidManifest` file is used.
    Let's see how this file informs the Android OS about the activities.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `AndroidManifest.xml` file contains all the settings and preferences of
    the application. When working on multiple activities, developers should be careful
    while declaring activities. Only one activity that defines the starting point
    of the application should have an intent filter of the launcher. All activities
    should be saved in here. The information about activities can include the label
    of the activity, theme of the activity, orientation, and so on. For activities,
    the `AndroidManifest.xml` file is like a registration center where all the components
    in the app, such as `Activity` classes, `Service` classes, and so on, should be
    registered. If any activity is not registered in the `AndroidManifest.xml` file,
    Android OS will throw the `ActivityNotFoundException` exception on calling that
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'About our explicit intent app, both the activities, `MainActivity` and `SecondActivity`,are
    registered in the `AndroidManifest.xml` file. It should be noted here that `MainActivity`
    has a subtag of `<intent-filter>` that declares `MainActivity` as the starting
    or launcher activity of the whole application. The following is the code implemented
    in the `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the `AndroidManifest.xml` file, our explicit intent example is completed.
    In this example, we defined two activities; one of them was the main activity.
    The main activity used an explicit intent to start the other activity by declaring
    its name explicitly. The example contained two layout files for a visual representation
    of both the activities and the manifest file to register all the activities and
    basic settings for the application. When you run the project, you should see the
    screen transition as shown in following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will have a look at another use of explicit intents
    in services. We will learn how a service is started explicitly using intents from
    an activity.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a service through an explicit intent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike activities, services perform specific tasks and actions in the background.
    Services don't have any visual layout or UI. It must be noted that services run
    on the main thread of the app; so, when Android has a need of memory, it will
    stop the services that are not running or are in a paused state. In the next example,
    we will start a service using an explicit intent, and we will also stop it using
    the same explicit intent. So, in order to start this example, create an empty
    project using any Android IDE such as Eclipse with the ADT plugin or Android Studio.
    In this project, we will implement the use of explicit intents for starting/stopping
    services. As our main focus is on explicit intents, we will create a very simple
    service that will display toasts on being started or stopped by the activity.
    We have modified/implemented the four section in the example application. So,
    let's see what these files do one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The ServiceExample.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since our example app includes a service, this file is a representation of
    a service class used in our app. The following code shows the implementation of
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Android development, we have to extend our class from the `Service` class
    and override and implement the required methods according to our customizations
    to create any service. At first, the `onBind()` method is to be implemented by
    the developer, and this is a mandatory one. This method is an abstract method
    of `Service`. This method is used to bind the running services at runtime. Then,
    `onCreate()` and `onStart()` methods are the same as in the activity class. Developers
    do the necessary initial setup in these methods. In our example, we are just going
    to display toasts to notify the user about the method calls. The `onStartCommand()`
    method is a very important method, and this is where we do all the background
    work. It should be noted that services run in the main thread. So, if you want
    to do heavy processing tasks, you should create a separate thread in this method
    and start it. This is how background processing is done in the standard way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also create threads in the main thread, and perform our heavy processing
    in the background; then why do we need services to create a thread? In Android
    OS, services are the standard method for doing background processing. When the
    Android OS becomes short on memory, it can stop the idle services to get their
    memory. But it can't stop the threads; so, using services is a better way of continuously
    performing tasks in the background.
  prefs: []
  type: TYPE_NORMAL
- en: We are not doing anything in the `onStartCommand()` method except displaying
    a toast like other methods of the service class. There isn't any special point
    to mention about the service class. Like the previous example, the most important
    part in this example app is the main activity. Let's see the main activity class
    in detail now.
  prefs: []
  type: TYPE_NORMAL
- en: The ServiceDemoActivity.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ServiceDemoActivity.java class is the main activity of our app and defines
    the starting point of the application. The following code shows the implementation
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ServiceDemoActivity.java class](img/9639_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This class is extended from the `Activity` class, and we have overridden some
    of its methods. In the `onCreate()` method, we set the Content View layout of
    the activity by referencing the layout stored in the `res/layout` folder of the
    app. Then, we extracted buttons in the layout and set `OnClickListener` for those
    buttons. In an earlier example, we used anonymous objects of the `OnClickListener`
    interface for buttons. In this example, we are providing the `Activity` class
    as our `OnClickListener` by passing `this` in the parameter of the `setOnClickListener()`
    method. The object passed in the parameter must implement the `OnClickListener`
    interface and override the `onClick()` method. So, our activity class implements
    this interface along with the extending activity. We have also overridden the
    `onClick()` method in this class. As we have two buttons this time and only one
    `OnClickListener` interface for both, we have to first find which button has been
    pressed and then take action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to get the ID of the pressed View and compare it with
    the IDs in the resources. So, the `getId()` method returns the ID of the View
    to us; we pass the ID in the switch block and compare it with our IDs of the buttons.
    In both cases, we are creating an explicit intent that passes the context of the
    activity and our service class name as the target component to be activated, as
    we did in our activity example. How the service is being started by the `startService()`
    method and being stopped by the `stopService()` method should be noted. These
    methods take explicit intents that include information about which service has
    to be started or stopped. This class showed us how easy is it to use explicit
    intents to start or stop any service from any activity. As usual, this main activity
    is using two buttons, `Start` and `Stop`, which are extracted from a layout placed
    in the resources folder of the Android project directory. Let's see what this
    layout file contains.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The activity_main.xml file is the layout file of `ServiceDemoActivity` and
    is written in XML. The following code shows the implementation of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have a `<LinearLayout>` element and two button Views in the layout. Remember
    that these buttons were extracted by the `ServiceDemoActivity` file to set `OnClickListener`
    for both buttons after setting the View of the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can create layouts in XML as well as Java. Android recommends creating all
    the layouts in XML because Java is used for processing in Android. If we create
    layouts in Java, the layout creation will also be processed; this can make the
    app more battery consumptive. Use Java only for dynamic layouts such as the ones
    used in games.
  prefs: []
  type: TYPE_NORMAL
- en: When describing the `activity_main.xml` file, there is a `<LinearLayout>` element
    with certain parameters regarding `height`, `width`, and `orientation`. As you
    can see, inside the `<LinearLayout>` tag, there are buttons declared that are
    brought into the code of Java. This tag also comes with certain parameters about
    `height`, `width`, `id`, and `text` that will appear in the layout. Last but not
    least, the Android manifest file is for the application settings. Like activities,
    a developer has to register all the services implemented in the app in the manifest
    file. Let's have a look at the file and see how we have registered our service
    in the manifest file of the example app.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To register a service, we have to provide the code inside the `<application>`
    tag. The following code shows the full implementation of the `AndroidManifest.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It can be noted that after `<activity>` tags, we have placed the `<service>`
    tag with the attribute name to define which service we are registering. If we
    don''t register our service in the `AndroidManifest.xml` file, we will get a `ServiceNotFoundException`
    exception thrown, and we will get error log such as "`Unable to start service
    (service package with name): not found`".'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**LogCat** is found in the DDMS View in Android Studio. LogCat logs all the
    activity being done in the connected device or emulator. Any `Force Close` crash
    exception that is thrown is logged in LogCat, and a developer can find the cause
    of the crash from it and solve it.'
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have focused on explicit intents, and we created two simple apps
    that use explicit intents. Now, let's move to another type of intent called implicit
    intent.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike explicit intents, when a developer doesn''t know which component to
    use, implicit intent is a good choice. Implicit intents do not directly specify
    the Android components to be activated as in explicit intents, but they only specify
    which actions need to be performed. The Android OS will choose the components
    to be triggered. If there are multiple components which can be triggered, the
    Android OS provides options to the user to select one component. For example,
    we want to open a web link in a browser. If we use explicit intents, one option
    that we have is to develop our own custom browser and trigger it explicitly from
    our app to view the web link. The other way, which is more preferable, is to use
    implicit intents to open any already-installed browser in the phone. If there
    is more than one browser installed in the phone, the user will be given the choice
    to select one for performing the action, that is, view the web link. This feature
    of implicit intents works as a general form to perform any action in the Android
    OS. We specify the data and action in the intent, and Android chooses a suitable
    component according to that data. The following code snippet shows a simple declaration
    of an implicit intent that provides a link to be browsed by Android in the best
    suitable component or browser in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implicit intents](img/9639_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like explicit intents, two parameters are passed in the constructor of the implicit
    intent. You can read more about constructors of intents in [Chapter 2](ch02.html
    "Chapter 2. Introduction to Android Intents"), *Introduction to Android Intents*.
    The first parameter is the action to be performed by the Android OS; we specified
    it here as `ACTION_VIEW`. This will tell the Android system that something is
    about to be viewed. The other parameter is the data, mostly defined in the `URI`
    format. We have used the PacktPub website as an example. The Android OS will open
    this web address in the default browser of the phone. If more than one browser
    is found, the user will be given a list of all the available browsers to choose
    one to view the address in.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any URI can be passed in here, not only a web address. For example, the URI
    of any contact in the phone or any image in the gallery can also be passed, and
    the Android OS will take the most suitable action for the data passed in the URI.
  prefs: []
  type: TYPE_NORMAL
- en: The general behavior of this intent proves to be a very important feature in
    Android development. Developers save a lot of time by making generalized apps.
    This becomes beneficial for the developers as they just have to send information.
    The rest is defined by the Android OS, and the users get a choice to perform the
    action as they wish. Developers can not only provide the user with the feature
    to choose other apps for performing actions in implicit intents, but they can
    also develop their own custom apps to be added in the choose list. For example,
    we develop an image-editing app. We want the app to function in such a way that
    when a user selects an image from any other app, our app appears in the options
    list so that the user can easily navigate to our app for editing images from anywhere
    in his or her phone. This can be done through implicit intents. But the difference
    this time is that we will not send implicit intents; instead, we will receive
    implicit intents from other apps. We can do this by registering the intent filter
    in our `AndroidManifest.xml` file, where we will have to define the action for
    which our app will perform. This feature makes an app more interactive with other
    apps, and the integration between different apps and the Android OS becomes very
    easy for developers. In the following sections, we will develop two examples of
    implicit intents, and see what we can do with these examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using implicit intents in an Android application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will discuss the various uses of implicit intents in an Android
    application. As discussed earlier, implicit intents can be used in communicating
    with other Android components in a general form unlike explicit intents. Let''s
    look at the implicit intents in action with the following two examples: one uses
    implicit intents for sharing content, and the other uses implicit intents to get
    content from other Android apps.'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing content using implicit intents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today, social networking is what makes any application viral and promotes it
    to other users. Due to a large variety of social networks, it becomes difficult
    to put all of the sharing features in the apps. Mostly, developers add Facebook,
    Twitter, and Instagram in their apps, but adding those SDKs in the app sometimes
    becomes troublesome for the developers as well as the users. For example, multiple
    SDKs add some size in the build file; an app becomes complex due to a lot of features.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can solve this problem using a few lines of code through implicit
    intents. Let's see how this can become possible by creating a simple content sharing
    example. First create an empty project using any Android IDE such as Eclipse with
    the ADT plugin or Android Studio, or open any existing project in which you want
    to add the share feature. We will now implement the use of implicit intents in
    sharing any data on social networks.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented a simple, one line-sharing application that asks the user
    to choose the sharing method and shares the line on that network. There are two
    main files that are modified in any empty project. Let's explore both the files
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The activity_main.xml file is the visual layout of our simple, line-sharing
    app. The following code snippet shows the implementation of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a relative layout in which we have placed two Views: a button with
    `text` as `Share` and an `<EditText>` tag to get an input line from the user.
    In the previous examples, we used `<LinearLayout>` to align the Views on the screen.
    This time, we used `<RelativeLayout>` to add the Views. In relative layouts, we
    place our Views relative to other Views. For example, `android:layout_alignLeft`
    takes the ID of any View and puts this View on the left-hand side of the main
    View. Similarly, we also used the `android:layout_below` attribute in the `Share`
    button to place it below the text field. About the text field, this is the first
    View on the screen; so, this can be placed relative to the parent View.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `layout_ android:layout_alignParentLeft` and `android:layout_alignParentTop`
    Boolean flags place the `EditText` View on the top-left corner of the parent,
    that is, the screen. Using Relative layouts for aligning a View is the most recommended
    method in the Android OS.
  prefs: []
  type: TYPE_NORMAL
- en: This was the visual representation of our one line-sharing app. Now, let's see
    how implicit intents are used in the main activity file.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The MainActivity.java class file is the main activity of the line-sharing app.
    The following code shows the implementation of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class is extended from the `Activity` class in order to make it an activity.
    As usual, we override the `onCreate()` method, set the Content View of the activity
    by the `setContentView()` method, and reference a layout that is our `activity_main.xml`
    file placed in the `res/layout` directory. After setting the layout, we get the
    button reference from the layout by the `findViewById()` method and set its `View.OnClickListener`
    interface to an anonymous object.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the Views, let's set the listeners and define the functionalities
    on the touchable Views. For this purpose, we have overridden the `onClick()` method
    of the listener and placed our main functionality code in this method as we want
    to share the line on a button tap. We have first got the message text from the
    text field by getting its reference and then the text in the field. We created
    an `Intent` object and passed `ACTION_SEND` as its category into the constructor.
    The `ACTION_SEND` intent delivers data to the Android OS.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we have not specified the receiver of the data unlike in explicit
    intents, where we used to specify the target explicitly. It is up to the receiver
    of this action to ask the user where the data should be sent, and this happens
    through the chooser dialog.
  prefs: []
  type: TYPE_NORMAL
- en: After creating an instance of the intent, we add the extra data of the message
    line in the intent. We have chosen the `EXTRA_TEXT` key to add our data in. For
    example, if we want to send an SMS, we have to insert the data into the SMS body,
    and if we want to send an e-mail, we have to put the data into the e-mail body.
    So, we have chosen a general type of the text, and the Android OS will detect
    a suitable place to put the data.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have set the category and data, but we have to set the type of
    the data as well. The Android OS will put the apps in our chooser dialog on the
    basis of the type of the data. For example, we have set the type to `text/html`;
    this will put all the apps that support the text or HTML format of the data, such
    as e-mail, Facebook, Twitter, and so on, in the chooser. If we set `this` to `image/png`,
    all the apps, such as image editors, gallery, and so on, will be put in the chooser
    list. Also, we can define general types of supported images by putting a slash
    followed by a star. For example, `image/*` will put all the image apps, not limited
    to only PNG, in the chooser list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we start the activity with this intent by calling the `startActivity()`
    method. You should be careful to pass the intent in the `startActivity()` method
    or in the `Intent.chooser()` method. If we pass the intent in `startActivity`,
    we will get the `ActivityNotFoundException` exception. We don't specifically know
    which activity to start in order to share the app; so, in that case, we will create
    a chooser list, and the user will decide which activity to start. This is how
    we provide the user with the option to choose his or her favorite method to share
    the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the project and you will see a screen that will have a **Share** button
    and a text field to write something to share. On pressing the **Share** button,
    you will see a dialog asking you to choose the method of sharing. This dialog
    will include all those apps, such as text messaging, SMS, MMS, e-mail, and Facebook,
    which are used to share the text. The following figure shows the app screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java class](img/9639_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we used implicit intents to communicate with other apps of
    the Android OS. In the next example, we will see how other apps can communicate
    with our app.
  prefs: []
  type: TYPE_NORMAL
- en: Registering your app for the share intent
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous example, we triggered other sharing apps from our app. In this
    example, we will register our app for the share intent so that the other app developers
    and users can communicate with our app using implicit intents. Both examples use
    implicit intents, but the method of use is different in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we used implicit intents in Java files and triggered
    the intent on a button tap in `OnClickListener`. In this example, to register
    our app for any intent such as the share intent in this case, we have to put our
    code in the XML file in the `AndroidManifest.xml` file. Just to revise a little,
    the `AndroidManifest.xml` file manages all the settings of our app. Let's learn
    how to implement the app now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start this example, create an empty project using any Android IDE
    such as Eclipse with the ADT plugin or Android Studio, or open any existing project
    in which you want to receive the send intent. In this project, we will explore
    the use of implicit intents in getting the data shared by other apps in our app.
    We first register our app as a text-sharing app. Then, all the apps that share
    any `text/html` type file in Android can trigger our app if a user chooses it.
    To perform this task, we have modified the code in three files: a layout file,
    an activity file, and the manifest file. Let''s look at those files one by one
    now.'
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The activity_main.xml file is the visual layout of our sharing app. The following
    code shows the implementation of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have a Relative layout with a text View component in it. We have set the
    initial text value of Text View to "Hello World"; remember that the data we get
    from other apps while sharing will be printed in this Text View content. After
    the visual representation, it always comes to the processing and coding logic
    of app. Let's look at the next activity file which performs the main task and
    implements the logic of using implicit intents.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The MainActivity.java class file is the activity that displays the data which
    is shared from any other app. The following code shows the implementation of this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java class](img/9639_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a user chooses our app from the **Share** dialog, this activity will be
    opened. We also have set this activity to our main activity. Any activity in the
    app can be registered for getting the share intent. It is not necessary that the
    main activity has to be registered for getting the shared data. We have set the
    layout of the activity, and after that, we get the intent data. This is the data
    that will be thrown from any other sharing app. We first get the intent by calling
    the `getIntent()` method. There are many types of intents; we have to make sure
    that our activity will work only for the intent type that we have registered in
    the `AndroidManifest.xml` file. To detect whether this intent was sent for sharing
    or not, we have to check the intent action. So, we have obtained the action of
    intent by calling the `Intent.getAction()` method. We can get the type of intent
    using the `Intent.getType()` method. Then, we check the type and action.
  prefs: []
  type: TYPE_NORMAL
- en: If the intent action is `Intent.ACTION_SEND` and the type is `text/html`, it
    means that we can display that type of data in our app. If both conditions are
    `true`, we set the Text View content to the data that we got from the intent.
    We can get the data from the intent through the `Intent.getStringExtra()` method.
    This method takes the data type as an input argument or parameter. In this example,
    we get the `Intent.EXTRA_TEXT` data type that represents any text or message data
    in the intent that is normally used for the body text in e-mails, Facebook posts,
    or SMS messages.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the `MainActivity` class, we saw that we have only got the
    intent and checked it. But there is also a problem regarding how the other apps
    are going to recognize our app and how they can know that our app can display
    the `text/html` data. If we open this activity explicitly from another activity
    of the same app, the same intent will be received and the same conditions will
    be checked. But this time, no condition will be `true`, so no text will be changed
    in the layout. To make the app visible to other apps, we have to register an intent
    filter. This is done in the `AndroidManifest.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make our app visible for sharing content, we have to register the receiving
    activity of the app with an intent filter in this file. The following code shows
    the implementation of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `<activity>` tag of `MainActivity`, we have inserted two intent filters.
    The first intent filter is to make this activity a main activity and the launcher
    of the app. The second intent filter is a piece of code that performs the core
    functions of the app. We have inserted an intent filter with the action as `android.intent.action.SEND`
    and `mimeType` as `text/html`. This tells the Android OS that whenever any intent
    with the `Send` action is triggered and it contains data with `text/html` type,
    the app can process this intent. This is how our app is shown in the chooser dialog
    of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the project and you will see the **Hello World** screen. Close the
    app and run our previous example app, **ShareImplicitIntent**. Write something
    in the text field and tap the **Share** button. In the chooser dialog, you will
    see our app, **GettingSharedData,** in the list. Choosing this app will open the
    activity, and this time, instead of **Hello World**, you will see the data shared
    from another app in the text field. The following screenshot shows a demo of the
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have seen two examples of implicit intents. In one example, we shared
    some data with other apps such as e-mail, SMS, Facebook, and so on. In the other
    example, other apps shared their content with our app, and we received that data
    and displayed it. But, implicit intents are not limited to sharing content alone.
    There are lots of options and choices that can be performed using implicit intents,
    including making calls, sending texts, showing maps, searching for anything, taking
    pictures, showing and editing contacts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In our next example, we will learn how we can pick any image from the gallery
    and display it in our activity.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an image through an implicit intent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, we will implement the use of implicit intents to pick any image
    from the gallery. We will put an Image View that will display an image in our
    app. This image will be chosen by the user from the gallery. Let's implement it
    now! In order to start this example, create an empty project using any Android
    IDE such as Eclipse with the ADT plugin or Android Studio, or open any existing
    project in which you want to add the image picking feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will register our app as an image-sharing app, and then all the apps which
    share any image in Android OS can trigger our app if the user chooses it. We have
    modified the code in three files: a layout file, an activity file, and the manifest
    file. Let''s see what these files do.'
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just like in all the Android apps, the activity_main.xml file represents the
    layout file of the main activity. The following code shows the implementation
    of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml file](img/9639_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have placed two View components; a button View to open the gallery on a tap
    and an Image View to display the image. Unlike other apps, we have set the button
    listener in our layout file. Revising the last method, we set our click listener
    by calling the `button.setOnClickListener()` method in the activity class file.
    In this example, we have used the `android:onClick` attribute in the `<Button>`
    tag, and provided the name of the listener on the other side of the attribute.
    We have to provide a method name that should be defined in the activity file using
    this layout.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android OS recommends that you set listeners in the XML layout file. But,
    if the layout is used by more than one activity, developers should be careful
    as an attribute value is a method name and should be defined in the activity file.
    That means either all activities using the layout file should define that method,
    or all activities should set the listeners in Java files instead of XML.
  prefs: []
  type: TYPE_NORMAL
- en: The other View component in our layout file is Image View. This Image View will
    show the image picked from the gallery or other image sharing apps. We have set
    Image View's source to launcher-icon image as the default image.
  prefs: []
  type: TYPE_NORMAL
- en: After developing the layout of the app, let's focus on the logic of the app.
    The `MainActivity` file shows how the app gets the image from other apps and displays
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The MainActivity.java class is the main activity Java file that performs all
    the functionalities in the app. The following code snippet is the implementation
    of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java class](img/9639_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We start from the `onCreate()` method where we first set the Content View of
    the activity to our layout file. We have created three private fields in our class.
    The first is the `REQUEST_CODE` constant that is an integer value. This constant
    is used as the request code to get any data from any other Android app. As we
    are picking an image from the gallery, we need a request code to identify the
    correct results and data. The second field is the bitmap. This bitmap is used
    to store the picked image in the bitmap format. The third and last field of the
    activity class is Image View. This is used to reference Image View in the XML
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `pickImage()` method is the button listener that was set in the XML layout
    file in the `<Button>` tag. This method should take the `View` parameter. This
    parameter contains the View that was tapped at runtime. As per our app requirements,
    we want to open the gallery on a button tap; so, to open the gallery, an implicit
    intent will be triggered in this method. We create an empty intent object with
    a no-argument constructor. Then, we set its type to any image format using `image/*.`
    After that, we set its intent action to `Intent.ACTION_GET_CONTENT`. This tells
    the Android OS to show all those apps that share the content.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we already told the Android OS that we need only the image content by setting
    the type; so, the Android OS will only show those apps, such as gallery, that
    shares images. We set the category to `Intent.CATEGORY_OPENABLE`. This is used
    to indicate that the `GET_CONTENT` intent only wants the URIs that can be opened
    with `ContentResolver.openInputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we start the activity by calling the `startActivityForResult()` method.
    Remember that we used the `startActivity()` method in our previous apps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between the `startActivity()` and `startActivityForResult()`
    methods is that the `startActivityForResult()` method returns some result to the
    parent activity after being stopped while `startActivity()` doesn't return anything.
  prefs: []
  type: TYPE_NORMAL
- en: As we need to get any image from gallery, the gallery app will return the URI
    of the image that we will use in our app to display it. To get the result in our
    activity, we need to override the `onActivityResult()` method in our class. This
    method takes three parameters. The first is a request-code that is an integer
    value. This value defines the request ID that we used to start an activity. We
    have used a constant private field `REQUEST_CODE` in our class for this value;
    so, in our `onActivityResult()` method, we will compare the request code to this
    constant value for confirmation. The second parameter, `RESULT_CODE`, is an integer
    value. This value tells us whether the result we have got is correct and okay
    to use or not. The third and last parameter is the intent; this contains the resulting
    data that we will use in our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the `onActivityResult()` method, we created an `InputStream` object and then
    we compared our request code and result code to confirm whether we should process
    the intent data or not. If everything goes fine, we get the URI of the picked
    image by calling the `Intent.getData()` method and pass it to `openInputStream()`
    of the content resolver of this activity. The content resolver of any activity
    can be retrieved by calling the `Activity.getContentResolver()` method. After
    getting the stream of the URI, we decode it to bitmap by calling the `BitmapFactory.decodeStream()`
    method, and set the output bitmap to our activity-bitmap field. Then, we set the
    bitmap in our Image View. And in the final section of the `try/catch` block, we
    close our stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the project and you will see the screens as shown in following screenshot.
    The user taps on the button, and the gallery will be shown. Then, the user chooses
    his favorite photo to be displayed, and the app displays it on the app screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java class](img/9639_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summarizing the whole section of implicit intents, we implemented three examples.
    In the first example, we learned how to share our data with other apps. In the
    second example, we learned how other apps can share their data with our app. And
    finally, in the third and last example, we learned how to get an image from the
    gallery and use it in our app. In the next and last section of the chapter, we
    will discuss Android late binding.
  prefs: []
  type: TYPE_NORMAL
- en: Intents and Android late binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we all know, three of the most core components of an application in Android
    are activities, services, and broadcast receivers. These components communicate
    and are triggered via messaging. This messaging is done through intents. Intent
    messaging is a facility for late-runtime binding (late binding) between components
    in the same or different applications. In each case, an Android system finds the
    right component, such as an activity, service, or receiver to be triggered, and
    instants them if necessary. There is no overlapping within these intents. For
    example, broadcast receiver intents are only sent to broadcast receivers and never
    sent to any activity or service. Another example is that an intent passed in the
    `startActivity()` or `startActivityForResult()` method is never sent to any component
    such as a service or receiver, but only to an activity.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples used in this chapter, implicit intents always performed actions
    in which the developer was not sure about how these actions will be performed
    and with what apps. This runtime behavior of assigning actions to components is
    called Android late-runtime binding, and this can be done easily via implicit
    intents.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the categories of intents, implicit intents, explicit
    intents, and late binding. The chapter also provided some important implementation
    of Android intents in which we shared our data with other apps, the other apps
    shared data with our app, picked any image from gallery, started an activity or
    service through explicit intents, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how mobile components such as a camera, can
    be triggered by intents, and how they are used in our apps.
  prefs: []
  type: TYPE_NORMAL
