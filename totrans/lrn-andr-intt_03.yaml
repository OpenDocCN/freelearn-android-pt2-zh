- en: Chapter 3. Intent and Its Categorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 意图及其分类
- en: '**Intents** are asynchronous messages used to activate one Android component
    using another. These intents are used to trigger the Android OS when some event
    has occurred, and some action should be taken. The Android OS, on the basis of
    the data received, determines the receiver for the intent and triggers it.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图** 是用来激活一个Android组件的异步消息，通过另一个组件来实现。这些意图用于在发生某些事件时触发Android操作系统，并采取一些行动。根据接收到的数据，Android操作系统确定意图的接收者并触发它。'
- en: 'Generally, there are two types of intents: **explicit** and **implicit**. As
    their names suggest, explicit intents trigger specific components of the Android
    OS specified explicitly by the developers. However, implicit intents trigger the
    general components of any category of the Android OS. It''s left to the Android
    OS to decide which component needs to be activated. If there is more than one
    general component, the user is asked to select a component from a list of all
    the components. This feature of the intents in the Android OS makes an application
    more interactive because the other applications and developers can also access
    it. For example, you are developing a picture-editing Android application to edit
    any image, apply filters to it, and so on. So, if the application receives images
    from any source of the Android system, such as an e-mail attachment, gallery images,
    any other image tools, and so on, the application will become more interactive
    and responsive as compared to the application that loads images from the app itself.
    This interaction of the application, whether it is sending an image via e-mail
    or receiving an image in an editing application, is implemented through implicit
    intents.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种类型的意图：**显式** 和 **隐式**。顾名思义，显式意图由开发者明确指定触发Android操作系统的特定组件。然而，隐式意图触发的是Android操作系统任何类别的一般组件。由Android操作系统决定需要激活哪个组件。如果有一个以上的通用组件，系统会要求用户从所有组件的列表中选择一个。Android操作系统中意图的这项功能使得应用程序更具交互性，因为其他应用程序和开发者也可以访问它。例如，你正在开发一个图片编辑的Android应用程序，用于编辑任何图片，应用滤镜等。所以，如果应用程序接收到来自Android系统任何来源的图片，比如电子邮件附件、图库图片、其他图片工具等，与仅从应用程序本身加载图片的应用程序相比，该应用程序将变得更加互动和响应迅速。这种应用程序的互动，无论是通过电子邮件发送图片还是在编辑应用程序中接收图片，都是通过隐式意图实现的。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解到以下主题：
- en: Types of intents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图的类型
- en: Explicit intents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式意图
- en: Using explicit intents in an Android application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android应用程序中使用显式意图
- en: Implicit intents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式意图
- en: Using implicit intents in an Android application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android应用程序中使用隐式意图
- en: Intents and Android late binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图和Android晚期绑定
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The concept of intents and their structure, as discussed in the previous chapter,
    are the prerequisites for understanding this chapter and the chapters that follow.
    If you don't have a basic understanding of these things, read [Chapter 2](ch02.html
    "Chapter 2. Introduction to Android Intents"), *Introduction to Android Intents*,
    in order to move forward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所讨论的意图及其结构的概念，是理解本章及后续章节的前提条件。如果你对这些内容没有基本的了解，请阅读 [第2章](ch02.html "第2章.
    Android意图简介") *Android意图简介*，以便继续学习。
- en: These two types of intents, namely, explicit and implicit intents, are very
    different in terms of functionality. Let's start with the simplest type of intent
    first.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种意图，即显式和隐式意图，在功能上有很大的不同。让我们从最简单的意图类型开始说起。
- en: Explicit intents
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式意图
- en: 'The simplest type of intent is the explicit intent. When a developer knows
    which component to use and doesn''t want to provide free access to the user, explicit
    intent is the best choice. Here, the developer explicitly specifies the component
    to be triggered in the declaration of the intent. This component can be any activity,
    service, or broadcast receiver. For example, an Android application usually consists
    of more than one activity for a corresponding functionality. In order to navigate
    from one activity to another, an explicit intent is used. The following code snippet
    shows a simple declaration of such an explicit intent that targets activity B
    from activity A:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的意图类型是显式意图。当开发者知道要使用哪个组件，并且不希望向用户提供自由访问时，显式意图是最佳选择。在这里，开发者在意图声明中明确指定了要触发的组件。这个组件可以是任何活动、服务或广播接收器。例如，一个Android应用程序通常包含一个以上对应功能的活动。为了从一个活动导航到另一个活动，会使用显式意图。以下代码段展示了这样一个显式意图的简单声明，它从活动A指向活动B：
- en: '![Explicit intents](img/9639_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![显式意图](img/9639_03_01.jpg)'
- en: 'Intents are instances of the `android.content.Intent` class. The explicit components
    are specified as Java class identifiers, and they are used by the Android OS to
    activate them whenever a developer sends the intent. As explained in the earlier
    chapters, an object of the intent takes two parameters: **context** and **class**.
    The context parameter receives the source context from which the intent is triggered
    to activate other components. The class parameter takes the class object of a
    specific class that is used to specify the target component. In the preceding
    code snippet, an `intent` object takes the `ActivityA` class as the source component
    and `ActivityB` as the target component to be activated. Now, this `intent` object
    declared in the code snippet with the specific component as the target can be
    used anywhere. For example, it can be used for starting `ActivityB` with `ActivityA`
    as the parent activity. The following section describes the uses of explicit intents
    to trigger various components such as activities, services, and so on.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是`android.content.Intent`类的实例。显式组件被指定为Java类标识符，它们被Android操作系统用于在开发者发送意图时激活它们。如前几章所述，意图对象接收两个参数：**上下文**和**类**。上下文参数接收触发其他组件激活的源上下文。类参数取特定类的类对象，用于指定目标组件。在前面的代码段中，`intent`对象以`ActivityA`类作为源组件，以`ActivityB`作为要激活的目标组件。现在，这个在代码段中声明的具有特定组件作为目标的`intent`对象可以在任何地方使用。例如，它可以用于以`ActivityA`作为父活动启动`ActivityB`。以下部分描述了使用显式意图触发各种组件（如活动、服务等）的用途。
- en: Using explicit intents in an Android application
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Android应用程序中使用显式意图
- en: In this section, we will discuss the various uses of explicit intents in an
    Android application. As discussed earlier, explicit intents can be used in activating
    other components such as activities, services, and broadcast receivers. We will
    talk about two examples of explicit intents; the first one to start one activity
    from another activity, and the other to start a service in the background.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在Android应用程序中显式意图的各种用途。如前所述，显式意图可以用于激活其他组件，如活动、服务和广播接收器。我们将讨论两个显式意图的示例；第一个是从一个活动启动另一个活动，另一个是在后台启动服务。
- en: Starting an activity through an explicit intent
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过显式意图启动一个活动
- en: 'Any Android application contains at least one or multiple activities. So, in
    the case of multiple activities, navigating between them becomes important for
    a developer. In this section, we will develop an example of two activities in
    which we will start one activity from the other and go back to it after stopping/finishing
    the currently opened activity. The following figure shows a simple prototype of
    the example we are about to develop:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Android应用程序至少包含一个或多个活动。因此，在存在多个活动的情况下，如何在它们之间导航对开发者来说变得很重要。在本节中，我们将开发一个包含两个活动的示例，我们将从一个活动启动另一个活动，并在停止/完成当前打开的活动后返回到它。下图展示了我们即将开发的示例的简单原型：
- en: '![Starting an activity through an explicit intent](img/9639_03_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![通过显式意图启动一个活动](img/9639_03_02.jpg)'
- en: 'As it is clear from the preceding figure, we have two activities: **Main Activity**
    and **Second Activity**. Both the activities have a single button to navigate
    and a title showing the name of the activity. Now, let''s get started with the
    development of our first example. But, in order to start this example, you need
    to build an Android project. You can use Android Studio or Eclipse (as per your
    convenience), but in the case of Eclipse, make sure that you have correctly installed
    the JDK, ADT, and Android SDK along with their compatibility. If you don''t know
    the difference between these IDEs, refer to the first chapter of this book. Creating
    a project in Android Studio has been explained in the previous chapter. Repeating
    those steps will give you a complete Android project with some predefined files
    and folders.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有两个活动：**主活动（Main Activity）**和**第二个活动（Second Activity）**。这两个活动都有一个用于导航的单一按钮和一个显示活动名称的标题。现在，让我们开始开发第一个示例。但是，要开始这个示例，你需要构建一个Android项目。你可以使用Android
    Studio或Eclipse（根据你的方便），但在使用Eclipse的情况下，请确保你已经正确安装了JDK、ADT和Android SDK及其兼容性。如果你不知道这些IDE之间的区别，请参考本书的第一章。在上一章中已经解释了如何在Android
    Studio中创建项目。重复这些步骤将给你一个带有一些预定义文件和文件夹的完整Android项目。
- en: After creating an empty Android project, we are going to implement the use of
    explicit intents. In the example, we will write or modify many different files
    of various types, such as Java, XML, and so on. Each file has its own purpose
    and performs its own functionality in the example. Let's explore these files one
    by one now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的Android项目后，我们将实现显式意图的使用。在示例中，我们将编写或修改许多不同类型的文件，如Java、XML等。每个文件都有其自身的目的，并在示例中执行其自身的功能。现在，让我们逐一探索这些文件。
- en: The MainActivity.java class
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MainActivity.java类
- en: 'The main file of the project is `MainActivity.java`. The following is the code
    snippet to be implemented in this file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的主文件是`MainActivity.java`。以下是在此文件中需要实现的代码片段：
- en: '![The MainActivity.java class](img/9639_03_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java类](img/9639_03_03.jpg)'
- en: The applications having more than one activity must have a main activity. This
    main activity defines the starting point of the application. In our example, the
    `MainActivity.java` class is the main activity of the project. To provide a layout
    file to the activity for visual representation, we will call `setContentView(R.layout.activity_main)`
    within the `onCreate()` method of the activity. The `activity_main.xml` file is
    the layout file contained in the `layout` folder of the project directory and
    represents the main screen of the app. After setting the View of the activity,
    we get all the components that will be used in the activity by getting their Views
    from the layout file. To get the View of any component, we will use the `findViewById()`
    method that takes an ID of the View and returns a `View` object that is the type
    casted as per our requirements. In this file, we've got the `View` object of the
    button having the ID, `button1`, in the layout file, and we have the `Button`
    type casted it to and reference it to our button. Any button should have listeners
    for user interaction with the View and customizing the behavior of the View. In
    our file, we only set `View.OnClickListener` for the button to get the clicks/taps
    of the button.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个以上活动的应用程序必须有一个主活动。这个主活动定义了应用程序的启动点。在我们的示例中，`MainActivity.java`类是项目的主活动。为了向活动提供布局文件以进行视觉展示，我们将在活动的`onCreate()`方法中调用`setContentView(R.layout.activity_main)`。`activity_main.xml`文件是项目目录中`layout`文件夹里的布局文件，代表了应用的主屏幕。设置活动的视图后，我们可以通过从布局文件获取它们的视图来获取活动中将使用的所有组件。要获取任何组件的视图，我们将使用`findViewById()`方法，该方法接收视图的ID并返回一个`View`对象，根据我们的需求进行类型转换。在这个文件中，我们从布局文件中获取了ID为`button1`的按钮的`View`对象，并将其类型转换为`Button`并引用到我们的按钮。任何按钮都应该有监听器以便与视图进行用户交互并自定义视图的行为。在我们的文件中，我们只为按钮设置了`View.OnClickListener`以获取按钮的点击/轻触。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are two `OnClickListener` classes in the Android SDK. One is in the `View`
    class. It is used for Views such as buttons, text fields, and so on. The other
    is in the `DialogInterface` class and is used for the detection of clicks and
    taps in dialogs. Developers should be careful when importing classes and their
    packages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK中有两个`OnClickListener`类。一个位于`View`类中，用于诸如按钮、文本字段等视图。另一个位于`DialogInterface`类中，用于检测对话框中的点击和轻触。开发者在导入类及其包时应小心谨慎。
- en: We have set the `OnClickListener` object of the button using the `setOnClickListener()`
    method of the `Button` object. We referenced an anonymous listener in the parameter
    of the method, and have overridden the `onClick()` method. In the `onClick()`
    method, we have to provide the behavior that we want to show when a button is
    tapped on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`Button`对象的`setOnClickListener()`方法来设置按钮的`OnClickListener`对象。我们在方法的参数中引用了一个匿名监听器，并覆盖了`onClick()`方法。在`onClick()`方法中，我们需要提供当按钮被点击时我们想要展示的行为。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Anonymous objects are the objects that have no object name specified by the
    developer. And because of this reason, developers can't access the object directly
    in the code. You can also set the `OnClickListener` object of the View by creating
    the object of the interface and passing it in the `setOnClickListener()` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名对象是开发者没有指定对象名称的对象。由于这个原因，开发者在代码中不能直接访问该对象。你也可以通过创建接口对象，并在`setOnClickListener()`方法中传递它来设置视图的`OnClickListener`对象。
- en: We have created an intent object with `MainActivity` as the source context,
    and the `SecondActivity` class is the target component to be activated. One thing
    to be noted here is that instead of passing the object of `SecondActivity`, we
    have explicitly passed the Java class representation of `SecondActivity`. This
    is how we have declared an explicit intent object. Now, through this intent object,
    we can do many different tasks depending on our requirements, but in our case,
    the options are limited. We have created an explicit intent that contains very
    specific information; so, for that reason, this intent can be used for limited
    purposes only. In this example, the intent is used to start another activity on
    top of a back stack by calling the `startActivity()` method. This method takes
    the parameter of an explicit intent object having the information of the source
    context and target activity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个意图对象，其源上下文为`MainActivity`，而`SecondActivity`类是要激活的目标组件。这里需要注意的是，我们不是传递`SecondActivity`的对象，而是显式传递了`SecondActivity`的Java类表示。这就是我们声明一个显式意图对象的方式。现在，通过这个意图对象，我们可以根据需求执行许多不同的任务，但在我们这个案例中，选项是有限的。我们创建了一个包含非常具体信息的显式意图，因此，这个意图仅可用于有限的目的。在这个例子中，意图被用来通过调用`startActivity()`方法在返回栈上启动另一个活动。这个方法接收一个显式意图对象的参数，该参数具有源上下文和目标活动的信息。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To declare the intent in a class other than running activities, we can use the
    application context to pass in the context parameter of the intent constructor.
    This can be accessed by the `getApplicationContext()` method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在一个除了正在运行的活动之外的类中声明意图，我们可以使用应用上下文来传递意图构造函数的上下文参数。这可以通过`getApplicationContext()`方法来获取。
- en: So, summarizing the functionality of the file here, the file represents the
    starting point of the application that shows a button. On tapping the button,
    the application navigates to another activity. This navigation between activities
    is implemented through an explicit intent object. After implementing the `MainActivity`
    file, let's implement our second activity in the `SecondActivity.java` file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结这个文件的功能，该文件表示应用程序的启动点，显示了一个按钮。点击按钮后，应用程序将导航到另一个活动。这种活动之间的导航是通过一个显式意图对象实现的。在实现了`MainActivity`文件之后，让我们在`SecondActivity.java`文件中实现我们的第二个活动。
- en: The SecondActivity.java class
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SecondActivity.java`类'
- en: 'The `SecondActivity.java` class is the destination activity for our explicit
    intent. The following is the code snippet implemented in this file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondActivity.java`类是我们显式意图的目标活动。以下是这个文件中实现代码片段：'
- en: '![The SecondActivity.java class](img/9639_03_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![`SecondActivity.java`类](img/9639_03_04.jpg)'
- en: Again, this class is extended from the `Activity` class, and follows the activity
    lifecycle. It should also override the lifecycle-callback methods as well. In
    the `onCreate()` method, we set the View of the activity by calling the `setContentView()`
    method, and this time, we have passed the `activity_main2.xml` file's reference
    using `R.layout.activity_main2`. This XML file is placed in the `layout` folder
    under `res`. We again get the `View` component of the button from the layout file
    by calling the `findViewById()` method, and we typecast this to `Button`. We then
    set `OnClickListener()` of the button to an anonymous listener, and override the
    `onClick()` method to define the behavior on a button tap. This time, we call
    the `Activity.finish()` method in the `onClick()` method. This method simply pulls
    out the activity on top from the back stack.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个类是从`Activity`类扩展而来的，遵循活动生命周期。它也应该重写生命周期回调方法。在`onCreate()`方法中，我们通过调用`setContentView()`方法来设置活动的视图，这次，我们通过`R.layout.activity_main2`传递了`activity_main2.xml`文件的引用。这个XML文件放在了`res`目录下的`layout`文件夹中。我们再次通过调用`findViewById()`方法从布局文件中获取按钮的`View`组件，并将其类型转换为`Button`。然后，我们将按钮的`OnClickListener()`设置为一个匿名监听器，并重写`onClick()`方法来定义点击按钮时的行为。这次，我们在`onClick()`方法中调用了`Activity.finish()`方法。这个方法只是简单地将位于返回栈顶部的活动移除。
- en: As we started `SecondActivity` from `MainActivity`, when we finish `SecondActivity`,
    we will see `MainActivity` again.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是直接从`MainActivity`启动的`SecondActivity`，当我们结束`SecondActivity`时，我们将会再次看到`MainActivity`。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The back button in Android devices simply calls the `finish()` method for activities
    or the `dismiss()` method for dialogs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备上的返回按钮仅仅调用了活动（Activity）的`finish()`方法，或者是对话框（Dialog）的`dismiss()`方法。
- en: We can also create an intent object with the context of `SecondActivity` and
    the target class of `MainActivity.java`. But, this will create a new instance
    of `MainActivity` in the back stack, and will push this on top of `SecondActivity`.
    In that case, we will have two instances of `MainActivity` and one instance of
    `SecondActivity` placed in the middle of these activities in the back stack.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个带有`SecondActivity`上下文和目标类`MainActivity.java`的意图对象。但这会在返回栈中创建`MainActivity`的新实例，并将其推到`SecondActivity`的顶部。在这种情况下，我们在返回栈中会有两个`MainActivity`实例和一个位于它们之间的`SecondActivity`实例。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we set the `android:noHistory` attribute to `true` in the `<activity>` tag
    of `MainActivity` in the `AndroidManifest.xml` file, starting a new instance of
    `MainActivity` will result in an already-created instance to be placed on top
    of the back stack, thus avoiding the creation of a new object. Developers should
    be more careful at the time of creating the app flow and navigation control because
    this type of flow can make loops in the app. This can cause a never-ending app
    problem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`AndroidManifest.xml`文件中`MainActivity`的`<activity>`标签里将`android:noHistory`属性设为`true`，那么启动`MainActivity`的新实例将会导致已创建的实例被置于返回栈的顶部，从而避免了新对象的创建。开发者在构建应用流程和导航控制时应该更加小心，因为这类流程可能导致应用中的循环。这可能会造成应用无休止的问题。
- en: We should note that both activity files, `MainActivity.java` and `SecondActivity.java`,
    contain almost the same code except the button listener of `MainActivity` that
    starts a new activity using explicit intent, and the button listener of `SecondActivity`
    that just pulls back the application by auto-pressing the back button of an Android
    phone.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到，这两个活动文件`MainActivity.java`和`SecondActivity.java`几乎包含相同的代码，除了`MainActivity`的按钮监听器使用显式意图启动新活动，以及`SecondActivity`的按钮监听器只是通过自动按下安卓手机的返回按钮来将应用拉回。
- en: Until now, we have learned how an explicit intent can be used to navigate to
    another activity. But, it should be remembered here that both activities were
    using different layout files for visual representation containing the action buttons
    that performed both tasks. It should be noted that the layout files don't play
    any role in the navigation of explicit intents. These files just show the visual
    content of activities to make the user interaction easy. Now, let's focus on those
    layout files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到如何使用显式意图导航到另一个活动。但是，应该记住，这两个活动使用了不同的布局文件进行可视化表示，包含执行两项任务的操作按钮。需要注意的是，布局文件在显式意图的导航中不起任何作用。这些文件只是展示活动的视觉内容，以简化用户交互。现在，让我们关注这些布局文件。
- en: The activity_main.xml file
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`activity_main.xml`文件'
- en: 'The activity_main.xml file is the layout file of `MainActivity.java` and is
    written in XML. The following code shows the implementation of the layout file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity_main.xml`文件是`MainActivity.java`的布局文件，采用XML编写。以下代码展示了布局文件的实现：'
- en: '![The activity_main.xml file](img/9639_03_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![activity_main.xml文件](img/9639_03_05.jpg)'
- en: From the layout file, we have `LinearLayout` and `<Button>` Views within the
    layout. Remember that this button was extracted by the `MainActivity` file after
    setting the View of the activity to `OnClickListener`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局文件中，我们有`LinearLayout`和`<Button>`视图在布局内。请记住，这个按钮是在将活动的视图设置为`OnClickListener`之后，由`MainActivity`文件提取的。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The references of all the layouts and Views declared in the XML files are autogenerated
    inside the `R.java` file. In Java, we can use the `R` class and access components
    in a static manner. For example, we could use `R.layout.layout_name` for layout.
    However, in XML, `R` can be accessed by placing `@`. For example, for accessing
    a color, we can use `android:name="@color/my_custom_color"`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML文件中声明的所有布局和视图的引用都会在`R.java`文件中自动生成。在Java中，我们可以使用`R`类以静态方式访问组件。例如，我们可以使用`R.layout.layout_name`来引用布局。然而，在XML中，可以通过放置`@`来访问`R`。例如，访问颜色时可以使用`android:name="@color/my_custom_color"`。
- en: Describing the `activity_main.xml` file, there is `<LinearLayout>` with certain
    parameters regarding `height`, `width`, and `orientation`. As you can see, inside
    the tags of `<LinearLayout>`, the `<Button>` tag that is brought into the code
    of Java through the `findViewById()` method in the activity is declared. This
    tag also comes with certain parameters such as `id`, `width`, `height`, and `text`
    that will appear in the layout.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 描述`activity_main.xml`文件，其中有一个带有关于`height`、`width`和`orientation`参数的`<LinearLayout>`。正如你所见，在`<LinearLayout>`标签内部，声明了通过活动中的`findViewById()`方法引入Java代码的`<Button>`标签。这个标签还带有如`id`、`width`、`height`和`text`等参数，这些参数将显示在布局中。
- en: The activity_main2.xml file
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`activity_main2.xml`文件'
- en: 'The activity_main2.xml file layout is a visual representation of the `SecondActivity`
    class. The following code shows this file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity_main2.xml`文件布局是`SecondActivity`类的视觉表示。以下代码展示了这个文件：'
- en: '![The activity_main2.xml file](img/9639_03_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![activity_main2.xml文件](img/9639_03_06.jpg)'
- en: This layout is the same as the `activity_main` layout except that the text values
    of buttons are different. This is used in the `SecondActivity.java` class. Again,
    a button is referenced from XML to Java through the `findViewById()` method in
    the activity, and `OnClickListener` is set to define the custom action to be performed
    when a button is tapped on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局与`activity_main`布局相同，只是按钮的文本值不同。这被用在`SecondActivity.java`类中。同样，按钮是从XML通过活动中的`findViewById()`方法引用到Java的，并且设置了`OnClickListener`以定义点击按钮时要执行的自定义操作。
- en: No Android application is complete without the `AndroidManifest` file. We have
    already implemented the visual layouts of our example app and also their functionality
    of navigating from one activity to the other, using explicit intents. However,
    when any application has multiple activities, the Android OS must be informed
    about all those activities and their attributes. In order to inform the Android
    OS about how many activity classes are used, the `AndroidManifest` file is used.
    Let's see how this file informs the Android OS about the activities.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有包含`AndroidManifest`文件的Android应用程序是不完整的。我们已经实现了示例应用的视觉布局以及它们使用显式意图从一个活动导航到另一个活动的功能。然而，当应用程序有多个活动时，必须通知Android操作系统所有这些活动及其属性。为了告知Android操作系统使用了多少个活动类，使用了`AndroidManifest`文件。让我们看看这个文件是如何通知Android操作系统有关活动的。
- en: The AndroidManifest.xml file
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件'
- en: The `AndroidManifest.xml` file contains all the settings and preferences of
    the application. When working on multiple activities, developers should be careful
    while declaring activities. Only one activity that defines the starting point
    of the application should have an intent filter of the launcher. All activities
    should be saved in here. The information about activities can include the label
    of the activity, theme of the activity, orientation, and so on. For activities,
    the `AndroidManifest.xml` file is like a registration center where all the components
    in the app, such as `Activity` classes, `Service` classes, and so on, should be
    registered. If any activity is not registered in the `AndroidManifest.xml` file,
    Android OS will throw the `ActivityNotFoundException` exception on calling that
    activity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件包含应用程序的所有设置和偏好。在处理多个活动时，开发者在声明活动时应小心。只有一个定义应用程序启动点的活动应该具有启动器的意图过滤器。所有活动都应该在这里保存。关于活动的信息可以包括活动的标签、活动的主题、方向等。对于活动来说，`AndroidManifest.xml`文件就像一个注册中心，应用中的所有组件，如`Activity`类、`Service`类等，都应该在这里注册。如果任何活动没有在`AndroidManifest.xml`文件中注册，Android操作系统在调用该活动时将抛出`ActivityNotFoundException`异常。'
- en: 'About our explicit intent app, both the activities, `MainActivity` and `SecondActivity`,are
    registered in the `AndroidManifest.xml` file. It should be noted here that `MainActivity`
    has a subtag of `<intent-filter>` that declares `MainActivity` as the starting
    or launcher activity of the whole application. The following is the code implemented
    in the `AndroidManifest.xml` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的显式意图应用，两个活动`MainActivity`和`SecondActivity`都在`AndroidManifest.xml`文件中注册。需要在此注意的是，`MainActivity`有一个`<intent-filter>`子标签，它将`MainActivity`声明为整个应用程序的启动或入口活动。以下是`AndroidManifest.xml`文件中实现的代码：
- en: '![The AndroidManifest.xml file](img/9639_03_07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_03_07.jpg)'
- en: 'With the `AndroidManifest.xml` file, our explicit intent example is completed.
    In this example, we defined two activities; one of them was the main activity.
    The main activity used an explicit intent to start the other activity by declaring
    its name explicitly. The example contained two layout files for a visual representation
    of both the activities and the manifest file to register all the activities and
    basic settings for the application. When you run the project, you should see the
    screen transition as shown in following figure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`AndroidManifest.xml`文件，我们的显式意图示例就完成了。在这个例子中，我们定义了两个活动；其中一个是主活动。主活动通过显式声明另一个活动的名称，使用显式意图来启动该活动。该示例包含了两个布局文件，用于两个活动以及清单文件的视觉表示，并注册所有活动以及应用程序的基本设置。当你运行项目时，你应该能看到如下所示的屏幕转换：
- en: '![The AndroidManifest.xml file](img/9639_03_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_03_08.jpg)'
- en: In the next section, we will have a look at another use of explicit intents
    in services. We will learn how a service is started explicitly using intents from
    an activity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解显式意图在服务中的另一种用途。我们将学习如何从活动中显式使用意图来启动服务。
- en: Starting a service through an explicit intent
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过显式意图启动服务。
- en: Unlike activities, services perform specific tasks and actions in the background.
    Services don't have any visual layout or UI. It must be noted that services run
    on the main thread of the app; so, when Android has a need of memory, it will
    stop the services that are not running or are in a paused state. In the next example,
    we will start a service using an explicit intent, and we will also stop it using
    the same explicit intent. So, in order to start this example, create an empty
    project using any Android IDE such as Eclipse with the ADT plugin or Android Studio.
    In this project, we will implement the use of explicit intents for starting/stopping
    services. As our main focus is on explicit intents, we will create a very simple
    service that will display toasts on being started or stopped by the activity.
    We have modified/implemented the four section in the example application. So,
    let's see what these files do one by one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动不同，服务在后台执行特定的任务和动作。服务没有任何视觉布局或UI。需要注意的是，服务运行在应用的主线程上；因此，当Android需要内存时，它会停止那些不在运行或处于暂停状态的服务。在下一个示例中，我们将使用显式意图启动服务，并使用相同的显式意图停止它。因此，为了开始这个示例，请使用任何Android
    IDE（如带有ADT插件的Eclipse或Android Studio）创建一个空项目。在这个项目中，我们将实现使用显式意图来启动/停止服务。由于我们的主要关注点是显式意图，我们将创建一个非常简单的服务，在被活动启动或停止时显示吐司通知。我们在示例应用程序中修改/实现了四个部分。下面，我们逐一看看这些文件的作用。
- en: The ServiceExample.java class
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ServiceExample.java类
- en: 'Since our example app includes a service, this file is a representation of
    a service class used in our app. The following code shows the implementation of
    the service:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的示例应用包含一个服务，这个文件是我们应用中使用的服务类的表示。以下代码展示了服务的实现：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Android development, we have to extend our class from the `Service` class
    and override and implement the required methods according to our customizations
    to create any service. At first, the `onBind()` method is to be implemented by
    the developer, and this is a mandatory one. This method is an abstract method
    of `Service`. This method is used to bind the running services at runtime. Then,
    `onCreate()` and `onStart()` methods are the same as in the activity class. Developers
    do the necessary initial setup in these methods. In our example, we are just going
    to display toasts to notify the user about the method calls. The `onStartCommand()`
    method is a very important method, and this is where we do all the background
    work. It should be noted that services run in the main thread. So, if you want
    to do heavy processing tasks, you should create a separate thread in this method
    and start it. This is how background processing is done in the standard way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，我们必须从`Service`类扩展我们的类，并根据我们的自定义覆盖和实现所需的方法，以创建任何服务。首先，开发者必须实现`onBind()`方法，这是必须的。这个方法是`Service`的一个抽象方法。该方法用于在运行时绑定正在运行的服务。然后，`onCreate()`和`onStart()`方法与活动类中的相同。开发者在这些方法中进行必要的初始化设置。在我们的示例中，我们只是将显示通知用户方法调用的吐司。`onStartCommand()`方法是一个非常重要的方法，我们在这里完成所有后台工作。需要注意的是，服务在主线程中运行。因此，如果你想要执行繁重的处理任务，你应该在这个方法中创建一个单独的线程并启动它。这就是标准方式下进行后台处理的方法。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also create threads in the main thread, and perform our heavy processing
    in the background; then why do we need services to create a thread? In Android
    OS, services are the standard method for doing background processing. When the
    Android OS becomes short on memory, it can stop the idle services to get their
    memory. But it can't stop the threads; so, using services is a better way of continuously
    performing tasks in the background.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在主线程中创建线程，在后台执行繁重的处理；那么为什么我们需要服务来创建线程呢？在Android操作系统中，服务是进行后台处理的标准方法。当Android操作系统内存不足时，它可以停止空闲的服务以获取其内存。但它不能停止线程；因此，使用服务是在后台持续执行任务的一种更好的方式。
- en: We are not doing anything in the `onStartCommand()` method except displaying
    a toast like other methods of the service class. There isn't any special point
    to mention about the service class. Like the previous example, the most important
    part in this example app is the main activity. Let's see the main activity class
    in detail now.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onStartCommand()`方法中，我们除了像服务类的其他方法一样显示一个吐司外，没有做任何事情。关于服务类没有特别需要提及的地方。与上一个示例一样，这个示例应用中最重要的部分是主活动。现在让我们详细看看主活动类。
- en: The ServiceDemoActivity.java class
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ServiceDemoActivity.java类
- en: 'The ServiceDemoActivity.java class is the main activity of our app and defines
    the starting point of the application. The following code shows the implementation
    of the class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceDemoActivity.java类是我们应用的主活动，定义了应用程序的启动点。以下代码展示了类的实现：
- en: '![The ServiceDemoActivity.java class](img/9639_03_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ServiceDemoActivity.java类](img/9639_03_10.jpg)'
- en: This class is extended from the `Activity` class, and we have overridden some
    of its methods. In the `onCreate()` method, we set the Content View layout of
    the activity by referencing the layout stored in the `res/layout` folder of the
    app. Then, we extracted buttons in the layout and set `OnClickListener` for those
    buttons. In an earlier example, we used anonymous objects of the `OnClickListener`
    interface for buttons. In this example, we are providing the `Activity` class
    as our `OnClickListener` by passing `this` in the parameter of the `setOnClickListener()`
    method. The object passed in the parameter must implement the `OnClickListener`
    interface and override the `onClick()` method. So, our activity class implements
    this interface along with the extending activity. We have also overridden the
    `onClick()` method in this class. As we have two buttons this time and only one
    `OnClickListener` interface for both, we have to first find which button has been
    pressed and then take action accordingly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是从 `Activity` 类扩展而来的，我们覆盖了一些其方法。在 `onCreate()` 方法中，我们通过引用存储在应用 `res/layout`
    文件夹中的布局来设置活动的 ContentView 布局。然后，我们在布局中提取按钮并为这些按钮设置 `OnClickListener`。在早期的示例中，我们为按钮使用了
    `OnClickListener` 接口的匿名对象。在这个示例中，我们通过在 `setOnClickListener()` 方法参数中传递 `this` 来提供
    `Activity` 类作为我们的 `OnClickListener`。传递给参数的对象必须实现 `OnClickListener` 接口并覆盖 `onClick()`
    方法。因此，我们的活动类实现了这个接口以及扩展的活动。我们还在这个类中覆盖了 `onClick()` 方法。由于这次我们有两个按钮并且只有一个 `OnClickListener`
    接口，我们必须首先找出哪个按钮被按下，然后相应地采取行动。
- en: One way to do this is to get the ID of the pressed View and compare it with
    the IDs in the resources. So, the `getId()` method returns the ID of the View
    to us; we pass the ID in the switch block and compare it with our IDs of the buttons.
    In both cases, we are creating an explicit intent that passes the context of the
    activity and our service class name as the target component to be activated, as
    we did in our activity example. How the service is being started by the `startService()`
    method and being stopped by the `stopService()` method should be noted. These
    methods take explicit intents that include information about which service has
    to be started or stopped. This class showed us how easy is it to use explicit
    intents to start or stop any service from any activity. As usual, this main activity
    is using two buttons, `Start` and `Stop`, which are extracted from a layout placed
    in the resources folder of the Android project directory. Let's see what this
    layout file contains.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方式是获取按下视图的 ID，并与资源中的 ID 进行比较。因此，`getId()` 方法为我们返回视图的 ID；我们在 switch 代码块中传递
    ID，并与我们按钮的 ID 进行比较。在这两种情况下，我们都在创建一个显式意图，传递活动的上下文和我们的服务类名作为要激活的目标组件，就像我们在活动示例中所做的那样。需要注意的是，服务是通过
    `startService()` 方法启动并通过 `stopService()` 方法停止的。这些方法采用显式意图，包括有关需要启动或停止哪个服务的信息。这个类向我们展示了如何容易地使用显式意图从任何活动中启动或停止任何服务。像往常一样，这个主活动使用了两个按钮，`Start`
    和 `Stop`，这两个按钮是从位于 Android 项目目录资源文件夹中的布局中提取的。让我们看看这个布局文件包含什么。
- en: The activity_main.xml file
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`activity_main.xml` 文件'
- en: 'The activity_main.xml file is the layout file of `ServiceDemoActivity` and
    is written in XML. The following code shows the implementation of the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity_main.xml` 文件是 `ServiceDemoActivity` 的布局文件，采用 XML 编写。以下代码显示了该文件的实现：'
- en: '![The activity_main.xml file](img/9639_03_11.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![`activity_main.xml` 文件](img/9639_03_11.jpg)'
- en: We have a `<LinearLayout>` element and two button Views in the layout. Remember
    that these buttons were extracted by the `ServiceDemoActivity` file to set `OnClickListener`
    for both buttons after setting the View of the activity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在布局中有一个 `<LinearLayout>` 元素和两个按钮视图。请记住，这些按钮是由 `ServiceDemoActivity` 文件提取的，以在设置活动的视图后为两个按钮设置
    `OnClickListener`。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can create layouts in XML as well as Java. Android recommends creating all
    the layouts in XML because Java is used for processing in Android. If we create
    layouts in Java, the layout creation will also be processed; this can make the
    app more battery consumptive. Use Java only for dynamic layouts such as the ones
    used in games.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 XML 以及 Java 中创建布局。Android 建议在 XML 中创建所有布局，因为 Java 在 Android 中用于处理。如果我们用
    Java 创建布局，布局的创建也将被处理；这可能导致应用程序更加耗电。只有在动态布局中，例如在游戏中使用的布局，才使用 Java。
- en: When describing the `activity_main.xml` file, there is a `<LinearLayout>` element
    with certain parameters regarding `height`, `width`, and `orientation`. As you
    can see, inside the `<LinearLayout>` tag, there are buttons declared that are
    brought into the code of Java. This tag also comes with certain parameters about
    `height`, `width`, `id`, and `text` that will appear in the layout. Last but not
    least, the Android manifest file is for the application settings. Like activities,
    a developer has to register all the services implemented in the app in the manifest
    file. Let's have a look at the file and see how we have registered our service
    in the manifest file of the example app.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述`activity_main.xml`文件时，有一个`<LinearLayout>`元素，它具有关于`height`（高度）、`width`（宽度）和`orientation`（方向）的特定参数。如您所见，在`<LinearLayout>`标签内，声明了按钮，这些按钮被引入到Java代码中。此标签还带有关于`height`（高度）、`width`（宽度）、`id`和`text`（将出现在布局中的文本）的特定参数。最后但同样重要的是，Android的manifest文件用于应用程序设置。与活动一样，开发者必须在manifest文件中注册应用程序中实现的所有服务。让我们看看文件，了解我们是如何在示例应用的manifest文件中注册服务的。
- en: The AndroidManifest.xml file
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件'
- en: 'To register a service, we have to provide the code inside the `<application>`
    tag. The following code shows the full implementation of the `AndroidManifest.xml`
    file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册一个服务，我们必须在`<application>`标签内提供代码。以下代码展示了`AndroidManifest.xml`文件的完整实现：
- en: '![The AndroidManifest.xml file](img/9639_03_12.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![`AndroidManifest.xml`文件](img/9639_03_12.jpg)'
- en: 'It can be noted that after `<activity>` tags, we have placed the `<service>`
    tag with the attribute name to define which service we are registering. If we
    don''t register our service in the `AndroidManifest.xml` file, we will get a `ServiceNotFoundException`
    exception thrown, and we will get error log such as "`Unable to start service
    (service package with name): not found`".'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '可以注意到，在`<activity>`标签之后，我们放置了带有属性名称的`<service>`标签，以定义我们正在注册哪个服务。如果我们不在`AndroidManifest.xml`文件中注册我们的服务，我们将遇到`ServiceNotFoundException`异常抛出，并且我们会得到错误日志，例如
    "`Unable to start service (service package with name): not found`"。'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**LogCat** is found in the DDMS View in Android Studio. LogCat logs all the
    activity being done in the connected device or emulator. Any `Force Close` crash
    exception that is thrown is logged in LogCat, and a developer can find the cause
    of the crash from it and solve it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**LogCat**位于Android Studio的DDMS视图中。LogCat记录了连接设备或模拟器中执行的所有活动。任何抛出的`Force Close`崩溃异常都会在LogCat中记录，开发者可以通过它找到崩溃的原因并解决。'
- en: Until now, we have focused on explicit intents, and we created two simple apps
    that use explicit intents. Now, let's move to another type of intent called implicit
    intent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是显式意图，并创建了两个使用显式意图的简单应用。现在，让我们转向另一种称为隐式意图的意图类型。
- en: Implicit intents
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式意图
- en: 'Unlike explicit intents, when a developer doesn''t know which component to
    use, implicit intent is a good choice. Implicit intents do not directly specify
    the Android components to be activated as in explicit intents, but they only specify
    which actions need to be performed. The Android OS will choose the components
    to be triggered. If there are multiple components which can be triggered, the
    Android OS provides options to the user to select one component. For example,
    we want to open a web link in a browser. If we use explicit intents, one option
    that we have is to develop our own custom browser and trigger it explicitly from
    our app to view the web link. The other way, which is more preferable, is to use
    implicit intents to open any already-installed browser in the phone. If there
    is more than one browser installed in the phone, the user will be given the choice
    to select one for performing the action, that is, view the web link. This feature
    of implicit intents works as a general form to perform any action in the Android
    OS. We specify the data and action in the intent, and Android chooses a suitable
    component according to that data. The following code snippet shows a simple declaration
    of an implicit intent that provides a link to be browsed by Android in the best
    suitable component or browser in this case:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与显式意图不同，当开发者不知道要使用哪个组件时，隐式意图是一个很好的选择。隐式意图不会像显式意图那样直接指定要激活的Android组件，而只是指定需要执行哪些操作。Android操作系统将选择要触发的组件。如果有多個可以触发的组件，Android操作系统会为用户提供选项，让用户选择一个组件。例如，我们想要在浏览器中打开一个网页链接。如果我们使用显式意图，我们有一个选项是开发我们自己的自定义浏览器，并从我们的应用程序中明确触发它来查看网页链接。另一种更可取的方法是使用隐式意图打开手机中已安装的任何浏览器。如果手机中安装了不止一个浏览器，用户将被给予选择一个来执行操作，即查看网页链接。隐式意图的这项功能作为在Android操作系统中执行任何操作的一般形式。我们在意图中指定数据和操作，Android根据该数据选择合适的组件。以下代码段展示了一个隐式意图的简单声明，它提供了一个链接，由Android在最适合的组件或浏览器中浏览：
- en: '![Implicit intents](img/9639_03_13.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![隐式意图](img/9639_03_13.jpg)'
- en: Like explicit intents, two parameters are passed in the constructor of the implicit
    intent. You can read more about constructors of intents in [Chapter 2](ch02.html
    "Chapter 2. Introduction to Android Intents"), *Introduction to Android Intents*.
    The first parameter is the action to be performed by the Android OS; we specified
    it here as `ACTION_VIEW`. This will tell the Android system that something is
    about to be viewed. The other parameter is the data, mostly defined in the `URI`
    format. We have used the PacktPub website as an example. The Android OS will open
    this web address in the default browser of the phone. If more than one browser
    is found, the user will be given a list of all the available browsers to choose
    one to view the address in.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与显式意图一样，隐式意图的构造函数中传递了两个参数。你可以在[第2章](ch02.html "第2章. Android意图简介")《Android意图简介》中阅读更多关于意图构造函数的内容。第一个参数是Android操作系统要执行的操作；我们在这里指定为`ACTION_VIEW`。这将告诉Android系统，即将查看某物。另一个参数是数据，通常以`URI`格式定义。我们使用了PacktPub网站作为示例。Android操作系统将在手机默认浏览器中打开这个网页地址。如果找到多个浏览器，用户将看到一个所有可用浏览器的列表，以选择一个查看地址。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any URI can be passed in here, not only a web address. For example, the URI
    of any contact in the phone or any image in the gallery can also be passed, and
    the Android OS will take the most suitable action for the data passed in the URI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以传递任何URI，不仅限于网页地址。例如，手机中任何联系人的URI或图库中的任何图片也可以传递，Android操作系统将为传递在URI中的数据采取最合适的操作。
- en: The general behavior of this intent proves to be a very important feature in
    Android development. Developers save a lot of time by making generalized apps.
    This becomes beneficial for the developers as they just have to send information.
    The rest is defined by the Android OS, and the users get a choice to perform the
    action as they wish. Developers can not only provide the user with the feature
    to choose other apps for performing actions in implicit intents, but they can
    also develop their own custom apps to be added in the choose list. For example,
    we develop an image-editing app. We want the app to function in such a way that
    when a user selects an image from any other app, our app appears in the options
    list so that the user can easily navigate to our app for editing images from anywhere
    in his or her phone. This can be done through implicit intents. But the difference
    this time is that we will not send implicit intents; instead, we will receive
    implicit intents from other apps. We can do this by registering the intent filter
    in our `AndroidManifest.xml` file, where we will have to define the action for
    which our app will perform. This feature makes an app more interactive with other
    apps, and the integration between different apps and the Android OS becomes very
    easy for developers. In the following sections, we will develop two examples of
    implicit intents, and see what we can do with these examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种意图的通用行为在Android开发中显得尤为重要。开发者通过制作通用应用节省了大量时间。这对开发者来说很有利，因为他们只需发送信息即可。其余的由Android操作系统定义，用户可以根据自己的意愿选择执行操作。开发者不仅可以为用户提供选择其他应用执行隐式意图中动作的功能，还可以开发自己的自定义应用，并将其添加到选择列表中。例如，我们开发了一个图片编辑应用。我们希望该应用能够实现在用户从任何其他应用中选择图片时，我们的应用能出现在选项列表中，这样用户就可以轻松地从手机中的任何位置导航到我们的应用来编辑图片。这可以通过隐式意图实现。但这次的差别是，我们不会发送隐式意图；相反，我们将从其他应用接收隐式意图。我们可以通过在我们的`AndroidManifest.xml`文件中注册意图过滤器来实现这一点，在这里我们需要定义应用将执行的操作。这个特性使得应用与其他应用的互动性更强，不同应用与Android操作系统之间的集成对开发者来说变得非常简单。在以下各节中，我们将开发两个隐式意图的示例，并看看我们可以用这些示例做什么。
- en: Using implicit intents in an Android application
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Android应用程序中使用隐式意图
- en: 'This section will discuss the various uses of implicit intents in an Android
    application. As discussed earlier, implicit intents can be used in communicating
    with other Android components in a general form unlike explicit intents. Let''s
    look at the implicit intents in action with the following two examples: one uses
    implicit intents for sharing content, and the other uses implicit intents to get
    content from other Android apps.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论在Android应用程序中隐式意图的各种用途。如前所述，隐式意图可以以通用形式用于与其他Android组件进行通信，与显式意图不同。让我们通过以下两个示例来看隐式意图的实际应用：一个用于共享内容，另一个用于从其他Android应用获取内容。
- en: Sharing content using implicit intents
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用隐式意图共享内容
- en: Today, social networking is what makes any application viral and promotes it
    to other users. Due to a large variety of social networks, it becomes difficult
    to put all of the sharing features in the apps. Mostly, developers add Facebook,
    Twitter, and Instagram in their apps, but adding those SDKs in the app sometimes
    becomes troublesome for the developers as well as the users. For example, multiple
    SDKs add some size in the build file; an app becomes complex due to a lot of features.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，社交网络是使任何应用程序病毒式传播并推广给其他用户的原因。由于社交网络的种类繁多，将所有共享功能都放入应用中变得困难。大多数情况下，开发者在他们的应用中添加Facebook、Twitter和Instagram，但有时在应用中添加这些SDK不仅给开发者带来麻烦，也给用户带来麻烦。例如，多个SDK会在构建文件中增加一些大小；应用由于功能过多而变得复杂。
- en: Fortunately, we can solve this problem using a few lines of code through implicit
    intents. Let's see how this can become possible by creating a simple content sharing
    example. First create an empty project using any Android IDE such as Eclipse with
    the ADT plugin or Android Studio, or open any existing project in which you want
    to add the share feature. We will now implement the use of implicit intents in
    sharing any data on social networks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过几行代码使用隐式意图来解决此问题。让我们通过创建一个简单的内容共享示例来看看这是如何可能的。首先，使用任何Android IDE（如带有ADT插件的Eclipse或Android
    Studio）创建一个空项目，或者打开您想要添加共享功能的任何现有项目。我们现在将实现使用隐式意图在社交网络上共享任何数据。
- en: We have implemented a simple, one line-sharing application that asks the user
    to choose the sharing method and shares the line on that network. There are two
    main files that are modified in any empty project. Let's explore both the files
    one by one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个简单的单行分享应用，该应用会要求用户选择分享方式，并在该网络上分享这一行内容。在任何空项目中，都有两个主要文件会被修改。让我们逐一探索这两个文件。
- en: The activity_main.xml file
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: activity_main.xml文件
- en: 'The activity_main.xml file is the visual layout of our simple, line-sharing
    app. The following code snippet shows the implementation of this file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: activity_main.xml文件是我们简单的行分享应用的视觉布局。以下代码片段展示了这个文件的实现：
- en: '![The activity_main.xml file](img/9639_03_14.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![activity_main.xml文件](img/9639_03_14.jpg)'
- en: 'We have a relative layout in which we have placed two Views: a button with
    `text` as `Share` and an `<EditText>` tag to get an input line from the user.
    In the previous examples, we used `<LinearLayout>` to align the Views on the screen.
    This time, we used `<RelativeLayout>` to add the Views. In relative layouts, we
    place our Views relative to other Views. For example, `android:layout_alignLeft`
    takes the ID of any View and puts this View on the left-hand side of the main
    View. Similarly, we also used the `android:layout_below` attribute in the `Share`
    button to place it below the text field. About the text field, this is the first
    View on the screen; so, this can be placed relative to the parent View.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相对布局，在其中放置了两个视图：一个带有`text`为`Share`的按钮和一个`<EditText>`标签，用于获取用户的输入行。在之前的例子中，我们使用了`<LinearLayout>`来在屏幕上对齐视图。这次，我们使用了`<RelativeLayout>`来添加视图。在相对布局中，我们根据其他视图来放置我们的视图。例如，`android:layout_alignLeft`获取任何视图的ID，并将此视图放在主视图的左侧。同样，在`Share`按钮中，我们也使用了`android:layout_below`属性，将其放置在文本字段下方。关于文本字段，这是屏幕上的第一个视图；因此，它可以相对于父视图放置。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `layout_ android:layout_alignParentLeft` and `android:layout_alignParentTop`
    Boolean flags place the `EditText` View on the top-left corner of the parent,
    that is, the screen. Using Relative layouts for aligning a View is the most recommended
    method in the Android OS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout_ android:layout_alignParentLeft`和`android:layout_alignParentTop`布尔标志将`EditText`视图放置在父视图的左上角，即屏幕的左上角。在Android操作系统中，使用相对布局来对齐视图是最推荐的方法。'
- en: This was the visual representation of our one line-sharing app. Now, let's see
    how implicit intents are used in the main activity file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的单行分享应用的视觉表示。现在，让我们看看在主活动文件中是如何使用隐式意图的。
- en: The MainActivity.java class
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MainActivity.java类
- en: 'The MainActivity.java class file is the main activity of the line-sharing app.
    The following code shows the implementation of the file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MainActivity.java类文件是行分享应用的主活动。以下代码展示了该文件的实现：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class is extended from the `Activity` class in order to make it an activity.
    As usual, we override the `onCreate()` method, set the Content View of the activity
    by the `setContentView()` method, and reference a layout that is our `activity_main.xml`
    file placed in the `res/layout` directory. After setting the layout, we get the
    button reference from the layout by the `findViewById()` method and set its `View.OnClickListener`
    interface to an anonymous object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是从`Activity`类扩展而来的，目的是使其成为一个活动。像往常一样，我们重写了`onCreate()`方法，通过`setContentView()`方法设置活动的Content
    View，并引用了一个布局，这个布局就是位于`res/layout`目录下的`activity_main.xml`文件。设置布局后，我们通过`findViewById()`方法从布局中获取按钮的引用，并将其`View.OnClickListener`接口设置为一个匿名对象。
- en: After setting the Views, let's set the listeners and define the functionalities
    on the touchable Views. For this purpose, we have overridden the `onClick()` method
    of the listener and placed our main functionality code in this method as we want
    to share the line on a button tap. We have first got the message text from the
    text field by getting its reference and then the text in the field. We created
    an `Intent` object and passed `ACTION_SEND` as its category into the constructor.
    The `ACTION_SEND` intent delivers data to the Android OS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 设置视图后，让我们设置监听器并在可触摸视图上定义功能。为此，我们重写了监听器的`onClick()`方法，并在该方法中放置了我们的主要功能代码，因为我们要在按钮点击时分享行内容。我们首先通过获取其引用从文本字段中获取消息文本，然后获取字段中的文本。我们创建了一个`Intent`对象，并在构造函数中传递了`ACTION_SEND`作为其类别。`ACTION_SEND`意图将数据传递给Android操作系统。
- en: Remember that we have not specified the receiver of the data unlike in explicit
    intents, where we used to specify the target explicitly. It is up to the receiver
    of this action to ask the user where the data should be sent, and this happens
    through the chooser dialog.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们没有像显式意图中那样明确指定数据的接收者。这个动作的接收者会通过选择器对话框询问用户数据应该发送到哪里。
- en: After creating an instance of the intent, we add the extra data of the message
    line in the intent. We have chosen the `EXTRA_TEXT` key to add our data in. For
    example, if we want to send an SMS, we have to insert the data into the SMS body,
    and if we want to send an e-mail, we have to put the data into the e-mail body.
    So, we have chosen a general type of the text, and the Android OS will detect
    a suitable place to put the data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建意图实例后，我们在意图中添加了消息行的额外数据。我们选择了`EXTRA_TEXT`键来添加我们的数据。例如，如果我们想发送短信，我们必须将数据插入到短信正文中；如果我们想发送电子邮件，我们必须将数据放入电子邮件正文中。因此，我们选择了一般文本类型，Android操作系统将检测到合适的位置放置数据。
- en: Until now, we have set the category and data, but we have to set the type of
    the data as well. The Android OS will put the apps in our chooser dialog on the
    basis of the type of the data. For example, we have set the type to `text/html`;
    this will put all the apps that support the text or HTML format of the data, such
    as e-mail, Facebook, Twitter, and so on, in the chooser. If we set `this` to `image/png`,
    all the apps, such as image editors, gallery, and so on, will be put in the chooser
    list. Also, we can define general types of supported images by putting a slash
    followed by a star. For example, `image/*` will put all the image apps, not limited
    to only PNG, in the chooser list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了类别和数据，但我们还必须设置数据的类型。Android操作系统将根据数据的类型在我们的选择器对话框中放置应用。例如，我们将类型设置为`text/html`；这将把所有支持文本或HTML数据格式的应用，如电子邮件、Facebook、Twitter等，放在选择器中。如果我们将其设置为`image/png`，所有支持图像编辑、图库等的应用将被放入选择器列表中。此外，我们可以通过放置一个斜杠后跟一个星号来定义支持的图像的一般类型。例如，`image/*`将把所有支持图像的应用，不仅限于PNG，放在选择器列表中。
- en: Finally, we start the activity with this intent by calling the `startActivity()`
    method. You should be careful to pass the intent in the `startActivity()` method
    or in the `Intent.chooser()` method. If we pass the intent in `startActivity`,
    we will get the `ActivityNotFoundException` exception. We don't specifically know
    which activity to start in order to share the app; so, in that case, we will create
    a chooser list, and the user will decide which activity to start. This is how
    we provide the user with the option to choose his or her favorite method to share
    the content.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`startActivity()`方法启动这个意图的活动。你应该小心，在`startActivity()`方法或`Intent.chooser()`方法中传递意图。如果我们通过`startActivity`传递意图，我们将得到`ActivityNotFoundException`异常。我们不知道为了共享应用而具体要启动哪个活动；在这种情况下，我们将创建一个选择器列表，用户将决定要启动哪个活动。这就是我们为用户提供选择他或她喜欢的共享内容方式的方法。
- en: 'Now, run the project and you will see a screen that will have a **Share** button
    and a text field to write something to share. On pressing the **Share** button,
    you will see a dialog asking you to choose the method of sharing. This dialog
    will include all those apps, such as text messaging, SMS, MMS, e-mail, and Facebook,
    which are used to share the text. The following figure shows the app screens:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目，你会看到一个屏幕，上面有一个**共享**按钮和一个输入要共享内容的文本字段。按下**共享**按钮后，你会看到一个对话框，询问你选择共享的方法。这个对话框将包括所有用于共享文本的应用，如短信、SMS、MMS、电子邮件和Facebook。以下截图展示了应用屏幕：
- en: '![The MainActivity.java class](img/9639_03_16.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java 类](img/9639_03_16.jpg)'
- en: In this example, we used implicit intents to communicate with other apps of
    the Android OS. In the next example, we will see how other apps can communicate
    with our app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用隐式意图与Android操作系统的其他应用进行通信。在下一个示例中，我们将看到其他应用如何与我们的应用通信。
- en: Registering your app for the share intent
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为共享意图注册你的应用
- en: In the previous example, we triggered other sharing apps from our app. In this
    example, we will register our app for the share intent so that the other app developers
    and users can communicate with our app using implicit intents. Both examples use
    implicit intents, but the method of use is different in both cases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们从我们的应用触发了其他共享应用。在本例中，我们将为共享意图注册我们的应用，以便其他应用开发者和用户可以使用隐式意图与我们的应用通信。两个示例都使用了隐式意图，但使用方法在这两种情况下是不同的。
- en: In the previous example, we used implicit intents in Java files and triggered
    the intent on a button tap in `OnClickListener`. In this example, to register
    our app for any intent such as the share intent in this case, we have to put our
    code in the XML file in the `AndroidManifest.xml` file. Just to revise a little,
    the `AndroidManifest.xml` file manages all the settings of our app. Let's learn
    how to implement the app now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们在Java文件中使用了隐式意图，并在`OnClickListener`中的按钮点击时触发了意图。在此示例中，为了注册我们的应用以接收任何意图，例如此例中的分享意图，我们必须在`AndroidManifest.xml`文件的XML文件中放置我们的代码。稍微复习一下，`AndroidManifest.xml`文件管理我们应用的所有设置。现在让我们学习如何实现应用。
- en: 'In order to start this example, create an empty project using any Android IDE
    such as Eclipse with the ADT plugin or Android Studio, or open any existing project
    in which you want to receive the send intent. In this project, we will explore
    the use of implicit intents in getting the data shared by other apps in our app.
    We first register our app as a text-sharing app. Then, all the apps that share
    any `text/html` type file in Android can trigger our app if a user chooses it.
    To perform this task, we have modified the code in three files: a layout file,
    an activity file, and the manifest file. Let''s look at those files one by one
    now.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此示例，请使用任何Android IDE（如带有ADT插件的Eclipse或Android Studio）创建一个空项目，或打开你想要接收发送意图的任何现有项目。在这个项目中，我们将探索在应用中获取其他应用共享数据时隐式意图的使用。我们首先将我们的应用注册为文本共享应用。然后，所有在Android中共享任何`text/html`类型文件的应用都可以在用户选择时触发我们的应用。为了执行这个任务，我们修改了三个文件中的代码：一个布局文件、一个活动文件和清单文件。现在让我们逐一看看这些文件。
- en: The activity_main.xml file
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`activity_main.xml`文件'
- en: 'The activity_main.xml file is the visual layout of our sharing app. The following
    code shows the implementation of this file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity_main.xml`文件是我们共享应用的视觉布局。以下代码展示了此文件的实现：'
- en: '![The activity_main.xml file](img/9639_03_17.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![activity_main.xml文件](img/9639_03_17.jpg)'
- en: We have a Relative layout with a text View component in it. We have set the
    initial text value of Text View to "Hello World"; remember that the data we get
    from other apps while sharing will be printed in this Text View content. After
    the visual representation, it always comes to the processing and coding logic
    of app. Let's look at the next activity file which performs the main task and
    implements the logic of using implicit intents.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含文本视图组件的相对布局。我们将文本视图的初始文本值设置为“Hello World”；记住，我们从其他应用共享时得到的数据将打印在此文本视图内容中。在视觉表现之后，接下来总是应用的处理和编码逻辑。现在让我们看看下一个活动文件，它执行主要任务并实现使用隐式意图的逻辑。
- en: The MainActivity.java class
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`MainActivity.java`类'
- en: 'The MainActivity.java class file is the activity that displays the data which
    is shared from any other app. The following code shows the implementation of this
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity.java`类文件是显示来自任何其他应用共享数据的活动。以下代码展示了此文件的实现方法：'
- en: '![The MainActivity.java class](img/9639_03_18.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java类](img/9639_03_18.jpg)'
- en: When a user chooses our app from the **Share** dialog, this activity will be
    opened. We also have set this activity to our main activity. Any activity in the
    app can be registered for getting the share intent. It is not necessary that the
    main activity has to be registered for getting the shared data. We have set the
    layout of the activity, and after that, we get the intent data. This is the data
    that will be thrown from any other sharing app. We first get the intent by calling
    the `getIntent()` method. There are many types of intents; we have to make sure
    that our activity will work only for the intent type that we have registered in
    the `AndroidManifest.xml` file. To detect whether this intent was sent for sharing
    or not, we have to check the intent action. So, we have obtained the action of
    intent by calling the `Intent.getAction()` method. We can get the type of intent
    using the `Intent.getType()` method. Then, we check the type and action.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从**分享**对话框中选择我们的应用时，此活动将被打开。我们还已将此活动设置为我们的主活动。应用中的任何活动都可以注册以接收分享意图。主活动不一定需要注册以接收共享数据。我们已设置活动的布局，之后我们获取意图数据。这是将从任何其他分享应用抛出的数据。我们首先通过调用`getIntent()`方法获取意图。有许多类型的意图；我们必须确保我们的活动只对我们在`AndroidManifest.xml`文件中注册的意图类型起作用。为了检测此意图是否用于分享，我们必须检查意图动作。因此，我们通过调用`Intent.getAction()`方法获取了意图的动作。我们可以使用`Intent.getType()`方法获取意图的类型。然后，我们检查类型和动作。
- en: If the intent action is `Intent.ACTION_SEND` and the type is `text/html`, it
    means that we can display that type of data in our app. If both conditions are
    `true`, we set the Text View content to the data that we got from the intent.
    We can get the data from the intent through the `Intent.getStringExtra()` method.
    This method takes the data type as an input argument or parameter. In this example,
    we get the `Intent.EXTRA_TEXT` data type that represents any text or message data
    in the intent that is normally used for the body text in e-mails, Facebook posts,
    or SMS messages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意图动作是`Intent.ACTION_SEND`且类型为`text/html`，这意味着我们可以在应用中显示那种类型的数据。如果两个条件都为`true`，我们将文本视图内容设置为从意图中得到的数据。我们可以通过`Intent.getStringExtra()`方法从意图中获取数据。这个方法将数据类型作为输入参数或参数。在这个例子中，我们获取了`Intent.EXTRA_TEXT`数据类型，它表示意图中通常用于电子邮件正文、Facebook帖子或短信的消息或文本数据。
- en: By understanding the `MainActivity` class, we saw that we have only got the
    intent and checked it. But there is also a problem regarding how the other apps
    are going to recognize our app and how they can know that our app can display
    the `text/html` data. If we open this activity explicitly from another activity
    of the same app, the same intent will be received and the same conditions will
    be checked. But this time, no condition will be `true`, so no text will be changed
    in the layout. To make the app visible to other apps, we have to register an intent
    filter. This is done in the `AndroidManifest.xml` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解`MainActivity`类，我们得知我们只是接收了意图并检查了它。但还有一个问题，就是其他应用如何识别我们的应用，以及它们如何知道我们的应用可以显示`text/html`数据。如果我们从同一应用的另一个活动中显式打开这个活动，同样会接收到相同的意图，并检查相同的条件。但这次，没有条件会为`true`，因此布局中的文本不会改变。为了让其他应用看到我们的应用，我们必须注册一个意图过滤器。这是在`AndroidManifest.xml`文件中完成的。
- en: The AndroidManifest.xml file
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件'
- en: 'To make our app visible for sharing content, we have to register the receiving
    activity of the app with an intent filter in this file. The following code shows
    the implementation of this file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的应用在分享内容时可见，我们必须在文件中为应用的接收活动注册一个意图过滤器。以下代码展示了此文件的实现：
- en: '![The AndroidManifest.xml file](img/9639_03_19.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![`AndroidManifest.xml`文件](img/9639_03_19.jpg)'
- en: In the `<activity>` tag of `MainActivity`, we have inserted two intent filters.
    The first intent filter is to make this activity a main activity and the launcher
    of the app. The second intent filter is a piece of code that performs the core
    functions of the app. We have inserted an intent filter with the action as `android.intent.action.SEND`
    and `mimeType` as `text/html`. This tells the Android OS that whenever any intent
    with the `Send` action is triggered and it contains data with `text/html` type,
    the app can process this intent. This is how our app is shown in the chooser dialog
    of the app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的`<activity>`标签中，我们插入了两个意图过滤器。第一个意图过滤器是为了让这个活动成为主活动，也就是应用的启动器。第二个意图过滤器是一段执行应用核心功能的代码。我们插入了一个意图过滤器，其动作为`android.intent.action.SEND`，`mimeType`为`text/html`。这告诉安卓操作系统，每当触发具有`Send`动作的意图，并且包含`text/html`类型的数据时，应用都可以处理这个意图。这样我们的应用就会显示在应用的chooser对话框中。
- en: 'Now, run the project and you will see the **Hello World** screen. Close the
    app and run our previous example app, **ShareImplicitIntent**. Write something
    in the text field and tap the **Share** button. In the chooser dialog, you will
    see our app, **GettingSharedData,** in the list. Choosing this app will open the
    activity, and this time, instead of **Hello World**, you will see the data shared
    from another app in the text field. The following screenshot shows a demo of the
    app:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目，你会看到**Hello World**的屏幕。关闭应用并运行我们之前的示例应用**ShareImplicitIntent**。在文本字段中写些东西，然后点击**分享**按钮。在chooser对话框中，你会在列表中看到我们的应用**GettingSharedData**。选择这个应用会打开活动，这次，文本字段中不会显示**Hello
    World**，而是会显示从另一个应用共享的数据。以下截图展示了应用的演示效果：
- en: '![The AndroidManifest.xml file](img/9639_03_20.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![`AndroidManifest.xml`文件](img/9639_03_20.jpg)'
- en: So far, we have seen two examples of implicit intents. In one example, we shared
    some data with other apps such as e-mail, SMS, Facebook, and so on. In the other
    example, other apps shared their content with our app, and we received that data
    and displayed it. But, implicit intents are not limited to sharing content alone.
    There are lots of options and choices that can be performed using implicit intents,
    including making calls, sending texts, showing maps, searching for anything, taking
    pictures, showing and editing contacts, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两个隐式意图的例子。在一个例子中，我们与其他应用如电子邮件、短信、Facebook等共享了一些数据。在另一个例子中，其他应用与我们的应用共享内容，我们接收了这些数据并进行了展示。但是，隐式意图并不仅限于共享内容。使用隐式意图可以执行很多操作和选择，包括拨打电话、发送短信、显示地图、搜索任何内容、拍照、显示和编辑联系人等等。
- en: In our next example, we will learn how we can pick any image from the gallery
    and display it in our activity.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将学习如何从图库中选择任何图片并在我们的活动中显示它。
- en: Selecting an image through an implicit intent
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过隐式意图选择图片
- en: In this project, we will implement the use of implicit intents to pick any image
    from the gallery. We will put an Image View that will display an image in our
    app. This image will be chosen by the user from the gallery. Let's implement it
    now! In order to start this example, create an empty project using any Android
    IDE such as Eclipse with the ADT plugin or Android Studio, or open any existing
    project in which you want to add the image picking feature.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将实现使用隐式意图从图库中选择任何图片的功能。我们将放置一个ImageView，以在我们的应用中显示图片。这张图片将由用户从图库中选择。现在就让我们来实现它吧！为了开始这个例子，请使用任何Android
    IDE（如带有ADT插件的Eclipse或Android Studio）创建一个空项目，或者打开任何你想要添加图片选择功能的项目。
- en: 'We will register our app as an image-sharing app, and then all the apps which
    share any image in Android OS can trigger our app if the user chooses it. We have
    modified the code in three files: a layout file, an activity file, and the manifest
    file. Let''s see what these files do.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册我们的应用作为一个图片分享应用，这样在Android操作系统中所有分享图片的应用都可以在用户选择的情况下触发我们的应用。我们修改了三个文件中的代码：一个布局文件、一个活动文件和清单文件。让我们看看这些文件的作用。
- en: The activity_main.xml file
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`activity_main.xml`文件'
- en: 'Just like in all the Android apps, the activity_main.xml file represents the
    layout file of the main activity. The following code shows the implementation
    of this file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有Android应用一样，`activity_main.xml`文件代表了主活动的布局文件。以下代码展示了此文件的实施例：
- en: '![The activity_main.xml file](img/9639_03_21.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![`activity_main.xml`文件](img/9639_03_21.jpg)'
- en: We have placed two View components; a button View to open the gallery on a tap
    and an Image View to display the image. Unlike other apps, we have set the button
    listener in our layout file. Revising the last method, we set our click listener
    by calling the `button.setOnClickListener()` method in the activity class file.
    In this example, we have used the `android:onClick` attribute in the `<Button>`
    tag, and provided the name of the listener on the other side of the attribute.
    We have to provide a method name that should be defined in the activity file using
    this layout.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放置了两个视图组件；一个按钮视图，用于点击时打开图库，以及一个用于显示图片的ImageView。与其他应用不同，我们在布局文件中设置了按钮监听器。回顾最后一种方法，我们通过在活动类文件中调用`button.setOnClickListener()`方法来设置我们的点击监听器。在这个例子中，我们在`<Button>`标签中使用了`android:onClick`属性，并在属性另一侧提供了监听器的名称。我们必须提供一个方法名，该方法应该在此布局使用的活动文件中定义。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Android OS recommends that you set listeners in the XML layout file. But,
    if the layout is used by more than one activity, developers should be careful
    as an attribute value is a method name and should be defined in the activity file.
    That means either all activities using the layout file should define that method,
    or all activities should set the listeners in Java files instead of XML.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统建议你在XML布局文件中设置监听器。但是，如果布局被多个活动使用，开发者应该注意，因为属性值是一个方法名，并且应该在活动文件中定义。这意味着要么所有使用布局文件的活动都定义该方法，要么所有活动都应该在Java文件中设置监听器，而不是在XML中。
- en: The other View component in our layout file is Image View. This Image View will
    show the image picked from the gallery or other image sharing apps. We have set
    Image View's source to launcher-icon image as the default image.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们布局文件中的另一个视图组件是ImageView。这个ImageView将显示从图库或其他图片分享应用中选择的图片。我们将ImageView的来源设置为启动器图标图像作为默认图片。
- en: After developing the layout of the app, let's focus on the logic of the app.
    The `MainActivity` file shows how the app gets the image from other apps and displays
    it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序的布局之后，让我们关注应用程序的逻辑。`MainActivity`文件展示了应用程序如何从其他应用程序获取图像并显示它。
- en: The MainActivity.java class
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MainActivity.java类
- en: 'The MainActivity.java class is the main activity Java file that performs all
    the functionalities in the app. The following code snippet is the implementation
    of this file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: MainActivity.java类是主活动Java文件，它执行应用程序中的所有功能。以下代码段是此文件的实现：
- en: '![The MainActivity.java class](img/9639_03_22.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java类](img/9639_03_22.jpg)'
- en: We start from the `onCreate()` method where we first set the Content View of
    the activity to our layout file. We have created three private fields in our class.
    The first is the `REQUEST_CODE` constant that is an integer value. This constant
    is used as the request code to get any data from any other Android app. As we
    are picking an image from the gallery, we need a request code to identify the
    correct results and data. The second field is the bitmap. This bitmap is used
    to store the picked image in the bitmap format. The third and last field of the
    activity class is Image View. This is used to reference Image View in the XML
    file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`onCreate()`方法开始，首先将活动的Content View设置为我们布局文件。我们在类中创建了三个私有字段。第一个是`REQUEST_CODE`常量，它是一个整数值。这个常量用作从任何其他Android应用获取数据的请求代码。由于我们要从图库中选择图片，因此需要一个请求代码来识别正确的结果和数据。第二个字段是位图。这个位图用于以位图格式存储选中的图片。活动类的第三个也是最后一个字段是Image
    View。这用于在XML文件中引用Image View。
- en: The `pickImage()` method is the button listener that was set in the XML layout
    file in the `<Button>` tag. This method should take the `View` parameter. This
    parameter contains the View that was tapped at runtime. As per our app requirements,
    we want to open the gallery on a button tap; so, to open the gallery, an implicit
    intent will be triggered in this method. We create an empty intent object with
    a no-argument constructor. Then, we set its type to any image format using `image/*.`
    After that, we set its intent action to `Intent.ACTION_GET_CONTENT`. This tells
    the Android OS to show all those apps that share the content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickImage()`方法是设置在XML布局文件的`<Button>`标签中的按钮监听器。这个方法应该带有`View`参数。这个参数包含了在运行时被点击的视图。根据我们应用程序的要求，我们希望在按钮点击时打开图库；因此，为了打开图库，在这个方法中将触发一个隐式意图。我们使用无参数构造函数创建一个空的意图对象。然后，我们使用`image/*`将其类型设置为任何图像格式。之后，我们将它的意图动作设置为`Intent.ACTION_GET_CONTENT`。这告诉Android操作系统显示所有共享内容的应用程序。'
- en: Now, we already told the Android OS that we need only the image content by setting
    the type; so, the Android OS will only show those apps, such as gallery, that
    shares images. We set the category to `Intent.CATEGORY_OPENABLE`. This is used
    to indicate that the `GET_CONTENT` intent only wants the URIs that can be opened
    with `ContentResolver.openInputStream`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经告诉Android操作系统，我们只需要图像内容，通过设置类型；因此，Android操作系统只显示那些共享图像的应用程序，如图库。我们将类别设置为`Intent.CATEGORY_OPENABLE`。这用于指示`GET_CONTENT`意图只需要可以用`ContentResolver.openInputStream`打开的URIs。
- en: Finally, we start the activity by calling the `startActivityForResult()` method.
    Remember that we used the `startActivity()` method in our previous apps.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`startActivityForResult()`方法来启动活动。请记住，在我们之前的应用程序中使用了`startActivity()`方法。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The difference between the `startActivity()` and `startActivityForResult()`
    methods is that the `startActivityForResult()` method returns some result to the
    parent activity after being stopped while `startActivity()` doesn't return anything.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`startActivity()`方法和`startActivityForResult()`方法之间的区别在于，`startActivityForResult()`方法在停止后会将一些结果返回给父活动，而`startActivity()`则不返回任何内容。'
- en: As we need to get any image from gallery, the gallery app will return the URI
    of the image that we will use in our app to display it. To get the result in our
    activity, we need to override the `onActivityResult()` method in our class. This
    method takes three parameters. The first is a request-code that is an integer
    value. This value defines the request ID that we used to start an activity. We
    have used a constant private field `REQUEST_CODE` in our class for this value;
    so, in our `onActivityResult()` method, we will compare the request code to this
    constant value for confirmation. The second parameter, `RESULT_CODE`, is an integer
    value. This value tells us whether the result we have got is correct and okay
    to use or not. The third and last parameter is the intent; this contains the resulting
    data that we will use in our app.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要从图库中获取任何图片，图库应用将返回我们将在应用中使用的图片URI以显示它。为了在我们的活动中获取结果，我们需要在类中覆盖`onActivityResult()`方法。这个方法有三个参数。第一个是请求码，是一个整数值。这个值定义了我们用于启动活动的请求ID。我们在类中使用了一个常量私有字段`REQUEST_CODE`作为这个值；因此，在我们的`onActivityResult()`方法中，我们将请求码与这个常量值进行比较以确认。第二个参数`RESULT_CODE`是一个整数值。这个值告诉我们得到的结果是否正确且可以使用。第三个参数是意图，它包含我们将要在应用中使用的结果数据。
- en: In the `onActivityResult()` method, we created an `InputStream` object and then
    we compared our request code and result code to confirm whether we should process
    the intent data or not. If everything goes fine, we get the URI of the picked
    image by calling the `Intent.getData()` method and pass it to `openInputStream()`
    of the content resolver of this activity. The content resolver of any activity
    can be retrieved by calling the `Activity.getContentResolver()` method. After
    getting the stream of the URI, we decode it to bitmap by calling the `BitmapFactory.decodeStream()`
    method, and set the output bitmap to our activity-bitmap field. Then, we set the
    bitmap in our Image View. And in the final section of the `try/catch` block, we
    close our stream.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onActivityResult()`方法中，我们创建了一个`InputStream`对象，然后通过比较请求码和结果码来确定是否应该处理意图数据。如果一切顺利，我们可以通过调用`Intent.getData()`方法获取选定的图片URI，并将其传递给本活动的`ContentResolver`的`openInputStream()`。任何活动的`ContentResolver`都可以通过调用`Activity.getContentResolver()`方法获得。获取到URI的数据流后，我们通过调用`BitmapFactory.decodeStream()`方法将其解码为位图，并将输出位图设置到我们的活动位图字段中。然后，我们在图像视图中设置位图。在`try/catch`块的最后一部分，我们关闭了流。
- en: 'Now, run the project and you will see the screens as shown in following screenshot.
    The user taps on the button, and the gallery will be shown. Then, the user chooses
    his favorite photo to be displayed, and the app displays it on the app screen:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目，您将看到如下截图所示的屏幕。用户点击按钮，将显示图库。然后，用户选择他喜欢的照片以显示，应用将在应用屏幕上展示它：
- en: '![The MainActivity.java class](img/9639_03_23.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java类](img/9639_03_23.jpg)'
- en: Summarizing the whole section of implicit intents, we implemented three examples.
    In the first example, we learned how to share our data with other apps. In the
    second example, we learned how other apps can share their data with our app. And
    finally, in the third and last example, we learned how to get an image from the
    gallery and use it in our app. In the next and last section of the chapter, we
    will discuss Android late binding.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总结关于隐式意图的整个部分，我们实现了三个示例。在第一个示例中，我们学习了如何与其他应用共享数据。在第二个示例中，我们了解了其他应用如何与我们的应用共享数据。最后，在第三个也是最后一个示例中，我们学习了如何从图库获取图片并在我们的应用中使用它。在下一节也是最后一节中，我们将讨论Android晚期绑定。
- en: Intents and Android late binding
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图和Android晚期绑定
- en: As we all know, three of the most core components of an application in Android
    are activities, services, and broadcast receivers. These components communicate
    and are triggered via messaging. This messaging is done through intents. Intent
    messaging is a facility for late-runtime binding (late binding) between components
    in the same or different applications. In each case, an Android system finds the
    right component, such as an activity, service, or receiver to be triggered, and
    instants them if necessary. There is no overlapping within these intents. For
    example, broadcast receiver intents are only sent to broadcast receivers and never
    sent to any activity or service. Another example is that an intent passed in the
    `startActivity()` or `startActivityForResult()` method is never sent to any component
    such as a service or receiver, but only to an activity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Android 应用程序最核心的三个组件是活动（activities）、服务（services）和广播接收器（broadcast receivers）。这些组件通过消息传递进行通信和触发。这种消息传递是通过意图（intents）完成的。意图消息传递是同一应用程序或不同应用程序中组件之间的晚期运行时绑定（晚期绑定）的机制。在每种情况下，Android
    系统都会找到正确的组件，例如要触发的活动、服务或接收器，并在必要时实例化它们。这些意图之间没有重叠。例如，广播接收器意图只发送给广播接收器，而不会发送给任何活动或服务。另一个例子是，通过`startActivity()`或`startActivityForResult()`方法传递的意图永远不会发送给任何如服务或接收器这样的组件，而只发送给一个活动。
- en: In the examples used in this chapter, implicit intents always performed actions
    in which the developer was not sure about how these actions will be performed
    and with what apps. This runtime behavior of assigning actions to components is
    called Android late-runtime binding, and this can be done easily via implicit
    intents.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章使用的示例中，隐式意图总是执行开发者不确定这些操作将如何执行以及使用什么应用程序的动作。这种将动作分配给组件的运行时行为称为Android晚期运行时绑定，这可以通过隐式意图轻松完成。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the categories of intents, implicit intents, explicit
    intents, and late binding. The chapter also provided some important implementation
    of Android intents in which we shared our data with other apps, the other apps
    shared data with our app, picked any image from gallery, started an activity or
    service through explicit intents, and so on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了意图的分类，包括隐式意图、显式意图和晚期绑定。本章还提供了Android意图的一些重要实现，我们通过这些实现与其他应用程序共享数据，其他应用程序与我们的应用程序共享数据，从图库中选择任何图片，通过显式意图启动活动或服务等等。
- en: In the next chapter, we will learn how mobile components such as a camera, can
    be triggered by intents, and how they are used in our apps.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过意图触发移动组件，例如摄像头，以及它们在我们的应用程序中的使用方式。
