- en: Chapter 5. Multithreading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 多线程
- en: When the mobile phone market started falling and the smartphones one boomed,
    it was clear that users needed a large computing capacity on a mobile device.
    The growing demand for calculation and the availability of suitable hardware has
    led to multicore CPUs on the devices, allowing parallel execution of multiple
    tasks. Android engineers knew this before it happened. Moreover, that is why we
    have many options to execute different tasks at the same time, with great flexibility
    and a lot of different components to choose to apply to our multithreading strategy.
    However, are we doing well? To answer this question, we will see all the threading
    facets, from the basics of threading Java framework inherited by the Android platform
    to all of the classes Android provides for this aim. We will also see how Android
    handles its processes and how we can correctly choose the right component to use
    in different situations, because not all of them are interchangeable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当手机市场开始下滑，智能手机市场兴起时，用户显然需要在移动设备上拥有强大的计算能力。对计算能力的不断增长的需求以及合适硬件的可用性导致了设备上的多核CPU，允许并行执行多个任务。Android工程师在这一切发生之前就已经知道了这一点。此外，这就是为什么我们有多种选项可以同时执行不同的任务，具有很大的灵活性，以及许多不同的组件可供选择以应用于我们的多线程策略。然而，我们做得好吗？为了回答这个问题，我们将了解线程的所有方面，从Android平台继承的Java框架线程基础到Android为此目的提供的所有类。我们还将了解Android如何处理其进程，以及我们如何在不同情况下正确选择合适的组件，因为并非所有组件都是可互换的。
- en: It might seem easy to deal with multithreading, but there are many pitfalls,
    especially in communication between multiple threads. So, we will see how the
    Android platform helps us to handle this kind of problem, providing some useful
    classes that we will use in lots of cases. Our goal is to know how to use them
    and how to handle them properly to improve the performance of our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多线程看似简单，但在多个线程之间的通信中存在许多陷阱。因此，我们将了解Android平台如何帮助我们处理这类问题，提供了一些有用的类，我们将在许多情况下使用它们。我们的目标是了解如何正确使用它们以及如何处理它们，以提高我们应用程序的性能。
- en: As developers, our aim is to measure the performance of the application. So,
    in the last part of this chapter, we will introduce an instrument to be used to
    detect if some code is being executed in the main thread, slowing down the responsiveness
    of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们的目标是衡量应用程序的性能。因此，在本章的最后部分，我们将介绍一个工具，用于检测某些代码是否在主线程中执行，从而降低了应用程序的响应性。
- en: Walkthrough
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演练
- en: We will define here all we need to know to deal with a multithreading environment
    like Android. It is crucial to understand what a thread is and what problems can
    occur while dealing with one. That is why we are focusing on the Java framework
    for a while, because every Android developer should know those notions, and then
    we will focus on how that platform is defined in Android and integrated with more
    objects. This provides multiple ways to separate execution at all levels, from
    the multithreading inside an application to the communication between different
    processes, defining a particular language to reach the target. So, let's see what
    we are talking about.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里定义所有需要了解的内容，以便处理像Android这样的多线程环境。理解线程是什么以及处理线程时可能遇到的问题至关重要。因此，我们会暂时聚焦于Java框架，因为每位Android开发者都应该了解这些概念，然后我们将关注该平台在Android中的定义以及与更多对象的集成。这为从应用程序内的多线程到不同进程间通信的所有级别提供了多种分离执行的方式，定义了一种特定的语言以实现目标。那么，让我们看看我们讨论的是什么。
- en: Threading basics
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程基础
- en: We could think of a thread as a portion of instructions executed sequentially.
    These instructions are translated to be performed by the hardware of the device.
    When there are multiple portions of instructions to be executed, then the environment
    is called **multithreaded**. This technique is helpful to speed up any system
    because the parallel execution is always faster than the serial one. Moreover,
    this improves responsiveness in all of the application with a user interface and
    can lead to better management of resources and the system in general.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将线程视为一系列按顺序执行的指令。这些指令被翻译成由设备硬件执行的指令。当有多个部分指令需要执行时，环境就被称为**多线程**。这种技术有助于加速任何系统，因为并行执行总是比串行执行快。此外，这提高了具有用户界面的应用程序的响应性，并可能导致更好的资源管理和整个系统的管理。
- en: Java provides the `java.lang.Thread` package with lots of classes used to handle
    concurrency among multiple threads. This is a wrapper for the actual background
    execution that is not visible to the developer. That is why we need to understand
    the Java framework before deepening the Android one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`java.lang.Thread`包，其中包含许多用于处理多个线程间并发性的类。这是对实际后台执行的包装，对开发者不可见。因此，在深入理解Android框架之前，我们需要先了解Java框架。
- en: Multicore CPUs
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多核CPU
- en: Until a few years ago, processors could only execute one instruction at a time.
    Nevertheless, the threading framework already existed. Then, code from multiple
    threads were executed sequentially using a time-slicing technique, and multithreading
    was just a fiction. In this case, we cannot know which order the virtual machine
    will follow to execute code from multiple threads. However, processors with multicore
    technology have been available for some years. They can execute multiple codes
    simultaneously, making multithreading a reality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，处理器一次只能执行一条指令。然而，线程框架已经存在。然后，使用时间分片技术按顺序执行来自多个线程的代码，而多线程只是一个虚构的概念。在这种情况下，我们无法知道虚拟机将按照什么顺序执行来自多个线程的代码。但是，具有多核技术的处理器已经存在了好几年。它们可以同时执行多个代码，使多线程成为现实。
- en: Threads
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程
- en: 'To create a thread, you can use the `Thread` object and then call the `Thread.start()`
    method to start its execution in parallel with respect to the current one. This
    way, the calling thread notifies the virtual machine that a new thread is needed,
    then the virtual machine creates a new thread and executes the bytecode related
    to the code inside the `Thread.run()` method. However, the default implementation
    of that method does nothing. It has to be pointed out that the direct call to
    the `Thread.run()` method instead of `Thread.start()` will call the method without
    creating a new thread, hence it''s just the wrong way to start a new thread. There
    are two ways to add code to the thread''s execution:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个线程，你可以使用`Thread`对象，然后调用`Thread.start()`方法以与当前线程并行启动其执行。这样，调用线程通知虚拟机需要一个新线程，然后虚拟机创建一个新线程并执行与`Thread.run()`方法内部代码相关的字节码。然而，该方法默认实现什么都不做。必须指出的是，直接调用`Thread.run()`方法而不是`Thread.start()`将在不创建新线程的情况下调用该方法，因此这是启动新线程的错误方式。有两种方法可以向线程的执行中添加代码：
- en: '**Extending the** `Thread` **class:** This way you create a class that extends
    the `Thread` class and then you need to override the `Thread.run()` method to
    specify what to execute when the `Thread.start()` is called:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展** `Thread` **类**：这种方式是创建一个扩展了`Thread`类的类，然后需要重写`Thread.run()`方法，以指定当调用`Thread.start()`时要执行的操作：'
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Implementing the** `Runnable` **interface**: This way, when the `Thread.start()`
    will be called, the code to be executed will be the `Runnable.run()` method one:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现** `Runnable` **接口**：这种方式，当调用`Thread.start()`时，要执行的代码将是`Runnable.run()`方法中的代码：'
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A thread is always started by another one, so there is always a special thread
    called main thread, and it is the thread where the application is first started
    and executed. Every time we launch a new thread, the execution of this main thread
    is split into two independent lines, as shown in *Figure 1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 线程总是由另一个线程启动，因此总有一个特殊的线程称为主线程，它是应用程序首次启动和执行的地方。每次我们启动一个新线程时，主线程的执行都会分成两个独立的线路，如图1*所示：
- en: '![Threads](img/4666_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![线程](img/4666_05_01.jpg)'
- en: 'Figure 1: Thread operations'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：线程操作
- en: 'In *Figure 1*, different operations on threads are shown:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1*中，展示了线程的不同操作：
- en: '**Thread-1** is just created and executed. It terminates and then it is destroyed
    because there is no more execution in the queue.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程1**只是被创建和执行。它结束后就会被销毁，因为没有更多的执行在队列中。'
- en: '**Thread-2**, as **Thread-1**, is created and executed, but during its lifetime
    is paused for an amount of time. This is possible using the `Thread.sleep()` method,
    specifying the milliseconds to wait. For that amount of time the thread has stopped
    waiting for the timeout to be reached and then it resumes its running operations.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程2**像**线程1**一样被创建和执行，但在其生命周期内会被暂停一段时间。这可以通过使用`Thread.sleep()`方法实现，指定要等待的毫秒数。在这段时间内，线程停止等待，直到达到超时时间，然后恢复运行操作。'
- en: '**Thread-3** is created and executed, and during its life, it starts a new
    thread and waits for it. This means that it cannot know how much time it should
    be waiting. That is why, if you do not know the time to wait, but you are waiting
    for another thread to finish its work, you can call the `Thread.join()` method.
    When the created thread has finished its task, **Thread-3** can resume its execution
    until its end. It is also possible to specify a timeout for the waiting; when
    it''s reached, **Thread-3** will be resumed anyway.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程-3** 被创建并执行，在其生命周期内，它启动了一个新线程并等待它。这意味着它不知道应该等待多久。这就是为什么，如果你不知道需要等待的时间，但需要等待另一个线程完成工作，你可以调用
    `Thread.join()` 方法。当创建的线程完成其任务后，**线程-3** 可以继续执行直到结束。还可以为等待指定一个超时时间；当达到这个时间，**线程-3**
    无论如何都会继续执行。'
- en: 'Java provides a priority system to threads. This means we can change a thread
    priority to let it execute faster or slower in respect to other threads. There
    are 10 levels of priority. Java also defines three constants for max, min, or
    normal priorities. We can use the following to change the thread priority:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java 为线程提供了优先级系统。这意味着我们可以改变线程的优先级，让它相对于其他线程执行得更快或更慢。有 10 个优先级级别。Java 还定义了最大、最小或正常优先级的三个常量。我们可以使用以下方法来改变线程优先级：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Multithreaded applications
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程应用程序
- en: Applications and systems that use multithreading need to face some problems
    that involve the developer and that force them to be careful about how objects
    are accessed from different threads.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多线程的应用程序和系统需要面对一些问题，这些问题涉及到开发者，并迫使他们小心处理不同线程如何访问对象的问题。
- en: The order of execution of multiple threads in an application is unpredictable.
    There are no guarantees which thread will be executed first or which one will
    finish first. Moreover, we are referring not only to blocks of code but to single
    lines of code as well. This is worrying in some critical situation where there
    is the need for a predefined sequence of accesses to a single object. Think about
    what could happen in a laundry if washers and dryers could work on loads with
    no predefined order. No problem if the washer starts first, but what if the dryer
    works first? Or worse, what if they can work alternatively for small periods of
    time? We want the load to be first washed and then dried. Then the load should
    be accessed by one at a time and in the right order. In other words, we need to
    prevent a thread to access the object while it's being accessed by another one.
    This means that the access to the load is synchronized.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中多个线程的执行顺序是不可预测的。无法保证哪个线程会先执行或先完成。而且，这里所指的不仅仅是代码块，还包括单行代码。在一些需要按预定顺序访问单一对象的临界情况下，这可能会引起担忧。想象一下，如果洗衣店的洗衣机和干衣机可以随意顺序地处理衣物，会出现什么情况。如果洗衣机先开始工作当然没问题，但如果干衣机先工作呢？或者更糟的是，如果它们交替进行短期工作会怎样？我们希望衣物先被洗净再烘干。也就是说，应该依次并按正确顺序访问这些负载。换句话说，我们需要防止当一个线程正在访问对象时，另一个线程也尝试访问。这意味着对负载的访问需要是同步的。
- en: Thread safety
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程安全
- en: The concept of thread safety is strictly related to the multithreaded environment.
    It refers to the safe execution of code that cannot change shared data in a concurrent
    way. While the reading access of an object may not be a problem for safety, the
    writing one is. A multithreaded application is thread safe if there are no concurrent
    operations on shared objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全的概念与多线程环境紧密相关。它指的是代码的安全执行，这种执行不会以并发方式改变共享数据。虽然对对象的读取访问可能不会对安全性构成问题，但写入访问却可能。如果一个多线程应用程序在共享对象上没有并发操作，那么它是线程安全的。
- en: 'Let''s see what this means in the Java framework. Java uses the concepts of
    monitor: every object has got a monitor, and the thread can lock and unlock it.
    The monitor makes sure that there is only one lock at a time. Any other lock attempt
    is queued. These operations are at a low-level code and can be done using special
    classes to call the lock, or the unlock on an object explicitly, but Java provides
    a particular keyword to do the same: `synchronized`. It can be used as a statement
    or to declare a synchronized method in its signature. In the first case, you need
    to specify what object needs to be locked and which code is affected by the lock:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在Java框架中意味着什么。Java使用监视器的概念：每个对象都有一个监视器，线程可以锁定和解锁它。监视器确保一次只有一个锁定。任何其他锁定尝试都会被排队。这些操作在低级代码中，可以使用特殊类来显式调用对象的锁定或解锁，但Java提供了一个特殊的关键字来完成同样的操作：`synchronized`。它可以作为语句使用，也可以用来声明同步方法的签名。在第一种情况下，你需要指定需要锁定哪个对象以及哪些代码受到锁的影响：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, the object cannot be accessed by other threads until the end of the
    execution of the code inside the brackets. Developers have to be aware of what
    is called deadlock. This situation happens when two or more Threads are locked
    waiting for each other, then those threads are blocked forever. This can happen
    using the `synchronized` keyword with cross-referenced locks; this condition has
    to be avoided.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在括号内的代码执行完毕之前，其他线程无法访问该对象。开发者必须了解所谓的死锁。当两个或更多线程相互锁定等待对方时，这种情况就会发生，然后这些线程将永远被阻塞。当使用带有交叉引用锁定的`synchronized`关键字时，可能会发生这种情况；这种条件必须被避免。
- en: 'The synchronized methods'' aim is to lock the object the method refers to:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同步方法的目标是锁定该方法引用的对象：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Android multithreading environment
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android多线程环境
- en: 'The Android platform inherits from Linux the process and threading system.
    The system generates, at least, one process for different applications, and every
    process has its threads. We have already talked about processes when dealing with
    memory. Let''s analyze what they are and how they are managed: this is helpful
    to understand how to handle application''s threads and components.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台从Linux继承了进程和线程系统。系统至少为不同的应用程序生成一个进程，每个进程都有其线程。在处理内存时我们已经讨论过进程。让我们分析它们是什么以及如何管理它们：这有助于理解如何处理应用程序的线程和组件。
- en: Processes
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程
- en: 'A **process** in Android is the container for main components such as activities,
    services, BroadcastReceivers, and ContentProviders. Hence, every process affects
    memory and, then, if the system is in a critical state with that, it starts destroying
    them. The system does this using a **Least Recently Used** (**LRU**) strategy:
    when needed, the least recently used object is destroyed first to free memory.
    A priority system is designed for this: a process can be in one of the following
    states during its lifetime:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，**进程**是主要组件（如活动、服务、广播接收器和内容提供者）的容器。因此，每个进程都会影响内存，如果系统在这方面处于关键状态，它会开始销毁这些进程。系统通过使用**最近最少使用**（**LRU**）策略来完成这个操作：在需要时，首先销毁最近最少使用的对象以释放内存。为此设计了一个优先级系统：在其生命周期中，进程可以是以下几种状态之一：
- en: '**Foreground**: A process is a foreground one if it is hosting a component
    that the user is interacting with. Then the process is at the top of the stack.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台**：如果一个进程正在托管用户正在与之交互的组件，那么它是前台进程。此时，该进程位于堆栈顶部。'
- en: '**Visible**: A process is visible if it is not a foreground one, but it can
    still be visible to the user.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见**：如果一个进程不是前台进程，但它仍然可以被用户看到，那么它是可见的。'
- en: '**Service**: This is a process that holds just-started services.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这是一个仅包含刚刚启动的服务进程。'
- en: '**Background**: This contains components no longer visible to the user.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台**：这包含不再对用户可见的组件。'
- en: '**Empty**: Such a process does not include any component. It''s used for caching
    purposes to speed up future application resumptions. It is at the bottom of the
    stack; then it is discarded first when the system reclaims memory.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空**：这样的进程不包括任何组件。它用于缓存目的，以加快未来应用程序的恢复速度。它位于堆栈底部；当系统回收内存时，它会首先被丢弃。'
- en: 'When an application is first started, a default process is created and all
    of its components are executed there. However, we can handle our application''s
    components forcing the creation of a new process for every one of them, or letting
    them join the same custom process. This can be done using a particular attribute
    inside the manifest file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序首次启动时，会创建一个默认进程，并且其所有组件都在该进程中执行。然而，我们可以通过在清单文件中使用特定属性来处理应用程序的组件，为每个组件强制创建新进程，或者让它们加入同一个自定义进程。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is just the need to specify the name of the process. When the name starts
    with a colon, the process is private to the application. When it starts with a
    lowercase, the process can be shared with other applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要指定进程的名称。当名称以冒号开头时，该进程是应用程序私有的。当以小写字母开头时，该进程可以与其他应用程序共享。
- en: Android application thread
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓应用程序线程
- en: 'What we discussed earlier in this chapter about threads, is the same in the
    Android system: when an application is started a new main thread is created, and
    its code is executed sequentially. From that thread, we can start new threads
    to do background operations. Any other thread created for an application is called
    **background thread** or **worker thread**. Another kind of thread is the binder
    one, used for communication between processes.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面讨论的关于线程的内容在Android系统中同样适用：当应用程序启动时，会创建一个新的主线程，并且其代码按顺序执行。从该线程，我们可以启动新线程来进行后台操作。为应用程序创建的任何其他线程都被称为**后台线程**或**工作线程**。另一种类型的线程是Binder线程，用于进程间的通信。
- en: The UI thread
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI线程
- en: It is critical to understand that the main thread is the only one that can manage
    the user interface. That is why it is also called UI thread. The UI thread's lifetime
    is the same as the application one's and the process's one because there is the
    need to have a thread able to let the user interact at any time. However, why
    is this such a strict requirement? Why isn't there a way to access views from
    outside the UI thread? The Android UI is not thread safe, and if a view could
    be accessed and modified by different threads, there might be unexpected behaviors
    and concurrent errors during the execution of our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 了解主线程是唯一可以管理用户界面的线程至关重要。这就是它也被称作UI线程的原因。UI线程的生命周期与应用程序和进程的生命周期相同，因为需要有一个线程能够随时让用户进行交互。然而，为什么会有这样一个严格的要求？为什么不能在UI线程外部访问视图呢？因为Android
    UI不是线程安全的，如果视图可以被不同的线程访问和修改，那么在应用程序执行期间可能会出现不可预期的行为和并发错误。
- en: 'This choice has been made to speed up the UI, because lock and unlock operations
    on an object are expensive and would have affected the Android user experience,
    just to let the developer access views from multiple threads. Then, the platform
    forces the access to the UI from just the main thread. This means that there is
    no need to synchronize views because they can be accessed only by the UI thread.
    So, it would be just a useless addition to the code structure. In fact, every
    time a background thread tries to access a view instance, the following exception
    is thrown:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这一选择是为了加快UI的响应速度，因为对对象进行加锁和解锁操作是昂贵的，这会影响到Android的用户体验，仅仅是为了让开发者能够从多个线程访问视图。因此，平台强制要求只能从主线程访问UI。这意味着无需同步视图，因为它们只能由UI线程访问。所以，在代码结构中加入同步是多余的。实际上，每当后台线程尝试访问视图实例时，都会抛出以下异常：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Worker threads
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作线程
- en: 'The other aspect to see in the Android platform is that the main thread is
    not only responsible for the UI, but it should only do that: any unnecessary UI
    operation must be done in different threads to have a fluid UI and, then, a good
    UX, that is the primary aim of worker threads. They are used to execute long-running
    operations that may affect the UI. More than this, those operations can freeze
    the UI until their ends if executed in the UI thread. This can cause what is also
    known as *Application Not Responding* dialog. When something is blocking the UI,
    the system shows the user this dialog saying that the application is not responding
    and asking the user if it should be closed. This is awful for user experience
    and a disaster for performance. We will see what kind of structures Android provides
    to reach the responsiveness we want for our application.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台中另一个需要注意的方面是，主线程不仅负责UI，而且应当只做这件事：任何不必要的UI操作都应该在不同的线程中完成，以保持UI的流畅，进而提供良好的用户体验，这是工作线程的主要目标。它们用于执行可能影响UI的长时间运行的操作。更重要的是，如果这些操作在UI线程中执行，它们可能会让UI冻结直到操作结束。这可能导致所谓的*应用无响应*对话框的出现。当UI被阻塞时，系统会向用户显示这个对话框，告知应用无响应，并询问用户是否关闭应用。这对用户体验来说非常糟糕，对性能来说则是灾难。我们将了解Android提供了哪些结构来达到我们希望应用拥有的响应性。
- en: The binder thread
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Binder线程
- en: When we need different threads from different processes to communicate, we cannot
    use the standard code, but we need some more advanced techniques to do so. The
    Android platform uses binder threads to let threads from different processes communicate.
    These kind of threads simplify this inter-process communication, as we will see
    in the following pages. Regardless, we do not need to deal with binder threads
    directly. There is a particular language that allows us to exchange data between
    processes, called **Android Interface Definition Language** (**AIDL**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要来自不同进程的不同线程进行通信时，我们不能使用标准代码，而需要一些更高级的技术来实现。Android平台使用Binder线程让来自不同进程的线程进行通信。这种线程简化了进程间通信，我们将在后续页面中看到这一点。不过，我们不需要直接处理Binder线程。有一种特定的语言允许我们在进程间交换数据，称为**Android接口定义语言**（**AIDL**）。
- en: Android thread messaging
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android线程消息传递
- en: 'Let''s have a look at the framework that handles communication between threads
    in an application. Some objects are involved in the message passing operation.
    They are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看处理应用中线程间通信的框架。一些对象参与了消息传递操作，它们如下：
- en: 'The `Message` or `Runnable` objects: They are the objects to communicate and
    send across threads.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`或`Runnable`对象：它们是用于线程间通信和发送的对象。'
- en: '`MessageQueue`: This is a container of ordered messages and runnables to be
    processed.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageQueue`：这是一个待处理的有序消息和可运行对象的容器。'
- en: '`Looper`: This is the object that dispatches the `Message` and `Runnable` objects
    to the right `Handler` object.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Looper`：这是将`Message`和`Runnable`对象分派给正确`Handler`对象的对象。'
- en: '`Handler`: This is the source of the `Message` and `Runnable` objects and the
    recipient of `Looper`. So, it has the dual responsibility of putting messages
    and runnables into `MessageQueue` and to execute them once the `Looper` sends
    them back. The magic is right here: the sending operation is made on the sending
    thread while the execution one is made in the receiving one. Hence, the communication
    between different threads.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Handler`：这是`Message`和`Runnable`对象的来源，也是`Looper`的接收者。因此，它具有双重责任，即将消息和可运行对象放入`MessageQueue`，并在`Looper`将它们送回时执行它们。这里的奥秘在于：发送操作是在发送线程上进行的，而执行操作是在接收线程上进行的。因此，实现了不同线程之间的通信。'
- en: '*Figure 2* shows what the primary relationships between those objects are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2*展示了这些对象之间主要的关系：'
- en: '![Android thread messaging](img/4666_05_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Android线程消息传递](img/4666_05_02.jpg)'
- en: 'Figure 2: The messaging process between two threads'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：两个线程之间的消息传递过程
- en: 'Not all threads have `Looper`. On the contrary, just the main thread has its
    own `Looper`. This means that if you want to let two threads communicate, a `Looper`
    object needs to be assigned to that communication and `MessageQueue` needs to
    be created. This can be done by calling the static `Looper.prepare()` method inside
    `Thread.run()` one. Now that we have `MessageQueue` and `Looper`, we need this
    `Looper` to start dispatching messages and runnables to the `Handler`. This can
    be done by calling the static `Looper.loop()` method. The following is a code
    snippet to show what is said:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有线程都有`Looper`。相反，只有主线程有自己的`Looper`。这意味着如果你想让两个线程进行通信，需要为该通信分配一个`Looper`对象并创建`MessageQueue`。这可以通过在`Thread.run()`中调用静态的`Looper.prepare()`方法来完成。现在我们有了`MessageQueue`和`Looper`，我们需要这个`Looper`开始向`Handler`分派消息和可运行对象。这可以通过调用静态的`Looper.loop()`方法来完成。以下是展示所说内容的代码片段：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s have a look at how the `Handler` object works and can send messages
    and runnables. The `Handler` object needs to be associated with a `Looper` from
    construction. Then the empty `Handler` constructor will get the association with
    the `Looper` of the thread in which it''s created. Then the following instantiation
    of the handler is possible only if it is done in the main thread or after calling
    the `Looper.prepare()` method of the background thread:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Handler`对象是如何工作的，以及它可以如何发送消息和可运行对象。`Handler`对象在构造时需要与一个`Looper`相关联。然后空的`Handler`构造函数将与创建它的线程的`Looper`关联。以下只有在主线程中或调用后台线程的`Looper.prepare()`方法之后，才能实例化处理器：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That is why, if you do not do so, a `RuntimeException` will be thrown, and
    the application will crash with the following message in the stack trace:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么如果不这样做，将会抛出`RuntimeException`，应用程序将在堆栈跟踪中显示以下消息后崩溃：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From an operation point of view, the `Handler` uses the following methods to
    send messages and runnables to `MessageQueue`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作的角度来看，`Handler`通过以下方法将消息和可运行对象发送到`MessageQueue`：
- en: '`post(Runnable r)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post(Runnable r)`'
- en: '`sendEmptyMessage(int what)`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendEmptyMessage(int what)`'
- en: '`sendMessage(Message m)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendMessage(Message m)`'
- en: 'All three have the possibility to specify a particular time for execution or
    a delay and the `Handler` can remove them from the `MessageQueue` using the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个都有指定特定执行时间或延迟的可能性，而`Handler`可以使用以下方法从`MessageQueue`中移除它们：
- en: '`removeCallbacks(Runnable r)`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeCallbacks(Runnable r)`'
- en: '`removeMessages(int what)`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeMessages(int what)`'
- en: '`removeCallbacksAndMessages(Object token)`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeCallbacksAndMessages(Object token)`'
- en: While the `Runnable` object contains the code to be executed, messages should
    be handled by the `Handler` using the `Handler.handleMessage()` method, which
    provides the `Message` itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Runnable`对象包含要执行的代码时，消息应该由`Handler`使用`Handler.handleMessage()`方法处理，该方法提供了`Message`本身。
- en: Best practices
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: With the threading concepts in mind, let's go through the code to understand
    how Google has improved the multithreading framework inherited from Java and which
    API the Android platform provides to the developer to deal with the main problem
    of separation between UI thread and worker threads. We will also see what problems
    may derive from this and which solutions Android introduced during its development.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 携带线程概念，让我们通过代码了解谷歌是如何改进从Java继承的多线程框架的，以及Android平台为开发者提供了哪些API来处理UI线程与工作线程之间的主要问题。我们还将看到由此可能产生的问题以及Android在其开发过程中引入的解决方案。
- en: We will then deal with advanced techniques to manage main components and the
    AIDL and messenger for inter-process communications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将处理高级技术以管理主要组件和AIDL以及跨进程通信的Messenger。
- en: Threads
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: The standard Java threads are the base for the other frameworks we will see
    in the following pages. They wrap threads or runnables to achieve some platform
    requirements like the communication with the UI thread. They are still the lightweight
    solution for brief background operations that don't need to be notified to the
    UI thread.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Java线程是我们将在以下页面中看到的其他框架的基础。它们包装线程或可运行对象以实现一些平台要求，如与UI线程的通信。对于不需要通知UI线程的简短后台操作，它们仍然是轻量级的解决方案。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a general rule to observe, when using threads, avoid the synchronization
    inside loops because acquiring and releasing a lock is an expensive operation.
    Then, this can lead to increased timings and useless consumption of resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用线程时需要遵守的一般规则，避免在循环内进行同步，因为获取和释放锁是一个昂贵的操作。然后，这可能导致时间增加和资源的无谓消耗。
- en: HandlerThread
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HandlerThread
- en: 'In typical application development, we deal with threads and handlers, and
    sometimes we forget to prepare what is needed to work with messaging on background
    threads. This is the reason why Android provides a helpful `Thread` subclass that
    wraps the thread itself, the `Looper`, and the `MessageQueue`. This is the `HandlerThread`
    that prepares the `Looper` by itself. Then the developer does not need to do it.
    Moreover, if more initializations are required, we can do them in the `HandlerThread.onLooperPrepared()`
    method: this way we know that the `Looper.prepare()` has already been called and
    the result of `HandlerThread.getLooper()` won''t be null.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的应用程序开发中，我们处理线程和处理器，有时我们会忘记准备在后台线程上处理消息所需的内容。这就是为什么Android提供了一个有用的`Thread`子类，它包装了线程本身、`Looper`和`MessageQueue`。这就是`HandlerThread`，它会自行准备`Looper`。这样开发者就不需要手动准备。此外，如果需要更多的初始化，我们可以在`HandlerThread.onLooperPrepared()`方法中进行：这样我们就知道`Looper.prepare()`已经被调用，且`HandlerThread.getLooper()`的返回结果不会为null。
- en: 'Let''s go through the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看以下代码片段：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unlike a classic thread, `HandlerThread` can be reused because it remains active
    until the `HandlerThread.quit()` method is called. This particular method terminates
    `Looper` that cannot process messages and runnables anymore. Then any further
    `Message` or `Runnable` sent will fail, and the `MessageQueue` is emptied. That
    method will force the pending messages and runnables to quit, and they will not
    be dispatched to the `Handler`. To ensure that no pending messages will be terminated
    and dispatched, use the `HandlerThread.quitSafely()` method. When one of those
    methods is called, the `HandlerThread` object cannot be used anymore, as the thread
    is at the end of its execution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典线程不同，`HandlerThread`可以被复用，因为它会保持活动状态，直到调用`HandlerThread.quit()`方法。这个特殊的方法会终止`Looper`，使其无法再处理消息和可运行对象。之后发送的任何`Message`或`Runnable`都会失败，`MessageQueue`会被清空。该方法将强制挂起的消息和可运行对象退出，它们不会再被分派给`Handler`。为确保没有挂起的消息被终止和分派，请使用`HandlerThread.quitSafely()`方法。当调用这些方法之一时，`HandlerThread`对象将不能再使用，因为线程已经执行完毕。
- en: When to use
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用
- en: The `HandlerThread` keeps a thread alive with `Looper` and `MessageQueue`. Moreover,
    it provides a controlled message processing. Hence, this is good to use when we
    need an always available thread to use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerThread`通过`Looper`和`MessageQueue`保持线程存活，并提供可控的消息处理。因此，当我们需要一个始终可用的线程时，使用它是很好的选择。'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When dealing with multiple threads and messaging between them, a `HandlerThread`
    is a good choice to delegate the `Looper` management to. It can also be reused
    for multiple messages and runnables. Remember, however, to quit when it is not
    needed anymore to free resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个线程之间的消息传递时，`HandlerThread`是一个很好的选择，可以将`Looper`的管理委托给它。它还可以被复用于多个消息和可运行对象。但是，请记住，在不再需要时退出，以释放资源。
- en: AsyncTask
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AsyncTask
- en: As discussed earlier, the primary goal as a developer from a multithreading
    perspective is to free the UI thread from operations, as much as possible, that
    could be executed in a parallel thread to maintain a fluid user interface. The
    primary tool available to the developer from the beginning of the platform is
    `AsyncTask`. It is not a threading framework, but just a helper class used to
    let worker threads communicate with the UI thread.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如先前讨论的，从多线程的角度来看，开发者主要的目标是尽可能让UI线程从可以在并行线程中执行的操作中解脱出来，以保持用户界面的流畅。从一开始，开发者可以使用的主要工具就是`AsyncTask`。它不是一个线程框架，只是一个辅助类，用于让工作线程与UI线程通信。
- en: 'The `AsyncTask` object can be started only one time, just like the `Thread`
    one. It can be created, loaded, and started from the UI thread. An `AsyncTask`
    subclass can override the following methods:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`对象只能启动一次，就像`Thread`一样。它可以在UI线程中创建、加载和启动。`AsyncTask`的子类可以覆盖以下方法：'
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this in mind, let's go through the explanation of what this means.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们了解这意味着什么。
- en: Methods
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'Among the preceding methods, only the `AsyncTask.doInBackground()` one is abstract
    and executed in the worker thread. The other ones can be overridden if needed
    and have the following purposes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的方法中，只有`AsyncTask.doInBackground()`是抽象的，并在工作线程中执行。其他方法如果需要可以覆盖，并具有以下目的：
- en: '`onPreExecute()`: This is called before starting the background work. It is
    used to notify the user that something is happening in the background.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPreExecute()`: 在开始后台工作之前调用。它用于通知用户后台正在发生某些操作。'
- en: '`onProgressUpdate()`: This is used to update the UI after some updates from
    the worker thread.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onProgressUpdate()`: 这用于在从工作线程收到一些更新后更新UI。'
- en: '`onPostExecute()`: This handles the result coming from the worker thread.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPostExecute()`: 这处理来自工作线程的结果。'
- en: '`onCancelled()`: This is used to handle the `AsyncTask` cancelation on the
    UI thread.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCancelled()`: 这用于在UI线程上处理`AsyncTask`的取消。'
- en: Generics parameters
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型参数
- en: 'The generics in the class signature are needed to specify the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类签名中的泛型是为了指定以下内容：
- en: '`Params`: This is the type of input expected by the `AsyncTask.doInBackground()`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Params`: 这是`AsyncTask.doInBackground()`期望的输入类型。'
- en: '`Progress`: This is the type used to notify of an update to `AsyncTask.onProgressUpdate()`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Progress`: 这是用来通知`AsyncTask.onProgressUpdate()`更新的类型。'
- en: '`Result`: This is the result of the `AsyncTask`, `doInBackground()` method,
    and the input of the `AsyncTask.onPostExecute()`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result`: 这是`AsyncTask`的`doInBackground()`方法的返回结果，也是`AsyncTask.onPostExecute()`的输入。'
- en: States management
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态管理
- en: 'An `AsyncTask` object can pass through three subsequent `AsyncTask.Status`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`AsyncTask`对象可以经历三个连续的`AsyncTask.Status`：
- en: '`PENDING`: Before starting'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PENDING`: 开始前'
- en: '`RUNNING`: While executing'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNING`: 执行中'
- en: '`FINISHED`: After `AsyncTask.onPostExecute()` is complete'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FINISHED`: 在`AsyncTask.onPostExecute()`完成之后'
- en: Executor
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Executor
- en: 'Every time `AsyncTask` needs to be executed, an `Executor` object must be supplied.
    There are two types of default execution for `AsyncTask`. They are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要执行`AsyncTask`时，都必须提供一个`Executor`对象。`AsyncTask`有两种默认执行方式。如下所示：
- en: '`SERIAL_EXECUTOR`: This completes all the tasks one at a time and in sequential
    order'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIAL_EXECUTOR`: 这会一次完成所有任务，并按照顺序执行。'
- en: '`THREAD_POOL_EXECUTOR`: This performs tasks in parallel'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREAD_POOL_EXECUTOR`: 这会并行执行任务。'
- en: 'There are three methods to start the execution of `AsyncTask`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以启动`AsyncTask`的执行：
- en: '`execute(Params)`: This adds the task to the queue of the `SERIAL_EXECUTOR`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute(Params)`: 这会将任务添加到`SERIAL_EXECUTOR`的队列中。'
- en: '`execute(Runnable)`: This is a static method to execute a `Runnable` object
    with the `SERIAL_EXECUTOR`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute(Runnable)`: 这是一个静态方法，用于使用`SERIAL_EXECUTOR`执行`Runnable`对象。'
- en: '`executeOnExecutor(Executor, Params)`: This allows you to specify the `Executor`
    object you want to use'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executeOnExecutor(Executor, Params)`: 这允许你指定想要使用的`Executor`对象。'
- en: 'This is the crucial part for performance because the execution of the worker
    thread depends on the particular executor used; the serial execution can lead
    to unexpected delays if the queue is full and the tasks are long-running ones.
    The default parallel execution, on the other hand, is global: hence, the threads
    inside the thread pool are shared between multiple applications. As an alternative,
    we can create our executor to be used in the `AsyncTask.executeOnExecutor()` method.
    To do this, there is a `Factory` class that creates an executor. This class is
    called `Executors`, and its methods are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是性能的关键部分，因为工作线程的执行取决于所使用的特定执行器；如果队列已满且任务运行时间较长，串行执行可能会导致意外的延迟。另一方面，默认的并行执行是全局的：因此，线程池中的线程在多个应用程序之间共享。作为替代方案，我们可以创建自己的执行器，以在`AsyncTask.executeOnExecutor()`方法中使用。为此，有一个`Factory`类可以创建执行器。这个类叫做`Executors`，其方法如下：
- en: '`newCachedThreadPool()`: This checks, first if there are available threads
    to be used, then, if there aren''t, it creates a new one and caches it for future
    requests'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`: 这首先检查是否有可用的线程，如果没有，它会创建一个新的线程并将其缓存以供未来请求使用。'
- en: '`newFixedThreadPool()`: This is the same as the cached case, but with a fixed
    number of threads'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool()`: 这与缓存情况相同，但线程数量是固定的。'
- en: '`newScheduledThreadPool()`: This creates an executor that can schedule the
    threads to execute the task at a defined time'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newScheduledThreadPool()`: 这会创建一个可以安排线程在定义的时间执行任务的执行器。'
- en: '`newSingleThreadExecutor()`: This creates a single thread executor'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`: 这会创建一个单线程执行器'
- en: '`newSingleThreadScheduledExecutor()`: This creates an executor with a single
    thread that can be scheduled to execute at a defined time'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`: 这会创建一个具有单个线程的执行器，可以安排在定义的时间执行。'
- en: 'This way, we can create and reuse our private thread pool as a singleton or
    in the `Application` class. For example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以创建并重用私有的线程池，作为单例或者在`Application`类中使用。例如：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When to use
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用时机
- en: 'The aim of `AsyncTask` is to let the worker thread communicate with the UI
    one. Then, if our background operation does not need to notify the user, or, in
    general, doesn''t need to update the UI, then there is no need to use `AsyncTask`:
    a thread is enough and more performant than the `AsyncTask`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`的目标是让工作线程与UI线程通信。那么，如果我们的后台操作不需要通知用户，或者一般而言，不需要更新UI，那么就没有必要使用`AsyncTask`：一个线程就足够了，而且比`AsyncTask`性能更好。'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using `AsyncTask` with all void parameters or you are implementing
    just the `AsyncTask.doInBackground()` method, then you do not need an `AsyncTask`.
    Change the implementation to a classical thread because the UI is not changed
    by `AsyncTask`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是带有所有void参数的`AsyncTask`，或者只实现了`AsyncTask.doInBackground()`方法，那么你不需要`AsyncTask`。将实现更改为经典线程，因为UI不会通过`AsyncTask`改变。
- en: Besides this case, the `AsyncTask` implementation faces a couple of problems
    due to `Activity` lifecycle. It is used many times as an inner class inside the
    `Activity`. Then, the memory leak, as discussed in [Chapter 4](ch04.html "Chapter 4. Memory"),
    *Memory* is so easy to occur. Apart from that, it is used inside an `Activity,`
    and when the instance of the `Activity` is destroyed due to a configuration change
    the `AsyncTask` is still active and operating, but the UI references are no longer
    available. Then, when the `Activity` is destroyed and recreated, the result data
    from the `AsyncTask` needs to be cached somewhere. Otherwise, the `AsyncTask`
    must be executed again.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种情况，`AsyncTask`实现由于`Activity`生命周期面临一些问题。它经常作为`Activity`内的内部类使用。然后，如[第4章](ch04.html
    "第4章. 内存") *Memory* 所讨论的，内存泄漏很容易发生。除此之外，它在`Activity`内部使用，当由于配置更改而销毁`Activity`的实例时，`AsyncTask`仍然活跃并运行，但UI引用不再可用。然后，当`Activity`被销毁并重新创建时，需要将`AsyncTask`的结果数据缓存到某处。否则，必须再次执行`AsyncTask`。
- en: Loaders
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Loaders
- en: Knowing the limits of an `AsyncTask`, Android started providing the loader framework
    to have a valid alternative to the `AsyncTask` in a couple of situations. Let's
    have a look at what the loader offers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到`AsyncTask`的限制，Android开始提供加载器框架，在某些情况下作为`AsyncTask`的有效替代。让我们看看加载器提供了什么。
- en: 'They handle asynchronous operations useful to retrieve data from a remote server,
    for example, and, then, they trigger callbacks to notify the caller that new data
    is available. The callers may be activities or fragments. Loaders are life cycle
    independent: it does not matter if the `Activity` or the `Fragment` is destroyed
    and recreated after a configuration changed. It still operates in the background
    and notifies the newly created instance of `Activity` or `Fragment`. Moreover,
    if the background work is completed before the configuration change, the loader
    caches the data resulting from the background to notify the new instance anyway.
    This particular feature of activity life cycle independence means that there is
    no connection between the loader and activity itself: hence, the loader uses the
    application context, reducing the risk of an activity leak.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它们处理异步操作，例如从远程服务器检索数据，然后触发回调通知调用者有新数据可用。调用者可能是活动或片段。加载器与生命周期无关：无论`Activity`或`Fragment`在配置更改后是否被销毁并重新创建，它仍然在后台运行并通知新创建的`Activity`或`Fragment`实例。此外，如果在配置更改之前后台工作已完成，加载器将缓存后台产生的数据，无论如何通知新实例。这种与活动生命周期无关的特殊功能意味着加载器与活动本身之间没有连接：因此，加载器使用应用程序上下文，降低了活动泄漏的风险。
- en: LoaderManager
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoaderManager
- en: 'Every `Activity` or `Fragment` has one and only one `LoaderManager`. It can
    be retrieved using the following method of `Activity` and `Fragment`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Activity`或`Fragment`都有一个且仅有一个`LoaderManager`。可以通过以下`Activity`和`Fragment`的方法来获取：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A `LoaderManager` class deals with some operations on loaders, as described
    in the following methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoaderManager`类处理一些关于加载器的操作，如下方法所述：'
- en: '`initLoader(int id, Bundle args, LoaderCallbacks<D> cb)`: This initializes
    a loader assigning it an ID, passing extra arguments, and specifying how to handle
    the callback. If a loader with the same ID already exists, it is used instead
    of creating another one.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initLoader(int id, Bundle args, LoaderCallbacks<D> cb)`：这初始化一个加载器，为其分配一个ID，传递额外的参数，并指定如何处理回调。如果已经存在具有相同ID的加载器，它将被使用，而不是创建另一个。'
- en: '`restartLoader(int id, Bundle args, LoaderCallbacks<D> cb)`: This starts a
    loader again or creates a new one if no loaders are associated with the specified
    ID, passing the extra arguments and the callback instance to handle the response.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restartLoader(int id, Bundle args, LoaderCallbacks<D> cb)`：这将会重新启动一个加载器，如果指定的ID没有关联的加载器，则创建一个新的加载器，传递额外的参数和回调实例以处理响应。'
- en: '`getLoader(int id)`: This returns the loader with the specified ID.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLoader(int id)`：这返回具有指定ID的加载器。'
- en: '`destroyLoader(int id)`: This stops the loader with the specified ID.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroyLoader(int id)`：这停止具有指定ID的加载器。'
- en: LoaderCallbacks<D>
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoaderCallbacks<D>
- en: 'The callback interface used to handle the result of the loader operation is
    made by the following methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理加载器操作结果的回调接口是由以下方法组成的：
- en: '`onCreateLoader(int id, Bundle args)`: This returns a new loader'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateLoader(int id, Bundle args)`：这返回一个新的加载器。'
- en: '`onLoadFinished(Loader<D> loader, D data)`: This notifies that the loader finished
    its background operation and then passes the result'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoadFinished(Loader<D> loader, D data)`：这通知加载器完成了后台操作，并将结果传递出去。'
- en: '`onLoaderReset(Loader<D> loader)`: This notifies the loader has been reset
    and then data is no longer available'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoaderReset(Loader<D> loader)`：这通知加载器已被重置，数据不再可用。'
- en: Provided loaders
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供的加载器
- en: When using loaders, we need to use `CursorLoader` or create subclasses of loader
    or some other loader specializations like `AsyncTaskLoader`. Let's see these options
    and the differences.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加载器时，我们需要使用`CursorLoader`或创建加载器的子类或其他一些加载器专业化，如`AsyncTaskLoader`。让我们看看这些选项和区别。
- en: AsyncTaskLoader
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AsyncTaskLoader
- en: 'This loader is used to do background work using a wrapped `AsyncTask` that
    handles, as we know, the data passing through the worker thread and the UI thread.
    However, it''s an abstract class because we need to override the `AsyncTaskLoader.loadInBackground()`
    method to tell the class which operations have to be executed inside the worker
    thread:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加载器用于使用包装的`AsyncTask`进行后台工作，我们知道，它处理通过工作者线程和UI线程的数据传递。然而，它是一个抽象类，因为我们需要覆盖`AsyncTaskLoader.loadInBackground()`方法，告诉类哪些操作必须在工作者线程内执行：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, `AsyncTaskLoader` can be used for every background operation needed by
    an `Activity` or a `Fragment` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`AsyncTaskLoader`可以用于`Activity`或`Fragment`类所需的每个后台操作。
- en: CursorLoader
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CursorLoader
- en: 'CursorLoader is a specialized tool to retrieve data from a `ContentProvider`,
    hence, if you do not have a `ContentProvider` to store data, this is not the right
    choice of loader to use. However, it is an implementation of the `AsyncTaskLoader<Cursor>`.
    Then, it is helpful to query the `ContentProvider` in a worker thread without
    affecting the UI. It''s designed for the use with `CursorAdapter` or `SimpleCursorAdapter`,
    to simplify the development of the activity: look, for example, at the following
    snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: CursorLoader是一个专门用于从`ContentProvider`检索数据的工具，因此，如果没有`ContentProvider`来存储数据，这不是使用加载器的正确选择。然而，它是`AsyncTaskLoader<Cursor>`的一个实现。那么，它有助于在工作者线程中查询`ContentProvider`，而不会影响UI。它旨在与`CursorAdapter`或`SimpleCursorAdapter`一起使用，以简化活动开发：例如，看看以下代码段：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When to use
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用时机
- en: The loader framework improves the features of an `AsyncTask` allowing us not
    to worry about the activities or fragment life cycles and caching data for us.
    For these reasons, it is a valid alternative to the use of `AsyncTask`. Nevertheless,
    multiple loader management is easier than the `AsyncTask` one. Then, its specialization
    in the cursor case is easy to use.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器框架增强了`AsyncTask`的功能，使我们不必担心活动或片段的生命周期，并为我们缓存数据。因此，它是使用`AsyncTask`的有效替代方案。然而，加载器的管理比`AsyncTask`更容易。在光标情况下的专业化也易于使用。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we need to fetch data, an `AsyncTaskLoader` is a right choice: it offers
    the same features of an `AsyncTask` plus the activity life cycle independence
    and data caching. Hence the performance improvement regarding responsiveness and
    stability of the application.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要获取数据时，`AsyncTaskLoader`是一个正确的选择：它提供了`AsyncTask`的相同功能，加上活动生命周期的独立性和数据缓存。因此，在应用程序的响应性和稳定性方面有性能提升。
- en: Services
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: A service is one of the main components the Android platform provides and then
    you need to declare it inside the manifest file. Contrary to the activity, a service
    has no UI to handle. Then, its primary aim is to execute long-running operations
    in the background. However, do we need another way to create and control worker
    threads?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是Android平台提供的主要组件之一，因此您需要在清单文件中声明它。与活动不同，服务没有UI要处理。然后，其主要目的是在后台执行长时间运行的操作。但是，我们需要另一种创建和控制工作线程的方法吗？
- en: 'Think about all the other ways we saw in the previous pages: they depend on
    the activity life cycle of the UI update. Moreover, here comes the service. It
    is a separate object that can be used in the background with no restriction and
    without the user interaction and, then, without user interface. Hence, extensive
    operations that don''t need the interaction with the user can be executed in a
    service.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们在前面几页看到的所有其他方式：它们依赖于UI更新的活动生命周期。而且，这里出现了服务。它是一个独立的对象，可以在没有限制和用户交互的情况下在后台使用，然后，不需要用户界面。因此，不需要与用户交互的大量操作可以在服务中执行。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The most important thing to remember when dealing with services is that they
    are not threads and, on the contrary, they are executed on the UI thread by default.
    Hence, never start a long-running operation in a service without creating a new
    thread: it would affect all the UI of the application. Then an *Application Not
    Responding* dialog could be showed to the user while doing something different
    on the UI.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理服务时需要记住的最重要的事情是，它们不是线程，相反，它们默认在UI线程上执行。因此，在创建新线程之前，永远不要在服务中启动长时间运行的操作：它会影响应用程序的所有UI。然后，当用户在UI上执行其他操作时，可能会显示一个*应用程序无响应*对话框。
- en: Life cycle
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'As an activity, a service has two methods to identify its creation and destruction.
    Moreover, those methods have the same name as for the activity:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为活动，服务有两个方法来标识其创建和销毁。此外，这些方法与活动的名称相同：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Service` class is abstract, and the only method to be overridden is the
    `Service.onBind()` one. However, what is it for? Let''s define two types of service
    from the life cycle point of view:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service`类是抽象的，唯一需要覆盖的方法是`Service.onBind()`。但是，它是用来做什么的呢？让我们从生命周期的角度定义两种类型的服务：'
- en: '**Started Service**: The service is started using the `Context.startService()`
    method or using an `Intent` and it is active until it has called the `Context.stopService()`
    or the `Service.stopSelf()` method.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动服务**：使用`Context.startService()`方法或`Intent`启动服务，并且它将一直保持活跃状态，直到调用了`Context.stopService()`或`Service.stopSelf()`方法。'
- en: '**Bound Service**: The service is started when another component asks for a
    binding with it and it remains active until it is bound to at least one external
    component. When no longer bound to other components, it is destroyed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定服务**：当另一个组件请求与它绑定时，服务开始启动，并且只要至少有一个外部组件与之绑定，它就会保持活跃状态。当不再绑定到其他组件时，它将被销毁。'
- en: There is not a clear separation between the two because a started service can
    be bound at any point in its lifetime. However, it will still be active after
    all of the other bound components are gone.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于启动的服务在其生命周期中的任何时刻都可能被绑定，因此两者之间没有明确的界限。然而，即使所有其他绑定的组件都消失了，它仍然会保持活跃状态。
- en: Started Service
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动服务
- en: 'When we want to create a Started Service, we have to override the `Service.onBind()`
    method anyway because it is an abstract one. Hence, if we do not want it to be
    bound, we can leave it, returning null. We will see next what to do to bind a
    service. Instead, what we need to override, is the `Service.onStartCommand()`
    method. This has three parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建一个启动服务时，无论如何都必须覆盖`Service.onBind()`方法，因为它是一个抽象方法。因此，如果我们不希望它被绑定，可以将其留空，返回null。接下来我们将看到如何绑定服务。相反，我们需要覆盖的是`Service.onStartCommand()`方法。这个方法有三个参数：
- en: '`Intent intent`: This is the way to provide extra information to the service
    when calling the `Context.startService()` method.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent intent`：这是在调用`Context.startService()`方法时向服务提供额外信息的方式。'
- en: '`int flags`: This is used to determine what kind of intent is passed. We will
    see it later in this section.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int flags`：用于确定传递的意图类型。我们将在本节后面看到它。'
- en: '`int startId`: This is the ID of the caller. It can be used to know if it is
    started again from the same component or restarted after termination.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int startId`：这是调用者的ID。它可以用来判断是否从同一组件重新启动或终止后重新启动。'
- en: 'We already know that the system can start destroying processes with a policy
    based on the process''s priority. In this case, our service can be terminated
    and the background operation it was executing would not be completed. This is
    the reason the `Service.onStartCommand()` method needs to return an integer value.
    This way we can specify the way we want the system to deal with unexpected termination
    of the service itself. The possible values to be returned by the method are as
    follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道系统可以根据进程优先级基于策略开始销毁进程。在这种情况下，我们的服务可能会被终止，它正在执行的背景操作可能不会完成。这就是为什么`Service.onStartCommand()`方法需要返回一个整数值的原因。这样我们可以指定我们希望系统处理服务本身意外终止的方式。该方法可能返回的值如下：
- en: '`START_STICKY`: Using this, the service will be created again after a termination
    occurs. To be recreated, the system sends it a null `Intent`. Then, check if it
    is null in the `Service.onStartCommand()` method before using it. Consider using
    it when the service needs to be restarted after an unexpected termination to complete
    some work.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_STICKY`：使用此标志，在终止后服务将被重新创建。为了重新创建，系统会发送一个null `Intent`。在`Service.onStartCommand()`方法中使用它之前，检查是否为null。当服务在意外终止后需要重新启动以完成一些工作时，考虑使用它。'
- en: '`START_NOT_STICKY`: The service will not be recreated until a new `Intent`
    class, delivered by a normal `Context.startService()` method is called or a new
    `Intent` matches the `Service IntentFilter`. Then, no null intents will be triggered
    to the method. This is to be used when there is no need to start the service again
    to complete some work when it is terminated unexpectedly.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_NOT_STICKY`：除非通过正常的`Context.startService()`方法调用新的`Intent`类或新的`Intent`与`Service
    IntentFilter`匹配，否则服务在意外终止后不会被重新创建。然后，不会有null意图被触发到方法中。当服务在意外终止时不需要重新启动以完成某些工作时使用。'
- en: '`START_REDELIVER_INTENT`: When the service is terminated for a different cause
    than the call to the `Service.stopSelf()` method or the `Context.stopService()`
    one, then, the service is restarted using the last intent used to call the `Service.onStartCommand()`
    method again. To be used when we need to know which operation was interrupted
    with the termination.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_REDELIVER_INTENT`：当服务因调用`Service.stopSelf()`方法或`Context.stopService()`以外的其他原因而终止时，服务将使用最后一次调用`Service.onStartCommand()`方法的意图重新启动。当我们需要知道哪个操作因终止而中断时使用。'
- en: 'Depending on the strategy adopted to restart the service using the preceding
    constants, the `Intent` passed as a parameter of the `Service.onStartCommand()`
    can have a different meaning. Let''s look at the possible values:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 根据采用重启服务的策略使用前面的常量，作为`Service.onStartCommand()`参数传递的`Intent`可能有不同的含义。让我们看看可能的值：
- en: '`0`: This is the default value, and the intent is just passed generally, as
    the first time.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这是默认值，意图通常像第一次一样传递。'
- en: '`START_FLAG_REDELIVERY`: The `Intent` class has been redelivered due to the
    redelivery strategy. It has already been given previously, but after having handled
    that, the service has been stopped unexpectedly. Hence, the intent is delivered
    again, and this flag is useful for knowing this fact.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_FLAG_REDELIVERY`：由于重传策略，`Intent`类已被重新传递。它之前已经被赋予过，但在处理之后，服务意外停止了。因此，意图再次传递，此标志有助于了解这一事实。'
- en: '`START_FLAG_RETRY`: The intent was about to be delivered to the service, but
    it has been terminated and, then, the intent is delivered again with this flag.
    This time, we can know that the service has never processed the intent, contrary
    to the previous case.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_FLAG_RETRY`：意图即将传递给服务，但已被终止，然后再次传递此标志的意图。这一次，我们可以知道服务从未处理过意图，与之前的情况相反。'
- en: 'Let''s see an example of implementation of a Started Service. Remember that
    it''s executed on the UI thread and, then, we need to create the necessary threads
    to run long-running operations without affecting the UI and without forgetting
    the lesson learned from [Chapter 4](ch04.html "Chapter 4. Memory"), *Memory* about
    inner classes and memory implications:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个启动服务的实现示例。记住它是在UI线程上执行的，然后我们需要创建必要的线程来运行长时间运行的操作，以不影响UI，并且不要忘记从[第4章](ch04.html
    "第4章.内存")，*内存*关于内部类和内存影响的教训：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we used a classic thread, but for communications between different
    threads, we could have used a `Handler` or `HandlerThread` object or the `Executor`
    framework or an `AsyncTask`, depending on our needs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了经典线程，但对于不同线程之间的通信，我们可以根据需要使用`Handler`或`HandlerThread`对象或`Executor`框架或`AsyncTask`。
- en: When to use
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: A Started Service is helpful to handle multiple simultaneous requests. You will
    have to design your multithreading strategy because it's executed in the UI thread,
    but it is the more flexible component because of this from a threading perspective.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 启动的服务有助于处理多个同时请求。你将不得不设计你的多线程策略，因为它是在UI线程中执行的，但从线程的角度来看，这是最灵活的组件。
- en: Bound Service
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定服务
- en: While talking about Bound Service, we need to define a client side and a server
    one. The service is the server of this client server architecture, while an activity
    or another service is the client. Hence, we need an interface to let them communicate
    properly. The platform provides the `Context.bindService()` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到绑定服务时，我们需要定义一个客户端和一个服务器端。服务是这种客户端服务器架构中的服务器，而活动或其他服务则是客户端。因此，我们需要一个接口来让它们正确地通信。平台提供了`Context.bindService()`方法。
- en: As mentioned, the Bound Service holds a reference to the clients and, when no
    more clients are referenced, the service is automatically terminated. This behavior
    is helpful when we need to share a background operation between multiple activities
    without the need to close the service because it is terminated automatically.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，绑定服务持有对客户端的引用，当不再有客户端被引用时，服务会自动终止。当我们需要在多个活动之间共享后台操作，而无需关闭服务时，这种行为非常有用，因为它会自动终止。
- en: 'The Bound Service life cycle from a server client perspective is made of just
    two methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器客户端的角度来看，绑定服务生命周期仅由两个方法组成：
- en: '`Service.onBind()`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service.onBind()`'
- en: '`Service.onUnbind()`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service.onUnbind()`'
- en: Contrary to popular belief, the preceding methods are not called every time
    the service is bound to a client or unbound to the same; the `Service.onBind()`
    method is called just for the first client and the `Service.onUnbind()` method
    is called when the last client is unbound. Hence, these methods are used to initialize
    and release the `Service` objects or variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与普遍看法相反，这些方法并不是每次服务绑定到客户端或从同一客户端解绑时都会被调用；`Service.onBind()`方法只在第一个客户端时被调用，而`Service.onUnbind()`方法在最后一个客户端解绑时被调用。因此，这些方法用于初始化和释放`Service`对象或变量。
- en: 'The interface created to let the client and server communicate, uses an instance
    of the `ServiceConnection` interface in the client and a binder in the server.
    Let''s see what this means in the code of both. This is the `Service` class code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端和服务器端进行通信而创建的接口，在客户端使用了`ServiceConnection`接口的一个实例，在服务器端使用了绑定器。让我们看看这在两者的代码中意味着什么。以下是`Service`类的代码：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Returning our `ServiceBinder` object that has a method to get a reference to
    the `Service` class itself, we allow the client to get a reference to that and
    then call its methods. Let''s see the client code now:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 返回我们的`ServiceBinder`对象，它有一个获取对`Service`类本身引用的方法，我们允许客户端获取对该引用的引用，然后调用其方法。现在让我们看看客户端的代码：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ServiceConnection.onServiceConnected()` method has an `IBinder` as parameter,
    then, we can cast it to the `ServiceBinder` we defined in the `Service` class
    and use it to retrieve the service itself through the `ServiceBinder.getService()`
    method we defined.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceConnection.onServiceConnected()`方法有一个`IBinder`作为参数，然后，我们可以将其转换为在`Service`类中定义的`ServiceBinder`，并通过我们定义的`ServiceBinder.getService()`方法来获取服务本身。'
- en: This way we can use the `myService` object inside the activity to call the service's
    methods. Remember to call the `Context.unbindService()` method when the reference
    to that is no longer needed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在活动中使用`myService`对象来调用服务的方法。当不再需要该引用时，记得调用`Context.unbindService()`方法。
- en: When to use
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: If you need a direct communication between a component and the service, the
    Bound Service is the right choice, because it extends the flexibility of a Started
    Service to the other component, keeping separated the two bound components implementations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个组件与服务之间的直接通信，绑定服务是正确的选择，因为它将启动服务的灵活性扩展到另一个组件，同时保持两个绑定组件实现的分离。
- en: IntentService
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IntentService
- en: 'A particular implementation of a service provided by the platform is the `IntentService`
    class. It is useful in some situations for the reasons we are going to find out.
    This class wraps a single background thread to execute different requests related
    to intents in its queue. When the queue becomes empty, the `IntentService` class
    is automatically destroyed. Hence, it has a different life cycle than the `Service`
    class. It is active only while operating in the background thread. Knowing this,
    let''s see the differences between `Service` and `IntentService`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 平台提供的一个特定服务实现是`IntentService`类。在某些情况下它非常有用，原因我们将会了解到。这个类包装了一个后台线程，以执行与其队列中与意图相关的不同请求。当队列变空时，`IntentService`类会自动销毁。因此，它具有与`Service`类不同的生命周期。它仅在后台线程中运行时处于活动状态。了解了这一点，让我们看看`Service`和`IntentService`之间的区别：
- en: The implementation of the `Service.onStartCommand()` method returns `Service.START_NOT_STICKY`
    by default. Hence, no intents will be redelivered if the service is terminated
    unexpectedly. Anyway, we can use the `Service.setIntentRedelivery()` method to
    change this behavior.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service.onStartCommand()`方法的默认实现返回`Service.START_NOT_STICKY`。因此，如果服务意外终止，将不会重新传递意图。不过，我们可以使用`Service.setIntentRedelivery()`方法来更改此行为。'
- en: Due to its life cycle, there is no possibility to bind such a service. Hence,
    there is no possibility to create a binder for this and the default implementation
    of the `Service.onBind()` method is returning null.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其生命周期，不可能绑定这样的服务。因此，没有可能为此创建Binder，并且`Service.onBind()`方法的默认实现是返回null。
- en: Instead of using the `System.onStartCommand()` method to handle the incoming
    intents, the class provides the `IntentService.handleIntent()` method. This method
    is executed in the background thread; then, there is no need to create worker
    threads in this case. The class handles the thread creation and management for
    us. This thread management is done using a `HandlerThread`; this is why there
    is a queue with a sequential execution of the messages and runnables.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其使用`System.onStartCommand()`方法来处理传入的意图，该类提供了`IntentService.handleIntent()`方法。这个方法在后台线程中执行；因此，在这种情况下，无需创建工作线程。该类为我们处理线程的创建和管理。这种线程管理是使用`HandlerThread`完成的；这就是为什么会有一个顺序执行消息和runnables的队列。
- en: As mentioned, an `IntentService` class cannot be bound, hence, the way to start
    it is just with the `Context.startService()` method.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，`IntentService`类不能被绑定，因此启动它的方式只能是使用`Context.startService()`方法。
- en: 'The code for an `IntentService` class looks like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentService`类的代码如下所示：'
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When to use
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用
- en: 'When you need to execute a sequential operation in the background in a separate
    thread, and you do not need to handle the life cycle of `Service`, the `IntentService`
    class is the right choice: it provides all that is required to do asynchronous
    operations without affecting the UI.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在一个单独的线程中在后台执行顺序操作，并且不需要处理`Service`的生命周期时，`IntentService`类是正确的选择：它提供了进行异步操作所需的一切，而不会影响UI。
- en: Inter-process communication
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间通信
- en: The communication between two threads from two different processes is not so
    simple as in the previous case because two separate processes cannot share memory,
    and then, there is no way for a `Handler` object to be executed on both threads.
    In this situation, the binder thread we discussed earlier helps us let threads,
    in different processes, communicate.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 两个来自不同进程的线程之间的通信并不像前一个案例那么简单，因为两个独立的进程不能共享内存，因此`Handler`对象无法在两个线程上执行。在这种情况下，我们之前讨论的Binder线程帮助我们让在不同进程中的线程进行通信。
- en: Remote Procedure Call
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: 'The framework lets us define **Remote Procedure Call** (**RPC**), which allows
    the client thread in the local process to call remote methods as if they are local.
    *Figure 3* shows what this means:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 框架让我们定义**远程过程调用**（**RPC**），它允许本地进程中的客户端线程像调用本地方法一样调用远程方法。*图3*展示了这意味着什么：
- en: '![Remote Procedure Call](img/4666_05_03.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![远程过程调用](img/4666_05_03.jpg)'
- en: 'Figure 3: Remote Procedure Call scheme'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：远程过程调用方案
- en: 'The appropriate process is the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的流程如下：
- en: The client calls a server method.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端调用服务器方法。
- en: Data and methods are converted to a format suitable for transmission. This operation
    is also known as **marshaling**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据和方法被转换成适合传输的格式。这项操作也被称为**编组**（marshaling）。
- en: Through a binder thread, data and methods are transmitted.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Binder线程，传输数据和方法。
- en: Data and methods are converted back into the original format through demarshaling.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据和方法通过解编（demarshaling）转换回原始格式。
- en: The server executes the method with the data and prepares the result for the
    same process backwards to the client.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端用数据执行方法，并为客户端原路返回准备结果。
- en: The data that needs to be passed through processes must implement the Parcelable
    interface.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在进程间传递的数据必须实现Parcelable接口。
- en: AIDL
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AIDL
- en: 'The RPC can be defined using a special language called **Android Interface
    Definition Language** (**AIDL**). The interface between client and server is defined
    inside an `.aidl` file, and its content is replicated in both client and server
    processes. The marshaling and demarshaling operations are delegated to two particular
    inner classes called **Proxy** for the client side and **Stub** for the server
    one. In this case, the scheme in *Figure 3* is turned into that in *Figure 4*:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: RPC可以使用一种特殊的语言定义，称为**Android接口定义语言**（**AIDL**）。客户端和服务器之间的接口在`.aidl`文件中定义，其内容在客户端和服务器进程中被复制。编组（marshaling）和解编组（demarshaling）操作被委托给两个特殊的内部类，客户端侧称为**Proxy**，服务器侧称为**Stub**。在这种情况下，*图3*的方案变成了*图4*的方案：
- en: '![AIDL](img/4666_05_04.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![AIDL](img/4666_05_04.jpg)'
- en: 'Figure 4: Android Interface Definition Language scheme'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：Android接口定义语言方案
- en: 'To use this language, you need to define the interface with a method signature
    in the `.aidl` file. For example, look at the following declaration inside the
    `.aidl` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种语言，你需要在`.aidl`文件中定义带有方法签名的接口。例如，查看以下在`.aidl`文件中的声明：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, this is converted to a `.java` file and shared between processes. So,
    the `RemoteService` class can have an instance of its stub this way:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这将转换成一个`.java`文件，并在进程间共享。因此，`RemoteService`类可以以这种方式拥有其存根的实例：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Moreover, finally, the client activity can bind the remote service and call
    the method of the interface as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最后，客户端活动可以绑定远程服务，并按以下方式调用接口的方法：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Messenger
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Messenger
- en: 'Another way to send methods and data to a remote process is the use of a `Messenger`
    object. It is easier but single-threaded, hence slower. A `Messenger` object has
    a reference to a `Handler` object in one process and, then, another process handles
    it. Let''s start with the code of the remote service:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将方法和数据发送到远程进程的方法是使用`Messenger`对象。它更简单，但是单线程的，因此较慢。`Messenger`对象有一个指向一个进程中`Handler`对象的引用，然后另一个进程处理它。让我们从远程服务的代码开始：
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, the `Messenger` object is used by the client `Activity` to send messages:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户端`Activity`使用`Messenger`对象来发送消息：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Advanced techniques
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级技术
- en: We saw until here an overview of the main techniques to handle multithreading
    in an Android application. We now want to have a look at advanced techniques helpful
    to improve performance, in particular, situations where a developer is not always
    aware of how multithreading strategy works, moving expensive operations from the
    UI thread to a worker thread.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到此为止了解了在Android应用程序中处理多线程的主要技术概览。现在我们想要看看有助于提高性能的高级技术，特别是在开发者不一定清楚多线程策略如何工作的情况下，将昂贵的操作从UI线程移动到工作线程。
- en: BroadcastReceiver asynchronous techniques
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`BroadcastReceiver`异步技术'
- en: 'A `BroadcastReceiver` class is another Android platform main component. It
    differs from the other main components because of its short life cycle. The `BroadcastReceiver`
    class is active just for the execution of the `BroadcastReceiver.onReceive()`
    method. Its main use is to receive messages. Hence, it has a short lifetime. Then,
    this component was not created to execute long-running operations. However, it
    is the perfect candidate to be used to start a background task starting, for example,
    `IntentService`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`BroadcastReceiver`类是Android平台另一个主要组件。它与其他主要组件的区别在于其生命周期短暂。`BroadcastReceiver`类仅在执行`BroadcastReceiver.onReceive()`方法时处于活动状态。其主要用途是接收消息。因此，其生命周期短暂。然后，这个组件并非用于执行长时间运行的操作。然而，它非常适合用于启动后台任务，例如启动`IntentService`：'
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Starting from Android Honeycomb (API Level 11), the platform provides a particular
    way to extend the `BroadcastReceiver` class lifetime and wait until a background
    thread ends: calling the `BroadcastReceiver.goAsync()` method, a `PendingResult`
    object is returned. This object is used to handle the state of the background
    thread. The lifetime of the receiver endures until the `PendingResult.finish()`
    method is called. This is crucial to remember: if you are going to use this particular
    technique when the thread has completed its task, call the `PendingResult.finish()`
    method to free the `BroadcastReceiver` class. Otherwise, the receiver will not
    be closed, leading to a memory leak and unexpected results in the next receiving
    broadcast events. Let''s have a look at the code to use this technique:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android Honeycomb（API 级别 11）开始，平台提供了一种特殊的方法来扩展 `BroadcastReceiver` 类的生命周期，并等待后台线程结束：调用
    `BroadcastReceiver.goAsync()` 方法，会返回一个 `PendingResult` 对象。这个对象用于处理后台线程的状态。直到调用了
    `PendingResult.finish()` 方法，接收器的生命周期才会结束。这是至关重要的：如果你打算在线程完成任务时使用这种特殊技术，请调用 `PendingResult.finish()`
    方法来释放 `BroadcastReceiver` 类。否则，接收器将不会被关闭，导致内存泄漏，并在下一次接收广播事件时产生预期之外的结果。让我们看看使用这种技术的代码：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ContentProvider asynchronous techniques
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ContentProvider 异步技术
- en: A `ContentProvider` class is another main component used to share data across
    other main components, processes, and applications. Its primary purpose is to
    hold a database for information to be shared. Most of the time, the provider is
    a remote object in a different process. Then, the provider is not accessed directly,
    but a `ContentResolver` object is used to query, insert, delete, and update the
    provider. This way the inter-process communication is handled.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentProvider` 类是另一个主要组件，用于跨其他主要组件、进程和应用共享数据。其主要目的是持有数据库以共享信息。大多数时候，提供者是不同进程中的远程对象。因此，不直接访问提供者，而是使用
    `ContentResolver` 对象来查询、插入、删除和更新提供者。这种方式处理了进程间通信。'
- en: A `ContentProvider` class cannot know how many concurrent modifications are
    occurring at the same time. Then, thread safety is needed, because there is the
    need for consistency of queried data. Luckily, an SQLite database is locked and,
    then, it is thread-safe. Moreover, the SQLiteDatabase class has a method called
    `SQLiteDatabase.setLockingEnabled()` to change the thread-safety behavior of the
    database. Its default value is `true`, and it has even been deprecated and, more
    than this, disabled starting from Android JellyBean (API Level 16) so you cannot
    remove locks and thread safety from the database accesses. You can enable the
    parallel writing of data in the SQLiteDatabase anyway using the `SQLiteDatabase.enableWriteAheadLogging()`
    method. This way, writing operations are done while reading ones are executed
    in a different log file to enable parallel read/write executions. Hence, the readers
    will read the value as it was before the writing operation started. This way of
    getting access at the same time as multiple threads is expensive from a memory
    perspective because of the duplication of data in the background while writing.
    Then, use it only if you strictly need multiple threads to access the database.
    In all of the other use cases, the default implementation of lock for the database
    accesses is enough.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentProvider` 类无法知晓同一时间发生多少并发修改。因此，需要线程安全，因为需要查询数据的连贯性。幸运的是，SQLite数据库是锁定的，因此它是线程安全的。此外，SQLiteDatabase
    类有一个名为 `SQLiteDatabase.setLockingEnabled()` 的方法，可以改变数据库的线程安全行为。其默认值为 `true`，并且已经被弃用，从Android
    JellyBean（API 级别 16）开始甚至被禁用，因此你不能从数据库访问中移除锁和线程安全。不过，你可以使用 `SQLiteDatabase.enableWriteAheadLogging()`
    方法来启用 SQLiteDatabase 的并行数据写入。这样，写入操作在与读取操作在不同的日志文件中执行时进行，以实现并行读写执行。因此，读者将读取到的值是在写入操作开始前的状态。这种同时让多个线程访问的方式从内存角度来看是昂贵的，因为后台在写入时会复制数据。因此，只有在你严格需要多个线程访问数据库时才使用它。在所有其他用例中，数据库访问的默认锁实现就足够了。'
- en: 'When we need to make operations on `ContentProvider`, we should avoid making
    them on the UI thread; they can be long and block the UI. We already discussed
    the database querying in the background when we dealt with `CursorLoader`: the
    `CursorLoader` object is used just to read from a database. However, now we are
    dealing with `ContentProvider`, and we do not have direct access to them. Moreover,
    we want to write to them as well as read from them. Android provides a particular
    API to do this: we are talking about the `AsyncQueryHandler` class. It wraps the
    `ContentResolver` to start asynchronous operations on the `ContentProvider`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要对`ContentProvider`进行操作时，应避免在UI线程上执行，这些操作可能会很耗时并阻塞UI。我们在讨论`CursorLoader`时已经涉及了后台数据库查询：`CursorLoader`对象仅用于从数据库中读取。然而，现在我们要处理`ContentProvider`，并且没有直接访问权限。此外，我们还希望对其进行写入以及读取操作。Android提供了一个特定的API来完成这项工作：我们讨论的是`AsyncQueryHandler`类。它包装了`ContentResolver`，以在`ContentProvider`上启动异步操作。
- en: 'The `AsyncQueryHandler` is an abstract subclass of `Handler`. It has no abstract
    methods, but we can define what to do to handle different writing and/or reading
    operations completions. Here are the `AsyncQueryHandler` callbacks:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncQueryHandler`是`Handler`的抽象子类。它没有抽象方法，但我们可以定义如何处理不同的读写操作完成。以下是`AsyncQueryHandler`的回调：'
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The methods to start the execution of a particular request to the `ContentResolver`
    object are shown in the following snippet. When the operation is done, the corresponding
    callback method indicated above is called:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 启动对`ContentResolver`对象特定请求执行的方法如下所示。操作完成后，将调用上面指定的相应回调方法：
- en: '`startQuery(int token, Object cookie, Uri uri, String[]projection, String selection,
    String[] selectionArgs, String orderBy)`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startQuery(int token, Object cookie, Uri uri, String[]projection, String selection,
    String[] selectionArgs, String orderBy)`'
- en: '`startInsert(int token, Object cookie, Uri uri, ContentValues initialValues)`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startInsert(int token, Object cookie, Uri uri, ContentValues initialValues)`'
- en: '`startUpdate(int token, Object cookie, Uri uri, ContentValues values, String
    selection, String[] selectionArgs)`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startUpdate(int token, Object cookie, Uri uri, ContentValues values, String
    selection, String[] selectionArgs)`'
- en: '`startDelete(int token, Object cookie, Uri uri, String selection, String[]
    selectionArgs)`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startDelete(int token, Object cookie, Uri uri, String selection, String[]
    selectionArgs)`'
- en: 'The token to be passed to the preceding methods is the same that will be passed
    as a parameter in the related callback method. This way we can know who the caller
    is and then do some particular action instead of another one. It is useful if
    we want to cancel a particular operation: we can do it by calling the `AsyncQueryHandler.cancelOperation()`
    method. Now let''s see how to use it in `Activity`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给前面方法的是与相关回调方法中作为参数传递的相同token。这样我们可以知道调用者是谁，然后执行特定的操作而不是其他操作。如果我们想取消一个特定的操作，这很有用：我们可以通过调用`AsyncQueryHandler.cancelOperation()`方法来实现。现在让我们看看如何在`Activity`中使用它：
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `AsyncQueryHandler` class is just a handler, and its callback methods are
    called from the thread that created the `AsyncQueryHandler` object, while the
    operations are done in a worker thread.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncQueryHandler`类只是一个处理器，其回调方法是从创建`AsyncQueryHandler`对象的线程中调用的，而操作是在工作线程中完成的。'
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Every time you are dealing with `ContentProvider`, the choice of the `AsyncQueryHandler`
    is the right one to free the UI thread from unnecessary operations, delegating
    a worker thread to deal with `ContentResolver`. This way, you can improve the
    UI performance of your application. Moreover, it is easy to use and frees us to
    deal with `Looper` and `MessageQueue`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每当处理`ContentProvider`时，选择`AsyncQueryHandler`是正确的，它可以释放UI线程不必要的操作，并将工作线程委托给`ContentResolver`处理。这样，你可以提高应用程序的UI性能。此外，它易于使用，让我们无需处理`Looper`和`MessageQueue`。
- en: Repeating tasks
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复任务
- en: Many times we have needed to start a recurring task in our development experience.
    However, is the adopted strategy the right way to do it? Can it be improved from
    a performance point of view? Let's check which options we have to create a recurring
    timer to start background operations without affecting the UI thread.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的开发经验中，很多时候我们需要启动一个周期性任务。但是，采用的战略是正确的吗？从性能角度来看，它可以改进吗？让我们检查一下，我们有哪些选项来创建一个周期性定时器，以启动后台操作而不影响UI线程。
- en: Timer
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定时器
- en: 'The `Timer` class is the most used method to create a recurring task:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`类是创建周期性任务最常用的方法：'
- en: '[PRE30]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Timer` object creates a thread used to execute the code of the recurring
    task. Hence, the `TimerTask` is not executed on the main thread.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`对象创建了一个线程，用于执行周期性任务的代码。因此，`TimerTask`不是在主线程上执行的。'
- en: When done, the `Timer` must be canceled using the `Timer.cancel()` method to
    free resources that otherwise can be held indefinitely. This API can be used for
    short period recurring tasks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，必须使用`Timer.cancel()`方法取消`Timer`，以释放资源，否则可能会无限期地占用这些资源。这个API可以用于短周期的周期性任务。
- en: ScheduledExecutorService
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ScheduledExecutorService
- en: 'This particular implementation of the `Executor` framework allows us to schedule
    a repeating task at regular intervals. It can be done in the following way:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`框架的这种特定实现允许我们按固定间隔安排重复任务。可以以下列方式完成：'
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the execution is no longer needed, call `ScheduledExecutorService.shutdown()`
    or `ScheduledExecutorService.shutdownNow()`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要执行时，调用`ScheduledExecutorService.shutdown()`或`ScheduledExecutorService.shutdownNow()`。
- en: This one is more flexible and capable than the `Timer` API. Therefore, it should
    be preferred to that for short period recurring tasks.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比`Timer` API更灵活且功能强大。因此，对于短周期的周期性任务，应该优先考虑使用它。
- en: AlarmManager
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AlarmManager
- en: 'An `AlarmManager` object can be used to start recurring operations by starting
    a new component at particular times:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlarmManager`对象可以用来在特定时间启动新的组件，以开始重复操作：'
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use two methods to start a new repeating alarm:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方法来启动新的重复闹钟：
- en: '`setRepeating()`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRepeating()`'
- en: '`setInexactRepeating()`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInexactRepeating()`'
- en: 'The `AlarmManager` class is much more efficient than the other ones because
    of its internal checks of the system status, but it is not suitable for short
    period tasks. Hence, use it when possible instead of the `Timer` and the `Executor`
    framework, considering its limits. Remember to restore the alarms once a reboot
    is completed: you can use a `BroadcastReceiver` to be used with `Intent.ACTION_BOOT_COMPLETED`
    to be notified about this event.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlarmManager`类由于其内部检查系统状态，比其他类更高效，但它不适合短周期任务。因此，在可能的情况下，用它代替`Timer`和`Executor`框架，考虑到它的限制。记得在重新启动完成后恢复闹钟：你可以使用与`Intent.ACTION_BOOT_COMPLETED`一起使用的`BroadcastReceiver`来通知此事件。'
- en: Debugging tools
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试工具
- en: We have seen different techniques to create our multithreaded application and
    when to use them. The right structure to use depends on a lot of various factors;
    it's up to the developer to treasure what we said and apply the appropriate framework
    in each case. However, our primary goal is to provide a fluid UI to the user,
    avoiding the *Application Not Responding* dialog, lags, and any obstacle to the
    correct execution of the UI thread. For this, Android provides some tools that
    we are about to see in the following pages.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了创建多线程应用程序的不同技术以及何时使用它们。使用正确的结构取决于许多不同因素；这需要开发者珍惜我们所讲的，并在每种情况下应用适当的框架。然而，我们的主要目标是向用户提供流畅的UI，避免出现*应用程序无响应*对话框、延迟以及UI线程正确执行过程中的任何障碍。为此，Android提供了一些工具，我们将在接下来的页面中看到。
- en: StrictMode
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StrictMode
- en: We already dealt with this tool in [Chapter 4](ch04.html "Chapter 4. Memory"),
    *Memory*, while talking about memory leaks. However, this tool can also help us
    find and notify threading problems.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章](ch04.html "第四章. 内存") *内存* 中讨论内存泄漏时，我们已经处理过这个工具。然而，这个工具还可以帮助我们查找并通知线程问题。
- en: 'To use it we need to know what we are searching for and how to be informed
    that a threading problem is occurring. For this, we need to set `ThreadPolicy`
    to the `StrictMode` class, using a `ThreadPolicy.Builder` class. This way we can
    be notified of the following occurring problems:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们需要知道我们在寻找什么以及如何获知正在发生的线程问题。为此，我们需要将`ThreadPolicy`设置为`StrictMode`类，使用`ThreadPolicy.Builder`类。这样，我们可以获知以下发生的问题：
- en: '`detectCustomSlowCalls()`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectCustomSlowCalls()`'
- en: '`detectDiskReads()`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectDiskReads()`'
- en: '`detectDiskWrites()`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectDiskWrites()`'
- en: '`detectNetwork()`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectNetwork()`'
- en: '`detectResourceMismatches()`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectResourceMismatches()`'
- en: '`detectAll()`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectAll()`'
- en: 'The way we are notified depends on what method we call. We can choose among
    the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获知的方式取决于我们调用的方法。我们可以从以下选项中选择：
- en: '`penaltyDeath()`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penaltyDeath()`'
- en: '`penaltyDeathOnNetwork()`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penaltyDeathOnNetwork()`'
- en: '`penaltyDialog()`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penaltyDialog()`'
- en: '`penaltyDropBox()`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penaltyDropBox()`'
- en: '`penaltyFlashScreen()     `'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penaltyFlashScreen()     `'
- en: '`penaltyLog()`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`penaltyLog()`'
- en: 'Hence, the following code snippet is a good example of what we should do to
    check any threading problem:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下代码段是我们应该执行的检查任何线程问题的好例子：
- en: '[PRE33]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Starting from the basic definition of thread, through the Java threading framework,
    we got to talk about Android process management, thread types, and the messaging
    framework. We analyzed pitfalls in multithreading environments, defining thread
    safety. Indicating what we can do with multiple threads in an application, we
    described the primary goal for an Android developer from a multithreading performance
    point of view. The UI thread should just deal with the UI, and any other operation
    should be executed in the background using a worker thread. Because of this, we
    evaluated a lot of different solutions provided by the platform for various situations,
    defining when they can or shouldn't be used. Anyway, the choice of the right framework
    depends on the particular situation the developer is dealing with, but, knowing
    all the possibilities, he has more chances to improve the performance of the application.
    At the end of the chapter, we saw which tools we have for the detection of threading
    anomalies to keep the application responsive.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 从线程的基本定义出发，我们通过Java线程框架，谈及了Android进程管理、线程类型以及消息框架。我们分析了多线程环境中的陷阱，定义了线程安全。指出了在一个应用程序中我们可以用多个线程做什么，从多线程性能的角度描述了Android开发者追求的主要目标。UI线程只需处理UI，任何其他操作都应该在后台使用工作线程执行。因此，我们评估了平台为各种情况提供的许多不同解决方案，定义了何时应该或不应使用它们。总之，选择正确的框架取决于开发者所面对的具体情况，但是，了解了所有可能性后，他更有机会提升应用程序的性能。在本章的最后，我们了解了有哪些工具可以帮助我们检测线程异常，以保持应用程序的响应性。
