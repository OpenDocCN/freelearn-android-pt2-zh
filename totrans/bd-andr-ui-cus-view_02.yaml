- en: Implementing Your First Custom View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we've seen how to create the foundations of a custom
    view, but unless we add some more features and customizations it'll be pretty
    useless. In this chapter, we'll continue building on top of these foundations,
    see how we can parameterize our custom view to allow either ourselves or any other
    developer to customize them, and at the end, cover some rendering that will enable
    us to build slightly more complex custom views.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In addition, as we've mentioned in the previous chapter, we can create custom
    layouts as well. In this chapter, we'll see how to create a simple custom layout.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Measuring and parameterizing our custom view
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating custom views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic rendering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring and parameterizing our custom view
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to have a good reusable custom view, it needs to be able to adapt to
    different sizes and device resolutions, and to increase its reusability even more
    it should support parameterization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Measuring our custom view
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the quick example we built in the previous chapter, we delegated all sizes
    and measurement to the parent view itself. To be honest, we haven''t even delegated
    it; we just didn''t do anything specifically to take care of that. Being able
    to control the size and dimensions of our custom view is something we definitely
    need to pay some attention to. To start, we''re going to **override** the `onMeasure()`
    method from view as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Reading the Android documentation about the `onMeasure()` method, we should
    see we must **call** either `setMeasuredDimension(int, int)` or the superclass''
    `onMeasure(int, int)`. If we forget to do so, we''ll get an `IllegalStateException`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are three different **modes** in which our view's parent can indicate
    to our view how it should calculate its size. We can get the mode by using the
    `MeasureSpec.getMode(int)` method with each size spec `widthMeasureSpec` and `heightMeasureSpec`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'These modes are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`MeasureSpec.EXACTLY`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MeasureSpec.AT_MOST`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MeasureSpec.UNSPECIFIED`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll get `MeasureSpec.EXACTLY` when the size has been calculated or decided
    by the parent. Our view will have that size even if it requires or returns a different
    size. If we get `MeasureSpec.AT_MOST` we have more flexibility: we can be as big
    as we need but up to the size we also have. Finally, if we received `MeasureSpec.UNSPECIFIED`,
    we can size our view to whatever size we want or the view needs.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Using `MeasureSpec.getSize(int)`, we can also get a size value from the size
    spec.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all this, how do we know which values map to the width and
    height parameters on our XML layout file? Easy to see, let''s check. For example,
    if we specify precise values as shown in the `activity_main.xml` file in the GitHub
    repository, we will get the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code on our custom view, using `MeasureSpec.toString(int)` to get a string
    description of the measure specification and the size looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result on the Android log is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our view will be `394` by `394` pixels exactly. The `394` pixels comes from
    transforming the `150dp` to pixels on the mobile device I was using for testing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: As there are many Android devices with different resolutions and screen densities,
    we should always use **density-independent pixel** (**dp**) or (**dip**) instead
    of pixels.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about dp, refer to a video by Google available on YouTube:
    DesignBytes: Density-independent Pixels.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to convert from dp to real pixels on a specific device, you
    can use the following method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see how the conversion is done using the density of the screen, so on
    different devices the conversion can be different. The `+ 0.5` in the previous
    code is just to round up the value when converting from a floating point number
    to an `int`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert from pixels to density-independent points, we have to do the inverse
    operation, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s now see what we receive if we use different measure parameters, such
    as `match_parent` or `wrap_content`, as shown in the `activity_main.xml` file
    in the GitHub repository:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the same code as before, we get the following on the Android log:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So we are still getting a `MeasureSpec.EXACTLY`, but this time with the size
    of the parent `RelativeLayout`; let''s try changing one of the `match_parents`
    for a `wrap_content` in `activity_main.xml`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can spot an easy-to-follow pattern with `MeasureSpec.EXACTLY` and `MeasureSpec.AT_MOST`,
    but what about `MeasureSpec.UNSPECIFIED`?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll get a `MeasureSpec.UNSPECIFIED` if our parent is not bounded; for example,
    if we have a vertical `LinearLayout` inside a `ScrollView`, as shown in the `scrollview_layout.xml`
    file in the GitHub repository:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we''ll get the following on the Android log:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That seems alright, but what happens if we now run this code? We''ll get an
    empty screen; our red background we''ve previously implemented is gone:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1bcec83-d3f8-4aab-8d2c-a4cbe743e041.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'That is because we''re not managing the size of our custom view. Let''s fix
    that, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, depending on the measurement specs, we'll set the size of our view by calling
    the `setMeasuredDimension(int, int)` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: For the full example, check the source code in the `Example03-Measurement` folder
    in the GitHub repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing our custom view
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have our custom view that adapts to multiple sizes now; that''s good, but
    what happens if we need another custom view that paints the background blue instead
    of red? And yellow? We shouldn''t have to copy the custom view class for each
    customization. Luckily, we can set parameters on the XML layout and read them
    from our custom view:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the type of parameters we will use on our custom view.
    We''ve got to create a file called `attrs.xml` in the `res` folder:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we add a different namespace on our layout file where we want to use
    this new parameter we''ve just created:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have this defined, let''s see how we can read it from our custom
    view class:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By getting a `TypedArray` using the styled attribute ID Android tools created
    for us after saving the `attrs.xml` file, we'll be able to query for the value
    of those parameters set on the XML layout file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we created an attribute named `fillColor` that will be formatted
    as a color. This format, or basically, the type of the attribute, is very important
    to limit the kind of values we can set, and how these values can be retrieved
    afterwards from our custom view.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Also, for each parameter we define, we'll get a `R.styleable.<name>_<parameter_name>
    index` in the `TypedArray`. In the preceding code, we're querying for the `fillColor`
    using the `R.styleable.OwnCustomView_fillColor index`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn't forget to recycle the `TypedArray` after using it so it can be
    reused later on, but once recycled, we can't use it again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the results of this little customization:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9126c6f-80b6-489a-8525-aebfd9ecb311.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'We''ve used color in this specific case, but we can use many other types of
    parameters; for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Int
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimension
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawable
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each one has its own getter method: `getBoolean(int index, boolean defValue)`
    or `getFloat(int index, float defValue)`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In addition, to know if a parameter is set we can use the `hasValue(int)` method
    before querying or we can simply use the default values of the getters. If the
    attribute is not set at that index, the getter will return the default value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: For the full example, check the `Example04-Parameters` folder in the GitHub
    repository.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating custom views
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen how to set parameters on the XML layout and parse them on
    our custom view class, we'll see how to instantiate custom views from code as
    well and reuse then as much as possible from both instantiation mechanisms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating custom views from code
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our custom view, we've created a single constructor with two parameters,
    a `Context` and an `AttributeSet`. Now, if we're creating our UI programmatically,
    or if by any other reason we need to instantiate our custom view by code, we need
    to create an additional constructor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'As we want to keep using our custom view in our XML layouts, we have to keep
    both constructors. To code avoid duplication, we will create some helper methods
    to initialize it and use them from both constructors:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also created a public method, `setFillColor(int)`, so we can set the fill
    color by code as well. For example, let''s modify our `Activity` to create the
    view hierarchy programmatically instead of inflating it from an XML layout file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we're just creating a `LinearLayout` with vertical orientation and adding
    a custom view as a child. Then we're setting the `LinearLayout` as the content
    view of the `Activity`. Also, we've used a hexadecimal color directly. If we're
    not used to specifying colors in hexadecimal format, we could use `Color.argb()`
    or `Color.rgb()` to convert color components to an integer value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The full source code can be found in the `Example05-Code` folder in the GitHub
    repository.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we used the `setFillColor()` method to set the fill
    color of the custom view, but suppose we will have many other parameters, the
    code might get a bit messy with all the setters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple example: instead of having one single background color,
    we''ll have four different colors and we''ll draw a gradient on our view:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the four different colors and their setters as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We also added a boolean to check if we have to update the gradient. Let's ignore
    thread synchronization here as it's not the main purpose of this example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ve added a check for this `boolean` on the `onDraw()` method and,
    in the case it''s needed, it''ll regenerate the gradient:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It's a bad practice to create new object instances on the `onDraw()` method.
    Here it is only done once, or every time we're changing the colors. If we were
    changing the color constantly, this would be a bad example as it'll be constantly
    creating new objects, polluting the memory, and triggering the **Garbage Collector**
    (**GC**). There will be more on performance and memory in [Chapter 7](6a783453-2297-4806-80b4-c8022bd9e309.xhtml),
    *Performance Considerations*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to update the code of our `Activity` to set these new colors:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, we've used four setters to set the colors. If we've got more
    parameters, we could use more setters, but one of the issues of this approach
    is that we have to take care of thread synchronization and the object might be
    in an unstable state until all calls are done.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to add all the parameters to the constructor, but that is
    not a good solution either. It'd make our job more complex, as it'll be hard to
    remember the order of the parameters or, in the case where we had optional, to
    create many different constructors or passing null references that make our code
    harder to read and maintain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Check the full source code of this example in the `Example06-BuilderPattern-NoBuilder`
    folder of the GitHub repository.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve introduced the issue, let''s solve it by implementing the `Builder`
    pattern on our custom view. We start by creating a `public static class` inside
    our custom view that will build it as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also create a new private constructor that only accepts an `OwnCustomView.Builder`
    object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've removed other constructors for clarity. Also at this point, we create
    the array of colors based on the colors that the `builder` object has and a `boolean`
    to know if it's the first time it'll be drawn or not.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be useful to instantiate the `LinearGradient` object only once and
    avoid creating many instances:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, once the object is created we can't change its colors, but we don't have
    to worry about thread synchronization and the object's state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it work, let''s update the code on our `Activity` as well:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using the `Builder` pattern, our code is cleaner and the object is constructed
    or built when we've set all the properties and this will become even handier if
    the custom view has more parameters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The full example source code can be found in the `Example07-BuilderPattern`
    folder in the GitHub repository.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom layout
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android provides several layouts to position our views in many different ways,
    but if these standard layouts aren't useful for our specific use case, we can
    create our own layouts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Extending ViewGroup
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process to create a custom layout is quite similar to creating a custom
    view. We've got to create a class that extends from `ViewGroup` instead of view,
    create the appropriate constructors, implement the `onMeasure()` method, and override
    the `onLayout()` method rather than the `onDraw()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a very simple custom layout; it will add elements to the right
    of the previous element until it doesn't fit on the screen, then it'll start a
    new row, using the higher element to calculate where this new row will start and
    avoid any overlapping between views.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding random sized views, where each view has a red background, will look
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62f2b38c-b67f-4150-b747-a33a9502534a.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'First, let''s create a class that extends from `ViewGroup`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We created the constructor and we implemented the `onLayout()` method as it''s
    an abstract method and we''ve got to implement it. Let''s add some logic to it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This logic implements what we've described before; it tries to add a child to
    the right of the previous child and if it doesn't fit on the layout width, checking
    the current `left` position plus the measured child width, it starts a new row.
    The `rowHeight` variable measures the higher view on that row.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also implement the `onMeasure()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The logic is the same as before, but it''s not laying out its children. It
    calculates the maximum width and height that will be needed, and then with the
    help of a helper method sets the dimensions of this custom layout according to
    the width and height measurement specs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we''ve got our custom layout, let''s add it to our `activity_main`
    layout:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the last step, let''s add some random sized views to it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Check the `Example08-CustomLayout` folder on GitHub for the full source code
    of this example.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: On this page, we can also find a quite complex example of a full-featured custom
    layout.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Basic rendering
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we've only been drawing a solid background or a linear gradient. That's
    neither exciting nor really useful. Let's see how we can draw more interesting
    shapes and primitives. We'll do so by creating an example of a circular activity
    indicator that we'll be adding more and more features to in the following chapters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Creating the basic circular activity indicator
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Canvas` class provides us with many drawing functions; for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`drawArc()`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawBitmap()`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawOval()`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawPath()`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To draw a circular activity indicator, we can use the `drawArc()` method. Let''s
    create the basic class and draw an arc:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result is as shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c9a946b-8846-4198-97c5-f5f935e32353.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Let''s fix the ratio, so the width of the arc will be the same as the height:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll use the smaller dimension, either width or height, and draw the arc
    centered with a square ratio: with the same width and same height.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't look like an activity indicator; let's change it and draw only
    a thin band of the arc. We can achieve this by using the clipping capabilities
    that `canvas` gives us. We can use `canvas.clipRect` or `canvas.clipPath`, for
    example. When using clipping methods, we can also specify a clipping operation.
    By default, if we don't specify it, it will intersect with the current clipping.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw only a thin band, we''ll create a smaller arc in a path, around *75%*
    of the size of the arc we''d like to draw. Then, we''ll subtract it from the clipping
    rectangle of the whole view:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the following screenshot, we can see the difference:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ac73a16-70b2-4c7a-87ea-d1feacd304a0.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: As finishing touches, let's add a background color to the arc and change the
    starting position to the top of the view.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the background, we''ll add the following code to create a background
    `Paint` to our constructor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then modify the `onDraw()` method to actually draw it, just before drawing
    the other arc:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As a small difference, we're drawing the whole `360` degrees so it will cover
    the whole circle.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the starting position of the arc, we''ll rotate our drawing operations.
    `Canvas` supports rotation, translation, and matrix transformations as well. In
    this case, we only need to rotate `90` degrees anti-clockwise to get our starting
    point at the top of the arc:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We also used `canvas.save()` and `canvas.restore()` to preserve the state of
    our `canvas`; otherwise, it will be rotating `-90` degrees each time it is drawn.
    When calling the `canvas.rotate()` method, we also specified the center point
    of the rotation, which matches with the center point of the screen and the center
    point of the arc.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we're using a `canvas` function as `rotate`, `scale`, or `translate`,
    for example, we're actually applying a transformation to all the successive `canvas`
    drawing operations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result is shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/725dac60-6a60-4a79-8249-148e5a8cf8a4.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Something we need to be aware of is that not all `canvas` operations are supported
    by hardware on all Android versions. Please check if the operations you have to
    do are supported or provide a runtime workaround for them. Find more information
    about what operations are hardware accelerated at:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到的一件事是，并非所有的`canvas`操作在所有Android版本上都得到硬件支持。请检查您需要执行的操作是否受支持，或者为它们提供运行时解决方案。在以下链接中了解更多关于哪些操作是硬件加速的信息：
- en: '[https://developer.android.com/guide/topics/graphics/hardware-accel.html](https://developer.android.com/guide/topics/graphics/hardware-accel.html).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/guide/topics/graphics/hardware-accel.html](https://developer.android.com/guide/topics/graphics/hardware-accel.html)。'
- en: 'Here is the final implementation of the class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的最终实现代码：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The whole example source code can be found in the `Example09-BasicRendering`
    folder in the GitHub repository.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 整个示例源代码可以在GitHub仓库中的`Example09-BasicRendering`文件夹中找到。
- en: 'Furthermore, I gave a talk about this at the Android Developer''s Backstage
    in Krakow in January 2015; here is a link to the presentation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我在2015年1月在克拉科夫的Android开发者后台关于这个话题进行了演讲；以下是演讲的链接：
- en: '[https://www.slideshare.net/RaimonRls/android-custom-views-72600098](https://www.slideshare.net/RaimonRls/android-custom-views-72600098).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.slideshare.net/RaimonRls/android-custom-views-72600098](https://www.slideshare.net/RaimonRls/android-custom-views-72600098)。'
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how to measure and how to add parameters to our
    custom view. We also saw how to instantiate a custom view from code and use a
    `Builder` pattern to simplify all the parameters and keep our code cleaner. In
    addition, we went through a quick example of a custom layout and we started building
    a circular activity indicator. In the next chapter, we will see how to handle
    events and add some interactions to the circular activity indicator we've just
    started to build.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何测量以及如何为自定义视图添加参数。我们还了解了如何从代码中实例化自定义视图，并使用`Builder`模式来简化所有参数，使代码保持整洁。此外，我们还快速通过一个自定义布局的示例，并开始构建圆形活动指示器。在下一章中，我们将学习如何处理事件并为刚刚开始构建的圆形活动指示器添加一些交互。
