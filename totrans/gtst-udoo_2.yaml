- en: Chapter 2. Know Your Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the last chapter, real-world applications aren't just software.
    They are composed of simple or complex circuits that perform actions in the physical
    world. Before we start to build our first interactive project, we need to know
    how these physical components work, so that we know what's inside our toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the first Arduino program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling a connection with Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an Android application capable of acting as a controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple circuit controlled by Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Arduino Due capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The physical world is composed of many forms of energy that we perceive in the
    form of light, heat, sound, or motion. While driving a car when we are near traffic
    lights and see a red light up ahead, we start to slow down and stop the car. We
    are just sensing a light form of energy and this led us to change our activity
    because someone taught us what every traffic light's phase means.
  prefs: []
  type: TYPE_NORMAL
- en: This natural behavior is the same we want to bring to our interactive physical
    applications. We use hardware devices called **sensors** that listen to the environment
    and that cooperate with other hardware components, called **actuators**, which
    perform actions in the real world. However, we need a third element called **microcontroller**
    that uses connected sensors and actuators to sense and alter the surrounding environment,
    according to the uploaded program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The onboard Arduino Due bears the latest part and provides a common way to
    connect external electronic components. It has 54 digital I/O pins that we can
    use to send or receive digital signals. This is particularly useful when we want
    to gather inputs from external devices such as switches or push buttons, while
    we can send digital signals to turn simple components on or off. In the following
    diagram, you can see all the digital pins in black:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Arduino Due capabilities](img/1942OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have 12 analog inputs at our disposal, with a 12 bits resolution for 4096
    different values for reading. They are useful when we need to collect data from
    our sensors and use the returned value as a condition for our program to change
    the behavior of our physical device. Good examples of read values are related
    to temperature, light, or proximity sensors. The board also offers 2 **Digital
    to Analog Converters** (**DAC**),with a 12 bits resolution, which can be used
    as analog output when we have to use a digital signal to drive an analog device.
    A good example of when you''ve to use DAC I/O pins is when you have to create
    an audio output with your device. In the following diagram, you will find all
    analog pins marked in black, while the 2 DAC pins are marked in gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Arduino Due capabilities](img/1942OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With these functionalities, we have all the required tools to control little
    devices from our Android applications. On the other hand, we can also take advantages
    from the inverse and let connected devices change the behavior of our Android
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, UDOO becomes really powerful when used to pilot a complex circuit that
    may need a hardware driver to interact with it. This could become the usual approach
    when we are going to recycle devices that we already own, such as old toys, or
    when we are buying new things such as little motorized robots or rovers.
  prefs: []
  type: TYPE_NORMAL
- en: Building hardware drivers is an expensive task that requires a lot of experience
    in software and electronics. UDOO, through the onboard Arduino, makes this task
    easy because it reuses all components built from the makers community. We can
    add other functionalities combining UDOO with a *shield*, which is a pluggable
    board that implements a complex circuit with all the required hardware logic.
    Good examples are LCD Arduino compatible screens, Bluetooth controllers and motor
    shields to control connected motors, with a few lines of code and without the
    need to build an external circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the first program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know what are the main components and capabilities of our UDOO board,
    we can start to write and upload our first program. We have to keep in mind that,
    even if the SAM3X is a standalone processor, we need a working microSD card with
    a valid UDOO image, otherwise the Arduino programmer will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did earlier for Android, we are going to write a simple application that
    prints Hello World! on our screen, without any Android interaction at the moment.
    Before opening the Arduino IDE, we need to connect the board to our computer via
    the microUSB port, available on the left of the board, as you can see in the following
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading the first program](img/1942OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, this connection isn't enough to allow a correct communication between
    the Arduino SAM3X and our computer because both the processors use this microUSB
    port to communicate via a serial port with the connected device. An internal physical
    switch chooses the connected processor between the i.MX6 that runs Android and
    the Arduino SAM3X.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a different connection and not the same used in the previous chapter.
    It refers to the serial port and must not be confused with the OTG microUSB port
    used for the deployment of Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the connection between our computer and the SAM3X, we must unplug
    the physical **jumper J18** as we can see in the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading the first program](img/1942OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to launch the Arduino IDE and proceed to write and upload our
    first program. When the IDE shows up, it will open an empty program. Every program
    and code written for Arduino is called a **sketch**. Arduino sketches are written
    using a simplified set of C/C++, and if you are interested, you can find a full
    reference at [http://arduino.cc/en/Reference/HomePage](http://arduino.cc/en/Reference/HomePage).
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial sketch contains two functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup()`: This is called once during the initial execution and there we put
    all initial configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop()`: This is called over and over until someone turns off the device,
    and it represents the core of our sketch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All our sketches must contain both functions, otherwise our program will not
    work. We may add our own functions to make the code more readable and reusable,
    so we can embrace the programming principle **Don't Repeat Yourself** (**DRY**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must bear in mind that we are going to write software for a microcontroller
    that has at most 512 KB of available memory to store the code. Moreover, we have
    the 96 KB of SRAM limit in which the sketch creates and manipulates variables
    at runtime. For complex projects, we should always optimize our code to reduce
    the used memory, but for the purpose of this book, we write the code so that it's
    more readable and easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print Hello World! on our screen, we need to code a sketch that writes a
    String into the built-in serial port. This sketch can be implemented with the
    following easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `setup()` function, initialize the serial port with the specified data
    rate expressed in **bits per second** (**baud**), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We choose `115200` baud per second, because the onboard Arduino Due supports
    this data rate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write into the serial port using the `println()`function within the main `loop()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even if we are tempted to upload our project, we have to bear in mind that the
    `loop()` function is called over and over and this means that maybe we will receive
    too many Hello World! instances. A good thing is to add a `delay()` function so
    that Arduino waits for the given milliseconds before starting with the `loop()`
    function again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To print one sentence per second, add the highlighted code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we are ready to start the upload process. It consists of two phases where
    our code is first compiled and then uploaded to the SAM3X processor. If we upload
    two different sketches, the latest one overrides the first one because we can
    load and execute only one sketch at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we need to configure the IDE so it can program the correct board
    connected to the correct serial port. Click on **Tools**, hover over **Boards**
    and choose **Arduino Due (programming port)**. Now click on **Tools**, hover over
    **Port**, and choose your configured port. The correct port depends on your operating
    system and usually they have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows: The `COM` port with the highest number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Mac OS X: `/dev/tty.SLAB_USBtoUART`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Linux: `/dev/ttyUSB0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To upload the program, click on **File** and then on **Upload** or use the
    shortcut available in the toolbar. If the upload process goes fine, you will see
    the logger with the following output in the bottom of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading the first program](img/1942OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To be sure that our first sketch works as expected, we need to use a serial
    port reader, and the Arduino IDE provides a built-in serial monitor. Click on
    **Tools** and then on **Serial Monitor**, or use the shortcut available in the
    toolbar. We may see some strange characters and this occurs because the serial
    monitor is configured by default to read the serial at 9600 baud. In the bottom-right
    dropdown, select **115200 baud** to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading the first program](img/1942OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `Serial.println()` function allows you to send data through the serial
    port. This is not used to communicate with the i.MX6 processor, but it's a great
    way to debug variables or your sketch flow from your computer.
  prefs: []
  type: TYPE_NORMAL
- en: When we've finished the sketch upload, we can plug in the **J18 jumper**. Now
    that we know how to deploy Android applications and Arduino sketches, it's time
    to start from scratch and build our first project.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first real-world prototype should be an Android application that we can
    use to control a simple electronic component. We have to choose something that
    is not too trivial, so we can experiment with it, but also that it is not too
    complex, so we can dive into all main concepts without too many implementation
    details. A good starting point is the creation of a controller that we can use
    to turn on and off a real **Light Emitting Diode** (**LED**) component.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we proceed, we have to understand how to create a communication
    between the Android application and the sketch. During the deployment process,
    we used to enable the external OTG port to communicate with the i.MX6 processor
    from our computer. If we disable this option, an internal switch activates a bidirectional
    communication between the i.MX6 and the SAM3X processors. This is possible because
    Arduino Due has full support for USB OTG connection and we are using this connection
    to let Android and Arduino communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the above software switch isn't very useful if we don't have
    a communication protocol. This is where the **Accessory Development Kit** (**ADK**)
    plays an important role. It's a reference implementation developed by Google to
    build Android accessories and it provides a set of software libraries. UDOO board
    has the full support of ADK. By combining the internal Android APIs with the external
    Arduino library, we can easily use this functionality to send commands and receive
    data. In this way, our Android sees our Arduino device like an *Android accessory*
    so that the connection is supported in our application and in the whole system.
    We can find further details about ADK at [http://developer.android.com/tools/adk/index.html](http://developer.android.com/tools/adk/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step of this prototype is to start a new sketch and set up the initial
    connection from the Arduino side. On the top of our empty sketch, we should add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `adk.h` header file contains all the required declarations for many utilities
    and functions that we can use, for example, to initialize the ADK connection,
    to send hardware information to Android, and read and write buffered data between
    the two processors. In the preceding code, we're also defining two *macro objects*,
    which, respectively, provide the maximum dimension of the read and write buffer
    and what is the used pinout to turn on and off the LED. We have to keep in mind
    this number because we will reuse it later when we connect our first electronic
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the protocol used by the ADK, Arduino is recognized by Android like
    an external accessory. To distinguish our accessory among the others, Android
    needs an **accessory descriptor** that we can provide with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provide information about the accessory name, the name of the hardware
    manufacturer and the unique identifier of the model. Other than these prototype
    descriptors, we have to define the hardware version and the serial number because
    they are strongly required when we connect the device to the Android application.
    Indeed, the `versionNumber`, the `model` and the `manufacturer` parameters will
    be matched with the values we provide to the Android application later, and if
    there is a mismatch, our sketch will not be recognized by the Android application.
    In this way, we can also maintain a strong binding between the application version
    and the hardware version in order to avoid an older Android application wrongly
    controlling a new hardware release.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding descriptor is required to recognize the sketch and the hardware
    from the Android application. However, bear in mind that this is a part of good
    *programming etiquette* and that, for every application and prototype, you should
    always provide version numbering together with a change log. In this book, we
    will use **semantic versioning** and you can find more information about it at
    [http://semver.org](http://semver.org).
  prefs: []
  type: TYPE_NORMAL
- en: The latest parameter is the `url` that is used by Android to redirect users
    to a website where they can find further information about the connected accessory.
    Android will show that message every time it does not find an installed application
    capable of managing the interaction with the Arduino accessory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, it's a good idea to set the `url` parameter with a link that
    will download and install the packaged Android application. In this way, if the
    Android application is missing, we are providing a fast way to retrieve and install
    it, and this is particularly useful when we're distributing schematics and sketches
    of our prototypes to other developers. You can find further information about
    how to create a packaged application with Android Studio at [https://developer.android.com/tools/building/building-studio.html](https://developer.android.com/tools/building/building-studio.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the ADK configuration, we have to add the following code below the
    previous declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are declaring the used `buffer` parameter during read and write operations
    and an `USBHost` object. We use it to initialize the connection in the main `loop()`
    function so that Android receives all the required information during the discovery
    process. In the last line, we are initializing the ADK accessory descriptor with
    defined values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the connection, we should put the following code into the `loop()`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Usb.Task()` function call polls connected USB devices for updates to their
    status and waits for 5 seconds to see whether any devices respond to the update
    request. When Android responds to the polling, we use a conditional statement
    to evaluate the `adk.isReady()` function call. It returns `True` when the device
    is connected and ready to communicate with Android, so we know exactly when the
    Android system reads the prototype descriptor and when it notifies the installed
    applications that a new accessory is connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our initial configuration is done and we can upload our sketch into the board.
    When the sketch is uploaded and we disable the OTG external port, Android will
    discover the running accessory and then show a message to notify users that there
    aren''t any available applications that will work with the attached USB accessory.
    It also gives users the opportunity to follow the chosen URL, as you can see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communicating with Arduino](img/1942OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing an Android application controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first building block is ready, but at the moment it doesn't have any physical
    actuator that we can use, nor a user interface to control it. For this reason,
    our next step is to create our second Android project through Android Studio called
    **LEDLamp**. As we did in our first application, remember to choose **API level
    19** and a **Blank Activity** that we can call **LightSwitch**.
  prefs: []
  type: TYPE_NORMAL
- en: When the activity editor shows up, it would be a good idea to change the visual
    preview of the user interface because we're going to use the monitor view instead
    of a common smartphone view. We can change it through the **Preview** tab that
    you can find on the right of the application screen and there we can select **Android
    TV (720p)**from the contextual menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we need a really simple activity, we have to change the default layout
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `res/layout/activity_light_switch.xml` file, change the `RelativeLayout`
    parameter in a vertical `LinearLayout` parameter, as you can see in the following
    code that is highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the preceding `LinearLayout` change the default `TextView` parameter
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a title that we place at the top of the layout. Below this view, we
    will place all the available controlled devices, like our first LED.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Below the previous `TextView` add the following `Switch` view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To keep the user interface simple, we need a button that we can use to turn
    the LED on and off. For this purpose, we are going to use a switch button so that
    we can send the action to the microcontroller, and at the same time, give a visual
    feedback of what the actual LED status is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In our Android applications, it's always a good idea to have a visual feedback
    about what the microcontroller is doing. In this way, we can easily know the state
    of the sketch and this may help us to find anomalies. This becomes relevant especially
    when the real-world device doesn't give any immediate feedback to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Without any further customizations, the following screenshot is the expected
    user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing an Android application controller](img/1942OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To try it in our board, we can proceed with the application deployment like
    we did in the previous chapter, and then we can proceed to write the ADK communication
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Android Accessory Development Kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable Android ADK in our application, we need to add some configurations
    to our `AndroidManifest.xml` file. Because we are using a *special feature* of
    the Android system, which relies on the available hardware, we need to add the
    following declaration at the top of our `manifest` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application registers itself into the system, it should declare the
    capability to respond to events raised when a USB accessory is attached. To achieve
    this, we need to add an *intent filter* to our `LightSwitch` activity declaration
    with the highlighted code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Android system requires the same accessory information that we filled in
    the Arduino sketch previously. Indeed, we have to provide the manufacturer, the
    model, and the version of our accessory, and to keep things organized, we can
    create the folder `res/xml/` and put inside an XML file named `usb_accessory_filter.xml`.
    In this file, we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To include the preceding file into the Android manifest, simply add the following
    code below the USB intent filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that our application is ready for the discovery process, we need to include
    some logic to establish the link and start to send data through the ADK.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this prototype, we are going to use the ADK through the Android internal
    API. Starting from [Chapter 4](ch04.html "Chapter 4. Using Sensors to Listen to
    the Environment"), *Using Sensors to Listen to the Environment*, we will use a
    high-level abstraction through an external library that will help us to implement
    our projects more easily and without any boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to isolate some of the ADK functionalities in a new Java package
    to organize our work better. We need to create a new package named `adk`, and
    we should add in it a new class called `Manager`. In this class, we need to use
    the `UsbManager` class that we got from the Android `Context` parameter, a file
    descriptor, and an output stream to write data in the OTG port. Add the following
    code in the `Manager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java snippets require many imports at the top of the file, which are intentionally
    missing for better code readability. However, to let everything work as expected,
    we need to write them and use the autocomplete function available in Android Studio.
    When you find a missing import, just place the cursor above the statement colored
    in red and press the *Ctrl*+*Space* keys. We can now choose the right import from
    the suggestion box.
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect the `UsbManager` method as a parameter because we don''t have access
    to the Android `Context`, and we will get it later from the main activity. To
    simplify our work during the ADK communication, the following helpers should be
    contained within our wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openAccessory()`: When a device is found, it should open a connection with
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeAccessory()`: If any device is connected, it should close and release
    any used resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeSerial()`: With a connected device, it should send data through opened
    streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first helper that opens a connection with the accessory and initializes
    the related output stream could be realized with the following method that we
    should add at the bottom of the `Manager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the stored `UsbManager` object to get all the available accessories.
    If we have at least one accessory, we open it to initialize a descriptor and an
    output stream that we will use later to send data to the accessory. To close the
    above connection, we could add the second helper as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have already opened an accessory, we use the created descriptor to close
    the activated streams and then we release the reference from the instance variable.
    Now we can add the latest write helper that includes the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method writes the given `value` into the enabled output stream.
    In this way, if an accessory is connected, we use the output stream reference
    to write into the OTG port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to create a `Manager` class instance in our activity, so we
    can use it to open a communication with Arduino. In the `onCreate` method of the
    `LightSwitch` activity, add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are querying the system for the USB service, so we can use it inside our
    `Manager` class to access the state and the functions of USB accessories. We store
    the `Manager` class reference inside the class so that we can access our helpers
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Manager` class is initialized, we should open and close our accessory
    contextually to the opening and the closing of the activity. Indeed, usually,
    it''s a good idea to call the `openAccessory()` and the `closeAccessory()` functions
    in the activity `onResume()` and `onPause()` callbacks. In this way, we''re sure
    that the ADK communication is initialized when we start to use it within our activity
    methods. To achieve this last building block to implement the ADK communication,
    add the following methods below the `onCreate()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the Android application is ready, we can proceed with the deployment,
    and when we disable the external OTG port, the following message appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Accessory Development Kit](img/1942OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Android system has discovered the physical accessory and is asking permission
    to work with it using the LED Lamp application. If we click on **OK**, the application
    will be opened. We can even set our application as *default*; so, whenever the
    accessory starts to communicate with the Android system, our application will
    be launched immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Fast prototyping a circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a fully functional communication between Android and Arduino and now
    it's the time to build a real circuit. Our goal is to turn on and off an LED using
    the Android system and this problem is little and self-contained. However, at
    the beginning, we could be a little more ambitious and, instead of turning on
    an LED, we may want to turn on a light bulb in our bedroom. So why create such
    a simple project while we can make things a little more interesting? Because we
    are **fast prototyping** our project.
  prefs: []
  type: TYPE_NORMAL
- en: Fast prototyping is a group of techniques that we can use to create our working
    project as soon as possible. This is really helpful because we are removing many
    implementation details, such as the product design, keeping the focus only on
    the core of our project. In our case, we are removing all the problems related
    to turning on a light bulb, like the use of a transistor, a relay, and an external
    battery, and we're focusing on the creation of a light switch that is powered
    by the Android system. When the first prototype is working we can increase the
    requirements, step by step, until we realize the final project.
  prefs: []
  type: TYPE_NORMAL
- en: Using a breadboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To proceed with our project, we should create a circuit prototype. We can use
    many tools to achieve this goal but one of the most important, at the beginning,
    is the **breadboard**. It can be used to connect our board and other electric
    components without soldering. This allows us to experiment with circuits design
    while reusing the breadboard for other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a breadboard](img/1942OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A breadboard is composed of two identical parts that are separated by a middle
    horizontal row that breaks any connection between the two sides. Each side contains
    a red and a blue row, at the top or at the bottom of the side, and they represent
    the *power bus*. They are connected for the whole horizontal line and we will
    use it to connect the power and ground of the UDOO board. The colors, usually,
    represent the power in red and the ground in blue, but bear in mind that this
    is just a convention and the colors of your breadboard may be different.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining five horizontal lines are the *prototyping area* and this is where
    we connect our devices. Despite the power bus, these lines are connected vertically
    while there is no connection between the horizontal line. For instance, if we
    plug a **jump wire** inside the hole A1, a metal strip creates the electrical
    connection with the holes starting from B1 through E1\. On the other hand, the
    holes in the range A2–E2 and F1–J1 aren't connected with our A1–E1 columns.
  prefs: []
  type: TYPE_NORMAL
- en: As our first prototype, we are going to connect our LED to our UDOO using the
    breadboard connections. However, we need another electric component that is called
    as the *resistor*. It creates an opposition to the passage of electrical current
    through the wire and it's necessary; otherwise, too much current can break the
    component. On the other hand, if we make too much electrical resistance, not enough
    current will flow through the component and it will not work. The electrical resistance
    of this component is measured in *Ohm*, and in our case, we need a *220 Ohm* resistor
    power the LED correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to connect our components to the breadboard as we can see in the
    following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a breadboard](img/1942OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to connect the pinout 2 to the positive line of the power bus while
    the ground should be connected to the negative line. We then connect the LED into
    the prototyping area and put the resistor before the *positive lead*. We can distinguish
    the LED **polarity** *looking at its legs*: the longer leg is the positive lead
    while the smaller is the negative lead. Keeping this in mind, we can connect the
    long leg to the resistor. To close the circuit, we simply connect the resistor
    to the positive line of the power bus and the negative leg of the LED to the ground
    line. We have made our first circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LED should be powered Off but it's possible that a small quantity of current
    flows through it. This could be caused by our Arduino sketch that doesn't disable
    the pin by default. This behavior is safe and we will manage this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with external circuits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we have a working communication and a prototyped circuit. The
    last step we should achieve is to send the turn on and off signal from the Android
    application and to parse and execute this command in the sketch. We can start
    from our sketch in which we need to configure the pinout to work as an output
    pin. These kinds of configurations are done in the `setup()`function; inside it,
    we should add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With the `pinMode()` function, we are declaring that the chosen pin will work
    as `OUTPUT` so we can control the current flow through it. Because we have previously
    defined the `LED` macro object, it refers to pin 2\. The `digitalWrite()` function
    is another abstraction of the Arduino language and we use it to let current flow,
    or not, into the chosen pin. In this case, we are saying that no current should
    flow through the pin because in the initialization step, we want the LED powered
    off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the Android application will send us a command that can have only `0`
    and `1` values, we need a function to parse this command so that Arduino knows
    what is the related action. To achieve this, we can simply add an `executor()`
    function at the bottom of our sketch as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a switch that parses the `command` parameter. If the value is
    `0`, Arduino uses the `digitalWrite()` function to turn off the LED; however,
    if the value is `1`, it uses the same function to turn the LED on. In any other
    case, we are just discarding the received command.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to put things together in our main `loop()` function
    inside the `adk.isReady` condition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: During the main `loop()` function, if we find an ADK connection, we read any
    messages from the communication channel and we write the result in our `buffer`
    variable through the `adk.read()` function call. If we read at least 1 byte, we
    pass the first value of the bytes array to the `executor()` function. After this
    step, we can upload the sketch into the UDOO board.
  prefs: []
  type: TYPE_NORMAL
- en: Sending commands from Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that UDOO is ready to take physical actions, we have to complete the Android
    application and implement the command sending within the `LightSwitch` class.
    As the first step, we need to add to our activity a variable to store the LED
    status. At the top of our class, add the `mSwitchLed` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do is to create a method that uses the ADK writing wrapper
    to send a command to Arduino. Below the `onCreate()` method, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are changing the state of the LED and create from it the resulting `command`
    parameter, which could be of `0` or `1` values. We then use the `mManager` to
    write the command into the OTG port. To complete the application, we just need
    to bind the `switchLight` method to our view. Into the `activity_light_switch.xml`
    file, add the `onClick()` attribute to our switch button like follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This was our final step and we now have our first real-world prototype. We can
    now upload the Android application into the UDOO board and use it to turn on and
    off the LED.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned some of the UDOO characteristics related to
    available input and output pins, and how both processors are connected together
    via the internal serial bus. Moreover, in the first part, we wrote and deployed
    our first sketch into the board.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delved the communication mechanism realized through the ADK and wrote
    a new Arduino sketch capable of establishing a communication with Android using
    the internal OTG port. Doing the same for Android, we created a simple user interface
    to provide a visual feedback during the device usage. We also wrote in our Android
    application some wrappers to easily expose commonly used ADK methods to open and
    close the connection, and to write into the communication channel.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, you learned how to use a breadboard to fast prototype
    a circuit and you built your first one using an LED and a resistor. Then, we added
    all the required code to send the turn on and off signal from our Android application
    and to receive and execute this command from the sketch. This was a more complex
    Hello World application that was really helpful to build our first real-world
    device.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend the above circuit with a debugging feature
    so that we can test our hardware and see if our device has any broken electronic
    components.
  prefs: []
  type: TYPE_NORMAL
