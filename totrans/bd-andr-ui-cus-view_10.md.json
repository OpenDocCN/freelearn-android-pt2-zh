["```kt\nprotected void onDraw(Canvas canvas) {\n    int startPadding = getPaddingStart();\n    int topPadding = getPaddingTop();\n\n    int width = canvas.getWidth() - startPadding - getPaddingEnd();\n    int height = canvas.getHeight() - topPadding - getPaddingBottom();\n}\n```", "```kt\npublic class Chart extends View {\n    private Paint linePaint;\n\n    public Chart(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        linePaint = new Paint();\n        linePaint.setAntiAlias(true);\n        linePaint.setColor(0xffffffff);\n        linePaint.setStrokeWidth(8.f);\n        linePaint.setStyle(Paint.Style.STROKE);\n    }\n}\n```", "```kt\nprivate float[] dataPoints;\nprivate float minValue;\nprivate float maxValue;\nprivate float verticalDelta;\n\npublic void setDataPoints(float[] originalData) {\n    dataPoints = new float[originalData.length];\n    minValue = Float.MAX_VALUE;\n    maxValue = Float.MIN_VALUE;\n    for (int i = 0; i< dataPoints.length; i++) {\n        dataPoints[i] = originalData[i];\n        if (dataPoints[i] <minValue) minValue = dataPoints[i];\n        if (dataPoints[i] >maxValue) maxValue = dataPoints[i];\n    }\n\n    verticalDelta = maxValue - minValue;\n    postInvalidate();\n}\n```", "```kt\n@Override\nprotected void onDraw(Canvas canvas) {\n    canvas.drawARGB(255,0 ,0 ,0);\n\n    float leftPadding = getPaddingLeft();\n    float topPadding = getPaddingTop();\n\n    float width = canvas.getWidth() - leftPadding - getPaddingRight();\n    float height = canvas.getHeight() - topPadding -\n    getPaddingBottom();\n\n    float lastX = getPaddingStart();\n    float lastY = height * ((dataPoints[0] - minValue) / verticalDelta)\n    + topPadding;\n\n    for (int i = 1; i < dataPoints.length; i++) {\n        float y = height * ((dataPoints[i] - minValue) / verticalDelta)\n        + topPadding;\n        float x = width * (((float) i + 1) / dataPoints.length) +\n        leftPadding;\n\n        canvas.drawLine(lastX, lastY, x, y, linePaint);\n        lastX = x;\n        lastY = y;\n    }\n}\n```", "```kt\npublic void setDataPoints(float[] originalData) {\n    dataPoints = new float[originalData.length];\n\n    float minValue = Float.MAX_VALUE;\n    float maxValue = Float.MIN_VALUE;\n    for (int i = 0; i < dataPoints.length; i++) {\n        dataPoints[i] = originalData[i];\n        if (dataPoints[i] < minValue) minValue = dataPoints[i];\n        if (dataPoints[i] > maxValue) maxValue = dataPoints[i];\n    }\n\n    float verticalDelta = maxValue - minValue;\n\n    for (int i = 0; i < dataPoints.length; i++) {\n        dataPoints[i] = (dataPoints[i] - minValue) / verticalDelta;\n    }\n\n    postInvalidate();\n}\n```", "```kt\n@Override\nprotected void onDraw(Canvas canvas) {\n    canvas.drawARGB(255,0 ,0 ,0);\n\n    float leftPadding = getPaddingLeft();\n    float topPadding = getPaddingTop();\n\n    float width = canvas.getWidth() - leftPadding - getPaddingRight();\n    float height = canvas.getHeight() - topPadding -\n    getPaddingBottom();\n\n    float lastX = getPaddingStart();\n    float lastY = height * dataPoints[0] + topPadding;\n    for (int i = 1; i < dataPoints.length; i++) {\n        float y = height * dataPoints[i] + topPadding;\n        float x = width * (((float) i) / dataPoints.length) +\n        leftPadding;\n\n        canvas.drawLine(lastX, lastY, x, y, linePaint);\n\n        lastX = x;\n        lastY = y;\n    }\n}\n```", "```kt\nprivate Path graphPath; \n\n@Override\nprotected void onDraw(Canvas canvas) {\n    canvas.drawARGB(255,0 ,0 ,0);\n\n    float leftPadding = getPaddingLeft();\n    float topPadding = getPaddingTop();\n\n    float width = canvas.getWidth() - leftPadding - getPaddingRight();\n    float height = canvas.getHeight() - topPadding - \n    getPaddingBottom();\n\n    if (graphPath == null) {\n        graphPath = new Path();\n\n        graphPath.moveTo(leftPadding, height * dataPoints[0] +\n        topPadding);\n\n        for (int i = 1; i < dataPoints.length; i++) {\n            float y = height * dataPoints[i] + topPadding;\n            float x = width * (((float) i + 1) / dataPoints.length) +\n            leftPadding;\n\n            graphPath.lineTo(x, y);\n        }\n    }\n\n    canvas.drawPath(graphPath, linePaint);\n}\n\n```", "```kt\nprivate boolean regenerate; \nprivate float lastWidth; \nprivate float lastHeight; \n```", "```kt\ngraphPath = new Path(); \nlastWidth = -1; \nlastHeight = -1; \n```", "```kt\nif (lastWidth != width || lastHeight != height) {\n    regenerate = true;\n\n    lastWidth = width;\n    lastHeight = height;\n}\n```", "```kt\nif (regenerate) {\n    graphPath.reset();\n    graphPath.moveTo(leftPadding, height * dataPoints[0] + topPadding);\n\n    for (int i = 1; i < dataPoints.length; i++) {\n        float y = height * dataPoints[i] + topPadding;\n        float x = width * (((float) i + 1) / dataPoints.length) +\n        leftPadding;\n\n        graphPath.lineTo(x, y);\n    }\n\n    regenerate = false;\n}\n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout \n\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n\n    tools:context=\"com.rrafols.packt.chart.MainActivity\">\n\n    <com.rrafols.packt.chart.Chart\n        android:layout_margin=\"16dp\"\n        android:padding=\"10dp\"\n        android:id=\"@+id/chart_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n</LinearLayout>\n```", "```kt\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n   super.onCreate(savedInstanceState);\n   setContentView(R.layout.activity_main);\n\n   Chart chart = (Chart) findViewById(R.id.chart_view);\n\n   float[] data = new float[20];\n   for (int i = 0; i < data.length; i++) {\n       data[i] = (float) Math.random() * 10.f;\n   }\n\n   chart.setDataPoints(data);\n}\n```", "```kt\ncirclePaint = new Paint(); \ncirclePaint.setAntiAlias(true); \ncirclePaint.setColor(0xffff2020); \ncirclePaint.setStyle(Paint.Style.FILL); \n```", "```kt\n@Override\nprotected void onDraw(Canvas canvas) {\n    canvas.drawARGB(255,0 ,0 ,0);\n\n    float leftPadding = getPaddingLeft();\n    float topPadding = getPaddingTop();\n\n    float width = canvas.getWidth() - leftPadding - getPaddingRight();\n    float height = canvas.getHeight() - topPadding -\n    getPaddingBottom();\n\n    if (lastWidth != width || lastHeight != height) {\n\n        regenerate = true;\n\n        lastWidth = width;\n        lastHeight = height;\n    }\n\n    if (regenerate) {\n        circlePath.reset();\n        graphPath.reset();\n\n        float x = leftPadding;\n        float y = height * dataPoints[0] + topPadding;\n\n        graphPath.moveTo(x, y);\n        circlePath.addCircle(x, y, 10, Path.Direction.CW);\n\n        for (int i = 1; i < dataPoints.length; i++) {\n            y = height * dataPoints[i] + topPadding;\n            x = width * (((float) i + 1) / dataPoints.length) +\n            leftPadding;\n\n            graphPath.lineTo(x, y);\n            circlePath.addCircle(x, y, 10, Path.Direction.CW);\n        }\n\n        regenerate = false;\n    }\n\n    canvas.drawPath(graphPath, linePaint);\n    canvas.drawPath(circlePath, circlePaint);\n}\n```", "```kt\nbackgroundPaint = new Paint(); \nbackgroundPaint.setColor(0xffBBBB40); \nbackgroundPaint.setStyle(Paint.Style.STROKE); \nbackgroundPaint.setPathEffect(new DashPathEffect(new float[] {5, 5}, 0)); \n```", "```kt\n@Override\nprotected void onDraw(Canvas canvas) {\n    canvas.drawARGB(255,0 ,0 ,0);\n\n    float leftPadding = getPaddingLeft();\n    float topPadding = getPaddingTop();\n\n    float width = canvas.getWidth() - leftPadding - getPaddingRight();\n    float height = canvas.getHeight() - topPadding -\n    getPaddingBottom();\n\n    if (lastWidth != width || lastHeight != height) {\n        regenerate = true;\n\n        lastWidth = width;\n        lastHeight = height;\n    }\n\n    if (regenerate) {\n        circlePath.reset();\n        graphPath.reset();\n        backgroundPath.reset();\n\n for (int i = 0; i <= dataPoints.length; i++) {\n float xl = width * (((float) i) / dataPoints.length) +\n leftPadding;\n backgroundPath.moveTo(xl, topPadding);\n backgroundPath.lineTo(xl, topPadding + height);\n }\n\n for (int i = 0; i <= 10; i++) {\n float yl = ((float) i / 10.f) * height + topPadding;\n backgroundPath.moveTo(leftPadding, yl);\n backgroundPath.lineTo(leftPadding + width, yl);\n }\n\n        float x = leftPadding;\n        float y = height * dataPoints[0] + topPadding;\n\n        graphPath.moveTo(x, y);\n        circlePath.addCircle(x, y, 10, Path.Direction.CW);\n\n        for (int i = 1; i < dataPoints.length; i++) {\n            x = width * (((float) i + 1) / dataPoints.length) + \n           leftPadding;\n            y = height * dataPoints[i] + topPadding;\n\n            graphPath.lineTo(x, y);\n            circlePath.addCircle(x, y, 10, Path.Direction.CW);\n        }\n\n        regenerate = false;\n    }\n\n    canvas.drawPath(backgroundPath, backgroundPaint);\n    canvas.drawPath(graphPath, linePaint);\n    canvas.drawPath(circlePath, circlePaint);\n}\n```", "```kt\nprivate String[] labels; \n\npublic void setLabels(String[] labels) {\n    this.labels = labels;\n}\n\n```", "```kt\nif (labels == null) {\n     labels = new String[dataPoints.length + 1];\n     for (int i = 0; i < labels.length; i++) {\n         labels[i] = \"\" + i;\n     }\n }\n```", "```kt\nprivate Rect textBoundaries = new Rect(); \n```", "```kt\nfor (int i = 0; i <= dataPoints.length; i++) {\n    float xl = width * (((float) i) / dataPoints.length) + leftPadding;\n    backgroundPaint.getTextBounds(labels[i], 0, labels[i].length(),\n    textBoundaries);\n    canvas.drawText(labels[i], \n        xl - (textBoundaries.width() / 2), \n        height + topPadding + backgroundPaint.getTextSize() * 1.5f, \n        backgroundPaint);\n}\n```", "```kt\nfloat height = canvas.getHeight() - topPadding - getPaddingBottom() \n        - backgroundPaint.getTextSize() + 0.5f; \n```", "```kt\nfloat maxLabelWidth = 0.f;\n\nfor (int i = 0; i <= 10; i++) {\n    float step = ((float) i / 10.f);\n    float value = step * verticalDelta + minValue;\n    verticalLabels[i] = decimalFormat.format(value);\n    backgroundPaint.getTextBounds(verticalLabels[i], 0,\n    verticalLabels[i].length(), textBoundaries);\n    if (textBoundaries.width() > maxLabelWidth) {\n        maxLabelWidth = textBoundaries.width();\n    }\n}\n```", "```kt\ndecimalFormat = new DecimalFormat(\"#.##\"); \n```", "```kt\nfloat labelLeftPadding = getPaddingLeft() + maxLabelWidth * 0.25f; \nfloat leftPadding = getPaddingLeft() + maxLabelWidth * 1.5f; \n```", "```kt\nfor (int i = 0; i <= 10; i++) {\n    float step = ((float) i / 10.f);\n    float yl = step * height + topPadding- (backgroundPaint.ascent() +\n    backgroundPaint.descent()) * 0.5f;\n    canvas.drawText(verticalLabels[i],\n        labelLeftPadding, \n        yl, \n        backgroundPaint);\n}\n```", "```kt\nfloat labelLeftPadding = getPaddingLeft() + maxLabelWidth * 0.25f; \nfloat leftPadding = getPaddingLeft() + maxLabelWidth * 1.5f; \nfloat rightPadding = getPaddingRight(); \nfloat topPadding = getPaddingTop(); \n\nfloat width = canvas.getWidth() - leftPadding - rightPadding; \nfloat height = canvas.getHeight() - topPadding - getPaddingBottom() \n        - backgroundPaint.getTextSize() + 0.5f; \n\nif (getLayoutDirection() == LAYOUT_DIRECTION_RTL) { \n    leftPadding = getPaddingEnd(); \n    labelLeftPadding = leftPadding + width + maxLabelWidth * 0.25f; \n} \n```", "```kt\nprivate boolean invertVerticalAxis;\n\npublic void setInvertVerticalAxis(boolean invertVerticalAxis) {\n    this.invertVerticalAxis = invertVerticalAxis;\n    regenerate = true;\n    postInvalidate();\n}\n```", "```kt\nfloat maxLabelWidth = 0.f;\nif (regenerate) {\n    for (int i = 0; i <= 10; i++) {\n        float step;\n\n        if (!invertVerticalAxis) {\n step = ((float) i / 10.f);\n } else {\n step = ((float) (10 - i)) / 10.f;\n }\n\n        float value = step * verticalDelta + minValue;\n        verticalLabels[i] = decimalFormat.format(value);\n        backgroundPaint.getTextBounds(verticalLabels[i], 0,\n        verticalLabels[i].length(), textBoundaries);\n        if (textBoundaries.width() > maxLabelWidth) {\n            maxLabelWidth = textBoundaries.width();\n        }\n    }\n}\n```", "```kt\nprivate float getDataPoint(int i) { \n    float data = dataPoints[i]; \n    return invertVerticalAxis ? 1.f - data : data; \n} \n```", "```kt\nprivate boolean drawLegend;\n\npublic void setDrawLegend(boolean drawLegend) {\n    this.drawLegend = drawLegend;\n    regenerate = true;\n    postInvalidate();\n}\n```", "```kt\nprivate ArrayList<Float> dataPoints;\n\npublic void setDataPoints(float[] originalData) {\n    ArrayList<Float> array = new ArrayList<>();\n    for (float data : originalData) {\n        array.add(data);\n    }\n\n    setDataPoints(array);\n}\n\npublic void setDataPoints(ArrayList<Float> originalData) {\n    dataPoints = new ArrayList<Float>();\n    dataPoints.addAll(originalData);\n\n    adjustDataRange();\n}\n```", "```kt\nprivate void adjustDataRange() {\n    minValue = Float.MAX_VALUE;\n    maxValue = Float.MIN_VALUE;\n    for (int i = 0; i < dataPoints.size(); i++) {\n        if (dataPoints.get(i) < minValue) minValue = dataPoints.get(i);\n        if (dataPoints.get(i) > maxValue) maxValue = dataPoints.get(i);\n    }\n\n    verticalDelta = maxValue - minValue;\n\n    regenerate = true;\n    postInvalidate();\n}\n```", "```kt\npublic void addValue(float data) {\n    dataPoints.add(data);\n\n    if (data < minValue || data > maxValue) {\n        adjustDataRange();\n    } else {\n        regenerate = true;\n        postInvalidate();\n    }\n}\n```", "```kt\nprivate float getDataPoint(int i) { \n    float data = (dataPoints.get(i) - minValue) / verticalDelta; \n    return invertVerticalAxis ? 1.f - data : data; \n} \n```", "```kt\nlinePaint = new Paint[2]; \nlinePaint[0] = new Paint(); \nlinePaint[0].setAntiAlias(true); \nlinePaint[0].setColor(0xffffffff); \nlinePaint[0].setStrokeWidth(8.f); \nlinePaint[0].setStyle(Paint.Style.STROKE); \n\nlinePaint[1] = new Paint(); \nlinePaint[1].setAntiAlias(true); \nlinePaint[1].setColor(0xff4040ff); \nlinePaint[1].setStrokeWidth(8.f); \nlinePaint[1].setStyle(Paint.Style.STROKE); \ncirclePaint = new Paint[2]; \ncirclePaint[0] = new Paint(); \ncirclePaint[0].setAntiAlias(true); \ncirclePaint[0].setColor(0xffff2020); \ncirclePaint[0].setStyle(Paint.Style.FILL);  \ncirclePaint[1] = new Paint(); \ncirclePaint[1].setAntiAlias(true); \ncirclePaint[1].setColor(0xff20ff20); \ncirclePaint[1].setStyle(Paint.Style.FILL); \n```", "```kt\nlinePaint = new Paint[2]; \nlinePaint[0] = new Paint(); \nlinePaint[0].setAntiAlias(true); \nlinePaint[0].setColor(0xffffffff); \nlinePaint[0].setStrokeWidth(8.f); \nlinePaint[0].setStyle(Paint.Style.STROKE);\n\nlinePaint[1] = new Paint(linePaint[0]); \nlinePaint[1].setColor(0xff4040ff); \n\ncirclePaint = new Paint[2]; \ncirclePaint[0] = new Paint(); \ncirclePaint[0].setAntiAlias(true); \ncirclePaint[0].setColor(0xffff2020); \ncirclePaint[0].setStyle(Paint.Style.FILL); \n\ncirclePaint[1] = new Paint(circlePaint[0]); \ncirclePaint[1].setColor(0xff20ff20); \n```", "```kt\ngraphPath = new Path[2]; \ngraphPath[0] = new Path(); \ngraphPath[1] = new Path(); \n\ncirclePath = new Path[2]; \ncirclePath[0] = new Path(); \ncirclePath[1] = new Path(); \n\ndataPoints = (ArrayList<Float>[]) new ArrayList[2]; \n```", "```kt\npublic void setDataPoints(ArrayList<Float> originalData, int index) {\n    dataPoints[index] = new ArrayList<Float>();\n    dataPoints[index].addAll(originalData);\n\n    adjustDataRange();\n}\n```", "```kt\nprivate void adjustDataRange() {\n    minValue = Float.MAX_VALUE;\n    maxValue = Float.MIN_VALUE;\n    for (int j = 0; j < dataPoints.length; j++) {\n        for (int i = 0; dataPoints[j] != null && i <\n        dataPoints[j].size(); i++) {\n            if (dataPoints[j].get(i) < minValue) minValue =\n            dataPoints[j].get(i);\n            if (dataPoints[j].get(i) > maxValue) maxValue =\n            dataPoints[j].get(i);\n        }\n    }\n\n    verticalDelta = maxValue - minValue;\n\n    regenerate = true;\n    postInvalidate();\n}\n```", "```kt\nprivate float getDataPoint(int i, int index) { \n    float data = (dataPoints[index].get(i) - minValue) / verticalDelta; \n    return invertVerticalAxis ? 1.f - data : data; \n} \n```", "```kt\nfor (int j = 0; j < 2; j++) {\n    if (dataPoints[j] != null) {\n        float x = leftPadding;\n        float y = height * getDataPoint(0, j) + topPadding;\n\n        graphPath[j].moveTo(x, y);\n        circlePath[j].addCircle(x, y, 10, Path.Direction.CW);\n\n        for (int i = 1; i < dataPoints[j].size(); i++) {\n            x = width * (((float) i + 1) / dataPoints[j].size()) + \n            leftPadding;\n            y = height * getDataPoint(i, j) + topPadding;\n\n            graphPath[j].lineTo(x, y);\n            circlePath[j].addCircle(x, y, 10, Path.Direction.CW);\n        }\n    }\n}\n```", "```kt\nfor (int j = 0; j < graphPath.length; j++) {\n    canvas.drawPath(graphPath[j], linePaint[j]);\n    canvas.drawPath(circlePath[j], circlePaint[j]);\n}\n```", "```kt\nprivate boolean missingAnimations() {\n    if (Math.abs(scrollXTarget - scrollX) > ANIM_THRESHOLD) \n        return true;\n\n    if (Math.abs(scrollYTarget - scrollY) > ANIM_THRESHOLD)\n        return true;\n\n    return false;\n}\n\nprivate void animateLogic() {\n    long currentTime = SystemClock.elapsedRealtime();\n    accTime += currentTime - timeStart;\n    timeStart = currentTime;\n\n    while (accTime > TIME_THRESHOLD) {\n        scrollX += (scrollXTarget - scrollX) / 4.f;\n        scrollY += (scrollYTarget - scrollY) / 4.f;\n        accTime -= TIME_THRESHOLD;\n    }\n\n    float factor = ((float) accTime) / TIME_THRESHOLD;\n    float nextScrollX = scrollX + (scrollXTarget - scrollX) / 4.f;\n    float nextScrollY = scrollY + (scrollYTarget - scrollY) / 4.f;\n\n    frScrollX = scrollX * (1.f - factor) + nextScrollX * factor;\n    frScrollY = scrollY * (1.f - factor) + nextScrollY * factor;\n}\n```", "```kt\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    scaleDetector.onTouchEvent(event);\n\n    if (zooming) {\n        invalidate();\n        zooming = false;\n        return true;\n    }\n\n    switch(event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            dragX = event.getX();\n            dragY = event.getY();\n\n            getParent().requestDisallowInterceptTouchEvent(true);\n            dragged = false;\n            return true;\n\n        case MotionEvent.ACTION_UP:\n            getParent().requestDisallowInterceptTouchEvent(false);\n            return true;\n\n        case MotionEvent.ACTION_MOVE:\n            float newX = event.getX();\n            float newY = event.getY();\n\n            scrollScreen(dragX - newX, dragY - newY);\n\n            dragX = newX;\n            dragY = newY;\n            dragged = true;\n            return true;\n        default:\n            return false;\n    }\n}\n\nprivate void scrollScreen(float dx, float dy) {\n    scrollXTarget += dx;\n    scrollYTarget += dy;\n\n    if (scrollXTarget < 0) scrollXTarget = 0;\n    if (scrollYTarget < 0) scrollYTarget = 0;\n\n    if (scrollXTarget > getWidth() * scale - getWidth()) {\n        scrollXTarget = getWidth() * scale - getWidth();\n    }\n\n    if (scrollYTarget > getHeight() * scale - getHeight()) {\n        scrollYTarget = getHeight() * scale - getHeight();\n    }\n\n    invalidate();\n}\n```", "```kt\nscaleDetector = new ScaleGestureDetector(context, new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n    private float focusX;\n    private float focusY;\n    private float scrollCorrectionX = 0.f;\n    private float scrollCorrectionY = 0.f;\n\n    @Override\n    public boolean onScaleBegin(ScaleGestureDetector detector) {\n        zooming = true;\n        focusX = detector.getFocusX();\n        focusY = detector.getFocusY();\n        scrollCorrectionX = focusX * scale - scrollXTarget;\n        scrollCorrectionY = focusY * scale - scrollYTarget;\n        return true;\n    }\n\n    public boolean onScale(ScaleGestureDetector detector) {\n        scale *= detector.getScaleFactor();\n        scale = Math.max(1.f, Math.min(scale, 2.f));\n\n        float currentX = focusX * scale - scrollXTarget;\n        float currentY = focusY * scale - scrollYTarget;\n\n        scrollXTarget += currentX - scrollCorrectionX;\n        scrollYTarget += currentY - scrollCorrectionY;\n\n        invalidate();\n        return true;\n    }\n\n    @Override\n    public void onScaleEnd(ScaleGestureDetector detector) {\n        zooming = true;\n    }\n});\n```", "```kt\nanimateLogic(); \n\ncanvas.save(); \n\ncanvas.translate(-frScrollX, -frScrollY); \ncanvas.scale(scale, scale); \n```", "```kt\ncanvas.restore(); \nif (missingAnimations()) invalidate(); \n```"]