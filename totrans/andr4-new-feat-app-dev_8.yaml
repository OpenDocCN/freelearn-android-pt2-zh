- en: Chapter 8. New Connectivity APIs – Android Beam and Wi-Fi Direct
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章. 新的连接性API - Android Beam和Wi-Fi Direct
- en: New connectivity APIs have been introduced with Android Ice Cream Sandwich –
    **Android Beam** which uses the NFC hardware of the device, and **Wi-Fi Direct**
    which allows devices to connect to each other without using a wireless access
    point. This chapter will teach us Android Beam and Wi-Fi Direct APIs' usage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Android Ice Cream Sandwich的推出，引入了新的连接性API - **Android Beam**，它使用设备的NFC硬件，以及**Wi-Fi
    Direct**，允许设备在不使用无线接入点的情况下相互连接。本章将教我们如何使用Android Beam和Wi-Fi Direct API。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖的主题包括：
- en: Android Beam
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Beam
- en: Beaming NdefMessages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送NdefMessages
- en: Sharing data with Wi-Fi Direct
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wi-Fi Direct共享数据
- en: Android Beam
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Beam
- en: Devices that have NFC hardware can share data by tapping them together. This
    could be done with the help of the Android Beam feature. It is similar to Bluetooth,
    as we get seamless discovery and pairing as in a Bluetooth connection. Devices
    connect when they are close to each other (not more than a few centimeters). Users
    can share pictures, videos, contacts, and so on, using the Android Beam feature.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有NFC硬件的设备可以通过轻触在一起来共享数据。这可以通过Android Beam功能实现。它类似于蓝牙，因为我们能无缝地发现和配对，就像蓝牙连接一样。设备在彼此靠近时（不超过几厘米）连接。用户可以使用Android
    Beam功能共享图片、视频、联系人等。
- en: Beaming NdefMessages
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送NdefMessages
- en: 'In this section, we are going to implement a simple Android Beam application.
    This application will send an image to another device when two devices are tapped
    together. There are three methods that are introduced with Android Ice Cream Sandwich
    that are used in sending **NdefMessages**. These methods are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个简单的Android Beam应用程序。此应用程序将在两个设备轻触在一起时将图片发送到另一设备。随着Android Ice Cream
    Sandwich的推出，引入了三种用于发送**NdefMessages**的方法。这些方法如下：
- en: '**setNdefPushMessage()**: This method takes an NdefMessage as a parameter and
    sends it to another device automatically when devices are tapped together. This
    is commonly used when the message is static and doesn''t change.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setNdefPushMessage()**: 此方法接受一个NdefMessage作为参数，并在设备轻触在一起时自动将其发送到另一设备。当消息是静态的且不变化时，通常使用这种方法。'
- en: '**setNdefPushMessageCallback()**: This method is used for creating dynamic
    NdefMessages. When two devices are tapped together, the `createNdefMessage()`
    method is called.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setNdefPushMessageCallback()**: 此方法用于创建动态NdefMessages。当两个设备轻触在一起时，会调用`createNdefMessage()`方法。'
- en: '**setOnNdefPushCompleteCallback()**: This method sets a callback which is called
    when the Android Beam is successful.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setOnNdefPushCompleteCallback()**: 此方法设置一个回调，当Android Beam成功时调用。'
- en: We are going to use the second method in our sample application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例应用程序中使用第二种方法。
- en: 'Our sample application''s user interface will contain a `TextView` component
    for displaying text messages and an `ImageView` component for displaying the received
    images sent from another device. The layout XML code will be as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序的用户界面将包含一个`TextView`组件用于显示文本消息，以及一个`ImageView`组件用于显示从另一设备接收的图片。布局XML代码如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we are going to implement, step-by-step, the `Activity` class of the sample
    application. The code of the `Activity` class with the `onCreate()` method is
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步实现示例应用程序的`Activity`类。带有`onCreate()`方法的`Activity`类的代码如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in this code, we can check whether the device provides an `NfcAdapter`.
    If it does, we get an instance of `NfcAdapter`. Then, we call the `setNdefPushMessageCallback()`
    method to set the callback using the `NfcAdapter` instance. We send the `Activity`
    class as a callback parameter because the `Activity` class implements `CreateNdefMessageCallback`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此代码中看到的，我们可以检查设备是否提供`NfcAdapter`。如果提供，我们将获取`NfcAdapter`的实例。然后，我们使用`NfcAdapter`实例调用`setNdefPushMessageCallback()`方法来设置回调。我们将`Activity`类作为回调参数发送，因为`Activity`类实现了`CreateNdefMessageCallback`。
- en: 'In order to implement `CreateNdefMessageCallback`, we should override the `createNdefMessage()`
    method as shown in the following code block:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`CreateNdefMessageCallback`，我们应该重写`createNdefMessage()`方法，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in this code, we get a drawable, convert it to bitmap, and then
    to a byte array. Then we create an `NdefMessage` with two `NdefRecords`. The first
    record contains the mime type and the byte array. The first record is created
    by the `createMimeRecord()` method. The second record contains the **Android Application
    Record** (**AAR**). The Android Application Record was introduced with Android
    Ice Cream Sandwich. This record contains the package name of the application and
    increases the certainty that your application will start when an **NFC Tag** is
    scanned. That is, the system firstly tries to match the intent filter and AAR
    together to start the activity. If they don't match, the activity that matches
    the AAR is started.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'When the activity is started by an Android Beam event, we need to handle the
    message that is sent by the Android Beam. We handle this message in the `onResume()`
    method of the `Activity` class as shown in the following code block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in this code, we firstly check whether the intent is `ACTION_NDEF_DISCOVERED`.
    This means the `Activity` class is started due to an Android Beam. If it is started
    due to an Android Beam, we process the intent with the `processIntent()` method.
    We firstly get `NdefMessage` from the intent. Then we get the first record and
    convert the byte array in the first record to bitmap using `BitmapFactory`. Remember
    that the second record is AAR, we do nothing with it. Finally, we set the bitmap
    of the `ImageView` component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AndroidManifest.xml` file of the application should be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in this code, we need to set the minimum SDK to API Level 14
    or more in the `AndroidManifest.xml` file because these APIs are available in
    API Level 14 or more. Furthermore, we need to set the permissions to use NFC.
    We also set the `uses` feature in `AndroidManifest.xml`. The feature is set as
    not required. This means that our application would be available for devices that
    don't have NFC support. Finally, we create an intent filter for `android.nfc.action.NDEF_DISCOVERED`
    with `mimeType` of `application/com.chapter9`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'When a device sends an image using our sample application, the screen will
    be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Beaming NdefMessages](img/9526_09_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Wi-Fi Direct
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a conventional wireless network, devices are connected to each other through
    a wireless access point. With the help of **Wi-Fi Direct**, devices connect to
    each other without the need of a wireless access point. It's similar to Bluetooth,
    but it is faster and the range of Wi-Fi Direct is longer. New Wi-Fi Direct APIs
    are introduced with Android Ice Cream Sandwich which allows us to use Wi-Fi Direct
    properties of Android devices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The main class that will help us to find and connect peers is the `WifiP2pManager`
    class. We are going to use the following `Listener` classes during finding and
    connecting to peers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '`WifiP2pManager.ActionListener`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WifiP2pManager.ChannelListener`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WifiP2pManager.ConnectionInfoListener`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WifiP2pManager.PeerListListener`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the following intents will help us in a Wi-Fi Direct connection:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`WIFI_P2P_CONNECTION_CHANGED_ACTION`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WIFI_P2P_PEERS_CHANGED_ACTION`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WIFI_P2P_STATE_CHANGED_ACTION`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WIFI_P2P_THIS_DEVICE_CHANGED_ACTION`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to use these new Wi-Fi Direct APIs
    with a sample application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Sample Wi-Fi Direct application
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use Wi-Fi Direct APIs, we need to set the minimum SDK version to
    API Level 14 or more in `AndroidManifest.xml`. Furthermore, we need some permission
    to use Wi-Fi Direct APIs. The `AndroidManifest.xml` file should be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first class that we need is a class that extends `BroadcastReceiver` and
    handles the intents that we listed previously in the `onReceive()` method. The
    constructor of this class should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in this code, we passed the `Channel`, `WifiP2pManager`, and
    the `Activity` classes to the constructor as parameters because we will need them
    later in the `onReceive()` method. We need to override the `onReceive()` method
    of `BroadcastReceiver` as shown in the following code block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this method, we handle the received intents. Firstly, we check whether the
    intent is `WIFI_P2P_STATE_CHANGED_ACTION`. This intent is received when Wi-Fi
    Direct is enabled or disabled. We receive the Wi-Fi Direct status from the intent
    and take action according to the Wi-Fi Direct status.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we check whether the intent is `WIFI_P2P_PEERS_CHANGED_ACTION`. This
    intent is received when the `discoverPeers()` method of the `WifiP2pManager` class
    is called. We get the list of the peers from the `requestPeers()` method of the
    `Wifi2P2pManager` class when we receive the `WIFI_P2P_PEERS_CHANGED_ACTION` intent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the received intent is `WIFI_P2P_CONNECTION_CHANGED_ACTION`.
    This intent is received when the Wi-Fi connection changes. We handle connections
    or disconnections when we receive the `WIFI_P2P_CONNECTION_CHANGED_ACTION` intent.
    We firstly get `NetworkInfo` from the intent to understand whether there is a
    connection or disconnection. If it is a connection, we call the `requestConnectionInfo()`
    method of `WifiP2pManager` to connect.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we check whether the intent is `WIFI_P2P_THIS_DEVICE_CHANGED_ACTION`.
    We receive this intent when the device details have changed. We do nothing for
    this intent.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a simple user interface for this application; a layout with two buttons.
    The first button is to find and second button is to connect peers. The XML code
    of the layout is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The user interface will look like the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Sample Wi-Fi Direct application](img/9526_09_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we need to implement the `Activity` class of this application. The
    code of the `Activity` class should be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The implementation is not complete currently. We will add the necessary methods
    step-by-step.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this code, our `Activity` class implements various `Listeners`
    to handle the Wi-Fi Direct events. `ConnectionInfoListener` is for the callback
    when the connection info is available. `PeerListListener` is for the callback
    when the peer list is available. `ChannelListener` is for the callback when the
    channel is lost.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此代码中所见，我们的`Activity`类实现了各种`Listeners`来处理Wi-Fi Direct事件。`ConnectionInfoListener`用于当连接信息可用时的回调。`PeerListListener`用于当对等设备列表可用时的回调。`ChannelListener`用于当通道丢失时的回调。
- en: We create an intent filter and add the intents that we will check in the `onReceive()`
    method of the class that extends `BroadcastReceiver`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个意图过滤器，并在继承`BroadcastReceiver`的类的`onReceive()`方法中添加我们将检查的意图。
- en: We initialize the `WifiP2pManager` class by calling the `initialize()` method.
    This will register our application with the Wi-Fi network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`initialize()`方法来初始化`WifiP2pManager`类。这将使我们的应用程序与Wi-Fi网络注册。
- en: 'We need to override the `onChannelDisconnected()` method because we implemented
    `ChannelListener`, as shown in the following code block:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们实现了`ChannelListener`，所以我们需要重写`onChannelDisconnected()`方法，如下代码块所示：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to implement the `onPeersAvailable()` method because we implemented
    `PeerListListener`, as shown in the following code block:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们实现了`PeerListListener`，所以我们需要实现`onPeersAvailable()`方法，如下代码块所示：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We get the available `peerList` in this method. We get the first device and
    break the `for` loop. We need the device for connection.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此方法中，我们获取可用的`peerList`。我们获取第一个设备并跳出`for`循环。我们需要这个设备来进行连接。
- en: 'We need to implement the `onConnectionInfoAvailable()` method because we implemented
    `ConnectionInfoListener`, as shown in the following code block:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们实现了`ConnectionInfoListener`，所以我们需要实现`onConnectionInfoAvailable()`方法，如下代码块所示：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the place where we get the connection info and connect and send data
    to the peer. For instance, an `AsyncTask` that transfers a file could be executed
    here.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们获取连接信息，并与对等设备连接并发送数据。例如，可以在这里执行一个传输文件的`AsyncTask`。
- en: 'We need to implement the `onClick()` method for the buttons:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为按钮实现`onClick()`方法：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `find()` and `connect()` methods are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`和`connect()`方法如下所示：'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the **find** button is clicked, we call the `discoverPeers()` method of
    `WifiP2pManager` to discover the available peers. As you will remember, calling
    the `discoverPeers()` method will cause `BroadcastReceiver` to receive the `WIFI_P2P_PEERS_CHANGED_ACTION`
    intent. Then we will request the peer list in `BroadcastReceiver`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**查找**按钮时，我们会调用`WifiP2pManager`的`discoverPeers()`方法来发现可用的对等设备。如您所记得，调用`discoverPeers()`方法将导致`BroadcastReceiver`接收到`WIFI_P2P_PEERS_CHANGED_ACTION`意图。然后在`BroadcastReceiver`中我们会请求对等设备列表。
- en: When the **connect** button is clicked, we call the `connect()` method of the
    `WifiP2pManager` using the device info. This starts a peer-to-peer connection
    with the specified device.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**连接**按钮时，我们使用设备信息调用`WifiP2pManager`的`connect()`方法。这将开始与指定设备的点对点连接。
- en: The sample application to introduce the Wi-Fi Direct APIs is complete with these
    methods.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方法，介绍Wi-Fi Direct API的示例应用程序就完成了。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we firstly learned the Android Beam feature of Android. With
    this feature, devices can send data using the NFC hardware. We implemented a sample
    Android Beam application and learned how to use Android Beam APIs. Secondly, we
    learned what Wi-Fi Direct is and how to use Wi-Fi Direct APIs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了Android的Android Beam功能。通过此功能，设备可以使用NFC硬件发送数据。我们实现了一个示例Android Beam应用程序，并学习了如何使用Android
    Beam API。其次，我们了解了Wi-Fi Direct是什么以及如何使用Wi-Fi Direct API。
