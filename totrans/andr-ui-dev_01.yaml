- en: Chapter 1. Developing a Simple Activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the world of Android, an `Activity` is the point at which you make contact
    with your users. It''s a screen where you capture and present information to the
    user. You can construct your `Activity` screens by using either: XML layout files
    or hard-coded Java.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin our tour of Android user interfaces, we need a user interface to start
    with. In this chapter, we will begin with a simple `Activity`. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the `Activity` layout in an application resource file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tie the resource file to an `Activity` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically populate the `Activity` with a series of multiple-choice questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing our first example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our first example, we''re going to write a multiple-choice question and
    answer `Activity`. We could use it for applications such as "Who wants to be a
    millionaire?", or "What type of a monkey are you?". This example will pose questions
    in order to answer a very important question: "What should I have to eat?" As
    the user answers the questions, this application will filter a database of food
    ideas. The user can exit the process at any time to view a list of suggested meals,
    or just wait until the application runs out of questions to ask them.'
  prefs: []
  type: TYPE_NORMAL
- en: Since it's a user interface example, we'll skip building filters and recipe
    databases. We'll just ask our user food preference-related questions. For each
    question, we have a list of preset answers which the user can select from (that
    is, multiple-choice questions). Each answer they give will allow us to narrow
    the list of suitable recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start writing code, we need a project structure. An Android project
    is made up of far more than just its Java code—there are also manifest files,
    resources, icons, and more. In order to keep things easy, we use the default Android
    toolset and project structure.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest version of the Android SDK for your favorite operating
    system from [http://developer.android.com](http://developer.android.com). A single
    Android SDK may be used to develop against any number of target Android versions.
    You will need to follow the installation instructions on the website at [http://developer.android.com/sdk/installing.html](http://developer.android.com/sdk/installing.html)
    to install the latest SDK "starter package" and one or more platform targets.
    Most of the examples in this book will work on Android 1.5 and higher. The Android
    website also maintains a very useful chart where you can see what the most popular
    versions of Android are.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the Android SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have downloaded the Android SDK archive for your operating system,
    you''ll need to install it and then download at least one Android Platform package.
    Open a command-line or console and complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the Android SDK archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change directory to the root of the unpackaged Android SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change directory to the `tools` directory of the Android SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the SDK by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new Virtual Device by going to the **Virtual Devices** screen and clicking
    on the **New** button. Name the new Virtual Device **default**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify its target as the most recent version of Android downloaded by the SDK.
    Set the size of the SD Card to **4096 MiB**. Click on the **Create AVD** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above command tells the new Android SDK installation to look for available
    packages and install them. This includes installing a Platform Package. Each Platform
    Package that you install can be used to create an **Android Virtual Device** (**AVD**).
    Each AVD you create is much like buying a new device on which tests can be performed,
    each with its own configuration and data. These are virtual machines that the
    Android emulator will run your software on when you wish to test.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – starting a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android SDK provides a handy command-line tool named `android` which can
    be used to generate the skeleton of a new project. You'll find it under the `tools`
    directory of your Android SDK. It's capable of creating a basic directory structure
    and a `build.xml` file (for Apache Ant) to help get you started with your Android
    application development. You will need to make sure that the `tools` directory
    is in your executable path for this to work. Open a command-line or console.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory in your home directory or desktop named `AndroidUIExamples`.
    You should use this directory for each of the examples in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the directory to the new `AndroidUIExamples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just created a skeleton project. In the preceding command line, we used
    the following options to specify the structure of the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Gives the project a name, in our case, `KitchenDroid`. This is really
    just an internal identifier for the project. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p` | Gives the base directory for the project. In this case use the same
    name as that of the project. The `android` tool will create this directory for
    you. |'
  prefs: []
  type: TYPE_TB
- en: '| `-k` | Specifies the root Java package for the application. This is a fairly
    important concept since it defines our unique namespace on the Android client
    devices. |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Gives the tool a name for a "main" `Activity` class. This class will
    be populated with a skeleton layout XML, and serves as a base point to build your
    application from. The skeleton project will be pre-configured to load this `Activity`
    when it''s started. |'
  prefs: []
  type: TYPE_TB
- en: If you run the command `android list targets` and it presents you with an empty
    list of possible targets, then you have not downloaded any of the Android Platform
    packages. You can generally run the android tool by itself and use its graphical
    interface to download and install Android Platform packages. The previous example
    uses API Level 3 which corresponds to Android Platform version 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the Android project layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical Android project has almost as many directories and files as an enterprise
    Java project. Android is as much of a framework as it is an operating environment.
    In some ways, you can think of Android as an application container designed for
    running on phones and other limited devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the new project structure, you will have the following important
    files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Folder name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bin` | Your binary files will be placed in this directory by the compiler.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gen` | Source code generated by various Android tools. |'
  prefs: []
  type: TYPE_TB
- en: '| `res` | Application resources go here, to be compiled and packaged with your
    application. |'
  prefs: []
  type: TYPE_TB
- en: '| `src` | The default Java source code directory, where the `build` script
    will look for source code to compile. |'
  prefs: []
  type: TYPE_TB
- en: '| `AndroidManifest.xml` | Your application descriptor, similar to a `web.xml`
    file. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Resource Types and Files**'
  prefs: []
  type: TYPE_NORMAL
- en: Most types of application resources (placed in the `res` directory) receive
    special handling by the Android application packager. This means these files consume
    less space than they usually would (since XML is compiled into a binary format
    instead of being left as plain text). You access resources in various ways, but
    always through an Android API (which decodes them into their original form for
    you).
  prefs: []
  type: TYPE_NORMAL
- en: Each subdirectory of `res` indicates a different file format. Therefore, you
    cannot put files directly into the root `res` directory since the package tool
    won't know how to handle it (and you'll get a compile error). If you need to access
    a file in its raw state, put it in the `res/raw` directory. Files in the `raw`
    directory are copied byte-for-byte into your application package.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – running the example project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The android tool has given us a minimal example of an Android project, basically
    a "Hello World" application.
  prefs: []
  type: TYPE_NORMAL
- en: In your console or command-line, change directory to `KitchenDroid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build and sign the project, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will need to start the emulator with the `default` AVD you created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now install your application in the emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the emulator, open the **Android** menu and, you should see an icon named
    **QuestionActivity** in the menu. Click on this icon.![Time for action – running
    the example project](img/4484_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android emulator is a full hardware emulator including the ARM CPU, hosting
    the entire Android operating system stack. This means software running under the
    emulator will run exactly how it will on bare-metal hardware (although the speed
    may vary).
  prefs: []
  type: TYPE_NORMAL
- en: When you use Ant to deploy your Android applications, you will need to use the
    `install` Ant target. The `install` Ant target looks for a running emulator and
    then installs the application archive on its virtual memory. It's useful to note
    that Ant will not start the emulator for you. Instead, it will emit an error and
    the build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Application Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: Every Android application package is digitally signed. The signature is used
    to identify you as a developer of the application, and establish permissions for
    the application. It's also used to establish permissions between applications.
  prefs: []
  type: TYPE_NORMAL
- en: You will generally use a self-signed certificate, since Android doesn't require
    that you use a certificate authority. However, all applications must be signed
    in order for them to be run by the Android system.
  prefs: []
  type: TYPE_NORMAL
- en: The screen layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Android allows you to create a screen layout in either Java code, or by
    declaring the layout in an XML file, we will declare the screen layout in an XML
    file. This is an important decision for several reasons. The first is that, using
    the Android widgets in Java code requires several lines of code for each widget
    (a declaration/construction line, several lines invoking setters, and finally
    adding the widget to its parent), while a widget declared in XML takes up only
    one XML tag.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason for keeping layouts as XML is that it's compacted into a special
    Android XML format when it's stored in the APK file. Therefore your application
    uses less space on the device, takes less time to download, and its in-memory
    size is also smaller since less byte code needs to be loaded. The XML is also
    validated by the Android resource packing tool during compilation, and so is subject
    to the same type safety as Java code.
  prefs: []
  type: TYPE_NORMAL
- en: The third reason XML layouts are a "good idea" is that they are subject to the
    same resource selection process as all the other external resources. This means
    that a layout can be varied based on any of the defined properties, such as language,
    screen orientation and size, and even the time of day. This means that you can
    add new variations on the same layout in the future, simply by adding new XML
    files, and without the need to change any of your Java code.
  prefs: []
  type: TYPE_NORMAL
- en: The layout XML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All XML layout files must be placed in the `/res/layout` directory of your Android
    project in order for the Android packaging tools to find them. Each XML file will
    result in a resource variable of the same name. For example, if we name our file
    `/res/layout/main.xml`, then we can access it in Java as `R.layout.main`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are building the screen layout as a resource file, it will be loaded
    by the application resource loader (having been compiled by the resource compiler).
    A resource is subject to a selection process, so while there is only one resource
    that the application loads, there may be multiple possible versions of the same
    resource available in the application package. This selection process is also
    what Android internationalization is built on top of.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to build a different version of the user interface layout for
    several different types of touchscreens, Android defines three different types
    of touchscreen properties for us: `notouch`, `stylus`, and `finger`. This roughly
    translates to: no touchscreen, resistive touchscreen, and capacitive touchscreen.
    If we wanted to define a more keyboard-driven user interface for devices without
    a touchscreen (`notouch`), we write a new layout XML file named `/res/layout-notouch/main.xml`.
    When we load the resource in our `Activity` code, the resource selector will pick
    the `notouch` version of the screen if the device we''re running on doesn''t have
    a touchscreen.'
  prefs: []
  type: TYPE_NORMAL
- en: Resource selection qualifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a list of commonly used qualifiers (property names) that will be taken
    into account when Android selects a resource file to load. This table is ordered
    by precedence, with the most important properties at the top.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description | Examples | API Level |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MCC and MNC | The mobile-country-code (MCC) and mobile-network-code (MNC).
    These can be used to determine which mobile operator and country the SIM card
    in the device is tied to.The mobile-network-code optionally follows the mobile-country-code,
    but cannot be used on its own (you must always specify country-code first). |
    `mcc505``mcc505-mnc03``mcc238``mcc238-mnc02``mcc238-mnc20` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Language and region codes | Language and region codes are probably the most
    commonly used resource properties. This is generally how you localize your application
    to the user language preferences.These values are standard ISO language and region
    codes, and are not case-sensitive. You cannot specify a region without a country
    code (similar to `java.util.Locale`). | `en``en-rUS``es``es-rCL``es-rMX` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Screen size | There are only three variations of this property: small, medium,
    and large. The value is based on the amount of screen space that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Small: QVGA (320×240 pixel) low-density type screens;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Medium: WQVGA low-density, HVGA (480x360 pixels) medium-density, and WVGA high-density
    type screens;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Large: VGA (640x480 pixels) or WVGA medium-density type screens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `small``medium``large` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Screen aspect | This is the aspect type of the screen, based on the way the
    device would "normally" be used. This value doesn''t change based on the orientation
    of the device. | `long``notlong` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Screen orientation | Used to determine whether the device is currently in
    portrait (`port`) or landscape (`land`) mode. This is only available on devices
    that can detect their orientation. | `land``port` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Night mode | This value simply changes with the time of day. | `night``notnight`
    | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Screen density (DPI) | The DPI of the device screen. There are four possible
    values for this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldpi`: Low-density, approximately 120dpi;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdpi`: Medium-density, approximately 160dpi;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hdpi`: High-density, approximately 240dpi;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodpi`: Can be used for `bitmap` resources that shouldn''t be scaled to match
    the screen density'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `ldpi``mdpi``hdpi``nodpi` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Keyboard status | What sort of keyboard is available on this device? This
    attribute shouldn''t be used to determine whether the device has a hardware keyboard,
    but instead whether a keyboard (or software keyboard) is currently visible to
    the user. | `keysexposed``keyshidden``keyssoft` | 1 |'
  prefs: []
  type: TYPE_TB
- en: Time for action – setting up the question activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick things off we''re going to be working with Android''s simplest layout
    called: `LinearLayout`. Unlike Java AWT or Swing, Android layout managers are
    defined as specific container types. Thus a `LinearLayout` is much like a `Panel`
    with a built-in `LayoutManager`. If you''ve worked with GWT, you''ll be quite
    familiar with this concept. We''ll lay out the screen in a simple top-to-bottom
    structure (which `LinearLayout` is perfect for).'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file in the `/res/layout` directory of your project named `main.xml`
    in you favorite IDE or text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete any template XML code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following XML code into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just removed the "Hello World" example, and put in an entirely empty layout
    structure which will serve as the platform for us to build the rest of the user
    interface upon. As you can see, Android has a special XML namespace for its resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All resource types in Android use the same XML namespace.
  prefs: []
  type: TYPE_NORMAL
- en: We declare our root element as `LinearLayout`. This element corresponds directly
    to the class `android.widget.LinearLayout`. Each element or attribute prefixed
    with the Android namespace corresponds to an attribute that is interpreted by
    the Android resource compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The AAPT (Android Asset Packaging Tool) will generate an `R.java` file into
    your root (or primary) package. This file contains all of the Java variables used
    to reference your various application resources. In our case, we have the `main.xml`
    package in the `/res/layout` directory. This file becomes an `R.layout.main` variable
    with a constant value assigned as its identification.
  prefs: []
  type: TYPE_NORMAL
- en: Populating a View and a ViewGroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A widget in Android is called a `View`, while a container (such as `LinearLayout`)
    is a `ViewGroup`. We have an empty `ViewGroup` now, but we need to start populating
    it in order to build up our user interface. While it is possible to nest a `ViewGroup`
    inside another `ViewGroup` object, an `Activity` has only one root `View`—so a
    layout XML file may have only one root `View`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – asking a question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to ask our user a question, you will need to add a `TextView` to the
    top of your layout. A `TextView` is a bit like a `Label` or `JLabel`. It's also
    the base class for many other Android `View` widgets that display text. We want
    it to take up all of the available horizontal space, but only enough vertical
    space for our question to fit. We populate the `TextView` with **Please wait...**
    as its default text. Later, on we will replace this with a dynamically selected
    question.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your `main.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Between the `<LinearLayout...>` and `</LinearLayout>` create a `<TextView />`
    element, ending it with the empty element `/>` syntax since elements representing
    `View` objects are not allowed to have child elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the `TextView` element an ID attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the layout width and height attributes to `fill_parent` and `wrap_content`
    respectively (the same as the `LinearLayout` element):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Give the `TextView` some placeholder text so we can see it on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reinstall the application using Apache Ant from your project root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application again in the emulator and it should look like the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action – asking a question](img/4484_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for the `TextView` should end up looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we used `fill_parent` and `wrap_content` as values
    for the layout width and height attributes. The `fill_parent` value is a special
    value that is always equal to the parent size. If it's used as the value for the
    `android:layout_width` attribute (as in our example), then it's the width of the
    parent view. If it's used in the `android:layout_height` attribute, it would be
    equal to the height of the parent view instead.
  prefs: []
  type: TYPE_NORMAL
- en: The value `wrap_content` can be used much like a preferred size in Java AWT
    or Swing. It says to the `View` object, "Take as much space as you need to, but
    no more". The only valid place to use these special attribute values is in the
    `android:layout_width` and `android:layout_height` attributes. Anywhere else will
    result in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to access this `TextView` in our Java code later, in order to invoke
    its `setText` method (which directly corresponds to the `android:text` attribute
    we used for the placeholder text). A Java reference to a resource variable is
    created by assigning the resource an ID. In this example, the ID is declared here
    as `@+id/question`. The AAPT will generate an `int` value as an identifier for
    each resource of `id` as part of your `R` class. The ID attribute is also needed
    for accessing resources from another resource file.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a space for answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While posing a question to the user is all very fine and well, we need to give
    them some way to answer that question. We have several possibilities at our disposal:
    We could use a `RadioGroup` with a `RadioButton` for each possible answer, or
    a `ListView` with an item for each answer. However, to minimize the required interaction,
    and make things as clear as possible, we use one `Button` for each possible answer.
    However, this complicates things slightly, since you can''t declare a variable
    number of `Button` objects in your layout XML file. Instead, we will declare a
    new `LinearLayout` and populate it with `Button` objects in the Java code.'
  prefs: []
  type: TYPE_NORMAL
- en: Under the `TextView` where we pose our question, you will need to add a `<LinearLayout
    />` element. While this element would normally have child elements, in our case,
    the number of possible answers is varied, so we leave it as an empty element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, a `LinearLayout` will place its child `View` objects horizontally
    alongside each other. However, we want each child `View` to be vertically below
    each other, so you''ll need to set the `orientation` attribute of the `LinearLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to populate the new `ViewGroup` (`LinearLayout`) later in our
    Java code, so give it an ID: `answers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like our `TextView` and root `LinearLayout`, make the width `fill_parent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the height `wrap_content` so that it doesn''t take up more space than
    all the buttons it will be populated with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that for this example, we have no content in our new `LinearLayout`.
    This may seem a little unusual, but in this case, we want to populate it with
    a variable number of buttons—one for each possible answer to our multiple-choice
    questions. However, for the next part of the example we need some simple content
    `Button` widgets in this `LinearLayout` so that we can see the entire screen layout
    in action. Use the following code in your layout resource file to add **Yes!**,
    **No!**, and **Maybe?** `Button` widgets to the `LinearLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In Android XML layout resources, any `View` classes extending from the `ViewGroup`
    class are considered containers. Adding widgets to them is as simple as nesting
    those `View` elements inside the element of your `ViewGroup` (as opposed to closing
    it with no child XML elements).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the preceding **Yes!**, **No!**, **Maybe?**
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – adding more buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have two additional buttons to add to the screen layout. One will allow the
    user to skip the current question; the other will allow them to look at the short
    list of meals that we have filtered through so far (based on the questions they
    have already answered).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an empty `<Button />` element below our answers `ViewGroup
    <LinearLayout />` (but still within the root `LinearLayout` element). Assign it
    the ID `skip`, so that we can reference it in Java:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create some padding between the answers and the new button by using a margin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Give it the display label **Skip Question**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like all of the previous widgets, the width should be `fill_parent` and the
    height should be `wrap_content`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create another empty `<Button />` element below the **Skip Question** button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The ID for the new button should be `view`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want this button to display the text: **Feed Me!**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, put a little space between the **Skip Question** button, and the new
    **Feed Me!** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, set the width and height of the **Feed Me!** button as with the other
    elements we''ve created so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you''ve completed these two buttons, your layout XML file should now end
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Separation of unrelated user interface objects is a very important part of user
    interface design. Groups of items can be separated by whitespace, a border, or
    a box. In our case, we chose to use whitespace, as space also helps make the user
    interface feel cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created our whitespace by using a margin above each of the buttons. Margins
    and padding work exactly the same way as they (should) do in CSS. A margin is
    spacing outside of the widget, while padding is spacing inside the widget. In
    Android, a margin is the concern of the `ViewGroup`, and so its attribute name
    is prefixed with `layout_`. Because padding is the responsibility of a `View`
    object, the padding attribute has no such prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would create extra space between the edge of the `Button`
    and the text in the middle of it, as well as retaining the margin above the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the measurements in the preceding example are specified in the `sp`
    unit, which is short for "scale independent pixels". Much like CSS, you suffix
    your measurement numbers with the unit of size that you are specifying the measurement
    in. Android recognizes the following measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unit suffix | Full name | Description and uses |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `px` | Pixel | Exactly one pixel of the device screen. This unit is the most
    common when writing desktop applications, but with the wide variety of phone screen
    sizes, it becomes much harder to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Inch | One inch (or the closest approximation). This is based on the
    physical size of the screen. This is great if you need to work with real world
    measurements, but again, because of the variations in the size of a device screen,
    it is not always very useful. |'
  prefs: []
  type: TYPE_TB
- en: '| `mm` | Millimeters | Another real world measurement, made to the closest
    approximation. This is just a metric version of inches: 25.4 millimeters in 1
    inch. |'
  prefs: []
  type: TYPE_TB
- en: '| `pt` | Points | Points are 1/72 of an inch in size. Much like millimeters
    and inches, they are very useful for sizing things against real-world sizes. They
    are also commonly used for sizing fonts, and so work well relative to font sizes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dp` or `dip` | Density-independent-pixels | A single DP is the same size
    as a single pixel is for a 160 dpi screen. This size is not always a direct ratio,
    not always precise, but is a best approximation for the current screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `sp` | Scale-independent pixels | Much like the `dp` unit, it is a pixel
    scaled according to the user selected font size. This is possibly the best unit
    to use, as it''s based on a user-selected parameter. The user may have increased
    the font size because they find the screen hard to read. Using an `sp` unit ensures
    that your user interface scales with it. |'
  prefs: []
  type: TYPE_TB
- en: Defining common dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android also allows you to define your own dimension values as resource constants
    (note: dimensions, not measurements). This can be useful when you want several
    `view` widgets to be the same size, or to define a common font size. Files containing
    dimension declarations are placed in the `/res/values` directory in your project.
    While the actual file name isn''t significant, a common name is `dimens.xml`.
    Dimensions can technically be included with other value types (that is, strings),
    but this is not recommended since it makes it harder to trace the dimension that
    are being applied at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of having your dimensions in their own file as opposed to being
    declared inline) is that you can then localize them based on the size of the screen.
    This makes screen-resolution-significant scales (such as pixels) much more useful.
    For example, you can place a `dimens.xml` file with different values into `/res/values-320x240`
    and another version of the same dimensions into `/res/values-640x480`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dimensions resource file is a simple values file (much like `strings.xml`),
    but dimensions are defined with the `<dimen>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To access this as a size in a layout XML file, you use a resource reference
    (much the same way as you access a resource string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Building a list of common dimensions comes in handy when you want to build complex
    layouts that will look good on many different screens since it avoids the need
    to build several different layout XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – improve the styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have the most basic structure for this user interface, but it doesn't
    really look too great. Other than the margins between the answer buttons, and
    the **Skip Question** and **Feed Me!** buttons, you can't really tell them apart.
    We need to let the user know that these buttons all do different things. We also
    need to draw more attention to the question, especially if they don't have a lot
    of time to squint at their screen. You may need the Android documentation, which
    can be found online at [http://developer.android.com/reference/](http://developer.android.com/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: We have a question at the top of our screen, but as you can see in the previous
    screenshots, it doesn't stand out much. Therefore, it's not really very clear
    to the user what they need to do (especially the first time they use the application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try making the following styling changes to the question `TextView` at the
    top of our screen. These will only require you to add some attributes to its XML
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: Center the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the text bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the text size to `24sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `12sp` spacing between the bottom of the question and the answer buttons
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Feed Me!** button is also very important. This is the button that gives
    the user access to the list of suggested recipes that the application has filtered
    based on their answers, so it should look good.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following styling should help the **Feed Me!** button to stand out nicely
    (hint: `Button` extends `TextView`):'
  prefs: []
  type: TYPE_NORMAL
- en: Make the text size `18sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the text color to a nice red `#9d1111`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style the text as bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a text shadow: `x=0`, `y=-3`, `radius=1.5`, and `color=white` ("`#fff`").'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''ve finished styling the screen, it should look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero – improve the styling](img/4484_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Limitations of the layout XML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most obvious limitations of the layout XML format is that you can't
    dynamically populate part of the `Activity` based on external variables—there
    are no loops or methods in the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, this limitation shows itself in the form of our empty `LinearLayout`.
    Because each question has any number of possible answers, we need a varying number
    of buttons in the group. For our purposes, we will create the `Button` objects
    and put them into the `LinearLayout` as part of the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other place the XML layout format falls down is dynamically referencing
    external resources. This can be seen in our example, where we put placeholder
    text in the `android:text` attribute on the `TextView` element—`question`. We
    could have referenced an external string using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will effectively reference a static variable from the `strings.xml` file.
    It's not suitable for a dynamically selected question, which will change each
    time we initialize the `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What reason do you have for writing your layouts in XML instead of in pure Java
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android can read the layout file externally for optimization.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout becomes part of the resource selection process.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Your users could download new layouts from the App Store.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout can have custom themes applied to it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we make the text of the **Next Question** button bold?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `android:typeface` attribute.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom `Button` implementation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a CSS attribute: `style="font-weight: bold"`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `android:textStyle` attribute.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What would happen if we changed the `LinearLayout` from `vertical` orientation,
    to `horizontal`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout would turn on its side.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the widgets would be squashed together on the screen.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only the question `TextView` would be visible on the screen.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The question, and possibly some other `View` objects may be visible on the screen
    depending on the number of pixels available.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout would overflow, causing the widgets to appear next to each other,
    over several lines.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Populating the QuestionActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a basic user interface, but right now, it''s static. We may want to
    ask our user many different questions, each of which have different answers. We
    may also want to vary which questions we ask in some way or another. In short,
    we need some Java code to populate the layout with a question and some possible
    answers. Our questions are made up of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of possible answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we will make use of string array resources to store all of
    the question and answer data. We will use one string array to list the question
    identifiers, and then one string array for each question and its answers. The
    advantages of this approach are very similar to the advantages of using a layout
    XML file instead of hard-coding it. The `res/values` directory of your project
    will have an auto-generated `strings.xml` file. This file contains string and
    string-array resources that you want your application to use. Here is the start
    of our `strings.xml` file, with two questions to ask the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first item of each `question` array (`vegetarian` and `size`) is the question
    itself, while each following item is an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing more Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `QuestionActivity.java` file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the Android `Resources` class below the package declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to start asking the questions from your `strings.xml` file, you''ll
    need a method to look in the `questions <string-array>` and find the name of the
    array that contains the current question. This is not normally something you need
    to do with application resources—their identifiers are generally known to you
    through the `R` class. In this case however, we want to work in the order defined
    in the `questions <string-array>`, making things a little bit more difficult:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now look at the `questions` string-array, which contains the identifying
    name of each question (our index string-array):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have the array of questions, and we need to find the identifier value. This
    is much like using `R.array.vegetarian` for the `vegetarian` question, except
    that it''s a dynamic lookup, and therefore much slower than normal. In general,
    the following line is not recommended, but in our case it''s very useful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `QuestionActivity` class will display several questions to the user. We
    want the application to "play nice" with the phone and its environment. For that
    reason, each question will be posed in a new instance of `QuestionActivity` (allowing
    the device to control the display of our `Activity`). However, this method raises
    an important question: How do we know the index of the question to pose to the
    user? The answer: Our `Intent`. An `Activity` is started with an `Intent` object,
    and each `Intent` object may carry any amount of "extra" information (similar
    to request attributes in the `HttpServletRequest` interface) for the `Activity`
    to use, sort of like arguments to a `main` method. So, an `Intent` is also like
    a `HashMap`, containing special data for the `Activity` to use. In our case we
    use an integer property named `KitchenDroid.Question`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two methods form the basis for populating our question screen and navigating
    our way through a defined list of questions. When complete, they should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `getQuestionID` method is pretty straight forward. In our code we use `R.array.questions`
    to access the `<string-array>` which identifies all of the questions we are going
    to ask the user. Each question has a name in the form of a `String`, and a corresponding
    resource identification number in the form of an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `getQuestionID` method, we make use of the `Resources.getIdentifier`
    method, which looks for the resource identifier (the integer value) for a given
    resource name. The second parameter of the method is the type of resource to look
    up. This parameter is normally an inner class to the generated `R` class. Finally,
    we pass the base package that the resource is found in. Instead of all three of
    these parameters, you could also look up the resource by its full resource name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `getQuestionIndex` method tells us where in the `questions <string-array>`
    we currently are, and thus, which question to ask the user. This is based on the
    "extra" information in the `Intent` that triggered the `Activity`. The `getIntent()`
    method provides you with access to the `Intent` that triggered your `Activity`.
    Each `Intent` may have any amount of "extra" data, and that data may be any "primitive"
    or "serializable" type. Here we fetch the `KitchenDroid.Question` extra integer
    value from our `Intent`, substituting a value of 0 if it has not been set (that
    is, the default value). If the user taps our icon in the menu, Android won't have
    specified that value, so we start from the first question.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically creating widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point we've only used the layout XML file to populate our screen.
    In some cases, this is just not enough. In this simple example, we want the user
    to have a list of buttons that they can touch to answer the questions posed to
    them. We could pre-create some buttons and name them `button1`, `button2`, and
    so on, but that means limiting the number of possible answers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create buttons from our `<string-array>` resources, we need to do
    it in Java. We created a `ViewGroup` earlier (in the form of the `LinearLayout`
    that we named `answers`). This is where we will add our dynamically created buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting the questions on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application now knows where to find the questions to ask, and knows which
    question it should be asking. Now it needs to put the question on the screen,
    and allow the user to select an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.xml` file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the **Yes!**, **No!**, and **Maybe?** `Button` elements from the layout
    resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `QuestionActivity.java` file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need a new class field to hold the dynamically-created `Button` objects
    (for reference):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to keep things neat, create a new `private` method to put the questions
    on the screen: `initQuestionScreen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, we assume that the layout XML file has already been loaded
    into the `Activity` screen (that is, it will be invoked after we `setContentView`
    in `onCreate`). This means that we can look up parts of the layout as Java objects.
    We''ll need both the `TextView` named `question` and the `LinearLayout` named
    `answers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two variables need to be populated with the question and its possible
    answers. For that we need the `<string-array>` (from our `strings.xml` file) which
    contains that data, so we need to know the resource identifier for the current
    question. Then we can fetch the actual array of data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first element of a `question` string array is the question to pose to the
    user. The following `setText` call is exactly the same as specifying an `android:text`
    attribute in your layout XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to create an empty array to store references to our `Button` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''re ready to populate the screen. A `for` loop over each of the answer
    values indexed according to our arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get each answer from the array, skipping the question string at index zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Button` object for the answer and set its label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the new `Button` to our answers object (`ViewGroup`), and reference
    it in our `buttons` array (where we''ll need it later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having done that, just after the `setContentView` calls in `onCreate`, we need
    to invoke our new `initQuestionScreen` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `findViewById` method traverses the tree of `View` objects looking for a
    specific identifying integer value. By default, any resource declared with an
    `android:id` attribute in its resource file will have an associated ID. You could
    also assign an ID by hand using the `View.setId` method.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many other user interface APIs, the Android user interface API is geared
    towards XML development than pure Java development. A perfect example of this
    fact is that the `View` subclasses have three different constructors, two of which
    are designed for use with the XML parsing API. Instead of being able to populate
    the `Button` label in a constructor (as with most other UI APIs), we are forced
    to first construct the object, and then use `setText` to define its label.
  prefs: []
  type: TYPE_NORMAL
- en: What you do pass into the constructor of every `View` object is a `Context`
    object. In the preceding example you pass the `Activity` object into the constructor
    of the answer `Button` objects as `this`. The `Activity` class inherits from the
    `Context` class. The `Context` object is used by the `View` and `ViewGroup` objects
    to load the application resources and services that they require in order to function
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You can now try running the application, in which case you'll be greeted with
    the following screen. You may have noticed that there is additional styling in
    this screenshot. If you don't have this, you may want to backtrack a little to
    the previous *Have a go hero* section.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling events in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android user interface events work in much the same way as a Swing event-listener
    or a GWT event-handler. Depending on the type of event you wish to receive, you
    implement an interface and pass an instance to the widget you wish to receive
    events from. In our case we have `Bu` `tton` widgets that fire click-events when
    they are touched by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The event-listener interfaces are declared in many of the Android classes, so
    there isn't a single place you can go look for them. Also, unlike most event-listener
    systems, many widgets may only have one of any given event-listeners. You can
    identify an event-listener interface by the fact that their class names are prefixed
    with `On` (much like HTML event attributes). In order to listen for click-events
    on a widget, you would set its `OnClickListener` using the `V` `iew.setOnClickListener`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how a click-listener might be added to a `Button`
    object to show a `Toast`. A `Toast` is a small pop-up box which is displayed briefly
    to give the user some information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding event-listener is declared as an anonymous inner class, which
    is okay when you are passing similar event-listeners to many different widgets.
    However, most of the time you'll want to be listening for events on widgets you've
    declared in an XML layout resource. In these cases it's better to either have
    your `Activity` class implement the required interfaces, or create specialized
    classes for different event-driven actions. While Android devices are very powerful,
    they are still limited when compared to a desktop computer or laptop. Therefore,
    you should avoid creating unnecessary objects in order to conserve memory. By
    placing as many event-listener methods in objects that will already be created,
    you lower the overhead required.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you declare an object in a layout XML file, how do you retrieve its Java
    object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object will be declared in the `R` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `Activity.findViewById` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `Resources.getLayout` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The object will be injected into a field in the `Activity` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the "best" way of listening for events in an Android application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declaring the listeners as anonymous inner classes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a separate event listener class for each `Activity`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the event-listening interfaces in the `Activity` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you pass `this Activity` into the constructors of `View` objects (that
    is, `new Button(this)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines the `Activity` screen they will be displayed on.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It's where event messages will be sent to.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It's how the `View` will reference its operating environment.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android comes with some great tools to create and test applications, even if
    you don't have an Android device handy. That said, there's no replacement for
    actually touching your application. It's part of what makes Android such a compelling
    platform, the way it feels and responds (and the emulator just doesn't convey
    that).
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important tools in an Android developer's arsenal is the resource
    selection system. With it you can build highly dynamic applications that respond
    to changes in the devices, and thus, the user environment. Changing the screen
    layout based on the orientation of the device, or when the user slides out the
    phone's QWERTY keyboard, lets them know that you've taken their preferences into
    account when building your application.
  prefs: []
  type: TYPE_NORMAL
- en: When building user interfaces in Android, it's strongly recommended to build
    at least the layout structure in an XML file. The XML layout files are not only
    considered as application resources, but Android also strongly favors building
    XML user interfaces over writing Java code. Sometimes, however, a layout XML file
    isn't enough, and you need to build parts of the user interface in Java. In this
    case it's a good idea to define at least a skeleton layout as XML (if possible),
    and then place the dynamically created `View` objects into the layout by using
    marker IDs and containers (much like dynamically adding to an HTML document in
    JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: When building a user interface, think carefully about the look and feel of the
    outcome. In our example, we use `Button` objects for the answers to questions.
    We could have used `RadioButton` objects instead, but then the user would have
    needed to select an option, and then touch a **Next Question** button, requiring
    two touches. We could also have used a `List` (which interacts nicely with the
    fact that it needs to be dynamically populated), however, a `List` doesn't indicate
    an "action" to the user quite the way a `Button` does.
  prefs: []
  type: TYPE_NORMAL
- en: When coding layouts, be careful with the measurement units that you use. It's
    strongly recommend that you stick to using `sp` for most purposes—if you can't
    use one of the special `fill_parent` or `wrap_content` values. Other values are
    highly dependent on the size of screen, and won't respond to the user preferences.
    You can make use of the resource selection process to build different screen designs
    for small, medium, or large screens. You could also define your own measurement
    unit and base it on the screen size.
  prefs: []
  type: TYPE_NORMAL
- en: Always think about how your user will interact with your application, and how
    much (or little) time they are likely to have with it. Keeping each screen simple
    and responsive keeps your users happy.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned how to create a skeleton Android project, and a simple
    `Activiy`, we can focus on the more subtle problems and solutions of Android user
    interface design. In the next chapter, we will focus on working with data-driven
    widgets. Android has several widgets designed specifically for displaying and
    selecting from more complex data structures. These widgets form the basis of data-driven
    applications such as an address book or a calendar application.
  prefs: []
  type: TYPE_NORMAL
