- en: Chapter 1. Developing a Simple Activity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 开发一个简单的Activity
- en: '*In the world of Android, an `Activity` is the point at which you make contact
    with your users. It''s a screen where you capture and present information to the
    user. You can construct your `Activity` screens by using either: XML layout files
    or hard-coded Java.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Android的世界里，`Activity`是您与用户接触的点。这是一个您向用户捕捉和展示信息的屏幕。您可以通过使用以下方式构建您的`Activity`屏幕：XML布局文件或硬编码的Java。*'
- en: 'To begin our tour of Android user interfaces, we need a user interface to start
    with. In this chapter, we will begin with a simple `Activity`. We will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的Android用户界面之旅，我们需要一个用户界面作为起点。在本章中，我们将从一个简单的`Activity`开始。我们将：
- en: Create a new Android project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Android项目
- en: Build the `Activity` layout in an application resource file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序资源文件中构建`Activity`布局
- en: Tie the resource file to an `Activity` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将资源文件与`Activity`类关联
- en: Dynamically populate the `Activity` with a series of multiple-choice questions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态填充`Activity`一系列的多项选择题
- en: Developing our first example
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个示例
- en: 'For our first example, we''re going to write a multiple-choice question and
    answer `Activity`. We could use it for applications such as "Who wants to be a
    millionaire?", or "What type of a monkey are you?". This example will pose questions
    in order to answer a very important question: "What should I have to eat?" As
    the user answers the questions, this application will filter a database of food
    ideas. The user can exit the process at any time to view a list of suggested meals,
    or just wait until the application runs out of questions to ask them.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个示例，我们将编写一个多项选择题和答案`Activity`。我们可以将其用于诸如“谁想成为百万富翁？”或“你是什么类型的猴子？”等应用程序。这个示例将通过提问来回答一个非常关键的问题：“我应该吃什么？”当用户回答问题时，这个应用程序将筛选出食物想法的数据库。用户可以在任何时候退出流程以查看建议的餐点列表，或者等到应用程序没有问题可问为止。
- en: Since it's a user interface example, we'll skip building filters and recipe
    databases. We'll just ask our user food preference-related questions. For each
    question, we have a list of preset answers which the user can select from (that
    is, multiple-choice questions). Each answer they give will allow us to narrow
    the list of suitable recipes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个用户界面示例，我们将跳过构建筛选器和食谱数据库。我们只向用户询问与食物偏好相关的问题。对于每个问题，我们有一系列预设答案供用户选择（即多项选择题）。他们给出的每个答案都会让我们缩小合适的食谱列表。
- en: Creating the project structure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目结构
- en: Before we can start writing code, we need a project structure. An Android project
    is made up of far more than just its Java code—there are also manifest files,
    resources, icons, and more. In order to keep things easy, we use the default Android
    toolset and project structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要一个项目结构。一个Android项目远不止其Java代码——还有清单文件、资源、图标等等。为了简化事情，我们使用默认的Android工具集和项目结构。
- en: You can download the latest version of the Android SDK for your favorite operating
    system from [http://developer.android.com](http://developer.android.com). A single
    Android SDK may be used to develop against any number of target Android versions.
    You will need to follow the installation instructions on the website at [http://developer.android.com/sdk/installing.html](http://developer.android.com/sdk/installing.html)
    to install the latest SDK "starter package" and one or more platform targets.
    Most of the examples in this book will work on Android 1.5 and higher. The Android
    website also maintains a very useful chart where you can see what the most popular
    versions of Android are.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://developer.android.com](http://developer.android.com)为您的常用操作系统下载最新版本的Android
    SDK。一个单一的Android SDK可以用来开发针对任何数量的目标Android版本。您需要遵循网站上的安装说明，在[http://developer.android.com/sdk/installing.html](http://developer.android.com/sdk/installing.html)安装最新的SDK“入门包”和一个或多个平台目标。本书中的大多数示例将在Android
    1.5及更高版本上运行。Android网站还维护了一个非常有用的图表，您可以在上面看到最受欢迎的Android版本。
- en: Time for action – setting up the Android SDK
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——设置Android SDK
- en: 'Once you have downloaded the Android SDK archive for your operating system,
    you''ll need to install it and then download at least one Android Platform package.
    Open a command-line or console and complete the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在为您的操作系统下载了Android SDK归档文件之后，您需要安装它，然后至少下载一个Android平台包。打开命令行或控制台，完成以下步骤：
- en: Extract the Android SDK archive.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压Android SDK归档文件。
- en: Change directory to the root of the unpackaged Android SDK.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改目录到未打包的Android SDK的根目录。
- en: Change directory to the `tools` directory of the Android SDK.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改目录到 Android SDK 的 `tools` 目录。
- en: 'Update the SDK by running the following command:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令更新 SDK：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a new Virtual Device by going to the **Virtual Devices** screen and clicking
    on the **New** button. Name the new Virtual Device **default**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过进入**虚拟设备**屏幕并点击**新建**按钮来创建一个新的虚拟设备。将新的虚拟设备命名为**default**。
- en: Specify its target as the most recent version of Android downloaded by the SDK.
    Set the size of the SD Card to **4096 MiB**. Click on the **Create AVD** button.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其目标指定为 SDK 下载的最新版本的 Android。将 SD 卡的大小设置为**4096 MiB**。点击**创建 AVD**按钮。
- en: '*What just happened?*'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The above command tells the new Android SDK installation to look for available
    packages and install them. This includes installing a Platform Package. Each Platform
    Package that you install can be used to create an **Android Virtual Device** (**AVD**).
    Each AVD you create is much like buying a new device on which tests can be performed,
    each with its own configuration and data. These are virtual machines that the
    Android emulator will run your software on when you wish to test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令告诉新的 Android SDK 安装程序查找可用的软件包并安装它们。这包括安装一个平台软件包。你安装的每个平台软件包都可以用来创建一个**Android
    虚拟设备**（**AVD**）。你创建的每个 AVD 都像购买了一个新的设备，可以在其上进行测试，每个设备都有自己的配置和数据。这些是虚拟机，当你要测试时，Android
    模拟器将在上面运行你的软件。
- en: Time for action – starting a new project
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个新项目的行动时间——
- en: The Android SDK provides a handy command-line tool named `android` which can
    be used to generate the skeleton of a new project. You'll find it under the `tools`
    directory of your Android SDK. It's capable of creating a basic directory structure
    and a `build.xml` file (for Apache Ant) to help get you started with your Android
    application development. You will need to make sure that the `tools` directory
    is in your executable path for this to work. Open a command-line or console.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 提供了一个便捷的命令行工具，名为 `android`，可用于生成新项目的基本框架。你可以在你的 Android SDK 的 `tools`
    目录下找到它。它能够创建基本的目录结构和一个 `build.xml` 文件（用于 Apache Ant），帮助你开始 Android 应用程序开发。你需要确保
    `tools` 目录在你的可执行路径中，以便这个工具能够正常工作。打开命令行或控制台。
- en: Create a new directory in your home directory or desktop named `AndroidUIExamples`.
    You should use this directory for each of the examples in this book.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主目录或桌面上创建一个名为 `AndroidUIExamples` 的新目录。你应该使用这个目录来存储本书中的每个示例。
- en: Change the directory to the new `AndroidUIExamples`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改目录到新的 `AndroidUIExamples`。
- en: 'Run the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*What just happened*'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: 'We just created a skeleton project. In the preceding command line, we used
    the following options to specify the structure of the new project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个框架项目。在前面的命令行中，我们使用了以下选项来指定新项目的结构：
- en: '| Option | Description |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-n` | Gives the project a name, in our case, `KitchenDroid`. This is really
    just an internal identifier for the project. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 给项目一个名字，在我们的例子中是 `KitchenDroid`。这实际上只是项目的内部标识符。 |'
- en: '| `-p` | Gives the base directory for the project. In this case use the same
    name as that of the project. The `android` tool will create this directory for
    you. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `-p` | 指定项目的基目录。在这种情况下，使用与项目相同的名称。`android`工具将为你创建这个目录。 |'
- en: '| `-k` | Specifies the root Java package for the application. This is a fairly
    important concept since it defines our unique namespace on the Android client
    devices. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `-k` | 指定应用程序的根 Java 包。这是一个相当重要的概念，因为它定义了我们在 Android 客户端设备上的唯一命名空间。 |'
- en: '| `-a` | Gives the tool a name for a "main" `Activity` class. This class will
    be populated with a skeleton layout XML, and serves as a base point to build your
    application from. The skeleton project will be pre-configured to load this `Activity`
    when it''s started. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 为工具提供一个“主” `Activity` 类的名称。这个类将被填充一个基本的布局 XML，并作为构建你的应用程序的基础点。框架项目将预先配置为在启动时加载这个
    `Activity`。 |'
- en: If you run the command `android list targets` and it presents you with an empty
    list of possible targets, then you have not downloaded any of the Android Platform
    packages. You can generally run the android tool by itself and use its graphical
    interface to download and install Android Platform packages. The previous example
    uses API Level 3 which corresponds to Android Platform version 1.5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行命令 `android list targets`，并且它提供了一个可能的空目标列表，那么你没有下载任何 Android 平台软件包。你通常可以单独运行
    android 工具，并使用其图形界面下载和安装 Android 平台软件包。前面的示例使用 API 级别 3，对应于 Android 平台版本 1.5。
- en: Examining the Android project layout
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Android项目布局
- en: A typical Android project has almost as many directories and files as an enterprise
    Java project. Android is as much of a framework as it is an operating environment.
    In some ways, you can think of Android as an application container designed for
    running on phones and other limited devices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Android项目几乎拥有与企业级Java项目一样多的目录和文件。Android既是一个框架，也是一个操作系统环境。在某种程度上，你可以将Android视为为在手机和其他有限设备上运行而设计的应用容器。
- en: 'As part of the new project structure, you will have the following important
    files and directories:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为新项目结构的一部分，你将拥有以下重要文件和目录：
- en: '| Folder name | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 文件夹名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bin` | Your binary files will be placed in this directory by the compiler.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `bin` | 编译器将把你的二进制文件放在这个目录中。 |'
- en: '| `gen` | Source code generated by various Android tools. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `gen` | 由各种Android工具生成的源代码。 |'
- en: '| `res` | Application resources go here, to be compiled and packaged with your
    application. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `res` | 应用资源放在这里，将与你的应用一起编译和打包。 |'
- en: '| `src` | The default Java source code directory, where the `build` script
    will look for source code to compile. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `src` | 默认的Java源代码目录，`build`脚本将在这里查找要编译的源代码。 |'
- en: '| `AndroidManifest.xml` | Your application descriptor, similar to a `web.xml`
    file. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `AndroidManifest.xml` | 你的应用描述符，类似于`web.xml`文件。 |'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Resource Types and Files**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源类型和文件**'
- en: Most types of application resources (placed in the `res` directory) receive
    special handling by the Android application packager. This means these files consume
    less space than they usually would (since XML is compiled into a binary format
    instead of being left as plain text). You access resources in various ways, but
    always through an Android API (which decodes them into their original form for
    you).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用资源类型（位于`res`目录中）会受到Android应用打包器的特殊处理。这意味着这些文件占用的空间比它们通常情况下要少（因为XML会被编译成二进制格式，而不是保持纯文本形式）。你可以通过各种方式访问资源，但始终要通过Android
    API（它会为你将这些资源解码成它们的原始形式）。
- en: Each subdirectory of `res` indicates a different file format. Therefore, you
    cannot put files directly into the root `res` directory since the package tool
    won't know how to handle it (and you'll get a compile error). If you need to access
    a file in its raw state, put it in the `res/raw` directory. Files in the `raw`
    directory are copied byte-for-byte into your application package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`res`的每个子目录表示不同的文件格式。因此，你不能直接将文件放入根`res`目录中，因为打包工具不知道如何处理它（你将得到一个编译错误）。如果你需要以原始状态访问一个文件，请将其放在`res/raw`目录中。`raw`目录中的文件会以字节为单位复制到你的应用程序包中。'
- en: Time for action – running the example project
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间——运行示例项目
- en: The android tool has given us a minimal example of an Android project, basically
    a "Hello World" application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: android工具为我们提供了一个最小的Android项目示例，基本上是一个“Hello World”应用。
- en: In your console or command-line, change directory to `KitchenDroid`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的控制台或命令行中，切换到`KitchenDroid`目录。
- en: 'To build and sign the project, run:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建并签名项目，请运行：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will need to start the emulator with the `default` AVD you created earlier:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要启动之前创建的`default` AVD：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now install your application in the emulator:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在模拟器中安装你的应用：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the emulator, open the **Android** menu and, you should see an icon named
    **QuestionActivity** in the menu. Click on this icon.![Time for action – running
    the example project](img/4484_01_01.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器中，打开**Android**菜单，你应在菜单中看到一个名为**QuestionActivity**的图标。点击这个图标。![动手操作时间——运行示例项目](img/4484_01_01.jpg)
- en: '*What just happened?*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The Android emulator is a full hardware emulator including the ARM CPU, hosting
    the entire Android operating system stack. This means software running under the
    emulator will run exactly how it will on bare-metal hardware (although the speed
    may vary).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Android模拟器是一个完整的硬件模拟器，包括ARM CPU，承载整个Android操作系统栈。这意味着在模拟器下运行软件将完全和在裸机硬件上运行一样（尽管速度可能会有所不同）。
- en: When you use Ant to deploy your Android applications, you will need to use the
    `install` Ant target. The `install` Ant target looks for a running emulator and
    then installs the application archive on its virtual memory. It's useful to note
    that Ant will not start the emulator for you. Instead, it will emit an error and
    the build will fail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Ant部署你的Android应用时，需要使用`install` Ant目标。`install` Ant目标会寻找正在运行的模拟器，然后将应用归档文件安装到它的虚拟内存中。需要注意的是，Ant不会为你启动模拟器。相反，它会发出错误，并且构建会失败。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Application Signatures**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用签名**'
- en: Every Android application package is digitally signed. The signature is used
    to identify you as a developer of the application, and establish permissions for
    the application. It's also used to establish permissions between applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android应用程序包都是数字签名的。签名用于将你标识为应用程序的开发者，并建立应用程序的权限。它还用于建立应用程序之间的权限。
- en: You will generally use a self-signed certificate, since Android doesn't require
    that you use a certificate authority. However, all applications must be signed
    in order for them to be run by the Android system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会使用自签名证书，因为Android并不要求你使用证书授权机构。然而，所有应用程序必须进行签名，以便它们能够被Android系统运行。
- en: The screen layout
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕布局
- en: While Android allows you to create a screen layout in either Java code, or by
    declaring the layout in an XML file, we will declare the screen layout in an XML
    file. This is an important decision for several reasons. The first is that, using
    the Android widgets in Java code requires several lines of code for each widget
    (a declaration/construction line, several lines invoking setters, and finally
    adding the widget to its parent), while a widget declared in XML takes up only
    one XML tag.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Android允许你通过Java代码或通过在XML文件中声明布局来创建屏幕布局，但我们将在XML文件中声明屏幕布局。这是一个重要的决定，原因有几个。首先，使用Java代码中的Android小部件需要为每个小部件编写多行代码（声明/构造行，调用setter的几行，最后将小部件添加到其父级），而在XML中声明的小部件只占用一个XML标签。
- en: The second reason for keeping layouts as XML is that it's compacted into a special
    Android XML format when it's stored in the APK file. Therefore your application
    uses less space on the device, takes less time to download, and its in-memory
    size is also smaller since less byte code needs to be loaded. The XML is also
    validated by the Android resource packing tool during compilation, and so is subject
    to the same type safety as Java code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将布局保持为XML的第二个原因是，当它存储在APK文件中时，会被压缩成特殊的Android XML格式。因此，你的应用程序在设备上占用的空间更少，下载时间更短，由于需要加载的字节码更少，其内存大小也更小。XML在编译期间还会由Android资源打包工具进行验证，因此具有与Java代码相同类型的安全性。
- en: The third reason XML layouts are a "good idea" is that they are subject to the
    same resource selection process as all the other external resources. This means
    that a layout can be varied based on any of the defined properties, such as language,
    screen orientation and size, and even the time of day. This means that you can
    add new variations on the same layout in the future, simply by adding new XML
    files, and without the need to change any of your Java code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将布局保持为XML的第三个原因是，它们需要经过与其他所有外部资源相同的选择过程。这意味着布局可以根据任何定义的属性进行变化，例如语言、屏幕方向和大小，甚至是一天中的时间。这意味着你可以在未来简单通过添加新的XML文件，来添加对同一布局的新变体，而无需更改任何Java代码。
- en: The layout XML file
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局XML文件
- en: All XML layout files must be placed in the `/res/layout` directory of your Android
    project in order for the Android packaging tools to find them. Each XML file will
    result in a resource variable of the same name. For example, if we name our file
    `/res/layout/main.xml`, then we can access it in Java as `R.layout.main`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Android打包工具能够找到它们，所有的XML布局文件必须放在你的Android项目的`/res/layout`目录下。每个XML文件将生成一个同名的资源变量。例如，如果我们将文件命名为`/res/layout/main.xml`，那么我们可以在Java中通过`R.layout.main`访问它。
- en: Since we are building the screen layout as a resource file, it will be loaded
    by the application resource loader (having been compiled by the resource compiler).
    A resource is subject to a selection process, so while there is only one resource
    that the application loads, there may be multiple possible versions of the same
    resource available in the application package. This selection process is also
    what Android internationalization is built on top of.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将屏幕布局构建为一个资源文件，它将由应用程序资源加载器加载（在资源编译器编译后）。资源需要经过选择过程，因此尽管应用程序只加载一个资源，但在应用程序包中可能有多个相同资源的可用版本。这个选择过程也是Android国际化的基础。
- en: 'If we wanted to build a different version of the user interface layout for
    several different types of touchscreens, Android defines three different types
    of touchscreen properties for us: `notouch`, `stylus`, and `finger`. This roughly
    translates to: no touchscreen, resistive touchscreen, and capacitive touchscreen.
    If we wanted to define a more keyboard-driven user interface for devices without
    a touchscreen (`notouch`), we write a new layout XML file named `/res/layout-notouch/main.xml`.
    When we load the resource in our `Activity` code, the resource selector will pick
    the `notouch` version of the screen if the device we''re running on doesn''t have
    a touchscreen.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为几种不同类型的触摸屏构建用户界面布局的不同版本，Android为我们定义了三种不同的触摸屏属性：`notouch`、`stylus`和`finger`。这大致相当于：没有触摸屏、电阻式触摸屏和电容式触摸屏。如果我们想为没有触摸屏的设备定义一个更依赖键盘的用户界面（`notouch`），我们可以编写一个新的布局XML文件，命名为`/res/layout-notouch/main.xml`。当我们在`Activity`代码中加载资源时，资源选择器会在我们运行的设备没有触摸屏时选择`notouch`版本的屏幕。
- en: Resource selection qualifiers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源选择限定符
- en: Here is a list of commonly used qualifiers (property names) that will be taken
    into account when Android selects a resource file to load. This table is ordered
    by precedence, with the most important properties at the top.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一组常用的限定符（属性名），当Android选择要加载的资源文件时会考虑这些限定符。这个表格是按优先级排序的，最重要的属性在顶部。
- en: '| Name | Description | Examples | API Level |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 示例 | API级别 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| MCC and MNC | The mobile-country-code (MCC) and mobile-network-code (MNC).
    These can be used to determine which mobile operator and country the SIM card
    in the device is tied to.The mobile-network-code optionally follows the mobile-country-code,
    but cannot be used on its own (you must always specify country-code first). |
    `mcc505``mcc505-mnc03``mcc238``mcc238-mnc02``mcc238-mnc20` | 1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| MCC 和 MNC | 移动国家代码（MCC）和移动网络代码（MNC）。这些可以用来确定设备中的SIM卡绑定的是哪个移动运营商和国家。移动网络代码可选地跟随移动国家代码，但单独使用是不被允许的（你必须首先指定国家代码）。|
    `mcc505``mcc505-mnc03``mcc238``mcc238-mnc02``mcc238-mnc20` | 1 |'
- en: '| Language and region codes | Language and region codes are probably the most
    commonly used resource properties. This is generally how you localize your application
    to the user language preferences.These values are standard ISO language and region
    codes, and are not case-sensitive. You cannot specify a region without a country
    code (similar to `java.util.Locale`). | `en``en-rUS``es``es-rCL``es-rMX` | 1 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 语言和地区代码 | 语言和地区代码可能是最常使用的资源属性。通常，这是你根据用户语言偏好本地化应用程序的方式。这些值是标准的ISO语言和地区代码，并且不区分大小写。你不能没有国家代码指定一个地区（类似于`java.util.Locale`）。|
    `en``en-rUS``es``es-rCL``es-rMX` | 1 |'
- en: '| Screen size | There are only three variations of this property: small, medium,
    and large. The value is based on the amount of screen space that can be used:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '| 屏幕尺寸 | 这个属性只有三种变化：小、中、大。这个值基于可使用的屏幕空间量：'
- en: 'Small: QVGA (320×240 pixel) low-density type screens;'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型：QVGA（320×240像素）低密度类型的屏幕；
- en: 'Medium: WQVGA low-density, HVGA (480x360 pixels) medium-density, and WVGA high-density
    type screens;'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中型：WQVGA低密度，HVGA（480x360像素）中密度，以及WVGA高密度类型的屏幕；
- en: 'Large: VGA (640x480 pixels) or WVGA medium-density type screens'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型：VGA（640x480像素）或WVGA中密度类型的屏幕
- en: '| `small``medium``large` | 4 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `small``medium``large` | 4 |'
- en: '| Screen aspect | This is the aspect type of the screen, based on the way the
    device would "normally" be used. This value doesn''t change based on the orientation
    of the device. | `long``notlong` | 4 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 屏幕宽高比 | 这是基于设备“正常”使用方式的屏幕宽高比类型。这个值不会因为设备的方向改变而改变。| `long``notlong` | 4 |'
- en: '| Screen orientation | Used to determine whether the device is currently in
    portrait (`port`) or landscape (`land`) mode. This is only available on devices
    that can detect their orientation. | `land``port` | 1 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 屏幕方向 | 用于确定设备当前是处于竖屏（`port`）还是横屏（`land`）模式。这只有在能检测到方向的设备上可用。| `land``port`
    | 1 |'
- en: '| Night mode | This value simply changes with the time of day. | `night``notnight`
    | 8 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 夜间模式 | 这个值简单地根据一天中的时间改变。| `night``notnight` | 8 |'
- en: '| Screen density (DPI) | The DPI of the device screen. There are four possible
    values for this property:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| 屏幕密度（DPI） | 设备屏幕的DPI。这个属性有四个可能的值：'
- en: '`ldpi`: Low-density, approximately 120dpi;'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldpi`：低密度，大约120dpi；'
- en: '`mdpi`: Medium-density, approximately 160dpi;'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdpi`：中密度，大约160dpi；'
- en: '`hdpi`: High-density, approximately 240dpi;'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hdpi`：高密度，大约240dpi；'
- en: '`nodpi`: Can be used for `bitmap` resources that shouldn''t be scaled to match
    the screen density'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodpi`: 可用于不应该根据屏幕密度进行缩放的`bitmap`资源。'
- en: '| `ldpi``mdpi``hdpi``nodpi` | 4 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `ldpi``mdpi``hdpi``nodpi` | 4 |'
- en: '| Keyboard status | What sort of keyboard is available on this device? This
    attribute shouldn''t be used to determine whether the device has a hardware keyboard,
    but instead whether a keyboard (or software keyboard) is currently visible to
    the user. | `keysexposed``keyshidden``keyssoft` | 1 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 键盘状态 | 设备上可用的键盘类型是什么？这个属性不应该用来确定设备是否有硬件键盘，而应该用来确定键盘（或软件键盘）当前是否对用户可见。 | `keysexposed``keyshidden``keyssoft`
    | 1 |'
- en: Time for action – setting up the question activity
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间——设置问题活动
- en: 'To kick things off we''re going to be working with Android''s simplest layout
    called: `LinearLayout`. Unlike Java AWT or Swing, Android layout managers are
    defined as specific container types. Thus a `LinearLayout` is much like a `Panel`
    with a built-in `LayoutManager`. If you''ve worked with GWT, you''ll be quite
    familiar with this concept. We''ll lay out the screen in a simple top-to-bottom
    structure (which `LinearLayout` is perfect for).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将使用Android最简单的布局，称为：`LinearLayout`。与Java AWT或Swing不同，Android布局管理器被定义为特定的容器类型。因此，`LinearLayout`就像一个带有内置`LayoutManager`的`Panel`。如果您使用过GWT，您会对这个概念非常熟悉。我们将以简单的从上到下结构（`LinearLayout`非常适合）来布局屏幕。
- en: Open the file in the `/res/layout` directory of your project named `main.xml`
    in you favorite IDE or text editor.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的IDE或文本编辑器中打开项目`/res/layout`目录下名为`main.xml`的文件。
- en: Delete any template XML code.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任何模板XML代码。
- en: 'Copy the following XML code into the file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下XML代码复制到文件中：
- en: '[PRE5]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just removed the "Hello World" example, and put in an entirely empty layout
    structure which will serve as the platform for us to build the rest of the user
    interface upon. As you can see, Android has a special XML namespace for its resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚移除了“Hello World”示例，并放入了一个完全空的布局结构，这将成为我们构建剩余用户界面的平台。如您所见，Android为其资源有一个特殊的XML命名空间。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All resource types in Android use the same XML namespace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的所有资源类型都使用相同的XML命名空间。
- en: We declare our root element as `LinearLayout`. This element corresponds directly
    to the class `android.widget.LinearLayout`. Each element or attribute prefixed
    with the Android namespace corresponds to an attribute that is interpreted by
    the Android resource compiler.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根元素声明为`LinearLayout`。这个元素直接对应于类`android.widget.LinearLayout`。每个带有Android命名空间前缀的元素或属性都对应于由Android资源编译器解释的属性。
- en: The AAPT (Android Asset Packaging Tool) will generate an `R.java` file into
    your root (or primary) package. This file contains all of the Java variables used
    to reference your various application resources. In our case, we have the `main.xml`
    package in the `/res/layout` directory. This file becomes an `R.layout.main` variable
    with a constant value assigned as its identification.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AAPT（Android资源打包工具）将生成一个`R.java`文件到您的根（或主要）包中。这个文件包含了用于引用各种应用资源的Java变量。在我们的例子中，我们有`/res/layout`目录中的`main.xml`包。这个文件变成了一个`R.layout.main`变量，并分配一个常数作为其标识。
- en: Populating a View and a ViewGroup
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充`View`和`ViewGroup`。
- en: A widget in Android is called a `View`, while a container (such as `LinearLayout`)
    is a `ViewGroup`. We have an empty `ViewGroup` now, but we need to start populating
    it in order to build up our user interface. While it is possible to nest a `ViewGroup`
    inside another `ViewGroup` object, an `Activity` has only one root `View`—so a
    layout XML file may have only one root `View`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，一个控件被称为`View`，而一个容器（如`LinearLayout`）是`ViewGroup`。现在我们有一个空的`ViewGroup`，但我们需要开始填充它以构建我们的用户界面。虽然可以将`ViewGroup`嵌套在另一个`ViewGroup`对象中，但`Activity`只有一个根`View`——因此布局XML文件只能有一个根`View`。
- en: Time for action – asking a question
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间——提出问题
- en: In order to ask our user a question, you will need to add a `TextView` to the
    top of your layout. A `TextView` is a bit like a `Label` or `JLabel`. It's also
    the base class for many other Android `View` widgets that display text. We want
    it to take up all of the available horizontal space, but only enough vertical
    space for our question to fit. We populate the `TextView` with **Please wait...**
    as its default text. Later, on we will replace this with a dynamically selected
    question.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户提问，你需要将`TextView`添加到布局的顶部。`TextView`有点像`Label`或`JLabel`。它也是许多其他显示文本的Android
    `View`小部件的基础类。我们希望它占用所有可用的水平空间，但只需足够的垂直空间让我们的问题适应。我们用**请稍等...**作为其默认文本填充`TextView`。稍后，我们将用动态选择的问题替换它。
- en: Go back to your `main.xml` file.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的`main.xml`文件。
- en: Between the `<LinearLayout...>` and `</LinearLayout>` create a `<TextView />`
    element, ending it with the empty element `/>` syntax since elements representing
    `View` objects are not allowed to have child elements.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<LinearLayout...>`和`</LinearLayout>`之间创建一个`<TextView />`元素，使用空元素`/>`语法结束，因为代表`View`对象的元素不允许有子元素。
- en: 'Give the `TextView` element an ID attribute:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`TextView`元素设置一个ID属性：
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Change the layout width and height attributes to `fill_parent` and `wrap_content`
    respectively (the same as the `LinearLayout` element):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局的宽度和高度属性分别更改为`fill_parent`和`wrap_content`（与`LinearLayout`元素相同）：
- en: '[PRE7]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Give the `TextView` some placeholder text so we can see it on the screen:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`TextView`设置一些占位文本，以便我们可以在屏幕上看到它：
- en: '[PRE8]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Reinstall the application using Apache Ant from your project root folder:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目根目录使用Apache Ant重新安装应用程序：
- en: '[PRE9]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the application again in the emulator and it should look like the following
    screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在模拟器中运行应用程序，它应该看起来像以下截图：
- en: '![Time for action – asking a question](img/4484_01_02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![动手时间——提出问题](img/4484_01_02.jpg)'
- en: 'The code for the `TextView` should end up looking something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextView`的代码最终看起来应该像这样：'
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: In the preceding example, we used `fill_parent` and `wrap_content` as values
    for the layout width and height attributes. The `fill_parent` value is a special
    value that is always equal to the parent size. If it's used as the value for the
    `android:layout_width` attribute (as in our example), then it's the width of the
    parent view. If it's used in the `android:layout_height` attribute, it would be
    equal to the height of the parent view instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`fill_parent`和`wrap_content`用作布局宽度和高度属性的值。`fill_parent`的值是一个特殊值，始终等于父视图的大小。如果它用作`android:layout_width`属性的值（如我们的示例所示），那么它就是父视图的宽度。如果它在`android:layout_height`属性中使用，那么它将等于父视图的高度。
- en: The value `wrap_content` can be used much like a preferred size in Java AWT
    or Swing. It says to the `View` object, "Take as much space as you need to, but
    no more". The only valid place to use these special attribute values is in the
    `android:layout_width` and `android:layout_height` attributes. Anywhere else will
    result in a compiler error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrap_content`的值在Java AWT或Swing中类似于首选大小。它告诉`View`对象，“占用你所需要的空间，但不要更多”。这些特殊属性值唯一有效的使用地方是`android:layout_width`和`android:layout_height`属性中。其他任何地方使用都会导致编译错误。'
- en: We will need to access this `TextView` in our Java code later, in order to invoke
    its `setText` method (which directly corresponds to the `android:text` attribute
    we used for the placeholder text). A Java reference to a resource variable is
    created by assigning the resource an ID. In this example, the ID is declared here
    as `@+id/question`. The AAPT will generate an `int` value as an identifier for
    each resource of `id` as part of your `R` class. The ID attribute is also needed
    for accessing resources from another resource file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后需要在Java代码中访问这个`TextView`，以便调用其`setText`方法（该方法直接对应于我们用于占位文本的`android:text`属性）。通过为资源分配ID，创建了对资源变量的Java引用。在这个例子中，ID在这里声明为`@+id/question`。AAPT将为`id`类型的每个资源生成一个`int`值作为标识符，作为你的`R`类的一部分。ID属性还用于从另一个资源文件访问资源。
- en: Time for action – adding a space for answers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——添加答案的空间
- en: 'While posing a question to the user is all very fine and well, we need to give
    them some way to answer that question. We have several possibilities at our disposal:
    We could use a `RadioGroup` with a `RadioButton` for each possible answer, or
    a `ListView` with an item for each answer. However, to minimize the required interaction,
    and make things as clear as possible, we use one `Button` for each possible answer.
    However, this complicates things slightly, since you can''t declare a variable
    number of `Button` objects in your layout XML file. Instead, we will declare a
    new `LinearLayout` and populate it with `Button` objects in the Java code.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户提问当然很好，但我们还需要给他们提供回答问题的方法。我们有几种选择：可以使用带有`RadioButton`的`RadioGroup`来表示每个可能的答案，或者使用带有每个答案项的`ListView`。然而，为了最小化所需的交互，并尽可能清晰，我们为每个可能的答案使用一个`Button`。但这稍微有些复杂，因为你在布局XML文件中不能声明可变数量的`Button`对象。相反，我们将声明一个新的`LinearLayout`，并在Java代码中使用`Button`对象填充它。
- en: Under the `TextView` where we pose our question, you will need to add a `<LinearLayout
    />` element. While this element would normally have child elements, in our case,
    the number of possible answers is varied, so we leave it as an empty element.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们提出问题的`TextView`下方，你需要添加一个`<LinearLayout />`元素。虽然这个元素通常会有子元素，但在我们的案例中，可能答案的数量是变化的，所以我们将其留为一个空元素。
- en: 'By default, a `LinearLayout` will place its child `View` objects horizontally
    alongside each other. However, we want each child `View` to be vertically below
    each other, so you''ll need to set the `orientation` attribute of the `LinearLayout`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`LinearLayout`会将它的子`View`对象水平排列。然而，我们希望每个子`View`垂直排列，因此你需要设置`LinearLayout`的`orientation`属性：
- en: '[PRE11]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will need to populate the new `ViewGroup` (`LinearLayout`) later in our
    Java code, so give it an ID: `answers`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们稍后需要在Java代码中填充新的`ViewGroup`（`LinearLayout`），所以给它一个ID：`answers`：
- en: '[PRE12]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Like our `TextView` and root `LinearLayout`, make the width `fill_parent`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们的`TextView`和根`LinearLayout`一样，将宽度设置为`fill_parent`：
- en: '[PRE13]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Make the height `wrap_content` so that it doesn''t take up more space than
    all the buttons it will be populated with:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将高度设置为`wrap_content`，使其不会占用比所有按钮更多的空间：
- en: '[PRE14]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting code should look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码应如下所示：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'You may have noticed that for this example, we have no content in our new `LinearLayout`.
    This may seem a little unusual, but in this case, we want to populate it with
    a variable number of buttons—one for each possible answer to our multiple-choice
    questions. However, for the next part of the example we need some simple content
    `Button` widgets in this `LinearLayout` so that we can see the entire screen layout
    in action. Use the following code in your layout resource file to add **Yes!**,
    **No!**, and **Maybe?** `Button` widgets to the `LinearLayout`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，对于这个例子，我们新的`LinearLayout`中没有内容。这可能看起来有些不寻常，但在这个案例中，我们希望用可变数量的按钮填充它——针对多项选择题的每个可能答案一个。然而，对于示例的下一部分，我们需要在这个`LinearLayout`中添加一些简单的内容`Button`小部件，以便我们可以看到整个屏幕布局的效果。在你的布局资源文件中使用以下代码，向`LinearLayout`添加**Yes!**，**No!**和**Maybe?**
    `Button`小部件：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In Android XML layout resources, any `View` classes extending from the `ViewGroup`
    class are considered containers. Adding widgets to them is as simple as nesting
    those `View` elements inside the element of your `ViewGroup` (as opposed to closing
    it with no child XML elements).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android XML布局资源中，任何从`ViewGroup`类扩展的`View`类都被视为容器。向它们添加小部件就像将那些`View`元素嵌套在`ViewGroup`的元素内（而不是用没有子XML元素的闭合它）一样简单。
- en: 'The following is a screenshot of the preceding **Yes!**, **No!**, **Maybe?**
    options:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述**Yes!**，**No!**，**Maybe?**选项的屏幕截图：
- en: '![What just happened?](img/4484_01_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/4484_01_03.jpg)'
- en: Time for action – adding more buttons
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——添加更多按钮
- en: We have two additional buttons to add to the screen layout. One will allow the
    user to skip the current question; the other will allow them to look at the short
    list of meals that we have filtered through so far (based on the questions they
    have already answered).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向屏幕布局添加两个额外的按钮。一个将允许用户跳过当前问题；另一个将允许他们查看到目前为止我们已过滤的简短餐单列表（基于他们已经回答的问题）。
- en: 'Start by creating an empty `<Button />` element below our answers `ViewGroup
    <LinearLayout />` (but still within the root `LinearLayout` element). Assign it
    the ID `skip`, so that we can reference it in Java:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们答案`ViewGroup <LinearLayout />`下方（但仍在根`LinearLayout`元素内）创建一个空的`<Button
    />`元素。给它分配ID `skip`，这样我们就可以在Java中引用它：
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create some padding between the answers and the new button by using a margin:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用边距为答案和新按钮之间创建一些填充：
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Give it the display label **Skip Question**:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它显示标签 **跳过问题**：
- en: '[PRE19]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Like all of the previous widgets, the width should be `fill_parent` and the
    height should be `wrap_content`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有之前的控件一样，宽度应为`fill_parent`，高度应为`wrap_content`：
- en: '[PRE20]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now create another empty `<Button />` element below the **Skip Question** button
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**跳过问题**按钮下方创建另一个空的 `<Button />` 元素。
- en: 'The ID for the new button should be `view`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新按钮的ID应为 `view`：
- en: '[PRE21]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We want this button to display the text: **Feed Me!**:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个按钮显示文本：**Feed Me!**：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, put a little space between the **Skip Question** button, and the new
    **Feed Me!** button:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在**跳过问题**按钮和新**Feed Me!**按钮之间放置一点空间：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, set the width and height of the **Feed Me!** button as with the other
    elements we''ve created so far:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**Feed Me!**按钮的宽度和高度设置为与我们迄今为止创建的其他元素一样：
- en: '[PRE24]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you''ve completed these two buttons, your layout XML file should now end
    with:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这两个按钮后，你的布局XML文件现在应该以以下内容结束：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened*'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: Separation of unrelated user interface objects is a very important part of user
    interface design. Groups of items can be separated by whitespace, a border, or
    a box. In our case, we chose to use whitespace, as space also helps make the user
    interface feel cleaner.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将不相关的用户界面对象分开是用户界面设计的一个非常重要的部分。可以通过空白、边框或盒子将项目组分开。在我们的案例中，我们选择使用空白，因为空间也有助于让用户界面感觉更清洁。
- en: 'We created our whitespace by using a margin above each of the buttons. Margins
    and padding work exactly the same way as they (should) do in CSS. A margin is
    spacing outside of the widget, while padding is spacing inside the widget. In
    Android, a margin is the concern of the `ViewGroup`, and so its attribute name
    is prefixed with `layout_`. Because padding is the responsibility of a `View`
    object, the padding attribute has no such prefix:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在每个按钮上方使用边距来创建空白空间。边距和填充的工作方式与CSS中的（应该）完全一样。边距是控件外的空间，而填充是控件内的空间。在Android中，边距是`ViewGroup`的关注点，因此其属性名称以`layout_`为前缀。由于填充是`View`对象的责任，因此填充属性没有这样的前缀：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code would create extra space between the edge of the `Button`
    and the text in the middle of it, as well as retaining the margin above the button.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在`Button`的边缘和中间文本之间创建额外的空间，同时保留按钮上方的边距。
- en: 'All of the measurements in the preceding example are specified in the `sp`
    unit, which is short for "scale independent pixels". Much like CSS, you suffix
    your measurement numbers with the unit of size that you are specifying the measurement
    in. Android recognizes the following measurements:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例中的所有测量单位均为`sp`，它是“与比例无关的像素”的缩写。与CSS类似，你可以在你指定的尺寸单位后缀上测量数字。Android识别以下测量单位：
- en: '| Unit suffix | Full name | Description and uses |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 单位后缀 | 全名 | 描述和用途 |'
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `px` | Pixel | Exactly one pixel of the device screen. This unit is the most
    common when writing desktop applications, but with the wide variety of phone screen
    sizes, it becomes much harder to use. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `px` | 像素 | 设备屏幕上的一个精确像素。这个单位在编写桌面应用程序时最常见，但随着手机屏幕尺寸的多样化，它变得较难使用。 |'
- en: '| `in` | Inch | One inch (or the closest approximation). This is based on the
    physical size of the screen. This is great if you need to work with real world
    measurements, but again, because of the variations in the size of a device screen,
    it is not always very useful. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 英寸 | 一英寸（或最接近的近似值）。这是基于屏幕的物理尺寸。如果你需要与实际世界尺寸一起工作，这很棒，但由于设备屏幕尺寸的变异，它并不总是非常有用。
    |'
- en: '| `mm` | Millimeters | Another real world measurement, made to the closest
    approximation. This is just a metric version of inches: 25.4 millimeters in 1
    inch. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `mm` | 毫米 | 另一个实际尺寸的测量，尽可能近似。这仅是英寸的公制版本：1英寸等于25.4毫米。 |'
- en: '| `pt` | Points | Points are 1/72 of an inch in size. Much like millimeters
    and inches, they are very useful for sizing things against real-world sizes. They
    are also commonly used for sizing fonts, and so work well relative to font sizes.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `pt` | 点 | 点的大小为1/72英寸。与毫米和英寸类似，它们对于与实际尺寸相对的大小调整非常有用。它们也常用于调整字体大小，因此相对于字体大小来说非常好用。
    |'
- en: '| `dp` or `dip` | Density-independent-pixels | A single DP is the same size
    as a single pixel is for a 160 dpi screen. This size is not always a direct ratio,
    not always precise, but is a best approximation for the current screen. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `dp` 或 `dip` | 密度独立像素 | 单个DP在160 dpi的屏幕上与单个像素大小相同。这个大小并不总是成比例的，也不总是精确的，但它是当前屏幕的最佳近似值。
    |'
- en: '| `sp` | Scale-independent pixels | Much like the `dp` unit, it is a pixel
    scaled according to the user selected font size. This is possibly the best unit
    to use, as it''s based on a user-selected parameter. The user may have increased
    the font size because they find the screen hard to read. Using an `sp` unit ensures
    that your user interface scales with it. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `sp` | 比例独立像素 | 与`dp`单位类似，它是根据用户选择的字体大小缩放的像素。这可能是最佳的单位，因为它是基于用户选择的参数。用户可能因为觉得屏幕难以阅读而增加了字体大小。使用`sp`单位可以确保你的用户界面随之缩放。
    |'
- en: Defining common dimensions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义通用尺寸
- en: 'Android also allows you to define your own dimension values as resource constants
    (note: dimensions, not measurements). This can be useful when you want several
    `view` widgets to be the same size, or to define a common font size. Files containing
    dimension declarations are placed in the `/res/values` directory in your project.
    While the actual file name isn''t significant, a common name is `dimens.xml`.
    Dimensions can technically be included with other value types (that is, strings),
    but this is not recommended since it makes it harder to trace the dimension that
    are being applied at runtime.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓还允许你定义自己的尺寸值作为资源常量（注意：是尺寸，不是测量）。当你想要多个`view`组件大小相同，或者定义一个通用的字体大小时，这会很有用。包含尺寸声明的文件放在项目的`/res/values`目录中。实际的文件名并不重要，常见的名称是`dimens.xml`。从技术上讲，尺寸可以与其他值类型（即字符串）一起包含，但这并不推荐，因为它使得在运行时追踪应用的尺寸变得更加困难。
- en: One advantage of having your dimensions in their own file as opposed to being
    declared inline) is that you can then localize them based on the size of the screen.
    This makes screen-resolution-significant scales (such as pixels) much more useful.
    For example, you can place a `dimens.xml` file with different values into `/res/values-320x240`
    and another version of the same dimensions into `/res/values-640x480`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将尺寸放在它们自己的文件中，而不是内联声明的一个优点是，你可以根据屏幕大小对它们进行本地化。这使得与屏幕分辨率相关的刻度（如像素）更加有用。例如，你可以将一个`dimens.xml`文件放入`/res/values-320x240`目录中，并带有不同的值，再将同一尺寸的另一个版本放入`/res/values-640x480`目录中。
- en: 'A dimensions resource file is a simple values file (much like `strings.xml`),
    but dimensions are defined with the `<dimen>` tag:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸资源文件是一个简单的值文件（类似于`strings.xml`），但是尺寸是通过`<dimen>`标签定义的：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To access this as a size in a layout XML file, you use a resource reference
    (much the same way as you access a resource string):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要在布局XML文件中作为大小访问，你可以使用资源引用（这与访问资源字符串的方式类似）：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Building a list of common dimensions comes in handy when you want to build complex
    layouts that will look good on many different screens since it avoids the need
    to build several different layout XML files.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个通用尺寸列表在构建复杂布局时会很有帮助，这些布局将在许多不同的屏幕上看起来都很好，因为它避免了需要构建几个不同的布局XML文件。
- en: Have a go hero – improve the styling
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试改进样式的大侠——提升样式
- en: Now we have the most basic structure for this user interface, but it doesn't
    really look too great. Other than the margins between the answer buttons, and
    the **Skip Question** and **Feed Me!** buttons, you can't really tell them apart.
    We need to let the user know that these buttons all do different things. We also
    need to draw more attention to the question, especially if they don't have a lot
    of time to squint at their screen. You may need the Android documentation, which
    can be found online at [http://developer.android.com/reference/](http://developer.android.com/reference/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个用户界面最基本的结构，但它看起来并不太好看。除了答案按钮之间的边距，以及**跳过问题**和**给我提示！**按钮之外，你几乎无法区分它们。我们需要让用户知道这些按钮各司其职。同时，我们也需要让问题更加突出，尤其是如果他们没有太多时间在屏幕上眯着眼看的时候。你可能需要安卓的文档，可以在网上找到，地址是[http://developer.android.com/reference/](http://developer.android.com/reference/)。
- en: We have a question at the top of our screen, but as you can see in the previous
    screenshots, it doesn't stand out much. Therefore, it's not really very clear
    to the user what they need to do (especially the first time they use the application).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在屏幕顶部有一个问题，但正如你在之前的屏幕截图中看到的，它并不突出。因此，对于用户来说，他们需要做什么并不是非常清晰（尤其是第一次使用该应用程序时）。
- en: 'Try making the following styling changes to the question `TextView` at the
    top of our screen. These will only require you to add some attributes to its XML
    element:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对屏幕顶部的题目`TextView`进行以下样式更改。这只需要你为其XML元素添加一些属性：
- en: Center the text.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本居中。
- en: Make the text bold.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使文本加粗。
- en: Change the text size to `24sp`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本大小改为`24sp`。
- en: Add `12sp` spacing between the bottom of the question and the answer buttons
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在问题和答案按钮之间添加`12sp`的间距
- en: The **Feed Me!** button is also very important. This is the button that gives
    the user access to the list of suggested recipes that the application has filtered
    based on their answers, so it should look good.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**喂我！**按钮也非常重要。这是让用户访问应用程序根据他们的答案过滤出的建议食谱列表的按钮，所以它应该看起来不错。'
- en: 'The following styling should help the **Feed Me!** button to stand out nicely
    (hint: `Button` extends `TextView`):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下样式应该有助于**喂我！**按钮很好地突出（提示：`Button`继承自`TextView`）：
- en: Make the text size `18sp`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本大小设置为`18sp`。
- en: Change the text color to a nice red `#9d1111`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本颜色改为好看的红色`#9d1111`。
- en: Style the text as bold.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本样式设置为加粗。
- en: 'Add a text shadow: `x=0`, `y=-3`, `radius=1.5`, and `color=white` ("`#fff`").'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加文本阴影：`x=0`，`y=-3`，`radius=1.5`，`color=white`（"`#fff`"）。
- en: 'When you''ve finished styling the screen, it should look like the following
    screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成屏幕样式的调整后，它应该看起来像以下截图：
- en: '![Have a go hero – improve the styling](img/4484_01_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![尝试改进样式](img/4484_01_04.jpg)'
- en: Limitations of the layout XML format
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局XML格式的限制
- en: One of the most obvious limitations of the layout XML format is that you can't
    dynamically populate part of the `Activity` based on external variables—there
    are no loops or methods in the XML file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 布局XML格式最明显的限制之一是，你不能基于外部变量动态填充`Activity`的一部分——XML文件中没有循环或方法。
- en: In our example, this limitation shows itself in the form of our empty `LinearLayout`.
    Because each question has any number of possible answers, we need a varying number
    of buttons in the group. For our purposes, we will create the `Button` objects
    and put them into the `LinearLayout` as part of the Java code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，这种限制以空`LinearLayout`的形式出现。因为每个问题都有任意数量的可能答案，我们需要在组内变动数量的按钮。对于我们的目的，我们将在Java代码中创建`Button`对象并将它们放入`LinearLayout`。
- en: 'The other place the XML layout format falls down is dynamically referencing
    external resources. This can be seen in our example, where we put placeholder
    text in the `android:text` attribute on the `TextView` element—`question`. We
    could have referenced an external string using the following syntax:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: XML布局格式另一个失败的地方是动态引用外部资源。这可以在我们的示例中看到，我们在`TextView`元素上放置了占位符文本——`question`的`android:text`属性。我们可以使用以下语法引用外部字符串：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will effectively reference a static variable from the `strings.xml` file.
    It's not suitable for a dynamically selected question, which will change each
    time we initialize the `Activity`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效地引用`strings.xml`文件中的静态变量。它不适合动态选择的问题，每次初始化`Activity`时都会改变。
- en: Pop quiz
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: What reason do you have for writing your layouts in XML instead of in pure Java
    code?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有什么理由用XML而不是纯Java代码来编写你的布局？
- en: Android can read the layout file externally for optimization.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安卓可以从外部读取布局文件以进行优化。
- en: The layout becomes part of the resource selection process.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局成为资源选择过程的一部分。
- en: Your users could download new layouts from the App Store.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的用户可以从App Store下载新的布局。
- en: The layout can have custom themes applied to it.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局可以应用自定义主题。
- en: How would we make the text of the **Next Question** button bold?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使**下一题**按钮的文本加粗？
- en: Use the `android:typeface` attribute.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`android:typeface`属性。
- en: Create a custom `Button` implementation.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义的`Button`实现。
- en: 'Add a CSS attribute: `style="font-weight: bold"`.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加一个CSS属性：`style="font-weight: bold"`。'
- en: Use the `android:textStyle` attribute.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`android:textStyle`属性。
- en: What would happen if we changed the `LinearLayout` from `vertical` orientation,
    to `horizontal`?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将`LinearLayout`从`vertical`方向改为`horizontal`方向，会发生什么？
- en: The layout would turn on its side.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局会侧翻。
- en: All of the widgets would be squashed together on the screen.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有小部件在屏幕上会被挤压在一起。
- en: Only the question `TextView` would be visible on the screen.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有问题的`TextView`会显示在屏幕上。
- en: The question, and possibly some other `View` objects may be visible on the screen
    depending on the number of pixels available.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据可用的像素数量，问题以及可能的其他`View`对象可能会显示在屏幕上。
- en: The layout would overflow, causing the widgets to appear next to each other,
    over several lines.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局将溢出，导致小部件紧挨着出现在多行上。
- en: Populating the QuestionActivity
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充QuestionActivity
- en: 'We have a basic user interface, but right now, it''s static. We may want to
    ask our user many different questions, each of which have different answers. We
    may also want to vary which questions we ask in some way or another. In short,
    we need some Java code to populate the layout with a question and some possible
    answers. Our questions are made up of two parts:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个基本用户界面，但现在它是静态的。我们可能想要向用户提出许多不同的问题，每个问题都有不同的答案。我们还可能以某种方式改变我们提出的问题。简而言之，我们需要一些Java代码来填充布局，加入一个问题及一些可能的答案。我们的问题由两部分组成：
- en: The question
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: A list of possible answers
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能答案的列表
- en: 'In this example, we will make use of string array resources to store all of
    the question and answer data. We will use one string array to list the question
    identifiers, and then one string array for each question and its answers. The
    advantages of this approach are very similar to the advantages of using a layout
    XML file instead of hard-coding it. The `res/values` directory of your project
    will have an auto-generated `strings.xml` file. This file contains string and
    string-array resources that you want your application to use. Here is the start
    of our `strings.xml` file, with two questions to ask the user:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将利用字符串数组资源来存储所有问题和答案数据。我们将使用一个字符串数组来列出问题标识符，然后为每个问题及其答案使用一个字符串数组。这种方法的优势与使用布局XML文件而不是硬编码的优势非常相似。你的项目的`res/values`目录中将有一个自动生成的`strings.xml`文件。这个文件包含了你希望应用程序使用的字符串和字符串数组资源。以下是我们`strings.xml`文件的开始部分，其中包含两个要问用户的问题：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first item of each `question` array (`vegetarian` and `size`) is the question
    itself, while each following item is an answer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题数组(`vegetarian`和`size`)的第一个条目是问题本身，而随后的每个条目都是一个答案。
- en: Time for action – writing more Java code
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——编写更多的Java代码
- en: Open the `QuestionActivity.java` file in an editor or IDE.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器或IDE中的`QuestionActivity.java`文件。
- en: 'Import the Android `Resources` class below the package declaration:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包声明下方导入Android的`Resources`类：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to start asking the questions from your `strings.xml` file, you''ll
    need a method to look in the `questions <string-array>` and find the name of the
    array that contains the current question. This is not normally something you need
    to do with application resources—their identifiers are generally known to you
    through the `R` class. In this case however, we want to work in the order defined
    in the `questions <string-array>`, making things a little bit more difficult:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从你的`strings.xml`文件开始提问，你需要一个方法来查找`questions <string-array>`并找到包含当前问题的数组名称。这通常不是你在应用程序资源中需要做的事情——它们的标识符通常通过`R`类为你所知。但在此情况下，我们想要按照`questions
    <string-array>`中定义的顺序进行操作，这使得事情变得有些复杂：
- en: '[PRE32]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now look at the `questions` string-array, which contains the identifying
    name of each question (our index string-array):'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以查看`questions`字符串数组，它包含了每个问题的标识名称（我们的索引字符串数组）：
- en: '[PRE33]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have the array of questions, and we need to find the identifier value. This
    is much like using `R.array.vegetarian` for the `vegetarian` question, except
    that it''s a dynamic lookup, and therefore much slower than normal. In general,
    the following line is not recommended, but in our case it''s very useful:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个问题数组，需要找到标识符值。这类似于对`vegetarian`问题使用`R.array.vegetarian`，只不过这是一个动态查找，因此比正常情况要慢得多。通常情况下，以下这行代码是不推荐的，但对我们来说非常有用：
- en: '[PRE34]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `QuestionActivity` class will display several questions to the user. We
    want the application to "play nice" with the phone and its environment. For that
    reason, each question will be posed in a new instance of `QuestionActivity` (allowing
    the device to control the display of our `Activity`). However, this method raises
    an important question: How do we know the index of the question to pose to the
    user? The answer: Our `Intent`. An `Activity` is started with an `Intent` object,
    and each `Intent` object may carry any amount of "extra" information (similar
    to request attributes in the `HttpServletRequest` interface) for the `Activity`
    to use, sort of like arguments to a `main` method. So, an `Intent` is also like
    a `HashMap`, containing special data for the `Activity` to use. In our case we
    use an integer property named `KitchenDroid.Question`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QuestionActivity`类将向用户展示几个问题。我们希望应用程序能够与手机及其环境"友好相处"。因此，每个问题都将在`QuestionActivity`的新实例中提出（允许设备控制我们`Activity`的显示）。然而，这种方法引发了一个重要问题：我们如何知道要向用户提出的问题的索引？答案是：我们的`Intent`。`Activity`是通过一个`Intent`对象启动的，每个`Intent`对象可能携带任何数量的"额外"信息（类似于`HttpServletRequest`接口中的请求属性），供`Activity`使用，有点像`main`方法的参数。所以，`Intent`也像一个`HashMap`，包含供`Activity`使用的特殊数据。在我们的例子中，我们使用了一个名为`KitchenDroid.Question`的整型属性：'
- en: '[PRE35]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These two methods form the basis for populating our question screen and navigating
    our way through a defined list of questions. When complete, they should look like
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法构成了我们填充问题屏幕和按定义好的问题列表进行导航的基础。完成时，它们应该看起来像这样：
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*What just happened*'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: The `getQuestionID` method is pretty straight forward. In our code we use `R.array.questions`
    to access the `<string-array>` which identifies all of the questions we are going
    to ask the user. Each question has a name in the form of a `String`, and a corresponding
    resource identification number in the form of an `int`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`getQuestionID`方法非常直接。在我们的代码中，我们使用`R.array.questions`来访问`<string-array>`，它标识了我们将要向用户提出的所有问题。每个问题都有一个`String`形式的名称，以及一个`int`形式的对应资源识别号。'
- en: 'In the `getQuestionID` method, we make use of the `Resources.getIdentifier`
    method, which looks for the resource identifier (the integer value) for a given
    resource name. The second parameter of the method is the type of resource to look
    up. This parameter is normally an inner class to the generated `R` class. Finally,
    we pass the base package that the resource is found in. Instead of all three of
    these parameters, you could also look up the resource by its full resource name:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getQuestionID`方法中，我们使用了`Resources.getIdentifier`方法，该方法用于查找给定资源名称的资源标识符（整数值）。该方法的第二个参数是要查找的资源类型。这个参数通常是生成的`R`类的内部类。最后，我们传递了资源所在的基包。除了这三个参数，你也可以通过完整的资源名称来查找资源：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `getQuestionIndex` method tells us where in the `questions <string-array>`
    we currently are, and thus, which question to ask the user. This is based on the
    "extra" information in the `Intent` that triggered the `Activity`. The `getIntent()`
    method provides you with access to the `Intent` that triggered your `Activity`.
    Each `Intent` may have any amount of "extra" data, and that data may be any "primitive"
    or "serializable" type. Here we fetch the `KitchenDroid.Question` extra integer
    value from our `Intent`, substituting a value of 0 if it has not been set (that
    is, the default value). If the user taps our icon in the menu, Android won't have
    specified that value, so we start from the first question.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`getQuestionIndex`方法告诉我们当前在`questions <string-array>`中的位置，从而确定要向用户提出哪个问题。这是基于触发`Activity`的`Intent`中的"额外"信息。`getIntent()`方法为你提供了访问触发你`Activity`的`Intent`的途径。每个`Intent`可以有任何数量的"额外"数据，这些数据可以是任何"原始"或"可序列化"的类型。这里我们从`Intent`中获取了`KitchenDroid.Question`额外的整数值，如果没有设置则替换为0（即默认值）。如果用户点击菜单中的图标，Android没有指定该值，那么我们从第一个问题开始。'
- en: Dynamically creating widgets
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态创建小部件
- en: Up to this point we've only used the layout XML file to populate our screen.
    In some cases, this is just not enough. In this simple example, we want the user
    to have a list of buttons that they can touch to answer the questions posed to
    them. We could pre-create some buttons and name them `button1`, `button2`, and
    so on, but that means limiting the number of possible answers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了布局XML文件来填充我们的屏幕。在某些情况下，这还不够。在这个简单的例子中，我们希望用户有一个按钮列表，他们可以点击来回答提出的问题。我们可以预先创建一些按钮并将它们命名为`button1`、`button2`等，但这意味着限制了可能的答案数量。
- en: In order to create buttons from our `<string-array>` resources, we need to do
    it in Java. We created a `ViewGroup` earlier (in the form of the `LinearLayout`
    that we named `answers`). This is where we will add our dynamically created buttons.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的 `<string-array>` 资源中创建按钮，我们需要在 Java 中进行操作。我们之前创建了一个 `ViewGroup`（以我们命名为
    `answers` 的 `LinearLayout` 的形式）。这就是我们将添加动态创建的按钮的地方。
- en: Time for action – putting the questions on the screen
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——将问题显示在屏幕上。
- en: Your application now knows where to find the questions to ask, and knows which
    question it should be asking. Now it needs to put the question on the screen,
    and allow the user to select an answer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序现在知道去哪里找问题来询问，也知道应该询问哪个问题。现在它需要将问题显示在屏幕上，并允许用户选择答案。
- en: Open the `main.xml` file in your editor or IDE.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或 IDE 中打开 `main.xml` 文件。
- en: Remove the **Yes!**, **No!**, and **Maybe?** `Button` elements from the layout
    resource.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从布局资源中移除 **Yes!**、**No!** 和 **Maybe?** `Button` 元素。
- en: Open the `QuestionActivity.java` file in an editor or IDE.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或 IDE 中打开 `QuestionActivity.java` 文件。
- en: 'We will need a new class field to hold the dynamically-created `Button` objects
    (for reference):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新的类字段来保存动态创建的 `Button` 对象（作为引用）：
- en: '[PRE38]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to keep things neat, create a new `private` method to put the questions
    on the screen: `initQuestionScreen`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持整洁，创建一个新的 `private` 方法来将问题显示在屏幕上：`initQuestionScreen`：
- en: '[PRE39]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this method, we assume that the layout XML file has already been loaded
    into the `Activity` screen (that is, it will be invoked after we `setContentView`
    in `onCreate`). This means that we can look up parts of the layout as Java objects.
    We''ll need both the `TextView` named `question` and the `LinearLayout` named
    `answers`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们假设布局 XML 文件已经加载到 `Activity` 屏幕中（即，在 `onCreate` 中 `setContentView` 之后将被调用）。这意味着我们可以将布局的部分作为
    Java 对象来查找。我们需要 `TextView` 名为 `question` 和 `LinearLayout` 名为 `answers` 的这两个对象：
- en: '[PRE40]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These two variables need to be populated with the question and its possible
    answers. For that we need the `<string-array>` (from our `strings.xml` file) which
    contains that data, so we need to know the resource identifier for the current
    question. Then we can fetch the actual array of data:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个变量需要用问题和其可能的答案来填充。为此，我们需要 `<string-array>`（来自我们的 `strings.xml` 文件），其中包含这些数据，因此我们需要知道当前问题的资源标识符。然后我们可以获取实际的数据数组：
- en: '[PRE41]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first element of a `question` string array is the question to pose to the
    user. The following `setText` call is exactly the same as specifying an `android:text`
    attribute in your layout XML file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`question` 字符串数组的第一个元素是向用户提出的问题。接下来的 `setText` 调用与在布局 XML 文件中指定 `android:text`
    属性完全相同：'
- en: '[PRE42]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We then need to create an empty array to store references to our `Button` objects:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要创建一个空数组来保存对我们 `Button` 对象的引用：
- en: '[PRE43]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we''re ready to populate the screen. A `for` loop over each of the answer
    values indexed according to our arrays:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备填充屏幕了。根据我们的数组，对每个答案值进行 `for` 循环：
- en: '[PRE44]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Get each answer from the array, skipping the question string at index zero:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组中获取每个答案，跳过索引为零的问题字符串：
- en: '[PRE45]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a `Button` object for the answer and set its label:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为答案创建一个 `Button` 对象并设置其标签：
- en: '[PRE46]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we add the new `Button` to our answers object (`ViewGroup`), and reference
    it in our `buttons` array (where we''ll need it later):'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将新的 `Button` 添加到我们的 answers 对象（`ViewGroup`）中，并在我们的 `buttons` 数组中引用它（我们稍后会需要它）：
- en: '[PRE47]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Having done that, just after the `setContentView` calls in `onCreate`, we need
    to invoke our new `initQuestionScreen` method.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做完这些之后，在 `onCreate` 中的 `setContentView` 调用之后，我们需要调用我们新的 `initQuestionScreen`
    方法。
- en: '*What just happened?*'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `findViewById` method traverses the tree of `View` objects looking for a
    specific identifying integer value. By default, any resource declared with an
    `android:id` attribute in its resource file will have an associated ID. You could
    also assign an ID by hand using the `View.setId` method.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`findViewById` 方法遍历 `View` 对象的树，寻找特定的标识整数值。默认情况下，任何在资源文件中使用 `android:id` 属性声明的资源都将有一个关联的
    ID。你也可以通过使用 `View.setId` 方法手动分配一个 ID。'
- en: Unlike many other user interface APIs, the Android user interface API is geared
    towards XML development than pure Java development. A perfect example of this
    fact is that the `View` subclasses have three different constructors, two of which
    are designed for use with the XML parsing API. Instead of being able to populate
    the `Button` label in a constructor (as with most other UI APIs), we are forced
    to first construct the object, and then use `setText` to define its label.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他用户界面API不同，Android用户界面API更倾向于XML开发而非纯Java开发。这一点的完美例证是`View`子类有三个不同的构造函数，其中两个是为与XML解析API配合使用而设计的。我们无法在构造函数中填充`Button`标签（像大多数其他UI
    API那样），而是被迫先构造对象，然后使用`setText`来定义其标签。
- en: What you do pass into the constructor of every `View` object is a `Context`
    object. In the preceding example you pass the `Activity` object into the constructor
    of the answer `Button` objects as `this`. The `Activity` class inherits from the
    `Context` class. The `Context` object is used by the `View` and `ViewGroup` objects
    to load the application resources and services that they require in order to function
    correctly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你传给每个`View`对象构造函数的是`Context`对象。在前面示例中，你将`Activity`对象作为`this`传递给答案`Button`对象的构造函数中。`Activity`类从`Context`类继承。`Context`对象被`View`和`ViewGroup`对象用来加载它们为了正确运行所需的应用程序资源和服务。
- en: You can now try running the application, in which case you'll be greeted with
    the following screen. You may have noticed that there is additional styling in
    this screenshot. If you don't have this, you may want to backtrack a little to
    the previous *Have a go hero* section.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试运行应用程序，在这种情况下，你会看到以下屏幕。你可能已经注意到这个截图中还有额外的样式。如果你没有这个，你可能需要回溯到之前的*尝试一下英雄*部分。
- en: '![What just happened?](img/4484_01_05.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_01_05.jpg)'
- en: Handling events in Android
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android中处理事件
- en: Android user interface events work in much the same way as a Swing event-listener
    or a GWT event-handler. Depending on the type of event you wish to receive, you
    implement an interface and pass an instance to the widget you wish to receive
    events from. In our case we have `Bu` `tton` widgets that fire click-events when
    they are touched by the user.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Android用户界面事件的工作方式与Swing事件监听器或GWT事件处理程序非常相似。根据你想接收的事件类型，实现一个接口并将一个实例传递给你希望从中接收事件的小部件。在我们的例子中，我们有`Button`小部件，当用户触摸时会触发点击事件。
- en: The event-listener interfaces are declared in many of the Android classes, so
    there isn't a single place you can go look for them. Also, unlike most event-listener
    systems, many widgets may only have one of any given event-listeners. You can
    identify an event-listener interface by the fact that their class names are prefixed
    with `On` (much like HTML event attributes). In order to listen for click-events
    on a widget, you would set its `OnClickListener` using the `V` `iew.setOnClickListener`
    method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听接口在许多Android类中声明，因此没有一个单独的地方可以查找它们。而且，与大多数事件监听系统不同，许多小部件可能只有一个给定类型的事件监听器。你可以通过类名前缀为`On`来识别事件监听接口（类似于HTML事件属性）。为了监听小部件上的点击事件，你会使用`View.setOnClickListener`方法来设置其`OnClickListener`。
- en: 'The following code snippet shows how a click-listener might be added to a `Button`
    object to show a `Toast`. A `Toast` is a small pop-up box which is displayed briefly
    to give the user some information:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何向`Button`对象添加一个点击监听器来显示一个`Toast`。`Toast`是一个小型的弹出框，会短暂显示以向用户提供一些信息：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding event-listener is declared as an anonymous inner class, which
    is okay when you are passing similar event-listeners to many different widgets.
    However, most of the time you'll want to be listening for events on widgets you've
    declared in an XML layout resource. In these cases it's better to either have
    your `Activity` class implement the required interfaces, or create specialized
    classes for different event-driven actions. While Android devices are very powerful,
    they are still limited when compared to a desktop computer or laptop. Therefore,
    you should avoid creating unnecessary objects in order to conserve memory. By
    placing as many event-listener methods in objects that will already be created,
    you lower the overhead required.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的事件监听器被声明为一个匿名内部类，当你需要将类似的事件监听器传递给许多不同的组件时，这样做是可以的。然而，大多数情况下，你会在XML布局资源中声明的组件上监听事件。在这些情况下，最好让你的`Activity`类实现所需的接口，或者为不同的事件驱动操作创建专门的类。尽管Android设备非常强大，但与台式电脑或笔记本电脑相比，它们仍然有限制。因此，你应该避免创建不必要的对象，以节省内存。通过将尽可能多的事件监听器方法放在已经创建的对象中，你可以降低所需的资源开销。
- en: Pop quiz
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: When you declare an object in a layout XML file, how do you retrieve its Java
    object?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在布局XML文件中声明一个对象时，你如何获取其Java对象？
- en: The object will be declared in the `R` class.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象将在`R`类中声明。
- en: Using the `Activity.findViewById` method.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Activity.findViewById`方法。
- en: By using the `Resources.getLayout` method.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Resources.getLayout`方法。
- en: The object will be injected into a field in the `Activity` class.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象将被注入到`Activity`类中的一个字段中。
- en: What is the "best" way of listening for events in an Android application?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android应用程序中监听事件的“最佳”方式是什么？
- en: Declaring the listeners as anonymous inner classes.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将监听器声明为匿名内部类。
- en: Create a separate event listener class for each `Activity`.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个`Activity`创建一个单独的事件监听器类。
- en: Implement the event-listening interfaces in the `Activity` class.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Activity`类中实现事件监听接口。
- en: Why do you pass `this Activity` into the constructors of `View` objects (that
    is, `new Button(this)`).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你要将`this Activity`传递给`View`对象（例如`new Button(this)`）的构造函数中？
- en: It defines the `Activity` screen they will be displayed on.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定义了`Activity`屏幕，它们将在上面显示。
- en: It's where event messages will be sent to.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是事件消息将被发送到的位置。
- en: It's how the `View` will reference its operating environment.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`View`将引用其操作环境的方式。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Android comes with some great tools to create and test applications, even if
    you don't have an Android device handy. That said, there's no replacement for
    actually touching your application. It's part of what makes Android such a compelling
    platform, the way it feels and responds (and the emulator just doesn't convey
    that).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了一些出色的工具来创建和测试应用程序，即使你没有Android设备在身边。话虽如此，实际触摸你的应用程序是无法替代的。这是Android平台如此吸引人的部分原因，它的感觉和响应方式（而模拟器并不能传达这一点）。
- en: One of the most important tools in an Android developer's arsenal is the resource
    selection system. With it you can build highly dynamic applications that respond
    to changes in the devices, and thus, the user environment. Changing the screen
    layout based on the orientation of the device, or when the user slides out the
    phone's QWERTY keyboard, lets them know that you've taken their preferences into
    account when building your application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Android开发者工具库中最重要工具之一是资源选择系统。通过它，你可以构建高度动态的应用程序，这些程序能够响应设备的变化，从而响应用户环境的变化。根据设备的方向改变屏幕布局，或者当用户滑出手机的QWERTY键盘时，让他们知道你在构建应用程序时考虑了他们的偏好。
- en: When building user interfaces in Android, it's strongly recommended to build
    at least the layout structure in an XML file. The XML layout files are not only
    considered as application resources, but Android also strongly favors building
    XML user interfaces over writing Java code. Sometimes, however, a layout XML file
    isn't enough, and you need to build parts of the user interface in Java. In this
    case it's a good idea to define at least a skeleton layout as XML (if possible),
    and then place the dynamically created `View` objects into the layout by using
    marker IDs and containers (much like dynamically adding to an HTML document in
    JavaScript).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中构建用户界面时，强烈建议至少在XML文件中构建布局结构。XML布局文件不仅被视为应用程序资源，而且Android也强烈倾向于通过编写XML用户界面而不是Java代码来构建。然而，有时布局XML文件是不够的，你需要用Java构建用户界面的一部分。在这种情况下，最好至少定义一个XML的布局框架（如果可能的话），然后使用标记ID和容器将动态创建的`View`对象放入布局中（类似于在JavaScript中动态添加到HTML文档）。
- en: When building a user interface, think carefully about the look and feel of the
    outcome. In our example, we use `Button` objects for the answers to questions.
    We could have used `RadioButton` objects instead, but then the user would have
    needed to select an option, and then touch a **Next Question** button, requiring
    two touches. We could also have used a `List` (which interacts nicely with the
    fact that it needs to be dynamically populated), however, a `List` doesn't indicate
    an "action" to the user quite the way a `Button` does.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建用户界面时，要仔细考虑最终的外观和感觉。在我们的示例中，我们使用`Button`对象作为问题的答案。我们本可以使用`RadioButton`对象，但那样用户就需要选择一个选项，然后触摸**下一题**按钮，需要两次触摸。我们也本可以使用`List`（它与需要动态填充的事实很好地交互），然而，`List`并不像`Button`那样向用户清楚地表示一个“动作”。
- en: When coding layouts, be careful with the measurement units that you use. It's
    strongly recommend that you stick to using `sp` for most purposes—if you can't
    use one of the special `fill_parent` or `wrap_content` values. Other values are
    highly dependent on the size of screen, and won't respond to the user preferences.
    You can make use of the resource selection process to build different screen designs
    for small, medium, or large screens. You could also define your own measurement
    unit and base it on the screen size.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写布局代码时，要小心使用测量单位。强烈建议在大多数情况下使用`sp`——除非你可以使用特殊的`fill_parent`或`wrap_content`值。其他值很大程度上取决于屏幕大小，并且不会响应用户偏好。你可以利用资源选择过程为小、中、大屏幕构建不同的屏幕设计。你也可以定义自己的测量单位，并基于屏幕大小进行设置。
- en: Always think about how your user will interact with your application, and how
    much (or little) time they are likely to have with it. Keeping each screen simple
    and responsive keeps your users happy.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 时刻考虑你的用户将如何与应用程序互动，以及他们可能会花费多少时间（或很少的时间）在其中。保持每个屏幕简洁且响应迅速可以使你的用户感到满意。
- en: Now that we've learned how to create a skeleton Android project, and a simple
    `Activiy`, we can focus on the more subtle problems and solutions of Android user
    interface design. In the next chapter, we will focus on working with data-driven
    widgets. Android has several widgets designed specifically for displaying and
    selecting from more complex data structures. These widgets form the basis of data-driven
    applications such as an address book or a calendar application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学会了如何创建一个基本的Android项目和一个简单的`Activiy`，我们可以专注于Android用户界面设计的更微妙的问题和解决方案。在下一章中，我们将重点关注数据驱动小部件的工作。Android有几个专门设计用于显示和选择更复杂数据结构的小部件。这些小部件构成了数据驱动应用程序（如地址簿或日历应用程序）的基础。
