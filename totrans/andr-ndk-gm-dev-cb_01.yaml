- en: Chapter 1. Establishing a Build Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *Some LinkedIn profiles say developing with a particular IDE is a skill.**No!
    Development without any IDE is the skill!* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Sergey Kosarevsky* |'
  prefs: []
  type: TYPE_TB
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android development tools on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Android development tools on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application template manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding native C++ code to your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching NDK toolchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting multiple CPU architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic rendering with OpenGL ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going cross platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unifying the cross-platform code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking and source code organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing release Android applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to install and configure Android NDK on Microsoft
    Windows or Ubuntu/Debian Linux, and how to build and run your first application
    on an Android-based device. We will learn how to set-up different compilers and
    **toolchains** that come with Android NDK. In addition, we show how to setup the
    GCC toolchain for Windows to build your projects. The rest of the chapter is devoted
    to cross-platform development using C++.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android development tools on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start developing games for Android you will need some essential tools to
    be installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the list of all the prerequisites you will need to start developing
    games for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK at [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is based on the Android SDK rev. 22.3 and tested with Android API
    Level 19.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Android NDK at [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)
    (we used Android NDK r9b).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Ant at [http://ant.apache.org](http://ant.apache.org). This is a Java
    command-line tool which may be unfamiliar to C++ developers. It's purpose is to
    build Java applications, and since every Android application has a Java wrapper,
    this tool will help us to pack them into archives ready for deployment (these
    are called `.apk` packages, which stands for **Android Package**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE Development Kit at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Former versions of SDK/NDK for Windows required a **Cygwin** environment, a
    Linux-like environment for Windows, to be installed. Up-to-date versions of these
    tools can run natively on Windows without any intermediate layer. We will focus
    on the Cygwin-less environment and will do all of the development without IDE.
    You heard it right, we will just use the command line. All the examples in this
    book were written and debugged on a Windows PC.
  prefs: []
  type: TYPE_NORMAL
- en: To compile native Windows applications presented in this book, you will need
    a decent C++ compiler, such as the MinGW package with a GCC toolchain. Using Microsoft
    Visual Studio is also possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Minimalist GNU for Windows** (**MinGW**) is a minimalist development environment
    for Windows applications using a port of **GNU Compiler Collection** (**GCC**).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android SDK and NDK should be installed into folders that do not contain any
    whitespaces in their names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This requirement comes from the limitations of scripts in Android SDK. There
    is a nice discussion on StackOverflow which explains some reasons behind these
    limitations at [http://stackoverflow.com/q/6603194/1065190](http://stackoverflow.com/q/6603194/1065190).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Other tools can be installed to their default locations. We used the following
    paths in our Windows 7 system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Tools | Path |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Android SDK | `D:\android-sdk-windows` |'
  prefs: []
  type: TYPE_TB
- en: '| Android NDK | `D:\ndk` |'
  prefs: []
  type: TYPE_TB
- en: '| Apache Ant | `D:\ant` |'
  prefs: []
  type: TYPE_TB
- en: '| Java Development Kit | `C:\Program Files\Java\jdk1.6.0_33` |'
  prefs: []
  type: TYPE_TB
- en: All tools have pretty decent GUI installers (see the following image, that shows
    the Android SDK Manager from SDK R21) so you don't have to use the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7785_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the Windows environment, you need the MinGW GCC toolchain. The easy to install
    all-in-one package can be found at [http://www.equation.com](http://www.equation.com),
    in the **Programming Tools** section, **Fortran, C, C++** subsection. Alternatively,
    you can download the official installer from [http://www.mingw.org](http://www.mingw.org).
    We will use the one from [www.equation.com](http://www.equation.com)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to set some environment variables to let the tools know where the
    files are located. The `JAVA_HOME` variable should point to the Java Development
    Kit folder. The `NDK_HOME` variable should point to the Android NDK installation
    folder, and `ANDROID_HOME` should point to the Android SDK folder (note the double
    backslash). We used the following environment variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JAVA_HOME=D:\Java\jdk1.6.0_23`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NDK_HOME=D:\ndk`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANDROID_HOME=D:\\android-sdk-windows`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final configuration looks similar to the one shown in the following screenshot,
    which shows the Windows **Environment Variables** dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/7785_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After MinGW has been successfully installed, you should also add the `bin` folder
    from its installation folder to the `PATH` environment variable. For example,
    if MinGW is installed to `C:\MinGW`, then `PATH` should contain the `C:\MinGW\bin`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android development tools on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installation of the basic tools on Linux is as easy as it was with their Windows
    counterpart. In this recipe, we will see how to install the basic Android development
    tools on *nix systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We assume you already have an Ubuntu/Debian system with the `apt` package manager.
    Refer to [http://wiki.debian.org/Apt](http://wiki.debian.org/Apt) for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Carry out the following steps to install the required basic tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are using the latest version of the packages for your OS by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install OpenJDK 6+:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the Apache Ant build automation tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the official Android SDK from [http://developer.android.com](http://developer.android.com).
    There is a bigger package next to it, with the ADT plugin for the Eclipse IDE.
    However, since we do all of our development from the command line, we won''t need
    it. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unpack the downloaded .`tgz` file (the actual version might vary, 22.2.1 is
    the latest version as of October 2013):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use `~/<sdk>/tools/android` to install the latest Platform Tools and all of
    the SDKs—just like in the Windows case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failure to do so will result in an error while trying to use the Ant tool when
    building any application for the Android.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get the official Android NDK from [http://developer.android.com](http://developer.android.com):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unpack the downloaded NDK `.tgz` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `NDK_ROOT` environment variable to your Android NDK directory (for
    example, `~/android-ndk-r9b` in our case):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is useful to put this line and the `JAVA_HOME` definition to `/etc/profile`
    or `/etc/environment`, if these settings are applicable to all the users of the
    system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In case you are running a 64-bit system, you must ensure that you have the 32-bit
    Java runtime installed also.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to install the libraries. Failure to do so may lead
    to errors with `adb` and `aapt` tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a nice one-liner script that helps you automatically detect the OpenJDK
    home directory. It essentially resolves the link `/usr/bin/javac` to the full
    path and returns the directory part of the path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating an application template manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we are going to create a basic template for our applications.
    Every Android application that is to be built via Android SDK, should contain
    a predefined directory structure and the configuration `.xml` files. This can
    be done using Android SDK tools and IDEs. In this recipe, we will learn how to
    do it manually. We will use these files later on as the very starting point for
    all our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us set up the directory structure of our project (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/7785_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a typical structure for any Android project. We will create all the
    required files manually rather than using Android tools.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the Java `Activity` code into the `App1\src\com\packtpub\ndkcookbook\app1\App1Activity.java
    file`, which should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The localizable application name should go to `App1\res\values\strings.xml`.
    The string parameter `app_name` is used in the `AndroidManifest.xml` file to specify
    the user-readable name of our application, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to write more scripts for Apache Ant and the Android SDK build system.
    They are necessary to build the `.apk` package of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `App1/project.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need two more files for Ant. The following is `App1/AndroidManifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our examples require at least OpenGL ES 2\. Let Android know about it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a full-screen application in a landscape screen orientation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second file is `App1/build.xml`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all the listed files in place, we can now build the project and install
    it on an Android device by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `App1` folder run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tail of the output from the previous command should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And the built debug `.apk` package is in `bin/App1-debug.apk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install the app, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to connect your device through a USB and turn USB Debugging on
    in Android settings before running this command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the output from `adb`, similar to the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application can now be started from your Android launcher (named `App1`).
    You will see just a black screen. You can exit the application using the **BACK**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't forget to put the application icon into `App1\res\drawable\icon.png`.
    Refer to the book's code bundle if you want to build the app quickly, or put your
    own icon there. 72 x 72 32-bit will do just fine. You can find the official Android
    icons guidelines at [http://developer.android.com/design/style/iconography.html](http://developer.android.com/design/style/iconography.html).
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation on the `AndroidManifest.xml` file can be found at
    [http://developer.android.com/guide/topics/manifest/manifest-intro.html](http://developer.android.com/guide/topics/manifest/manifest-intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you can update your applications without uninstalling the previous
    version using the `adb -r` command-line switch in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, before installing a new version of your application you will have
    to uninstall the existing one using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Signing release Android applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding native C++ code to your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us expand our minimalistic Java template, which was discussed in the previous
    recipe, so we can create a placeholder for our native C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to copy all the files from our `App1` project to save time while creating
    the initial project files. This recipe will focus on the changes to be made to
    the `App1` project in order to add the C++ code to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create a placeholder for our C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `jni/Wrappers.cpp` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to change our `Activity` class from the previous recipe to make use
    of the native code we just added in the preceding section, through the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here we load the native library named `libApp2.so`. Note the omitted `lib`
    prefix and `.so` extension:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tell the NDK build system how to treat the `.cpp` file. Create the `jni/Android.mk`
    file. The `Android.mk` file is used by the Android NDK build system to find out
    how to treat the source code of your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the `ifeq ($(TARGET_ARCH),x86)` section. Here we specify architecture-specific
    compiler flags for floating point support on ARMv7\. This will give you hardware
    floating-point support on the ARM architecture and a warnings-free log on the
    x86 Android target architecture..
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Paste the following code into the `jni/Application.mk` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to compile the native code. From the root of your `App2`
    project, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now proceed to the `.apk` creation as in the previous recipe by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your `libApp2.so` native shared library will be packed into the `App2-debug.apk`
    package. Install and run it. It will output a `Hello World!` string into the device
    log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `adb` command to view the device log. A nice clean formatted
    log with timestamps can be created using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual output from your device will look similar to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Switching NDK toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A toolchain is a set of tools that are used to build your project. A toolchain
    usually consists of a compiler, an assembler, and a linker. Android NDK comes
    with different toolchains—GCC and Clang—of different versions. It has a convenient
    and simple way to switch between them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look through the list of the available toolchains before proceeding. You can
    find all the available toolchains in the `$(NDK_ROOT)/toolchains/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The parameter `NDK_TOOLCHAIN_VERSION` in `Application.mk` corresponds to one
    of the available toolchains. In NDK r9b, you can switch between three GCC versions—4.6,
    and 4.7, which are marked as deprecated and will be removed from the next NDK
    releases, and 4.8\. And two Clang versions—Clang3.2, which is also marked as deprecated,
    and Clang3.3\. The default toolchain in the NDK r9b is still GCC 4.6.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the NDK r8e, you can just specify `clang` as the value of `NDK_TOOLCHAIN_VERSION`.
    This option will select the most recent version of the available Clang toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The toolchains are discovered by the `$(NDK_ROOT)/build/core/init.mk` script,
    so you can define your own toolchain in a folder named `<ABI>-<ToolchainName>`
    and use it in `Application.mk`.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple CPU architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android NDK supports different CPU architectures such as ARMv5TE and ARMv7-based
    devices, x86, and MIPS (big-endian architecture). We can create **fat** binaries
    that can run on any of the supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Find out the architecture of your Android-based device. You can do it using
    the `adb` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the two approaches to pick an appropriate set of CPU architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the NDK will generate the code for ARMv5TE-based CPUs. Use the
    parameter `APP_ABI` in `Application.mk` to select a different architecture, for
    example (use only one line from the following list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can specify multiple architectures to create a fat binary that will run
    on any of them through the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main pitfall of the fat binaries is the resulting `.apk` size, as separate
    native code versions are compiled for each of the specified architectures. If
    your application heavily uses third-party libraries, the package size can become
    an issue. Plan your deliverables wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Basic rendering with OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us add some graphics to our sample Android application `App2`. Here, we
    show how to create an off-screen bitmap, and then copy it to the screen using
    the OpenGL ES Version 2 or 3 available on your Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the `App3` sample in the book's downloadable code bundle for the full
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We assume that the reader is somewhat familiar with OpenGL and the **GL Shading
    Language** (**GLSL**). Refer to [http://www.opengl.org/documentation](http://www.opengl.org/documentation)
    for the desktop OpenGL, and [http://www.khronos.org/opengles](http://www.khronos.org/opengles)
    for the mobile OpenGL ES documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to write a simple vertex and fragment GLSL shader that will render
    our framebuffer on the screen using OpenGL ES. Let''s put them directly into `jni/Wrappers.cpp`
    as strings. The following code shows the vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fragment shader is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need the following helper function to load our shaders into OpenGL
    ES:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not go into all the details about the OpenGL ES programming here, and
    will instead focus on a minimal application (`App3`) that should initialize the
    `GLView` in Java; create fragment and vertex programs, create and fill the vertex
    array consisting of two triangles that form a single quadrilateral, and then render
    them with a texture, which is updated from `g_FrameBuffer` contents. This is it—just
    draw the offscreen framebuffer. The following is the code to draw the full-screen
    quad textured with the offscreen buffer content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These attribute variables are declared in a vertex shader. See the value of
    `g_vShaderStr[]` in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a few JNI callbacks. The first one handles the surface size changes,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Disable mip-mapping through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The second callback does the actual frame rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke our frame rendering callback through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Going cross platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea is the possibility of cross-platform development in What You See
    (on a PC) is What You Get (on a device), when most of the application logic can
    be developed in a familiar desktop environment like Windows, and it can be built
    for Android using the NDK whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform what we just discussed, we have to implement some sort of abstraction
    on top of the NDK, POSIX, and Windows API. Such an abstraction should feature
    at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to render buffer contents on the screen**: Our framework should provide
    the functions to build the contents of an off-screen framebuffer (a 2D array of
    pixels) to the screen (for Windows we refer to the window as "the screen").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event handling**: The framework must be able to process the multi-touch input
    and virtual/physical key presses (some Android devices, such as the Toshiba AC
    100, or the Ouya console, and other gaming devices, have physical buttons), timing
    events, and asynchronous operation completions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filesystem, networking, and audio playback**: The abstraction layers for
    these entities need a ton of work to be done by you, so the implementations are
    presented in [Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*, [Chapter
    4](ch04.html "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual
    Filesystem*, and [Chapter 5](ch05.html "Chapter 5. Cross-platform Audio Streaming"),
    *Cross-platform Audio Streaming*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us proceed to write a minimal application for the Windows environment,
    since we already have the application for Android (for example, `App1`). A minimalistic
    Windows GUI application is the one that creates a single window and starts the
    event loop (see the following example in `Win_Min1/main.c`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entry point is different from Android. However, its purpose remains the
    same— to initialize surface rendering and invoke callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The size of the window client area is predefined as `ImageWidth` and `ImageHeight`
    constants. However, the WinAPI function `CreateWindowA()` accepts not the size
    of the client area, but the size of the window, which includes caption, borders,
    and other decorations. We need to adjust the window rectangle to set the client
    area to the desired size through the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the offscreen device context and the bitmap, which holds our offscreen
    framebuffer through the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the application''s window is created, we have to run a typical message
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This program only handles the window destruction event and does not render
    anything. Compilation of this program is done with a single command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To render a framebuffer on the screen, we need to create a so-called device
    context with an associated bitmap, and add the `WM_PAINT` event handler to the
    window function.
  prefs: []
  type: TYPE_NORMAL
- en: To handle the keyboard and mouse events, we add the `WM_KEYUP` and `WM_MOUSEMOVE`
    cases to the `switch` statement in the previous program. Actual event handling
    is performed in the externally provided routines `OnKeyUp()` and `OnMouseMove()`,
    which contain our game logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the complete source code of the program (some omitted parts,
    similar to the previous example, are omitted). The functions `OnMouseMove()`,
    `OnMouseDown()`, and `OnMouseUp()` accept two integer arguments that store the
    current coordinates of the mouse pointer. The functions `OnKeyUp()` and `OnKeyDown()`
    accept a single argument—the pressed (or released) key code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we store our global RGBA framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We do all OS-independent frame rendering in this callback. We draw a simple
    XOR pattern ([http://lodev.org/cgtutor/xortexture.html](http://lodev.org/cgtutor/xortexture.html))
    into the framebuffer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the `WinAPI` window function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer the `g_FrameBuffer` to the bitmap through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And copy it to the window surface through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our project contains a make file the compilation can be done via a single
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program should produce the result as shown in the following screenshot,
    which shows the **Win_Min2** example running on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/7785_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main difference between the Android and Windows implementation of a main
    loop can be summarized in the following way. In Windows, we are in control of
    the main loop. We literally declare a loop, which pulls messages from the system,
    handles input, updates the game state, and render s the frame (marked green in
    the following figure). Each stage invokes an appropriate callback from our portable
    game (denoted with blue color in the following figure). On the contrary, the Android
    part works entirely differently. The main loop is moved away from the native code
    and lives inside the **Java Activity** and **GLSurfaceView** classes. It invokes
    the JNI callbacks that we implement in our wrapper native library (shown in red).
    The native wrapper invokes our portable game callbacks. Let''s summarize it in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/7785_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The rest of the book is centered on this kind of architecture and the game functionality
    will be implemented inside these portable **On...()** callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: There is yet another important note. Responding to timer events to create animation
    can be done on Windows with the `SetTimer()` call and the `WM_TIMER` message handler.
    We get to that in [Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"),
    *Porting Common Libraries,* when we speak about rigid body physics simulations.
    However, it is much better to organize a fixed time-step main loop, which is explained
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"), *Unifying
    OpenGL ES 3 and OpenGL 3*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe *Implementing the main loop* in [Chapter 8](ch08.html "Chapter 8. Writing
    a Match-3 Game"), *Writing a Match-3 Game*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unifying the cross-platform code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we have two different versions of a simple program (`Win_Min2` and
    `App3`). Let us see how to unify the common parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android, the application initialization phase is different, and since we
    use a mixed Java plus C++ approach, the entry points will be different. In C++,
    we are tied to, `int main()` or `DWORD WinMain()` functions; whereas in Android
    it is up to us to choose which JNI function we may call from our Java starter
    code. Event handling and rendering the initialization code are also quite different,
    too. To do so, we mark sections of the code with pre-processor definitions and
    put the different OS code into different files—`Wrappers_Android.h` and `Wrappers_Windows.h`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the standard macros to detect the OS for which the program is being
    compiled: Windows-targeted compilers provide the `_WIN32` symbol definition, and
    the `__linux__` macro is defined on any Linux-based OS, including Android. However,
    the `__linux__` defination is not enough, since some of the APIs are missing in
    Android. The macro `ANDROID` is a non-standard macro and we pass the `-DANDROID`
    switch to our compiler to identify the Android target in our C++ code. To make
    this for every source file, we modify the `CFLAGS` variable in the `Android.mk`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when we write the low-level code, the detection looks like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to make an entry point look the same for both the Android and
    Windows versions, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Later we will replace the `int main()` definition with the `APP_ENTRY_POINT()`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect more operating systems, compilers, and CPU architectures, it is useful
    to check out a list of predefined macros at [http://predef.sourceforge.net](http://predef.sourceforge.net).
  prefs: []
  type: TYPE_NORMAL
- en: Linking and source code organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we learned how to create basic wrappers that allow
    us to run our application on Android and Windows. However, we used an ad-hoc approach
    since the amount of source code was low and fit into a single file. We have to
    organize our project source files in a way suitable for building the code for
    larger projects in Windows and Android.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall the folder structure of the `App3` project. We have the `src` and `jni`
    folders inside our `App2` folder. The `jni/Android.mk`, `jni/Application.mk`,
    and `build.xml` files specify the Android build process. To enable the Windows
    executable creation, we add a file named `Makefile`, which references the `main.cpp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the content of `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that when we add more and more OS-independent logic, the code resides
    in `.cpp` files, which do not reference any OS-specific headers or libraries.
    For the first few chapters, this simple framework that delegates frame rendering
    and event handling to portable OS-independent functions (`OnDrawFrame()`, `OnKeyUp()`
    and so on) is enough.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of our examples from the subsequent chapters are buildable for Windows from
    the command line using a single `make all` command. Android native code is buildable
    with a single `ndk-build` command. We will use this convention throughout the
    rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Signing release Android applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can create a cross-platform application, debug it on a PC, and deploy
    it to Android devices. We cannot, however, upload it on Google Play because it
    is not (yet) signed properly with the release key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A detailed explanation of the signing procedure on Android is given in the developer
    manual at [http://developer.android.com/tools/publishing/app-signing.html](http://developer.android.com/tools/publishing/app-signing.html).
    We will focus on the signing from the command line and automating the entire process
    via batch files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to rebuild the project and create a release version of
    the `.apk` package. Let''s do it with our `App2` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a lot of text output from `Ant`, which ends with something like
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us generate a self-signed release key using `keytool` from the JDK through
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill out all the fields necessary for the key, as in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to proceed with the actual application signing. Use the `jarsigner`
    tool from the JDK through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is interactive, and it will require the user to enter the keystore
    password and the key password. However, we can provide passwords in a batch file
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Passwords should match what you entered while creating your release key and
    keystore.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more step left before we can safely publish our `.apk` package
    on Google Play. Android applications can access uncompressed content within `.apk`
    using `mmap()` calls. Yet, `mmap()` may imply some alignment restrictions on the
    underlying data. We need to align all uncompressed data within `.apk` on 4-byte
    boundaries. Android SDK has the `zipalign` tool to do it, as seen in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now our `.apk` is ready to be published.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"), *Porting Common
    Libraries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
