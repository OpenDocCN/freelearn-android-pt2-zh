- en: 'Chapter 10. Avoiding Problems: Debugging and Resource Considerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an application with Flash Professional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an application with Flash Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering application Elements using the Device GPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating application Shutdown upon Device Interruption Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting your application with the Device Back Button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Memory Usage and Frame Rate in an Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being that Android is a mobile operating system, it presents a new set of specific
    challenges in regard to optimizing both for performance and user experience. This
    is something Flash Platform developers must take into consideration when developing
    applications with AIR for Android and mobile Flash Player. This chapter will provide
    an overview of debugging and optimization techniques along with user experience
    tweaks to make our AIR for Android applications behave as nicely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an application with Flash Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging AIR for Android applications using Flash Professional is very similar
    to debugging desktop AIR or Flash projects, with some notable exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Be sure your AIR for Android project is open in Flash Professional and that
    your Player is AIR for Android. This can be verified through the **Properties**
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/1420_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the mobile debug launcher or debug on the device itself through USB:'
  prefs: []
  type: TYPE_NORMAL
- en: In the application menu, choose **Debug** and hover over the option labeled
    **Debug Movie**. This will cause a submenu of debug options to appear:![How to
    do it...](img/1420_10_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When choosing to debug **in AIR Debug Launcher (Mobile)**, Flash Professional
    will switch to the full Debug Console and launch the application within the device
    debugger. This is useful for performing quick debugging of your application when
    multi-touch, accelerometer, or other device-specific inputs and sensors are not
    involved. Breakpoints, trace statements, and other debug tools will function exactly
    the same as within a normal desktop project.![How to do it...](img/1420_10_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have performed our preliminary tests in the debug player and are ready
    to debug on the device through USB, we can switch to that option in the **Debug**
    menu. If we have never configured the AIR for Android Settings for this project,
    a dialog window will appear, allowing us to do so. This window should not appear
    during subsequent debug sessions. Be sure to choose the **Debug** option under
    **Android deployment type** and have the **Install and Launch** options selected
    in the **After publishing** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice there are fields for determining a certificate to sign your
    application at this point. To learn more about the code-signing process, please
    refer to [Chapter 11](ch11.html "Chapter 11. Final Considerations: Application
    Compilation and Distribution"), *Final Considerations: Application Compilation
    and Distribution.*![How to do it...](img/1420_10_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After initiating a debug session to deploy on our device, Flash Professional
    will take a few seconds to compile and deploy the application. As the application
    begins to load upon the device, AIR will launch a small dialog letting us know
    that it is attempting to connect to the debugger on our computer. Once this connection
    occurs, the window will go away and our full application will launch, allowing
    us to test and debug as normal.![How to do it...](img/1420_10_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging applications through breakpoints and variable inspection is on par
    with the course when developing applications using any Flash Platform technology.
    With AIR for Android, we are dealing with external hardware and a few extra steps
    must be taken to ensure that we are able to debug within our normal environment,
    while also interacting with an application running on a real device. This recipe
    demonstrates the steps necessary to get this all functioning within our present
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about project setup using Flash Professional, you may
    refer to [Chapter 1](ch01.html "Chapter 1. Getting Ready to Work with Android:
    Development Environment and Project Setup"), *Getting Ready to Work with Android:
    Development Environment and Project Setup.*'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an application with Flash Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to define debug configurations in Flash Builder is an excellent
    workflow improvement that we should take advantage of when setting up a new mobile
    project or preparing to test a project we have been working on for some time.
    We are able to set up multiple configurations for the same project using the Flash
    Builder **Debug Configurations** panel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to explore the **Debug Configurations** panel to configure a custom
    set of launch settings for our mobile project:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a mobile project and click the arrow next to the **Debug** button in
    the Flash Builder toolbar. Choose the **Debug Configurations** option from this
    menu. The Debug Configurations dialog window will open up:![How to do it…](img/1420_10_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double click on the left-hand menu entry labeled **MobileApp** to edit the particular
    settings for this selected project. From this window, we can select another project
    to configure, specify the default `Application` file for the project, set a `Target`
    platform (Google Android, in our case), and configure a `Launch` method. If debugging
    on the desktop, we can also select from a variety of device profiles and even
    configure our own. In the next screenshot , we have chosen to debug using the
    dimensions and resolution present on the Motorola Droid:![How to do it…](img/1420_10_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is necessary to define additional devices, we can click the **Configure**
    button to launch the **Device Configurations** screen, which allows us to Import
    device profiles, or even add our own:![How to do it…](img/1420_10_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When adding a custom device profile, we are given options for specifying width
    and height of our display along with supported pixels per inch. Google Android
    has a standard platform UI that can differ between devices depending upon how
    much customization the manufacturer performs over the standard display elements.
    The notifications bar, for instance, always appears unless the device is in full
    screen mode. If the notifications bar was taller or shorter on a specific device,
    we can account for it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: While resolution and PPI can be simulated here, unless the development machine
    has a multi-touch interface, we will have to test any touch or gesture input on
    an actual device. Of course, device performance is not part of the simulation
    either.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1420_10_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When choosing to debug on actual physical hardware, we can choose to debug on
    a device through USB or over a wireless network. USB debugging is often the more
    direct way and is recommended for most situations. Within the following screenshot,
    you can see that we have now defined one configuration for desktop debug and one
    for debugging on a USB-connected device:![How to do it…](img/1420_10_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When finished, click **Apply** and then **Close**. We can now access any of
    the defined configurations from the Flash Builder debug icon or the project context
    menu:![How to do it…](img/1420_10_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we choose to launch a debug session for our project, it will open within
    the Flash Builder mobile debug player when debugging on the desktop, or in the
    case of USB device debug; it will be compiled, pushed to the device, and installed.
    For a device debug session, AIR will launch a small dialog letting us know that
    it is attempting to connect to the debugger on our computer. Once this connection
    occurs, the window will go away and our full application will launch, allowing
    us to test and debug as normal.![How to do it…](img/1420_10_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you choose to launch on desktop, you will be able to debug locally within
    Flash Builder. You can also emulate a variety of Android devices by choosing from
    a set of profiles. If you wish to create your own profile, you can do so by clicking
    the **Configure** button.
  prefs: []
  type: TYPE_NORMAL
- en: When choosing to launch on a device, you also have the option of debugging on
    the device, through Flash Builder. This is, by far, the best way of debugging
    your mobile application, because it is tested on true Android hardware.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about project setup using Flash Builder, you may refer
    to [Chapter 1](ch01.html "Chapter 1. Getting Ready to Work with Android: Development
    Environment and Project Setup"), *Getting Ready to Work with Android: Development
    Environment and Project Setup.*'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering application elements using the device GPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While older Android devices must rely on the CPU for everything being rendered
    within a mobile Adobe AIR project, many of the newer devices on the market have
    full support for Graphics Processing Unit (GPU) rendering and providing necessary
    hooks for our applications to take advantage of this. This recipe will demonstrate
    the necessary steps we must take to enable GPU acceleration upon application elements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will modify settings in the AIR descriptor file and enable `DisplayObject`
    instances to take advantage of these modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` and resides at the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the file for a node named `<initialWindow>` near the beginning of this
    document. This node contains many default settings dealing with the visual aspects
    of our application window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now must locate the child node named `<renderMode>`. If this node does not
    exist, we can easily add it here. The `renderMode` value determines whether the
    application will use the CPU or GPU for rendering content. There are three possible
    values for application `renderMode:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AUTO:** The application will attempt to use the device GPU to render visual
    display objects:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**GPU:** The application will be locked to GPU mode. If the device does not
    support GPU rendering within Adobe AIR, problems will ensue:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**CPU:** The application will use the device CPU for rendering all visual display
    objects. This is the safest setting, but provides the fewest benefits:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, whenever we want to take advantage of this with `DisplayObject` instances
    within our application, we must set both the `DisplayObject` instances `cacheAsBitmap`
    property to `true` and assign the `cacheAsBitmapMatrix` property to a new Matrix
    object. This will enable 2D content rendering for these individual objects through
    the device GPU. When using objects in 2.5D space, they will automatically be rendered
    using the GPU and do not require these additional settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the application `renderMode` within the AIR descriptor file to `gpu`
    will force the application to render visual objects using the GPU. However, individual
    objects not being rendered in 2.5D space will require that both the `cacheAsBitmap`
    property be set to `true` and the `cacheAsBitmapMatix` property be assigned to
    a Matrix object. When setting `renderMode` to `auto`, the application will attempt
    to render these objects through the GPU, and will fall back to CPU rendering if
    GPU acceleration is not supported on a particular device. We can also set the
    `renderMode` to `cpu`, which simply renders everything through the CPU, bypassing
    any GPU rendering altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used appropriately, setting the application `renderMode` can greatly speed
    up visual object rendering within an application. It is important to realize that
    many devices will not have full GPU support available through AIR for Android,
    in which case forcing GPU may actually be quite problematic for the application
    and may even render it unusable on particular devices. There are also a number
    of limitations present when using the GPU. For instance: filters, PixelBender
    blends, and a variety of standard blend modes are not supported.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If using Flash Professional, we can also set the `Render` mode through the AIR
    for **Android Settings** panel. This is accessible through the **Properties**
    panel. Click the little wrench icon next to **Player selection** to configure
    these settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1420_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Automating application shutdown upon device interruption events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is running on an Android device, there is a good chance
    that a user session can be interrupted by a telephone call, or some other unforeseen
    event. When a situation like this occurs, we should consider whether it may be
    appropriate to exit the application and free up system resources for other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will listen to the application to fire a deactivate event and exit the application
    in response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we will need to import the following classes into our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must register an event listener of type `Event.DEACTIVATE` upon our `NativeApplication.nativeApplication`
    object. This event will fire in response to the application losing focus on the
    device in the event of a telephone call or some other interruption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the following function, we will invoke the `exit()` method upon the
    `NativeApplication.nativeApplication` object, closing the application completely.
    This will free up resources for other device applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to be good stewards of the resources set aside for our application to
    run while active on a user's device. An effective way to do this is to make sure
    to release any memory that our application is using when not in an active state.
    Listening for a deactivate event will allow us to know when some other application
    receives focus. At this point, we can exit the application completely which frees
    up the resources being used for whatever the user is currently doing.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before actually exiting the application, we have a chance to preserve any session
    data through local shared objects or local databases. For more information on
    how to do this, take a look at [Chapter 8](ch08.html "Chapter 8. Abundant Access:
    File System and Local Database"), *Abundant Access: File System and Local Database.*'
  prefs: []
  type: TYPE_NORMAL
- en: Exiting your application with the device back button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android devices generally have a set of four soft-keys along one side of the
    device which are always present to the user. Two of these keys involve navigation—the
    back and home keys. When a user activates an event such as when pressing the back
    button, we should consider whether it may be appropriate to fully exit the application
    and free up system resources for other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The home button will always return the user to the Android desktop, thus deactivating
    our application. To see how to close an application in such an event, refer the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will listen to the dedicated Android back button to be pressed and exit
    the application in response:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we will need to import the following classes into our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must register an event listener of type `KeyboardEvent.KEY_DOWN` upon our
    `NativeApplication.nativeApplication` object. This event will fire in response
    to the user activating the dedicated Android back key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the event of the back key being pressed by the user, we will invoke the
    `exit()` method upon the `NativeApplication.nativeApplication` object, closing
    the application completely. This will free up resources for other device applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to be good stewards of the resources set aside for our application to
    run while active on a user's device. An effective way to do this is to make sure
    to release any memory that our application is using when not in an active state.
    One way of doing this is to listen for keyboard events and intercepting a back
    key press. At this point, we can exit the application completely which frees up
    the resources being used for whatever the user is currently doing.
  prefs: []
  type: TYPE_NORMAL
- en: Depending upon the current state of our application, we can choose whether it
    is appropriate to exit the application or simply return to some previous state.
    When performing such actions within a Flex-based mobile project, we would probably
    only exit the application if our current view was the initial view within our
    application `ViewNavigator.`
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to prevent the Android back button from doing anything at
    all by using `KeyboardEvent.preventDefault():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that before actually exiting the application, we have a chance to preserve
    any session data through local shared objects or local databases. For more information
    on how to do this, take a look at [Chapter 8](ch08.html "Chapter 8. Abundant Access:
    File System and Local Database"), *Abundant Access: File System and Local Database.*'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring memory usage and frame rate in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android devices generally have a lot less memory and much less CPU power than
    a traditional desktop or laptop machine. We have to be very careful when building
    Android applications so as not to create something so power-hungry, that the frame
    rate drops to unacceptable levels or the application becomes unresponsive. To
    assist us in troubleshooting and monitoring these issues, we can keep track of
    the memory consumption and calculated frame rate of the running application which
    should respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can monitor many system properties through use of the `flash.system` package
    along with the `flash.utils.getTimer` class for calculating the present application
    frame rate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we will need to import the following classes into our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to declare a set of `Number` objects to hold persistent timing values
    in order to calculate the application frame rate. Also, declare a `TextField`
    and `TextFormat` pair to trace out this and other device messages to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step entails creation of the mechanism which handles our frame rate
    calculation. We will set the `prevTimeNumber` to the current elapsed milliseconds
    as the application has been initialized. We''ll also set the `numFrames` variable
    to `0` for the moment. This provides us with a base set of numbers to work off.
    Finally, we register an event listener of type `Event.ENTER_FRAME` upon our application
    to periodically perform new frame rate calculations for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This lengthy method will refresh everything within our `TextField`, every time
    a frame is entered. First, we will write out some information about the CPU architecture,
    manufacturer, and the memory available to our application. The memory is the important
    bit in this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To calculate the running frame rate, we will first increment our frame counter
    and once again gather the number of milliseconds elapsed from the initialization
    of our application. The previous reading of this can be then subtracted, giving
    us the time that has elapsed since this function last ran.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the time elapsed is over 1000, a second has transpired and we can then perform
    some calculations to determine our actual frames per second. We will retrieve
    the frames per minute by dividing the number of frames we are dealing with in
    this cycle by the variable holding our previous time, multiplied by 1000\. Setting
    the previous time variable to the present time elapsed, and resetting our frame
    count to `0`, will begin a new cycle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the application upon a device, we can see the CPU and OS information,
    along with memory usage and the calculated frame rate:![How to do it...](img/1420_10_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a wealth of information which can be accessed through the Capabilities
    and System classes regarding CPU and memory use. We can gather additional information
    about the current frame rate by calculating actual FPS based upon data gathered
    from the `getTimer()` utility method. Using all of this together will provide
    us with a reasonable set of data to determine how well our application is running
    upon a particular device. We can then use this data to make smart decisions while
    the application is running by modifying application properties, changing the way
    we are rendering content, or even alerting the user that there may be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the frame rate becomes too sluggish, we may want to consider lowering the
    frame rate or even dropping the rendering quality of our application to improve
    performance. This can be done using the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also recommend the use of a package like `Hi-ReS-Stats` which can be
    downloaded from [https://github.com/mrdoob/Hi-ReS-Stats](http://https://github.com/mrdoob/Hi-ReS-Stats)
    and used on mobile Android applications to monitor resource usage. Usage of this
    class will produce a graph overlay within our application to monitor application
    performance.
  prefs: []
  type: TYPE_NORMAL
