- en: Chapter 2. A New Layout – GridLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new layout is introduced with Android Ice Cream Sandwich known as the **GridLayout**.
    This layout is an optimized layout and could be used instead of **LinearLayout**
    and **RelativeLayout**. This chapter shows how to use and configure GridLayout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Why to use GridLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a GridLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring GridLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GridLayout** is a layout that divides its view space into rows, columns,
    and cells. GridLayout places views in it automatically, but it is also possible
    to define the column and row index to place a view into GridLayout. With the span
    property of cells, it is possible to make a view span multiple rows or columns.
    The following code block shows a sample layout file using a `GridLayout` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When this layout XML is viewed in the emulator it will look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GridLayout](img/9526_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this layout XML file, we placed four `TextView` components with the texts
    `Cell 1,1`, `Cell 1,2`, `Cell 2,1`, and `Cell 2,2`. With the GridLayout `orientation`
    set to `horizontal` and the `columnCount` and `rowCount` properties set to `2`,
    GridLayout firstly places items automatically to the first row, and when the number
    of items reaches `columnCount`; it starts placing items in the second row.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you will notice in this layout is that `TextView` components
    don't have `layout_width` and `layout_height` properties. These properties are
    not used because `GridLayout` uses the `layout_gravity` property for determining
    the size of cells instead of `layout_width` and `layout_height` properties. Normally
    the `gravity` property is used to align the content of a view, but in `GridLayout`
    it is used for a different purpose. The available gravity constants include `left`,
    `top`, `right`, `bottom`, `center_horizontal`, `center_vertical`, `center`, `fill_horizontal`,
    `fill_vertical`, and `fill`.
  prefs: []
  type: TYPE_NORMAL
- en: In `GridLayout`, you can explicitly define the cell that a view will be placed
    in by specifying the index of the column and row. If the index is not specified,
    `GridLayout` will automatically place the views to the first available position
    according to the orientation of the `GridLayout` layout.
  prefs: []
  type: TYPE_NORMAL
- en: Why to use GridLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LinearLayout** and **RelativeLayout** are the most common layouts used in
    user interface design in Android. For simple user interfaces they are a good choice
    but when the user interface gets complicated, the use of nested LinearLayout tends
    to increase. Nested layouts (of any type) can hurt performance, and furthermore
    nested LinearLayout deeper than 10 may cause a crash in your application. Thus,
    you should either avoid using too many nested LinearLayout blocks or you should
    use RelativeLayout in order to decrease nested LinearLayout blocks. Another drawback
    of these layouts for complicated user interfaces is the difficulty in readability.
    It is difficult to maintain nested LinearLayout or RelativeLayout layouts that
    have many views. It is a good choice to use **GridLayout** in these cases. Too
    many nested LinearLayouts could be avoided by using GridLayout. Furthermore, it
    is much easier to maintain GridLayout. Many of the user interfaces that use LinearLayout,
    RelativeLayout, or **TableLayout** can be converted to GridLayout where GridLayout
    will provide performance enhancements. One of the major advantages of GridLayout
    over other layouts is that you can control the alignment of a view in both horizontal
    and vertical axes.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a GridLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section we are going to migrate an Android application from **LinearLayout**
    to **GridLayout**. The layout''s XML code of the application with `LinearLayout`
    is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawable `borders_bottom_right` background used in the preceding layout
    file is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The screen will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a GridLayout](img/9526_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the layout XML code, we used three nested `LinearLayout`
    instances in order to achieve a simple login screen. If this screen was designed
    with `GridLayout`, the XML code of the layout would look like the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We set the `columnCount` property to `2` because we have a `TextView` component
    and an `EditText` component in a row. After that we placed the views and didn't
    specify the row or column index. **GridLayout** placed them automatically according
    to `orientation` and `columnCount`. We set the `layout_columnSpan` property to
    `2` in order to make the button span two columns. With the `layout_gravity` property
    we made the button appear in the center of the row. As you can see in the XML
    code of the layout, it is very simple and easy to design the same screen with
    GridLayout. Furthermore, alignments are much easier with GridLayout and this code
    has better readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'GridLayout has been available since API Level 14, so the minimum SDK property
    in the `AndroidManifest.xml` file should be set to `14` or greater as shown in
    the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Configuring GridLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we will write a sample `GridLayout` XML code and then we will use
    this code as a base for other examples. The XML code of the sample layout will
    look like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding code block the screen will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring GridLayout](img/9526_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the layout XML code, `TextView` components are placed without
    indices and they are automatically positioned in `GridLayout` according to `orientation`,
    `columnCount`, and `rowCount`. Now we will set the index number of `[1, 3]` to
    `[2, 1]`. The layout XML code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The screen should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring GridLayout](img/9526_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you see in the layout XML code (the highlighted part), we set the row and
    column index with `layout_row` and `layout_column` properties. The index is zero-based,
    thus the `TextView` component with text `[1, 3]` is placed to the second row and
    second column. The interesting part here is that the `TextView` component with
    text `[2, 1]` is placed after `[1, 3]`. This is because `[2, 1]` doesn't have
    an index and **GridLayout** continues positioning after `[1, 3]`. That is **GridLayout**
    looks for the first available position after the last placed view. Another noteworthy
    thing is that after shifting indices, the row count increased to `4` although
    we set the row count to `3`. **GridLayout** doesn't throw exception in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample, we will swap `[1, 2]` and `[2, 2]`.The layout XML
    code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The screen should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring GridLayout](img/9526_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you see in the layout XML code, we firstly set `layout_row` of `[1, 2]` to
    `1`. By this way, it will appear in place of `[2, 2]`. Then we have to set `layout_row`
    of `[1, 3]` to `0` and `layout_column` to `2`, because the cursor position of
    `GridLayout` was changed by setting the index of `[1, 2]`. If we don't change
    the index of `[1, 3]`, it will be placed after the `[1, 2]` index's new position.
    After that, in order to make `[2, 2]` appear in position of `[1, 2]`, we set the
    `layout_row` of `[2, 2]` to `0` and `layout_column` to `1`. Lastly, we have to
    set `layout_row` of `[2, 3]` to `1` in order to make it appear after `[1, 2]`
    index's new position. It seems a little complex to configure views in **GridLayout**,
    but if you try it in an emulator, you will see that it isn't that difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample code, we will delete `[2, 2]` and make `[1, 2]` to
    span two rows. The layout XML code look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding code block we get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring GridLayout](img/9526_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the layout XML code, we deleted the cell `[2,2]` and set the
    `layout_rowSpan` `property of `[1,2]` to `2`. By this way, `[1,2]` will cover
    two rows. We set the `layout_gravity` property to `fill` in order to make it fill
    the space of two rows. Then we set the `gravity` property to `center` in order
    to make the content of the `TextView` component to align to the center of space
    that it covers.`
  prefs: []
  type: TYPE_NORMAL
- en: '`# A new view – Space'
  prefs: []
  type: TYPE_NORMAL
- en: '**Space** is a new view introduced with Android Ice Cream Sandwich. It is used
    for putting spaces between views. It is very useful in **GridLayout**. In the
    following sample layout XML code, we removed `TextView` components with text `[2,
    2]` and `[2, 3]` and then put **Space** instead of them as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the layout XML code, we removed `TextView` components with
    text `[2,2]` and `[2,3]`. We put a `Space` view to row `1` and column `1`. We
    set `layout_columnSpan` to `2` in order to make it span two columns. The screen
    will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A new view – Space](img/9526_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LinearLayout** and **RelativeLayout** are the most common layouts in Android
    application development. However, when designing complex user interfaces you may
    need to use nested LinearLayout or RelativeLayout. This is a drawback in the performance
    and readability of your code because these layouts increase the view hierarchy
    which results in unnecessary iterations on view refreshes. **GridLayout** is a
    new layout introduced in Android Ice Cream Sandwich that overcomes these kinds
    of issues. You may design user interfaces without the need for nesting layouts.
    If you are developing applications for API Level 14 and more, it is better to
    use GridLayout. In the next chapter, we are going to learn about the new Social
    APIs introduced with Android Ice Cream Sandwich.`'
  prefs: []
  type: TYPE_NORMAL
