- en: Chapter 11. Wearable Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：可穿戴设备模式
- en: So far in this book, all the Android applications we have considered have been
    designed for mobile devices such as phones and tablets. As we have seen, the framework
    provides great facility for ensuring our designs work well on the wide variety
    of screen sizes and shapes available. However, there are three form factors that
    the work we have done so far does not cover, and that is wearable devices such
    as wrist watches, in-car consoles, and television sets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，在这本书中，我们考虑的所有Android应用程序都是为移动设备（如手机和平板电脑）设计的。正如我们所见，框架提供了极大的便利，确保我们的设计能在各种屏幕大小和形状上良好工作。然而，还有三种形态因素是我们至今未涉及的，那就是如手表、车载控制台和电视机等可穿戴设备。
- en: '![Wearable Patterns](img/image_11_001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![可穿戴设备模式](img/image_11_001.jpg)'
- en: When it comes to the application of design patterns to these alternative platforms,
    which patterns we choose depends on the purpose of the application rather than
    the platform itself. As we concentrated heavily on patterns in the previous chapter,
    this chapter will mostly cover the practicalities of building apps for each of
    these device types. However, as we shall see when we take a look at TV apps, these
    employ a **model-view-presenter pattern**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将这些设计模式应用于这些替代平台时，我们选择哪种模式取决于应用程序的目的，而不是平台本身。由于我们在上一章中重点讨论了模式，本章将主要涵盖为这些设备类型构建应用程序的实际操作。然而，当我们查看电视应用程序时，会发现它们采用了**模型-视图-呈现者模式**。
- en: As we have not yet dealt with coding sensors, the chapter will include exploring
    how a user's heart rate can be read and responded to by our code. The way that
    physical sensors, such as heart rate monitors and accelerometers, are managed
    is very similar and by examining one, we can learn how the others are handled.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未处理编码传感器的部分，章节将包括探索如何读取用户的心率，并让我们的代码对此作出响应。物理传感器（如心率监测器和加速度计）的管理方式非常相似，通过研究其中一个，我们可以了解如何处理其他传感器。
- en: 'In this chapter, you will learn how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Set up a TV app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置电视应用程序
- en: Use the leanback library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用leanback库
- en: Apply MVP patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用MVP模式
- en: Create banners and media components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建横幅和媒体组件
- en: Understand the browser and consumption views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解浏览器和消费视图
- en: Connect to wearable devices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到可穿戴设备
- en: Manage wearable screen shapes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理可穿戴设备的屏幕形状
- en: Handle wearable notifications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可穿戴设备的通知
- en: Read sensor data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取传感器数据
- en: Understand Auto safety features
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解自动安全特性
- en: Configure Auto apps for media services
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为媒体服务配置自动应用程序
- en: Configure Auto apps for messaging services
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为消息服务配置自动应用程序
- en: The first thing to consider when developing for this wide range of form factors
    is not just the size of the graphics we need to prepare, but also the distance
    it is viewed from. Most Android devices are used from just a few inches away and
    are often designed to be rotated, moved, and touched. The exception here is the
    television screen, which is generally viewed from around 10 feet away.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这个广泛的形态因素开发时，首先要考虑的不仅仅是需要准备图形的大小，还有观看距离。大多数Android设备从几英寸远的地方使用，并且经常设计为可旋转、移动和触摸。这里的例外是电视屏幕，通常是从大约10英尺远的地方观看。
- en: Android TV
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓电视
- en: Televisions are generally best for relaxing activities such as watching movies
    and shows and playing games. However, there is still a large area of overlap,
    particularly concerning games, where many apps can be easily converted to work
    on TV. The viewing distance, high definition, and controller devices mean that
    a few adaptions need to be made and this is largely helped by the leanback support
    library. This library facilitates the model-view-presenter design pattern, which
    is an adaption of the model-view-controller pattern.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 电视通常最适合于观看电影、电视节目和玩游戏等放松活动。然而，在这些活动中仍然有很大的重叠区域，尤其是在游戏方面，许多应用程序可以轻松转换为在电视上运行。观看距离、高清晰度和控制器设备意味着需要做出一些适应，这主要得益于leanback支持库的帮助。这个库促进了模型-视图-呈现者（model-view-presenter）设计模式的实现，这是模型-视图-控制器（model-view-controller）模式的一种适应。
- en: There is no limit to the types of app that could be developed for TV, but a
    large percentage of them fall into two categories, games and media. Unlike games,
    which often benefit from having unique interfaces and controls, media based apps
    should generally use widgets and interfaces that are familiar and consistent across
    the platform. This is where the **leanback library** comes in, providing a variety
    of detail, browser and search widgets, and overlays.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电视，可以开发各种类型的应用，但其中很大一部分属于两类：游戏和媒体。与通常受益于独特界面和控制的游戏不同，基于媒体的应用通常应使用平台熟悉的和一致的控件和小部件。这就是**leanback库**发挥作用的地方，它提供了各种详细、浏览器和搜索小部件，以及覆盖层。
- en: '![Android TV](img/image_11_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Android TV](img/image_11_002.jpg)'
- en: The leanback library is not the only support library that is of use to TV development,
    both the CardView and RecyclerView are useful and the RecyclerView is in fact
    required, as some leanback classes depend on it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: leanback库并不是唯一对电视开发有用的支持库，CardView和RecyclerView也很有用，实际上RecyclerView是必需的，因为一些leanback类依赖于它。
- en: Android Studio provides a very useful TV module template that provides a dozen
    or so classes that demonstrate most of the features needed in many media based
    TV applications. It is very worthwhile to take a good look at this template as
    it serves as a rather good tutorial. However, it is not necessarily the best starting
    point for individual projects unless they are quite generic in nature. If you
    are planning any original projects, it is necessary to know one or two things
    about how TV projects are set up, starting with the device home screen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 提供了一个非常实用的电视模块模板，它提供了十几个展示许多基于媒体的电视应用所需功能的类。仔细研究这个模板是非常值得的，因为它是一个相当好的教程。然而，除非项目性质相当通用，否则它不一定是单个项目的最佳起点。如果你计划进行任何原创项目，有必要了解有关如何设置电视项目的一些知识，从设备主屏幕开始。
- en: TV home screen
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电视主屏幕
- en: The home screen is the entry point for Android TV users. From here they can
    search for content, adjust settings, and access applications and games. The first
    view the user will get of our app will be on this screen in the form of a banner
    image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕是Android TV用户的入口点。从这里，他们可以搜索内容，调整设置，访问应用和游戏。用户对我们的应用的第一印象将是在这个屏幕上以横幅图像的形式出现。
- en: 'Every TV app has a banner image. This is a 320 x 180 dp bitmap that should
    portray what our app does in a simple and efficient manner. For example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个电视应用都有一个横幅图像。这是一个320 x 180 dp的位图，应该以简单高效的方式展示我们的应用功能。例如：
- en: '![TV home screen](img/image_11_003.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![TV home screen](img/image_11_003.jpg)'
- en: 'Banners can contain colorful photographic imagery too, but text should always
    be kept bold and to a minimum. The banner can then be declared in the project
    manifest. To see how this is done, and how other **manifest** properties relevant
    to TV apps can be set, follow these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 横幅也可以包含丰富多彩的摄影图像，但文本应始终保持粗体并尽量简练。然后可以在项目清单中声明横幅。要了解如何进行此操作，以及如何设置其他与电视应用相关的**清单**属性，请按照以下步骤操作：
- en: Start a new project, selecting **TV** as the **Target Android Device** and **Android
    TV Activity** as the activity template.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目，选择**TV**作为**Target Android Device**，选择**Android TV Activity**作为活动模板。
- en: Add your image to the drawable folder and call it `banner` or something like
    that.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的图像添加到drawable文件夹中，并命名为`banner`或类似名称。
- en: Open the `manifests/AndroidManifest.xml` file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`manifests/AndroidManifest.xml`文件。
- en: 'Delete the following line:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下行：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit the opening `<application>` node to include the following highlighted
    line:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑开头的`<application>`节点，包含以下高亮行：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the root `<manifest>` node, add the following attribute:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根`<manifest>`节点中，添加以下属性：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This last `<uses-feature>` node is not strictly required, but will make your
    app available to older televisions that do not have microphones included. If your
    app relies on voice control, then omit this attribute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`<uses-feature>`节点不是严格必需的，但它将使你的应用适用于没有内置麦克风的老款电视。如果你的应用依赖于语音控制，那么省略这个属性。
- en: 'We will also need to declare a leanback launcher for our main activity, which
    is done like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的主活动声明一个leanback启动器，操作如下：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are building for TV alone, then this is all you need to do in terms
    of making your app available in the TV section of the Play store. However, you
    may be developing an application such as a game that can be played on other devices.
    In this case, also include the following clause to make it available to devices
    that can be rotated:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仅针对电视构建应用，那么在Play商店的电视部分使您的应用可用需要做的就是这些。然而，您可能正在开发可以在其他设备上玩的游戏等应用程序。在这种情况下，请包含以下条款以使其适用于可以旋转的设备：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In these situations, you should also set `android.software.leanback` to `required="false"`
    and revert to the material or *appcompat* themes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您还应该将`android.software.leanback`设置为`required="false"`，并恢复到材料或*appcompat*主题。
- en: You may be wondering why we moved the banner declaration from the main activity
    to the application as a whole. This was not strictly necessary, and what we have
    done is simply apply one banner to the whole app, regardless of how many activities
    it contains. Unless you want separate banners for each activity, this is usually
    the best way to go.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们将横幅声明从主活动移动到整个应用。这并非绝对必要，我们所做的是将一个横幅应用于整个应用，不管它包含多少个活动。除非您希望每个活动都有不同的横幅，否则这通常是最佳做法。
- en: TV model-view-presenter pattern
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电视模型-视图-呈现器模式
- en: The leanback library is one of the few that directly facilitate the use of a
    design pattern, the model-view-presenter (MVP) pattern, which is a derivation
    of model-view-controller (MVC). Both these patterns are remarkably simple and
    obvious, and some might say that they do not really qualify as patterns at all.
    Even if you had never come across design patterns before, you would have applied
    one or both of these *architectures*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Leanback库是少数几个直接促进设计模式使用的库之一，即模型-视图-呈现器（MVP）模式，它是模型-视图-控制器（MVC）的衍生物。这两种模式都非常简单和明显，有些人可能会说它们实际上并不真正符合模式的定义。即使您以前从未接触过设计模式，您也可能会应用其中一种或两种*架构*。
- en: We covered MVC and MVP briefly earlier, but to recap, in an MVC pattern the
    view and the controller are separate. For example, when the controller receives
    input from the user, such as a click of a button, it passed this to the model
    which executes its logic and forwards this updated information to the view, which
    then displays this change to the user, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要介绍了MVC和MVP，但回顾一下，在MVC模式中，视图和控制器是分开的。例如，当控制器从用户那里接收输入，比如按钮的点击，它会将此传递给模型，模型执行其逻辑并将这些更新的信息转发给视图，然后视图向用户显示这些更改，依此类推。
- en: The MVP pattern combines the functions of both view and controller, making it
    an intermediary between the user and the model. This is something we have seen
    before in the shape of the adapter pattern, in particular the way recycler views
    and their adapters work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MVP模式结合了视图和控制器两者的功能，成为用户和模型之间的中介。这是我们之前在适配器模式中看到过的，特别是回收视图及其适配器的工作方式。
- en: The leanback presenter class also works in conjunction with a nested view holder,
    and in terms of the MVP pattern, the view is any Android view and the model can
    be any Java object or collection of objects we choose. This means that we can
    use the presenter to act as an adapter between any logic of our choice and any
    layout we wish.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Leanback呈现器类也与嵌套的视图持有者一起工作，在MVP模式方面，视图可以是任何Android视图，模型可以是任何我们选择的Java对象或对象集合。这意味着我们可以使用呈现器作为我们选择的任何逻辑和任何布局之间的适配器。
- en: Despite the freedom of this system, before embarking on project development,
    it is worth taking a little look at some of the conventions used in TV app development.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个系统很自由，但在开始项目开发之前，了解一下电视应用开发中的一些约定是值得的。
- en: TV app structure
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电视应用结构
- en: 'A large number of media TV apps offer a limited set of functions, and this
    is usually all that is required. For the most part, users want to:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数媒体电视应用提供有限的功能集，这通常就是所需要的一切。大多数情况下，用户希望：
- en: Browse for content
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览内容
- en: Search for content
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索内容
- en: Consume content
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费内容
- en: 'The leanback library provides fragment classes for each of these. A typical
    **browser view** is provided by the `BrowserFragment` and the template demonstrates
    this with a simple example, along with a `SearchFragment`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Leanback库为这些提供了片段类。一个典型的**浏览器视图**由`BrowserFragment`提供，模板通过一个简单的示例演示了这一点，以及一个`SearchFragment`：
- en: '![TV app structure](img/image_11_004.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![电视应用结构](img/image_11_004.jpg)'
- en: The **consumption view** is provided by the `PlaybackOverlayFragment` and is
    probably the simplest of views, comprising little more than a VideoView and the
    controls.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**消费视图**由`PlaybackOverlayFragment`提供，可能是最简单的视图，包含的元素比VideoView和控制按钮多不了多少。'
- en: 'There is also the `DetailsFragment` that provides content specific information.
    The content and layout of this view are dependent on the subject matter and can
    take any form you choose, the regular rules of material design applying. The **design
    view** scrolls up from the bottom of the consumption view:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`DetailsFragment`，它提供特定内容的信息。这个视图的内容和布局取决于主题内容，可以采取你选择的任何形式，常规的材料设计规则同样适用。**设计视图**从消费视图的底部向上滚动：
- en: '![TV app structure](img/image_11_005.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![电视应用结构](img/image_11_005.jpg)'
- en: The leanback library makes light work of bringing material design to TV devices.
    If you decide to use views from elsewhere, then the same material rules that apply
    to them elsewhere apply here too. Before moving on, it is worth mentioning that
    background images need to have a 5% bleed around the edges to ensure they reach
    the sides of all TV screens. This means that a 1280 x 720 px image needs to be
    1408 x 792 px.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: _Leanback_库使得将材料设计引入电视设备变得轻而易举。如果你决定使用其他地方的视图，那么适用于其他地方的同材料规则在这里同样适用。在继续之前，值得一提的是背景图片需要在边缘留出5%的出血区域，以确保它们能够覆盖所有电视屏幕的边缘。这意味着一个1280
    x 720像素的图片需要是1408 x 792像素。
- en: Earlier, we covered the banner image used to launch an app, but we also need
    a way to direct users to individual content and in particular to familiar or pertinent
    content.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们介绍了用于启动应用程序的横幅图像，但我们还需要一种方法来引导用户访问个别内容，尤其是熟悉或相关的内容。
- en: Recommendation cards
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推荐卡片
- en: The top row of the Android TV home screen is the **recommendation row**. This
    allows user to quickly access content based on their viewing history. Content
    can be recommended because it is a continuation of previously viewed content or
    related in some way based on the user's viewing history.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓电视主屏幕的顶部行是**推荐行**。这允许用户根据他们的观看历史快速访问内容。内容之所以被推荐，可能是因为它是之前观看内容的延续，或者基于用户的观看历史以某种方式相关。
- en: 'When designing recommendation cards, there are only a handful of design factors
    we need to consider. These cards are constructed from an image or large icon,
    a title, a subtitle and an application icon, like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设计推荐卡片时，我们需要考虑的设计因素寥寥无几。这些卡片由图片或大图标、标题、副标题和应用程序图标构成，如下所示：
- en: '![Recommendation cards](img/image_11_006.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![推荐卡片](img/image_11_006.jpg)'
- en: There is a certain amount of flexibility when it comes to the aspect ratio of
    the card image. The width of the card must never be less than 2/3 of its height
    or more than 3/2\. There must be no transparent elements within the image and
    it must not be less than 176 dp in height.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡片图片的宽高比方面有一定的灵活性。卡片的宽度绝不能小于其高度的2/3或超过3/2。图片内部不能有透明元素，且高度不得小于176 dp。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Large expanses of white can be quite harsh on many televisions. If you need
    large areas of white, use #EEE rather than #FFF.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大面积的白色在许多电视上可能相当刺眼。如果你需要大面积的白色，使用#EEE而不是#FFF。
- en: If you take a look at the recommendation row on a live Android TV set, you will
    see that as each card is highlighted, the background image changes and we too
    should provide background images for each recommendation card. These images must
    differ from the one on the card and be 2016 x 1134 px to allow for a 5% bleed
    and ensure they leave no gaps around the edge of the screen. These images too
    should have no transparent sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一下实时安卓电视设置中的推荐行，你会看到每个卡片被选中时，背景图像会发生变化，我们也应该为每个推荐卡片提供背景图像。这些图像必须与卡片上的图像不同，并且是2016
    x 1134像素，以允许5%的出血，并确保它们不会在屏幕边缘留下空隙。这些图像也不应有透明部分。
- en: '![Recommendation cards](img/image_11_007.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![推荐卡片](img/image_11_007.jpg)'
- en: The challenge of designing for such large screens affords us the opportunity
    to include colorful and vibrant imagery with high-quality graphics. At the other
    end of this size spectrum falls the wearable device, where space is premium and
    an entirely different approach is required.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设计如此大屏幕的挑战为我们提供了机会，可以包含丰富多彩、高质量的图像。在这个尺寸范围的另一端是可穿戴设备，空间极为宝贵，需要完全不同的方法。
- en: Android Wear
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓穿戴
- en: Wearable Android apps deserve special treatment for yet another reason, and
    that is that nearly all Android Wear applications act as a companion app and work
    in conjunction with a main module that runs on the user's handset. This tethering
    is an interesting and straightforward process and many mobile apps can be enhanced
    greatly by adding a wearable component. Another feature that makes developing
    for wearables a lot of fun is the availability of exciting new sensors and gadgetry.
    In particular, the heart rate monitor found in many smart watches has proved unsurprisingly
    popular in fitness apps.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴Android应用由于另一个原因也值得特别对待，那就是几乎所有Android Wear应用都作为伴侣应用，并与在用户手机上运行的主模块结合工作。这种绑定是一个有趣且直接的过程，许多移动应用可以通过添加可穿戴组件大大增强功能。另一个使可穿戴设备开发变得非常有趣的特点是，有许多激动人心的新型传感器和设备。特别是，许多智能手表中配备的心率监测器在健身应用中已经证明非常受欢迎。
- en: Wearables are one of the most exciting areas of smart device development. Smart
    phones and other worn devices with a whole range of new sensors open up uncountable
    new possibilities for developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴设备是智能设备开发中最激动人心的领域之一。智能手机和其他配备一系列新型传感器的可穿戴设备为开发者开启了无数新的可能性。
- en: Apps running on wearable devices need to be connected to a parent application
    running on a mobile handset and are best thought of as extensions of the main
    app. Whereas most developers have access to at least one handset, wearable devices
    can be an expensive option for testing only, particularly because we would need
    a minimum of two. This is because of the difference in the way **square and round
    screens** are handled. Fortunately, we can create AVDs with an emulator and connect
    these to either a real phone or tablet or a virtual one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在可穿戴设备上运行的应用需要连接到在手机上运行的主应用，最好将其视为主应用的一个扩展。尽管大多数开发者至少能接触到一部手机，但可穿戴设备对于仅用于测试来说可能是一个昂贵的选项，特别是因为我们至少需要两部设备。这是因为方形和圆形屏幕处理方式的不同。幸运的是，我们可以创建带有模拟器的AVD，并将其连接到真实的手机或平板电脑，或者是虚拟设备。
- en: Pairing with a wearable device
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与可穿戴设备配对
- en: 'To best see this difference between round and square screen management, begin
    by creating an emulator for each:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要最好地了解圆形和方形屏幕管理的区别，首先为每种屏幕创建一个模拟器：
- en: '![Pairing with a wearable device](img/B05685_11_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![与可穿戴设备配对](img/B05685_11_08.jpg)'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is also a chinned version, but for programming purposes we can consider
    this the same as the round screen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个带下巴的版本，但对于编程目的我们可以将其视为圆形屏幕。
- en: 'How you pair the wearable AVD will depend on whether you are coupling it with
    a real handset or another emulator. If you are using a handset, you will need
    to download the Android Wear app from:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何配对可穿戴AVD取决于您是将其与真实手机还是另一个模拟器配对。如果您使用手机，需要从以下位置下载Android Wear应用：
- en: '[https://play.google.com/store/apps/details?id=com.google.android.wearable.app](https://play.google.com/store/apps/details?id=com.google.android.wearable.app)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.google.com/store/apps/details?id=com.google.android.wearable.app](https://play.google.com/store/apps/details?id=com.google.android.wearable.app)'
- en: Then locate the `adb.exe` file, which, by default, is located in `user\AppData\Local\Android\sdk\platform-tools\`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后找到 `adb.exe` 文件，默认情况下位于 `user\AppData\Local\Android\sdk\platform-tools\`
- en: 'Open the command window here and issue the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此打开命令窗口，并输入以下命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now launch the companion app and follow the instructions to pair the
    devices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以启动伴侣应用并按照说明配对设备。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to issue this port forwarding command each time you connect the
    handset.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您每次连接手机时都需要执行这个端口转发命令。
- en: If you are pairing your wearable emulator with an emulated handset, then you
    will need an AVD that targets Google APIs rather than a regular Android platform.
    You can then download the `com.google.android.wearable.app-2.apk`. There are many
    places online where this can be found, such as:  [www.file-upload.net/download](http://www.file-upload.net/download)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将可穿戴模拟器与模拟手机配对，那么您需要一个针对Google APIs而不是常规Android平台的AVD。然后您可以下载 `com.google.android.wearable.app-2.apk`。在网上有许多地方可以找到这个文件，例如：[www.file-upload.net/download](http://www.file-upload.net/download)
- en: 'The apk should be placed in your `sdk/platform-tools` directory, where it can
    be installed with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: apk文件应放在您的 `sdk/platform-tools` 目录中，可以用以下命令安装：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now start your wearable AVD and enter `adb devices` into the command prompt,
    making sure that both emulators are visible with an output similar to this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动您的可穿戴AVD，并在命令提示符中输入 `adb devices`，确保两个模拟器都能用类似以下输出显示出来：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Enter:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: at the command prompt, where `5554` is the phone emulator. Next, enter `adb
    redir add tcp:5601:5601\.` You can now use the Wear app on the handheld AVD to
    connect to the watch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下，其中 `5554` 是手机模拟器。接下来，输入 `adb redir add tcp:5601:5601\.` 现在你可以使用手持式 AVD
    上的 Wear 应用连接到手表。
- en: When creating Wear projects, you will need to include two modules, one for the
    wearable component and one for the handset.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Wear 项目时，你需要包含两个模块，一个用于可穿戴组件，另一个用于手机。
- en: '![Pairing with a wearable device](img/image_11_009.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![与可穿戴设备配对](img/image_11_009.jpg)'
- en: 'Android provides a **wearable UI support library** that provides some very
    useful features for Wear developers and designers. If you have created a wearable
    project using the wizard, this will have been included during setup. Otherwise
    you will need to include the following dependencies in the `Module: wear` `build.gradle`
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'Android 提供了一个 **可穿戴 UI 支持库**，为 Wear 开发者和设计师提供了一些非常有用的功能。如果你使用向导创建了一个可穿戴项目，这将在设置过程中包含。否则，你需要在
    `Module: wear` 的 `build.gradle` 文件中包含以下依赖项：'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will also require these lines in the Module: mobile build file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '你还需要在 Module: mobile 构建文件中包含以下这些行：'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Managing screen shapes
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理屏幕形状
- en: We have no idea in advance which of these shapes our apps will be running on,
    and there are two solutions to this conundrum. The first, and most obvious, is
    simply to create a layout for each shape and this is very often the best solution.
    If you have a wearable project created with the wizard, you will see that template
    activities for both shapes have been included.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法提前知道应用将在哪些形状的屏幕上运行，对此有两个解决方案。第一个，也是最明显的，就是为每种形状创建一个布局，这通常是最佳解决方案。如果你使用向导创建了一个可穿戴项目，你会看到模板活动已经包含了这两种形状。
- en: 'We still need a way to detect the screen shape when the app is run on an actual
    device or emulator so that it knows which layout to inflate. This is done with
    the **WatchViewStub** and the code to call it has to be included in `onCreate()`
    method of our main activity file, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用在实际设备或模拟器上运行时，我们仍然需要一种方法来检测屏幕形状，以便知道要加载哪个布局。这是通过 **WatchViewStub** 实现的，调用它的代码必须包含在我们主活动文件的
    `onCreate()` 方法中，如下所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can then be implemented in XML like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 XML 中如下实现：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The alternative to creating separate layouts for each screen shape is to use
    a layout that itself is aware of screen shape. This comes in the form of the **BoxInsetLayout**,
    which adjusts padding settings for round screens and only positions views within
    the largest possible square within that circle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为每种屏幕形状创建独立布局的替代方法是使用一种本身能感知屏幕形状的布局。这就是 **BoxInsetLayout** 的形式，它会为圆形屏幕调整内边距设置，并且只在该圆圈中最大可能的正方形内定位视图。
- en: 'The BoxInsetLayout can be used like any other layout, as the root ViewGroup
    in your main XML activity:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: BoxInsetLayout 可以像其他任何布局一样使用，作为主 XML 活动中的根 ViewGroup：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are definitely drawbacks to this approach, as it does not always make
    the most of the space available on round faces, but what the BoxInsetLayout lacks
    in flexibility it makes up for in ease of use. In most cases, this is not a drawback
    at all, as a well-designed Wear app should only grab the user's attention briefly
    with simple information. Users are not keen to navigate complex UIs on their watches.
    The information we display on a watch screen should be able to be absorbed in
    a glance and the responding action should be limited to no more than a tap or
    a swipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实有一些缺点，因为它并不总是能充分利用圆形表盘上的空间，但 BoxInsetLayout 在灵活性方面的不足，通过易用性得到了弥补。在大多数情况下，这根本不是缺点，因为设计良好的
    Wear 应用应该只通过简单信息短暂吸引用户的注意力。用户不希望在手表上导航复杂的 UI。我们在手表屏幕上显示的信息应该能够一眼就被吸收，响应动作应该限制在不超过一次点击或滑动。
- en: One of the main uses of smart devices is to receive notifications when the user
    is otherwise unable to access their handset, for example when they are exercising.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 智能设备的主要用途之一是当用户无法访问手机时接收通知，例如在锻炼时。
- en: Wearable notifications
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可穿戴设备通知
- en: 'There is very little to adding wearable notification functionality to any mobile
    app. Recall how notifications are delivered from [Chapter 9](ch09.html "Chapter 9. Observing
    Patterns"), *Observing Patterns*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何移动应用中添加可穿戴通知功能非常简单。回想一下通知是如何从 [第9章](ch09.html "第9章. 观察模式")，*观察模式* 中传递的：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To adapt this to also send the notification to the paired wearable device,
    simply add these two lines to the builder string:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使通知也发送到配对的穿戴设备，只需将这两行添加到构建器字符串中：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The optional `setHintShowBackgroundOnly` setting allows us to display the notification
    without a background card.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`setHintShowBackgroundOnly`设置允许我们不显示背景卡片而只显示通知。
- en: Most of the time a wearable is used as an output device, but it can also act
    as an input and many new functions can be derived when sensors are placed close
    to the body, such as the heart rate monitor included in many smart phones.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，穿戴设备被用作输出设备，但它也可以作为输入设备，并且当传感器靠近身体时，可以派生出许多新功能，比如许多智能手机中包含的心率监测器。
- en: Reading sensors
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取传感器
- en: There are a growing number sensors available on most smart devices today and
    smart watches offer new opportunities to developers. Fortunately these sensors
    are very simple to program, they are after all, just another input device and
    as such, we employ listeners to *observe* them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数智能设备上都配备了越来越多的传感器，智能手表为开发者提供了新的机会。幸运的是，这些传感器编程非常简单，毕竟它们只是另一种输入设备，因此我们使用监听器来*观察*它们。
- en: 'Although the function and purpose of individual sensors differs widely, the
    way they are read is almost identical, the only difference being the nature of
    their outputs. Here we will look at the heart rate monitor found on many wearables:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单个传感器的功能和用途存在很大差异，但读取它们的方式几乎相同，唯一的区别在于它们输出的性质。下面我们将看看许多可穿戴设备上找到的心率监测器：
- en: Open or start a Wear project.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开或启动一个Wear项目。
- en: 'Open the wear module and add a BoxInsetLayout with a TextView to the main activity
    XML file, like so:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开穿戴模块，并在主活动XML文件中添加一个带有TextView的BoxInsetLayout，如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Open the Manifest file in the wear module and add the following permission inside
    the root `manifest` node.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开穿戴模块中的Manifest文件，并在根`manifest`节点内添加以下权限。
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the main Java activity file in the wear module and add the following fields:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开穿戴模块中的主Java活动文件，并添加以下字段：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement a `SensorEventListener` on the activity:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动上实现一个`SensorEventListener`：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implement the two methods required by the listener.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现监听器所需的两个方法。
- en: 'Edit the `onCreate()` method like this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下编辑`onCreate()`方法：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add this `onResume()` method:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这个`onResume()`方法：
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And this `onPause()` method:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及这个`onPause()`方法：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Edit the `onSensorChanged()` callback, like so:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下编辑`onSensorChanged()`回调：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Reading sensors](img/image_11_010.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![读取传感器](img/image_11_010.jpg)'
- en: As you can see, sensor listeners act like observers in exactly the same way
    as click and touch listeners. The only real difference is that sensors need to
    be explicitly registered and unregistered, as they are not available by default
    and need to be switched off when done with to preserve battery.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，传感器监听器与点击和触摸监听器一样，完全像观察者一样工作。唯一的真正区别是传感器需要显式注册和注销，因为它们默认不可用，并且在完成操作后需要关闭以节省电池。
- en: 'All sensors can be managed the same way with a sensor event listener and it
    is usually best to check for each sensor''s presence when initializing the app
    with:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有传感器都可以通过传感器事件监听器以相同的方式管理，通常最好在初始化应用时检查每个传感器的存在，方法是：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Wearable devices open up a whole new world of app possibilities, bringing Android
    into ever increasing aspects of our lives. Another such example would be the use
    of Android devices in our cars.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 穿戴设备开启了应用可能性的全新世界，将Android带入我们生活的各个方面。另一个例子就是在我们的汽车中使用Android设备。
- en: Android Auto
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Auto
- en: As with Android TV, Android Auto can run many apps designed originally for mobile
    devices. Of course, with in-car software, safety is the overwhelming priority,
    which is why most Auto apps concentrate on audio functions, such as messaging
    and music.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android TV一样，Android Auto可以运行许多最初为移动设备设计的应用。当然，在车载软件中，安全是首要考虑的因素，这也是为什么大多数Auto应用主要集中在音频功能上，比如信息和音乐。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because of the emphasis on safety, Android Auto apps have to undergo stringent
    testing before they can be published.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对安全的重视，Android Auto应用在发布前必须经过严格的测试。
- en: 'It barely needs mentioning that safety is the overriding principle when developing
    in-car apps, and for this reason, Android Auto applications nearly all fall into
    two categories: music or audio players and messaging.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不用说，开发车载应用时安全是首要原则，因此，Android Auto应用程序几乎都分为两类：音乐或音频播放器和信息传递。
- en: All applications require extensive testing during the development phase. Obviously,
    it would be impractical and highly dangerous to test an Auto app on a live device,
    and for this reason Auto API simulators are provided. These can be installed from
    the SDK manager's tools tab.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用在开发阶段都需要进行广泛测试。显然，在实车上测试Auto应用是不切实际且非常危险的，因此提供了Auto API模拟器。这些可以从SDK管理器的工具标签中安装。
- en: '![Android Auto](img/image_11_011.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Android Auto](img/image_11_011.jpg)'
- en: Auto safety considerations
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Auto安全考虑因素
- en: 'Many of the rules governing Auto safety are simple common sense, avoid animations,
    distractions and delays, but of course it is necessary to formalize these and
    Google have done so. These rules concern driver attention, screen layout, and
    readability. The most significant can be found in the list here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于Auto安全的规则都是简单的常识，比如避免动画、分心和延迟，但当然需要对这些进行规范化，谷歌也这样做了。这些规则涉及驾驶员注意力、屏幕布局和可读性。最重要的可以在这里找到：
- en: There must be no animated elements on the Auto screen
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auto屏幕上不能有动画元素
- en: Only audio ads are allowed
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许有声广告
- en: Apps must support voice control
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用必须支持语音控制
- en: All buttons and clickable controls must respond within two seconds
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有按钮和可点击控件必须在两秒内响应
- en: Text must be longer than 120 characters and must always be in the default Roboto
    font
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本必须超过120个字符，并且始终使用默认的Roboto字体
- en: Icons must be white so that the system can control contrast
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标必须是白色，以便系统控制对比度
- en: Apps must support day and night mode
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用必须支持日间和夜间模式
- en: App must support voice commands
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用必须支持语音命令
- en: App-specific buttons must respond to user actions with no more than a two-second
    delay
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用特定按钮必须在两秒内响应用户操作
- en: 'A comprehensive list can be found at:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到详尽的列表：
- en: '[developer.android.com/distribute/essentials/quality/auto.html](http://developer.android.com/distribute/essentials/quality/auto.html)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[developer.android.com/distribute/essentials/quality/auto.html](http://developer.android.com/distribute/essentials/quality/auto.html)'
- en: 'IMPORTANT: These, and several other stipulations, will be tested by Google
    before publication, so it is essential that you run all of these tests yourself.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在发布之前，谷歌会测试这些以及其他一些规定，因此您自己运行所有这些测试是至关重要的。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Designing apps that are suitable for day and night modes and that can have
    contrast controlled by the system to automatically remain readable in different
    light conditions is quite a detailed subject and Google have produced a very useful
    guide to this, which can be found at: [commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf](http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设计适用于日间和夜间模式的应用，并使系统可以控制对比度，以便在不同光线条件下自动保持可读性，这是一个非常详细的课题，谷歌提供了一个非常有用的指南，可以在以下链接找到：[commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf](http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf)
- en: Other than safety and the limitation of application type, Auto apps differ from
    the other apps we have explored only in how they are set up and configured.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全和应用类型的限制之外，Auto应用与我们所探讨的其他应用在设置和配置上的唯一不同。
- en: Configuring Auto apps
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Auto应用
- en: 'If you use the studio wizard to set up an Auto app, you will see that, as with
    Wear apps, we have to include both a Mobile and an Auto module. Unlike wearable
    projects, this does not involve a second module and everything is managed from
    the mobile module. The addition of the Auto component provides a configuration
    file that can be found in `res/xml`. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用工作室向导来设置Auto应用，您会看到，与Wear应用一样，我们必须同时包含移动和Auto模块。与可穿戴项目不同，这并不涉及第二个模块，一切都可以从移动模块管理。添加Auto组件会提供一个配置文件，可以在`res/xml`中找到。例如：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For messaging apps, we would use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息应用，我们会使用以下资源：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The other important Auto elements can be found by examining the template-generated
    manifest files. Whichever type of app you choose to develop, you will need to
    add the following metadata:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查模板生成的清单文件，可以找到其他重要的Auto元素。无论您选择开发哪种类型的应用，都需要添加以下元数据：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you would imagine, a music or audio provider requires a service alongside
    the launcher activity and a messaging app would require a receiver. A music service
    tag would look like the following snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象，音乐或音频提供者需要伴随启动活动的一个服务，而消息应用则需要一个接收器。音乐服务标签如下所示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For a messaging application, we need a service and two receivers, one to receive
    messages and one to send them, like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个消息应用，我们需要一个服务以及两个接收器，一个用于接收消息，一个用于发送消息，如下所示：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In-car devices represent one of the largest growth areas of Android development
    and this is set to grow further still as hands-free driving becomes more prevalent.
    Very often, we may only want to include a single Auto feature into an app designed
    mostly for other form factors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 车载设备是Android开发中增长最快的领域之一，随着免提驾驶变得越来越普遍，这一领域预计将进一步增长。通常，我们可能只想将单个Auto功能集成到主要为其他形态因子设计的应用程序中。
- en: Unlike handheld and wearable devices, we do not have to concern ourselves overly
    with screen size, shape or density, nor do we have to worry about the make or
    model of a particular vehicle. This will no doubt change in the near future as
    the nature of driving and transportation changes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与手持和可穿戴设备不同，我们不必过分关注屏幕尺寸、形状或密度，也不必担心特定车辆的制造商或型号。随着驾驶和交通方式的变化，这无疑将在不久的将来发生变化。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The alternative form factors described in this chapter provide exciting new
    platforms for developers and the kind of applications we can create. This is not
    simply a matter of coming up with apps for each platform, and it is perfectly
    possible to include all three device types within a single app.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的替代形态因子为开发人员以及我们可以创建的应用类型提供了令人激动的新平台。这不仅仅是针对每个平台开发应用程序的问题，完全有可能在单个应用程序中包含这三种设备类型。
- en: Take the sandwich building app we looked at earlier; we could easily adapt it
    so that users could order a sandwich when they were watching a movie. Equally,
    we could send a notification of when their order was ready to their smart phone
    or auto console. In short, these devices open up the market for new apps and added
    functionality for existing ones.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前看过的三明治制作应用为例；我们可以轻松地调整它，让用户在观看电影时下单三明治。同样，我们也可以将订单准备好的通知发送到他们的智能手机或自动控制台。简而言之，这些设备为新的应用程序和现有应用程序的附加功能开辟了市场。
- en: However clever or versatile our creations, there are very few apps that couldn't
    benefit from the promotional opportunities provided my social media. A single
    *tweet* or *like* can reach untold numbers without the expense of advertising.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的创造多么巧妙或多功能，很少有应用程序不能从社交媒体提供的推广机会中受益。一个单一的*tweet*或*like*可以在不花费广告费用的情况下，触及无数的人。
- en: In the next chapter, we will see how easy it is to add social media features
    to our apps and also how we can build web-app functionality into Android apps
    or even construct complete web apps, using the SDK's webkit and WebView.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到向应用程序中添加社交媒体功能是多么容易，以及我们如何将Web应用功能构建到Android应用中，甚至使用SDK的webkit和WebView构建完整的Web应用。
