- en: Chapter 11. Wearable Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, all the Android applications we have considered have been
    designed for mobile devices such as phones and tablets. As we have seen, the framework
    provides great facility for ensuring our designs work well on the wide variety
    of screen sizes and shapes available. However, there are three form factors that
    the work we have done so far does not cover, and that is wearable devices such
    as wrist watches, in-car consoles, and television sets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wearable Patterns](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When it comes to the application of design patterns to these alternative platforms,
    which patterns we choose depends on the purpose of the application rather than
    the platform itself. As we concentrated heavily on patterns in the previous chapter,
    this chapter will mostly cover the practicalities of building apps for each of
    these device types. However, as we shall see when we take a look at TV apps, these
    employ a **model-view-presenter pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: As we have not yet dealt with coding sensors, the chapter will include exploring
    how a user's heart rate can be read and responded to by our code. The way that
    physical sensors, such as heart rate monitors and accelerometers, are managed
    is very similar and by examining one, we can learn how the others are handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a TV app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the leanback library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply MVP patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create banners and media components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the browser and consumption views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect to wearable devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage wearable screen shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle wearable notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read sensor data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand Auto safety features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Auto apps for media services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Auto apps for messaging services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing to consider when developing for this wide range of form factors
    is not just the size of the graphics we need to prepare, but also the distance
    it is viewed from. Most Android devices are used from just a few inches away and
    are often designed to be rotated, moved, and touched. The exception here is the
    television screen, which is generally viewed from around 10 feet away.
  prefs: []
  type: TYPE_NORMAL
- en: Android TV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Televisions are generally best for relaxing activities such as watching movies
    and shows and playing games. However, there is still a large area of overlap,
    particularly concerning games, where many apps can be easily converted to work
    on TV. The viewing distance, high definition, and controller devices mean that
    a few adaptions need to be made and this is largely helped by the leanback support
    library. This library facilitates the model-view-presenter design pattern, which
    is an adaption of the model-view-controller pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There is no limit to the types of app that could be developed for TV, but a
    large percentage of them fall into two categories, games and media. Unlike games,
    which often benefit from having unique interfaces and controls, media based apps
    should generally use widgets and interfaces that are familiar and consistent across
    the platform. This is where the **leanback library** comes in, providing a variety
    of detail, browser and search widgets, and overlays.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android TV](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The leanback library is not the only support library that is of use to TV development,
    both the CardView and RecyclerView are useful and the RecyclerView is in fact
    required, as some leanback classes depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio provides a very useful TV module template that provides a dozen
    or so classes that demonstrate most of the features needed in many media based
    TV applications. It is very worthwhile to take a good look at this template as
    it serves as a rather good tutorial. However, it is not necessarily the best starting
    point for individual projects unless they are quite generic in nature. If you
    are planning any original projects, it is necessary to know one or two things
    about how TV projects are set up, starting with the device home screen.
  prefs: []
  type: TYPE_NORMAL
- en: TV home screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The home screen is the entry point for Android TV users. From here they can
    search for content, adjust settings, and access applications and games. The first
    view the user will get of our app will be on this screen in the form of a banner
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every TV app has a banner image. This is a 320 x 180 dp bitmap that should
    portray what our app does in a simple and efficient manner. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TV home screen](img/image_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Banners can contain colorful photographic imagery too, but text should always
    be kept bold and to a minimum. The banner can then be declared in the project
    manifest. To see how this is done, and how other **manifest** properties relevant
    to TV apps can be set, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project, selecting **TV** as the **Target Android Device** and **Android
    TV Activity** as the activity template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your image to the drawable folder and call it `banner` or something like
    that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `manifests/AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the opening `<application>` node to include the following highlighted
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the root `<manifest>` node, add the following attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This last `<uses-feature>` node is not strictly required, but will make your
    app available to older televisions that do not have microphones included. If your
    app relies on voice control, then omit this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to declare a leanback launcher for our main activity, which
    is done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are building for TV alone, then this is all you need to do in terms
    of making your app available in the TV section of the Play store. However, you
    may be developing an application such as a game that can be played on other devices.
    In this case, also include the following clause to make it available to devices
    that can be rotated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In these situations, you should also set `android.software.leanback` to `required="false"`
    and revert to the material or *appcompat* themes.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we moved the banner declaration from the main activity
    to the application as a whole. This was not strictly necessary, and what we have
    done is simply apply one banner to the whole app, regardless of how many activities
    it contains. Unless you want separate banners for each activity, this is usually
    the best way to go.
  prefs: []
  type: TYPE_NORMAL
- en: TV model-view-presenter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The leanback library is one of the few that directly facilitate the use of a
    design pattern, the model-view-presenter (MVP) pattern, which is a derivation
    of model-view-controller (MVC). Both these patterns are remarkably simple and
    obvious, and some might say that they do not really qualify as patterns at all.
    Even if you had never come across design patterns before, you would have applied
    one or both of these *architectures*.
  prefs: []
  type: TYPE_NORMAL
- en: We covered MVC and MVP briefly earlier, but to recap, in an MVC pattern the
    view and the controller are separate. For example, when the controller receives
    input from the user, such as a click of a button, it passed this to the model
    which executes its logic and forwards this updated information to the view, which
    then displays this change to the user, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The MVP pattern combines the functions of both view and controller, making it
    an intermediary between the user and the model. This is something we have seen
    before in the shape of the adapter pattern, in particular the way recycler views
    and their adapters work.
  prefs: []
  type: TYPE_NORMAL
- en: The leanback presenter class also works in conjunction with a nested view holder,
    and in terms of the MVP pattern, the view is any Android view and the model can
    be any Java object or collection of objects we choose. This means that we can
    use the presenter to act as an adapter between any logic of our choice and any
    layout we wish.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the freedom of this system, before embarking on project development,
    it is worth taking a little look at some of the conventions used in TV app development.
  prefs: []
  type: TYPE_NORMAL
- en: TV app structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A large number of media TV apps offer a limited set of functions, and this
    is usually all that is required. For the most part, users want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse for content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consume content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The leanback library provides fragment classes for each of these. A typical
    **browser view** is provided by the `BrowserFragment` and the template demonstrates
    this with a simple example, along with a `SearchFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TV app structure](img/image_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **consumption view** is provided by the `PlaybackOverlayFragment` and is
    probably the simplest of views, comprising little more than a VideoView and the
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also the `DetailsFragment` that provides content specific information.
    The content and layout of this view are dependent on the subject matter and can
    take any form you choose, the regular rules of material design applying. The **design
    view** scrolls up from the bottom of the consumption view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TV app structure](img/image_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The leanback library makes light work of bringing material design to TV devices.
    If you decide to use views from elsewhere, then the same material rules that apply
    to them elsewhere apply here too. Before moving on, it is worth mentioning that
    background images need to have a 5% bleed around the edges to ensure they reach
    the sides of all TV screens. This means that a 1280 x 720 px image needs to be
    1408 x 792 px.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we covered the banner image used to launch an app, but we also need
    a way to direct users to individual content and in particular to familiar or pertinent
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The top row of the Android TV home screen is the **recommendation row**. This
    allows user to quickly access content based on their viewing history. Content
    can be recommended because it is a continuation of previously viewed content or
    related in some way based on the user's viewing history.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing recommendation cards, there are only a handful of design factors
    we need to consider. These cards are constructed from an image or large icon,
    a title, a subtitle and an application icon, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recommendation cards](img/image_11_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a certain amount of flexibility when it comes to the aspect ratio of
    the card image. The width of the card must never be less than 2/3 of its height
    or more than 3/2\. There must be no transparent elements within the image and
    it must not be less than 176 dp in height.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Large expanses of white can be quite harsh on many televisions. If you need
    large areas of white, use #EEE rather than #FFF.'
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the recommendation row on a live Android TV set, you will
    see that as each card is highlighted, the background image changes and we too
    should provide background images for each recommendation card. These images must
    differ from the one on the card and be 2016 x 1134 px to allow for a 5% bleed
    and ensure they leave no gaps around the edge of the screen. These images too
    should have no transparent sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recommendation cards](img/image_11_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The challenge of designing for such large screens affords us the opportunity
    to include colorful and vibrant imagery with high-quality graphics. At the other
    end of this size spectrum falls the wearable device, where space is premium and
    an entirely different approach is required.
  prefs: []
  type: TYPE_NORMAL
- en: Android Wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wearable Android apps deserve special treatment for yet another reason, and
    that is that nearly all Android Wear applications act as a companion app and work
    in conjunction with a main module that runs on the user's handset. This tethering
    is an interesting and straightforward process and many mobile apps can be enhanced
    greatly by adding a wearable component. Another feature that makes developing
    for wearables a lot of fun is the availability of exciting new sensors and gadgetry.
    In particular, the heart rate monitor found in many smart watches has proved unsurprisingly
    popular in fitness apps.
  prefs: []
  type: TYPE_NORMAL
- en: Wearables are one of the most exciting areas of smart device development. Smart
    phones and other worn devices with a whole range of new sensors open up uncountable
    new possibilities for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Apps running on wearable devices need to be connected to a parent application
    running on a mobile handset and are best thought of as extensions of the main
    app. Whereas most developers have access to at least one handset, wearable devices
    can be an expensive option for testing only, particularly because we would need
    a minimum of two. This is because of the difference in the way **square and round
    screens** are handled. Fortunately, we can create AVDs with an emulator and connect
    these to either a real phone or tablet or a virtual one.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing with a wearable device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To best see this difference between round and square screen management, begin
    by creating an emulator for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pairing with a wearable device](img/B05685_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a chinned version, but for programming purposes we can consider
    this the same as the round screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'How you pair the wearable AVD will depend on whether you are coupling it with
    a real handset or another emulator. If you are using a handset, you will need
    to download the Android Wear app from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.google.com/store/apps/details?id=com.google.android.wearable.app](https://play.google.com/store/apps/details?id=com.google.android.wearable.app)'
  prefs: []
  type: TYPE_NORMAL
- en: Then locate the `adb.exe` file, which, by default, is located in `user\AppData\Local\Android\sdk\platform-tools\`
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the command window here and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can now launch the companion app and follow the instructions to pair the
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to issue this port forwarding command each time you connect the
    handset.
  prefs: []
  type: TYPE_NORMAL
- en: If you are pairing your wearable emulator with an emulated handset, then you
    will need an AVD that targets Google APIs rather than a regular Android platform.
    You can then download the `com.google.android.wearable.app-2.apk`. There are many
    places online where this can be found, such as:  [www.file-upload.net/download](http://www.file-upload.net/download)
  prefs: []
  type: TYPE_NORMAL
- en: 'The apk should be placed in your `sdk/platform-tools` directory, where it can
    be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start your wearable AVD and enter `adb devices` into the command prompt,
    making sure that both emulators are visible with an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: at the command prompt, where `5554` is the phone emulator. Next, enter `adb
    redir add tcp:5601:5601\.` You can now use the Wear app on the handheld AVD to
    connect to the watch.
  prefs: []
  type: TYPE_NORMAL
- en: When creating Wear projects, you will need to include two modules, one for the
    wearable component and one for the handset.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pairing with a wearable device](img/image_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Android provides a **wearable UI support library** that provides some very
    useful features for Wear developers and designers. If you have created a wearable
    project using the wizard, this will have been included during setup. Otherwise
    you will need to include the following dependencies in the `Module: wear` `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also require these lines in the Module: mobile build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Managing screen shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have no idea in advance which of these shapes our apps will be running on,
    and there are two solutions to this conundrum. The first, and most obvious, is
    simply to create a layout for each shape and this is very often the best solution.
    If you have a wearable project created with the wizard, you will see that template
    activities for both shapes have been included.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need a way to detect the screen shape when the app is run on an actual
    device or emulator so that it knows which layout to inflate. This is done with
    the **WatchViewStub** and the code to call it has to be included in `onCreate()`
    method of our main activity file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be implemented in XML like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The alternative to creating separate layouts for each screen shape is to use
    a layout that itself is aware of screen shape. This comes in the form of the **BoxInsetLayout**,
    which adjusts padding settings for round screens and only positions views within
    the largest possible square within that circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BoxInsetLayout can be used like any other layout, as the root ViewGroup
    in your main XML activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are definitely drawbacks to this approach, as it does not always make
    the most of the space available on round faces, but what the BoxInsetLayout lacks
    in flexibility it makes up for in ease of use. In most cases, this is not a drawback
    at all, as a well-designed Wear app should only grab the user's attention briefly
    with simple information. Users are not keen to navigate complex UIs on their watches.
    The information we display on a watch screen should be able to be absorbed in
    a glance and the responding action should be limited to no more than a tap or
    a swipe.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main uses of smart devices is to receive notifications when the user
    is otherwise unable to access their handset, for example when they are exercising.
  prefs: []
  type: TYPE_NORMAL
- en: Wearable notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is very little to adding wearable notification functionality to any mobile
    app. Recall how notifications are delivered from [Chapter 9](ch09.html "Chapter 9. Observing
    Patterns"), *Observing Patterns*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To adapt this to also send the notification to the paired wearable device,
    simply add these two lines to the builder string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The optional `setHintShowBackgroundOnly` setting allows us to display the notification
    without a background card.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time a wearable is used as an output device, but it can also act
    as an input and many new functions can be derived when sensors are placed close
    to the body, such as the heart rate monitor included in many smart phones.
  prefs: []
  type: TYPE_NORMAL
- en: Reading sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a growing number sensors available on most smart devices today and
    smart watches offer new opportunities to developers. Fortunately these sensors
    are very simple to program, they are after all, just another input device and
    as such, we employ listeners to *observe* them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the function and purpose of individual sensors differs widely, the
    way they are read is almost identical, the only difference being the nature of
    their outputs. Here we will look at the heart rate monitor found on many wearables:'
  prefs: []
  type: TYPE_NORMAL
- en: Open or start a Wear project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the wear module and add a BoxInsetLayout with a TextView to the main activity
    XML file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the Manifest file in the wear module and add the following permission inside
    the root `manifest` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the main Java activity file in the wear module and add the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a `SensorEventListener` on the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the two methods required by the listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `onCreate()` method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this `onResume()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And this `onPause()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `onSensorChanged()` callback, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Reading sensors](img/image_11_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, sensor listeners act like observers in exactly the same way
    as click and touch listeners. The only real difference is that sensors need to
    be explicitly registered and unregistered, as they are not available by default
    and need to be switched off when done with to preserve battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'All sensors can be managed the same way with a sensor event listener and it
    is usually best to check for each sensor''s presence when initializing the app
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Wearable devices open up a whole new world of app possibilities, bringing Android
    into ever increasing aspects of our lives. Another such example would be the use
    of Android devices in our cars.
  prefs: []
  type: TYPE_NORMAL
- en: Android Auto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with Android TV, Android Auto can run many apps designed originally for mobile
    devices. Of course, with in-car software, safety is the overwhelming priority,
    which is why most Auto apps concentrate on audio functions, such as messaging
    and music.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the emphasis on safety, Android Auto apps have to undergo stringent
    testing before they can be published.
  prefs: []
  type: TYPE_NORMAL
- en: 'It barely needs mentioning that safety is the overriding principle when developing
    in-car apps, and for this reason, Android Auto applications nearly all fall into
    two categories: music or audio players and messaging.'
  prefs: []
  type: TYPE_NORMAL
- en: All applications require extensive testing during the development phase. Obviously,
    it would be impractical and highly dangerous to test an Auto app on a live device,
    and for this reason Auto API simulators are provided. These can be installed from
    the SDK manager's tools tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Auto](img/image_11_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Auto safety considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the rules governing Auto safety are simple common sense, avoid animations,
    distractions and delays, but of course it is necessary to formalize these and
    Google have done so. These rules concern driver attention, screen layout, and
    readability. The most significant can be found in the list here:'
  prefs: []
  type: TYPE_NORMAL
- en: There must be no animated elements on the Auto screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only audio ads are allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps must support voice control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All buttons and clickable controls must respond within two seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text must be longer than 120 characters and must always be in the default Roboto
    font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Icons must be white so that the system can control contrast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps must support day and night mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App must support voice commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App-specific buttons must respond to user actions with no more than a two-second
    delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A comprehensive list can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[developer.android.com/distribute/essentials/quality/auto.html](http://developer.android.com/distribute/essentials/quality/auto.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'IMPORTANT: These, and several other stipulations, will be tested by Google
    before publication, so it is essential that you run all of these tests yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Designing apps that are suitable for day and night modes and that can have
    contrast controlled by the system to automatically remain readable in different
    light conditions is quite a detailed subject and Google have produced a very useful
    guide to this, which can be found at: [commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf](http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Other than safety and the limitation of application type, Auto apps differ from
    the other apps we have explored only in how they are set up and configured.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Auto apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use the studio wizard to set up an Auto app, you will see that, as with
    Wear apps, we have to include both a Mobile and an Auto module. Unlike wearable
    projects, this does not involve a second module and everything is managed from
    the mobile module. The addition of the Auto component provides a configuration
    file that can be found in `res/xml`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For messaging apps, we would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The other important Auto elements can be found by examining the template-generated
    manifest files. Whichever type of app you choose to develop, you will need to
    add the following metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would imagine, a music or audio provider requires a service alongside
    the launcher activity and a messaging app would require a receiver. A music service
    tag would look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For a messaging application, we need a service and two receivers, one to receive
    messages and one to send them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In-car devices represent one of the largest growth areas of Android development
    and this is set to grow further still as hands-free driving becomes more prevalent.
    Very often, we may only want to include a single Auto feature into an app designed
    mostly for other form factors.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike handheld and wearable devices, we do not have to concern ourselves overly
    with screen size, shape or density, nor do we have to worry about the make or
    model of a particular vehicle. This will no doubt change in the near future as
    the nature of driving and transportation changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The alternative form factors described in this chapter provide exciting new
    platforms for developers and the kind of applications we can create. This is not
    simply a matter of coming up with apps for each platform, and it is perfectly
    possible to include all three device types within a single app.
  prefs: []
  type: TYPE_NORMAL
- en: Take the sandwich building app we looked at earlier; we could easily adapt it
    so that users could order a sandwich when they were watching a movie. Equally,
    we could send a notification of when their order was ready to their smart phone
    or auto console. In short, these devices open up the market for new apps and added
    functionality for existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: However clever or versatile our creations, there are very few apps that couldn't
    benefit from the promotional opportunities provided my social media. A single
    *tweet* or *like* can reach untold numbers without the expense of advertising.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how easy it is to add social media features
    to our apps and also how we can build web-app functionality into Android apps
    or even construct complete web apps, using the SDK's webkit and WebView.
  prefs: []
  type: TYPE_NORMAL
