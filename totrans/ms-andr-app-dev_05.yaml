- en: Chapter 5. Lists and Grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will work with lists and grids. A list or a matrix of elements
    can be found in almost every app on the market. Knowing how to display a list
    of elements on Android is something that you learn at a basic level; however,
    there is a lot to expand on and understand.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to know which patterns we can use here, how to recycle the view,
    and how to display different kinds of elements with different views in the same
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we will be able to understand why `RecyclerView` is the
    successor of `ListView`, and we will learn how to implement a list with this component.
    Therefore, we will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ListView
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom adapter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recycling views
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ViewHolder pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing RecyclerView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List, grid, or stack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OnItemClick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have heard of `RecyclerView`, you might wonder why we are going through
    `ListView`. The `RecyclerView` widget is new; it came out with Android Lollipop,
    and is a revolution when displaying a list of items; it can do it vertically and
    horizontally, as a list or as a grid, or with nice animations among other improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Answering the question, even if `RecyclerView` is more efficient and flexible
    in some scenarios, it needs extra coding to achieve the same result, so there
    are still reasons to use `ListView`. For example, there is no `onItemClickListener()`
    for item selection in `RecyclerView`, and there is no visual feedback when we
    click on an item. If we don't need customization and animations, for instance
    for a simple data picker popup, this could be a dialog where we just have to select
    a country. In this case, it's perfectly fine to use `ListView` rather than `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to start with `ListView` is that `RecyclerView` solves most of
    the problems presented when working with `ListViews`. Therefore, by starting with
    `ListView` and solving these problems, we will fully understand how `RecyclerView`
    works and why it is implemented this way. Thus, we will explain individually the
    patterns that are used to have a global idea of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the basic `AlertDialog` with the purpose of selecting
    an item; here, the use of `ListView` makes perfect sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with lists](img/4887_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using ListViews with built-in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you first implement `ListView`, it might seem trivial and easy; however,
    when you spend more time with Android, you realize how complex it can get. You
    can very easily find performance and memory issues by just having a large list
    of elements with an image on every row. It can be difficult to customize the list
    if you try to implement a complex UI; for example, having the same list displaying
    different items, creating different rows with different views, or even trying
    to group some items while showing a section title can be a headache.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the shortest way to implement a list, using the Android built-in
    item layout, which is created to be used in simple lists as discussed before.
    In order to show the list, we will include it in `AlertDialog`, which will be
    shown when we tap on a button in the settings fragment. I will set the text of
    the button to `Lists Example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create the button in `settings_fragment.xml`; once created,
    we can set the click listener to the button. Now, we understand a bit more about
    software patterns instead of setting the click listener in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will do it in a more structured way, especially because we know that in the
    settings screen, there will be a good number of buttons, and we want to handle
    all the clicks in the same place. Instead of creating `onClickListener` inside
    the method call, we will make the `Fragment` implement `OnClikListener` by setting
    `onClickListener` to `this`. The `this` keyword refers to the whole fragment here,
    so the fragment will be listening for the click in the `onClick` method, which
    is mandatory to implement once the `Fragment` implements `View.OnClickListener`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnClick()` method receives a view, which is the view clicked on. If we
    compare that view's ID with the ID of the button, we will know whether the button
    or the other view where we set `clickListener` has been clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just type `implements View.OnClickListener` when defining the class, and you
    will be asked to implement the mandatory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we also move the logic to show the list dialog to an external
    method, keeping the structure easy to read in `onClick();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the dialog, we can show an `AlertDialog` that has a `setAdapter()`
    property, which automatically binds the items with an internal `ListView`. Alternatively,
    we could create a view for our dialog with `ListView` on it and then set the adapter
    to that `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This dialog will show a message indicating the option clicked. We have used
    `android.R.layout.select_dialog_singlechoice` as a view for our rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are a few different examples of built-in layouts for lists, which will
    depend on the theme of our application. The dialog won''t look the same in 4.4
    KitKat and in 5.0 Lollipop, for instance, in `android.R.layout.simple_list_item_1`,
    this is how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ListViews with built-in views](img/4887_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what `android.R.layout.simple_list_item_2` with two rows will look
    similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ListViews with built-in views](img/4887_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an example of `android.R.layout.simpleListItemChecked`, where we can
    change the choice mode to multiple or single:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ListViews with built-in views](img/4887_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is `android.R.layout.activityListItem`, where we have an icon and text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ListViews with built-in views](img/4887_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can access these built-in layout components to tweak the view a bit more
    when creating the layout. These components are named `android.resource.id.Text1`,
    `android.resource.id.Text2`, `android.resource.id.Icon`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have an idea of how to create lists with the functionality and views
    ready to be used. It's time to create our own Adapter and implement the functionality
    and the view manually.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you look for a job, apart from looking at offers, you would also be handing
    your CV to different software companies or to IT recruitment companies that will
    find a company for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our contact fragment, we will create a list sorted by country, displaying
    the contact details of these companies. There will be two different rows: one
    for the country header and another one for the company details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create another table in our Parse database, called `JobContact`, with
    the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom Adapter](img/4887_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will request the job contacts from the server and build a list of items
    that will be sent to the Adapter to build the list. In the list, we will send
    two different elements: the company and the country. What we can do is generate
    a list of items and add the two as objects. Our two classes will look similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we download the information sorted by country from [http://www.parse.com](http://www.parse.com),
    we can build our list of items, iterating through the parse list and adding a
    country header when a different country is detected. Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our list with the headers included we are ready to create
    the `Adapter` based on this list, which will be sent as a parameter in the constructor.
    The best way to customize an `Adapter` is to create a subclass extending `BaseAdapter`.
    Once we do this, we will be asked to implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods will have to be implemented according to the data that we want
    to display; for instance, `getCount()` will have to return the size of the list.
    We need to implement a constructor receiving two parameters: the list and the
    context. The context will be necessary to inflate the list in the `getView()`
    method. This is how the adapter will look without implementing `getView()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we can create two different views; so, apart from the mandatory
    methods, we need to implement two extra methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getItemViewType` method will return `0` if the element is a country or
    `1` if the element is a company. With the help of this method, we can implement
    `getView()`. In case it''s a country, we inflate `row_job_country.xml`, which
    contains `ImageView` and `TextView`; in case it''s a company, we inflate `row_job_contact.xml`,
    which contains three text views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, we can create `ListView` in `contact_fragment.xml` and set the adapter
    to this list. However, we will take a shortcut and use `android.support.v4.ListFragment`;
    this is a fragment that already inflates a view with `ListView` and contains the
    `setListAdapter()` method, which sets an adapter to the built-in `ListView`. Extending
    from this fragment, our `ContactFragment` class will look similar to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon calling the `retrieveJobContacts()` method after the view has been created,
    we achieve the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom Adapter](img/4887_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The flags that we have displayed are images in the `drawable` folder whose
    name matches the country code, *drawable/ "country_code" .png*. We can display
    them by setting the resource identifier to `ImageView` and retrieving it with
    the following method inside the `Country` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic version of `ListView` with two different types of rows. This
    version is still far from perfect; it lacks performance. It does not recycle the
    views, and it finds the IDs of the widget every time we create a row. We will
    explain and solve this problem in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Recycling views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working with `ListView`, we need to keep in mind that the number of rows
    is a variable and we always want the list to feel fluent even if we scroll as
    quickly as we can. Hopefully, Android helps us a lot with this task.
  prefs: []
  type: TYPE_NORMAL
- en: When we scroll through `ListView`, the views that are not visible anymore on
    one side of the screen are reused and displayed again on the other side. This
    way, android saves inflation of the views; when it inflates, a view has to go
    through the xml nodes, instantiating every component. This extra computation can
    be the difference between a fluent and staggering list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recycling views](img/4887_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `getView()` method receives as a parameter one of the views that are to
    be recycled or null if there are no views to be recycled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of this view recycling, we need to stop creating a view every
    time and reuse the view coming as a parameter. We still need to change the value
    of the text views and widget inside the row on a recycled view because it has
    the initial values that correspond to its previous position. In our example, we
    have an extra complication; we cannot recycle a country view to be used for a
    company view, so we can only recycle views of the same view type. However, again,
    Android does that check for us using internally the `getItemViewType` method that
    we implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Applying the ViewHolder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that in `getView()`, every time we want to set a text to `TextView`, we
    search this `TextView` in row view with the `findViewById()` method; even when
    the row is recycled, we still find the `TextView` again to set the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a class called `ViewHolder`, which holds the reference to the
    widget by saving the computation of the widget search inside the row. This `ViewHolder`
    class will only contain references to the widgets, and we can keep a reference
    between a row and its `ViewHolder` class through the `setTag()` method. A `View`
    object allows us to set an object as a tag and retrieve it later; we can add as
    many tags as we want by specifying a key for this tag: `setTag(key)` or `getTag(key)`.
    If no key is specified, we can save and retrieve the default tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this pattern for the first time that we create the view, we will
    create the `ViewHolder` class and set it as a tag to the view. If the view is
    already created and we are recycling it, we will simply retrieve the holder. Execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify this code, we can create a method called `bindView()` inside each
    holder; it will get a country or company object and populate the widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now finish with the list of `ListView` performance improvements. If
    there are images or long operations to load a view, we need to create `AsyncTask`
    method inside `getView()` so as to avoid heavy operation while scrolling. For
    instance, if we want to display an image downloaded from the Internet on every
    row, we would have a `LoadImageAsyncTask` method, which we will execute with the
    holder and the URL to download the image from. When the `Asynctask` method finishes,
    it will have a reference to the holder and will therefore be able to display the
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know all of the different techniques to improve the performance
    of a `ListView`, we are ready to introduce `RecyclerView`. By applying most of
    these techniques in the implementation, we will be able to identify it easily.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RecyclerView` was introduced in Android 5.0 Lollipop and was defined by
    Google as a more flexible and advanced version of `ListView`. It is based on an
    `Adapter` class similar to `ListView`, but it enforces the use of a `ViewHolder`
    class to improve performance and modularity, as we have seen in the previous section.
    The flexibility comes in when we decouple the item representation from the component
    and allow animations, item decorations, and layout managers to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: The `RecyclerView` handles the adding and removing of animations using `RecyclerView.ItemAnimator`,
    which we can subclass to customize the animations. If you display data from a
    source or if the data changes, for instance by adding or removing items, you can
    call `notifyItemInserted()` or `notifyItemRemoved()` to trigger the animations.
  prefs: []
  type: TYPE_NORMAL
- en: To add separators, group items, or highlight an item, we can use `RecyclerView.ItemDecoration`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main differences in utilizing `ListView` is the use of layout managers
    to position the items. With `ListView`, we know that our items will always be
    displayed vertically, and if we want to have a grid, we can use `GridView`. Layout
    managers make our list more flexible in that we can display elements as we want
    and can even create our own layout manager.
  prefs: []
  type: TYPE_NORMAL
- en: Using list, grid, or stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, we have three built-in layout managers: `LinearLayoutManager`,
    `GridLayoutManager`, and `StaggeredLayoutManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `LinearLayoutManager` displays the items aligned in a list, where we can
    specify the orientation—vertical or horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using list, grid, or stack](img/4887_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `GridLayoutManager` displays the items as a matrix, where we can specify
    the columns and rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using list, grid, or stack](img/4887_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `StaggereGriddLayoutManager` displays the items in a staggered way; these
    items can have different widths or heights, and we can control how they are displayed
    with `setGapStrategy()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using list, grid, or stack](img/4887_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing RecyclerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with `MasteringAndroidApp`, we will implement again the list of job
    offers, removing `ParseQueryAdapter` and using `RecyclerView` instead. We will
    still query the data from Parse, but this time, what we will do is save the list
    of items in a variable and use it to build `RecyclerView.Adapter`, which will
    be used by `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RecyclerView` is included in the v7 support library; the best way to include
    it in our project is to open the project structure, click on the dependencies
    tab, and search for `RecyclerView`. A list of results will be presented as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing RecyclerView](img/4887_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the equivalent of adding the following line to the `build.gradle` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once the line is added, we will click on **Sync Gradle with Project files**
    to update the dependencies and get ready to use `RecyclerView` in our XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `fragment_list.xml` and replace the existing `ListView` with `RecyclerView`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you don't get any errors after adding it, the dependency was added correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the adapter. This adapter is slightly different
    from the adapter that we created for the job contacts; instead of extending `BaseAdapter`,
    we will extend `RecyclerView.Adapter <RecyclerView.MyViewHolder>`, which is an
    adapter that implements the `ViewHolder` pattern after creating the `JobOfferAdapter`
    adapter class. However, before extending, we have to create an internal `MyViewHolder`
    class extending `RecylcerView.ViewHolder`. So far, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is when we extend the `JobOffersAdapter` class from `RecyclerView.Adapter<JobsOfferAdapter.MyViewHolder>`.
    We will be asked to implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Following the same approach as in `JobsContactsAdapter`, we create a constructor
    by receiving the list of job offers and implement the adapter methods based on
    that list.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnBindViewHolder` receives the holder with a position; all we need to do is
    get the job offer in that position on the list and update the holder text views
    with these values. `OnCreateViewHolder` will inflate the view; in this case, we
    only have one type, so we ignore the `ViewType` parameter. We will show here an
    alternative way to inflate the view: using the context of the parent, which comes
    as a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `getItemCount` will return the number of job offers. As you complete
    all of the above tasks, our new Adapter will be created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all that we need from the adapter side; now, we need to initialize
    `RecyclerView` and set a layout manager along with the adapter. The adapter has
    to be instantiated using the list of objects from Parse in the same way that we
    retrieved our job contacts in the previous Adapter. First, in `OnCreateView`,
    we will initialize `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we will call `retrieveOffers()`, which is an `async` operation.
    Only when the result is retrieved from Parse will we be able to create the adapter
    and set it to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to test all that we set to work is to see if there are any errors
    in the console. If all runs fine, you should be able to see the list of offers,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing RecyclerView](img/4887_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have intentionally added a repeated job offer, which we will delete in order
    to see the removing animations included by default in `RecyclerView`. We will
    implement this functionality in a **long click listener**. The click listener
    is performed only to open the offer in the detail view. We will see how to do
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on RecyclerView items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `ListView`, it was quite easy to detect a click on an item; we could simply
    perform `ListView.setOnItemClickLister` and `setOnItemLongClickListener` for long
    clicks. However, this implementation is not as quick with `RecyclerView`; the
    flexibility comes at a cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two approaches to implementing an item click here: one is to create
    a class that implements `RecyclerView.OnItemTouchListener` and calls the `RecyclerView`
    method, `addOnItemTouchListener`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this approach is that we define what to do inside `onClick` in
    each activity or fragment. The logic of the click is not on the view, and once
    we build this component, we can reuse it in different apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is to set and manage the click inside `ViewHolder`. We
    will have a problem here if we want to reuse this `ViewHolder` in a different
    part of the app or in another app because the logic of the click is inside the
    view and we might want to have a different logic in different fragments or activities.
    However, this approach makes it easier to detect clicks on different components
    inside the same row. For instance, if we had a small icon to delete and another
    one to share the offer inside the row, this approach would make much more sense.
    This way, we can set the click on the job name in every row and a long click listener
    in the whole row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to judge which implementation to use in every situation and
    argue in its favor. To be able to test this, we are going to delete an element
    after a long tap (we should have a confirmation dialog here to avoid deleting
    items by mistake but we will skip this part). The element will be deleted locally
    to display the remove animation. Note that we are not deleting this element from
    the source in Parse; all we need to do is to delete the element from the list
    and call `notifyItemRemoved` to trigger the notification. We will know which item
    is clicked on with the `getPosition()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of this chapter, you will know how to implement an Adapter, how to
    handle different types of items in lists, and how and why we apply the `ViewHolder`
    pattern. You first learned this along with the `ListView` class and manually implemented
    the recycling view techniques. As a result, you will be able to fully understand
    the features and how `RecyclerView` works in showing different ways to display
    the items and implement item click listeners.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover a new component introduced along with
    `RecyclerView` in Android 5.0— `CardView`. We will combine this with `RecyclerView`
    to have a flexible and professional-looking list of cards.
  prefs: []
  type: TYPE_NORMAL
