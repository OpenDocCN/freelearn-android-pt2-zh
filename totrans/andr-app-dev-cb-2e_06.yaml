- en: Chapter 6. Working with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing simple data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write a text file to internal storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write a text file to external storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including resource files in your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access data in the background using a Loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since almost any application, big or small, requires saving some kind of data,
    Android offers many options. From saving a simple value to creating full databases
    using SQLite, storage options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shared preferences: simple name/value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internal storage: data files in private storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'External storage: data files in private or public storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLite database: private data can expose the data through a Content Provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud storage: Private server or Service Provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are benefits and tradeoffs to using internal and external storage. We
    will list some of the differences here to help you decide whether to use internal
    or external storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal storage**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike external storage, internal storage is always available, but generally
    has less free space
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are not accessible to the user (unless the device has root access)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are automatically deleted when your app is uninstalled (or with the Clear
    Cache/Cleanup File option in the App Manager)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External storage**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device may not have external storage or it may be inaccessible (such as
    when it's connected to a computer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are accessible to the user (and other apps) without requiring root access
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are not deleted when your app is uninstalled (unless you use `getExternalFilesDir()`
    to get app-specific public storage)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will demonstrate working with shared preferences, internal
    and external storage, and SQLite databases. For cloud storage, take a look at
    the Internet recipes in [Chapter 12](ch12.html "Chapter 12. Telephony, Networks,
    and the Web"), *Telephony, Networks, and the Web* and Online Service Providers
    in [Chapter 15](ch15.html "Chapter 15. The Backend as a Service Options"), *Backend
    as a Service Options*.
  prefs: []
  type: TYPE_NORMAL
- en: Storing simple data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a common requirement to store simple data, and Android makes it simple
    using the Preferences API. It's not limited to just user preferences either; you
    can store any of the primitive data types using a name/value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll demonstrate saving a name from an `EditText` and displaying it when
    the application starts. The following screenshot shows how the application looks
    the first time with no saved name, and then on startup, after a name is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing simple data](img/B05057_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `Preferences`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use the existing **TextView** to display a **Welcome back** message
    and create a new `EditText` button to save the name. Start by opening `activity_main.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing **TextView** and add the following new views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `ActivityMain.java` and add the following global declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to `onCreate()` to save a reference to the `EditText`
    and to load any saved name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `saveName()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator. Since we are demonstrating persisting
    data, it loads the name during the `onCreate()`, so save a name and restart the
    program to see it load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To load the name, we first get a reference to `SharedPreference` so we can call
    the `getString()` method. We pass in the key for our name/value pair and the default
    value to return if the key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: To save the preference, we first need to get a reference to the Preference Editor.
    We use `putString()` and follow it with `commit().` Without `commit()`, the change
    will not be saved.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our example stores all the preferences in a single file. We can also store preferences
    in different files using `getSharedPreferences()` and passing in the name. This
    option can be used if you want to have separate profiles for multiple users.
  prefs: []
  type: TYPE_NORMAL
- en: Read and write a text file to internal storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When simple name/value pairs are not sufficient, Android also supports regular
    file operations including working with text and binary data.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipe demonstrates how to read and write a file to internal or
    private storage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `InternalStorageFile`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate both reading and writing text, we''ll need a layout with an
    `EditText` and two buttons. Start by opening `main_activity.xml` and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing `<TextView>` element with the following views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open `ActivityMain.java` and add the following global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the `onCreate()` method, after `setContentView ()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `writeFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the `readFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the `InputStream` and `FileOutputStream` classes to read and write, respectively.
    Writing to the file is as simple as getting the text from the `EditText` and calling
    the `write()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reading back the contents is a little more involved. We could use the `FileInputStream`
    class for reading, but when working with text, the helper classes make it easier.
    In our example, we open the file with `openFileInput()`, which returns an `InputStream`
    object. We then use the `InputStream` to get a `BufferedReader`, which offers
    the `ReadLine()` method. We loop through each line in the file and append it to
    our `StringBuilder`. When we're finished reading the file, we assign the text
    to the `EditText`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our previous file was created in the app''s private data folder. To view the
    contents of the file, you can use the Android Device Monitor to pull the file
    to your computer. The full file path is: `/data/data/com.packtpub.androidcookbook.`
    `internalstoragetile/files/testfile.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the file appears when viewed through the
    **Android Device Monitor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05057_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need a device with root access to view the private folder shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see some additional information that can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Cache Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If all you need is to temporarily store data, you can also use the cache folder.
    The following method returns the cache folder as a `File` object (the next recipe
    demonstrates working with the `File` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main benefit of the cache folder is that the system can clear the cache
    if running low on storage space. (The user can also clear the cache folder from
    Apps Management in Settings.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your app downloads news articles, you could store those in the
    cache. When your app starts, you can display the news already downloaded. These
    are files that are not required to make your app work. If the system is low on
    resources, the cache can be cleared without adversely affecting your app. (Even
    though the system may clear the cache, it's still a good idea for your app to
    remove old files as well.)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Read and write a text file to external storage*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write a text file to external storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of reading and writing files to external storage is basically the
    same as using internal storage. The difference is in obtaining a reference to
    the storage location. Also, as mentioned in the *Introduction*, external storage
    may not be available, so it's best to check availability before attempting to
    access it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will read and write a text file, as we did in the previous recipe.
    We'll also demonstrate how to check the external storage state before we access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `ExternalStorageFile`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for the **Activity Type**. We will use the same layout as the previous
    recipe, so you can just copy and paste if you typed it in already. Otherwise,
    use the layout from Step 1 in the previous recipe, *Read and write a text file
    to internal storage*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously in the *Getting ready* section, we''ll use the layout
    from the previous recipe. With the layout file done, the first step will be to
    add permission to access the write to external storage. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Android Manifest and add the following permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open `ActivityMain.java` and add the following global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the `onCreate()` method, after `setContentView ()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following two methods to check the storage state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `writeFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `readFile()`method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator with external storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading and writing files are basically the same for both internal and external
    storage. The main difference is that we should check for the availability of the
    external storage before attempting to access it, which we do with the `isExternalStorageWritable()`
    and `isExternalStorageReadable()` methods. When checking the storage state, `MEDIA_MOUNTED`
    means we can read and write to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the internal storage example, we request the working path as we do in
    this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The actual reading and writing is done with the same classes, as it is just
    the location that is different.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not safe to hard code an external folder path. The path can vary between
    versions of the OS and especially between hardware manufacturers. It is always
    best to call `getExternalStorageDirectory()`, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some additional information are discussed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting public folders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `getExternalStorageDirectory()` method returns the root folder of the external
    storage. If you want to obtain specific public folders, such as the `Music` or
    `Ringtone` folder, use `getExternalStoragePublicDirectory()` and pass in the desired
    folder type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Checking available space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One issue consistent between internal and external storage is limited space.
    If you know how much space you will need ahead of time, you can call the `getFreeSpace()`
    method on the `File` object. (`getTotalSpace()` will return the total space.)
    Here is a simple example to using the call to `getFreeSpace()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many helper methods available through the `File` object, including
    deleting a file. If we wanted to delete the text file we created in the example,
    we could call `delete()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Working with directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though it''s called a `File` object, it supports directory commands as well,
    such as making and removing directories. If you want to make or remove a directory,
    build the `File` object, then call the respective methods: `mkdir()` and `delete()`.
    (There''s also a method called `mkdirs()` (plural) that will create parent folders
    as well.) See the following link for a complete list.'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing files from being included in galleries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android employs a **media scanner** that automatically includes sound, video,
    and image files in the system collections, such as the Image Gallery. To exclude
    your directory, create an empty file called `.nomedia` (note the preceding period)
    in the same directory as the files you wish to exclude.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a complete list of methods available in the `File` class, visit [http://developer.android.com/reference/java/io/File.html](http://developer.android.com/reference/java/io/File.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including resource files in your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android provides two options for including files in your project: the `raw`
    folder and the `Assets` folder. Which option you use depends on your requirements.
    To start, we''ll give a brief overview of each option to help you decide when
    to use each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raw files**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Included in the resource directory: `/res/raw`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a resource, accessed through the raw identifier: `R.raw.<resource>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A good place for storing media files such as MP3, MP4, and OOG files
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset files**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a filesystem compiled in your APK (does *NOT* provide a resource ID)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Access files using their file names, generally making them easier to use with
    dynamically created names
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some APIs do not support a Resource Identifier and therefore require including
    as an Asset
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, `raw` files are easier to work with since they are accessed through
    the resource identifier. As we'll demonstrate in this recipe, the main difference
    is how you access the file. In this example, we will load both a `raw` text file
    and an `asset` text file and display the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `ReadingResourceFiles`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate reading content from both resource locations, we''ll create
    a split layout. We also need to create both resource folders as they are not included
    in the default Android project. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml` and replace the contents with the following layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `raw` resource folder in the res folder. It will read as: `res/raw`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new text file by right-clicking on the `raw` folder and select **New**
    | **File**. Name the file `raw_text.txt` and type some text in the file. (This
    text will display when you run the application.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `asset` folder. The `asset` folder is trickier because of the location.
    Fortunately, Android Studio provides a menu option that makes creating it very
    easy. Go to the **File** menu (or right-click on the **app** node) and select
    **New** | **Folder** | **Assets Folder** as shown in this screenshot:![How to
    do it...](img/B05057_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another text file in the asset folder called `asset_text.txt`. Again,
    whatever text you type here will be shown when you run the app. Here's how the
    final result should look after both text files are created:![How to do it...](img/B05057_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time for the code. Open `MainActivity.java` and add the following
    method to read the text file (which is passed into the method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following code to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize, the only difference is in how we get a reference to each file.
    This line of code reads the `raw` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And this code reads the `asset` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Both calls return an `InputStream`, which the `getText()` method uses to read
    the file contents. It is worth noting, though, that the call to open the `asset`
    text file requires an additional `try`/`catch`. As noted in the recipe introduction,
    resources are indexed so we have compile time verification, which the `asset`
    folder does not have.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common approach is to include resources in your APK, but download new resources
    as they become available. (See the network communication in [Chapter 12](ch12.html
    "Chapter 12. Telephony, Networks, and the Web"), *Telephony, Networks, and the
    Web*.) If new resources aren't available, you can always fall back on the resources
    in your APK.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network communication recipes in [Chapter 12](ch12.html "Chapter 12. Telephony,
    Networks, and the Web"), *Telephony, Networks, and the Web.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we're going to demonstrate working with an SQLite database.
    If you are already familiar with SQL databases from other platforms, then much
    of what you know will apply. If you are new to SQLite, take a look at the reference
    links in the "See also" section as this recipe assumes a basic understanding of
    database concepts including schemas, tables, cursors, and raw SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get you up and running with an SQLite database quickly, our example implements
    the basic CRUD operations. Generally, when creating a database in Android, you
    create a class that extends `SQLiteOpenHelper`, which is where your database functionality
    is implemented. Here is a list of the functions to provide each of the basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create: `insert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read: `query()` and `rawQuery()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update: `update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delete: `delete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate a fully working database, we will create a simple `Dictionary`
    database, so we can store words and their definitions. We'll demonstrate the CRUD
    operations by allowing adding new words (with their definitions) and updating
    existing word definitions. We'll show words in a `ListView` using a cursor. Pressing
    a word in the `ListView` will read the definition from the database and display
    it in a Toast message. A long press will delete the word.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `SQLiteDatabase`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll create the UI, which will consist of two `EditText` fields, a
    button, and a `ListView`. As we add words to the database, they will populate
    the `ListView`. To start, open `activity_main.xml` and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing `<TextView>` with these new views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new Java class to the project named `DictionaryDatabase`. This class
    extends from `SQLiteOpenHelper` and handles all the SQLite functions. Here is
    the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the declaration, add the following constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following constructor, `OnCreate()` and `onUpgrade()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following methods are responsible for creating, updating, and deleting
    the records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And these methods handle reading the information from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the database class finished, open `MainActivity.java`. Add the following
    global variables below the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to save the fields when the button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this method to populate the `ListView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following code to `onCreate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by explaining the `DictionaryDatabase` class as that''s the heart
    of an SQLite database. The first item to note is the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice `DATABASE_VERSION`? Only when you make changes to your database schema
    do you need to increment this value.
  prefs: []
  type: TYPE_NORMAL
- en: Next is `onCreate()`, where the database is actually created. This is only called
    the first time the database is created, not each time the class is created. It's
    also worth noting the `_id` field. Android does not require tables to have a primary
    field, except for some classes such as `SimpleCursorAdapter`, require `_id`.
  prefs: []
  type: TYPE_NORMAL
- en: We're required to implement the `onUpgrade()` callback, but as this is a new
    database, there's nothing to do. This method will be called when the database
    version is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: The `saveRecord()` method handles calling `addRecord()` or `updateRecord()`,
    as appropriate. Since we are going to modify the database, both methods call `getWritableDatabase()`
    so we can make changes. A writeable database requires more resources so if you
    don't need to make changes, get a read-only database instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method to note is `getWordList()`, which returns all the words in
    the database using a cursor object. We use this cursor to populate the `ListView`,
    which brings us to `ActivityMain.java`. The `onCreate()` method does the standard
    initialization we''ve seen before and also creates an instance of the database
    with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `onCreate()` method is also where we set up the events to show the word
    definition (with a Toast) when an item is pressed and to delete the word on a
    long press. Probably the most complicated code is in `updateWordList()`.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't the first time we've used an adapter, but this is the first cursor
    adapter, so we'll explain. We use the `SimpleCursorAdapter` to create a mapping
    between our field in the cursor and the `ListView` item. We use the `layout.simple_list_item_1`
    layout, which only includes a single text field with ID `android.R.id.text1`.
    In a real application, we'd probably create a custom layout and include the definition
    in the `ListView` item, but we wanted to demonstrate a method to read the definition
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: We call `updateWordList()` in three places—during `onCreate()` to create the
    initial list, then again after we add/update a list, and lastly when deleting
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though this is a fully functioning example of SQLite, it is still just the basics.
    A whole book can, and has, been written on SQLite for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned previously, when we increment the database version, the `onUpgrade()`
    method will be called. What you do here is dependent on the change(s). If you
    changed an existing table, ideally you'll want to migrate the user data to the
    new format by querying the existing data and inserting it into the new format.
    Keep in mind, there is no guarantee the user will upgrade in consecutive order—so
    they could jump from version 1 to version 4, for example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLite Home Page: [https://www.sqlite.org/](https://www.sqlite.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLite Database Android Reference: [http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access data in the background using a Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any potentially long-running operations should not be done on the UI thread,
    as this can cause your application to be slow or become non-responsive. The Android
    OS will bring up the **Application Not Responding** (**ANR**) dialog when apps
    become non-responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Since querying databases can be time-consuming, Android introduced the Loader
    API in Android 3.0\. A Loader processes the query on a background thread and notifies
    the UI thread when it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two primary benefits to Loaders include:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the database is (automatically) handled on a background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Query auto-updates (when using a Content Provider data source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate a Loader, we will modify the previous SQLite database example
    to use a `CursorLoader` to populate the `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the project from the previous example, *Creating and using an SQLite
    database,* as the base for this recipe. Create a new project in Android Studio
    and call it: `Loader`. Use the default **Phone & Tablet** options and select **Empty
    Activity** when prompted for the **Activity Type**. Copy the `DictionaryDatabase`
    class and the layout from the previous recipe. Though we will use parts of the
    previous `ActivityMain.java` code, we will start at the beginning in this recipe
    to make it easier to follow.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the project set up as described previously, we will start by creating
    two new Java classes, and then tie it all together in `ActivityMain.java`. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class called `DictionaryAdapter` that extends `CursorAdapter`.
    This class replaces the `SimpleCursorAdapater` we used in the previous recipe.
    Here is the full code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create another new Java class and call this one `DictionaryLoader`. Though
    this is the class that handles the data loading on the background thread, it''s
    actually very simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open `ActivityMain.java`. We need to change the declaration to implement
    the `LoaderManager.LoaderCallbacks<Cursor>` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the adapter to the global declarations. The complete list is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `onCreate()` to use the new adapter and add a call to update the Loader
    after deleting a record. The final `onCreate()` method should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We no longer have the `updateWordList()` method, so change `saveRecord()` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement these three methods for the Loader interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default `CursorAdapter` requires a Content Provider URI. Since we are accessing
    the SQLite database directly (and not through a Content Provider), we don't have
    a URI to pass, so instead we created a custom adapter by extending the `CursorAdapter`
    class. `DictionaryAdapter` still performs the same functionality as the previous
    `SimpleCursorAdapter` from the previous recipe, namely mapping the data from the
    cursor to the item layout.
  prefs: []
  type: TYPE_NORMAL
- en: The next class we added was `DictionaryLoader`, which is the actual Loader.
    As you can see, it's actually very simple. All it does is return the cursor from
    `getWordList()`. The key here is that this query is being handled in a background
    thread and will call the `onLoadFinished()` callback (in `MainActivity.java`)
    when it finishes. Fortunately, most of the heavy lifting is handled in the base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This takes us to `ActivityMain.java`, where we implemented the following three
    callbacks from the `LoaderManager.LoaderCallbacks` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreateLoader()`: It''s initially called in `onCreate()` with the `initLoader()`
    call. It''s called again with the `restartLoader()` call, after we make changes
    to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoadFinished()`: It''s called when the Loader `loadInBackground()` finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoaderReset()`: It''s called when the Loader is being recreated (such as
    with the `restart()` method). We set the old cursor to `null` because it will
    be invalidated and we don''t want a reference kept around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the previous example, we need to manually notify the Loader to
    requery the database using `restartLoader()`. One of the benefits of using a Loader
    is that it can auto-update, but it requires a Content Provider as the data source.
    A Content Provider supports using an SQLite database as the data source, and for
    a serious application, would be recommended. See the following Content Provider
    link to get started.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *AsyncTask* recipe in [Chapter 14](ch14.html "Chapter 14. Getting your app
    ready for the Play Store"), *Getting Your App Ready for the Play Store*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a Content Provider: [http://developer.android.com/guide/topics/providers/content-provider-creating.html](http://developer.android.com/guide/topics/providers/content-provider-creating.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
