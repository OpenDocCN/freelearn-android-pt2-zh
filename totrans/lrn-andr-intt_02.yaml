- en: Chapter 2. Introduction to Android Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Revising the previous lesson—Android Activity is the visual representation of
    controls, widgets and many other things with which the user interacts. An Android
    application is a combination of many activities which interact with each other
    in order to perform a single or multiple tasks for which the application is dedicated
    to. Mostly, there is only a single activity that is shown on the screen at a particular
    time. Some actions (like button tap or a gesture) may result in navigating from
    the current activity to a new one on the top of the Activity Stack.
  prefs: []
  type: TYPE_NORMAL
- en: Android Intents help developers to perform interaction between two activities,
    yet this is not the only thing that an intent does. This interaction includes
    moving from one activity to another, pushing data from one activity to another
    and bringing results after the closure of any particular activity. In short, it
    can be said that intent is an abstract term in android referring to any task that
    is to be performed. There are various other things which will be explored with
    the passage of time as you read through this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in an Android Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intent – a technical overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of an intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concepts of Android Activity, Activity Lifecycle, and Activity Stack, as
    discussed in the previous chapter, are the prerequisites for understanding this
    chapter and the chapters ahead. If you don't have the basic concept of these things,
    we would recommend that you read [Chapter 1](ch01.html "Chapter 1. Understanding
    Android"), *Understanding Android*, in order to move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in an Android Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see what the scope of Android Intents is. Till now,
    we have a complete view of why the activities are required and why it is necessary
    to maintain and trace the flow from one activity to another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in an Android Application](img/9639_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Navigation between different activities on button tap (using intents) and its
    representation by an activity stack
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be said that this portion of the book is the summary of the benefits
    that we can take from the Android Intents. The scope lies in the various factors
    of Android Activities, services, data transfer, and many other things. We will
    see this in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Activity transition from one activity to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer from one activity to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making connection with Wi-Fi and Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Android Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPS sensor to get current location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending SMS and MMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing mobile calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mails and social media posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and controlling Android Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling broadcast messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification bar alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now take a look at each of the key roles of Android Intents. A short
    description on these main features of Android Intents is given in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in Android Activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important and extensive use of intents can be seen in Android Activities.
    The Android Application consists of many activities and to transit between those
    activities, we need to use Android Intents. In the previous figure, you can see
    that in **Activity 1** (on the left-hand side) when the content is filled and
    the user taps the **Enter Data** button, Android will use an intent to navigate
    to the **Activity 2** (on the right-hand side).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the previously mentioned role of intent, it can also be used to call
    other applications such as a browser (with a certain website from your activity)
    and an e-mail client (such as Gmail or any other with proper subject and e-mail
    body from the activity, by sending it in a bundle).
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in data transfer between activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is now clear that we use intents to navigate from one activity to another.
    But as we all know the huge role of data in an Android Application, where the
    user needs to fetch, manipulate, and show data in order to perform a certain task.
    The handling of that data and its secure transfer from one activity to another
    is yet another purpose of Android Intents.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous figure, once the user has filled the form in Activity 1, on
    tapping the **Enter Data** button, intents will perform two tasks. One task is
    to take the user from one activity to another and second task is to transfer the
    filled data to the next activity in order to show/calculate the result.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in Wi-Fi and Bluetooth transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While inside the application, if you want to implement a feature which gives
    a facility to change the current Wi-Fi/Bluetooth connection, you need to use Android
    Intents. With Android Intents, you can easily provide the internal interface which
    will let the user switch between the Wi-Fi and Bluetooth connection while remaining
    inside the application.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in Android Camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android hardware can be of a huge importance when you talk about Android Application.
    The use of these components can be a fundamental part of your Android Application.
    Suppose the example of a 1D or 2D bar code reader, the application needs to scan
    the bar code and decode it in order to extract the information. This action can
    only be performed by opening the camera from inside the application. The opening
    of camera is also handled by Android Intents.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in GPS Sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android Application market is doing marvel in many categories. Various kinds
    of Android Applications are present in the market today, this includes location-based
    applications which perform various tasks by tracking the location of the user.
    Through intents a developer can easily extract the current location of the user
    as required for calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in sending SMS/MMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Intents can be used in order to enable your application for sending
    SMS/MMS. This task can be done by setting the SMS/MMS body from your activity
    and set it in bundle to call the native built-in application for sending SMS/MMS
    of the mobile. This SMS/MMS sending functionality can then be enhanced by implementing
    a Broadcast Receiver, which enables your activity to know when the message was
    sent or when it was delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in Mobile Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any condition that will initiate a mobile call in an application can be fulfilled
    by Android Intents. The Android Application will use the built-in application
    to start the call to any particular number that will be provided in the form of
    data in an intent.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in e-mail and social network posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing Gmail to send e-mail from your application is managed by Android Intents.
    There is an intent call in which we put the recipient's e-mail, attachments, body,
    and subject of the e-mail and start the intent on the activity. This will open
    the native Gmail application with those parameters filled and the user can send
    this to the desired recipient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can send various social network updates such as Facebook, Twitter,
    and Google+ through an intent. This task is done using Share Intent. We put the
    content in the form of text or bundle and send it via Android Intent. Android
    then opens all the available sharing applications (as shown in the previous figure)
    and gives access to the user in order to pick the best application for sharing.
    The only condition is that there should be a preinstalled application through
    which the Android Intent interacts and sends the desired post is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Intent does not disclose any other feature of social networking apart
    from posting on the wall or tweeting it to the timeline. To observe the complete
    set of features there are many third party APIs present on the Internet as free-license
    software or paid.
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in e-mail and social network posts](img/9639_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using intent to share posts on various platforms using Share Intents
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows what happens when you give a functionality to the
    user and for example, the user wants to share it via Gmail. In this case, the
    screen appears with your content in it and will look as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intents in e-mail and social network posts](img/9639_02_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gmail interface after passing the data from Share Intent
  prefs: []
  type: TYPE_NORMAL
- en: Role of intents in Android Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Same as Android Activity, intents are used to initiate **Android Services**.
    Android Services are basically the long-running tasks done by the Android Application
    without affecting the user interface. This background task can continue running
    even after the user switches the application. In other words, services can or
    cannot be bound from the activity. The services can work independently in order
    to perform a task. However in each case, an intent is used to initiate the services.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intent in Broadcast Receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intent has a wide usage with Broadcast Receiver. Broadcast Receiver is used
    to respond to the broadcast messages initiated by any other application or even
    the system. In this context, we catch the Android message and extract the data
    in order to show it in our application. For example, `Intent.ACTION_BOOT_COMPLETED`
    is used when we need to receive a signal when the system boot is completed. Similarly,
    many other intent values and intent objects can be used at different points of
    application in order to perform various tasks related to Broadcast Receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Another example can be sending the SMS/MMS where you can make a Broadcast Receiver
    in order to see whether the sending is completed or the message is delivered or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intent in time zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible that your application might do something that is related to the
    time zone. Once the time zone has changed while you are traveling, you want your
    application to behave differently. In such cases, we can use Broadcast Receiver
    to detect the change of the time zone, get data from the intent in order to access
    the current time zone, and perform a certain task. This is a very handy way to
    maintain your application structure and data according to your time zone.
  prefs: []
  type: TYPE_NORMAL
- en: Role of intent in Status Bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Status Bar is used to provide instant notification to a user without
    occupying too much space on the screen. The notification panel that slides from
    top to bottom has many features in it, such as some quick access items like wireless
    connection manager (currently available in few mobile phones only) and other things.
    We can put a notification in that bar in order to inform the user about anything.
    Android Intents are used in order to place the content and provide a status bar
    notification in it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Role of intent in Status Bar](img/9639_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Notification Panel and Notifications
  prefs: []
  type: TYPE_NORMAL
- en: Intent – a technical overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been through the theoretical overview of Android Intents in the past
    couple of topics. Let's take a deeper look at the technicalities of this feature
    of Android. In this portion, we will see the bigger picture of Android Intents
    which includes the example code and its explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, Android Intent consists of two components and both of them work
    independently. These two components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Coding component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XML component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Coding component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Intents are implemented in the Java code while writing a class. Normally
    in an Android project, we have a separate package for handling the activities.
    As it was mentioned earlier, in order to put a complete trace of application,
    there is an `AndroidManifest.xml` file in which the record of every activity,
    service, permission, and other things should be included.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While implementing the code, we need to take care that all of the activities
    should be declared in the `AndroidManifest.xml` file in order to access them from
    the code. Otherwise, Android will throw an error of `ActivityNotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of Android Intents for activities, services, and Broadcast
    Receivers is the same. While implementing Android Intents in an activity, we need
    to take care of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the `android.content` package before implementing the intent (this
    is the parent package of Android in which the intent class is present).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intent constructor should be under the context of Android Activity. If not,
    it should have the object of context in order to determine on which activity the
    intent is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination activity class should be imported (if it is under any other
    package of the source activity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only call the `startActivity()` method if the intent is in the context
    of Android Activity or if the context of that source activity is present in the
    context object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XML component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second and the most important component on which the intent depends is in
    the `AndroidManifest.xml` file. Giving a recap about what this file includes—`AndroidManifest`
    is the file which contains all the information regarding the application. It contains
    all names of activities, services, permissions, version codes, sdk versions, and
    many other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are Intent Filters that are also mentioned inside this file.
    At this time, we just want to cover the main use of Intent Filters. The brief
    introduction of an Intent Filter can be found in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Intent Filters have some conditions that have to be fulfilled in order to process
    the Android Intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intent Filters have additional information regarding the data and category of
    the Android Intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shorter definition may be that an Intent Filter describes how the Android
    System will identify what behavior to adopt on a certain Android Intent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can include many Intent Filters inside a single activity in `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous code, it is clearly mentioned that the tags of `<intent-filter>`
    contain the information regarding the category and the action. These tags are
    an essential part of the activity in `AndroidManifest` when the application tries
    to do a task which is unknown to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why `<category>` appears in the previous code of an Intent Filter,
    take an example: we make an application in which there are two activities. If
    we do not mention to the system which is the first activity to start the application
    with; the system will get confused and show the error `No Launcher Activity Found`
    and it will not start the application. So, in order to achieve this task, we need
    to put the category of any of the one activity as `android.intent.category.LAUNCHER`.
    This will help the system to recognize the base activity from which the application
    starts and the flow continues.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of Android Intents for Activity Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the implementation of the Android Intent.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: In order to start this example, you need to build an Android project. You can
    use Android Studio or Eclipse (as per your convenience) but make sure that if
    you are using Eclipse, you should have correctly installed JDK, ADT, and the Android
    SDK, along with their compatibility packages. If you don't know the difference
    between these IDEs, you can refer to [Chapter 1](ch01.html "Chapter 1. Understanding
    Android"), *Understanding Android*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in Android Studio was covered in the previous chapter. Repeating
    those steps will help you to create a complete Android project with some predefined
    files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get started with the implementation of Android Intents, you need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android project or choose any existing project in which you want
    to implement Android Intents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the source activity in which you want to implement the intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Just a reminder that intents are called when there is an event-call taking place
    in an activity. For example, on tapping the button, the next activity should appear.
    So the button-tap is the event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the following code in order to achieve this result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project and a button will appear. Tap the button in order to navigate
    to the next activity through intents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Implementation of Android Intents for Activity Navigation](img/9639_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Indicates the flow of application from the first activity to the second activity
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous code is described in five parts; we will describe them one by one.
    Keep in mind that these parts are referring to five different files in the Android
    project. Knowing the fact that you will use this code inside a predefined project,
    we will describe it from the scenario of a newly created project in order to make
    it elaborative and clear.
  prefs: []
  type: TYPE_NORMAL
- en: Part one – MainActivity.java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MainActivity.java` is the first class that is made while creating a project.
    Since it is an Android Activity, it comes with an `onCreate` method which is called
    once the activity has been created (as discussed in [Chapter 1](ch01.html "Chapter 1. Understanding
    Android"), *Understanding Android*, *Android Activity Life Cycle*). The layout
    attached with this Activity is named as `activity_main.xml`. Hence in the `onCreate()`
    method, the line `setContentView(R.layout.activity_main)` refers to that XML and
    is used to set the view of that activity in accordance with the layout present
    in `activity_main.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the second step, the button present in the `activity_main.xml` layout
    with the ID of `button1` is fetched in the code by using the `findViewById(int
    id)` method present in the `Activity` class. It will return the object of the
    `View` class, so we can easily cast it over the button in order to have a button
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Once the button object is extracted, we implement the `setOnClickListener()`
    method on it. The `setOnClickListener()` method belongs to the `View` class which
    takes an argument of `View.OnClickListener` (an interface). This interface requires
    us to override the `onClick()` functionality to be implemented. This event is
    triggered whenever the button is tapped in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `onClick()` method, the real implementation of intent will take
    place. Since we want to call our intent on tapping the button, we will do all
    of the stuff related to the intent in this method. Declare the intent object with
    the constructor taking the argument of context and the destination class. The
    `MySecondActivity.class` file is the destination activity on which we want to
    navigate while we are accessing the context of the current activity by taking
    `MainActivity` (or you can use the `getContext()` method which basically returns
    the same context of the activity). This is because we are currently in the context
    of `OnClickListener`.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment we have the object of intent. We could do much more with this
    object but at the moment, our task is to only navigate it to the next activity.
    This is why we call the method `startActivity`() and pass this intent as an argument.
    This will navigate the application to the next activity which will appear from
    the top in the activity stack, while the previous activity will go underneath
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Part two – MySecondActivity.java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The activity `MySecondActivity.java` is the destination activity for the intent.
    This is the simple activity which contains an `onCreate()` method which is setting
    the content view on the screen. Just after the creation of the layout, we are
    showing a toast message on the screen through the `show()` method in order to
    recognize that the second activity has been loaded and is displaying the message
    `The intent has been called`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A toast message is a simple message which appears in a box for a few seconds
    and goes away. By default, this message contains text, but one can easily make
    a custom toast in order to include pictures and many other things.
  prefs: []
  type: TYPE_NORMAL
- en: Part three – activity_main.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This XML file is the layout for the `MainActivity.java` class. As you can see,
    we tried to bring the reference of the button from the layout. That button is
    declared inside this `activity_main` file with the ID used to extract it from
    the XML.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The references of all the layouts declared in the XML files are put inside the
    R file, which is used by the Java code/classes to get the object in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the `activity_main.xml` file, there is a Linear Layout with certain
    parameters regarding its length, width, and orientation. Inside the tags of Linear
    Layout, you can see that the button which is brought into the code of Java is
    declared. This tag also comes with certain parameters about height, width, ID,
    and text that will appear in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take precautionary measures in order to give the ID to any view. All of these
    IDs are present in the R file which handles everything inside a single class.
    Try to customize your ID in order to avoid confusing the view of one activity
    with that of another.
  prefs: []
  type: TYPE_NORMAL
- en: Part four – activity_two_layout.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a simple layout file containing the parent Linear Layout in order to
    make a simple blank activity. This layout file is assigned to the second activity
    on which the intent brings the user after tapping the button and on which the
    toast message is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Part five – AndroidManifest.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No project is complete without the `AndroidManifest.xml` file because it contains
    all the information regarding the application. In this XML file, there is a parent
    tag of manifest which contains the three most important properties regarding the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Name**: This is the name of the project from which the application
    will go to Google Play (or any other market). This name should be uniquely defined
    for the whole application and it should not match any other package name in the
    market.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Code**: This is an integer value which represents the version number
    compared to the previous version of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Name**: This is a string value which is used to display for the user.
    It is the release version name of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `Manifest` tag, there is a tag named `<uses-sdk>` which, in its attributes,
    defines the minimum and maximum API version of Android on which the application
    is accessible. After this there is an application tag in which the information
    related to application is stored which contains icon, label, and theme for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the main tag, which describes the activities in an application, there are
    the `<activity>` tags. It should be equal to the number of activities used in
    the application. As you can see the XML component of intent is present in the
    first activity, namely `<intent-filter>`, which is telling the system that `MainActivity.java`
    is the class that should be used as a Launcher Activity. Unlike the first activity,
    the second activity does not contain the tag for Intent Filter. You can analyze
    that there is no need for the second activity to contain those tags because it
    is in the flow with the first activity.
  prefs: []
  type: TYPE_NORMAL
- en: From the first activity, the second activity should come on the foreground intent.
    That is why there is no need for it to contain the tags `<category>` and `<action>`.
    The application will work fine without it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Future considerations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will see in detail what more we can do with intents in this book. Till now
    we have only covered the basic intent functionality with its flow in the activity
    stack. You will encounter a lot of content on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Other constructors of the android.content.Intent class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Intent class comes with a variety of constructors which help developers
    in various scenarios. In the previous section, we used only one type of constructor.
    Other polymorphic forms of the constructor are also available on Google.
  prefs: []
  type: TYPE_NORMAL
- en: Various kinds of constructors are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Intent()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the default constructor which returns an empty intent object. However,
    by empty it does not mean that it is a null object.
  prefs: []
  type: TYPE_NORMAL
- en: Intent(intent o)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This constructor is used to make a clone of an existing intent. We pass the
    intent object which we want to clone and put it in the argument of the constructor.
    In this condition, the intent returned is the copy of the original one. It will
    also map each and every value (extras) put in the original one and returns a copy
    of that intent.
  prefs: []
  type: TYPE_NORMAL
- en: Intent(Context c, Class<?> cls)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the constructor that we used in our example before. It basically takes
    two arguments: a source context and the destination class. The source context
    is the context of the activity you are currently using, while the second parameter
    is the class to which you want to navigate to.'
  prefs: []
  type: TYPE_NORMAL
- en: Intent(String action)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The constructor with the action is used to make an intent object in which the
    action is written. The proper use and definition of the action, as used in intents,
    will be covered in the upcoming chapters. Also keep in mind that this constructor
    is used to broadcast actions.
  prefs: []
  type: TYPE_NORMAL
- en: Intent(String action, URI uri)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This constructor is used to create an intent with the desired action as well
    as some data URL. For example, we pass the argument `new Intent(Intent.ACTION_VIEW,
    Uri.parse("http://www.google.com"));`. The constructor clearly means that the
    intent will facilitate the action that is used for viewing and with the other
    parameter, we are parsing the URI of the URL [http://www.google.com](http://www.google.com).
    This will open the browser in which Google''s website will be loaded. Take another
    example of this constructor: `new Intent(Intent.ACTION_DIAL, Uri.parse("tel: (+1)
    123456789"));`. By writing this statement, we are clearly mentioning that we want
    to make an intent which is used to activate the phone dialer and pass the value
    of URI in order to perform the call function through intents.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This form of constructor is mostly used for calling implicit intents. More information
    about the code can be found at [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting results from Android Intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen previously, Android Intents were used to navigate from one activity
    to another but in real scenarios there are many things that are required with
    this navigation. One of the most important features of Android Intents is going
    to be discussed here. What we will see here is the response that the source activity
    will get once the destination activity is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further explain the previous statement, we have a scenario in which:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a source activity (from which the navigation will start)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destination activity (to which the navigation will be done)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the closure of the destination activity, it will return a result back to
    the source activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very handy option in Android Intents for bringing back the result
    from an activity. We will discuss this feature in a great detail with an example
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding with an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will look at the scenario in which there are two activities.
    Activity one will be used as the launcher activity. Activity two will be used
    as the destination activity which will also return some result back to the first
    activity. The first activity will catch the result and on the basis of that code,
    it will decide what kind of task was finished or failed in the second activity.
    In the end some dialog message will be shown on the first activity in accordance
    with the result that is given back.
  prefs: []
  type: TYPE_NORMAL
- en: Going deep into the example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again, the following code is in five parts. It is the modification of the last
    example in which the normal use of intents was described. In order to implement
    this example, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project or open any existing project in which you want to make
    the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the source activity in which you want to implement the intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project and a button will appear. Tap the button in order to navigate
    to the next activity through intents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successful execution of the intent, the new activity will appear. Click
    on the back key of the emulator or Android phone on which you are testing and
    the system will bring you back to the first activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After coming back to first activity it will show the toast in order to communicate
    the result from the destination activity.![Going deep into the example](img/9639_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indicates the flow of application from the first activity to the second activity
    and getting the result back to the first activity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explaining the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, as mentioned before, we will understand how to get back the
    result in order to verify (on the first activity) whether the task performed in
    the second activity is successfully done or not.
  prefs: []
  type: TYPE_NORMAL
- en: Before going further, keep in mind that this is an extension of the previously
    defined example; so the things that we went through previously will not be explained
    in this example. Kindly read the previous example if you find anything difficult
    in here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Part one – MainActivity.java
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to before, this is the first activity from which the navigation will
    start on tapping the button. Most part of this activity is same as that of the
    previous example, but if you take a deeper look, you will notice that the `startActivityForResult()`
    method is used in order to start the activity. That is because the activity that
    we are starting will return a result after the second activity is closed.
  prefs: []
  type: TYPE_NORMAL
- en: The `startActivityForResult()` method has two arguments. First is the intent
    which is similar to that of the `startActivity()` method described before. Let's
    check out what the second argument is. Take a scenario where the first activity
    invokes more than one activity which will return some result. Now at the time
    of catching that result, we need to be sure which activity it is coming from.
    So this is why we assign a request code which will return the result when the
    intent gets back the user to the first activity. We will then put a check to know
    which activity the result is coming from.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, if you look carefully in the code, there is an overridden method
    named `onActivityResult()`. This method will be called when the closure of the
    second activity occurs. It has three arguments as you can see in the code. The
    first is `requestCode` which will be in accordance to the activity which is sending
    the result back. Apart from that we have `resultCode` which will tell whether
    the task in the second activity was performed successfully or not. Thirdly, we
    have an intent which is basically the object which is causing the activity to
    move back to the first one. We can also send some data back to the first activity
    through this intent.
  prefs: []
  type: TYPE_NORMAL
- en: Part two – MySecondActivity.java
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is same as the first example; rather, it carries two objects of check boxes
    in the layout file and these are used to make a result in the second activity.
    We find the view using the ID and on the basis of the selected check box, we see
    which one is enabled. When the button is pressed, it will see which check box
    is enabled and on the basis of the enabled priority, it calls the `setResult()`
    function. This function sets a result to the intent which will help the activity
    to move back to the first activity.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the result, we will finish the second activity and it will move
    back to the first activity with the result. Just after the activity has finished,
    the `onActivityResult()` method from the first activity will be executed in order
    to see the result which is sent by the second activity.
  prefs: []
  type: TYPE_NORMAL
- en: Part three – activity_main.xml
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This part of the code is similar to the first example; kindly refer to the first
    example for an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Part four – activity_two_layout.xml
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This layout file refers to the second activity. We have put two checkboxes,
    on the basis of which it will be decided which result is to be sent back to the
    first activity. There are some attributes that are the same as the ones in the
    previous example and hence, that example can be referred to.
  prefs: []
  type: TYPE_NORMAL
- en: Part five – AndroidManifest.xml
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Again, this file is untouched and is same as the first example. Kindly refer
    to the first simple example of intent.
  prefs: []
  type: TYPE_NORMAL
- en: Future considerations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two scenarios which we can focus on as a future consideration. The
    first is how two or more activities can be handled while all of them are sending
    the result back. This is of course with the help of the `requestCode` argument.
    The second most important thing is, in the scenario where we are sending back
    only the response code, there might be a need to also send back some strings,
    int values, or some custom objects as a result. In that case, we will need some
    other methods to send those objects back to the first one via intents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Data Transfer Using Intents"), *Data Transfer
    Using Intents*, we will have a complete look into how we can transfer different
    kinds of data inside an intent.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of an intent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will study the structure of an intent object as used in
    Android. An intent is the bundle of information in which there are multiple things
    to facilitate. It has information about the actions that should be taken while
    the intent is executed. Similarly, it also has information about the category
    which is going to handle the intent. Data plays a vital role in intents. So an
    intent has information of the data in the form of a URI that has to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Due to limited space here, we cannot explain every constant in every component.
    In order to get a complete list of constants that Android uses, you can take a
    look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We will now go through each one of the components in order to see what they
    really mean.
  prefs: []
  type: TYPE_NORMAL
- en: Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will explain which component will get affected or handle the execution
    of a particular intent. For example, there is an intent that is responsible for
    making an action which is related to the activity in which it is called. Similarly,
    there is an intent which is handled by Broadcast Receiver and reports when a certain
    system-related task is performed. If the component name is not set, it will self-recognize
    the component with other information. The following table shows the different
    kinds of components that are used in Android Intents:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constants | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_BROWSABLE` | Describes that the intent can be safely executed by
    the browser to display the data. |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_LAUNCHER` | Tells that the activity should be executed as the launcher
    while the application starts. |'
  prefs: []
  type: TYPE_TB
- en: '| `CATEGORY_GADGET` | The activity can be put inside another activity that
    starts from any gadget. |'
  prefs: []
  type: TYPE_TB
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions basically state what action this intent will cause. For example, if
    we initiate an intent object with the action named `ACTION_CALL`, this intent
    will start the call functionality with the data string passed with the `ACTION_CALL`
    action in the form of URI. Taking another example of `ACTION_BATTERY_LOW`, which
    is related to the Broadcast Receiver component. By placing this action in the
    Intent Filter, it will fire the event (or in short a low battery pop-up) if the
    battery goes lower than that of the threshold value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various kinds of actions present in Android. The following table
    shows some of the intent actions and their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constants | Component | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_CALL` | Activity | Start the phone call |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_EDIT` | Activity | Display the data of the user to edit |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_MAIN` | Activity | Start as the initial activity with no data |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_SYNC` | Activity | Sync the data present on the server with the mobile
    device |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_BATTERY_LOW` | Broadcast Receiver | Shows the battery low warning
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_HEADSET_PLUG` | Broadcast Receiver | Shows an alert when the headset
    is plugged in or unplugged |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_SCREEN_ON` | Broadcast Receiver | Triggered when the screen is turned
    on |'
  prefs: []
  type: TYPE_TB
- en: '| `ACTION_TIMEZONE_CHANGED` | Broadcast Receiver | When the setting of the
    time zone is changed |'
  prefs: []
  type: TYPE_TB
- en: Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This should not be considered as the separate component; rather, it is used
    to facilitate the action component. As described previously, there are certain
    components which require some data to be passed. For example, the `ACTION_CALL`
    function requires a data value by which it recognizes on which telephone number
    calling should be performed. In this particular scenario, we need the `tel: xxxxxxxxxxx`
    URI to be put in the data and forwarded to the action. Similarly, when the `ACTION_EDIT`
    or `ACTION_VIEW` actions are performed, they need to be provided with a document
    or a HTTP URL in order to complete the action. The data is given to the intent
    in the form of **URI** (**Universal Resource Identifier**).'
  prefs: []
  type: TYPE_NORMAL
- en: Extras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are basically the key-value pairs of the additional data that is required
    by the Android Intent. We can take these values from the code (when we make an
    object of the intent) and transfer that data to the next activity. Talking with
    respect to the actions, there are some actions which require additional data to
    fulfill the task. For example, the `ACTION_TIMEZONE_CHANGED` action needs an extra
    time zone which describes the new time zone on the basis of which further tasks
    can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the introduction of intents with its role, technical
    overview, the basic implementation in an Android Application, and the structure
    of intent based on which, we will further explore different kinds of tasks that
    can be performed. The chapter also provides two very important implementations
    of Android Intents in which the navigation from one activity to another took place,
    while in the second one, the result corresponding to any particular activity is
    sent back to the first activity. The concept discussed in this chapter is the
    key tool to understand the advanced concepts of Android Intent which will be discussed
    later in this book. In the next chapter, we will learn about the categorization
    of Android Intents and its Its theory and implementation in the light of various
    handy examples which can be implemented easily in your Eclipse environment.
  prefs: []
  type: TYPE_NORMAL
