- en: 'Chapter 5. Rich Media Presentation: Working with Images, Video, and Audio'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 富媒体展示：处理图像、视频和音频
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下食谱：
- en: Loading photographs from the device cameraRoll
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备cameraRoll加载照片
- en: Applying Pixel Bender Shader effects to loaded images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Pixel Bender着色器效果应用于加载的图像
- en: Playing video files from the local file system or over HTTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地文件系统或通过HTTP播放视频文件
- en: Playing remote video files over RTMP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过RTMP播放远程视频文件
- en: Playing audio files from the local file system or over HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地文件系统或通过HTTP播放音频文件
- en: Generating an audio spectrum visualizer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成音频频谱可视化器
- en: Generating audio tones for your application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序生成音频音调
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: This chapter will include a variety of recipes for the display of image data
    and playback of both video and audio streams. Included among these recipes are
    examples demonstrating the ability to load images from the device camera repository,
    applying Pixel Bender Shaders to loaded images, the playback of audio and video
    over different protocols, as well as the generation of visual data from sound
    and the generation of raw sound data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将包含多种展示图像数据和播放视频及音频流的食谱。这些食谱中包括的例子演示了从设备相机库加载图像的能力，对加载的图像应用Pixel Bender着色器，通过不同协议播放音频和视频，以及从声音生成视觉数据和原始声音数据。
- en: The Flash platform is well known as the premiere video distribution platform
    worldwide. In the following pages, we will see that this experience and reach
    is in no way confined to desktop and browser-based computing. With new features
    such as StageVideo available in AIR 2.6 and Flash Player 10.2, Flash is becoming
    an even stronger platform for delivering video while preserving device battery
    life and providing a better user experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Flash平台作为全球领先的视频分发平台而闻名。在以下几页中，我们将看到这种体验和影响力绝不仅限于桌面和基于浏览器的计算。随着AIR 2.6和Flash
    Player 10.2中提供的StageVideo等新功能，Flash正在成为在保持设备电池寿命的同时提供更佳用户体验的更强大的视频交付平台。
- en: Loading photographs from the device cameraRoll
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从设备cameraRoll加载照片
- en: The Android operating system has a central repository for storing photographs
    captured by the variety of camera applications a user may have installed. There
    are APIs within AIR for Android, which allows a Flash developer to specifically
    target and pull from this repository for display within an application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓操作系统有一个中央存储库，用于存储用户可能安装的各种相机应用程序捕获的照片。AIR for Android中提供了API，允许Flash开发者专门针对这个存储库进行操作，并在应用程序中显示。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We must use the mobile `CameraRoll` API to browse directly to the device camera
    roll and select a photograph for display:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用移动`CameraRoll` API直接浏览到设备相机胶卷，并选择一张照片以显示：
- en: 'First, import the following classes into your project:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `CameraRoll` object and a `Loader`, which will be used to display
    the photograph, once selected:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`CameraRoll`对象和一个`Loader`，用于在选定照片后显示照片：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create our `Loader` object, add it to the `Stage`, and register an
    event listener to properly scale the photo once it has been loaded:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建我们的`Loader`对象，将其添加到`Stage`中，并注册一个事件监听器，以便在照片加载后适当缩放：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the `CameraRoll` itself, all we need to do is instantiate it and then add
    an event listener to fire once the user has selected a photograph to display.
    We should always check to see whether the device supports `CameraRoll.browseForImage()by`
    checking the `supportsBrowseForImage` property:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`CameraRoll`本身，我们需要做的就是实例化它，然后添加一个事件监听器，以便在用户选择要显示的照片时触发。我们应该始终检查设备是否支持`CameraRoll.browseForImage()`，通过检查`supportsBrowseForImage`属性：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will now register a `TouchEvent` listener of type `TOUCH_TAP` to the `Stage`.
    This will enable the user to invoke a browse dialog in order to select a photograph
    from the `CameraRoll` by tapping the device screen.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在`Stage`上注册一个类型为`TOUCH_TAP`的`TouchEvent`监听器。这将使用户能够通过轻敲设备屏幕来调用浏览对话框，从`CameraRoll`中选择照片。
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT`
    constant in order for our application to accept touch events.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量，以便我们的应用程序接受触摸事件。
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the following method is invoked from a user interaction, we can invoke
    the `browseForImage()` method upon the `CameraRoll` object we had set up earlier.
    This will open the default gallery application on an Android device and allow
    the user to select a photograph from their collection. If there is more than one
    gallery application on the device, the user will first choose which one to use
    for this event through a native Android dialog. Our application will lose focus
    and this will be handled by the operating system, returning to our application
    once a selection is made.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦从用户交互中调用了以下方法，我们就可以对我们之前设置的`CameraRoll`对象调用`browseForImage()`方法。这将打开Android设备上的默认图库应用，允许用户从他们的收藏中选择一张照片。如果设备上有不止一个图库应用，用户将首先通过一个原生的Android对话框选择在这个事件中使用哪一个。我们的应用将失去焦点，这由操作系统处理，一旦做出选择，就会返回到我们的应用。
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see the default gallery application on Android. A user can spend
    as much time as they wish browsing the various collections and photographs before
    a selection is made.![How to do it…](img/1420_05_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Android上的默认图库应用。用户可以在做出选择之前花尽可能多的时间浏览各种收藏和照片。![如何操作…](img/1420_05_01.jpg)
- en: When the user has performed a valid selection in the native Android gallery
    application, focus returns to our application and an event containing a `MediaPromise`
    object is returned. The `Loader` class has a specific method called `loadFilePromise()`
    specifically for this sort of thing. We will now pass the `MediaPromise` through
    this method.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在原生的Android图库应用中进行了有效的选择后，焦点将返回到我们的应用，并返回一个包含`MediaPromise`对象的事件。`Loader`类有一个特定的方法`loadFilePromise()`，专门用于这类操作。现在我们将`MediaPromise`通过这个方法传递。
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we've passed the `MediaPromise` object through the `Loader` using `loadFilePromise()`,
    it will load up onto the `Stage`. We will perform one more action here to adjust
    the `Loader` size to fit within the constraints of our `Stage:`
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们使用`loadFilePromise()`将`MediaPromise`对象传递给`Loader`，它将被加载到`Stage`上。在这里，我们将执行一个额外的操作，调整`Loader`的大小以适应我们的`Stage`的约束条件。
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The resulting image, when loaded upon the `Stage`, will appear as follows:![How
    to do it…](img/1420_05_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载到`Stage`上的结果图像将如下所示：![如何操作…](img/1420_05_02.jpg)
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The ActionScript `CameraRoll` API specifically targets the on device storage
    location for photographs on Android. Whenever a user performs some interaction
    that invokes a `CameraRoll.browseForImage()` method in our application, the default
    Android gallery application will launch, allowing the user to select an image
    file from within their collection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ActionScript的`CameraRoll` API专门针对Android设备上的照片存储位置。每当用户进行一些交互，调用我们应用中的`CameraRoll.browseForImage()`方法时，默认的Android图库应用将启动，允许用户从他们的收藏中选择一个图像文件。
- en: Once the user has selected a photograph from the gallery application, they will
    be returned to our AIR for Android application along with a `MediaPromise` object
    with which we can ascertain certain information about the file, or even load the
    photograph directly into our application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户在图库应用中选择了照片，他们将被返回到我们的AIR for Android应用，并带有一个`MediaPromise`对象，通过这个对象我们可以确定文件的一些信息，甚至可以直接将照片加载到我们的应用中。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In this example, we examine how to load an image from the `CameraRoll` into
    a `Loader` on the `Stage`. There are, of course, many things we could do to the
    photograph once it has been loaded up. For an example of this, have a look at
    the next recipe: *Applying Pixel Bender Shader effects to loaded images*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们探讨了如何从`CameraRoll`将图像加载到`Stage`上的`Loader`中。当然，一旦照片被加载，我们可以对它进行很多操作。关于这方面的例子，请看下一个食谱：*对已加载的图像应用Pixel
    Bender着色器效果*。
- en: Applying Pixel Bender Shader effects to loaded images
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对已加载的图像应用Pixel Bender着色器效果
- en: Once we load a visual object into our application, as this is all Flash-based,
    we can do all sorts of robust visual manipulation. In this example, we will load
    a preselected photograph from the local file system, and then apply a variety
    of Pixel Bender Shaders to it, drastically changing its appearance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将视觉对象加载到我们的应用程序中，由于这一切都是基于Flash的，我们可以进行各种强大的视觉操作。在这个例子中，我们将从本地文件系统加载一个预先选择的照片，然后对其应用各种Pixel
    Bender着色器，极大地改变它的外观。
- en: Getting ready…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: This recipe makes use of Pixel Bender Shaders. You can download `.pbj` files
    from the Adobe Exchange or create your own.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱使用了Pixel Bender着色器。你可以在Adobe Exchange下载`.pbj`文件，或者创建自己的文件。
- en: If you decide to write your own Pixel Bender kernels, you can download the Pixel
    Bender Toolkit for free from [http://www.adobe.com/devnet/pixelbender.html](http://www.adobe.com/devnet/pixelbender.html)
    and use it to compile all sorts of shaders for use in Flash and AIR projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定编写自己的 Pixel Bender 内核，可以从[http://www.adobe.com/devnet/pixelbender.html](http://www.adobe.com/devnet/pixelbender.html)免费下载
    Pixel Bender 工具包，并使用它编译各种着色器，以便在 Flash 和 AIR 项目中使用。
- en: The toolkit allows you to write kernels using the Pixel Bender kernel language
    (formerly known as Hydra) and provides mechanisms for image preview and separate
    property manipulation that can be exposed to ActionScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具包允许你使用 Pixel Bender 内核语言（以前称为 Hydra）编写内核，并提供图像预览和分离属性操作的机制，这些可以暴露给 ActionScript。
- en: '![Getting ready…](img/1420_05_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪…](img/1420_05_03.jpg)'
- en: For a good resource on writing Pixel Bender Shaders, check out the documentation
    located at [http://www.adobe.com/devnet/pixelbender.html](http://www.adobe.com/devnet/pixelbender.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解关于编写 Pixel Bender 着色器的良好资源，请查看位于[http://www.adobe.com/devnet/pixelbender.html](http://www.adobe.com/devnet/pixelbender.html)的文档。
- en: In this recipe, we are also referencing a photograph that exists within the
    Android image gallery, which we previously captured with the default camera application.
    You may do the same, or simply bundle an image file along with the application
    for later reference.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们还引用了 Android 图像库中存在的照片，我们之前使用默认相机应用程序捕获的。你可以做同样的事情，或者将图像文件与应用程序一起打包以便后续引用。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will now load a predetermined image from the local device storage and apply
    multiple Pixel Bender Shaders to it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从本地设备存储中加载一个预定的图像，并对其应用多个 Pixel Bender 着色器：
- en: 'First, import the following classes into your project:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this recipe, we must declare a number of different objects up front. We
    will declare a `String` constant to hold the path to our image and a `Loader`,
    which will be used to display the photograph. A `URLRequest` and `URLLoader` object
    pair will be used to load in our `.pbj` files. The `Array` will be set up to hold
    the names of each `.pbj` we will be loading. An `int` is employed to keep track
    of the shader we have currently loaded from our `Array` set. Finally, a `Shader`
    and `ShaderFilter` pair are declared to apply the loaded `.pbj` onto our `Loader`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们首先需要声明许多不同的对象。我们将声明一个`String`常量来保存图像的路径和一个`Loader`，用于显示照片。`URLRequest`和`URLLoader`对象对将用于加载我们的`.pbj`文件。`Array`将用于保存我们将要加载的每个`.pbj`的名称。使用`int`来跟踪我们当前从`Array`集合中加载的着色器。最后，声明一个`Shader`和`ShaderFilter`对，以将加载的`.pbj`应用到我们的`Loader`上。
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next step is to initialize our `Array` and populate it with the Pixel Bender
    Shader file references we will be loading into our application. These files can
    be obtained through the Adobe Exchange, other locations on the web, or authored
    using the Pixel Bender Toolkit:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是初始化我们的`Array`，并用我们将要加载到应用程序中的 Pixel Bender 着色器文件引用来填充它。这些文件可以通过 Adobe Exchange、网络上的其他位置获取，或者使用
    Pixel Bender 工具包编写：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we create our `Loader` object, add it to the `Stage`, and register an
    event listener to properly scale the photo once it has been loaded:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建`Loader`对象，将其添加到`Stage`中，并注册一个事件监听器，以便在照片加载后适当缩放：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will now register a `TouchEvent` listener of type `TOUCH_TAP` to the `Loader`.
    This will enable the user to tap the loaded image to cycle through a variety of
    Pixel Bender Shaders. We also set the `currentFilter int` to `0`, which will indicate
    the first position of our `Array:`
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将为`Loader`注册一个类型为`TOUCH_TAP`的`TouchEvent`监听器。这将允许用户点击加载的图像以循环浏览各种 Pixel
    Bender 着色器。我们还设置`currentFilter int`为`0`，这将表示我们的`Array`中的第一个位置：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To load the photograph into the `Loader` instance for display within our application,
    we will invoke the `load()` method and pass in a new `URLRequest` along with the
    `photoURL String` constant that was declared earlier:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将照片加载到`Loader`实例中以便在我们的应用程序中显示，我们将调用`load()`方法，并传入先前声明的`photoURL String`常量以及新的`URLRequest`：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the file has loaded, we will perform one more action to adjust the `Loader`
    size to fit within the constraints of our `Stage:`
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件加载后，我们将执行一个操作，调整`Loader`的大小以适应我们的`Stage`的约束：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The resulting image, when loaded upon the `Stage`, without any shaders applied,
    will appear as follows:![How to do it…](img/1420_05_04.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载到`Stage`上的原始图像，在没有应用任何着色器的情况下，将如下所示：![如何操作…](img/1420_05_04.jpg)
- en: Each time the users performs a touch tap upon the `Loader` instance, this method
    will execute. Basically, we are setting up a `URLRequest` using values from the
    `Array` of shader locations that was set up earlier, pulling the value from whatever
    current index that has been recorded to the `currentFilter` object.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户在`Loader`实例上执行触摸点击时，此方法将会执行。基本上，我们正在使用之前设置的着色器位置`Array`中的值来设置`URLRequest`，从已记录到`currentFilter`对象的当前索引中提取值。
- en: Before we invoke the `URLLoader.load()` method, we must explicitly set the `dataFormat`
    property to the `URLLoaderDataFormat.BINARY` constant. This ensures that when
    our file is loaded up, it is treated as binary and not text.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们调用`URLLoader.load()`方法之前，我们必须显式地将`dataFormat`属性设置为`URLLoaderDataFormat.BINARY`常量。这确保了当我们的文件加载时，它被视为二进制文件而不是文本。
- en: An `Event.COMPLETE` listener is registered to invoke the `applyFilter` method
    once our shader has been loaded up.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册了一个`Event.COMPLETE`监听器，一旦着色器加载完毕，就会调用`applyFilter`方法。
- en: Finally, we can either increment our `currentFilter` value, or set it back to
    `0`, depending upon where we are along the length of the `Array:`
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以递增我们的`currentFilter`值，或者将其设置回`0`，具体取决于我们在`Array`的长度上的位置：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To actually apply the loaded `.pbj` onto our `Loader`, we will first assign
    the binary data to a new `Shader` object. This is subsequently passed through
    the constructor of a `ShaderFilter`, which is then applied to the filters property
    of our `Loader` as an `Array:`
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实际将加载的`.pbj`应用到我们的`Loader`上，我们首先将二进制数据分配给一个新的`Shader`对象。然后，这个对象通过`ShaderFilter`的构造函数传递，最后作为一个`Array`应用到我们的`Loader`的`filters`属性上。
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the user has tapped the image, we cycle through the available Pixel Bender
    Shaders and apply then, in turn, to the loaded photograph. The resulting image
    cycle can be seen as follows:![How to do it…](img/1420_05_05.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击图像时，我们会遍历可用的Pixel Bender着色器，并依次应用到加载的照片上。结果图像循环如下所示：![如何操作...](img/1420_05_05.jpg)
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Using Pixel Bender Shaders is a simple and direct way of enabling some really
    powerful visual manipulation within an application. In this recipe, we load an
    image into a `Loader` object, construct an `Array` of `.pbj` file references to
    pass through a `URLLoader`. When the user interacts with our loaded image, we
    will load a `.pbj` file and construct a `Shader` based upon the received data.
    Finally we can construct a `ShaderFilter` based off of this object and pass this
    onto our image through the `Loader.filters` property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pixel Bender着色器是在应用程序中进行强大视觉处理的一种简单直接的方式。在此配方中，我们将图像加载到`Loader`对象中，构建一个`.pbj`文件引用的`Array`，通过`URLLoader`传递。当用户与加载的图像交互时，我们将加载一个`.pbj`文件，并根据接收到的数据构建一个`Shader`。最后，我们可以基于此对象构建一个`ShaderFilter`，并通过`Loader.filters`属性将其传递给图像。
- en: There's more…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: In this example, we examine how to load an image into a `Loader` on the `Stage`
    and look at applying Pixel Bender Shaders to it upon user interaction. You can,
    of course, apply such shaders to any `DisplayObject` you like, including video!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将探讨如何将图像加载到`Stage`上的`Loader`中，并在用户交互时应用Pixel Bender着色器。当然，你可以将这些着色器应用到任何你喜欢的`DisplayObject`上，包括视频！
- en: A good place to locate a variety of Pixel Bender files to use in such an example,
    is the Adobe Exchange. Visit the Exchange website at [http://www.adobe.com/exchange](http://www.adobe.com/exchange).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个各种Pixel Bender文件用于此类示例的好地方，可以访问Adobe Exchange。访问Exchange网站：[http://www.adobe.com/exchange](http://www.adobe.com/exchange)。
- en: Playing video files from the local filesystem or over HTTP
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地文件系统或通过HTTP播放视频文件
- en: As we have the full Flash Player (and Adobe AIR) on Android devices, playback
    of video files is as simple as it normally is on the desktop. The main consideration
    is whether the video is optimized for playback on mobile, or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备上，我们拥有完整的Flash播放器（和Adobe AIR），因此视频文件的播放与在桌面上一样简单。主要考虑的是视频是否针对移动设备播放进行了优化。
- en: Getting ready…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: This recipe involves the playback of a video file that has been packaged along
    with our application. We could just as easily reference an HTTP address or even
    local storage on the Android device, so long as it is a file format and codec,
    which can be played back through Flash Platform runtimes. You will want to prepare
    this file ahead of time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方涉及播放与应用程序一起打包的视频文件。我们可以同样轻松地引用HTTP地址，甚至是Android设备上的本地存储，只要它是可以通过Flash Platform运行时播放的文件格式和编解码器。你需要提前准备这个文件。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a `Video` object, add it to the `Stage`, and stream a file in
    through a basic `NetConnection` and `NetStream` pair:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Video`对象，将其添加到`Stage`中，并通过基本的`NetConnection`和`NetStream`对来流式传输文件：
- en: 'First, import the following classes into your project:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For this recipe, we must declare a number of different objects up front. We
    are, in this case, packaging a video file along with the application itself; we
    will declare a `String` constant referring to this file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们首先需要声明许多不同的对象。在这种情况下，我们将一个视频文件与应用程序本身打包在一起；我们将声明一个引用这个文件的`String`常量。
- en: The next set of objects pertains to the actual video stream. Declare a `Video`
    object to display the `NetStream` data coming in over our local `NetConnection`.
    We will also declare an `Object` to bind specific, necessary functions to for
    video playback.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对象集合与实际的视频流有关。声明一个`Video`对象以显示通过我们的本地`NetConnection`传入的`NetStream`数据。我们还将声明一个`Object`，以绑定特定的、必要的函数来进行视频播放。
- en: 'Finally, we will declare a `TextField` and `TextFormat` pair to relay text
    messages onto the device display:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将声明一个`TextField`和`TextFormat`对，以将文本消息传递到设备显示屏上：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来为我们执行所有这些操作：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now to set up our video connection; we will create a new Object called `streamClient`,
    which we will use to bind a number of helper functions to our stream objects.
    A `Video` object must be created and added to the `DisplayList` in order for the
    user to actually view the video stream. Finally, we create a `NetConnection`,
    assign `streamClient` to its `client` property, register an event listener to
    monitor connection status, and then invoke the `connect()` method, passing in
    `null` as the connection argument, since we are not using any sort of media server
    in this example.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置我们的视频连接；我们将创建一个名为`streamClient`的新对象，我们将使用它将一些辅助函数绑定到我们的流对象上。必须创建一个`Video`对象并将其添加到`DisplayList`中，以便用户实际查看视频流。最后，我们创建一个`NetConnection`，将`streamClient`分配给它的`client`属性，注册一个事件监听器以监控连接状态，然后调用`connect()`方法，传入`null`作为连接参数，因为在这个例子中我们没有使用任何类型的媒体服务器。
- en: 'We may not always want to set the `Video.smoothing` property to true; in this
    case, since we are unsure exactly how large the video is, we will enable it in
    order to smooth any potential artifacting that may occur through scaling:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能并不总是希望将`Video.smoothing`属性设置为true；在这种情况下，由于我们不确定视频的确切大小，我们将启用它以平滑通过缩放可能发生的任何潜在图像失真：
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following method will be called from our `onNetStatus` function once we
    are sure the `NetConnection` has connected successfully. Within this method, create
    a new `NetStream` object to stream the video over our `NetConnection`. We will
    also assign `streamClient` to the `client` property and register an event listener
    to monitor stream status. To display the stream through our `Video` object, use
    the `attachStream()` method and pass in our `NetStream` object. Now, simply invoke
    the `play()` method, passing in our `videoPath` constant, and pointing to the
    video file location:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们确定`NetConnection`已成功连接，以下方法将从我们的`onNetStatus`函数中调用。在这个方法中，创建一个新的`NetStream`对象，通过我们的`NetConnection`流式传输视频。我们还将`streamClient`分配给`client`属性，并注册一个事件监听器以监控流状态。要通过我们的`Video`对象显示流，请使用`attachStream()`方法，并传入我们的`NetStream`对象。现在，只需调用`play()`方法，传入我们的`videoPath`常量，并指向视频文件位置：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `onNetStatus` method, as defined in the following code snippet, can be used
    with both our `NetStream` and `NetConnection` objects in order to make decisions
    based upon the different status messages returned. In this example, we are either
    firing the `connectStream` method once a `NetConnection` is successfully connected,
    or performing some scaling and layout once we are sure the `NetStream` is playing
    successfully.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码片段中定义的`onNetStatus`方法，可以与我们的`NetStream`和`NetConnection`对象一起使用，以便根据返回的不同状态消息做出决策。在这个例子中，我们要么在`NetConnection`成功连接后触发`connectStream`方法，要么在确定`NetStream`播放成功后执行一些缩放和布局。
- en: 'For a comprehensive list of all supported `NetStatusEvent` info codes, have
    a look at: [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/NetStatusEvent.html#info](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/NetStatusEvent.html#info).'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有支持的 `NetStatusEvent` 信息代码的完整列表，请访问：[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/NetStatusEvent.html#info](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/NetStatusEvent.html#info)。
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next three steps include methods which have been bound to the client property
    of either the `NetConnection` or `NetStream`. These must exist as part of the
    client object, or else errors may be thrown as they are expected methods. The
    `onTextData` method fires whenever text is encountered within the file being streamed:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个步骤包括绑定到 `NetConnection` 或 `NetStream` 的 `client` 属性的方法。这些方法必须是客户端对象的一部分，否则可能会抛出错误，因为它们是预期的方法。`onTextData`
    方法在流式文件中遇到文本时触发：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `onMetaData` method fires when the stream metadata is loaded into the application.
    This provides us with many useful pieces of information, such as stream width,
    height, and duration:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onMetaData` 方法在流元数据加载到应用程序中时触发。这为我们提供了许多有用的信息，如流宽度、高度和持续时间：'
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `onCuePoint` method fires whenever embedded cue points are encountered
    within the file being streamed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onCuePoint` 方法在流式文件中遇到嵌入的提示点时触发：'
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_06.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应用程序的界面将类似于以下屏幕渲染：![如何操作…](img/1420_05_06.jpg)
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The entire workflow is almost exactly what would be used when developing for
    the desktop. When playing back video over Flash, we must first establish a `NetConnection`
    for our `NetStream` to travel across. Once the `NetConnection` is connected, we
    create our `NetStream` and bind the two of them together. Adding a `Video` object
    to the `Stage` will enable the stream to be viewable on our device, so long as
    we attach out `NetStream` to it. At this point, we can then play any files we
    wish over that `NetStream` by simply invoking the `play()` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 整个工作流程与为桌面开发时的流程几乎完全相同。在 Flash 中播放视频时，我们首先必须为 `NetStream` 建立一个 `NetConnection`。一旦
    `NetConnection` 连接，我们创建 `NetStream` 并将它们绑定在一起。将 `Video` 对象添加到 `Stage` 将使流可以在我们的设备上观看，只要我们将
    `NetStream` 绑定到它上面。此时，我们可以通过简单地调用 `play()` 方法，在 `NetStream` 上播放我们希望的任何文件。
- en: When dealing with `NetConnection` and `NetStream`, there is always the need
    to create a number of helper functions. These functions include the registration
    of event listeners to detect particular status events, and the definition of a
    custom `client` property with associated methods that will be expected by the
    established workflow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 `NetConnection` 和 `NetStream` 时，我们总是需要创建一些辅助函数。这些函数包括注册事件监听器以检测特定状态事件，以及定义一个自定义的
    `client` 属性以及关联的方法，这些方法将符合已建立的工作流程的预期。
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this example, we are playing a file packaged with our application. It would
    be just as simple to play a video file from the device gallery (assuming the codec
    used to compress the video is supported by Flash and AIR) or progressively stream
    a video over HTTP from a location available over a wireless network connection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们播放的是与应用程序打包在一起的视频文件。从设备图库播放视频文件也同样简单（假设用于压缩视频的编解码器由 Flash 和 AIR 支持），或者通过无线网络连接从可用位置渐进式地流式传输视频。
- en: The video file we are playing back through Flash player or AIR must be of a
    type which is supported by the Flash Platform runtimes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Flash Player 或 AIR 播放的视频文件必须是 Flash Platform 运行时支持的类型。
- en: 'Valid video file types include:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的视频文件类型包括：
- en: FLV
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FLV
- en: MP4
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MP4
- en: M4V
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M4V
- en: F4V
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F4V
- en: 3GPP
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3GPP
- en: 'Flash Platform runtimes support every level and profile of the H.264 standard
    and retain full FLV support as well. However, recommended resolutions specific
    to Android are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Flash Platform 运行时支持 H.264 标准的每个级别和配置文件，并保持对 FLV 的完全支持。然而，针对 Android 推荐的分辨率如下：
- en: '**4:3 video:** 640 × 480, 512 × 384, 480 × 360'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4:3 视频：** 640 × 480, 512 × 384, 480 × 360'
- en: '**16:9 video:** 640 × 360, 512 x 288, 480 × 272'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**16:9 视频：** 640 × 360, 512 x 288, 480 × 272'
- en: When packaging such an application, which utilizes files that are distributed
    as part of the application package, we will also need to be sure and include them
    through the use of a GUI (if your IDE supports this) or as extra files in the
    command line compilation process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当打包这样一个应用程序时，需要确保包含作为应用程序包一部分分发的文件，可以通过使用GUI（如果您的IDE支持）或者在命令行编译过程中作为额外的文件包含它们。
- en: Playing remote video streams over RTMP
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过RTMP播放远程视频流
- en: Aside from the playback of video available through the local file system or
    from a remote HTTP web address, we also have the ability to stream video files
    onto Android devices using Flash Media Server and the RTMP protocol. If a streaming
    server such as this is available, you can make great use of this when deploying
    video across mobile Android devices.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以通过本地文件系统或远程HTTP网络地址播放视频之外，我们还可以使用Flash媒体服务器和RTMP协议将视频文件流式传输到Android设备上。如果可以使用这样的流媒体服务器，那么在将视频部署到移动Android设备时可以充分利用它。
- en: Getting ready…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: 'This recipe involves the playback of a video file that has been deployed to
    a Flash Media Server. You can actually set up a developer version of FMS for free
    if you do not have access to a production server. To find out more information
    about streaming video over **Real Time Messaging Protocol** (**RTMP**), you can
    have a look at the resources available at: [http://www.adobe.com/products/flashmediaserver/](http://www.adobe.com/products/flashmediaserver/)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱涉及播放一个已经部署在Flash媒体服务器上的视频文件。如果你没有生产服务器的访问权限，实际上可以免费设置一个开发者版本的FMS。想要了解更多关于通过**实时消息传递协议**（**RTMP**）流式传输视频的信息，你可以查看以下资源：[http://www.adobe.com/products/flashmediaserver/](http://www.adobe.com/products/flashmediaserver/)
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will create a `Video` object, add it to the `Stage`, and stream a file in
    through a `NetConnection` and `NetStream` pair over RTMP:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Video`对象，将其添加到`Stage`中，并通过`NetConnection`和`NetStream`对通过RTMP流式传输文件：
- en: 'First, import the following classes into your project:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For this recipe, we must declare a number of different objects up front. We
    are, in this case, using a Flash Media Server to perform a stream over RTMP; we
    will declare a `String` constant referring to the FMS application path.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们首先需要声明许多不同的对象。在这种情况下，我们使用Flash媒体服务器通过RTMP进行流式传输；我们将声明一个指向FMS应用程序路径的`String`常量。
- en: The next set of objects pertains to the actual video stream. Declare a `Video`
    object to display the `NetStream` data coming in over our local `NetConnection`.
    We will also declare an `Object` to bind specific, necessary function to for video
    playback.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对象集合与实际的视频流有关。声明一个`Video`对象以显示通过我们的本地`NetConnection`传入的`NetStream`数据。我们还将声明一个`Object`，以绑定特定必要的功能，用于视频播放。
- en: 'Finally, we will declare a `TextField` and `TextFormat` pair to relay text
    messages onto the device display:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将声明一个`TextField`和`TextFormat`对，将文本消息传递到设备显示屏上：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用`TextFormat`，并将其添加到`DisplayList`中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now to set up our video connection; we will create a new Object called `streamClient`,
    which we will use to bind a number of helper functions to our stream objects.
    A `Video` object must be created and added to the `DisplayList` in order for the
    user to actually view the video stream.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在设置我们的视频连接；我们将创建一个名为`streamClient`的新对象，我们将用它将一些辅助函数绑定到我们的流对象上。必须创建一个`Video`对象并将其添加到`DisplayList`中，以便用户实际查看视频流。
- en: Finally, we create a `NetConnection`, assign `streamClient` to its `client`
    property, register an event listener to monitor connection status, and then invoke
    the `connect()` method, passing in the predefined `fmsPath` constant as the connection
    argument. This is because we must make a connection to this application instance
    on the Flash Media Server before proceeding.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`NetConnection`，将其`client`属性分配给`streamClient`，注册一个事件监听器来监控连接状态，然后调用`connect()`方法，传入预定义的`fmsPath`常量作为连接参数。这是因为我们必须在继续之前连接到Flash媒体服务器上的这个应用程序实例。
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The following method will be called from our `onNetStatus` function once we
    are sure the `NetConnection` has connected successfully. Within this method, create
    a new `NetStream` object to stream the video over our `NetConnection`. We will
    also assign `streamClient` to the `client` property and register an event listener
    to monitor stream status.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们确定`NetConnection`成功连接，以下方法将从我们的`onNetStatus`函数中调用。在此方法中，创建一个新的`NetStream`对象，通过我们的`NetConnection`流式传输视频。我们还将`streamClient`分配给`client`属性，并注册事件监听器以监控流状态。
- en: To display the stream through our `Video` object, use the `attachStream()` method
    and pass in our `NetStream` object.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过我们的`Video`对象显示流，请使用`attachStream()`方法，并传入我们的`NetStream`对象。
- en: Now, simply invoke the `play()` method, passing in a `String` identifying the
    particular stream or file to play over RTMP. You will notice that since we are
    using an H.264 based file format, we must prefix the stream name with `mp4:`.
    If streaming live or via FLV, the prefix is not necessary.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需调用`play()`方法，传入一个标识特定流或文件的`String`，通过RTMP播放。你会注意到，由于我们使用基于H.264的文件格式，因此必须以`mp4:`为流名称前缀。如果是直播或通过FLV流式传输，则不需要前缀。
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `onNetStatus` method, as defined in the following code snippet, can be
    used with both our `NetStream` and `NetConnection` objects in order to make decisions
    based upon the different status messages returned. In this example, we are either
    firing the `connectStream` method once a `NetConnection` is successfully connected,
    or performing some scaling and layout once we are sure the `NetStream` is playing
    successfully:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onNetStatus`方法，如以下代码片段中定义的，可以与我们的`NetStream`和`NetConnection`对象一起使用，以便根据返回的不同状态消息做出决策。在这个例子中，我们要么在`NetConnection`成功连接后触发`connectStream`方法，要么在确定`NetStream`正在成功播放后执行一些缩放和布局操作：'
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next three steps include methods which have been bound to the client property
    of either the `NetConnection` or `NetStream`. These must exist as part of the
    client object, else errors may be thrown as they are expected methods. The `onBWDone`
    method is particular to files streamed over RTMP. It fires whenever the streaming
    server has completed an estimation of client bandwidth available.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下三个步骤包括绑定到`NetConnection`或`NetStream`的客户端属性的方法。这些方法必须作为客户端对象的一部分存在，否则可能会抛出错误，因为它们是预期的方法。`onBWDone`方法特别适用于通过RTMP传输的文件。它会在流媒体服务器完成对客户端可用带宽的估算后触发。
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `onTextData` method fires whenever text is encountered within the file being
    streamed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTextData`方法在流文件中遇到文本时触发。'
- en: '[PRE33]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `onMetaData` method fires when the stream metadata is loaded into the application.
    This provides us with many useful pieces of information, such as stream width,
    height, and duration:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onMetaData`方法在流元数据加载到应用程序时触发。这为我们提供了许多有用的信息，如流宽度、高度和持续时间：'
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `onCuePoint` method fires whenever embedded cue points are encountered
    within the file being streamed:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onCuePoint`方法在流文件中遇到嵌入的提示点时触发：'
- en: '[PRE35]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_07.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的应用程序将类似于以下屏幕渲染：![如何操作…](img/1420_05_07.jpg)
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: When playing back RTMP streams, we must first establish a `NetConnection` for
    our `NetStream` to travel across. The `NetConnection` will attempt to connect
    to the specified application defined on a Flash Media Server address. Once the
    `NetConnection` is connected, we create our `NetStream` and bind the two of them
    together. Adding a `Video` object to the `Stage` will enable the stream to be
    viewable on our device, as long as we attach out `NetStream` to it. At this point,
    we can then play any files we wish over that `NetStream` by simply invoking the
    `play()` method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在回放RTMP流时，我们首先必须为`NetStream`建立一个`NetConnection`以便传输。`NetConnection`将尝试连接到在Flash媒体服务器地址上定义的特定应用程序。一旦`NetConnection`连接，我们创建`NetStream`并将它们绑定在一起。将`Video`对象添加到`Stage`将使流可以在我们的设备上观看，只要我们将`NetStream`附加到它上面。此时，我们可以通过简单地调用`play()`方法，在`NetStream`上播放我们希望的任何文件。
- en: When dealing with `NetConnection` and `NetStream`, there is always the need
    to create a number of helper functions. These functions include the registration
    of event listeners to detect particular status events, and the definition of a
    custom `client` property with associated methods that will be expected by the
    established workflow.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`NetConnection`和`NetStream`时，总是需要创建许多辅助函数。这些函数包括注册事件监听器以检测特定状态事件，以及定义一个自定义`client`属性和关联的方法，这些方法将由已建立的工作流程预期。
- en: There's more…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: In this example, we are streaming a video file through an RTMP location over
    the Internet through Flash Media Server. You can use this same technique to stream
    audio files over RTMP or write a video chat application using the device camera.
    While we demonstrate here how to generate a `Video` object from scratch, keep
    in mind that there are various component solutions available such as the `FLVPlayBack`
    control that ships with Flash Professional, and the `VideoDisplay` and `VideoPlayer`
    components, which are part of the Flex framework. There are endless possibilities
    with this technology!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过Flash Media Server在互联网上通过RTMP位置流式传输视频文件。你可以使用相同的技术通过RTMP流式传输音频文件，或者编写一个使用设备摄像头视频聊天应用程序。虽然这里我们演示了如何从零开始生成一个`Video`对象，但请记住，还有各种组件解决方案可供选择，例如随Flash
    Professional提供的`FLVPlayBack`控件以及Flex框架中的`VideoDisplay`和`VideoPlayer`组件。这项技术有着无限的可能性！
- en: Playing audio files from the local filesystem or over HTTP
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地文件系统或通过HTTP播放音频文件
- en: The playback of audio files through Flash Platform runtimes on Android devices
    is fairly straightforward. We can point to files bundled with our application,
    as this recipe demonstrates, files on the device storage, or files over a remote
    network connection. No matter where the file is located, playback is accomplished
    in the same way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Android设备上的Flash Platform运行时播放音频文件相当直接。我们可以指向与应用程序捆绑的文件，正如本配方所示，设备存储上的文件，或者远程网络连接上的文件。无论文件位于何处，播放都是通过相同的方式完成的。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We must load the audio file into a `Sound` object and will then have the ability
    to manipulate playback, volume, pan, among other properties. In this recipe, we
    will allow the user to control volume through the rotation of a basic dial:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将音频文件加载到`Sound`对象中，然后才能操作播放、音量、声道平衡等属性。在此配方中，我们将允许用户通过旋转一个基本的旋钮来控制音量：
- en: 'First, import the following classes into your project:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For this recipe, we must declare a number of different objects up front. We
    will begin with a sound object group consisting of `Sound, SoundChannel`, and
    `SoundTransform`. These objects will allow us to take full control over the audio
    for this recipe. We will also create a `Sprite`, which will serve as a user interaction
    point. Finally, we will declare a `TextField` and `TextFormat` pair to relay text
    messages onto the device display:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们前端必须声明许多不同的对象。我们将从声音对象组开始，包括`Sound`、`SoundChannel`和`SoundTransform`。这些对象将允许我们完全控制此配方的音频。我们还将创建一个`Sprite`，作为用户交互点。最后，我们将声明一个`TextField`和`TextFormat`对，将文本消息传递到设备显示屏上：
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To create our volume dial, we will initialize a new `Sprite` and use the `graphics`
    API to draw a representation of a dial within it. We then add this `Sprite` to
    the `Stage:`
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建音量旋钮，我们将初始化一个新的`Sprite`对象，并使用`graphics` API在其内部绘制一个旋钮的表示。然后，我们将这个`Sprite`添加到`Stage`中：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we will go about setting up our audio related objects. Initialize our `Sound`
    and load a `MP3` file into it through `URLRequest`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始设置与音频相关的对象。初始化我们的`Sound`对象，并通过`URLRequest`将一个`MP3`文件加载到其中。
- en: Next, we will set the initial volume of the sound to 50% by creating a `SoundTransform`
    and passing in a value of `0.5` as the `volume` in ActionScript is registered
    in a range of `0 -1`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建一个`SoundTransform`并将`0.5`作为`volume`值（在ActionScript中注册的范围是`0 - 1`）传递给音量，将声音的初始音量设置为50%。
- en: 'To play the `Sound`, we will create a `SoundChannel` object, assign our `SoundTransform`
    to its `soundTransform` property, and finally set the `SoundChannel` through the
    `Sound.Play()` method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了播放`Sound`，我们将创建一个`SoundChannel`对象，将我们的`SoundTransform`分配给它的`soundTransform`属性，并通过`Sound.Play()`方法最终设置`SoundChannel`：
- en: '[PRE40]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.GESTURE` constant.
    We will also register a listener for `TransformGestureEvent.GESTURE_ROTATE` events
    upon our `Sprite` to intercept user interaction:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Multitouch.inputMode`设置为`MultitouchInputMode.GESTURE`常量，为多点触控API设置特定的输入模式以支持触摸输入。我们还将为`Sprite`注册一个`TransformGestureEvent.GESTURE_ROTATE`事件的监听器，以截获用户交互：
- en: '[PRE41]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When the `Sprite` is rotated by a user, we want to adjust playback volume accordingly.
    To accomplish this, we will adjust the `Sprite rotation` based upon the data received
    from our gesture event. We can then convert the `Sprite rotation` into a valid
    `volume Number` and modify the `SoundTransform` to reflect this, which will raise
    or lower the volume of our audio:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户旋转`Sprite`时，我们希望相应地调整播放音量。为了实现这一点，我们将根据手势事件收到的数据调整`Sprite`的旋转。然后我们可以将`Sprite`的旋转转换为一个有效的`音量数字`，并修改`SoundTransform`以反映这一点，这将提高或降低我们的音频音量：
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_08.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的应用程序将类似于以下屏幕渲染：![如何操作…](img/1420_05_08.jpg)
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We load an audio file into a `Sound` object in ActionScript through a `URLRequest`
    to make it available to our application. Simple playback can be achieved by invoking
    the `play()` method upon the `Sound`, but we retain a greater amount of control
    by assigning the sound playback onto a `SoundChannel` object, as we can then control
    things aspects such as pan and volume through the construction and assignment
    of a `SoundTransform` object. In this recipe, we modify the volume of the `SoundTransform`
    and then assign it to the `SoundChannel.soundTransform` property upon which our
    `Sound` is playing, thus modifying the sound.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`URLRequest`将音频文件加载到ActionScript中的`Sound`对象中，以便我们的应用程序可以使用它。通过调用`Sound`上的`play()`方法可以实现简单的播放，但我们通过将声音播放分配给`SoundChannel`对象可以保留更多的控制权，因为我们可以通过构建和分配`SoundTransform`对象来控制诸如立体声声像和音量等方面。在这个食谱中，我们修改了`SoundTransform`的音量，然后将其分配给正在播放我们`Sound`的`SoundChannel.soundTransform`属性，从而改变声音。
- en: There's more…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this example, we are playing a file packaged with our application. It would
    be just as simple to play an audio file from the device file system (assuming
    the codec used to compress the audio is supported by Flash and AIR) or progressively
    stream a file over HTTP from a location available over a network connection.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们播放的是与应用程序打包在一起的文件。从设备文件系统播放音频文件（假设Flash和AIR支持用于压缩音频的编解码器）或者通过HTTP从网络连接可访问的位置渐进式流式传输文件也同样简单。
- en: The audio file we are playing back through Flash Player or AIR must be of a
    type that is supported by the Flash Platform runtimes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Flash Player或AIR播放的音频文件必须是Flash Platform运行时支持的类型。
- en: 'Valid audio formats include:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的音频格式包括：
- en: FLV
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FLV
- en: MP3
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MP3
- en: AAC+
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AAC+
- en: HE-AAC
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HE-AAC
- en: AAC v1
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AAC v1
- en: AAC v2
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AAC v2
- en: When packaging such an application, which utilizes files which are distributed
    as part of the application package, we will also need to be sure and include them
    through the use of a GUI (if your IDE supports this) or as extra files in the
    command line compilation process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当打包这样的应用程序时，需要确保包含作为应用程序包一部分分发的文件，如果你的IDE支持，可以通过GUI包含它们，或者在命令行编译过程中作为额外的文件包含。
- en: Generating an audio spectrum visualizer
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成音频频谱可视化器
- en: The ability to generate some sort of visual feedback when playing audio is very
    useful to the user, as they will be able to see that playback occurs even if the
    device volume has been muted or turned down. Generating visuals from audio is
    also useful in certain games, or in monitoring audio input levels.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放音频时能够生成某种视觉反馈对用户非常有用，因为他们将能够看到即使设备音量被静音或调低，播放仍在进行。从音频生成视觉在某些游戏中或在监控音频输入水平时也很有用。
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will load a `MP3` file into a `Sound` object. By employing the `SoundMixer.
    computeSpectrum()` method, we can access the actual bytes being played back and
    construct visualizations with this data using the `Sprite graphics` API:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`MP3`文件加载到一个`Sound`对象中。通过使用`SoundMixer.computeSpectrum()`方法，我们可以访问实际正在播放的字节，并使用`Sprite
    graphics` API用这些数据构建可视化：
- en: 'First, import the following classes into your project:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE43]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For this recipe, we must declare a number of different objects up front. We
    will begin with a sound object pair consisting of `Sound` and `SoundChannel`.
    These objects will allow us to take full control over the audio for this recipe.
    We will also create a `Sprite`, which will serve as a canvas to draw out audio
    spectrum data. Finally, we will declare a `Timer` in order to refresh the sound
    spectrum visualization every few milliseconds:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们首先需要声明许多不同的对象。我们将从`Sound`和`SoundChannel`声音对象对开始。这些对象将使我们能够完全控制这个配方的音频。我们还将创建一个`Sprite`对象，它将作为绘制音频频谱数据的画布。最后，我们将声明一个`Timer`，以便每隔几毫秒刷新声音频谱可视化：
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To construct the canvas within which we will draw out visualization elements,
    we must initialize a `Sprite`, define a particular line style on the `graphics`
    API, and add it to the `Stage:`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建我们将绘制可视化元素的画布，我们必须初始化一个`Sprite`，在`graphics` API上定义特定的线条样式，并将其添加到`Stage`上：
- en: '[PRE45]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `Timer` will be used to determine how often we will refresh the visualization
    within our container `Sprite`. In this case, we will set it to fire a `TIMER`
    event every 100 milliseconds, or 10 times every second.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Timer`来确定我们将在容器`Sprite`中刷新可视化的频率。在这种情况下，我们将它设置为每100毫秒触发一次`TIMER`事件，也就是每秒10次。
- en: '[PRE46]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we will go about setting up our audio related objects. Initialize our `Sound`
    and load a `MP3` file into it through `URLRequest`. To play the `Sound`, we will
    create a `SoundChannel` object, assign our `SoundTransform` to its `soundTransForm`
    property, and finally set the `SoundChannel` through the `Sound.Play()` method.
    As we now have our `Sound` loaded and ready to go, we can start running our `Timer`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将开始设置我们的音频相关对象。初始化我们的`Sound`并通过`URLRequest`加载一个`MP3`文件。为了播放`Sound`，我们将创建一个`SoundChannel`对象，将我们的`SoundTransform`分配给它的`soundTransForm`属性，并最终通过`Sound.Play()`方法设置`SoundChannel`。现在我们的`Sound`已经加载并准备就绪，我们可以开始运行我们的`Timer`。
- en: '[PRE47]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, construct a method similar to the following, which will extract byte
    data from the global Flash `SoundMixer`, and use the `graphics` API to draw out
    visualizations based upon this data. We first initialize a number of variables
    to be used in this method and run `computeSpectrum()` off of the `SoundMixer`
    class. This will populate our `ByteArray` with all of the sound sample data needed
    to create our visuals.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建一个类似于以下的方法，该方法将从全局 Flash `SoundMixer`中提取字节数据，并使用`graphics` API基于这些数据绘制可视化。我们首先初始化此方法中将要使用的几个变量，并运行`SoundMixer`类中的`computeSpectrum()`。这将用创建我们的视觉效果所需的所有声音样本数据填充我们的`ByteArray`。
- en: In looping through the data, we can use the `graphics` API to draw lines, circles,
    or anything we desire into our `Sprite` container. In this case, we draw a series
    of lines to create a spectrum visualization. As this is set to update every 100
    milliseconds, it becomes an ever-shifting visual indicator of the sound being
    played back.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遍历数据时，我们可以使用`graphics` API在我们的`Sprite`容器中绘制线条、圆形或任何我们想要的内容。在这个例子中，我们绘制一系列线条以创建频谱可视化。由于这被设置为每100毫秒更新一次，因此它成为播放声音的持续变化的视觉指示器。
- en: '[PRE48]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_09.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应用程序将类似于以下屏幕渲染：![如何操作…](img/1420_05_09.jpg)
- en: How it works…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: The `SoundMixer` class provides access to the `computeSpectrum()` method, which
    is able to take a snapshot of the any sound being played through Flash Player
    or AIR and write it into a `ByteArray` object. There are 512 total `Number` values
    written to the `ByteArray`; the first 256 represent the left channel, and the
    remaining 256 represent the right. Depending upon what sort of visualization you
    need, the full 512 values may not be needed, as in the case here.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundMixer`类提供了对`computeSpectrum()`方法的访问，该方法能够捕获通过Flash Player或AIR播放的任何声音的快照，并将其写入一个`ByteArray`对象。共有512个`Number`值写入`ByteArray`；前256个代表左声道，剩下的256个代表右声道。根据您需要的可视化类型，可能不需要全部512个值，正如本例所示。'
- en: To generate the values which determine where to draw our lines using the graphics
    API, we use `ByteArray.readFloat()`, which reads a 32-bit floating-point value
    from the byte stream, and converts it to a `Number`. As this value indicates the
    specific sound data for that particular sample, we can use that to draw out a
    series of lines through the graphics API and form our visible spectrum.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成确定使用图形API绘制线条位置的价值，我们使用`ByteArray.readFloat()`，它从字节数据流中读取一个32位的浮点值，并将其转换为一个`Number`。由于这个值表示该特定样本的具体声音数据，我们可以使用它通过图形API绘制一系列线条，形成我们的可见频谱。
- en: There's more…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can find a large amount of additional methods and formulae online by doing
    a simple search. The possibilities for doing this sort of generative visualization
    are truly endless, but we must take into account the lower than normal hardware
    specifications on these devices when deciding how far to push any visualization
    engine.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单的搜索在网上找到大量的方法和公式。这种生成性可视化的可能性确实是无限的，但在决定将任何可视化引擎推进多远时，我们必须考虑到这些设备上低于正常的硬件规格。
- en: Generating audio tones for your application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的应用程序生成音频音调
- en: Packing a lot of sound files into an application is one method of including
    audio. Another method is the runtime generation of sound data. We'll produce some
    simple sine tones in this recipe, which vary based upon detected touch pressure.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中打包大量的声音文件是一种包含音频的方法。另一种方法是运行时生成声音数据。在这个配方中，我们将生成一些简单的正弦音调，这些音调根据检测到的触摸压力而变化。
- en: How to do it…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will examine how to generate audio sample byte data based upon user touch
    pressure and feed this into a `Sound` object to generate a variety of tones:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何根据用户的触摸压力生成音频样本字节数据，并将其输入到`Sound`对象中以产生各种音调：
- en: 'First, import the following classes into your project:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE49]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For this recipe, we must declare a number of different objects up front. We
    will begin with a sound object pair consisting of `Sound` and `SoundChannel`.
    These objects will allow us full control over the audio for this recipe. We will
    also create a `Number`, which will retain pressure information obtained through
    user touch. Finally, we will declare a `TextField` and `TextFormat` pair to relay
    text messages onto the device display:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们首先必须声明多个不同的对象。我们将从由`Sound`和`SoundChannel`组成的声波对象对开始。这些对象将允许我们对这个配方的音频进行完全控制。我们还将创建一个`Number`，用来通过用户触摸获取压力信息。最后，我们将声明一个`TextField`和`TextFormat`对，用于在设备显示屏上传递文本消息：
- en: '[PRE50]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的`TextField`，应用一个`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE51]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we will go about setting up our audio related objects. Initialize a `Sound`
    and `SoundChannel` object pair. These will be employed later on to play back our
    generated audio data:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将开始设置与音频相关的对象。初始化一个`Sound`和`SoundChannel`对象对。这些将在后面用来回放我们生成的音频数据：
- en: '[PRE52]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    We will also register a listener for `SampleDataEvent.SAMPLE_DATA` events, which
    requests will begin once we set out `Sound` object to `play()` through the previously
    established `SoundChannel:`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多点触控APIs的特定输入模式设置为通过将`Multitouch.inputMode`设置为`MultitouchInputMode.TOUCH_POINT`常量来支持触摸输入。我们还将为`SampleDataEvent.SAMPLE_DATA`事件注册一个监听器，一旦我们通过先前建立的`SoundChannel`让`Sound`对象`play()`，这些请求就会开始。
- en: '[PRE53]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Whenever a touch event is detected, we will monitor it through the following
    method. Basically, we modify the `touchPressure Number`, which will be used to
    calculate our sine wave generation:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当检测到触摸事件时，我们将会通过以下方法来监控它。基本上，我们修改`touchPressure Number`，这将用于计算我们的正弦波生成：
- en: '[PRE54]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our final method will execute whenever the currently playing `Sound` object
    requests new sample data to play back. We will employ the `ByteArray.writeFloat()`
    method to send generated audio data back to our `Sound` object for playback upon
    each sample request:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后的方法将在当前播放的`Sound`对象请求新的样本数据以回放时执行。我们将使用`ByteArray.writeFloat()`方法将生成的音频数据发送回我们的`Sound`对象，在每个样本请求时进行回放：
- en: '[PRE55]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The resulting application will produce a variable tone depending upon the amount
    of pressure applied through touch and should look similar to the following screen
    render:![How to do it…](img/1420_05_10.jpg)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果应用程序将根据通过触摸施加的压力量产生可变音调，并且应该类似于以下屏幕渲染：![如何操作…](img/1420_05_10.jpg)
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The ActionScript `Sound` object, when registered with a `SampleDataEvent` event
    listener, will act as a socket when playback is initiated. We must provide sample
    data to pass along to this `Sound` object through a function, which generates
    this data, and passes samples to the waiting `Sound` object. The number of samples
    can vary between 2048 and 8192, in this case, we provide as much sample data as
    possible. The general formula provided by Adobe for generating a sine wave is:
    `Math.sin((Number(loopIndex+SampleDataEvent.position)/Math.PI/2))` multiplied
    by 0.25\. Since we are modifying the formula based upon recorded touch point pressure,
    we multiply by this recorded value, instead. This modifies the generated audio
    that is produced by the application.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册了`SampleDataEvent`事件监听器的ActionScript `Sound`对象在播放启动时，它将作为一个插座。我们必须通过一个函数提供样本数据，这个函数生成数据，并将样本传递给等待的`Sound`对象。样本的数量可以在2048到8192之间变化，在这种情况下，我们尽可能提供多的样本数据。Adobe提供的生成正弦波的通用公式是：`Math.sin((Number(loopIndex+SampleDataEvent.position)/Math.PI/2))`乘以0.25。由于我们是根据记录的触摸点压力修改公式，所以我们用这个记录的值来代替乘数。这改变了应用程序产生的音频输出。
- en: There's more…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: For a more controlled library of generated sound tones, there exist ActionScript
    libraries, which can be used free of charge, or for a fee, depending on the library.
    I'd recommend checking out Sonoport at [http://www.sonoport.com/](http://www.sonoport.com/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更可控的生成声音库，存在ActionScript库，可以免费使用，或者根据库的不同可能需要付费。我建议查看一下[Sonoport](http://www.sonoport.com/)。
