- en: 'Chapter 5. Rich Media Presentation: Working with Images, Video, and Audio'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Loading photographs from the device cameraRoll
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Pixel Bender Shader effects to loaded images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing video files from the local file system or over HTTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing remote video files over RTMP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio files from the local file system or over HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an audio spectrum visualizer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating audio tones for your application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will include a variety of recipes for the display of image data
    and playback of both video and audio streams. Included among these recipes are
    examples demonstrating the ability to load images from the device camera repository,
    applying Pixel Bender Shaders to loaded images, the playback of audio and video
    over different protocols, as well as the generation of visual data from sound
    and the generation of raw sound data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The Flash platform is well known as the premiere video distribution platform
    worldwide. In the following pages, we will see that this experience and reach
    is in no way confined to desktop and browser-based computing. With new features
    such as StageVideo available in AIR 2.6 and Flash Player 10.2, Flash is becoming
    an even stronger platform for delivering video while preserving device battery
    life and providing a better user experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Loading photographs from the device cameraRoll
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android operating system has a central repository for storing photographs
    captured by the variety of camera applications a user may have installed. There
    are APIs within AIR for Android, which allows a Flash developer to specifically
    target and pull from this repository for display within an application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must use the mobile `CameraRoll` API to browse directly to the device camera
    roll and select a photograph for display:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `CameraRoll` object and a `Loader`, which will be used to display
    the photograph, once selected:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create our `Loader` object, add it to the `Stage`, and register an
    event listener to properly scale the photo once it has been loaded:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the `CameraRoll` itself, all we need to do is instantiate it and then add
    an event listener to fire once the user has selected a photograph to display.
    We should always check to see whether the device supports `CameraRoll.browseForImage()by`
    checking the `supportsBrowseForImage` property:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will now register a `TouchEvent` listener of type `TOUCH_TAP` to the `Stage`.
    This will enable the user to invoke a browse dialog in order to select a photograph
    from the `CameraRoll` by tapping the device screen.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We are setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT`
    constant in order for our application to accept touch events.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the following method is invoked from a user interaction, we can invoke
    the `browseForImage()` method upon the `CameraRoll` object we had set up earlier.
    This will open the default gallery application on an Android device and allow
    the user to select a photograph from their collection. If there is more than one
    gallery application on the device, the user will first choose which one to use
    for this event through a native Android dialog. Our application will lose focus
    and this will be handled by the operating system, returning to our application
    once a selection is made.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see the default gallery application on Android. A user can spend
    as much time as they wish browsing the various collections and photographs before
    a selection is made.![How to do it…](img/1420_05_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user has performed a valid selection in the native Android gallery
    application, focus returns to our application and an event containing a `MediaPromise`
    object is returned. The `Loader` class has a specific method called `loadFilePromise()`
    specifically for this sort of thing. We will now pass the `MediaPromise` through
    this method.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we've passed the `MediaPromise` object through the `Loader` using `loadFilePromise()`,
    it will load up onto the `Stage`. We will perform one more action here to adjust
    the `Loader` size to fit within the constraints of our `Stage:`
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The resulting image, when loaded upon the `Stage`, will appear as follows:![How
    to do it…](img/1420_05_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ActionScript `CameraRoll` API specifically targets the on device storage
    location for photographs on Android. Whenever a user performs some interaction
    that invokes a `CameraRoll.browseForImage()` method in our application, the default
    Android gallery application will launch, allowing the user to select an image
    file from within their collection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has selected a photograph from the gallery application, they will
    be returned to our AIR for Android application along with a `MediaPromise` object
    with which we can ascertain certain information about the file, or even load the
    photograph directly into our application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we examine how to load an image from the `CameraRoll` into
    a `Loader` on the `Stage`. There are, of course, many things we could do to the
    photograph once it has been loaded up. For an example of this, have a look at
    the next recipe: *Applying Pixel Bender Shader effects to loaded images*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Applying Pixel Bender Shader effects to loaded images
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we load a visual object into our application, as this is all Flash-based,
    we can do all sorts of robust visual manipulation. In this example, we will load
    a preselected photograph from the local file system, and then apply a variety
    of Pixel Bender Shaders to it, drastically changing its appearance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe makes use of Pixel Bender Shaders. You can download `.pbj` files
    from the Adobe Exchange or create your own.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to write your own Pixel Bender kernels, you can download the Pixel
    Bender Toolkit for free from [http://www.adobe.com/devnet/pixelbender.html](http://www.adobe.com/devnet/pixelbender.html)
    and use it to compile all sorts of shaders for use in Flash and AIR projects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The toolkit allows you to write kernels using the Pixel Bender kernel language
    (formerly known as Hydra) and provides mechanisms for image preview and separate
    property manipulation that can be exposed to ActionScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/1420_05_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: For a good resource on writing Pixel Bender Shaders, check out the documentation
    located at [http://www.adobe.com/devnet/pixelbender.html](http://www.adobe.com/devnet/pixelbender.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are also referencing a photograph that exists within the
    Android image gallery, which we previously captured with the default camera application.
    You may do the same, or simply bundle an image file along with the application
    for later reference.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now load a predetermined image from the local device storage and apply
    multiple Pixel Bender Shaders to it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this recipe, we must declare a number of different objects up front. We
    will declare a `String` constant to hold the path to our image and a `Loader`,
    which will be used to display the photograph. A `URLRequest` and `URLLoader` object
    pair will be used to load in our `.pbj` files. The `Array` will be set up to hold
    the names of each `.pbj` we will be loading. An `int` is employed to keep track
    of the shader we have currently loaded from our `Array` set. Finally, a `Shader`
    and `ShaderFilter` pair are declared to apply the loaded `.pbj` onto our `Loader`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next step is to initialize our `Array` and populate it with the Pixel Bender
    Shader file references we will be loading into our application. These files can
    be obtained through the Adobe Exchange, other locations on the web, or authored
    using the Pixel Bender Toolkit:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we create our `Loader` object, add it to the `Stage`, and register an
    event listener to properly scale the photo once it has been loaded:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will now register a `TouchEvent` listener of type `TOUCH_TAP` to the `Loader`.
    This will enable the user to tap the loaded image to cycle through a variety of
    Pixel Bender Shaders. We also set the `currentFilter int` to `0`, which will indicate
    the first position of our `Array:`
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To load the photograph into the `Loader` instance for display within our application,
    we will invoke the `load()` method and pass in a new `URLRequest` along with the
    `photoURL String` constant that was declared earlier:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the file has loaded, we will perform one more action to adjust the `Loader`
    size to fit within the constraints of our `Stage:`
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The resulting image, when loaded upon the `Stage`, without any shaders applied,
    will appear as follows:![How to do it…](img/1420_05_04.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time the users performs a touch tap upon the `Loader` instance, this method
    will execute. Basically, we are setting up a `URLRequest` using values from the
    `Array` of shader locations that was set up earlier, pulling the value from whatever
    current index that has been recorded to the `currentFilter` object.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we invoke the `URLLoader.load()` method, we must explicitly set the `dataFormat`
    property to the `URLLoaderDataFormat.BINARY` constant. This ensures that when
    our file is loaded up, it is treated as binary and not text.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Event.COMPLETE` listener is registered to invoke the `applyFilter` method
    once our shader has been loaded up.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we can either increment our `currentFilter` value, or set it back to
    `0`, depending upon where we are along the length of the `Array:`
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To actually apply the loaded `.pbj` onto our `Loader`, we will first assign
    the binary data to a new `Shader` object. This is subsequently passed through
    the constructor of a `ShaderFilter`, which is then applied to the filters property
    of our `Loader` as an `Array:`
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the user has tapped the image, we cycle through the available Pixel Bender
    Shaders and apply then, in turn, to the loaded photograph. The resulting image
    cycle can be seen as follows:![How to do it…](img/1420_05_05.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Pixel Bender Shaders is a simple and direct way of enabling some really
    powerful visual manipulation within an application. In this recipe, we load an
    image into a `Loader` object, construct an `Array` of `.pbj` file references to
    pass through a `URLLoader`. When the user interacts with our loaded image, we
    will load a `.pbj` file and construct a `Shader` based upon the received data.
    Finally we can construct a `ShaderFilter` based off of this object and pass this
    onto our image through the `Loader.filters` property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we examine how to load an image into a `Loader` on the `Stage`
    and look at applying Pixel Bender Shaders to it upon user interaction. You can,
    of course, apply such shaders to any `DisplayObject` you like, including video!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: A good place to locate a variety of Pixel Bender files to use in such an example,
    is the Adobe Exchange. Visit the Exchange website at [http://www.adobe.com/exchange](http://www.adobe.com/exchange).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Playing video files from the local filesystem or over HTTP
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have the full Flash Player (and Adobe AIR) on Android devices, playback
    of video files is as simple as it normally is on the desktop. The main consideration
    is whether the video is optimized for playback on mobile, or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe involves the playback of a video file that has been packaged along
    with our application. We could just as easily reference an HTTP address or even
    local storage on the Android device, so long as it is a file format and codec,
    which can be played back through Flash Platform runtimes. You will want to prepare
    this file ahead of time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `Video` object, add it to the `Stage`, and stream a file in
    through a basic `NetConnection` and `NetStream` pair:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For this recipe, we must declare a number of different objects up front. We
    are, in this case, packaging a video file along with the application itself; we
    will declare a `String` constant referring to this file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next set of objects pertains to the actual video stream. Declare a `Video`
    object to display the `NetStream` data coming in over our local `NetConnection`.
    We will also declare an `Object` to bind specific, necessary functions to for
    video playback.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will declare a `TextField` and `TextFormat` pair to relay text
    messages onto the device display:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now to set up our video connection; we will create a new Object called `streamClient`,
    which we will use to bind a number of helper functions to our stream objects.
    A `Video` object must be created and added to the `DisplayList` in order for the
    user to actually view the video stream. Finally, we create a `NetConnection`,
    assign `streamClient` to its `client` property, register an event listener to
    monitor connection status, and then invoke the `connect()` method, passing in
    `null` as the connection argument, since we are not using any sort of media server
    in this example.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We may not always want to set the `Video.smoothing` property to true; in this
    case, since we are unsure exactly how large the video is, we will enable it in
    order to smooth any potential artifacting that may occur through scaling:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following method will be called from our `onNetStatus` function once we
    are sure the `NetConnection` has connected successfully. Within this method, create
    a new `NetStream` object to stream the video over our `NetConnection`. We will
    also assign `streamClient` to the `client` property and register an event listener
    to monitor stream status. To display the stream through our `Video` object, use
    the `attachStream()` method and pass in our `NetStream` object. Now, simply invoke
    the `play()` method, passing in our `videoPath` constant, and pointing to the
    video file location:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `onNetStatus` method, as defined in the following code snippet, can be used
    with both our `NetStream` and `NetConnection` objects in order to make decisions
    based upon the different status messages returned. In this example, we are either
    firing the `connectStream` method once a `NetConnection` is successfully connected,
    or performing some scaling and layout once we are sure the `NetStream` is playing
    successfully.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a comprehensive list of all supported `NetStatusEvent` info codes, have
    a look at: [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/NetStatusEvent.html#info](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/events/NetStatusEvent.html#info).'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next three steps include methods which have been bound to the client property
    of either the `NetConnection` or `NetStream`. These must exist as part of the
    client object, or else errors may be thrown as they are expected methods. The
    `onTextData` method fires whenever text is encountered within the file being streamed:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `onMetaData` method fires when the stream metadata is loaded into the application.
    This provides us with many useful pieces of information, such as stream width,
    height, and duration:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `onCuePoint` method fires whenever embedded cue points are encountered
    within the file being streamed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_06.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire workflow is almost exactly what would be used when developing for
    the desktop. When playing back video over Flash, we must first establish a `NetConnection`
    for our `NetStream` to travel across. Once the `NetConnection` is connected, we
    create our `NetStream` and bind the two of them together. Adding a `Video` object
    to the `Stage` will enable the stream to be viewable on our device, so long as
    we attach out `NetStream` to it. At this point, we can then play any files we
    wish over that `NetStream` by simply invoking the `play()` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with `NetConnection` and `NetStream`, there is always the need
    to create a number of helper functions. These functions include the registration
    of event listeners to detect particular status events, and the definition of a
    custom `client` property with associated methods that will be expected by the
    established workflow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are playing a file packaged with our application. It would
    be just as simple to play a video file from the device gallery (assuming the codec
    used to compress the video is supported by Flash and AIR) or progressively stream
    a video over HTTP from a location available over a wireless network connection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The video file we are playing back through Flash player or AIR must be of a
    type which is supported by the Flash Platform runtimes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid video file types include:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: FLV
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MP4
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M4V
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F4V
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3GPP
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flash Platform runtimes support every level and profile of the H.264 standard
    and retain full FLV support as well. However, recommended resolutions specific
    to Android are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**4:3 video:** 640 × 480, 512 × 384, 480 × 360'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**16:9 video:** 640 × 360, 512 x 288, 480 × 272'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When packaging such an application, which utilizes files that are distributed
    as part of the application package, we will also need to be sure and include them
    through the use of a GUI (if your IDE supports this) or as extra files in the
    command line compilation process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Playing remote video streams over RTMP
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from the playback of video available through the local file system or
    from a remote HTTP web address, we also have the ability to stream video files
    onto Android devices using Flash Media Server and the RTMP protocol. If a streaming
    server such as this is available, you can make great use of this when deploying
    video across mobile Android devices.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe involves the playback of a video file that has been deployed to
    a Flash Media Server. You can actually set up a developer version of FMS for free
    if you do not have access to a production server. To find out more information
    about streaming video over **Real Time Messaging Protocol** (**RTMP**), you can
    have a look at the resources available at: [http://www.adobe.com/products/flashmediaserver/](http://www.adobe.com/products/flashmediaserver/)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `Video` object, add it to the `Stage`, and stream a file in
    through a `NetConnection` and `NetStream` pair over RTMP:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For this recipe, we must declare a number of different objects up front. We
    are, in this case, using a Flash Media Server to perform a stream over RTMP; we
    will declare a `String` constant referring to the FMS application path.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next set of objects pertains to the actual video stream. Declare a `Video`
    object to display the `NetStream` data coming in over our local `NetConnection`.
    We will also declare an `Object` to bind specific, necessary function to for video
    playback.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will declare a `TextField` and `TextFormat` pair to relay text
    messages onto the device display:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now to set up our video connection; we will create a new Object called `streamClient`,
    which we will use to bind a number of helper functions to our stream objects.
    A `Video` object must be created and added to the `DisplayList` in order for the
    user to actually view the video stream.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we create a `NetConnection`, assign `streamClient` to its `client`
    property, register an event listener to monitor connection status, and then invoke
    the `connect()` method, passing in the predefined `fmsPath` constant as the connection
    argument. This is because we must make a connection to this application instance
    on the Flash Media Server before proceeding.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The following method will be called from our `onNetStatus` function once we
    are sure the `NetConnection` has connected successfully. Within this method, create
    a new `NetStream` object to stream the video over our `NetConnection`. We will
    also assign `streamClient` to the `client` property and register an event listener
    to monitor stream status.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the stream through our `Video` object, use the `attachStream()` method
    and pass in our `NetStream` object.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, simply invoke the `play()` method, passing in a `String` identifying the
    particular stream or file to play over RTMP. You will notice that since we are
    using an H.264 based file format, we must prefix the stream name with `mp4:`.
    If streaming live or via FLV, the prefix is not necessary.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `onNetStatus` method, as defined in the following code snippet, can be
    used with both our `NetStream` and `NetConnection` objects in order to make decisions
    based upon the different status messages returned. In this example, we are either
    firing the `connectStream` method once a `NetConnection` is successfully connected,
    or performing some scaling and layout once we are sure the `NetStream` is playing
    successfully:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next three steps include methods which have been bound to the client property
    of either the `NetConnection` or `NetStream`. These must exist as part of the
    client object, else errors may be thrown as they are expected methods. The `onBWDone`
    method is particular to files streamed over RTMP. It fires whenever the streaming
    server has completed an estimation of client bandwidth available.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `onTextData` method fires whenever text is encountered within the file being
    streamed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `onMetaData` method fires when the stream metadata is loaded into the application.
    This provides us with many useful pieces of information, such as stream width,
    height, and duration:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `onCuePoint` method fires whenever embedded cue points are encountered
    within the file being streamed:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_07.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When playing back RTMP streams, we must first establish a `NetConnection` for
    our `NetStream` to travel across. The `NetConnection` will attempt to connect
    to the specified application defined on a Flash Media Server address. Once the
    `NetConnection` is connected, we create our `NetStream` and bind the two of them
    together. Adding a `Video` object to the `Stage` will enable the stream to be
    viewable on our device, as long as we attach out `NetStream` to it. At this point,
    we can then play any files we wish over that `NetStream` by simply invoking the
    `play()` method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with `NetConnection` and `NetStream`, there is always the need
    to create a number of helper functions. These functions include the registration
    of event listeners to detect particular status events, and the definition of a
    custom `client` property with associated methods that will be expected by the
    established workflow.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are streaming a video file through an RTMP location over
    the Internet through Flash Media Server. You can use this same technique to stream
    audio files over RTMP or write a video chat application using the device camera.
    While we demonstrate here how to generate a `Video` object from scratch, keep
    in mind that there are various component solutions available such as the `FLVPlayBack`
    control that ships with Flash Professional, and the `VideoDisplay` and `VideoPlayer`
    components, which are part of the Flex framework. There are endless possibilities
    with this technology!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio files from the local filesystem or over HTTP
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The playback of audio files through Flash Platform runtimes on Android devices
    is fairly straightforward. We can point to files bundled with our application,
    as this recipe demonstrates, files on the device storage, or files over a remote
    network connection. No matter where the file is located, playback is accomplished
    in the same way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must load the audio file into a `Sound` object and will then have the ability
    to manipulate playback, volume, pan, among other properties. In this recipe, we
    will allow the user to control volume through the rotation of a basic dial:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For this recipe, we must declare a number of different objects up front. We
    will begin with a sound object group consisting of `Sound, SoundChannel`, and
    `SoundTransform`. These objects will allow us to take full control over the audio
    for this recipe. We will also create a `Sprite`, which will serve as a user interaction
    point. Finally, we will declare a `TextField` and `TextFormat` pair to relay text
    messages onto the device display:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To create our volume dial, we will initialize a new `Sprite` and use the `graphics`
    API to draw a representation of a dial within it. We then add this `Sprite` to
    the `Stage:`
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we will go about setting up our audio related objects. Initialize our `Sound`
    and load a `MP3` file into it through `URLRequest`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will set the initial volume of the sound to 50% by creating a `SoundTransform`
    and passing in a value of `0.5` as the `volume` in ActionScript is registered
    in a range of `0 -1`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To play the `Sound`, we will create a `SoundChannel` object, assign our `SoundTransform`
    to its `soundTransform` property, and finally set the `SoundChannel` through the
    `Sound.Play()` method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Set the specific input mode for the multitouch APIs to support touch input
    by setting `Multitouch.inputMode` to the `MultitouchInputMode.GESTURE` constant.
    We will also register a listener for `TransformGestureEvent.GESTURE_ROTATE` events
    upon our `Sprite` to intercept user interaction:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When the `Sprite` is rotated by a user, we want to adjust playback volume accordingly.
    To accomplish this, we will adjust the `Sprite rotation` based upon the data received
    from our gesture event. We can then convert the `Sprite rotation` into a valid
    `volume Number` and modify the `SoundTransform` to reflect this, which will raise
    or lower the volume of our audio:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_08.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We load an audio file into a `Sound` object in ActionScript through a `URLRequest`
    to make it available to our application. Simple playback can be achieved by invoking
    the `play()` method upon the `Sound`, but we retain a greater amount of control
    by assigning the sound playback onto a `SoundChannel` object, as we can then control
    things aspects such as pan and volume through the construction and assignment
    of a `SoundTransform` object. In this recipe, we modify the volume of the `SoundTransform`
    and then assign it to the `SoundChannel.soundTransform` property upon which our
    `Sound` is playing, thus modifying the sound.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are playing a file packaged with our application. It would
    be just as simple to play an audio file from the device file system (assuming
    the codec used to compress the audio is supported by Flash and AIR) or progressively
    stream a file over HTTP from a location available over a network connection.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The audio file we are playing back through Flash Player or AIR must be of a
    type that is supported by the Flash Platform runtimes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid audio formats include:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: FLV
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MP3
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AAC+
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HE-AAC
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AAC v1
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AAC v2
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When packaging such an application, which utilizes files which are distributed
    as part of the application package, we will also need to be sure and include them
    through the use of a GUI (if your IDE supports this) or as extra files in the
    command line compilation process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Generating an audio spectrum visualizer
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to generate some sort of visual feedback when playing audio is very
    useful to the user, as they will be able to see that playback occurs even if the
    device volume has been muted or turned down. Generating visuals from audio is
    also useful in certain games, or in monitoring audio input levels.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load a `MP3` file into a `Sound` object. By employing the `SoundMixer.
    computeSpectrum()` method, we can access the actual bytes being played back and
    construct visualizations with this data using the `Sprite graphics` API:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For this recipe, we must declare a number of different objects up front. We
    will begin with a sound object pair consisting of `Sound` and `SoundChannel`.
    These objects will allow us to take full control over the audio for this recipe.
    We will also create a `Sprite`, which will serve as a canvas to draw out audio
    spectrum data. Finally, we will declare a `Timer` in order to refresh the sound
    spectrum visualization every few milliseconds:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To construct the canvas within which we will draw out visualization elements,
    we must initialize a `Sprite`, define a particular line style on the `graphics`
    API, and add it to the `Stage:`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `Timer` will be used to determine how often we will refresh the visualization
    within our container `Sprite`. In this case, we will set it to fire a `TIMER`
    event every 100 milliseconds, or 10 times every second.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we will go about setting up our audio related objects. Initialize our `Sound`
    and load a `MP3` file into it through `URLRequest`. To play the `Sound`, we will
    create a `SoundChannel` object, assign our `SoundTransform` to its `soundTransForm`
    property, and finally set the `SoundChannel` through the `Sound.Play()` method.
    As we now have our `Sound` loaded and ready to go, we can start running our `Timer`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, construct a method similar to the following, which will extract byte
    data from the global Flash `SoundMixer`, and use the `graphics` API to draw out
    visualizations based upon this data. We first initialize a number of variables
    to be used in this method and run `computeSpectrum()` off of the `SoundMixer`
    class. This will populate our `ByteArray` with all of the sound sample data needed
    to create our visuals.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In looping through the data, we can use the `graphics` API to draw lines, circles,
    or anything we desire into our `Sprite` container. In this case, we draw a series
    of lines to create a spectrum visualization. As this is set to update every 100
    milliseconds, it becomes an ever-shifting visual indicator of the sound being
    played back.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The resulting application will look similar to the following screen render:![How
    to do it…](img/1420_05_09.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SoundMixer` class provides access to the `computeSpectrum()` method, which
    is able to take a snapshot of the any sound being played through Flash Player
    or AIR and write it into a `ByteArray` object. There are 512 total `Number` values
    written to the `ByteArray`; the first 256 represent the left channel, and the
    remaining 256 represent the right. Depending upon what sort of visualization you
    need, the full 512 values may not be needed, as in the case here.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: To generate the values which determine where to draw our lines using the graphics
    API, we use `ByteArray.readFloat()`, which reads a 32-bit floating-point value
    from the byte stream, and converts it to a `Number`. As this value indicates the
    specific sound data for that particular sample, we can use that to draw out a
    series of lines through the graphics API and form our visible spectrum.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find a large amount of additional methods and formulae online by doing
    a simple search. The possibilities for doing this sort of generative visualization
    are truly endless, but we must take into account the lower than normal hardware
    specifications on these devices when deciding how far to push any visualization
    engine.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Generating audio tones for your application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packing a lot of sound files into an application is one method of including
    audio. Another method is the runtime generation of sound data. We'll produce some
    simple sine tones in this recipe, which vary based upon detected touch pressure.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will examine how to generate audio sample byte data based upon user touch
    pressure and feed this into a `Sound` object to generate a variety of tones:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For this recipe, we must declare a number of different objects up front. We
    will begin with a sound object pair consisting of `Sound` and `SoundChannel`.
    These objects will allow us full control over the audio for this recipe. We will
    also create a `Number`, which will retain pressure information obtained through
    user touch. Finally, we will declare a `TextField` and `TextFormat` pair to relay
    text messages onto the device display:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we will go about setting up our audio related objects. Initialize a `Sound`
    and `SoundChannel` object pair. These will be employed later on to play back our
    generated audio data:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Set the specific input mode for the multitouch APIs to support touch input by
    setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT` constant.
    We will also register a listener for `SampleDataEvent.SAMPLE_DATA` events, which
    requests will begin once we set out `Sound` object to `play()` through the previously
    established `SoundChannel:`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Whenever a touch event is detected, we will monitor it through the following
    method. Basically, we modify the `touchPressure Number`, which will be used to
    calculate our sine wave generation:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our final method will execute whenever the currently playing `Sound` object
    requests new sample data to play back. We will employ the `ByteArray.writeFloat()`
    method to send generated audio data back to our `Sound` object for playback upon
    each sample request:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The resulting application will produce a variable tone depending upon the amount
    of pressure applied through touch and should look similar to the following screen
    render:![How to do it…](img/1420_05_10.jpg)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ActionScript `Sound` object, when registered with a `SampleDataEvent` event
    listener, will act as a socket when playback is initiated. We must provide sample
    data to pass along to this `Sound` object through a function, which generates
    this data, and passes samples to the waiting `Sound` object. The number of samples
    can vary between 2048 and 8192, in this case, we provide as much sample data as
    possible. The general formula provided by Adobe for generating a sine wave is:
    `Math.sin((Number(loopIndex+SampleDataEvent.position)/Math.PI/2))` multiplied
    by 0.25\. Since we are modifying the formula based upon recorded touch point pressure,
    we multiply by this recorded value, instead. This modifies the generated audio
    that is produced by the application.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册了`SampleDataEvent`事件监听器的ActionScript `Sound`对象在播放启动时，它将作为一个插座。我们必须通过一个函数提供样本数据，这个函数生成数据，并将样本传递给等待的`Sound`对象。样本的数量可以在2048到8192之间变化，在这种情况下，我们尽可能提供多的样本数据。Adobe提供的生成正弦波的通用公式是：`Math.sin((Number(loopIndex+SampleDataEvent.position)/Math.PI/2))`乘以0.25。由于我们是根据记录的触摸点压力修改公式，所以我们用这个记录的值来代替乘数。这改变了应用程序产生的音频输出。
- en: There's more…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: For a more controlled library of generated sound tones, there exist ActionScript
    libraries, which can be used free of charge, or for a fee, depending on the library.
    I'd recommend checking out Sonoport at [http://www.sonoport.com/](http://www.sonoport.com/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更可控的生成声音库，存在ActionScript库，可以免费使用，或者根据库的不同可能需要付费。我建议查看一下[Sonoport](http://www.sonoport.com/)。
