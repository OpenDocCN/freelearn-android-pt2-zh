- en: Chapter 6. Applications of Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Physics-based games provide players with a unique type of experience not encountered
    in many other genres. This chapter covers the use of AndEngine''s **Box2D physics
    extension**. Our recipes include:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Box2D physics extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding different body types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating category-filtered bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple-fixture bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating unique bodies by specifying vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using forces, velocities, and torque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying anti-gravity to a specific body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rag doll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using preSolve and postSolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating destructible objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raycasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Box2D physics extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physics-based games are one of the most popular types of games available for
    mobile devices. AndEngine allows the creation of physics-based games with the
    Box2D extension. With this extension, we can construct any type of physically
    realistic 2D environment from small, simple simulations to complex games. In this
    recipe, we will create an activity that demonstrates a simple setup for utilizing
    the Box2D physics engine extension. Furthermore, we will use this activity for
    the remaining recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new activity class named `PhysicsApplication` that extends `BaseGameActivity`
    and implements `IAccelerationListener` and `IOnSceneTouchListener`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build our `PhysicsApplication` activity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following variables in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to set up the foundation of our activity. To start doing so, place
    these four, common overridden methods in the class to set up the engine, resources,
    and the main scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue setting up the activity by adding the following overridden method,
    which will be used to populate our scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will fill the previous method with the following code to create our
    `PhysicsWorld` object and `Scene` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following overridden activities handle the scene touch events, the accelerometer
    input, and the two engine life cycle events—`onResumeGame` and `onPauseGame`.
    Place them at the end of the class to finish this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we do is define a camera width and height. Then, we define
    a `Scene` object and a `FixedStepPhysicsWorld` object in which the physics simulations
    will take place. The last set of variables defines what will act as the borders
    for our physics-based scenes.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we override the `onCreateEngine()` method to return a `FixedStepEngine`
    object that will process `60` updates per second. The reason that we do this,
    while also using a `FixedStepPhysicsWorld` object, is to create a simulation that
    will be consistent across all devices, regardless of how efficiently a device
    can process the physics simulation. We then create the `EngineOptions` object
    with standard preferences, create the `onCreateResources()` method with only a
    simple callback, and set the main scene with a light-gray background.
  prefs: []
  type: TYPE_NORMAL
- en: In the `onPopulateScene()` method, we create our `FixedStepPhysicsWorld` object
    that has double the gravity of the Earth, passed as an `(x,y)` coordinate `Vector2`
    object, and will update `60` times per second. The gravity can be set to other
    values to make our simulations more realistic or `0` to create a zero gravity
    simulation. A gravity setting of `0` is useful for space simulations or for games
    that use a top-down camera view instead of a profile. The `false` Boolean parameter
    sets the `AllowSleep` property of the `PhysicsWorld` object, which tells `PhysicsWorld`
    to not let any bodies deactivate themselves after coming to a stop. The last two
    parameters of the `FixedStepPhysicsWorld` object tell the physics engine how many
    times to calculate velocity and position movements. Higher iterations will create
    simulations that are more accurate, but can cause lag or jitteriness because of
    the extra load on the processor. After creating the `FixedStepPhysicsWorld` object,
    we register it with the main scene as an update handler. The physics world will
    not run a simulation without being registered.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `WALL_FIXTURE_DEF` is a **fixture definition** . Fixture definitions
    hold the shape and material properties of entities that will be created within
    the physics world as fixtures. The shape of a fixture can be either circular or
    polygonal. The material of a fixture is defined by its density, elasticity, and
    friction, all of which are required when creating a fixture definition. Following
    the creation of the `WALL_FIXTURE_DEF` variable, we create four rectangles that
    will represent the locations of the wall bodies. A body in the Box2D physics world
    is made of fixtures. While only one fixture is necessary to create a body, multiple
    fixtures can create complex bodies with varying properties.
  prefs: []
  type: TYPE_NORMAL
- en: Further along in the `onPopulateScene()` method, we create the box bodies that
    will act as our walls in the physics world. The rectangles that were previously
    created are passed to the bodies to define their position and shape. We then define
    the bodies as static, which means that they will not react to any forces in the
    physics simulation. Lastly, we pass the wall fixture definition to the bodies
    to complete their creation.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the bodies, we attach the rectangles to the main scene and set
    the scene's touch listener to our activity, which will be accessed by the `onSceneTouchEvent()`
    method. The final line of the `onPopulateScene()` method tells the engine that
    the scene is ready to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The overridden `onSceneTouchEvent()` method will handle all touch interactions
    for our scene. The `onAccelerationAccuracyChanged()` and `onAccelerationChanged()`
    methods are inherited from the `IAccelerationListener` interface and allow us
    to change the gravity of our physics world when the device is tilted, rotated,
    or panned. We override `onResumeGame()` and `onPauseGame()` to keep the accelerometer
    from using unnecessary battery power when our game activity is not in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the overridden `onAccelerationChanged()` method, we make two calls to the
    `Vector2Pool` class. The `Vector2Pool` class simply gives us a way of re-using
    our `Vector2` objects that might otherwise require garbage collection by the system.
    On newer devices, the Android Garbage Collector has been streamlined to reduce
    noticeable hiccups, but older devices might still experience lag depending on
    how much memory the variables being garbage collected occupy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html) to
    see the **Box2D User Manual**. The AndEngine Box2D extension is based on a Java
    port of the official Box2D C++ physics engine, so some variations in procedure
    exist, but the general concepts still apply.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding different body types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Box2D physics world gives us the means to create different body types that
    allow us to control the physics simulation. We can generate **dynamic bodies**
    that react to forces and other bodies, **static bodies** that do not move, and
    **kinematic bodies** that move but are not affected by forces or other bodies.
    Choosing which type each body will be is vital to producing an accurate physics
    simulation. In this recipe, we will see how three bodies react to each other during
    collision, depending on their body types.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the recipe in the *Introduction to the Box2D physics extension* section
    given at the beginning of this chapter to create a new activity that will facilitate
    the creation of our bodies with varying body types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete the following steps to see how specifying a body type for bodies affects
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, insert the following fixture definition into the `onPopulateScene()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place the following code that creates three rectangles and their corresponding
    bodies after the fixture definition from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add the following code after the definitions from the previous step
    to set the linear and angular velocities for our kinematic body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we create the `BoxBodyFixtureDef` fixture definition that
    we will use when creating our bodies in the second step. For more information
    on fixture definitions, see the *Introduction to the Box2D physics extension*
    recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we first define the `staticRectangle` rectangle by calling the
    `Rectangle` constructor. We place `staticRectangle` at the position of `cameraWidth
    / 2f, 75f`, which is near the lower-center of the scene, and we set the rectangle
    to have a width of `400f` and a height of `40f`, which makes the rectangle into
    a long, flat bar. Then, we set the `staticRectangle` rectangle's color to be red
    by calling `staticRectangle.setColor(0.8f, 0f, 0f)`. Lastly, for the `staticRectangle`
    rectangle, we attach it to the scene by calling the `mScene.attachChild()` method
    with `staticRectangle` as the parameter. Next, we create a body in the physics
    world that matches our `staticRectangle`. To do this, we call the `PhysicsFactory.createBoxBody()`
    method with the parameters of `mPhysicsWorld`, which is our physics world, `staticRectangle`
    to tell the box to be created with the same position and size as the `staticRectangle`
    rectangle, `BodyType.StaticBody` to define the body as static, and our `BoxBodyFixtureDef`
    fixture definition.
  prefs: []
  type: TYPE_NORMAL
- en: Our next rectangle, `dynamicRectangle`, is created at the location of `400f`
    and `120f`, which is the middle of the scene slightly above the `staticRectangle`
    rectangle. Our `dynamicRectangle` rectangle's width and height are set to `40f`
    to make it a small square. Then, we set its color to green by calling `dynamicRectangle.setColor(0f,
    0.8f, 0f)` and attach it to our scene using `mScene.attachChild(dynamicRectangle)`.
    Next, we create the `dynamicBody` variable using the `PhysicsFactory.createBoxBody()`
    method in the same way that we did for our `staticRectangle` rectangle. Notice
    that we set the `dynamicBody` variable to have `BodyType` of `DynamicBody`. This
    sets the body to be dynamic. Now, we register `PhysicsConnector` with the physics
    world to link `dynamicRectangle` and `dynamicBody`. A `PhysicsConnecter` class
    links an entity within our scene to a body in the physics world, representing
    the body's realtime position and rotation in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Our last rectangle, `kinematicRectangle`, is created at the location of `600f`
    and `100f`, which places it on top of our `staticRectangle` rectangle toward the
    right-hand side of the scene. It is set to have a height and width of `40f`, which
    makes it a small square like our `dynamicRectangle` rectangle. We then set the
    `kinematicRectangle` rectangle's color to yellow and attach it to our scene. Similar
    to the previous two bodies that we created, we call the `PhysicsFactory.createBoxBody()`
    method to create our `kinematicBody` variable. Take note that we create our `kinematicBody`
    variable with a `BodyType` type of `KinematicBody`. This sets it to be kinematic
    and thus moved only by the setting of its velocities. Lastly, we register a `PhysicsConnector`
    class between our `kinematicRectangle` rectangle and our `kinematicBody` body
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we set our `kinematicBody` body's linear velocity by calling
    the `setLinearVelocity()` method with a vector of `-2f` on the x axis, which makes
    it move to the left. Finally, we set our `kinematicBody` body's angular velocity
    to negative `pi` by calling `kinematicBody.setAngularVelocity((float) (-Math.PI))`.
    For more information on setting a body's velocities, see the *Using forces, velocities,
    and torque* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static bodies cannot move from applied or set forces, but can be relocated using
    the `setTransform()` method. However, we should avoid using the `setTransform()`
    method while a simulation is running, because it makes the simulation unstable
    and can cause some strange behaviors. Instead, if we want to change the position
    of a static body, we can do so whenever creating the simulation or, if we need
    to change the position at runtime, simply check that the new position will not
    cause the static body to overlap existing dynamic bodies or kinematic bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Kinematic bodies cannot have forces applied, but we can set their velocities
    via the `setLinearVelocity()` and `setAngularVelocity()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using forces, velocities, and torque* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating category-filtered bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the type of physics simulation that we want to achieve, controlling
    which bodies are capable of colliding can be very beneficial. In Box2D, we can
    assign a category, and category-filter to fixtures to control which fixtures can
    interact. This recipe will cover the defining of two category-filtered fixtures
    that will be applied to bodies created by touching the scene to demonstrate category-filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section given at the beginning of the chapter. This activity
    will facilitate the creation of the category-filtered bodies used in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build our category-filtering demonstration activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the following class-level variables within the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create this method within the class that generates new category-filtered
    bodies at a given location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, fill the body of the `onSceneTouchEvent()` method with the following
    code that calls the `addBody()` method by passing the touched location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we create an integer, `mBodyCount`, which counts how many
    bodies we have added to the physics world. The `mBodyCount` integer is used in
    the second step to determine which color, and thus which category, should be assigned
    to the new body.
  prefs: []
  type: TYPE_NORMAL
- en: We also create the `CATEGORYBIT_DEFAULT`, `CATEGORYBIT_RED_BOX`, and `CATEGORYBIT_GREEN_BOX`
    category bits by defining them with unique power-of-two short integers and the
    `MASKBITS_RED_BOX` and `MASKBITS_GREEN_BOX` mask bits by adding their associated
    category bits together. The category bits are used to assign a category to a fixture,
    while the mask bits combine the different category bits to determine which categories
    a fixture can collide with. We then pass the category bits and mask bits to the
    fixture definitions to create fixtures that have category collision rules.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is a simple method that creates a rectangle and its corresponding
    body. The method takes the `X` and `Y` location parameters that we want to use
    to create a new body and passes them to a `Rectangle` object's constructor, to
    which we also pass a height and width of `50f` and the activity's `VertexBufferObjectManager`.
    Then, we set the rectangle to be 50 percent transparent using the `rectangle.setAlpha()`
    method. After that, we define a body and modulate the `mBodyCount` variable by
    `2` to determine the color and fixture of every other created body. After determining
    the color and fixture, we assign them by setting the rectangle's color and creating
    a body by passing our `mPhysicsWorld` physics world, the rectangle, a dynamic
    body type, and the previously-determined fixture to use. Finally, we attach the
    rectangle to our scene and register a `PhysicsConnector` class to connect the
    rectangle to our body.
  prefs: []
  type: TYPE_NORMAL
- en: The third step calls the `addBody()` method from step two only if the physics
    world has been created and only if the scene's `TouchEvent` is `ActionDown`. The
    parameters that are passed, `pSceneTouchEvent.getX()` and `pSceneTouchEvent.getY()`,
    represent the location on the scene that received a touch input, which is also
    the location where we want to create a new category-filtered body.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default category of all fixtures has a value of one. When creating mask
    bits for specific fixtures, remember that any combination that includes the default
    category will cause the fixture to collide with all other fixtures that are not
    masked to avoid collision with the fixture.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple-fixture bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We sometimes need a body that has varying physics attributes on certain parts
    of it. For instance, a car with a bumper should react differently if it hits a
    wall to a car without a bumper. The creation of such a multifixture body in Box2D
    is fairly simple and straightforward. In this recipe, we will see how to create
    a multifixture body by creating two fixtures and adding them to an empty body.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    the creation of our multifixture body.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to see how we can create multifixture bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following code in the `onPopulateScene()` method to create two rectangles
    that have a modified `AnchorCenter` value which allows for precise placement when
    linked to a body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code creates a `Body` object and two fixtures, one that is perfectly
    elastic and another that is perfectly inelastic. Add it after the creation of
    the rectangles in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we need to set the location of our multifixture body now that it has
    been created. Place the following call to `setTransform()` after the creation
    of the bodies in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step that we take is to define a rectangle that will represent a non-bouncy
    fixture by using the `Rectangle` constructor and passing `0f` on the x axis and
    `0f` on the y axis, representing the origin of the world. We then pass a height
    and width of `100f`, which makes the rectangle a large square, and the activity's
    `VertexBufferObjectManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set the color of the non-bouncy rectangle to black, `0f, 0f, 0f`, and
    set its anchor-center using the `nonbouncyBoxRect.setAnchorCenter()` method to
    represent the location on the body, created in the second step, at which the non-bouncy
    rectangle will be attached. The anchor-center location of `(((nonbouncyBoxRect.getWidth()
    / 2) - nonbouncyBoxRect.getX()) / nonbouncyBoxRect.getWidth(), ((nonbouncyBoxRect.getHeight()
    / 2) – nonbouncyBoxRect.getY()) / nonbouncyBoxRect.getHeight()` converts the rectangle's
    location and size to the location that the rectangle rests on the origin. In the
    case of our non-bouncy rectangle, the anchor-center remains at the default `0.5f,
    0.5f`, but the formula is necessary for any fixture that will be created from
    a rectangle that is not centered on the origin. Next, we attach our non-bouncy
    rectangle to the scene. Then, we create a rectangle that will represent a bouncy
    fixture using the same method that we used to create the non-bouncy rectangle,
    but we place the rectangle at `-55f` on the y axis to put it directly below the
    non-bouncy rectangle. We also set the width of the rectangle to `90f`, making
    it slightly smaller than the previous rectangle, and the height to `10f` to make
    it a slim bar that will act as a bouncy portion directly below the non-bouncy
    rectangle. After setting the bouncy rectangle's anchor-center using the same formula
    used for the non-bouncy rectangle, we attach it to the scene. Take note that we
    have modified the `AnchorCenter` values of each of the rectangles, so that the
    `PhysicsConnectors` class that we register in the second step can place the rectangles
    in the proper location when we run the simulation. Also, note that we create our
    rectangles and multifixture body at the world's origin to make calculations simple
    and fast. After our body has been created, we move it to the position that it
    should be in for the simulation, as can be seen in the third step, when we call
    the `multiFixtureBody.setTransform()` method with the parameters `400f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    and `240f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`, which represent the
    center of the screen in the physics world, and `0f`, which represents the zero-rotation
    that the body will have.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we create an empty body, `multiFixtureBody`, by calling
    `mPhysicsWorld.createBody(new BodyDef())` and set it to be dynamic by calling
    its `setType()` method with the parameter `BodyType.DynamicBody`. Then, we define
    a fixture definition, `nonbouncyBoxFixtureDef`, for the non-bouncy fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `PolygonShape` shape named `nonbouncyBoxShape` and set it
    as a box that mimics our `nonbouncyBoxRect` by calling `nonbouncyBoxShape` shape's
    `setAsBox()` method with the first two parameters as `nonbouncyBoxRect.getWidth()
    / 2f` and `nonbouncyBoxRect.getHeight() / 2f` to set the `nonbouncyBoxShape` object
    to have the same width and height as our `nonbouncyBoxRect` rectangle. Both of
    the parameters are divided by `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    to scale the values to the physics world. Furthermore, the `setAsBox()` method's
    first two parameters are half sizes. This means that a normal width of `10f` will
    be passed to the `setAsBox()` method as `5f`. The next parameter of the `setAsBox()`
    method is a `Vector2` parameter that will identify the location of our `nonbouncyBoxShape`
    shape in the physics world. We set it to the location of our `nonbouncyBoxRect`
    rectangle, converting the location to physics world coordinates by scaling with
    the `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT` variable. The last parameter
    of the `setAsBox()` method is the rotation that `nonbouncyBoxShape` should have.
    Because our `nonbouncyBoxRect` rectangle is not rotated, we use `0f`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set the `shape` property of our `nonbouncyBoxFixtureDef` fixture definition
    to `nonbouncyBoxShape`, which applies the shape to our fixture definition. Next,
    we attach the fixture to our multifixture body by calling the body's `createFixture()`
    method with the `nonbouncyBoxFixtureDef` fixture definition as the parameter.
    Then, we register a `PhysicsConnector` class to link the `nonbouncyBoxRect` rectangle
    in our scene to the `multiFixtureBody` body in the physics world. Finally, we
    follow the same procedures that we used when creating the non-bouncy fixture to
    create our bouncy fixture. The result should be a black square with one bouncy,
    green side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By setting the `isSensor` property of a fixture definition to `true`, a fixture
    can be created as a sensor, which allows it to contact other fixtures without
    a physical interaction occurring. For more information on sensors, see the **Fixtures**
    section of the Box2D manual at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating unique bodies by specifying vertices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not everything in our physics simulations must be made of rectangles or circles.
    We can also create polygonal bodies by creating a list of the polygonal points.
    This approach is useful for creating certain types of terrain, vehicles, and characters.
    In this recipe, we will demonstrate how to create a unique body from a list of
    vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section given at the beginning of the chapter. This activity
    will easily allow the creation of a uniquely constructed body with vertices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete the following steps to define and create our unique, polygonal body:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our unique body''s vertices will be defined by a list of `Vector2` objects.
    Add the following list to the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the preceding list of vertices, we must run them through the `EarClippingTriangulator`
    class to turn the vertices list into a list of triangles that the physics engine
    will use to create multiple fixtures that are joined into a single body. Place
    this code after the creation of the initial `ector2` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a mesh that will represent our unique body, as well as adapt the
    triangulated vertices for use in the physics world, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have adapted the vertices to be used in the physics world, we can
    create the body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we want the unique body to have something to collide with. Add the
    following body definitions to create two static bodies that will act as small
    pegs in our hysics world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The list of vertices that we first create represents the shape that our unique
    body will be, relative to the center of the body. In the second step, we create
    another list of vertices using the `EarClippingTriangulator` class. This list
    that is returned from the `computeTriangles()` method of the `EarClippingTriangulator`
    class contains all of the points of the triangles that make up our unique body.
    The following figure shows what our polygonal body looks like before and after
    running its vertices through the `EarClippingTriangulator` class. Notice that
    our body will be made from several triangular shapes that represent the original
    shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In step three, after adding each vertex to the `MeshTriangles` array for use
    in creating a mesh to represent our body, we multiply each vertex by `1/PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`,
    which is the same as dividing the vertex's coordinates by the default pixel-to-meter
    ratio. This division process is a common practice used to convert the scene coordinates
    to the physics world coordinates. The physics world measures distance in meters,
    so a conversion from pixels is necessary. Any consistent, reasonable value can
    be used as the conversion constant, but the default pixel-to-meter-ratio is 32
    pixels per meter and has been proven to work in almost every simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Step four creates the unique body by calling `PhysicsFactory.createTrianglulatedBody`.
    It is important to note that while it is possible to create polygonal bodies from
    a non-triangulated list of vertices, the only benefit to doing so would be if
    we were using a list with less than seven vertexes. Even with such a small list,
    triangulating the body does not have a noticeable negative impact on the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several physics-body editors are available to simplify body creation. The following
    are all usable with AndEngine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physics Bo****dy Editor** (free): [http://code.google.com/p/box2d-editor](http://code.google.com/p/box2d-editor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phys****icsEditor** (paid): [http://www.codeandweb.com/physicseditor](http://www.codeandweb.com/physicseditor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inkscape** (free, plugins required): [http://inkscape.org/](http://inkscape.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using forces, velocities, and torque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter what kind of simulation we are creating, we will more than likely
    want to control at least one body. To move bodies in Box2D, we can apply linear
    or angular forces, set linear or angular velocities, and apply an angular force
    in the form of torque. In this recipe, we will see how we can apply these forces
    and velocities on multiple bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    the creation of bodies that will react to forces, velocities, and torque. Then,
    update the activity to include the additional code from the `ForcesVelocitiesTorqueActivity`
    class found in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the supplemental `ForcesVelocitiesTorqueActivity` class for the complete
    example of this recipe. We will cover only the basics of the recipe in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first work with the methods that handle the linear motion of our bodies.
    Place the following code snippet in the overridden `onAreaTouched()` method of
    the `LinearForceRect` rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, insert this code in the `onAreaTouched()` method of the `LinearImpulseRect`
    rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add this code to the `onAreaTouched()` method of the `LinearVelocityRect`
    rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will work with the `Body` methods that affect the angular motion of
    our bodies. Place this code in the `onAreaTouched()` method of the `AngularTorqueRect`
    rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the following code in the `onAreaTouched()` method of the `AngularImpulseRect`
    rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add this code to the `onAreaTouched()` method of the `AngularVelocityRect`
    rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we apply a linear force on `LinearForceBody` by calling its `applyForce()`
    method with the force parameters of `0f` on the x axis and `2000f` on the y axis
    to apply a strong, positive vertical force and the force location in world coordinates
    of `LinearForceBody.getWorldCenter().x` and `LinearForceBody.getWorldCenter().y`
    to apply the force at the center of the `LinearForceBody` body.
  prefs: []
  type: TYPE_NORMAL
- en: Step two applies a linear impulse on the `LinearImpulseBody` body via its `applyLinearImpulse()`
    method. The `applyLinearImpulse()` method's first two parameters are the impulse
    amount with respect to the world axis. We use the values of `0f` and `200f` to
    apply the moderate impulse pointing straight up. The remaining two parameters
    of the `applyLinearImpulse()` method are the x and y location that the impulse
    will be applied to the body in world coordinates. We pass `LinearImpulseBody.getWorldCenter().x`
    and `LinearImpulseBody.getWorldCenter().y` to apply the impulse at the center
    of the `LinearImpulseBody` body.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we set the linear velocity of `LinearVelocityBody` by calling
    its `setLinearVelocity()` method with the parameters `0f` and `20f`. The parameter
    of `0f` signifies that the body will not be moving on the x axis, and the parameter
    of `20f` sets the y axis motion immediately to be 20 meters per second. When using
    the `setLinearVelocity()` method, the velocity is automatically set at the body's
    center of mass.
  prefs: []
  type: TYPE_NORMAL
- en: Step four applies a torque to `AngularTorqueBody`. We call the `AngularTorqueBody.applyTorque()`
    method with a value of `2000f` to apply a very strong torque to the `AngularTorqueBody`
    body at the body's center of mass.
  prefs: []
  type: TYPE_NORMAL
- en: In the fifth step, we apply an angular impulse to the `AngularImpulseBody` body
    by calling the `AngularImpulseBody.applyAngularImpulse()` method with a value
    of `20f`. This small, angular impulse will be applied to the `AngularImpulseBody`
    body's center of mass.
  prefs: []
  type: TYPE_NORMAL
- en: For the final step, we set the angular velocity of the `AngularVelocityBody`
    body. We call the `AngularVelocityBody.setAngularVelocity()` method with the value
    of `10f` to make the body immediately rotate at 10 radians per second.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Impulses* differ from *forces* in that they function independently of the
    timestep. An impulse actually equals *force* multiplied by *time*. Likewise, *forces*
    equal the *impulse* divided by *time*.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the velocity of bodies and applying an impulse are similar, but there
    is an important distinction to make—applying impulses directly adds to or subtracts
    from the velocity, while setting a velocity does not incrementally increase or
    decrease he velocity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying anti-gravity to a specific body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at how forces affect bodies. Using a constant
    force that opposes gravity, we can release a body from the gravity of the physics
    world. If the force that opposes gravity is great enough, the body will even float
    away! In this recipe, we will create a body that counteracts the force of gravity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section at the beginning of the chapter. This activity will
    facilitate the creation of a body that has a constant force applied that opposes
    gravity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, follow these steps to create a body that opposes gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following definitions in the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a rectangle and body that will demonstrate the normal effects
    of gravity on a body. Place the following code snippet in the `onPopulateScene()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a rectangle and body that show how a body can ignore gravity
    by applying an anti-gravity force during every update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step that we take is to define a body affected by gravity, a body
    that opposes gravity, and a fixture definition used when creating the bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a rectangle and its corresponding body that is affected by gravity.
    For more information on creating rectangles, refer to the *Applying primitives
    to a layer* recipe in [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*, or for more information on creating bodies, refer to
    the *Understanding different body types* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create the anti-gravity body and its connected rectangle. By overriding
    the anti-gravity rectangle''s `onManagedUpdate()` method, we can place code in
    it that will run after every engine update. In the case of our `AntiGravityRect`
    rectangle, we fill the `onManagedUpdate()` method with the `antigravityBody.applyForce()`
    method, passing the negated `mPhysicsWorld.getGravity()` method''s `x` and `y`
    values multiplied by `antigravityBody` body''s mass and finally set the force
    to be applied at the world center of `antigravityBody`. By using this force that
    is the exact opposite of the physics-world''s gravity within the `onManagedUpdate()`
    method, the anti-gravity body is corrected against the physics-world''s gravity
    after every update. Furthermore, the force that we apply must be multiplied by
    the body''s mass to fully compensate for the effects of gravity. Refer to the
    following diagram to better understand how anti-gravity bodies function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using forces, velocities, and torque* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with joints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Box2d, **joints** are used to connect two bodies so that each body is in
    some way attached to the other. The various types of joints make it possible to
    customize our characters, vehicles, and the world. Furthermore, joints can be
    created and destroyed during a simulation, which gives us endless possibilities
    for our games. In this recipe, we will create a line joint to demonstrate how
    joints are set up and used in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an activity following the steps in the *Introduction to the Box2D physics
    extension* section given at the beginning of the chapter. This activity will facilitate
    the creation of two bodies and a connecting line joint that we will use for this
    recipe. Refer to the `JointsActivity` class in the supplemental code for examples
    of more types of joints.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a line joint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the following variables within our activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `onPopulateScene()` method to create two rectangles
    and their associated bodies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place the following code after the code shown in the previous step to create
    a line joint that connects the bodies from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first define the two bodies, `LineJointBodyA` and `LineJointBodyB`, that
    will be connected to our line joint and the `boxFixtureDef` fixture definition
    that will be applied to the bodies. For more information about creating fixture
    definitions, refer to the *Introduction to the Box2D physics extension* recipe
    given at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we create the `LineJointRectA` rectangle using the `Rectangle()`
    constructor with a position of `228f` and `240f`, which places it in the middle
    of the left-half of our scene, and a height and width of `30f` to make it a small
    square. We then set its color to dark orange by calling the `LineJointRectA.setColor()`
    method with the parameters `0.5f`, `0.25f` and `0f`. Next, we create `LineJointRectA`
    rectangle's associated `LineJointBodyA` body by calling the `PhysicsFactory.createBoxBody()`
    constructor with the parameters `mPhysicsWorld`, which is our physics world, `LineJointRectA`,
    which is used to define the shape and position of the body, `BodyType` of `BodyType.KinematicBody`,
    and the `boxFixtureDef` fixture definition.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we handle the creation of `LineJointRectB` and `LineJointBodyB` in the
    same way that we created `LineJointRectA` and `LineJointBodyA`, but with the addition
    of the overridden `onManagedUpdate()` method in the creation of `LineJointRectB`
    and a `PhysicsConnector` class to connect `LineJointRectB` and `LineJointBodyB`.
    The overridden `onManagedUpdate()` method of `LineJointRectB` applies a large
    torque to `LineJointBodyB` by calling the `LineJointBodyB.applyTorque()` method
    with a value of `1000f`. After we apply the torque, we make sure that LineJointBodyB
    body's angular velocity does not exceed `0.2f` by passing `Math.min(LineJointBodyB.getAngularVelocity(),
    0.2f)` to the `LineJointBodyB.setAngularVelocity()` method. Finally, the `PhysicsConnector`
    class created and registered at the end of step two links `LineJointRectB` in
    our scene to `LineJointBodyB` in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we create our line joint. To initialize the line joint, we use
    the `lineJointDef.initialize()` method to which we pass the associated bodies,
    `LineJointBodyA` and `LineJointBodyB`. Then, we pass the world-based center of
    `LineJointBodyB` as the anchor point of the joint and `Vector2`, that contains
    the unit vector world axis of our joint. The world axis for our joint is set at
    `0f` and `1f`, which means zero movement on the x axis and a movement with a scale
    of `1f` on the y axis. We then tell the joint to allow collisions between the
    joint's bodies by setting the `lineJointDef.collideConnected` variable to `true`
    and enable the limit of the joint by setting the `lineJointDef.enableLimit` variable
    to `true`, which limits `LineJointBodyB` body's distance from the first. To set
    the lower distance limit of our joint, which represents how far from the joint
    that `LineJointBodyB` body can travel in the negative, we set the `lineJointDef.lowerTranslation`
    variable to `-220f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`. For the upper
    distance limit, we set the `lineJointDef.upperTranslation` variable to `0f` to
    keep `LineJointBodyB` from being forced above `LineJointBodyA`. Next, we enable
    the joint's motor by setting the `lineJointDef.enableMotor` variable to `true`,
    which will either pull or push `LineJointBodyB` toward or away from `LineJointBodyA`
    depending on the motor's speed. Lastly, we give the joint's motor a fast, negative
    speed by setting the `lineJointDef.motorSpeed` variable to `-200f` to move `LineJointBodyB`
    toward the `lowerTranslation` limit and give the motor a strong maximum force
    by setting the `lineJointDef.maxMotorForce` variable to `420f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line joint acts similarly to the suspension-and-wheel part of a car. It
    allows for constrained movement on an axis, usually vertical for vehicles, and
    allows the second body to rotate or act as a powered wheel if necessary. The following
    diagram illustrates the various components of the line joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All joints have two bodies and give us the option of allowing collision between
    those connected bodies. We enable the collision whenever we need it, but the default
    value of every joint's `collideConnected` variable is `false`. Furthermore, the
    second body of all joints should always be one with a `BodyType` type of `BodyType.DynamicBody`.
  prefs: []
  type: TYPE_NORMAL
- en: For any joints that have a frequency, which determines how elastically the joint
    behaves, never set the frequency to exceed more than half of the physics world
    timestep. If the timestep of the physics world is 40, the maximum value that we
    should assign as the frequency of our joints would be `20f`.
  prefs: []
  type: TYPE_NORMAL
- en: If either body connected to a joint is destroyed while the joint is active,
    the joint is also destroyed. This means that when we dispose of a physics world,
    we do not need to dispose of the joints within it as long as we destroy all of
    the bodies.
  prefs: []
  type: TYPE_NORMAL
- en: More joint types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The line joint is only one of several types of joints available for use in our
    physics simulations. The other types of joints are the distance, mouse, prismatic,
    pulley, revolute, and weld joints. Continue reading to learn more about each type.
    Refer to the supplemental `JointsActivity` class for a more in-depth example of
    each of the joint types.
  prefs: []
  type: TYPE_NORMAL
- en: '![More joint types](img/8987OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The distance joint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **distance joint** simply attempts to keep its connected bodies a certain
    distance from each other. If we do not set the length of the distance joint, it
    assumes the length to be the initial distance between its bodies. The following
    code creates a distance joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we initialize the distance joint by passing the two bodies to be
    connected, `DistanceJointBodyA` and `DistanceJointBodyB`, and the centers of the
    bodies, `DistanceJointBodyA.getWorldCenter()` and `DistanceJointBodyB.getWorldCenter()`,
    as the anchor points for the joint. Next, we set the length of the joint by setting
    the `distanceJointDef.length` variable to `3.0f`, which tells the joint that the
    two bodies should be 3 meters apart in the physics world. Finally, we set the
    `distanceJointDef.frequencyHz` variable to `1f` to force a small frequency for
    the spring of the joint and the `distanceJointDef.dampingRatio` variable to `0.001f`
    to produce a very small dampening effect for the connected bodies. For an easier
    understanding of what the distance joint looks like, refer to the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The mouse joint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **mouse joint** attempts to pull a body to a specific location, usually
    the location of a touch, using a set maximum force. It is a great joint for testing
    purposes, but for the release version of most games, we should opt for using a
    kinematic body with the appropriate code to move it to where a touch is registered.
    To understand how the mouse joint acts, reference the preceding diagram. The following
    code defines a mouse joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Unlike other joints, the mouse joint does not have an `initialize()` method
    to help set up the joint. We first create the `mouseJointDef` mouse joint definition
    and set the `mouseJointDef.bodyA` variable to `MouseJointBodyA` and the `mouseJointDef.bodyB`
    variable to `MouseJointBodyB` in order to tell the joint which bodies it will
    be linking. In all of our simulations, `MouseJointBodyA` should be an immobile
    body that does not move while the mouse joint is active.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the `mouseJointDef.dampingRatio` variable to `0.0f` to cause the
    joint to have absolutely no damping. We then set the `mouseJointDef.frequencyHz`
    variable to `1f` to force a slight frequency response whenever `MouseJointBodyB`
    has reached the mouse joint's target, which we can see being set in the following
    code. Finally, we set the `maxForce` variable of our `mouseJointDef to (100.0f
    * MouseJointBodyB.getMass())` method. The strong force of `100.0f` is multiplied
    by `MouseJointBodyB` body's mass to account for any changes in the mass of `MouseJointBodyB`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we initialized the mouse joint, but it should only be active
    after the simulation has started. To activate the mouse joint from within the
    `onSceneTouchEvent()` method of a class while the simulation is running, see the
    following code. Note that the `mouseJoint` variable, which is a mouse joint, is
    created at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the screen is first touched, which is determined by checking `pSceneTouchEvent.isActionDown()`,
    we set the initial mouse joint target using the `mouseJointDef.target.set()` method
    to the world center of `MouseJointBodyB` via the `MouseJointBodyB.getWorldCenter()`
    method. Then, we set the `mouseJoint` variable by creating the mouse joint definition
    in the physics world using the `MouseJoint` joint-casted `mPhysicsWorld.createJoint()`
    method with the `mouseJointDef` variable as the parameter. After the joint is
    created, we create `Vector2` from `Vector2Pool`, that holds the location of the
    scene's touch location, `pSceneTouchEvent.getX()` and `pSceneTouchEvent.getY()`,
    converted to physics-world coordinated by dividing the location by `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`.
  prefs: []
  type: TYPE_NORMAL
- en: We then change the `mouseJoint` joint's target variable to the previously created
    `Vector2` and recycle `Vector2` to `Vector2Pool`. While the touch is still active,
    determined by checking `pSceneTouchEvent.isActionMove()`, we update the target
    of the mouse joint using the same procedure that we used immediately after creating
    the mouse joint in the physics world. We call for `Vector2` from `Vector2Pool`,
    that is set to the physics world-converted touch location, set the target of the
    mouse joint to that `Vector2`, and then recycle `Vector2`. As soon as the touch
    is released, which is determined by checking `pSceneTouchEvent.isActionCancel()`,
    `pSceneTouchEvent.isActionOutside()`, or `pSceneTouchEvent.isActionUp()`, we destroy
    the mouse joint in the world by calling the `mPhysicsWorld.destroyJoint()` method
    with our `mouseJoint` variable as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![The mouse joint](img/8987OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The prismatic joint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **prismatic joint** allows its connected bodies to slide apart or together
    on a single axis, powered by a motor if necessary. The bodies have a locked rotation,
    so we must keep that in mind when designing a simulation that uses a prismatic
    joint. Consider the preceding diagram to grasp how this joint functions. The following
    code creates a prismatic joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After defining our `prismaticJointDef` variable, we initialize it using the
    `prismaticJointDef.initialize()` method and passing to it our connected bodies,
    `PrismaticJointBodyA` and `PrismaticJointBodyB`, the anchor point, which we declare
    to be the center of `PrismaticJointBodyA` in world coordinates, and the unit vector
    world axis of the joint in terms of a `Vector2` object, `Vector2(0f,1f)`. We disable
    collision between the bodies by setting the `prismaticJointDef.collideConnected`
    variable to `false` and then enable limits for the range of sliding of the joint
    by setting the `prismaticJointDef.enableLimit` variable to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: To set the limits of the joint, we set the `lowerTranslation` and `upperTranslation`
    properties to `-80f` and `80f` pixels, respectively, divided by `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    to convert the pixel limits to meters in the physics world. Finally, we enable
    the motor by setting the `prismaticJointDef.enableMotor` property to `true`, set
    its max force to `400f` via the `prismaticJointDef.maxMotorForce` property, and
    set its speed to a positive `500f` via the `prismaticJointDef.motorSpeed` property
    to drive `PrismaticJointBodyB` toward the upper-limit of the joint.
  prefs: []
  type: TYPE_NORMAL
- en: The pulley joint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **pulley joint** acts much like a realistic pulley—when one side descends,
    the other ascends. The length of the pulley joint is determined at initialization
    and should not be changed after creation. Refer to the preceding diagram to see
    what a pulley joint looks like. The following code creates a pulley joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After creating the `pulleyJointDef` variable, we initialize it via the `pulleyJointDef.initialize()`
    method. The first two parameters of the `pulleyJointDef.initialize()` method are
    the two connected bodies, `PulleyJointBodyA` and `PulleyJointBodyB`. The next
    two parameters are the ground anchors for the pulley, which in this case are `2.5f`
    meters above each body. To get the relative point above each body in world coordinates,
    we use the `getWorldPoint()` method of each of the bodies with an x parameter
    of `0` and a y parameter of `2.5` meters above each body. The fifth and sixth
    parameters of the `pulleyJointDef.initialize()` method are the anchor points of
    each body in world coordinates. We use the center in this simulation, so we pass
    the `getWorldCenter()` method of each of the connected bodies.
  prefs: []
  type: TYPE_NORMAL
- en: The final parameter of the method is the ratio of the pulley, `1f` in this case.
    A ratio of `2` would cause `PulleyJointBodyA` to move twice the distance from
    its ground anchor for every distance change of `PulleyJointBodyB` from its ground
    anchor. Furthermore, because the work required by `PulleyJointBodyA` to move in
    relation to its ground anchor would be half of the work that `PulleyJointBodyB`
    would take to move, `PulleyJointBodyA` would have more leverage than `PulleyJointBodyB`,
    causing `PulleyJointBodyA` to be more easily affected by gravity and thus acting
    to lift `PulleyJointBodyB` in a normal simulation. The last step in creating a
    pulley joint is to call the `mPhysicsWorld.createJoint()` method by passing to
    it our `pulleyJointDef` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![The pulley joint](img/8987OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The revolute joint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **revolute joint** is the most popular joint in Box2D simulations. It is
    essentially a pivot point between its two connected bodies with an optional motor
    and limits. See the previous diagram to help clarify how the revolute joint functions.
    The following code creates a revolute joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We first define the `revoluteJointDef` definition as a new `RevoluteJointDef()`
    method. Then, we initialize it using the `revoluteJointDef.initialize()` method
    with the parameters of `RevoluteJointBodyA` and `RevoluteJointBodyB` to connect
    the bodies and the `getWorldCenter()` method of `RevoluteJointBodyA` to define
    where the joint will rotate. Then, we enable our revolute joint's motor by setting
    the `revoluteJointDef.enableMotor` property to `true`. Next, we set the `maxMotorTorque`
    property to `5000f` to make the motor very strong and the `motorSpeed` property
    to `-1f` to make the motor spin clockwise at a very slow rate. Finally, we create
    the revolute joint in the physics world by calling `mPhysicsWorld.createJoint(revoluteJointDef)`
    to make the physics world create a revolute joint using our `revoluteJointDef`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The weld joint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **weld joint** bonds two bodies together and disables rotation between
    them. It is a useful joint for destructible objects, but larger destructible objects
    will occasionally fail due to jittering from Box2D''s iterative position solver.
    In such a case, we would create the object from multiple fixtures, and recreate
    each piece of the object, when detached, in the form of a new body. Refer to the
    previous diagram of the weld joint to better understand how it works. The following
    code creates a weld joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To create our weld joint, we first create a `WeldJointDef` definition named
    `weldJointDef`. Then, we initialize it by calling the `weldJointDef.initialize()`
    method with the body parameters of `WeldJointBodyA` and `WeldJointBodyB` to connect
    our bodies and the anchor point of the joint at the center of `WeldJointBodyA`
    body in world coordinates. The anchor point of a weld joint may seem like it could
    be placed anywhere, but because of how Box2D handles the anchor of weld joints
    during collision, we want to put it at the center location of one of the connected
    bodies. Doing otherwise can cause shearing or displacement of the joint when colliding
    with a body that has a large mass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rag doll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most popular depictions of characters in physics simulations is the
    rag doll. The visual look of such characters differs according to detail, but
    the underlying system is always the same—we just attach several physics bodies
    to a larger physics body via joints. In this recipe, we will create a rag doll.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Review the creation of a physics-based activity in the *Introduction to the
    Box2D physics extension* recipe, the creation of bodies in the *Understanding
    different body types* recipe, and the use of revolute joints and mouse joints
    in the *Working with joints* recipe, all found in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the supplemental `RagdollActivity` class for the code that we use in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to define the variables that represent the multiple bodies
    that make up our rag doll. Our bodies are the `headBody`, which represents the
    head, the `torsoBody`, which represents the torso, the `leftUpperarmBody` and
    `leftForearmBody`, representing the left arm, the `rightUpperarmBody` and `rightForearmBody`,
    representing the right arm, the `leftThighBody` and `leftCalfBody`, which represent
    the left leg, and finally the `rightThighBody` and `rightCalfBody`, which represent
    the right leg. The following diagram shows how all of our bodies will be linked
    together using revolute joints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we define the necessary variables used by our mouse joint to throw the
    rag doll when the screen is touched, the `Vector2 localMouseJointTarget` target
    for the mouse joint, the `mouseJointDef` mouse joint definition, the `mouseJoint`
    joint, and the ground body for the mouse joint, `MouseJointGround`. We then create
    the fixture definitions that we will apply to the various parts of our ragdoll—`headFixtureDef`
    for the head, `torsoFixtureDef` for the torso, `armsFixtureDef` for the arms,
    and `legsFixtureDef` for the legs. For more information on creating fixture definitions,
    refer to the *Introduction to the Box2D physics extension* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `onPopulateScene()` method, we create individual rectangles and
    their linked bodies, which are defined in the activity, for each body part of
    the rag doll. Each rectangle matches the exact location and size in which its
    corresponding body part is located As we create the bodies to be linked to the
    rectangles, we assign the appropriate fixture definition defined in the activity
    via the final parameter of the `PhysicsFactory.createBoxBody()` method. Finally,
    for each rectangle body group, we register a `PhysicsConnector` object with the
    physics world. For more information on creating bodies and `PhysicsConnector`
    objects, refer to the *Understanding different body types* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the many revolute joints that connect the body parts of our
    rag doll. The locations of the anchor points of each joint are where we want that
    body part to rotate, in world coordinates, passed via the final parameter of the
    `initialize()` method of each of the joint definitions. We make sure that each
    joint's connected bodies do not collide by setting the joint's `collideConnected`
    property to `false`. This does not keep the bodies from colliding with other portions
    of the rag doll, but it does allow the joint's bodies to overlap when rotating.
    Next, notice that we apply limits to the joint definitions to keep the body parts
    from moving beyond a set range of motion, much like the limits that humans have
    when moving their limbs. Not setting limits for the joints would create a rag
    doll that would allow complete rotation of its limbs, which is an unrealistic
    representation but necessary for some simulations. For more information on revolute
    joints, refer to the *Working with joints* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the revolute joints that represent the joints of our rag doll,
    we create the `mouseJointDef` mouse joint definition that will allow us to fling
    the rag doll around the scene. We attach the `headBody` body of our rag doll as
    the mouse joint's second body, but any of the bodies attached to the rag doll
    could be used depending on the simulation. Our final step in creating our rag
    doll is to set up the mouse joint for use at runtime via touch interactions passed
    by the `onSceneTouchEvent()` method of our activity. For more information on using
    mouse joints, refer to the *Working with joints* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with joints* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it is performance-intensive to simulate a realistic rope using Box2D,
    a simple rope is not only fast, but also very customizable. A rope, from a construction
    standpoint, is similar to a rag doll and can add an extra layer of playability
    to a game. If a physics simulation seems to be too bland to attract players, the
    addition of rope will be sure to give players another reason to like a game. In
    this recipe, we will create a physics-enabled rope for use in our simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Review the creation of a physics-based activity in the *Introduction to the
    Box2D physics extension* recipe, the creation of bodies in the *Understanding
    different body types* recipe, and the use of revolute joints and mouse joints
    in the *Working with joints* recipe, all found in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the supplemental `Rope` and `RopeActivity` classes for the code that
    we use in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A rope created in Box2D can be thought of as a chain of similar bodies linked
    together by joints. We can use either rectangular or circular bodies to define
    each section of a rope, but circular bodies will have less chance of catching
    onto and stretching from collision with other bodies. See the following diagram
    to get an idea of how we design a rope for a physics simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, refer to the `Rope` class, which will make it easier for us to create
    multiple ropes and fine-tune all of the ropes at once for our simulation. The
    initial code in the `Rope` class is a set of variables that reflect the specific
    properties of each rope. The `numRopeSegments` variable holds the number of segments
    that our rope will have. The `ropeSegmentsLength` and `ropeSegmentsWidth` variables
    hold the length and width that each segment of rope will have. Next, the `ropeSegmentsOverlap`
    variable represents how much each rope segment will overlap the previous rope
    segment, which prevents gaps during slight stretches. The `RopeSegments` array
    and `RopeSegmentsBodies` array define the rectangles and bodies for each segment
    of our rope. Finally, the `RopeSegmentFixtureDef` fixture definition will hold
    the fixture data that we will apply to each segment of the rope.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a constructor, named `Rope`, to handle the placement, detail,
    length, width, weight, and general creation of the rope. Then, we assign values
    to the variables created in the previous step. Notice that the `RopeSegmentFixtureDef`
    fixture definition starts with the maximum density. As each segment of the rope
    is created via the `for` loop later in the constructor, the density, and thus
    mass, of the fixture decrements to the minimum density. This prevents stretching
    by giving the highest body segments the most strength to hold the lower body segments.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the `Rope` constructor's `for` loop, we define the revolute
    joint for each rope segment. For more information on revolute joints, see the
    *Working with joints* recipe in this chapter. Then, we create the rectangle, `RopeSegments[i]`,
    that will represent the segment, checking to make sure that the first segment,
    when `i` is less than `1`, is placed according to the `pAttachTo` hinge passed
    in the constructor while the remaining segments are placed relative to their previous
    segment, `RopeSegments[i-1]`. The creation of the rectangles includes an overlap
    value, `ropeSegmentsOverlap`, to remove spacing in the rope caused by the iterative
    process of Box2D.
  prefs: []
  type: TYPE_NORMAL
- en: After we have created the segment's rectangle and set its color to brown by
    calling `RopeSegments[i].setColor(0.97f, 0.75f, 0.54f)`, we apply the density
    calculation to the `RopeSegmentFixtureDef` fixture definition and create a circular
    body based on the segment's rectangle using the `PhysicsFactory.createCircleBody()`
    method. For more information on creating bodies, refer to the *Understanding different
    body types* recipe in this chapter. We then set a moderate angular damping of
    each rope segment body via the `setAngularDamping(4f)` method and a slight linear
    damping via the `setLinearDamping(0.5f)` method to remove unpredictability in
    the rope's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we enable the rope segment to act as a bullet by setting the `RopeSegmentsBodies[i].setBullet`
    property to `true`, which reduces the chances of our segments slipping through
    colliding bodies. Finally, we create the revolute joint for the current rope segment
    in relation to the previous segment, or the hinge if the current segment is the
    first in the rope. For more information on revolute joints, refer to the *Working
    with joints* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For our activity class, we first create the variables necessary for our mouse
    joint, which will move the rope's hinge body to the touched location, and define
    our `RopeHingeBody` body that will act as the anchor point of the rope. Then,
    in the `onPopulateScene()` method, we create our `RopeHingeBody` body and, subsequently,
    our `rope` object, passing the rope-hinge body as the first parameter to the `Rope`
    constructor. For more information on creating bodies, refer to the *Understanding
    different body types* recipe in this chapter. The next parameters of the `Rope`
    constructor tell our rope to be `10` segments long, make each segment `25f` pixels
    long and `10f` pixels wide with an overlap of `2f` pixels, have a minimum density
    of `5f` and a maximum density of `50f`, and our `mScene` scene to which we attach
    the rope segment rectangles. The final two parameters of the `Rope` constructor
    tell the rope to create the segment bodies in our `mPhysicsWorld` physics world
    and to set each segment's rectangle to be managed by the activity's `VertexBufferObjectManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define and set up the variables used for our mouse joint. Take note
    that we set the `RopeHingeBody` body as the mouse joint's second body. Finally,
    we set up the `onSceneTouchEvent()` method to handle our mouse joint. For more
    information on mouse joints, refer to the *Working with joints* recipe in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with joints* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causing an effect to occur from the collisions between bodies, whether it is
    the playing of sound or the disposal of a body, is often a necessary part of a
    game based on a physics simulation. Handling collisions seems like an intimidating
    task at first, but it will become second nature after we learn how each part of
    the `ContactListener` interface functions. In this recipe, we will demonstrate
    how to handle collisions between fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    the creation of our simulation in which we will control collision behavior.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to demonstrate our control of collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following definitions at the beginning of the activity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To determine whether a specific body is contacted in the `ContactListener`
    interface, insert the following method in the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following method is similar to the previous method, but tests another body
    in addition to the first. Add it to the class after the previous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are going to create a dynamic body and a static body to test collisions.
    Place the following in the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to set the `ContactListener` property of the physics world. Add
    the following to the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the physics world may call the `ContactListener` interface multiple
    times per contact, we want to move all logic from the `ContactListener` interface
    to an update handler called once per engine update. Place the following in the
    `onPopulateScene()` method to complete our activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we define the rectangles and bodies that we will be using to visualize
    collisions. We also define several Boolean variables that will be changed depending
    on the results of the `ContactListener` interface. The final variable is the fixture
    definition used to create the collision-enabled bodies.
  prefs: []
  type: TYPE_NORMAL
- en: In steps two and three, we create two convenience methods, `isBodyContacted()`
    and `areBodiesContacted()`, that will make determining the presence of bodies
    in the `ContactListener` interface easier. Notice that the `if` statements in
    each of the methods check both of the fixtures against each body. Because of the
    way that the contact listener passes the `Contact` object, we cannot be certain
    which fixture will correlate with a certain body, so we must check both.
  prefs: []
  type: TYPE_NORMAL
- en: Step four creates the rectangles and bodies—one static and one dynamic—used
    in this simulation. We set the alpha of the rectangles using their `setAlpha()`
    method with a value of `0.5f` to demonstrate that contact is not currently occurring.
    The alpha of the rectangles is restored to opaque upon collision and set back
    to transparent after the collision has ended.
  prefs: []
  type: TYPE_NORMAL
- en: In step five, we set the physics world's contact listener by overriding the
    inherited methods. The first method, `beginContact()`, is called when a collision
    has occurred within the physics world. In that method, we first test that the
    collision actually involves the touching of two bodies by checking the `isTouching()`
    property of the `contact` parameter. Box2D considers a collision to start whenever
    the **AABB**, or bounding box, of two bodies overlap, not when the actual bodies
    touch. Refer to the next diagram to see how collisions and touching differ. After
    that, we check to see if both, or just one, of our bodies are involved in the
    collision. If so, we set our full-alpha Boolean variables to `true`. The next
    method, `endContact()`, is called when bodies are no longer colliding. If our
    bodies are involved in the collision that is ending, we set the half-alpha Boolean
    variables to `true`. The remaining methods in the contact listener are called
    either before or after the collision-correcting calculations have occurred. Because
    we simply want to test which bodies have collided, we do not need to use those
    two methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In step six, we create an update handler to remove the effective code from the
    `ContactListener` interface. It simply checks the Boolean values set within the
    `ContactListener` interface to determine which actions need to be taken after
    every engine update. After the correct actions have been taken, we reset the Boolean
    variables. The reason that we need to remove effectual code from the contact listener
    is that the contact listener can, and often is, called multiple times per collision.
    If we were to change the score of a game from inside the contact listener, the
    score would often change at a much greater magnitude than we intended. We could
    have a variable that checks whether a contact has already been handled, but the
    flow of such code becomes messy and eventually counter productive.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-solve and Post-solve in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using preSolve and postSolve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making use of the available data for a collision inside the contact listener's
    `presolve` method, which is called before the Box2D iterator causes a reaction,
    allows us to have unique control over how our collisions occur. The `preSolve()`
    method is most commonly used to create “one-way” platforms that a character can
    jump through from below while still being able to walk on them from above. The
    `postSolve()` method, which is called after a reaction has been set in motion,
    gives us the corrective data, also known as the **impact force**, for the collision.
    This data can then be used to destroy or break apart objects. In this recipe,
    we will demonstrate how to properly use the `preSolve()` and `postSolve()` methods
    of a `ContactListener` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new activity by following the steps in the *Introduction to the Box2D
    physics extension* section given at the beginning of the chapter. This new activity
    will facilitate our use of the `preSolve()` and `postSolve()` methods called within
    the contact listener.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the activity that demonstrates the use of these
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following definitions at the beginning of the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To determine which body or bodies are contacted, insert these methods into
    the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to test the collisions between a small, dynamic body and a larger,
    static body. Place the following code in the `onPopulateScene()` method to create
    such bodies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to set the contact listener for our physics world. Insert the
    following into the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to be able to move the smaller body by touching where we want it to
    move to. Add the following code to set up a mouse joint which will alow us to
    do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, insert the following in the `onSceneTouchEvent()` method to control
    the mouse joint created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first define a static body, a dynamic body, and a fixture definition that
    will be used to create the two bodies. Then, we create two methods that make managing
    collisions using the contact listener much easier. Next, we create the bodies
    using their associated rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In step four, we set the physics world's contact listener. Notice that we create
    a variable, `maxImpulse`, at the beginning of the contact listener for use in
    the `postSolve()` method at the end of the contact listener. For this simulation
    we have no use for the `beginContact()` and `endContact()` methods so we leave
    them empty. In the `preSolve()` method, we first test to determine if the contact
    is between our two bodies, `dynamicBody` and `staticBody`. If it is, we test if
    the `dynamicBody` body is below our `staticBody` body by checking if the `dynamicBody.getWorldCenter().y`
    property is less than the `staticBody.getWorldCenter().y` property, and if so,
    we cancel the collision. This allows the dynamic body to pass through the static
    body from below while still colliding with the static body from above.
  prefs: []
  type: TYPE_NORMAL
- en: In the `postSolve()` method, we test to ensure that we are only handling the
    dynamic and static bodies that we had defined previously. If so, we set the `maxImpulse`
    variable to the first impulse in the `impulse.getNormalImpulses()` array. This
    list holds the corrective impulses of all contacted points between the two colliding
    fixtures. Next, we step through the list of impulses and set the `maxImpulse`
    variable to either the current `maxImpulse` value or the current impulse value
    from the list, whichever is greater. This gives us the greatest corrective impulse
    in the collision, which we then use to spin the dynamic body if the impulsive
    force is great enough, an impulse of `400f` in this simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Step five initializes the mouse joint for dragging our dynamic body around the
    screen, and step six controls the mouse joint using the `onSceneTouchEvent()`
    method. Refer to *Working with joints* for more informaton on the mouse joint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with joints* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with collisions* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating destructible objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the impulse data from the `postSolve()` method in the physics world's
    contact listener gives us a force of impact for each collision. Extending that
    data to cause a multiple-body object to break apart simply involves determining
    which body collided and if the force was great enough to break the body from the
    multiple-body object. In this recipe, we will demonstrate the creation of a destructible
    object made from bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section at the beginning of the chapter. This activity will
    facilitate the creation of the destructible body groups that we will use in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a destructible object that breaks apart when it
    collides with a large force:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following definitions to the activity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To determine which body is contacted easier, insert this method into the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to create a physics object comprised of three boxes that are held
    together by weld joints. Define the following boxes in the `onPopulateScene()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place the following weld joint definitions in the `onPopulateScene()`
    method after the box definitions defined in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to set our physics world''s contact listener. Add the following
    code to the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, to remove the logic from the contact listener, place the following
    update handler in the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step one initially defines three bodies that we will link together with weld
    joints. Next, we define three Boolean variables that represent which body, if
    any, should be released from the group of bodies. Then, we define three weld joints
    that hold our bodies together and their respective Boolean values that represent
    whether the joint exists. Finally, we define a fixture definition from which we
    will create our three box bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Step two creates a method that allows us to determine if a particular body is
    involved in a collision, as also seen in the *Working with collisions* recipe.
    Step three creates our bodies, and step four creates the weld joints that attach
    them. Refer to the *Understanding different body types* recipe for more information
    about creating bodies, or the *Working with joints* recipe for more information
    on using joints.
  prefs: []
  type: TYPE_NORMAL
- en: In step five, we set the physics world's contact listener, creating only the
    `maxImpulse` variable and filling only the `postSolve()` method. In the `postSolve()`
    method, we determine if the force of the collision impulse is great enough to
    break the joints connected to a body. If it is, we determine which of the bodies
    should be broken off from the group and set the associated Boolean value for that
    body. After the `ContactListener` interface is set, we register an update handler
    to destroy the appropriate joints according to which bodies are flagged to be
    broken off. Because each of the three bodies is connected to the other two bodies,
    there are two joints to destroy for each body in the group. As we destroy the
    joints, we flag each destroyed joint as inactive so that we do not attempt to
    destroy an already destroyed joint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with joints* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using preSolve and postSolve* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raycasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Raycasting** via the physics world is a calculation that shoots an imaginary
    line from one point to another, and reports back with the distance, each encountered
    fixture, and the normal vector of each surface hit. Raycasts can be used for anything
    from lasers and vision cones to determining what an imaginary bullet hit. In this
    recipe, we will demonstrate raycasting within our physics world.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    our use of raycasting in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a raycasting demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following definitions at the beginning of the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we tell the physics world to perform a raycast, it will use a provided
    `callback` interface to allow us to make use of the information gathered by the
    raycast. Place the following `RayCastCallback` definition in the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To give our raycast something to impact, we will create a box in the physics
    world. Insert the following code snippet in the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will define the `Line` object that represents some of the information
    gathered from the raycast. Add the following to the `onPopulateScne()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we want the raycast to occur wherever we touch the scene. Place the
    following in the `onSceneTouchEvent()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first define a body, `BoxBody`, against which we will use the raycast. Then,
    we define several lines that will visually represent the raycast. Lastly, we define
    a series of variables that help us to determine the positioning and results of
    the raycast.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step two, we define a `RayCastCallback` interface, which we will pass to
    the physics world whenever we request it to calculate a raycast. In the callback,
    we use the overridden `reportRayFixture()` method. This method is called every
    time that a requested raycast encounters a new fixture. In the method, we use
    the raycast-returned point and normal variables to modify the position of our
    line that represents the normal line of the reported fixture''s hit surface. After
    setting the normal line to be visible, we determine the normal angle and then
    the bounce angle. We then position the bounce line to represent the bounce of
    the raycast and set the bounce line to be visible. Finally, we return `0` for
    the method to tell the raycast to terminate after hitting the first fixture. For
    a better understanding of the various parameters returned in a raycast callback,
    consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step three creates the body defined in step one and sets it to have a semi-random
    rotation by calling the `BoxBody.setTransform()` method with the last parameter
    of `MathUtils.random(0.349f, 1.222f)`, which orients the body to a rotation between
    `0.349` radians and `1.222` radians. Step four creates the visual lines that represent
    the various parts of the raycast. For more information on creating bodies, see
    the *Understanding different body types* recipe in this chapter, and for more
    information on lines, see [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: In step five, we assign the `onSceneTouchEvent()` method to handle our raycasting.
    When a touch occurs, we first set the `RayCastAngle` variable for use in the raycast's
    callback. Then, we position the main raycast line and set it to be visible while
    also setting the other lines associated with the raycast to be invisible. Lastly,
    we request a raycast from the physics world by passing our callback, the start
    position of the raycast, and the end position of the raycast. When the touch event
    has ended, we set the main raycast line to be invisible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
