- en: Chapter 4. Managing Your Android Testing Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 管理你的安卓测试环境
- en: Now that we have a complete understanding of the available Android testing SDK
    and have a nice range of testing recipes ready to assert and verify our app's
    behavior, it is time to provide different conditions to run our tests, explore
    other tests, or even use the application manually to understand what the end user
    experience would be.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完全理解了可用的安卓测试SDK，并且准备好了一系列测试食谱来断言和验证我们应用的行为，现在是提供不同的测试运行条件的时候了，探索其他测试，或者甚至手动使用应用程序来了解最终用户的体验会是什么样的。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating Android Virtual Devices (AVD) to provide different conditions and configurations
    for an application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建安卓虚拟设备（AVD）为应用程序提供不同的条件和配置
- en: Understanding the different configurations that we can specify while creating
    AVDs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在创建AVD时我们可以指定的不同配置
- en: How to run AVDs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行AVD
- en: How to create headless emulators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建无头模拟器
- en: Unlocking the screen to be able to run all the tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁屏幕以运行所有测试
- en: Simulating real-life network conditions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟现实生活中的网络条件
- en: Speeding up your AVD with HAXM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HAXM加速你的AVD
- en: Alternatives to the Android Virtual Device
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓虚拟设备的替代方案
- en: Running monkey to generate events to send to the application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行猴子程序以生成发送到应用程序的事件
- en: Creating Android Virtual Devices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安卓虚拟设备
- en: To have the best chance of detecting problems related to the device on which
    the application is running, you need the widest possible coverage of device features
    and configurations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大可能地检测到与应用程序运行设备相关的问题，你需要尽可能广泛的设备功能和配置覆盖。
- en: While final and conclusive tests should always be run on real devices, with
    the ever-increasing number of devices and form factors, it is virtually impossible
    that you will have one device of each to test your application. There are also
    device farms in the cloud to test on a variety of devices (Google for `cloud device
    testing`), but sometimes, their cost is above the average developer budget. Android
    provides a way of emulating, more or less verbatim, a great variety of features
    and configuration just for the convenience of different AVD configurations (an
    emulator).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最终和结论性的测试应该总是在真实设备上运行，但随着设备和外形尺寸的不断增加，实际上你不可能拥有每种设备来进行测试。云中也有设备农场，可以在各种设备上进行测试（搜索`cloud
    device testing`），但有时，它们的成本超出了普通开发者的预算。安卓提供了一种方式，通过不同的AVD配置（一个模拟器）几乎逐字地模拟大量功能和配置，以方便不同的配置。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the examples in this chapter are run from OSX 10.9.4 (Mavericks) 32 bit
    using Android SDK Tools 23.0.5 with platform 4.4.2 (API 20) installed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都是在OSX 10.9.4（Mavericks）32位系统上运行，使用Android SDK Tools 23.0.5和安装的平台4.4.2（API
    20）。
- en: To create an AVD, you can use the `android avd` command from a terminal, or
    from inside Android Studio, using **Tools** | **Android** | **AVD** **Manager**
    or its shortcut icon. If you run the AVD Manager from a terminal, you get a GUI
    that is slightly different than what you get by running from Android Studio, but
    they both do the same job. We're going to be using the AVD Manager from Android
    Studio as this is the most likely use case.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个AVD，你可以在终端使用`android avd`命令，或者在Android Studio内通过**工具** | **安卓** | **AVD管理器**或其快捷图标。如果你从终端运行AVD管理器，你会得到一个与从Android
    Studio运行稍微不同的GUI，但它们的功能相同。我们将使用Android Studio中的AVD管理器，因为这是最有可能的使用场景。
- en: 'By clicking on the icon, you can access the **AVD Manager**. Here, you press
    the **Create Device...** button to create a new AVD, and the following dialog
    box is presented:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击图标，你可以访问**AVD管理器**。在这里，你按下**创建设备...**按钮来创建一个新的AVD，会出现以下对话框：
- en: '![Creating Android Virtual Devices](img/00014.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![创建安卓虚拟设备](img/00014.jpeg)'
- en: Now, you can select a profile phone for the hardware (let's pick Nexus 5), hit
    **Next**, and select an Android version (KitKat x86). Hit **Next** again, and
    you get a summary of your device. You can click on **Finish** and you create the
    AVD using the default values. However, if you need to support specific configurations,
    you can specify different hardware properties. Let's change the AVD name to `testdevice`.
    Even more properties are available by using the **Show Advanced Settings** button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以为硬件选择一个配置手机（我们选择 Nexus 5），点击**下一步**，并选择一个安卓版本（KitKat x86）。再次点击**下一步**，你将看到设备的汇总信息。你可以点击**完成**，使用默认值创建AVD。然而，如果你需要支持特定的配置，可以指定不同的硬件属性。我们将AVD名称改为`testdevice`。通过使用**显示高级设置**按钮，还可以访问更多属性。
- en: 'A wide range of properties can be set. Some highlights are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置广泛的属性。一些亮点包括：
- en: Ram size / SD card size
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM大小/SD卡大小
- en: Emulate or use your webcam as front / back camera
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟或使用你的网络摄像头作为前后摄像头
- en: Change the network speed / simulate latency
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变网络速度/模拟延迟
- en: Setting the scale is also very useful to test your application in a window that
    resembles the size of a real device. It is a very common mistake to test your
    application in an AVD with a window size that is at least twice the size of a
    real device, and using a mouse pointer, believing that everything is fine, to
    later realize on a physical device with a screen of 5 or 6 inches that some items
    on the UI are impossible to touch with your finger.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设置比例也很有用，以便在类似于真实设备大小的窗口中测试你的应用程序。一个非常常见的错误是在至少是真实设备两倍大小的AVD窗口中测试应用程序，并使用鼠标指针，认为一切都没问题，然后在5或6英寸的物理设备屏幕上才意识到UI上的一些项目用手指是无法触摸的。
- en: Finally, it is also helpful to test your application under the same conditions
    repeatedly. To be able to test under the same conditions again and again, it is
    sometimes helpful to delete all the information that was entered in the previous
    sessions. If this is the case, ensure **Store a snapshot for faster startup**
    is unticked so as to start afresh every time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反复在相同条件下测试你的应用程序也很有帮助。为了能够反复在相同条件下进行测试，有时删除之前会话中输入的所有信息会很有帮助。如果是这种情况，请确保取消勾选**存储快照以加快启动速度**，以便每次都能从零开始。
- en: Running AVDs from the command line
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行AVD
- en: Wouldn't it be nice if we could run different AVDs from the command line and
    perhaps automate the way we run or script our tests?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以从命令行运行不同的AVD，或许还能自动化我们运行或脚本测试的方式，那不是很好吗？
- en: By freeing the AVD from its UI window, we open a whole new world of automation
    and scripting possibilities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将AVD从其UI窗口中释放出来，我们开启了一个全新的自动化和脚本编写可能性世界。
- en: Well, let's explore these alternatives.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来探索这些选项。
- en: Headless emulator
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无界面模拟器
- en: A headless emulator (its UI window is not displayed) comes in very handy when
    we run automated tests and nobody is looking at the window, or the interaction
    between the test runner and the application is so fast that we hardly see anything.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行自动化测试且无人查看窗口，或者测试运行器和应用程序之间的交互非常快以至于几乎看不到任何内容时，无界面模拟器（不显示其UI窗口）就非常方便。
- en: Also, it is worth mentioning that, sometimes, you can't understand why some
    tests fail until you see the interaction on the screen, so use your own judgment
    when selecting a running mode for your emulator.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，值得注意的是，有时直到你看到屏幕上的交互，才能理解某些测试为什么会失败，因此在选择模拟器的运行模式时，请根据自身判断来决定。
- en: One thing that we may have noticed while running AVDs is that their network
    communication ports are assigned at runtime, incrementing the last used port by
    `2` and starting with `5554`. This is used to name the emulator and set its serial
    number; for example, the emulator using port `5554` becomes `emulator-5554`. This
    is very useful when we run AVDs during the development process because we don't
    have to pay attention to port assignment. However, it can be very confusing and
    difficult to track which test runs on which emulator if we are running more than
    one simultaneously.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行AVD时，我们可能会注意到它们的网络通信端口是在运行时分配的，从`5554`开始，每次增加`2`。这被用来命名模拟器并设置其序列号；例如，使用端口`5554`的模拟器成为`emulator-5554`。这在开发过程中运行AVD时非常有用，因为我们不需要关注端口分配。然而，如果我们同时运行多个模拟器，这可能会导致混淆，难以追踪哪个测试在哪个模拟器上运行。
- en: In such cases, we will be specifying manual ports to keep the specific AVD under
    our control.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们将指定手动端口以保持对特定AVD的控制。
- en: Usually, when we are running tests on more than one emulator at the same time,
    not only do we want to detach the window, but also avoid sound output. We will
    add options for this as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们同时在一个以上的模拟器上运行测试时，不仅想要分离窗口，还希望避免声音输出。我们也会为此添加选项。
- en: 'The command line to launch the test AVD that we just created is as follows,
    and the port must be an integer between 5554 and 5584:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们刚刚创建的测试AVD的命令行如下，端口号必须是5554到5584之间的整数：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now check whether the device is in the device list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查设备是否在设备列表中：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to install the application and the tests:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装应用程序和测试：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we can use the specified serial number to run the tests on it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用指定的序列号在它上面运行测试：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Disabling the keyguard
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用键盘锁
- en: We can see the tests being run without them requiring any intervention and access
    to the emulator GUI.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到测试正在运行，而无需任何干预和访问模拟器 GUI。
- en: Sometimes, you might receive some errors for tests that are not failing if you
    run in a more standard approach, like in a standard emulator launched from your
    IDE. In such cases, one of the reasons is that the emulator might be locked at
    the first screen, and we need to unlock it to be able to run tests that involve
    the UI.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果你以更标准的方式运行测试，例如从 IDE 启动的标准模拟器，可能会收到一些测试未失败的错误。在这种情况下，其中一个原因是模拟器可能被锁定在第一屏，我们需要解锁才能运行涉及
    UI 的测试。
- en: 'To unlock the screen, you can use the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要解锁屏幕，你可以使用以下命令：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The lock screen can also be disabled programmatically. In the instrumentation
    test class, you should add the following code, most probably in `setup()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 锁屏也可以通过编程禁用。在仪器测试类中，你应当在 `setup()` 中添加以下代码，很可能是在此函数中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will dismiss the keyguard for these tests and has the added advantage of
    not needing any extra security permissions or changes to the app under test (which
    the deprecated alternative does, see [http://developer.android.com/reference/android/app/KeyguardManager.html](http://developer.android.com/reference/android/app/KeyguardManager.html)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为这些测试解除键盘锁，并且具有不需要任何额外安全权限或更改测试应用（已弃用的替代方法需要，见[http://developer.android.com/reference/android/app/KeyguardManager.html](http://developer.android.com/reference/android/app/KeyguardManager.html)）的优点。
- en: Cleaning up
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: 'On certain occasions, you also need to clean up services and processes that
    are started after running tests. This prevents the results of the latter from
    being influenced by the ending conditions of the previous tests. In these cases,
    it is always better to start from a known condition, freeing all the used memory,
    stopping services, reloading resources, and restarting processes, which is achievable
    by warm-booting the emulator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你还需要清理在运行测试后启动的服务和进程。这防止后者的测试结果受到之前测试结束条件的影响。在这些情况下，最好从已知条件开始，释放所有已使用的内存，停止服务，重新加载资源，并重新启动进程，这可以通过热启动模拟器来实现：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command line opens the emulator shell for our emulator, and runs the stop
    and start commands, or as people say, turning it off and on again.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令行为我们打开模拟器的 shell，并运行停止和启动命令，正如人们所说，是将其关闭再重新打开。
- en: 'The output of these commands can be monitored using the `logcat` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的输出可以通过使用 `logcat` 命令来监控：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will see messages like these:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下信息：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Terminating the emulator
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止模拟器
- en: 'Once we finish working with one of the headless emulator instances, we start
    using the command mentioned earlier. We use the following command line to kill
    it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成一个无头模拟器实例的工作后，我们开始使用之前提到的命令。我们使用以下命令行来杀死它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will stop the emulator from freeing the used resources and terminating
    the emulator process on the host computer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止模拟器在主机计算机上释放已使用的资源并终止模拟器进程。
- en: Additional emulator configurations
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的模拟器配置
- en: Sometimes, what we need to test is outside the reach of the options that can
    be set when the AVD is created or configured.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要测试的内容超出了创建或配置 AVD 时可以设置的选项范围。
- en: One of the cases could be the need to test our application under different locales.
    Let's say we want to test our application on a Japanese phone—an emulator, with
    the language and country set to Japanese and Japan respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个情况可能是需要测试我们的应用程序在不同的地区设置下的表现。假设我们想要在设置为日语和日本的模拟器上测试我们的应用程序，就像是在日本手机上一样。
- en: 'We have the ability to pass these properties in the emulator command line.
    The `-prop` command line option allows us to set any of the properties we could
    set:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模拟器命令行中传递这些属性。`-prop` 命令行选项允许我们设置可以在其中设置的任何属性：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To verify that our settings were successful, we can use the `getprop` command
    to verify them, for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的设置是否成功，我们可以使用 `getprop` 命令来验证它们，例如：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to clear all the user data after playing with the persistent settings,
    you can use the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在玩转持久设置后清除所有用户数据，你可以使用以下命令：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After this, the emulator will start afresh.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后，模拟器将会全新启动。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information and a list of available properties for setting the emulator
    hardware options can be found at [http://developer.android.com/tools/devices/managing-avds-cmdline.html#hardwareopts](http://developer.android.com/tools/devices/managing-avds-cmdline.html#hardwareopts).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于设置模拟器硬件选项的可选属性信息，可以在[http://developer.android.com/tools/devices/managing-avds-cmdline.html#hardwareopts](http://developer.android.com/tools/devices/managing-avds-cmdline.html#hardwareopts)找到。
- en: Simulating network conditions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟网络条件
- en: It is extremely important to test under different network conditions, but it
    is neglected more often than not. This can lead to misconceptions that the application
    behaves differently because we use the host network that presents a different
    speed and latency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的网络条件下进行测试至关重要，但往往被忽视。这可能导致误解，认为应用程序因为使用了不同速度和延迟的主机网络而表现出不同的行为。
- en: The Android emulator supports network throttling, for example, to support slower
    network speeds and higher connection latencies. This can be selected when you
    first create your AVD, but can also be done in the emulator at any time from the
    command line using the `-netspeed` `<speed>` and `-netdelay` `<delay>` options.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Android模拟器支持网络限速，例如，支持更慢的网络速度和更高的连接延迟。在创建AVD时可以选择，也可以随时通过命令行使用`-netspeed` `<speed>`和`-netdelay`
    `<delay>`选项在模拟器中进行设置。
- en: 'The complete list of supporting options is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的完整选项列表如下：
- en: 'For network speed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络速度：
- en: '| Option | Description | Speeds [kbits/s] |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 | 速度 [kbits/s] |'
- en: '| --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-netspeed gsm` | GSM/CSD | Up: 14.4, down: 14.4 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed gsm` | GSM/CSD | 上传：14.4，下载：14.4 |'
- en: '| `-netspeed hscsd` | HSCSD | Up: 14.4, down: 43.2 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed hscsd` | HSCSD | 上传：14.4，下载：43.2 |'
- en: '| `-netspeed gprs` | GPRS | Up: 40.0, down: 80.0 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed gprs` | GPRS | 上传：40.0，下载：80.0 |'
- en: '| `-netspeed edge` | EDGE/EGPRS | Up: 118.4, down: 236.8 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed edge` | EDGE/EGPRS | 上传：118.4，下载：236.8 |'
- en: '| `-netspeed umts` | UMTS/3G | Up: 128.0, down: 1920.0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed umts` | UMTS/3G | 上传：128.0，下载：1920.0 |'
- en: '| `-netspeed hsdpa` | HSDPA | Up: 348.0, down: 14400.0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed hsdpa` | HSDPA | 上传：348.0，下载：14400.0 |'
- en: '| `-netspeed full` | No limit | Up: 0.0, down: 0.0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed full` | 无限制 | 上传：0.0，下载：0.0 |'
- en: '| `-netspeed <num>` | Select both the upload and download speed | Up: as specified,
    down: as specified |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed <num>` | 选择上传和下载速度 | 上传：如指定，下载：如指定 |'
- en: '| `-netspeed <up>:<down>` | Select the individual up and down speed | Up: as
    specified, down: as specified |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `-netspeed <up>:<down>` | 选择单独的上传和下载速度 | 上传：指定速度，下载：指定速度 |'
- en: 'For latency:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于延迟：
- en: '| Option | Description | Delay [msec] |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 | 延迟 [msec] |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-netdelay` `gprs` | GPRS | Min 150, max 550 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `-netdelay` `gprs` | GPRS | 最小150，最大550 |'
- en: '| `-netdelay` `edge` | EDGE/EGPRS | Min 80, max 400 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `-netdelay` `edge` | EDGE/EGPRS | 最小80，最大400 |'
- en: '| `-netdelay` `umts` | UMTS/3G | Min 35, max 200 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `-netdelay` `umts` | UMTS/3G | 最小35，最大200 |'
- en: '| `-netdelay` `none` | No latency | Min 0, max 0 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `-netdelay` `none` | 无延迟 | 最小0，最大0 |'
- en: '| `-netdelay` `<num>` | Select exact latency | Latency as specified |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `-netdelay` `<num>` | 选择确切的延迟 | 延迟如指定 |'
- en: '| `-netdelay` `<min>:<max>` | Select min and max latencies | Minimum and maximum
    latencies as specified |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `-netdelay` `<min>:<max>` | 选择最小和最大延迟 | 最小和最大延迟如指定 |'
- en: 'If the values are not specified, the emulator uses the following default values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定值，模拟器将使用以下默认值：
- en: The default network speed is full
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认网络速度为无限制
- en: The default network latency is none
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认网络延迟为无延迟。
- en: 'This is an example of an emulator using these options to select the GSM network
    speed of 14.4 kbits/sec and a GPRS latency of 150 to 500 msecs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用这些选项选择GSM网络速度14.4 kbits/sec和GPRS延迟150至500毫秒的模拟器示例：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the emulator is running, you can verify these network settings or change
    them interactively using the Android console inside a Telnet client:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟器运行时，你可以通过Telnet客户端内的Android控制台验证这些网络设置或交互式更改它们：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After we are connected, we can type the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 连接之后，我们可以输入以下命令：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can use the emulator to test applications using network services either
    manually or in an automated way.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模拟器手动或自动测试使用网络服务的应用程序。
- en: In some cases, this not only involves throttling the network speed but also
    changing the state of the GPRS connection to investigate how the application behaves
    and copes with these situations. To change this status, we can also use the Android
    console in a running emulator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这不仅涉及限制网络速度，还涉及更改GPRS连接的状态，以研究应用程序如何应对这些情况。要更改此状态，我们也可以在正在运行的模拟器中使用Android控制台。
- en: 'For example, to unregister the emulator from the network, we can use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从网络注销模拟器，我们可以使用：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After receiving the **OK** subprompt, we can set the data network mode as unregistered
    by issuing the following command. This will turn off all data:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到**OK**子提示后，我们可以通过发出以下命令将数据网络模式设置为未注册。这将关闭所有数据：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After testing the application under this condition, you can connect it again
    by using the following command line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种条件下测试应用程序后，你可以通过使用以下命令行再次连接它：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To verify the status, you can use the following command lines:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证状态，你可以使用以下命令行：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Speeding up your AVD with HAXM
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HAXM加速你的AVD
- en: When using Android Virtual Devices, you'll notice that they aren't the most
    responsive of emulators. This is due to the fact that the AVD emulator does not
    support hardware GL, and so the GL code gets translated into ARM software, which
    gets run on hardware emulated by QEMU (QEMU is the hosted virtual machine monitor
    that AVDs run on top of). Google has been working on this problem, and now, efficient
    use of the host GPU is boosting speed (SDK 17). Responsiveness has improved on
    this and above levels of emulator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android虚拟设备时，你会注意到它们并不是最响应灵敏的模拟器。这是因为AVD模拟器不支持硬件GL，所以GL代码会被转换为ARM软件，并在由QEMU（AVD运行在顶层的托管虚拟机监控器）模拟的硬件上运行。Google一直在解决这个问题，现在，高效使用宿主GPU正在提高速度（SDK
    17）。在这个级别及以上的模拟器上，响应性已经得到了改善。
- en: Another speed boost can be gained by using Intel's Hardware Accelerated Execution
    Manager (HAXM). You can get a 5 to 10 times speed boost on your AVDs that run
    x86 as it will execute the CPU commands natively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Intel的硬件加速执行管理器（HAXM）可以获得另一个速度提升。如果你的AVD运行x86架构，使用HAXM可以获得5到10倍的速度提升，因为它可以本地执行CPU命令。
- en: HAXM works by allowing the CPU commands to be run on your hardware (that is
    your Intel CPU), whereas earlier, QEMU would be simulating the CPU, and all commands
    would be through software, which is why the original architecture is cumbersome.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: HAXM的工作原理是允许CPU命令在你的硬件上运行（即你的Intel CPU），而在此之前，QEMU会模拟CPU，所有命令都是通过软件执行的，这就是原始架构为何笨拙的原因。
- en: As per the requirements, you need to have an Intel-based processor with VT (Virtualization
    Technology) support and an x86-based emulator with minimum SDK 10 (Gingerbread).
    Intel claims that most Intel processors from 2005 onwards will support VT offloading
    as standard.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，你需要拥有支持VT（虚拟化技术）的Intel处理器和一个基于x86的模拟器，最低SDK版本为10（姜饼）。Intel声称，从2005年开始的大多数Intel处理器都将支持VT卸载作为标准。
- en: 'Installation is straightforward; download HAXM from the extras section of the
    Android SDK Manager, locate the downloaded file, and follow the installer instructions.
    You can clarify a successful installation by running this command from a terminal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 安装很简单；从Android SDK管理器的附加部分下载HAXM，找到下载的文件，并按照安装程序说明操作。你可以通过从终端运行以下命令来确认安装成功：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you get a message that contains `com.intel.kext.intelhaxm`, you've installed
    and can now run your speedy x86 emulator. There is nothing else you have to do,
    just ensure the CPU/ABI of your Android emulator is x86 and HAXM will be running
    in the background for you.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到包含`com.intel.kext.intelhaxm`的消息，说明你已经安装并可以运行你的快速x86模拟器了。你不需要做其他事情，只需确保你的Android模拟器的CPU/ABI是x86，HAXM就会在后台为你运行。
- en: Alternatives to the AVD
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVD的替代方案
- en: The Android Virtual Device is not your only way of running Android apps. There
    are now a few solutions you can choose from. A quick search on Google can bring
    up this list (I won't write it here as they can quickly get out of date). One
    of these that I personally recommend is the GenyMotion emulator. This is an Android
    emulator that uses x86 architecture virtualization to make it much more efficient.
    It runs much faster and smoother than the AVD. The downside being it is only free
    for personal use, and as of this writing, it does not emulate all the sensors
    of a device, but I know they are busy working on this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Android虚拟设备并不是你运行Android应用的唯一方式。现在有一些解决方案可供选择。在Google上快速搜索可以找到这个列表（我不在这里写出来，因为它们可能会很快过时）。我个人推荐的一个是GenyMotion模拟器。这是一个使用x86架构虚拟化来提高效率的Android模拟器。它比AVD运行得更快更流畅。缺点是它仅对个人使用免费，并且截至撰写本文时，它并不能模拟设备所有的传感器，但我知道他们正在忙于解决这个问题。
- en: Running monkey
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行monkey
- en: You might know about the infinite monkey theorem. This theorem states that a
    monkey that hits keys at random on a typewriter keyboard for an infinite amount
    of time will eventually type a given text, such as the complete works of William
    Shakespeare. The Android version of this theorem states that a monkey that produces
    random touches on a device could crash your application in, well, much less than
    an infinite amount of time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过无限猴子定理。这个定理指出，一个猴子在打字机上随机按键无限次，最终会打出一段给定的文本，比如威廉·莎士比亚的完整作品。Android 版本的这个定理则是说，一个在设备上产生随机触摸的猴子可能会在远少于无限的时间里让你的应用崩溃。
- en: With this, Android features a monkey application ([http://goo.gl/LSWg85](http://goo.gl/LSWg85))
    that will generate the random events instead of a real monkey.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Android 特性中包含一个猴子应用（[http://goo.gl/LSWg85](http://goo.gl/LSWg85)），它会生成随机事件，而不是使用真正的猴子。
- en: 'The simplest way to run monkey against our application to generate random events
    is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的应用程序运行猴子以生成随机事件的最简单方法是：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will be receiving this output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会接收到以下输出：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The monkey will send events only to the specified package (`-p`), in this case
    `com.blundell.tut`, in a very verbose manner (`-v` `-v`). The count of events
    sent will be 1000.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子将只向指定的包（`-p`）发送事件，在这种情况下是 `com.blundell.tut`，以非常详细的方式（`-v` `-v`）。发送的事件数量将是
    1000。
- en: The client-server monkey
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器猴子
- en: There is another way of running monkey. It also presents a client-server model
    that ultimately allows for the creation of scripts that control what events are
    sent and does not rely only on random generation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一种运行猴子命令的方法。它也提供了一个客户端-服务器模型，最终允许创建控制发送哪些事件的脚本，并不只依赖于随机生成。
- en: 'Usually, the port used by monkey is `1080`, but you can use another one if
    it better suits your preferences:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，猴子使用的端口是 `1080`，但如果你更喜欢，可以使用其他端口：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we need to redirect the emulator port:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要重定向模拟器的端口：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we are ready to send events. To do it manually, we can use a Telnet client:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备发送事件。要手动执行，我们可以使用 Telnet 客户端：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the connection is established, we can type the specific monkey command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接后，我们可以输入特定的猴子命令：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To finish, exit the telnet command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，退出 telnet 命令。
- en: 'If we need to exercise the application repeatedly, it is much more convenient
    to create a script with the commands we want to send. A monkey script could look
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要反复测试应用程序，创建一个包含我们想要发送的命令的脚本会方便得多。一个猴子脚本可能如下所示：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The API for monkey tap is `tap <x pixel position> <y pixel position>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: monkey tap 的 API 是 `tap <x 像素位置> <y 像素位置>`。
- en: Therefore, if you are not running an emulator with the same § resolution as
    the one your monkey command was recorded with, you could get incorrect touch events
    from your monkey.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你运行的模拟器与记录猴子命令的分辨率不同，你可能会得到错误的触摸事件。
- en: 'After having started the example application for this chapter, we can run this
    script to exercise the user interface. To start the application, you can use the
    emulator window and click on its launcher icon or use the command line that states
    the activity you want to start, which is the only alternative if the emulator
    is headless, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 启动本章的示例应用后，我们可以运行这个脚本来测试用户界面。要启动应用，你可以使用模拟器窗口并点击其启动图标，或者使用命令行指定要启动的活动，如果模拟器是无头模式，这将是唯一的选择，如下所示：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is informed in the log by this line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这在日志中由以下行通知：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the application has started, you can send the events using the script
    and the `netcat` utility:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，你可以使用脚本和 `netcat` 实用工具发送事件：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will send the events contained in the script file to the emulator. These
    are the following events:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将脚本文件中的事件发送到模拟器。这些事件包括：
- en: Touch and select the edit text input.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸并选择编辑文本输入。
- en: Type `Hello World`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Hello World`。
- en: Tap the button to show the toast.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮显示提示信息。
- en: Touch and select the edit text again.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次触摸并选择编辑文本。
- en: Delete its content.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除其内容。
- en: Type `Monkey`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Monkey`。
- en: Tap the button to show the toast **Hello Monkey**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮显示**Hello Monkey**的提示信息。
- en: In this manner, simple scripts that consist of touch events and key presses
    can be created.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，可以创建包含触摸事件和按键按下的简单脚本。
- en: Test scripting with monkeyrunner
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 monkeyrunner 进行测试脚本编写
- en: The possibilities of monkey are fairly limited, and the lack of flow control
    restricts its use to very simple cases.To circumvent these limitations, a new
    project was created, which was named monkeyrunner. Notwithstanding this, the name
    is almost the same and leads to a huge amount of confusion because they are not
    related in any way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey的能力相当有限，流程控制的缺失限制了其仅能用于非常简单的场景。为了绕过这些限制，创建了一个名为monkeyrunner的新项目。尽管如此，这个名字几乎相同，导致大量的混淆，因为它们之间没有任何关联。
- en: Monkeyrunner, which is already included in the latest versions of the Android
    SDK, is a tool that provides an API for the purpose of writing scripts that externally
    control an Android device or emulator.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Monkeyrunner，已包含在最新版本的Android SDK中，是一个提供API的工具，用于编写外部控制Android设备或模拟器的脚本。
- en: Monkeyrunner is built on top of Jython ([http://jython.org/](http://jython.org/)),
    a version of the Python programming language ([http://python.org/](http://python.org/)),
    which is designed to run on the Java platform.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Monkeyrunner构建于Jython之上 ([http://jython.org/](http://jython.org/))，这是Python编程语言的一个版本
    ([http://python.org/](http://python.org/))，设计在Java平台上运行。
- en: 'According to its documentation, the monkeyrunner tool provides these unique
    features for Android testing. These are just the highlights of the complete list
    of features, examples, and reference documentation that can be obtained from the
    monkeyrunner home page ([http://developer.android.com/tools/help/monkeyrunner_concepts.html](http://developer.android.com/tools/help/monkeyrunner_concepts.html)):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其文档，monkeyrunner工具为Android测试提供了以下独特的功能。这些只是可以从monkeyrunner主页获取的完整功能列表、示例和参考文档的亮点
    ([http://developer.android.com/tools/help/monkeyrunner_concepts.html](http://developer.android.com/tools/help/monkeyrunner_concepts.html))：
- en: '**Multiple device control**: The `monkeyrunner` API can apply one or more test
    suites across multiple devices or emulators. You can physically attach all the
    devices or start up all the emulators (or both) at once, connect to each one in
    turn programmatically, and then run one or more tests. You can also start up an
    emulator configuration programmatically, run one or more tests, and then shut
    down the emulator.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多设备控制**：`monkeyrunner` API可以在多个设备或模拟器上应用一个或多个测试套件。你可以物理连接所有设备或一次性启动所有模拟器（或两者兼有），然后以编程方式逐个连接到每个设备，并运行一个或多个测试。你也可以以编程方式启动模拟器配置，运行一个或多个测试，然后关闭模拟器。'
- en: '**Functional testing**: `monkeyrunner` can run an automated start-to-finish
    test of an Android application. You provide input values with keystrokes or touch
    events, and view the results as screenshots.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：`monkeyrunner`可以运行一个Android应用的自动化从头到尾的测试。你提供通过按键或触摸事件输入的值，并以截图的形式查看结果。'
- en: '**Regression testing**: `monkeyrunner` can test the application stability by
    running an application and comparing its output screenshots to a set of screenshots
    that are known to be correct.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：`monkeyrunner`可以通过运行应用并比较其输出截图与一组已知正确的截图来测试应用的稳定性。'
- en: '**Extensible automation**: Since `monkeyrunner` is an API toolkit, you can
    develop an entire system of Python-based modules and programs to control Android
    devices. Besides using the `monkeyrunner` API itself, you can use the standard
    Python OS and subprocess modules to call Android tools such as Android Debug Bridge.
    You can also add your own classes to the `monkeyrunner` API. This is described
    in more detail in the online documentation under Extending monkeyrunner with plugins.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展自动化**：由于`monkeyrunner`是一个API工具包，你可以开发一整套基于Python的模块和程序来控制Android设备。除了使用`monkeyrunner`
    API本身，你还可以使用标准的Python OS和subprocess模块调用Android工具，如Android调试桥。你还可以向`monkeyrunner`
    API添加自己的类。这在线文档的“使用插件扩展monkeyrunner”部分有更详细的描述。'
- en: Getting test screenshots
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取测试截图。
- en: Currently, one of the most evident uses of monkeyrunner is getting screenshots
    of the application under test to be further analyzed or compared.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，monkeyrunner最明显的用途之一是获取待测应用的截图以供进一步分析或比较。
- en: 'These screenshots can be obtained with the help of the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤获取这些截图：
- en: Import the required modules.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块。
- en: Create the connection with the device.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与设备建立连接。
- en: Check whether the device is connected.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查设备是否已连接。
- en: Start the activity.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动活动。
- en: Add some delay for the activity start up.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为活动启动添加一些延迟。
- en: Type 'hello'.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入'hello'。
- en: Add some delay to allow for the events to be processed.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些延迟以允许事件被处理。
- en: Obtain the screenshots.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取截图。
- en: Save it to a file.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存到文件中。
- en: Press **BACK** to exit the Activity.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**返回**退出活动。
- en: 'The following is the code for the script needed to perform the preceding steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行上述步骤所需的脚本代码：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once this script runs, you will find the screenshot of the activity in `/tmp/device.png`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本运行后，你可以在`/tmp/device.png`找到活动的截图。
- en: Record and playback
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录和回放
- en: If you need something simpler, there is no need to manually create these scripts.
    To simplify the process, the `monkey_recorder.py` script, which is included in
    the Android source repository in the SDK project ([http://goo.gl/6Qv0z0](http://goo.gl/6Qv0z0)),
    can be used to record event descriptions that are later interpreted by another
    script called `monkey_playback.py`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更简单的方法，无需手动创建这些脚本。为了简化这个过程，Android源代码仓库中的SDK项目中包含的`monkey_recorder.py`脚本可以用来记录事件描述，这些描述稍后会被另一个名为`monkey_playback.py`的脚本解释。
- en: 'Run `monkey_recorder.py` from the command line, and you will be presented with
    this UI:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行`monkey_recorder.py`，你将看到这个用户界面：
- en: '![Record and playback](img/00015.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![记录和回放](img/00015.jpeg)'
- en: 'This interface has a toolbar with buttons to insert different commands in the
    recorded script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界面有一个工具栏，工具栏上有按钮可以在记录的脚本中插入不同的命令：
- en: '| Button | Description |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 按钮名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Wait** | This denotes how many seconds to wait.This number is requested
    by a dialog box. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **等待** | 这表示需要等待多少秒。这个数字是通过一个对话框请求的。 |'
- en: '| **Press a Button** | This sends the **MENU**, **HOME**, **RECENTS**, and
    **SEARCH** buttons. Press the **Down** or **Up** event. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **按下按钮** | 这会发送**菜单**、**主页**、**最近应用**和**搜索**按钮。按下**向下**或**向上**事件。 |'
- en: '| **Type Something** | This sends a string. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **输入内容** | 这会发送一个字符串。 |'
- en: '| **Fling** | This sends a fling event in the specified direction, distance,
    and number of steps. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **滑动** | 这会在指定方向、距离和步数发送一个滑动事件。 |'
- en: '| **Export Actions** | This saves the script. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **导出动作** | 这会保存脚本。 |'
- en: '| **Refresh Display** | This refreshes the copy of the screenshot that is displayed.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **刷新显示** | 这会刷新显示的截图副本。 |'
- en: 'Once the script is completed, save it, let''s say as `script.mr`, and then,
    you can re-run it by using this command line:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成脚本后，保存它，假设文件名为`script.mr`，然后你可以使用以下命令行重新运行它：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, all the events will be replayed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的事件都将被重新播放。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered all the alternatives we had to expose our application
    and its tests to a wide range of conditions and configurations, ranging from different
    screen sizes, the availability of devices such as cameras or keyboards, to simulating
    real-life network conditions to detect problems in our application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了所有将我们的应用程序及其测试暴露于广泛条件和配置的替代方案，从不同的屏幕尺寸，到设备（如相机或键盘）的可用性，再到模拟真实网络条件以检测我们应用程序中的问题。
- en: We also analyzed all of the options we have in order to be able to control emulators
    remotely when they are detached from its window. This prepares the foundation
    of doing test first development, and we will come back to this topic in [Chapter
    6](part0061_split_000.html#page "Chapter 6. Practicing Test-driven Development"),
    *Practicing Test-driven Development*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分析了所有可用的选项，以便能够在模拟器脱离窗口时远程控制它们。这为进行测试优先开发奠定了基础，我们将在[第6章](part0061_split_000.html#page
    "第6章. 实践测试驱动开发")，*实践测试驱动开发*中回到这个话题。
- en: We discussed the speed of the AVD and saw how we can improve this, as well as
    looked at emulator choices in GenyMotion and HAXM. Finally, some scripting alternatives
    were introduced, and examples to get you started were provided.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了AVD的速度，并看到了如何改进这一点，以及如何在GenyMotion和HAXM中查看模拟器选择。最后，介绍了一些脚本编写替代方案，并提供了一些入门示例。
- en: In the next chapter, we will discover continuous integration—a way of working
    that relies on the ability to automatically run all the test suites and configure,
    start, and stop emulators in order to automate the complete build process.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索持续集成——一种依赖于自动运行所有测试套件以及配置、启动和停止模拟器以自动化完整构建过程的工作方式。
