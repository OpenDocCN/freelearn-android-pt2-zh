- en: Chapter 1. Activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a new activity with an intent object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data to another activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a result from an activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving an activity's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing persistent activity data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the activity lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android SDK provides a powerful tool to program mobile devices, and the
    best way to master such a tool is to jump right in. Though you can read this book
    from beginning to end, as it is a cookbook, it is specifically designed to allow
    you to jump to specific tasks and get the results immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activities** are the fundamental building block of most Android applications
    as the activity class provides the interface between the application and screen.
    Most Android applications will have at least one activity, if not several (but
    they are not required). A background service application will not necessarily
    require an activity if there is no user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how to *declare* and *launch* activities within an application
    and how to manage several activities at once by sharing data between them, requesting
    results from them, and calling one activity from within another.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also briefly explores the **intent** object, which is often used
    in conjunction with activities. Intents can be used to transfer data between activities
    in your own application, as well as in external applications, such as those included
    with the Android operating system (a common example would be to use an intent
    to launch the default web browser).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin developing Android applications, head over to the **Android Studio**
    page to download the new Android Studio IDE and the **Android SDK** bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities and other application components, such as **services**, are declared
    in the `AndroidManifest` XML file. Declaring an activity is how we tell the system
    about our activity and how it can be requested. For example, an application will
    usually indicate that at least one activity should be visible as a desktop icon
    and serve as the main entry point to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Studio is the new tool used to develop Android applications, replacing
    the now-deprecated **Eclipse ADT** solution. Android Studio will be used for all
    the recipes shown in this book, so if you have not already installed it, visit
    the Android Studio website (the link has been provided earlier) to install the
    IDE and the SDK bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this first example, we''ll guide you through creating a new project. Android
    Studio provides a **Quick Start** wizard, which makes the process extremely easy.
    Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Android Studio, which brings up the **Welcome to Android Studio** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start a new Android Studio project** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an application name; for this example, we have used `DeclareAnActivity`.
    Click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Add an Activity to Mobile** dialog, click on the **Blank Activity**
    button, and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Target Android Devices** dialog, chose **Android 6.0 (API 23)** as
    the minimum SDK (for this example, it really doesn't matter which API level you
    chose, as activities have existed since API level 1, but choosing the latest release
    is considered to be the best practice). Click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we chose the **Blank Activity** option earlier, the **Customize the Activity**
    dialog is shown. You can leave the defaults as provided, but note the default
    activity name is `MainActivity`. Click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After finishing the wizard, Android Studio will create the project files. For
    this recipe, the two files that we will examine are `MainActivity.java` (which
    corresponds to the activity name mentioned in Step 6) and `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the `MainActivity.java` file, you will realize that it''s
    pretty basic. This is because we chose the **Blank Activity** option (in Step
    4). Now look at the `AndroidManifest.xml` file. This is where we actually declare
    the activity. Within the `<application>` element is the `<activity>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When viewing this `xml` within Android Studio, you may notice that the label
    element shows the actual text as defined in the `strings.xml` resource file. This
    is just a small example of enhancements in the new IDE.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring an activity is a simple matter of declaring the `<activity>` element
    and specifying the name of the activity class with the `android:name` attribute.
    By adding the `<activity>` element to the **Android Manifest**, we are specifying
    our intention to include this component within our application. Any activities
    (or any other component for that matter) that are not declared in the manifest
    will not be included in the application. Attempting to access or utilize an undeclared
    component will result in an exception being thrown at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, there is another attribute—`android:label`. This attribute
    indicates the title shown on the screen as well as the icon label if this is the
    Launcher activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a complete list of available application attributes, take a look at this
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/guide/topics/manifest/activity-element.html](http://developer.android.com/guide/topics/manifest/activity-element.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new activity with an intent object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android application model can be seen as a service-oriented one, with activities
    as components and intents as the messages sent between them. Here, an intent is
    used to start an activity that displays the user's call log, but intents can be
    used to do many things and we will encounter them throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep things simple, we are going to use an intent object to start one of
    Android's built-in applications rather than create a new one. This only requires
    a very basic application, so start a new Android project with Android Studio and
    call it `ActivityStarter`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, to keep the example simple so that we can focus on the task at hand,
    we will create a function to show an intent in action and call this function from
    a button on our activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your new project is created in Android Studio, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.java` class and add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While you are typing this code, Android Studio will give this warning on View
    and intent: **Cannot resolve symbol ''Intent''**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This means that you need to add the library reference to the project. You can
    do this manually by entering the following code in the `import` section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alternatively, just click on the words (in the red font), hit *Alt* + *Enter*,
    and let Android Studio add the library reference for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `activity_main.xml` file and add the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/05057_01_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now it's time to run the application and see the intent in action. You will
    need to either create an Android emulator (in Android Studio, go to **Tools |
    Android | AVD Manager**) or connect a physical device to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you press the **Launch Browser** button, you will see the default web browser
    open with the URL specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though simple, this app demonstrates much of the power behind the Android OS.
    The intent object is just a message object. Intents can be used to communicate
    across your application's components (such as services and broadcast receivers)
    as well as with other applications on the device (as we did in this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test on a physical device, you may need to install drivers for your device
    (the drivers are specific to the hardware manufacturer). You will also need to
    enable Developer Mode on your device. Enabling Developer Mode varies according
    to the Android OS version. If you do not see the Developer Mode option in your
    device settings, open the **About Phone** option and begin tapping **Build Number**.
    After three taps, you should see a **Toast** message telling you that you are
    on your way to be a developer. Four more taps will enable the option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we created an intent object by specifying `ACTION_VIEW` as
    what we want to do (our intention). You may have noticed that when you typed `Intent`
    and then the period, Android Studio provided a pop-up list of possibilities (this
    is the autocomplete feature), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/05057_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`ACTION_VIEW`, along with a URL in the data, indicates that the intention is
    to view the website, so the default browser is launched (different data could
    launch different apps). In this example, our intent is just to view the URL, so
    we call the intent with just the `startActivity()` method. There are other ways
    to call the intent depending on our needs. In the *Returning a result from an
    activity* recipe, we will use the `startActivityForResult()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's very common for Android users to download their favorite apps for web browsing,
    taking photos, text messaging, and so on. Using intents, you can let your app
    utilize your user's favorite apps instead of trying to reinvent all of this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start an activity from a menu selection, refer to the *Handling menu selections*
    recipe in [Chapter 4](ch04.html "Chapter 4. Menus"), *Menus*.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often we will want to activate one activity from within another activity. Although
    this is not a difficult task, it will require a little more setting up to be done
    than the previous recipes as it requires two activities. We will create two activity
    classes and declare them both in the manifest. We'll also create a button, as
    we did in the previous recipe, to switch to the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create a new project in Android Studio, just as we did in the previous
    recipes, and call this one `ActivitySwitcher`. Android Studio will create the
    first activity, `ActivityMain`, and automatically declare it in the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the Android Studio New Project wizard has already created the first activity,
    we just need to create the second activity. Open the **ActivitySwitcher** project
    and navigate to **File** | **New** | **Activity** | **Blank** **Activity**, as
    shown in this screenshot:![How to do it...](img/05057_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Customize the Activity** dialog, you can leave the default **Activity
    Name** as it is, which is `Main2Activity`, or change it to `SecondActivity`, as
    shown here:![How to do it...](img/05057_01_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.java` file and add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `activity_main.xml` file located in the `\res\layout` folder
    and add the following XML to create the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can actually run the code at this point and see the second activity come
    up. We''re going to go further and add a button to `SecondActivity` to close it,
    which will bring us back to the first activity. Open the `SecondActivity.java`
    file and add this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the **Close** button to the `SecondActivity` layout. Open the
    `activity_second.xml` file and add the following `<Button>` element just after
    the `<TextView>` element that was generated automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application on your device or emulator and see the buttons in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The real work of this exercise is in the `onClickSwitchActivity()` method from
    Step 3\. This is where we declare the second activity for the intent using `SecondActivity.class`.
    We went one step further by adding the close button to the second activity to
    show a common real-world situation—launching a new activity, then closing it,
    and returning to the original calling activity. This behavior is accomplished
    in the `onClickClose()` function. All it does is call `finish()`, but that tells
    the system that we're done with the activity. Finish doesn't actually return us
    to the calling activity or any specific activity for that matter; it just closes
    the current activity and relies on the **back stack**. If we want a specific activity,
    we can again use the intent object (we just change the class name while creating
    the intent).
  prefs: []
  type: TYPE_NORMAL
- en: This activity switching does not make a very exciting application. Our activity
    does nothing but demonstrate how to switch from one activity to another, which
    of course will form a fundamental aspect of almost any application that we develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had manually created the activities, we would need to add them to the
    manifest. By using these steps, Android Studio has already taken care of the XML.
    To see what Android Studio did, open the `AndroidManifest.xml` file and look at
    the `<application>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note in the preceding autogenerated code is that the second activity
    does not have the `<intent-filter>` element. The main activity is generally the
    entry point when starting the application. That's why `MAIN` and `LAUNCHER` are
    defined—so that the system will know which activity to launch when the application
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about embedding widgets such as the Button, visit [Chapter 3](ch03.html
    "Chapter 3. Views, Widgets, and Styles"), *Views, Widgets, and Styles*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data to another activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intent object is defined as a messaging object. As a message object, its
    purpose is to communicate with other components of the application. In this recipe,
    we'll show you how to pass information with the intent and how to get it out again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will pick up from where the previous one ended. We will call this
    project `SendData`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since this recipe is building on the previous recipe, most of the work is already
    done. We''ll add an `EditText` element to the main activity so that we have something
    to send to `SecondActivity`. We''ll use the (autogenerated) `TextView` view to
    display the message. Here are the complete steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml`, remove the existing `<TextView>` element, and add
    the following `<EditText>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `<Button>` element that we created in the previous recipe doesn't change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open the `MainActivity.java` file and change the `onClickSwitchActivity()`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the `activity_second.xml` file and modify the`<TextView>` element
    to include the ID attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last change is to edit the second activity to look for this new data and
    display it on the screen. Open `SecondActivity.java` and edit `onCreate()` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the project. Type some text on the main activity and press **Launch
    Second Activity** to see it send the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As expected, the intent object is doing all the work. We created an intent just
    as in the previous recipe and then added some extra data. Did you notice the `putExtra()`
    method call? In our example, we used the already defined `Intent.EXTRA_TEXT` as
    the identifier, but we didn't have to. We can use any key we want (you've seen
    this concept before if you're familiar with name/value pairs).
  prefs: []
  type: TYPE_NORMAL
- en: The key point about using name/value pairs is that you have to use the same
    name to get the data back out. That's why we used the same key identifier when
    we read the extra data with `getStringExtra()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second activity was launched with the intent that we created, so it''s
    simply a matter of getting the intent and checking for the data sent along with
    it. We do this in `onCreate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We aren't limited to just sending `String` data. The intent object is very flexible
    and already supports basic data types. Go back to Android Studio and click on
    the `putExtra` method. Then hit *Ctrl* and the *Spacebar*. Android Studio will
    bring up the autocomplete list so that you can see the different data types that
    you can store.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a result from an activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to start one activity from another is all well and good, but we will
    often need to know how the called activity has fared in its task or even which
    activity has been called. The `startActivityForResult()` method provides the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returning a result from an activity is not very different from the way we just
    called the activity in the previous recipes. You can either use the project from
    the previous recipe, or start a new project and call it `GettingResults`. Either
    way, once you have a project with two activities and the code needed to call the
    second activity, you're ready to begin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only a few changes needed to get the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, open `MainActivity.java` and add the following constant to the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, change the way the intent is called by modifying the `onClickSwitchActivity()`
    method to expect a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add this new method to receive the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, modify `onClickClose` in `SecondActivity.java` to set the return value
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, getting the results back is relatively straightforward. We just
    call the intent with `startActivityForResult`, so it knows that we want a result.
    We set up the `onActivityResult()` callback handler to receive the results. Finally,
    we make sure that the second activity returns a result with `setResult()` before
    closing the activity. In this example, we are just setting a result with a static
    value. We just display what we receive to demonstrate the concept.
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice to check the result code to make sure that the user didn't
    cancel the action. It's technically an integer, but the system uses it as a boolean
    value. Check for either `RESULT_OK` or `RESULT_CANCEL` and proceed accordingly.
    In our example, the second activity doesn't have a cancel button, so why bother
    to check? What if the user hits the back button? The system will set the result
    code to `RESULT_CANCEL` and the intent to null, which will cause our code to throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We made use of the **Toast** object, which is a convenient pop-up **message**
    that can be used to unobtrusively notify the user. It also functions as a handy
    method for debugging as it doesn't need a special layout or screen space.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the result code, `onActivityResults()` also includes a **Request Code**.
    Are you wondering where that came from? It is simply the integer value that was
    passed with the `startActivityForResult()` call, which takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We didn't check the request code because we knew we had only one result to handle—but
    in trivial applications with several activities, this value can be used to identify
    where the request originated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `startActivityForResult()` is called with a negative request code, it will
    behave exactly as if it were a call to `startActivity()`—that is, it will not
    return a result.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about creating new activity classes, refer to the *Switching between
    activities* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about Toasts, check out the *Making a Toast* recipe in
    [Chapter 7](ch07.html "Chapter 7. Alerts and Notifications"), *Alerts and Notifications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving an activity's state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mobile environment is very dynamic, with users changing tasks much more
    often than on desktops. With generally fewer resources on a mobile device, it
    should be expected that your application will be interrupted at some point. It's
    also very possible that the system will shut down your app completely to give
    additional resources to the task at hand. It's the nature of mobiles.
  prefs: []
  type: TYPE_NORMAL
- en: A user might start typing something in your app, be interrupted by a phone call,
    or switch over to another app to send a text message, and by the time they get
    back to your app, the system may have closed it down completely to free up the
    memory. To provide the best user experience, you need to expect such behavior
    and make it easier for your user to resume from where they left off. The good
    thing is that the Android OS makes this easier by providing callbacks to notify
    your app of state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply rotating your device will cause the OS to destroy and recreate your activity.
    This might seem a bit heavy-handed, but it's done for good reason—it's very common
    to have different layouts for portrait and landscape, so this ensures that your
    app is using the correct resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you'll see how to handle the `onSaveInstanceState()` and `onRestoreInstanceState()`
    callbacks to save your application's state. We will demonstrate this by creating
    a counter variable and increment it each time the **Count** button is pressed.
    We will also have an `EditText` and a `TextView` widget to see their default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and name it `StateSaver`. We need only
    a single activity, so the autogenerated main activity is sufficient. However,
    we will need a few widgets, including `EditText`, `Button`, and `TextView`. Their
    layout (in `activity_main.xml`) will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of the counter, we need to add a global variable to the project,
    along with a key for saving and restoring. Add the following code to the `MainActivity.java`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add the code needed to handle the button press; it increments the counter
    and displays the result in the `TextView` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To receive notifications of application state change, we need to add the `onSaveInstanceState()`
    and `onRestoreInstanceState()` methods to our application. Open `MainActivity.java`
    and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program and try changing the orientation to see how it behaves (if you're
    using the emulator, *Ctrl* + *F11* will rotate the device).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All activities go through multiple states during their lifetime. By setting
    up callbacks to handle the events, we can have our code save important information
    before the activity is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is where the actual saving and restoring occurs. The system sends a **Bundle**
    (a data object that also uses name/value pairs) to the methods. We use the `onSaveInstanceState()`
    callback to save the data and pull it out in the `onRestoreInstanceState()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! Did you try typing text in the `EditText` view before rotating the
    device? If so, you'd have noticed that the text was also restored, but we don't
    have any code to handle that view. By default, the system will automatically save
    the state, provided it has a unique ID (not all views automatically have their
    state saved, such as the `TextView`, but we can manually save it if we want).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you want Android to automatically save and restore the state of
    a view, it must have a unique ID (specified with the `android:id=` attribute in
    the layout). Beware; not all view types automatically save and restore the state
    of a view.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `onRestoreInstanceState()` callback is not the only place where the state
    can be restored. Look at the signature of `onCreate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Both methods receive the same `Bundle` instance named `savedInstanceState`.
    You could move the restore code to the `onCreate()` method and it would work the
    same. But one catch is that the `savedInstanceState` bundle will be null if there
    is no data, such as during the initial creation of the activity. If you want to
    move the code from the `onRestoreInstanceState()` callback, just check to make
    sure that the data is not null, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Storing persistent activity data* recipe will introduce persistent storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at [Chapter 6](ch06.html "Chapter 6. Working with Data"), *Working
    with Data*, for more examples on Android activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding the activity lifecycle* recipe explains the Android Activity
    Lifecycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing persistent activity data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to store information about our activities on a temporary basis is
    very useful, but more often than not, we will want our application to remember
    information across multiple sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Android supports SQLite, but that could be a lot of overhead for simple data,
    such as the user's name or a high score. Fortunately, Android also provides a
    lightweight option for these scenarios, with `SharedPreferences`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can either use the project from the previous recipe or start a new project
    and call it `PersistentData` (in a real-world application, you'll likely be doing
    both anyway). In the previous recipe, we saved `mCounter` in the session state.
    In this recipe, we'll add a new method to handle `onPause()` and save `mCounter`
    to `SharedPreferences`. We'll restore the value in `onCreate()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only two changes to make, and both are in `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `onPause()` method to save the data before the activity closes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add the following code at the end of `onCreate()` to restore the counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, this is very similar to saving state data, because it also uses
    name/value pairs. Here, we just stored an `int`, but we can just as easily store
    one of the other primitive data types. Each data type has equivalent getters and
    setters, for example, `SharedPreferences.getBoolean()` or `SharedPreferences.setString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our data requires the services of `SharedPreferences.Editor`. This is
    evoked with `edit()` and accepts `remove()` and `clear()` procedures as well as
    setters such as `putInt()`. Note that we must conclude any storing that we do
    here with the `commit()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a slightly more sophisticated variant of the `getPreferences()` accessor:
    `getSharedPreferences()`. It can be used to store multiple preference sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Using more than one preference file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `getSharedPreferences()` is no different from using its counterpart,
    but it allows for more than one preference file. It takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, `name` is the file. The `mode` can be either `MODE_PRIVATE`, `MODE_WORLD_READABLE`,
    or `MODE_WORLD_WRITABLE` and describes the file's access levels.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Working with Data"), *Working with Data*,
    for more examples on data storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the activity lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android OS is a dangerous place for an activity. The demand for resources
    on a battery-operated platform is managed quite ruthlessly by the system. Our
    activities can be dumped from memory when it's running low, without even a moment's
    notice and along with any data they contain. Therefore, it is essential to understand
    the activity lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the stages through which an activity passes during
    its lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the activity lifecycle](img/05057_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Along with the stages, the diagram also shows the methods that can be overridden.
    As you can see, we've already utilized most of these methods in the preceding
    recipes. Hopefully, getting the big picture will help in your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio with a **Blank Activity**, and call it
    `ActivityLifecycle`. We will use the (autogenerated) `TextView` method to display
    the state information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the application move through the various stages, we will create methods
    for all the stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml` and add an ID to the autogenerated `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The remaining steps will be in `MainActivity.java`. Add the following global
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `onCreate()` method to save `TextView` and set the initial text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods to handle the remaining events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application and observe what happens when the activity is interrupted
    by pressing the Back and Home keys. Try other actions, such as task switching,
    to see how they impact your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our activity can exist in one of these three states: **active**, **paused**,
    or **stopped**. There is also a fourth state, **destroyed**, but we can safely
    ignore it:'
  prefs: []
  type: TYPE_NORMAL
- en: An activity is in the `active` state when its interface is available for the
    user. It persists from `onResume()` until `onPause()`, which is brought about
    when another activity comes to the foreground. If this new activity does not entirely
    obscure our activity, then ours will remain in the `paused` state until the new
    activity is finished or dismissed. It will then immediately call `onResume()`
    and continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a newly started activity fills the screen or makes our activity invisible,
    then our activity will enter the `stopped` state, and the resumption will always
    invoke a call to `onRestart()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an activity is in either the `paused` or `stopped` state, the operating
    system can (and will) remove it from the memory when the memory is low or when
    other applications demand it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is worth noting that we never actually see the results of the `onDestroy()`
    method, as the activity is removed by this point. If you want to explore these
    methods further, then it is well worth employing `Activity.isFinishing()` to see
    whether the activity is really finishing before `onDestroy()` is executed, as
    seen in the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When implementing these methods, always call the superclass before doing any
    work.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shutting down an activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To shut down an activity, directly call its `finish()` method, which in turn
    calls `onDestroy()`. To perform the same action from a child activity, use `finishFromChild(Activity
    child)`, where `child` is the calling subactivity.
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful to know whether an activity is being shut down or merely
    paused, and the `isFinishing(boolean)` method returns a value that indicates which
    of these two states the activity is in.
  prefs: []
  type: TYPE_NORMAL
