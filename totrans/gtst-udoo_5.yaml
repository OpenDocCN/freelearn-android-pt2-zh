- en: Chapter 5. Managing Interactions with Physical Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 管理与物理组件的交互
- en: Electronic devices have changed our life. We are surrounded by quite a few invisible
    objects that collect and eventually compute environment data. Like we saw in the
    previous chapter, these devices use sensors to retrieve information and we can
    find them in our everyday life, for example, in our car, when we're walking through
    supermarkets' sliding doors, and maybe when we're coming back to home.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 电子设备改变了我们的生活。我们被许多看不见的物体所包围，它们收集并最终计算环境数据。正如我们在上一章所看到的，这些设备使用传感器来获取信息，并且我们可以在日常生活中找到它们，例如在我们的汽车中，当我们穿过超市的滑动门时，或者当我们回到家时。
- en: We can inspire ourselves looking at these things and build amazing physical
    applications that are capable of reacting to the environment and, indirectly,
    to the people around. However, if our project expects a direct human interaction,
    we may need to manage this interaction with physical components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些事物中汲取灵感，构建能够对环境和周围的人做出反应的惊人的物理应用。然而，如果我们的项目需要直接的与人交互，我们可能需要使用物理组件来管理这种交互。
- en: The goal of this chapter is to build a web radio that uses built-in Android
    APIs to manage Internet streams, while all interactions are managed by physical
    components, such as in the old fashioned radios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是构建一个使用内置 Android API 管理网络流的网络收音机，同时所有交互都由物理组件管理，就像旧式收音机一样。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Managing user interactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户交互
- en: Building a web radio with physical interactions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理交互构建网络收音机
- en: Sending multiple data with Arduino
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Arduino 发送多个数据
- en: Writing an Android application for audio streaming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写用于音频流的 Android 应用程序
- en: Managing user interactions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户交互
- en: 'One aspect that distinguishes an interactive prototype is the capability to
    react to any action made by users. As we''ve seen in the previous chapter, sensors
    are one of the most important building blocks to achieve this important goal.
    However, sometimes, we want to provide a physical interaction where users are
    capable of altering the application''s behavior with their hands, despite the
    presence of sensors. These parts that are still largely diffused, are simple **mechanic**
    or **electronic** components that convert analog movements into digital values
    that our microcontroller can use to alter the program flow. There are a lot of
    components that we may use to interact with our device: **push buttons**, **switch
    buttons**, **joysticks**, **knobs**, **pedals**, and **levers**, are just examples
    of these kind of components.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 区分交互式原型的其中一个方面是能够对用户的任何操作做出反应。正如我们在上一章所看到的，传感器是实现这一重要目标的最重要构建块之一。然而，有时我们希望提供一个物理交互，让用户能够通过双手改变应用程序的行为，尽管存在传感器。这些仍然广泛使用部分是简单的**机械**或**电子**组件，它们将模拟动作转换为微控制器可以用来改变程序流程的数字值。有许多我们可以用来与设备交互的组件：**按钮**、**开关按钮**、**操纵杆**、**扭钮**、**踏板**和**杠杆**，这些只是这类组件的例子。
- en: Knobs are components that we can use to alter some prototype configurations.
    Indeed, we may create a maintenance console that alters some device constants
    to prevent the recompilation and upload phase of a new sketch. At other times,
    knobs are used to make direct actions and their usage is an active part of the
    users interactions. A common use of knobs is related to electrical devices, such
    as volume controls in audio equipment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 扭钮是我们用来调整一些原型配置的组件。实际上，我们可以创建一个维护控制台，通过改变某些设备常数以避免新草图的重编译和上传阶段。在其他时候，扭钮用于直接操作，其使用是用户交互活动的积极部分。扭钮的常见用途与电器设备相关，例如音频设备中的音量控制。
- en: Another example could be related to robot rovers, when we want to provide direct
    control for users instead of the robot's own artificial intelligence. In this
    case, we may use a push button that facilitates the stopping action while activating
    a manual mode. For instance, we could provide a joystick that can be used to pilot
    the rover movements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是与火星车有关，当我们希望为用户提供直接控制而不是依靠机器人自身的人工智能时。在这种情况下，我们可以使用一个按钮来方便地激活停止动作并切换到手动模式。例如，我们可以提供一个操纵杆，用于控制火星车的移动。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An example of the usage of push buttons is related to stopping any actions made
    by the microcontroller or the prototype. This use of push buttons is called **emergency
    stop** and it's used in many DIY projects when they are fully automated and equipped
    with moving parts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的一个使用例子与停止微控制器或原型所做的任何动作相关。这种按钮的使用称为**紧急停止**，在许多全自动且配备有活动部件的DIY项目中都会用到。
- en: 'All these elements have two base components in common: **switches** and **potentiometers**.
    Push buttons are good examples of mechanical switches that close or open a circuit
    and control the current flow through the microcontroller pins. In this way, we
    may activate a particular functionality of our circuit like we did in [Chapter
    3](ch03.html "Chapter 3. Testing Your Physical Application"), *Testing your Physical
    Application*, according to the detected voltage.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些元素都有两个基本组件：**开关**和**电位计**。按钮是机械开关的好例子，它们可以关闭或打开电路，并通过微控制器引脚控制电流流。这样，我们可以根据检测到的电压激活电路的特定功能，就像在[第3章](ch03.html
    "第3章.测试您的物理应用")，*测试您的物理应用*中所做的那样。
- en: Potentiometers, instead, are electronic components, more like resistors. The
    electronic part is composed of three terminal legs that we can use in different
    ways to change the purpose of the potentiometer. Indeed, if we connect one end
    and the central leg to a component, it acts as a **variable resistor**. On the
    other hand, if we use all three terminals, it works like an adjustable **voltage
    divider**. The *shaft* of a potentiometer that we can turn from one direction
    to the other, is used to change the value of the resistor or the voltage divider.
    Good examples of the application of potentiometers are knobs, joysticks, and guitar
    pedals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，电位计是电子元件，更像是电阻器。电子部分由三个终端腿组成，我们可以用不同的方式使用它们来改变电位计的目的。实际上，如果我们将一端和中间腿连接到一个组件，它就像一个**可变电阻器**。另一方面，如果我们使用所有三个终端，它就像一个可调节的**分压电路**。我们可以从一个方向转到另一个方向的电位计的*轴*，用于改变电阻器或分压电路的值。电位计应用的好例子有旋钮、操纵杆和吉他踏板。
- en: Building a web radio with physical interaction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带物理交互的构建网络收音机
- en: Microcontrollers aren't designed for complicated work, so we need to be careful
    to partition the needs of our project to the right environments. For a web radio,
    we can use the microcontroller to read the knobs and switches, and let the Android
    APIs and UDOO's powerful CPU do the rest. This will keep Android from getting
    distracted while reading the hardware, and will prevent the microcontroller from
    getting overloaded with the complications of network streaming and playback.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器并非为复杂工作而设计，因此我们需要小心地将项目的需求分配到正确的环境中。对于网络收音机，我们可以使用微控制器读取旋钮和开关，让Android API和UDOO强大的CPU处理其余工作。这将防止Android在读取硬件时分心，并防止微控制器因网络流和播放的复杂性而过载。
- en: 'The first part of our prototype is to build a circuit and write a sketch that
    collects values from two potentiometers and a push button:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原型的第一部分是构建一个电路并编写一个草图，从两个电位计和一个按钮收集值：
- en: We use the first potentiometer to change the active radio station and to increase
    or decrease the audio volume
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用第一个电位计来更改活动电台并增加或减少音量
- en: We use the physical button to control the radio playback
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用物理按钮来控制收音机的播放
- en: In this way, we're removing all interactions done through the Android user interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就移除了所有通过Android用户界面进行的交互。
- en: 'As the first step, grab two potentiometers and connect them to the board so
    that we can realize the following circuit:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，拿两个电位计并将它们连接到板上，这样我们就可以实现以下电路：
- en: '![Building a web radio with physical interaction](img/1942OS_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![带物理交互的构建网络收音机](img/1942OS_05_01.jpg)'
- en: 'Follow the procedure given below to get the circuit connected to the potentiometer,
    as shown in the preceding schema:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的步骤将电路连接到电位计，如前面的原理图所示：
- en: Put two potentiometers on the right of your breadboard, because we need to use
    the free slots on the left for the push button.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的面包板右侧放置两个电位计，因为我们需要在左侧的自由插槽中使用按钮。
- en: Connect the UDOO +3.3V pin to the positive line of the power bus. Be sure not
    to connect the +5V power pin because it may damage the analog input pins during
    future connections.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOO +3.3V引脚连接到电源总线的正线。确保不要连接+5V电源引脚，因为未来连接时可能会损坏模拟输入引脚。
- en: Connect the UDOO ground to the negative line of the power bus.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOO地线连接到电源总线的负线。
- en: Connect the left terminal of the first potentiometer to the negative line of
    the power bus.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个电位计的左端子连接到电源总线的负线。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Potentiometers act like resistors, so there aren't any differences if you connect
    the wrong positive terminal. The only side effect is that the detected values
    will not start from a range [0-1023] but from [1023-0]. If you notice that, *invert
    these connections*.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电位计就像电阻一样，如果你连接了错误的正极端子，不会有任何区别。唯一的副作用是检测到的值将从[0-1023]范围变为[1023-0]。如果你注意到这一点，*请反转这些连接*。
- en: Connect the right terminal of the first potentiometer to the positive line of
    the power bus.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个电位计的右端子连接到电源总线的正线。
- en: Connect the middle terminal to the analog input A0.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将中间端子连接到模拟输入A0。
- en: Repeat points 4, 5, 6 for the second potentiometer and connect its middle terminal
    to the analog input A1.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对第二个电位计重复步骤4、5、6，并将其中间端子连接到模拟输入A1。
- en: With this circuit, we use both potentiometers as voltage dividers and when we
    turn the shaft, the microcontroller notices a change in the voltage output and
    transforms this value in to a numeric range [0-1023]. This circuit is really similar
    to the one built in the previous chapter to create a light sensor, but since the
    potentiometer already has a resistor in its package, we don't need any other electric
    components to keep it working.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个电路，我们使用两个电位计作为电压分压器，当我们转动轴时，微控制器注意到电压输出的变化，并将这个值转换成数值范围[0-1023]。这个电路与之前章节中构建的光传感器电路非常相似，但由于电位计已经在其包装内包含了一个电阻，我们不需要任何其他电子组件来保持其工作。
- en: 'Now we need a push button to start and stop the playback. We have to add the
    component on the left of the breadboard and connect it to UDOO as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个按钮来开始和停止播放。我们需要在面包板的左侧添加组件，并按以下方式连接到UDOOboard：
- en: '![Building a web radio with physical interaction](img/1942OS_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用物理交互构建网络收音机](img/1942OS_05_02.jpg)'
- en: 'Follow the given steps to connect the components, as shown in the preceding
    schema:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的步骤连接组件，如前图所示：
- en: Connect the left terminal of the push button to the positive line of the power
    bus.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的左端子连接到电源总线的正线。
- en: Connect the right terminal to the negative line of the power bus using 10 KOhm
    resistor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用10 KOhm电阻将右端子连接到电源总线的负线。
- en: Connect the right terminal to pin 12 of the UDOO board.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将右端子连接到UDOOboard的12号引脚。
- en: With this circuit, we can read the value of the push button using pin 12 of
    the UDOO board; when the button is pressed, we can change an internal state of
    the microcontroller.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个电路，我们可以使用UDOOboard的12号引脚读取按钮的值；当按下按钮时，我们可以改变微控制器的内部状态。
- en: 'Now that we have a circuit with all the required components, we have to start
    a new sketch and prepare a function that we can use to collect all data. The goal
    of the sketch is to prepare a **triple** that has the *playback status*, the *volume*
    and the *station* as ordered values. This approach simplifies our work later when
    we start communication with the Android application. We can start to write the
    new sketch as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了所有必需组件的电路，我们就必须开始一个新的草图，并准备一个函数来收集所有数据。草图的目标是准备一个包含*播放状态*、*音量*和*电台*的有序值的**三元组**。这种方法简化了稍后与Android应用程序通信时的工作。我们可以按照以下方式开始编写新草图：
- en: 'Define the connections at the top of the sketch:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图顶部定义连接：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are using pin 12 for the play button, the input A0 for the volume, and the
    input A1 to change the current station. In this project, we set a polling time
    of 100 milliseconds that is required for a fast interaction between our physical
    components and the Android application.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用12号引脚作为播放按钮，A0输入作为音量，A1输入来切换当前电台。在这个项目中，我们设置了一个100毫秒的轮询时间，这对于物理组件和Android应用程序之间的快速交互是必需的。
- en: 'Add the following variables after the previous declarations:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的声明后添加以下变量：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are using a playback variable as a simple state indicator so that the sketch
    knows whether the radio is playing or not. Because we're building a radio that
    relies on physical interactions, it's important that the device state contained
    in the sketch is considered the *source of truth* for the entire application and
    that Android should trust these values. We're also defining other variables to
    store the readings from the button and the two potentiometers.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用一个播放变量作为简单的状态指示器，以便草图知道收音机是否正在播放。由于我们正在构建一个依赖于物理交互的收音机，因此草图中的设备状态被认为是整个应用程序的*真实来源*，Android应该信任这些值。我们还定义了其他变量来存储按钮和两个电位计的读数。
- en: 'Add the pin mode in the `setup()` function and open the serial communication:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup()`函数中添加引脚模式，并打开串行通信：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `readData()` function at the bottom of the sketch in which we detect
    the user input from physical components:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部创建一个`readData()`函数，在其中检测用户从物理组件的输入：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first part, we assign the value of the push button to the `buttonRead`
    variable to check whether it's pressed or not. We also store in the `previousRead`
    variable the last detected value because we want to avoid wrong state changes
    during continuous readings. In this way, if a user holds the button, only one
    state change occurs.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一部分，我们将按钮的值赋给`buttonRead`变量，以检查它是否被按下。同时，我们还将最后一次检测到的值存储在`previousRead`变量中，因为我们希望在连续读取时避免状态错误变化。这样，如果用户按住按钮，只会发生一次状态变化。
- en: In the last lines, we make `analogRead` calls to collect data from both the
    potentiometers.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后几行，我们进行`analogRead`调用，从两个电位计收集数据。
- en: 'Call the `readData()` function inside the main `loop()` function and print
    the collected values as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`loop()`函数内调用`readData()`函数，并按以下方式打印收集的值：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can upload the sketch into our board and open the **serial monitor**
    to start playing with knobs and the playback button. The following is an example
    of an expected output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将草图上传到我们的电路板上，并打开**串行监视器**，开始玩转旋钮和播放按钮。以下是预期输出的一个示例：
- en: '![Building a web radio with physical interaction](img/1942OS_05_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用物理交互构建网络收音机](img/1942OS_05_03.jpg)'
- en: Normalizing collected data before sending
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在发送之前规范化收集的数据
- en: As we noticed, if we turn the potentiometers shafts or if we push the playback
    button, our values change immediately. This is a really good starting point, but
    now we have to transform these data so that they can be easily used by the Android
    application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，如果我们转动电位计的轴或按下播放按钮，我们的值会立即改变。这是一个非常好的起点，但现在我们需要转换这些数据，以便它们能被Android应用程序轻松使用。
- en: 'Because we want to manage five radio stations, the sketch should map the tuner
    readings into values between the range [0-4]. We are going to create fixed intervals
    in the [0-1023] range, so when we turn the shaft and pass one interval, the active
    station should be updated. To implement this mapping, we have to follow these
    steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要管理五个广播电台，草图应该将调谐器的读数映射到[0-4]范围内的值。我们将在[0-1023]范围内创建固定间隔，这样当我们转动轴并通过一个间隔时，应更新活动的电台。为了实现这种映射，我们需要遵循以下步骤：
- en: 'At the top of the sketch, add the highlighted declarations:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的顶部，添加突出显示的声明：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We define the number of managed stations as `5` and we set the maximum analog
    read value. In this way, we can reuse the above object-like macros to define the
    `tunerInterval` constant to map readings into the right interval.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将管理的电台数量定义为`5`，并设置最大模拟读取值。这样，我们可以重用上面的类似对象的宏来定义`tunerInterval`常数，以将读数映射到正确的间隔。
- en: 'Add the `mapStations()` function at the bottom of the sketch:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部添加`mapStations()`函数：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To find the `currentStation` variable, we divide the analog reading with the
    tuner interval. In this way, we're sure that returned value is bounded to [0-4]
    range.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了找到`currentStation`变量，我们将模拟读取值除以调谐器间隔。这样，我们可以确保返回的值被限制在[0-4]范围内。
- en: 'Using the preceding map function is not sufficient to let our radio work. Another
    required step is to convert the volume value because Android uses a float number
    in the range [0.0-1.0]. For this reason, we should normalize the volume knob through
    the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的映射函数不足以让我们的收音机工作。另一个必要的步骤是转换音量值，因为Android使用[0.0-1.0]范围内的浮点数。因此，我们应该通过以下步骤规范化音量旋钮：
- en: 'Add this function below the `mapStations()` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mapStations()`函数下面添加此功能：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the main `loop()` function as follows so that we can check whether all
    the values are transformed correctly:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改主`loop()`函数，如下所示，以便我们可以检查是否所有值都正确转换：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Upload the new sketch to see the results shown in the following screenshot:![Normalizing
    collected data before sending](img/1942OS_05_04.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传新的草图以查看以下截图显示的结果：![在发送前规范化收集的数据](img/1942OS_05_04.jpg)
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Through the preceding steps, we collected data from the physical input devices
    and transformed these values to calculate the current station and radio volume
    from knobs. However, we need to put this logic even in our Android application
    because it should map for each possible station, the related URL of web streaming.
    This means that the same logic is replicated and this isn't a good approach, especially
    if we need to add new channels in the future. In this case, our code must be changed
    in both applications, and we should always avoid the situations that are *error
    prone*. A good approach is to use the microcontroller only for input reporting
    and let the Android application manage and transform received raw data. We use
    this approach only for the scope of the book to help you get more comfortable
    with the sketch code.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过前面的步骤，我们从物理输入设备收集数据，并转换这些值以从旋钮计算当前的电台和收音机音量。然而，我们需要在Android应用程序中也放置这个逻辑，因为它应该为每个可能的电台映射相关的网络流媒体URL。这意味着相同的逻辑被复制，这不是一个好方法，特别是如果我们将来需要添加新的频道。在这种情况下，我们的代码必须在两个应用程序中更改，并且我们应始终避免那些*容易出错*的情况。一个好方法是只使用微控制器报告输入，并让Android应用程序管理和转换接收到的原始数据。我们仅在本书的范围内使用这种方法，以帮助您更熟悉草图代码。
- en: Sending multiple data with Arduino
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Arduino发送多个数据
- en: 'In [Chapter 4](ch04.html "Chapter 4. Using Sensors to Listen to the Environment"),
    *Using Sensors to Listen to the Environment*, we needed to send a single byte
    computed by the microcontroller. However, in most common cases, we need to read
    data from different sensors or physical components and we may need to send them
    back to Android at once. In this prototype, we should observe this requirement
    because the microcontroller must read all three values and send them back with
    only one ADK write. A simple approach is to build a string that represents our
    triple, and uses the comma to separate these values with the format `<playback>,<volume>,<station>`.
    Through this representation, we obtain the following values :'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章. 使用传感器聆听环境")《*使用传感器聆听环境*》中，我们需要发送由微控制器计算的一个字节。然而，在大多数常见情况下，我们需要从不同的传感器或物理组件读取数据，并且可能需要一次性将它们发送回Android。在这个原型中，我们应该关注这一需求，因为微控制器必须读取所有三个值，并且只能通过一次ADK写入将它们发送回去。一个简单的方法是构建一个表示我们三元组的字符串，并使用逗号分隔这些值，格式为`<playback>,<volume>,<station>`。通过这种表示，我们得到以下值：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then we can write the *serialized* representation of the radio state in the
    ADK buffer and proceed with the *deserialization* in the Android application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在ADK缓冲区中写入收音机状态的*序列化*表示，并在Android应用程序中进行*反序列化*处理。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We may think about implementing or using a more complex communication protocol
    to transfer generic data from Arduino to Android, but we should always bear in
    mind that, at the beginning, every good idea must follow the **KISS principle**:
    **Keep It Simple**, **Stupid** (a design principle noted by the U.S. Navy in 1960).
    Because the more simple the software, the more likely it is to work well.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会考虑实施或使用更复杂的通信协议，以将通用数据从Arduino传输到Android，但我们应该始终牢记，在开始时，每个好主意都必须遵循**KISS原则**：**保持简单**，**傻瓜**（一个由美国海军在1960年提出的设计原则）。因为软件越简单，它就越可能运行良好。
- en: 'We need to write the accessory descriptor at the top of the sketch, like the
    following proposed code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在草图的顶部编写配件描述符，如下所示的建议代码片段：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need a second buffer that will hold the triple; we can add its declaration
    just before the ADK buffer variable as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个用于保存三元组的第二个缓冲区；我们可以在ADK缓冲区变量之前添加其声明，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the bottom of the sketch, add the following function to write the triple
    in the ADK buffer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图的底部，添加以下函数以在ADK缓冲区中写入三元组：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `writeBuffer()` function expects three parameters used in triple building.
    To achieve this, we use the `sprintf()` function to write these values in the
    intermediate `triple` buffer. In the `sprintf()` function call, we also use the
    `normalizeVolume()` and `mapStations()` functions to get the transformed values.
    We then use the `memcpy()` function to write the `triple` variable in the ADK
    `buffer`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeBuffer()`函数期望三个用于构建三元组的参数。为此，我们使用`sprintf()`函数将这些值写入中间`triple`缓冲区。在`sprintf()`函数调用中，我们还使用`normalizeVolume()`和`mapStations()`函数获取转换后的值。然后我们使用`memcpy()`函数将`triple`变量写入ADK
    `buffer`。'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need this extra step because we cannot write the `triple` variable in the
    ADK `buffer`. The `adk.write()` function expects an `unsigned char*` type while
    the triple is a `char*` type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个额外的步骤，因为我们不能将`triple`变量写入ADK `buffer`中。`adk.write()`函数期望一个`unsigned char*`类型，而`triple`是`char*`类型。
- en: 'Now that the ADK buffer contains the serialized data, we have to remove all
    `Serial` calls and rewrite the main `loop()` function as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 既然ADK缓冲区包含了序列化的数据，我们就必须移除所有的`Serial`调用，并按以下方式重写主`loop()`函数：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the ADK is ready, we read data from the push button and both potentiometers,
    and then we serialize these values in a triple that will be written in the ADK
    output buffer. When everything is ready, we send the recorded input back to Android.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当ADK准备就绪时，我们从推按键和两个电位计中读取数据，然后将这些值序列化到一个三元组中，该三元组将被写入ADK输出缓冲区。一切准备就绪后，我们将记录的输入发送回Android。
- en: We can now update our sketch and complete the prototype with the Android application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新我们的草图，并使用Android应用程序完成原型。
- en: Streaming audio from Android applications
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Android应用程序中流式传输音频
- en: The Android operating system provides a great collection of UI components, an
    important building block for all physical applications. All of them are specific
    for phone or tablet interaction and this is an outstanding improvement because
    users already know how to use them. However, Android isn't just a collection of
    UI components because it allows many APIs to achieve recurring tasks. In our case,
    we want a physical application that is capable of interacting with a web service
    to open and reproduce an audio stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统提供了一组丰富的UI组件，这是所有物理应用的重要构建块。它们都是针对手机或平板交互的，这是一项杰出的改进，因为用户已经知道如何使用它们。然而，Android不仅仅是一组UI组件，因为它允许许多API来实现常规任务。在我们的案例中，我们希望一个物理应用能够与Web服务交互，以打开和播放音频流。
- en: Without the i.MX6 processor and the Android operating system, this task will
    never be easy to implement, but in our case, UDOO board provides all that we need.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有i.MX6处理器和Android操作系统，这项任务将不可能轻松实现，但在我们的情况下，UDOO开发板提供了我们所需要的一切。
- en: Designing the Android user interface
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Android用户界面
- en: From Android Studio, start a new application called **WebRadio** with **Android
    API 19**. During the bootstrap process, choose a **Blank Activity** named **Radio**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，启动一个名为**WebRadio**的新应用，使用**Android API 19**。在引导过程中，选择一个名为**Radio**的**空白活动**。
- en: 'Our first goal is to change the default layout in favor of a simple but fancy
    interface. The main layout must show the current activated radio station providing
    different information such as an optional image—the name of the channel together
    with a description. Before writing down the XML code required by Android to draw
    the user interface, we should plan our work to detect the required components.
    In the following screenshot, we can take a look at the user interface mock-up
    that provides all the required elements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是改变默认布局，以一个简单但花哨的界面替代。主布局必须显示当前激活的广播电台，并提供不同的信息，如可选的图片——频道名称以及描述。在编写Android绘制用户界面所需的XML代码之前，我们应该规划工作以检测所需的组件。在下面的截图中，我们可以查看提供所有必需元素的用户界面草图：
- en: '![Designing the Android user interface](img/1942OS_05_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![设计Android用户界面](img/1942OS_05_05.jpg)'
- en: 'The above layout includes a number marker that defines in which order the components
    will be created. According to this layout, we should provide three different views
    in the following order:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的布局包括一个数字标记，定义了组件创建的顺序。根据此布局，我们应该按照以下顺序提供三个不同的视图：
- en: As the first step, we should create a background frame with a different color
    to provide a block in which we will put all other components.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们应该创建一个不同颜色的背景框架，以提供一个块，我们将把所有其他组件放入其中。
- en: Even if this is optional, we can prepare a box that will host the radio channel
    image, if it's available.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管这是可选的，但我们可以准备一个框，如果可用的话，将用于显示电台频道图片。
- en: The last block includes two different text areas where the first represents
    the channel name, while the other represents the channel description.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个块包含两个不同的文本区域，第一个代表频道名称，而另一个代表频道描述。
- en: 'With this layout design, we should proceed and replace the standard theme with
    the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种布局设计，我们应该按照以下步骤继续操作，替换标准主题：
- en: 'In the `res/values/dimens.xml` resource file, add the following definitions
    to provide some dimensions for our components, such as the background frame height
    and the font size:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/values/dimens.xml` 资源文件中，添加以下定义，为我们提供一些组件的尺寸，如背景框架高度和字体大小：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `res/values/styles.xml` resource file, add the following colors used
    by the background frame and text elements:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/values/styles.xml` 资源文件中，添加背景框架和文本元素使用的以下颜色：
- en: '[PRE15]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `activity_radio.xml` file under `res/layout/`, replace the `RelativeLayout`
    with the following `FrameLayout` to implement the background frame:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/layout/` 下的 `activity_radio.xml` 文件中，用以下 `FrameLayout` 替换 `RelativeLayout`
    以实现背景框架：
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use the `FrameLayout` to create a section that houses all other components
    with the defined height and background color.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `FrameLayout` 创建一个区域，该区域以定义的高度和背景色容纳所有其他组件。
- en: 'Create a `LinearLayout` nested in the above `FrameLayout` parameter:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述 `FrameLayout` 参数中创建一个 `LinearLayout`：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first `LinearLayout` will contain the `radio_image` `ImageView` that changes
    according to the active channel. The second `LinearLayout` is used to host the
    radio name and description.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个 `LinearLayout` 将包含根据活动频道而变化的 `radio_image` `ImageView`。第二个 `LinearLayout`
    用于容纳电台名称和描述。
- en: 'Add within the second `LinearLayout` the following views:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个 `LinearLayout` 中添加以下视图：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'According to previous defined styles, the following is the obtained layout:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前定义的样式，以下是获得的布局：
- en: '![Designing the Android user interface](img/1942OS_05_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![设计 Android 用户界面](img/1942OS_05_06.jpg)'
- en: 'Before we can proceed with the logic implementation, we have to get all view
    references during the `onCreate()` callback through the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续逻辑实现之前，我们必须在 `onCreate()` 回调中通过以下步骤获取所有视图引用：
- en: 'Add the following declarations at the top of the `Radio` class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Radio` 类的顶部添加以下声明：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the bottom of the `onCreate()` callback, add the highlighted code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 回调的底部，添加高亮代码：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that the layout is completed, we can proceed with the ADK configuration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局已完成，我们可以继续进行 ADK 配置。
- en: Setting up the ADK Toolkit
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 ADK 工具包
- en: 'Before we begin the web radio implementation, we should first configure the
    *ADKToolkit* like we did in the previous chapter. To have a working ADK configuration,
    follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始网络电台实现之前，我们首先应该像上一章一样配置 *ADKToolkit*。为了拥有可工作的 ADK 配置，请按照以下步骤操作：
- en: Add the *ADKToolkit* library dependency in the `build.gradle` file under `app`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 下的 `build.gradle` 文件中添加 *ADKToolkit* 库依赖。
- en: Sync your Gradle configuration.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步你的 Gradle 配置。
- en: 'Create the accessory filter file `usb_accessory_filter.xml` under `res/xml/`
    using the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/xml/` 下创建配件过滤器文件 `usb_accessory_filter.xml`，使用以下代码：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add the *USB accessory support* option requirement and the *USB accessory intent
    filter* option in the `AndroidManifest.xml` file.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中添加 *USB accessory support* 选项要求和 *USB accessory intent
    filter* 选项。
- en: In the `Radio.java` class file, declare the `AdkManager` object at the top of
    the class.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Radio.java` 类文件中，在类的顶部声明 `AdkManager` 对象。
- en: Add the `AdkManager` initialization inside the `onCreate` method of the `Radio`
    activity class.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Radio` 活动类的 `onCreate` 方法中添加 `AdkManager` 初始化。
- en: Override the `onPause()` and `onResume()` callbacks to start and stop the ADK
    connection according to the activity lifecycle.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onPause()` 和 `onResume()` 回调，根据活动生命周期来启动和停止 ADK 连接。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The above checklist should be used every time we start a new project. It's a
    good idea to write down these steps and be sure that our projects always start
    with this ADK configuration.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次我们开始一个新项目时，都应该使用上述清单。最好将这些步骤写下来，确保我们的项目始终以此 ADK 配置开始。
- en: 'As a last step of the initial configuration, we need to add the Internet access
    permission because we are going to use network streams. Add in the following permission
    inside the tag manifest in your `AndroidManifest.xml` file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为初始配置的最后一步，我们需要添加互联网访问权限，因为我们将使用网络流。在你的`AndroidManifest.xml`文件的manifest标签内添加以下权限：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Changing web radio stations
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更换网络电台
- en: 'The next step is to write the required Android code to play and stop configured
    radio stations. What we need is to formalize the station object and a utility
    class that abstracts the same functionalities of the built-in media player. The
    following is the checklist of required classes with their usage:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写必要的Android代码以播放和停止配置的电台。我们需要正式化电台对象和一个实用程序类，该类抽象了内置媒体播放器的相同功能。以下是所需类的使用清单：
- en: '`Station`: Formalizes the audio channel and includes the title, the description,
    and the station image, together with the streaming URL required to start the remote
    playback'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Station`：正式定义音频频道，并包括标题、描述和电台图片，以及启动远程播放所需的流媒体URL'
- en: '`RadioManager`: Configures all available stations during its initialization
    and abstracts all common methods to manage the playback and the channel switching'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RadioManager`：在初始化期间配置所有可用的电台，并将所有管理播放和频道切换的通用方法抽象出来'
- en: 'We begin with the `Station` class that we can realize with the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从可以通过以下步骤实现的`Station`类开始：
- en: Create a new Java package inside our namespace called `streaming`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的命名空间内创建一个名为`streaming`的新Java包。
- en: 'Create the `Station` class in the newly created Java package and add the following
    declarations and class constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的Java包中创建`Station`类，并添加以下声明和类构造函数：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We define the first part of the URL that we will use to construct the channel
    streaming URL. In this case, we are going to use the **Jamendo** service that
    offers many music channels that are released under the **Creative Commons** license.
    If you want to get more information, you can take a look at the service website:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了我们将用于构建频道流媒体URL的第一部分。在这种情况下，我们将使用提供许多在**Creative Commons**许可下发布的音乐频道的**Jamendo**服务。如果你想获取更多信息，可以查看服务网站：
- en: '[https://www.jamendo.com](https://www.jamendo.com)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Jamendo网站](https://www.jamendo.com)'
- en: Other attributes that we will use are the station `title` and `description`
    attributes and the Android resource identifier.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用的其他属性是电台的`title`和`description`属性以及Android资源标识符。
- en: 'At the bottom of the class, the following getters are used to retrieve instance
    attributes:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部，以下获取器用于检索实例属性：
- en: '[PRE24]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the `getStreamUrl()` method, we are using the base URL with the radio name
    to find the correct audio stream.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`getStreamUrl()`方法中，我们使用带有电台名称的基础URL来查找正确的音频流。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This string concatenation is related to how the Jamendo service works. If you
    use another service or you don't want to use the title attribute during the URL
    composition, you should change this method.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个字符串连接与Jamendo服务的工作方式有关。如果你使用另一个服务或不想在URL构建时使用标题属性，你应该更改这个方法。
- en: 'Now that we have a formal `Station` class representation, we need to define
    the class capable of managing the Android playback. We realize the `RadioManager`
    class through the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了正式的`Station`类表示，我们需要定义一个能够管理Android播放的类。我们通过以下步骤实现`RadioManager`类：
- en: 'In the `streaming` package, create the `RadioManager` class and add the following
    declarations at the beginning:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`streaming`包中，创建`RadioManager`类，并在开始处添加以下声明：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the Android high-level `MediaPlayer` object to manage remote streaming;
    we make use of some status variables, such as the current active station with
    its array index and the playback status. We will fill the `mChannels` `ArrayList`
    object during the `RadioManager` class initialization and it will host all the
    available music channels.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用Android高级`MediaPlayer`对象来管理远程流媒体；我们使用一些状态变量，如当前活动电台及其数组索引和播放状态。我们将在`RadioManager`类初始化期间填充`mChannels`
    `ArrayList`对象，它将托管所有可用的音乐频道。
- en: 'Add the initializer method at the bottom of the class, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部添加初始化方法，如下所示：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the first part, we configure the list of all the available stations according
    to the previous `Station` constructor. We configure the `MediaPlayer` object so
    that it starts a network stream immediately when the prepare process is completed.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一部分，我们根据之前的 `Station` 构造函数配置所有可用频道的列表。我们配置 `MediaPlayer` 对象，以便在 prepare 过程完成后立即开始网络流。
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information about how the Android `MediaPlayer` class works
    at the URL:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在以下 URL 查找更多关于 Android `MediaPlayer` 类如何工作的信息：
- en: '[http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html).'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html)。'
- en: 'Add the following methods to abstract the play and stop functionalities to
    prevent code repeating:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法，以抽象播放和停止功能，防止代码重复：
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the player is stopped, we have to reset the media player object because
    we may need to set another data source immediately. The `play` method sets the
    streaming URL of the current activated station and starts a nonblocking prepare
    task.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当播放器停止时，我们必须重置媒体播放器对象，因为我们可能需要立即设置另一个数据源。`play` 方法设置当前激活频道的流媒体 URL 并开始一个非阻塞的
    prepare 任务。
- en: 'Add the following public method that changes the playback status:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下公共方法，该方法改变播放状态：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The sketch through the ADK sends continuous data to our application every 100
    milliseconds and this enhances the responsiveness of the user interface. However,
    we don't want to repeat the same command many times, so we only do something if
    the value received is different from the stored one. In the second part, we choose
    to start or play the current stream according to the given parameter.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过 ADK 的草图，我们的应用程序每隔 100 毫秒就会收到连续的数据，这提高了用户界面的响应性。然而，我们不想多次重复相同的命令，所以我们只有在收到的值与存储的值不同时才会执行操作。在第二部分，我们根据给定的参数选择开始或播放当前流。
- en: 'As the last part, we need a method to change the activated channel. Add the
    following code at the bottom of the class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要一个方法来更改激活的频道。在类的底部添加以下代码：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we did earlier, we avoid changing the station if the received value is the
    same as the one we currently played. Then, we update the current channel and stop
    the last stream. In this way, if we are in the playback state, we can safely reproduce
    a new station stream. In any case, we return the chosen `Station` instance, or
    `null` if the station has not changed.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们之前所做的，如果收到的值与我们当前播放的值相同，我们避免更改频道。然后，我们更新当前频道并停止最后的流。这样，如果我们处于播放状态，我们可以安全地播放新的电台流。在任何情况下，我们返回选择的
    `Station` 实例，如果频道没有变化则返回 `null`。
- en: Reading input from physical devices
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从物理设备读取输入
- en: 'Like we did in the previous chapter, we need to prepare our application to
    make continuous readings of user input available in the ADK buffer. As we did
    before, we are going to create a Java interface that exposes the required methods
    to update the user interface. We can achieve this through the following steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所做的，我们需要准备我们的应用程序，以使 ADK 缓冲区中用户输入的连续读取变得可用。正如之前所做，我们将创建一个 Java 接口，公开所需的方法以更新用户界面。我们可以通过以下步骤实现这一点：
- en: 'Create a new Java interface called `OnDataChanges` and add the following method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `OnDataChanges` 的新 Java 接口，并添加以下方法：
- en: '[PRE30]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let the `Radio` class implement the preceding interface through the highlighted
    code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `Radio` 类通过高亮代码实现前面的接口：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the interface code at the end of the class to update the Android
    user interface:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的末尾实现接口代码，以更新 Android 用户界面：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this part, we simply update all views according to the `station` instance
    attributes.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这部分，我们根据 `station` 实例属性简单地更新所有视图。
- en: 'The last required step is to implement our scheduled thread that reads processed
    data from the microcontroller and updates the `MediaPlayer` class streaming together
    with the Android user interface. To complete this last building block, perform
    the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个必要的步骤是实现我们的计划线程，从微控制器读取处理过的数据，并一起更新 `MediaPlayer` 类的流和 Android 用户界面。要完成这最后一个构建块，请执行以下步骤：
- en: Create a new package in your namespace called `adk`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的命名空间中创建一个名为 `adk` 的新包。
- en: In the `adk` package, add a new class named `DataReader`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `adk` 包中，添加一个名为 `DataReader` 的新类。
- en: 'At the top of the class, add the following declarations:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，添加以下声明：
- en: '[PRE33]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Like we did in the previous chapter, we're defining the polling time and the
    message type used by the main thread handler. We also store the references for
    the `AdkManager` parameter and the caller activity to use, respectively, the ADK
    read method and the `updateStation` function's callback. Then we define the `ExecutorService`
    method implementation together with the main thread `Handler`.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与前一章一样，我们定义主线程处理器使用的轮询时间和消息类型。我们还存储了`AdkManager`参数和调用活动的引用，分别用于ADK读取方法和`updateStation`函数的回调。然后我们定义了`ExecutorService`方法的实现以及主线程`Handler`。
- en: 'Implement the `DataReader` constructor to set the message handler when the
    main thread receives a new message from the background thread:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现主线程从后台线程接收到新消息时设置消息处理器的`DataReader`构造函数：
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We store the `AdkManager` and the `caller` activity references and then set
    a `Handler` attached to the application's main looper. The `handleMessage` callback
    checks the message code to identify the `STATION_UPDATE` messages. In this case,
    we call the `updateStation` method and pass the attached object.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们存储`AdkManager`和`caller`活动的引用，然后设置一个附加到应用程序主循环的`Handler`。`handleMessage`回调检查消息代码以识别`STATION_UPDATE`消息。在这种情况下，我们调用`updateStation`方法并传递附加的对象。
- en: 'At the bottom of `DataReader` class, add the following private class that implements
    the `Runnable` interface to read and manage the physical input devices:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataReader`类的底部，添加以下私有类，实现`Runnable`接口以读取和管理物理输入设备：
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the thread starts, we read user inputs using the `AdkManager` method. Then
    we get the raw string from the response and use the split method to deserialize
    the received triple. The first position refers to the playback status and we use
    it in the `RadioManager` class to start or stop the playback. The value in the
    third position is the activated channel and we pass this to the `changeStation`
    method. According to the previous implementation, if the `currentStation` variable
    is not changed, we avoid publishing the message to the main thread to prevent
    useless interface redraws.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线程启动时，我们使用`AdkManager`方法读取用户输入。然后我们从响应中获取原始字符串，并使用分割方法反序列化接收到的三元组。第一个位置指的是播放状态，我们在`RadioManager`类中使用它来启动或停止播放。第三个位置是激活的频道，我们将其传递给`changeStation`方法。根据之前的实现，如果`currentStation`变量没有改变，我们避免将消息发布到主线程，以防止无用的界面重绘。
- en: 'Add a method to the `DataReader` class to start the scheduler that spawns short-lived
    threads periodically:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DataReader`类添加一个方法，以定期生成短生命周期的线程来启动调度程序：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Like we did in the previous project, we use a scheduler that spawns a single
    `InputThread` parameter every time at a `INPUT_POLLING` variable milliseconds.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与上一个项目一样，我们使用一个调度程序，每次在`INPUT_POLLING`变量毫秒时生成一个单独的`InputThread`参数。
- en: 'Add the stop method at the bottom of the class to stop the scheduler from spawning
    new threads through the `shutdown` executor''s method:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部添加停止方法，通过执行器的`shutdown`方法停止调度程序生成新线程：
- en: '[PRE37]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we should go back to the `Radio` class to start and stop the scheduler
    within the activity lifecycle. Add the `DataReader` method declaration at the
    top of the `Radio` class:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该回到`Radio`类中，在活动生命周期内启动和停止调度程序。在`Radio`类的顶部添加`DataReader`方法声明：
- en: '[PRE38]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Initialize the `RadioManager` class and the `DataReader` instance when the
    activity is created through the following highlighted code, that you should add
    at the bottom of the `onCreate()` callback:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动创建时初始化`RadioManager`类和`DataReader`实例，通过以下高亮代码，你应该将其添加到`onCreate()`回调的底部：
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Start and stop the reading scheduler in the `onResume()` and `onPause()` activity''s
    callbacks as you can see in the highlighted code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如高亮代码所示，在`onResume()`和`onPause()`活动的回调中启动和停止读取调度程序：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With these last steps, the radio station is completed and we can upload the
    Android application in the UDOO board and start playing with the station knob
    and the push button.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，广播电台就完成了，我们可以将Android应用程序上传到UDO0板，并通过旋钮和按钮开始播放。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because we didn't manage network errors, be sure that UDOO is connected to the
    Internet and that you're using the Ethernet or the Wi-Fi network adapter, otherwise
    the application will not work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有处理网络错误，请确保UDO0已连接到互联网，并且你正在使用以太网或Wi-Fi网络适配器，否则应用程序将无法工作。
- en: Managing audio volume
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理音频音量
- en: 'Before we can release our first radio prototype, we should manage the volume
    knob from the Android application. This part is really easy thanks to the `MediaPlayer`
    method APIs, because it exposes a public method to change the volume of the activated
    stream. To improve our project with a volume manager, we need to add the following
    code snippets:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以发布第一个广播原型之前，我们应该从Android应用程序管理音量旋钮。这部分非常简单，这要感谢`MediaPlayer`方法的API，因为它公开了一个公共方法来改变激活流的音量。为了用音量管理器改进我们的项目，我们需要添加以下代码片段：
- en: 'In the `RadioManager` class, add the highlighted declaration at the top of
    the class:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RadioManager`类中，请在类顶部添加高亮的声明：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At the bottom of the `RadioManager` class, add this public method:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RadioManager`类的底部，添加以下公共方法：
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method `setVolume` expects the float received from Arduino as argument and
    we use it to change the volume of the `mMediaPlayer` instance. However, because
    we don't want to change the volume for little variations, we discard all requests
    for values that aren't so different from the previous recorded input.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setVolume`方法预期接收来自Arduino的浮点数作为参数，我们用它来改变`mMediaPlayer`实例的音量。然而，由于我们不希望因为微小的变化而改变音量，因此我们放弃了所有与之前记录的输入差异不大的请求。'
- en: 'Add the volume parsing and the `setVolume` function call within the `InputThread`
    implementation that we wrote in the `DataReader` class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataReader`类中编写的`InputThread`实现中添加音量解析和`setVolume`函数调用：
- en: '[PRE43]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this last piece, the web radio is completed and we can proceed with this
    last deployment. Now our users can interact and enjoy the prototype using both
    knobs and the push button to control every aspect of the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这最后一块，网络广播就完成了，我们可以继续进行最后的部署。现在，我们的用户可以使用旋钮和按钮与原型互动，控制应用程序的各个方面。
- en: Improving the prototype
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进原型
- en: Before we go further with other prototypes, we should think about how we can
    improve our devices when some unexpected events occur. A good starting point is
    to think about error handling and, in particular, what happens if the Android
    application stops hearing incoming data from the accessory. There are many approaches
    to prevent wrong actions and a good solution is to include a default behavior
    in the Android application that the prototype should follow in these emergency
    cases.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论其他原型之前，我们应该考虑当发生一些意外事件时，我们如何改进我们的设备。一个好的起点是考虑错误处理，特别是当Android应用程序停止从外设接收数据时会发生什么。有许多方法可以防止错误操作，一个好的解决方案是在Android应用程序中包含一个默认行为，这些紧急情况下原型应该遵循。
- en: We could have used another periodic timer that increases a variable every time
    it gets executed. When the `InputThread` instance completes a successful reading,
    it should reset the above variable. In this way, we can monitor for how much time
    we stop receiving user inputs and according to this time, we may decide to change
    the application's behavior. Through this variable, for example, we could stop
    the radio playback, or turn down the volume a little bit if the accessory stops
    providing user inputs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用另一个周期性定时器，每次执行时增加一个变量。当`InputThread`实例完成一次成功的读取后，它应该重置上述变量。通过这种方式，我们可以监控停止接收用户输入的时间，根据这个时间，我们可能决定改变应用程序的行为。通过这个变量，例如，如果外设停止提供用户输入，我们可以停止广播播放，或者稍微降低音量。
- en: The key point is that we should always design our prototype both for failure
    and success. Most *what happens if* problems are easy to incorporate up front,
    but hard to add in later.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，我们应始终为失败和成功设计我们的原型。大多数*如果发生*的问题在前端很容易融入，但后来很难添加。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to improve the quality of our prototypes when
    human interaction is required. We explored some of the common physical components
    that can be used to alter or control Android applications. Through powerful Android
    APIs, we built a web radio capable of complex tasks like network streaming.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了当需要人机交互时，如何提高我们原型的质量。我们探索了一些常见的物理组件，它们可以用来改变或控制Android应用程序。通过强大的Android
    API，我们构建了一个能够执行复杂任务如网络流传输的网络广播。
- en: In the first part, we built the required circuit using two potentiometers and
    a push button. When we checked returned values through the serial monitor, we
    saw that they are not so useful in this format, so we wrote a mapping and a normalization
    functions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们使用两个电位计和一个按钮构建了所需的电路。当通过串行监视器检查返回的值时，我们发现它们在这种格式下并不太有用，因此我们编写了映射和归一化函数。
- en: We continued providing a new layout for the Android application, but we avoided
    adding any kind of interaction through the user interface. We wrote a class to
    abstract all possible interactions with the built-in media player, so that we
    can easily control this component in any part of our application. Indeed, we used
    it within the background task, and every time it read user inputs, it immediately
    changed the state of the radio. In this way, we enabled the push button to start
    and stop the playback and the two potentiometers to change the active station
    and the music volume.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we start talking about home automation. We start from scratch
    a new prototype capable of turning on and off external devices using a combination
    of sensor values and users settings. We will make use of other Android APIs to
    store the application's settings and use them later to alter the sketch flow.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
