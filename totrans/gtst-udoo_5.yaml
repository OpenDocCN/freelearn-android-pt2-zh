- en: Chapter 5. Managing Interactions with Physical Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Electronic devices have changed our life. We are surrounded by quite a few invisible
    objects that collect and eventually compute environment data. Like we saw in the
    previous chapter, these devices use sensors to retrieve information and we can
    find them in our everyday life, for example, in our car, when we're walking through
    supermarkets' sliding doors, and maybe when we're coming back to home.
  prefs: []
  type: TYPE_NORMAL
- en: We can inspire ourselves looking at these things and build amazing physical
    applications that are capable of reacting to the environment and, indirectly,
    to the people around. However, if our project expects a direct human interaction,
    we may need to manage this interaction with physical components.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to build a web radio that uses built-in Android
    APIs to manage Internet streams, while all interactions are managed by physical
    components, such as in the old fashioned radios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing user interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a web radio with physical interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending multiple data with Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an Android application for audio streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing user interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One aspect that distinguishes an interactive prototype is the capability to
    react to any action made by users. As we''ve seen in the previous chapter, sensors
    are one of the most important building blocks to achieve this important goal.
    However, sometimes, we want to provide a physical interaction where users are
    capable of altering the application''s behavior with their hands, despite the
    presence of sensors. These parts that are still largely diffused, are simple **mechanic**
    or **electronic** components that convert analog movements into digital values
    that our microcontroller can use to alter the program flow. There are a lot of
    components that we may use to interact with our device: **push buttons**, **switch
    buttons**, **joysticks**, **knobs**, **pedals**, and **levers**, are just examples
    of these kind of components.'
  prefs: []
  type: TYPE_NORMAL
- en: Knobs are components that we can use to alter some prototype configurations.
    Indeed, we may create a maintenance console that alters some device constants
    to prevent the recompilation and upload phase of a new sketch. At other times,
    knobs are used to make direct actions and their usage is an active part of the
    users interactions. A common use of knobs is related to electrical devices, such
    as volume controls in audio equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Another example could be related to robot rovers, when we want to provide direct
    control for users instead of the robot's own artificial intelligence. In this
    case, we may use a push button that facilitates the stopping action while activating
    a manual mode. For instance, we could provide a joystick that can be used to pilot
    the rover movements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of the usage of push buttons is related to stopping any actions made
    by the microcontroller or the prototype. This use of push buttons is called **emergency
    stop** and it's used in many DIY projects when they are fully automated and equipped
    with moving parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these elements have two base components in common: **switches** and **potentiometers**.
    Push buttons are good examples of mechanical switches that close or open a circuit
    and control the current flow through the microcontroller pins. In this way, we
    may activate a particular functionality of our circuit like we did in [Chapter
    3](ch03.html "Chapter 3. Testing Your Physical Application"), *Testing your Physical
    Application*, according to the detected voltage.'
  prefs: []
  type: TYPE_NORMAL
- en: Potentiometers, instead, are electronic components, more like resistors. The
    electronic part is composed of three terminal legs that we can use in different
    ways to change the purpose of the potentiometer. Indeed, if we connect one end
    and the central leg to a component, it acts as a **variable resistor**. On the
    other hand, if we use all three terminals, it works like an adjustable **voltage
    divider**. The *shaft* of a potentiometer that we can turn from one direction
    to the other, is used to change the value of the resistor or the voltage divider.
    Good examples of the application of potentiometers are knobs, joysticks, and guitar
    pedals.
  prefs: []
  type: TYPE_NORMAL
- en: Building a web radio with physical interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microcontrollers aren't designed for complicated work, so we need to be careful
    to partition the needs of our project to the right environments. For a web radio,
    we can use the microcontroller to read the knobs and switches, and let the Android
    APIs and UDOO's powerful CPU do the rest. This will keep Android from getting
    distracted while reading the hardware, and will prevent the microcontroller from
    getting overloaded with the complications of network streaming and playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of our prototype is to build a circuit and write a sketch that
    collects values from two potentiometers and a push button:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the first potentiometer to change the active radio station and to increase
    or decrease the audio volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the physical button to control the radio playback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, we're removing all interactions done through the Android user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, grab two potentiometers and connect them to the board so
    that we can realize the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web radio with physical interaction](img/1942OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow the procedure given below to get the circuit connected to the potentiometer,
    as shown in the preceding schema:'
  prefs: []
  type: TYPE_NORMAL
- en: Put two potentiometers on the right of your breadboard, because we need to use
    the free slots on the left for the push button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the UDOO +3.3V pin to the positive line of the power bus. Be sure not
    to connect the +5V power pin because it may damage the analog input pins during
    future connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the UDOO ground to the negative line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left terminal of the first potentiometer to the negative line of
    the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Potentiometers act like resistors, so there aren't any differences if you connect
    the wrong positive terminal. The only side effect is that the detected values
    will not start from a range [0-1023] but from [1023-0]. If you notice that, *invert
    these connections*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect the right terminal of the first potentiometer to the positive line of
    the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the middle terminal to the analog input A0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat points 4, 5, 6 for the second potentiometer and connect its middle terminal
    to the analog input A1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this circuit, we use both potentiometers as voltage dividers and when we
    turn the shaft, the microcontroller notices a change in the voltage output and
    transforms this value in to a numeric range [0-1023]. This circuit is really similar
    to the one built in the previous chapter to create a light sensor, but since the
    potentiometer already has a resistor in its package, we don't need any other electric
    components to keep it working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a push button to start and stop the playback. We have to add the
    component on the left of the breadboard and connect it to UDOO as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web radio with physical interaction](img/1942OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow the given steps to connect the components, as shown in the preceding
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the left terminal of the push button to the positive line of the power
    bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the right terminal to the negative line of the power bus using 10 KOhm
    resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the right terminal to pin 12 of the UDOO board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this circuit, we can read the value of the push button using pin 12 of
    the UDOO board; when the button is pressed, we can change an internal state of
    the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a circuit with all the required components, we have to start
    a new sketch and prepare a function that we can use to collect all data. The goal
    of the sketch is to prepare a **triple** that has the *playback status*, the *volume*
    and the *station* as ordered values. This approach simplifies our work later when
    we start communication with the Android application. We can start to write the
    new sketch as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the connections at the top of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using pin 12 for the play button, the input A0 for the volume, and the
    input A1 to change the current station. In this project, we set a polling time
    of 100 milliseconds that is required for a fast interaction between our physical
    components and the Android application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following variables after the previous declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using a playback variable as a simple state indicator so that the sketch
    knows whether the radio is playing or not. Because we're building a radio that
    relies on physical interactions, it's important that the device state contained
    in the sketch is considered the *source of truth* for the entire application and
    that Android should trust these values. We're also defining other variables to
    store the readings from the button and the two potentiometers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the pin mode in the `setup()` function and open the serial communication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `readData()` function at the bottom of the sketch in which we detect
    the user input from physical components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first part, we assign the value of the push button to the `buttonRead`
    variable to check whether it's pressed or not. We also store in the `previousRead`
    variable the last detected value because we want to avoid wrong state changes
    during continuous readings. In this way, if a user holds the button, only one
    state change occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the last lines, we make `analogRead` calls to collect data from both the
    potentiometers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `readData()` function inside the main `loop()` function and print
    the collected values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can upload the sketch into our board and open the **serial monitor**
    to start playing with knobs and the playback button. The following is an example
    of an expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web radio with physical interaction](img/1942OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Normalizing collected data before sending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we noticed, if we turn the potentiometers shafts or if we push the playback
    button, our values change immediately. This is a really good starting point, but
    now we have to transform these data so that they can be easily used by the Android
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to manage five radio stations, the sketch should map the tuner
    readings into values between the range [0-4]. We are going to create fixed intervals
    in the [0-1023] range, so when we turn the shaft and pass one interval, the active
    station should be updated. To implement this mapping, we have to follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the sketch, add the highlighted declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the number of managed stations as `5` and we set the maximum analog
    read value. In this way, we can reuse the above object-like macros to define the
    `tunerInterval` constant to map readings into the right interval.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `mapStations()` function at the bottom of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To find the `currentStation` variable, we divide the analog reading with the
    tuner interval. In this way, we're sure that returned value is bounded to [0-4]
    range.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the preceding map function is not sufficient to let our radio work. Another
    required step is to convert the volume value because Android uses a float number
    in the range [0.0-1.0]. For this reason, we should normalize the volume knob through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function below the `mapStations()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the main `loop()` function as follows so that we can check whether all
    the values are transformed correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upload the new sketch to see the results shown in the following screenshot:![Normalizing
    collected data before sending](img/1942OS_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Through the preceding steps, we collected data from the physical input devices
    and transformed these values to calculate the current station and radio volume
    from knobs. However, we need to put this logic even in our Android application
    because it should map for each possible station, the related URL of web streaming.
    This means that the same logic is replicated and this isn't a good approach, especially
    if we need to add new channels in the future. In this case, our code must be changed
    in both applications, and we should always avoid the situations that are *error
    prone*. A good approach is to use the microcontroller only for input reporting
    and let the Android application manage and transform received raw data. We use
    this approach only for the scope of the book to help you get more comfortable
    with the sketch code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sending multiple data with Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Using Sensors to Listen to the Environment"),
    *Using Sensors to Listen to the Environment*, we needed to send a single byte
    computed by the microcontroller. However, in most common cases, we need to read
    data from different sensors or physical components and we may need to send them
    back to Android at once. In this prototype, we should observe this requirement
    because the microcontroller must read all three values and send them back with
    only one ADK write. A simple approach is to build a string that represents our
    triple, and uses the comma to separate these values with the format `<playback>,<volume>,<station>`.
    Through this representation, we obtain the following values :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then we can write the *serialized* representation of the radio state in the
    ADK buffer and proceed with the *deserialization* in the Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may think about implementing or using a more complex communication protocol
    to transfer generic data from Arduino to Android, but we should always bear in
    mind that, at the beginning, every good idea must follow the **KISS principle**:
    **Keep It Simple**, **Stupid** (a design principle noted by the U.S. Navy in 1960).
    Because the more simple the software, the more likely it is to work well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write the accessory descriptor at the top of the sketch, like the
    following proposed code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a second buffer that will hold the triple; we can add its declaration
    just before the ADK buffer variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the sketch, add the following function to write the triple
    in the ADK buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `writeBuffer()` function expects three parameters used in triple building.
    To achieve this, we use the `sprintf()` function to write these values in the
    intermediate `triple` buffer. In the `sprintf()` function call, we also use the
    `normalizeVolume()` and `mapStations()` functions to get the transformed values.
    We then use the `memcpy()` function to write the `triple` variable in the ADK
    `buffer`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need this extra step because we cannot write the `triple` variable in the
    ADK `buffer`. The `adk.write()` function expects an `unsigned char*` type while
    the triple is a `char*` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the ADK buffer contains the serialized data, we have to remove all
    `Serial` calls and rewrite the main `loop()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the ADK is ready, we read data from the push button and both potentiometers,
    and then we serialize these values in a triple that will be written in the ADK
    output buffer. When everything is ready, we send the recorded input back to Android.
  prefs: []
  type: TYPE_NORMAL
- en: We can now update our sketch and complete the prototype with the Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming audio from Android applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android operating system provides a great collection of UI components, an
    important building block for all physical applications. All of them are specific
    for phone or tablet interaction and this is an outstanding improvement because
    users already know how to use them. However, Android isn't just a collection of
    UI components because it allows many APIs to achieve recurring tasks. In our case,
    we want a physical application that is capable of interacting with a web service
    to open and reproduce an audio stream.
  prefs: []
  type: TYPE_NORMAL
- en: Without the i.MX6 processor and the Android operating system, this task will
    never be easy to implement, but in our case, UDOO board provides all that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Android user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Android Studio, start a new application called **WebRadio** with **Android
    API 19**. During the bootstrap process, choose a **Blank Activity** named **Radio**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first goal is to change the default layout in favor of a simple but fancy
    interface. The main layout must show the current activated radio station providing
    different information such as an optional image—the name of the channel together
    with a description. Before writing down the XML code required by Android to draw
    the user interface, we should plan our work to detect the required components.
    In the following screenshot, we can take a look at the user interface mock-up
    that provides all the required elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the Android user interface](img/1942OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The above layout includes a number marker that defines in which order the components
    will be created. According to this layout, we should provide three different views
    in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, we should create a background frame with a different color
    to provide a block in which we will put all other components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if this is optional, we can prepare a box that will host the radio channel
    image, if it's available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last block includes two different text areas where the first represents
    the channel name, while the other represents the channel description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this layout design, we should proceed and replace the standard theme with
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `res/values/dimens.xml` resource file, add the following definitions
    to provide some dimensions for our components, such as the background frame height
    and the font size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `res/values/styles.xml` resource file, add the following colors used
    by the background frame and text elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `activity_radio.xml` file under `res/layout/`, replace the `RelativeLayout`
    with the following `FrameLayout` to implement the background frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `FrameLayout` to create a section that houses all other components
    with the defined height and background color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `LinearLayout` nested in the above `FrameLayout` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first `LinearLayout` will contain the `radio_image` `ImageView` that changes
    according to the active channel. The second `LinearLayout` is used to host the
    radio name and description.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add within the second `LinearLayout` the following views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'According to previous defined styles, the following is the obtained layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the Android user interface](img/1942OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we can proceed with the logic implementation, we have to get all view
    references during the `onCreate()` callback through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following declarations at the top of the `Radio` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the `onCreate()` callback, add the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the layout is completed, we can proceed with the ADK configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the ADK Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin the web radio implementation, we should first configure the
    *ADKToolkit* like we did in the previous chapter. To have a working ADK configuration,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the *ADKToolkit* library dependency in the `build.gradle` file under `app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sync your Gradle configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the accessory filter file `usb_accessory_filter.xml` under `res/xml/`
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the *USB accessory support* option requirement and the *USB accessory intent
    filter* option in the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Radio.java` class file, declare the `AdkManager` object at the top of
    the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `AdkManager` initialization inside the `onCreate` method of the `Radio`
    activity class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `onPause()` and `onResume()` callbacks to start and stop the ADK
    connection according to the activity lifecycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The above checklist should be used every time we start a new project. It's a
    good idea to write down these steps and be sure that our projects always start
    with this ADK configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a last step of the initial configuration, we need to add the Internet access
    permission because we are going to use network streams. Add in the following permission
    inside the tag manifest in your `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Changing web radio stations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to write the required Android code to play and stop configured
    radio stations. What we need is to formalize the station object and a utility
    class that abstracts the same functionalities of the built-in media player. The
    following is the checklist of required classes with their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Station`: Formalizes the audio channel and includes the title, the description,
    and the station image, together with the streaming URL required to start the remote
    playback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadioManager`: Configures all available stations during its initialization
    and abstracts all common methods to manage the playback and the channel switching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We begin with the `Station` class that we can realize with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java package inside our namespace called `streaming`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `Station` class in the newly created Java package and add the following
    declarations and class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the first part of the URL that we will use to construct the channel
    streaming URL. In this case, we are going to use the **Jamendo** service that
    offers many music channels that are released under the **Creative Commons** license.
    If you want to get more information, you can take a look at the service website:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://www.jamendo.com](https://www.jamendo.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other attributes that we will use are the station `title` and `description`
    attributes and the Android resource identifier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the bottom of the class, the following getters are used to retrieve instance
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `getStreamUrl()` method, we are using the base URL with the radio name
    to find the correct audio stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This string concatenation is related to how the Jamendo service works. If you
    use another service or you don't want to use the title attribute during the URL
    composition, you should change this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have a formal `Station` class representation, we need to define
    the class capable of managing the Android playback. We realize the `RadioManager`
    class through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `streaming` package, create the `RadioManager` class and add the following
    declarations at the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the Android high-level `MediaPlayer` object to manage remote streaming;
    we make use of some status variables, such as the current active station with
    its array index and the playback status. We will fill the `mChannels` `ArrayList`
    object during the `RadioManager` class initialization and it will host all the
    available music channels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the initializer method at the bottom of the class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first part, we configure the list of all the available stations according
    to the previous `Station` constructor. We configure the `MediaPlayer` object so
    that it starts a network stream immediately when the prepare process is completed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find more information about how the Android `MediaPlayer` class works
    at the URL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following methods to abstract the play and stop functionalities to
    prevent code repeating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the player is stopped, we have to reset the media player object because
    we may need to set another data source immediately. The `play` method sets the
    streaming URL of the current activated station and starts a nonblocking prepare
    task.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following public method that changes the playback status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The sketch through the ADK sends continuous data to our application every 100
    milliseconds and this enhances the responsiveness of the user interface. However,
    we don't want to repeat the same command many times, so we only do something if
    the value received is different from the stored one. In the second part, we choose
    to start or play the current stream according to the given parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As the last part, we need a method to change the activated channel. Add the
    following code at the bottom of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we did earlier, we avoid changing the station if the received value is the
    same as the one we currently played. Then, we update the current channel and stop
    the last stream. In this way, if we are in the playback state, we can safely reproduce
    a new station stream. In any case, we return the chosen `Station` instance, or
    `null` if the station has not changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading input from physical devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like we did in the previous chapter, we need to prepare our application to
    make continuous readings of user input available in the ADK buffer. As we did
    before, we are going to create a Java interface that exposes the required methods
    to update the user interface. We can achieve this through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java interface called `OnDataChanges` and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the `Radio` class implement the preceding interface through the highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the interface code at the end of the class to update the Android
    user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this part, we simply update all views according to the `station` instance
    attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last required step is to implement our scheduled thread that reads processed
    data from the microcontroller and updates the `MediaPlayer` class streaming together
    with the Android user interface. To complete this last building block, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package in your namespace called `adk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `adk` package, add a new class named `DataReader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class, add the following declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like we did in the previous chapter, we're defining the polling time and the
    message type used by the main thread handler. We also store the references for
    the `AdkManager` parameter and the caller activity to use, respectively, the ADK
    read method and the `updateStation` function's callback. Then we define the `ExecutorService`
    method implementation together with the main thread `Handler`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `DataReader` constructor to set the message handler when the
    main thread receives a new message from the background thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We store the `AdkManager` and the `caller` activity references and then set
    a `Handler` attached to the application's main looper. The `handleMessage` callback
    checks the message code to identify the `STATION_UPDATE` messages. In this case,
    we call the `updateStation` method and pass the attached object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the bottom of `DataReader` class, add the following private class that implements
    the `Runnable` interface to read and manage the physical input devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the thread starts, we read user inputs using the `AdkManager` method. Then
    we get the raw string from the response and use the split method to deserialize
    the received triple. The first position refers to the playback status and we use
    it in the `RadioManager` class to start or stop the playback. The value in the
    third position is the activated channel and we pass this to the `changeStation`
    method. According to the previous implementation, if the `currentStation` variable
    is not changed, we avoid publishing the message to the main thread to prevent
    useless interface redraws.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a method to the `DataReader` class to start the scheduler that spawns short-lived
    threads periodically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like we did in the previous project, we use a scheduler that spawns a single
    `InputThread` parameter every time at a `INPUT_POLLING` variable milliseconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the stop method at the bottom of the class to stop the scheduler from spawning
    new threads through the `shutdown` executor''s method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we should go back to the `Radio` class to start and stop the scheduler
    within the activity lifecycle. Add the `DataReader` method declaration at the
    top of the `Radio` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the `RadioManager` class and the `DataReader` instance when the
    activity is created through the following highlighted code, that you should add
    at the bottom of the `onCreate()` callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start and stop the reading scheduler in the `onResume()` and `onPause()` activity''s
    callbacks as you can see in the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these last steps, the radio station is completed and we can upload the
    Android application in the UDOO board and start playing with the station knob
    and the push button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we didn't manage network errors, be sure that UDOO is connected to the
    Internet and that you're using the Ethernet or the Wi-Fi network adapter, otherwise
    the application will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Managing audio volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can release our first radio prototype, we should manage the volume
    knob from the Android application. This part is really easy thanks to the `MediaPlayer`
    method APIs, because it exposes a public method to change the volume of the activated
    stream. To improve our project with a volume manager, we need to add the following
    code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `RadioManager` class, add the highlighted declaration at the top of
    the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the `RadioManager` class, add this public method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method `setVolume` expects the float received from Arduino as argument and
    we use it to change the volume of the `mMediaPlayer` instance. However, because
    we don't want to change the volume for little variations, we discard all requests
    for values that aren't so different from the previous recorded input.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the volume parsing and the `setVolume` function call within the `InputThread`
    implementation that we wrote in the `DataReader` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this last piece, the web radio is completed and we can proceed with this
    last deployment. Now our users can interact and enjoy the prototype using both
    knobs and the push button to control every aspect of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go further with other prototypes, we should think about how we can
    improve our devices when some unexpected events occur. A good starting point is
    to think about error handling and, in particular, what happens if the Android
    application stops hearing incoming data from the accessory. There are many approaches
    to prevent wrong actions and a good solution is to include a default behavior
    in the Android application that the prototype should follow in these emergency
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: We could have used another periodic timer that increases a variable every time
    it gets executed. When the `InputThread` instance completes a successful reading,
    it should reset the above variable. In this way, we can monitor for how much time
    we stop receiving user inputs and according to this time, we may decide to change
    the application's behavior. Through this variable, for example, we could stop
    the radio playback, or turn down the volume a little bit if the accessory stops
    providing user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The key point is that we should always design our prototype both for failure
    and success. Most *what happens if* problems are easy to incorporate up front,
    but hard to add in later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to improve the quality of our prototypes when
    human interaction is required. We explored some of the common physical components
    that can be used to alter or control Android applications. Through powerful Android
    APIs, we built a web radio capable of complex tasks like network streaming.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we built the required circuit using two potentiometers and
    a push button. When we checked returned values through the serial monitor, we
    saw that they are not so useful in this format, so we wrote a mapping and a normalization
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We continued providing a new layout for the Android application, but we avoided
    adding any kind of interaction through the user interface. We wrote a class to
    abstract all possible interactions with the built-in media player, so that we
    can easily control this component in any part of our application. Indeed, we used
    it within the background task, and every time it read user inputs, it immediately
    changed the state of the radio. In this way, we enabled the push button to start
    and stop the playback and the two potentiometers to change the active station
    and the music volume.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we start talking about home automation. We start from scratch
    a new prototype capable of turning on and off external devices using a combination
    of sensor values and users settings. We will make use of other Android APIs to
    store the application's settings and use them later to alter the sketch flow.
  prefs: []
  type: TYPE_NORMAL
