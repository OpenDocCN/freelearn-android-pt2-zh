["```kt\n    std::string Flickr_GetListURL( const std::string& BaseURL,\n    int MaxResults,\n    int PageIndex,\n    const std::string& SearchQuery )\n    {\n      std::string Result = BaseURL + std::string( \"&api_key=\" );\n      Result += AppKey;\n      if ( !SearchQuery.empty() )\n      {\n      Result += std::string( \"&q=\\\"\" ) + \n      SearchQuery + std::string( \"\\\"\" );\n      }\n      Result += std::string( \"&per_page=\" );\n      Result += IntToStr( MaxResults );\n    ```", "```kt\n      if ( PageIndex > -1 )\n      {\n      Result += std::string( \"&page=\" ) + \n      IntToStr( PageIndex + 1 );\n      }\n      return Result;\n    }\n    ```", "```kt\n    std::string Picasa_GetListURL( const std::string& BaseURL,\n    int MaxResults,\n    int PageIndex,\n    const std::string& SearchQuery )\n    {\n      std::string Result = BaseURL;\n\n      Result +=  std::string( \"kind=photo&imgmax=1600\" );\n\n      if ( !SearchQuery.empty() )\n      {\n      Result += std::string( \"&q=\\\"\" ) + \n      SearchQuery + std::string( \"\\\"\" );\n      }\n\n      Result += std::string( \"&max-results=\" );\n      Result += IntToStr( MaxResults );\n\n      if ( PageIndex > 0 )\n      {\n      Result += std::string( \"&start-index=\" ) + \n      IntToStr( ( int )( 1 + PageIndex * MaxResults ) );\n      }\n\n      return Result;\n    }\n    ```", "```kt\n    const std::string AppKey = \"YourAppKeyHere\";\n    const std::string FlickrAPIBase = \"http://api.flickr.com/services/rest/?method=\";\n\n    const std::string FlickrFavoritesURL = FlickrAPIBase + \"flickr.interestingness.getList\";\n    const std::string FlickrRecentURL    = FlickrAPIBase + \"flickr.photos.getRecent\";\n\n    const std::string PicasaAPIBase = \"http://picasaweb.google.com/data/feed/api/\";\n\n    const std::string PicasaFavoritesURL = PicasaAPIBase + \"featured/?\";\n    const std::string PicasaRecentURL    = PicasaAPIBase + \"all/?\";\n    ```", "```kt\nstring URL = Flickr_GetListURL(FlickrFavoritesURL, 15, 0, \"\");\n```", "```kt\nstring URL = Picasa_GetListURL(PicasaFavoritesURL, 15, 1, \"\");\n```", "```kt\n    void Flickr_ParseXMLResponse( const std::string& Response,\n      std::vector<std::string>& URLs )\n    {\n      using std::string::npos;\n      size_t begin = Response.find( \"<photos\" );\n      if ( begin == npos ) { return; }\n      begin = Response.find_first_of( '>', begin );\n      if ( begin == npos ) { return; }\n      size_t end = Response.find( \"/photos>\" );\n      if ( end == npos ) { return; }\n      size_t cur = begin;\n      size_t ResLen = Response.length();\n    ```", "```kt\n      while ( cur < ResLen )\n      {\n        using std::string::npos;\n        size_t s_begin = Response.find( \"<photo\", cur );\n        if ( s_begin == npos ) { break; }\n        size_t s_end = Response.find( \"/>\", s_begin );\n        if ( s_end == npos ) { break; }\n        std::string Part = Response.substr( s_begin,s_end - s_begin + 2 );\n        URLs.push_back( Part );\n        cur = s_end + 2;\n      }\n    }\n    ```", "```kt\n    void Picasa_ParseXMLResponse( const std::string& Response, \n    std::vector<std::string>& URLs )\n    {\n      using std::string::npos;\n      size_t cur = 0;\n      size_t ResLen = Response.length();\n    ```", "```kt\n      while ( cur < ResLen )\n      {\n        size_t s_begin = Response.find( \"<media:content \",cur );\n        if ( s_begin == npos ) { break; }\n        size_t s_end = Response.find( \"/>\", s_begin );\n        if ( s_end == npos ) { break; }\n        std::string new_s = Response.substr( s_begin,s_end - s_begin + 2 );\n        URLs.push_back( ExtractURLAttribute( new_s,\"url=\\'\", '\\'' ) );\n        cur = s_end + 2;\n      }\n    }\n    ```", "```kt\n    std::string ExtractURLAttribute( const std::string& InStr,\n      const std::string& AttrName,\n      char Delim )\n    {\n      size_t AttrLen = AttrName.length();\n      size_t pos = InStr.find( AttrName );\n    ```", "```kt\n      if ( pos != std::string::npos )\n      {\n        for ( size_t j = pos+AttrLen ; j < InStr.size() ; j++ )\n        {\n          if ( InStr[j] == Delim ) { break; }\n        }\n        return InStr.substr( pos + AttrLen, j - pos - AttrLen );\n      }\n      return \"\";\n    }\n    ```", "```kt\n    std::string Flickr_GetDirectImageURL( const std::string& InURL,\n      int ImgSizeType )\n    {\n    ```", "```kt\n    string id     = ExtractURLAttribute(InURL, \"id=\\\"\", '\"');\n    string secret = ExtractURLAttribute(InURL, \"secret=\\\"\", '\"');\n    string server = ExtractURLAttribute(InURL, \"server=\\\"\", '\"');\n    string farm   = ExtractURLAttribute(InURL, \"farm=\\\"\", '\"');\n    ```", "```kt\n    std::string Res = std::string( \"http://farm\" ) + farm +\n    std::string( \".staticflickr.com/\" ) + server +\n    std::string( \"/\" ) + id + std::string( \"_\" ) + secret;\n    std::string Fmt = \"\";\n    ```", "```kt\n    if ( ImgSizeType == PHOTO_SIZE_128       ) { Fmt = \"t\"; }\n    else if ( ImgSizeType == PHOTO_SIZE_256  ) { Fmt = \"m\"; }\n    else if ( ImgSizeType == PHOTO_SIZE_512  ) { Fmt = \"-\"; }\n    else if ( ImgSizeType == PHOTO_SIZE_1024 ) { Fmt = \"b\"; }\n    else if ( ImgSizeType == PHOTO_SIZE_ORIGINAL ) { Fmt = \"b\"; };\n    return Res + std::string( \"_\" ) + Fmt + std::string( \".jpg\" );\n    }\n    ```", "```kt\n    std::string Picasa_GetDirectImageURL( const std::string& InURL,\n      int ImgSizeType )\n    {\n      std::string Fmt = \"\";\n\n      if ( ImgSizeType == PHOTO_SIZE_128       ) \n        { Fmt = \"/s128/\"; }\n        else if ( ImgSizeType == PHOTO_SIZE_256  )\n        { Fmt = \"/s256/\"; }\n        else if ( ImgSizeType == PHOTO_SIZE_512  )\n        { Fmt = \"/s512/\"; }\n        else if ( ImgSizeType == PHOTO_SIZE_1024 )\n        { Fmt = \"/s1024/\"; }\n        else if ( ImgSizeType == PHOTO_SIZE_ORIGINAL )\n        { Fmt = \"/s1600/\"; };\n\n      size_t spos = InURL.find( \"/s1600/\" );\n\n      if ( spos == std::string::npos ) { return \"\"; }\n      const size_t Len = strlen(\"/s1600/\");\n      return InURL.substr( 0, spos ) + Fmt +\n      InURL.substr( spos+Len, InURL.length()-spos-Len );\n    }\n    ```", "```kt\n    enum PhotoSize\n    {\n       PHOTO_SIZE_128     = 0,\n       PHOTO_SIZE_256     = 1,\n       PHOTO_SIZE_512     = 2,\n       PHOTO_SIZE_1024    = 3,\n       PHOTO_SIZE_ORIGINAL = 4\n    };\n    ```", "```kt\nstd::vector<std::string> Images;\nvoid Picasa_ParseXMLResponse( Response, Images);\n\n```", "```kt\nImageURL = Picasa_GetDirectImageURL(Images[0],\nPHOTO_SIZE_128);\n```", "```kt\n    #ifndef _WIN32\n    #include <pthread.h>\n    typedef pthread_t thread_handle_t;\n    typedef pthread_t native_thread_handle_t;\n    #else\n    #include <windows.h>\n    typedef uintptr_t thread_handle_t;\n    typedef uintptr_t native_thread_handle_t;\n    #endif\n    ```", "```kt\n    class iThread\n    {\n    public:\n      iThread::iThread():FThreadHandle( 0 ), FPendingExit(false) {}\n      virtual ~iThread() {}\n      void Start();\n      void Exit( bool Wait );\n      bool IsPendingExit() const { return FPendingExit; };\n    protected:\n      virtual void Run() = 0;\n    ```", "```kt\n    #ifdef _WIN32\n      static unsigned int __stdcall EntryPoint( void* Ptr );\n    #else\n      static void* EntryPoint( void* Ptr );\n    #endif\n      native_thread_handle_t GetCurrentThread();\n    private:\n      volatile bool FPendingExit;\n      thread_handle_t FThreadHandle;\n    };\n    ```", "```kt\n    void iThread::Start()\n    {\n      void* ThreadParam = reinterpret_cast<void*>( this );\n\n    #ifdef _WIN32\n      unsigned int ThreadID = 0;\n      FThreadHandle = ( uintptr_t )_beginthreadex( NULL, 0, &ThreadStaticEntryPoint, ThreadParam, 0, &ThreadID );\n\n    #else\n      pthread_create( &FThreadHandle, NULL, ThreadStaticEntryPoint, ThreadParam );\n      pthread_detach( FThreadHandle );\n    #endif\n    }\n    ```", "```kt\nclass TestThread: public iThread\n{\npublic:\n  virtual void Run()\n  {\n    printf(\"Test\\n\");\n    Sleep(1000);\n  }\n};\n\nvoid Test()\n{\n  TestThread* Thread = new TestThread();\n  Thread->Start();\n  while (true) {}\n}\n```", "```kt\n    class Mutex\n    {\n    public:\n      Mutex()\n      {\n    #if defined( _WIN32 )\n        InitializeCriticalSection( &TheCS );\n    #else\n        pthread_mutex_init( &TheMutex, NULL );\n    #endif\n      }\n      ~Mutex()\n      {\n    #if defined( _WIN32)\n        DeleteCriticalSection( &TheCS );\n    #else\n        pthread_mutex_destroy( &TheMutex );\n    #endif\n      }\n    ```", "```kt\n      void Lock() const\n      {\n    #if defined( _WIN32 )\n        EnterCriticalSection( (CRITICAL_SECTION*)&TheCS );\n    #else\n        pthread_mutex_lock( &TheMutex );\n    #endif\n      }\n\n      void Unlock() const\n      {\n    #if defined( _WIN32 )\n        LeaveCriticalSection( (CRITICAL_SECTION*)&TheCS );\n    #else\n        pthread_mutex_unlock( &TheMutex );\n    #endif\n      }\n\n    #if defined( _WIN32 )\n      CRITICAL_SECTION TheCS;\n    #else\n      mutable pthread_mutex_t TheMutex;\n    #endif\n    };\n    ```", "```kt\nclass Lock\n{\npublic:\n  explicit Lock( const clMutex* Mutex ) : FMutex( Mutex )\n{ FMutex->Lock(); };\n  ~Lock() { FMutex->Unlock(); };\nprivate:\n  const Mutex* FMutex;\n};\n```", "```kt\nLock( &SomeMutex );\n```", "```kt\nclass iObject\n{\npublic:\n  iObject(): FRefCounter(0) {}\n  virtual ~iObject() {}\n  void    IncRefCount()\n  {\n#ifdef _WIN32\n    return InterlockedIncrement( &FRefCounter );\n#else\n    return __sync_fetch_and_add( &FRefCounter, 1 );\n#endif\n  }\n  void    DecRefCount()\n  {\n#ifdef _WIN32\n    if ( InterlockedDecrement( &FRefCounter ) == 0 )\n#else\n    if ( __sync_sub_and_fetch( Value, 1 ) == 0 )\n#endif\n    { delete this; }\n  }\nprivate:\n  volatile long    FRefCounter;\n};\n```", "```kt\n    template <class T> class clPtr\n    {\n    public:\n      clPtr(): FObject( 0 ) {}\n      clPtr( const clPtr& Ptr ): FObject( Ptr.FObject )\n      {\n    ```", "```kt\n        LPtr::IncRef( FObject );\n      }\n      template <typename U>\n      clPtr( const clPtr<U>& Ptr ): FObject( Ptr.GetInternalPtr() )\n      {\n        LPtr::IncRef( FObject );\n      }\n      ~clPtr()\n      {\n    ```", "```kt\n        LPtr::DecRef( FObject );\n      }\n    ```", "```kt\n      clPtr( T* const Object ): FObject( Object )\n      {\n        LPtr::IncRef( FObject );\n      }\n    ```", "```kt\n      clPtr& operator = ( const clPtr& Ptr )\n      {\n        T* Temp = FObject;\n        FObject = Ptr.FObject;\n\n        LPtr::IncRef( Ptr.FObject );\n        LPtr::DecRef( Temp );\n\n        return *this;\n      }\n    ```", "```kt\n      inline T* operator -> () const\n      {\n        return FObject;\n      }\n    ```", "```kt\n      template <typename U>\n      inline clPtr<U> DynamicCast() const\n      {\n        return clPtr<U>( dynamic_cast<U*>( FObject ) );\n      }\n    ```", "```kt\n      template <typename U>\n      inline bool operator == ( const clPtr<U>& Ptr1 ) const\n      {\n        return FObject == Ptr1.GetInternalPtr();\n      }\n    ```", "```kt\n      inline T* GetInternalPtr() const\n      {\n        return FObject;\n      }\n    private:\n      T*    FObject;\n    };\n    ```", "```kt\nclass SomeClass: public iObject {};\nvoid Test()\n{\n  clPtr<SomeClass> Ptr = new SomeClass();\n}\n```", "```kt\nif ( SomeSmartPointer ) ...\n```", "```kt\nprivate:\n   class clProtector\n  {\n  private:\n    void operator delete( void* );\n  };\npublic:\n  inline operator clProtector* () const\n  {\n    if ( !FObject ) return NULL;\n    static clProtector Protector;\n    return &Protector;\n  }\n```", "```kt\nclass SomeContainer;\nclass SomeElement: public iObject\n{\n```", "```kt\n  SomeContainer* Parent;\n};\n\nclass SomeContainer: public iObject\n{\n```", "```kt\n  std::vector< clPtr<SomeElement> > Elements;\n};\n```", "```kt\n    class iTask: public iObject\n    {\n    public:\n      iTask()\n      : FIsPendingExit(false)\n      , FTaskID(0)\n      , FPriority(0) {};\n    ```", "```kt\n      virtual void Run() = 0;\n    ```", "```kt\n      virtual void Exit() { FIsPendingExit = true; }\n    ```", "```kt\n      virtual bool IsPendingExit() const volatile\n        { \n        return FIsPendingExit; }\n    ```", "```kt\n      virtual void   SetTaskID( size_t ID ) { FTaskID = ID; };\n      virtual size_t GetTaskID() const { return FTaskID; };\n    private:\n      volatile bool           FIsPendingExit;\n      size_t                  FTaskID;\n    };\n    ```", "```kt\n    class WorkerThread: public iThread\n    {\n    public:\n    ```", "```kt\n      virtual void   AddTask( const clPtr<iTask>& Task );\n      virtual bool   CancelTask( size_t ID );\n      virtual void   CancelAll();\n      …\n    ```", "```kt\n    private:\n      clPtr<iTask> ExtractTask();\n      clPtr<iTask> FCurrentTask;\n    private:\n      std::list< clPtr<iTask> >   FPendingTasks;\n      tthread::mutex              FTasksMutex;\n      tthread::condition_variable FCondition;\n    };\n    ```", "```kt\nclass TestTask: public iTask\n{\npublic:\n  virtual void Run()\n  {\n    printf(\"Test\\n\");\n  }\n};\n\nint main()\n{\n  WorkerThread* wt = new WorkerThread();\n  wt->Start( iThread::Priority_Normal );\n```", "```kt\n  wt->AddTask( new TestTask() );\n  wt->AddTask( new TestTask() );\n  wt->AddTask( new TestTask() );\n```", "```kt\n  while (wt->GetQueueSize() > 0) {}\n\n  return 0;\n}\n```", "```kt\n    class iAsyncCapsule: public iObject\n    {\n    public:\n      virtual void Invoke() = 0;\n    };\n    ```", "```kt\n    class AsyncQueue\n    {\n    public:\n      AsyncQueue(): FDemultiplexerMutex()\n      , FCurrentQueue( 0 )\n      , FAsyncQueues( 2 )\n      , FAsyncQueue( &FAsyncQueues[0] )\n      { }\n    ```", "```kt\n      void EnqueueCapsule( const clPtr<iAsyncCapsule>& Capsule )\n      {\n        LMutex Mutex( &FDemultiplexerMutex );\n        FAsyncQueue->push_back( Capsule );\n      }\n    ```", "```kt\n      void DemultiplexEvents()\n      {\n        CallQueue* LocalQueue = &FAsyncQueues[ FCurrentQueue ];\n\n        {\n          LMutex Lock( &FDemultiplexerMutex );\n    ```", "```kt\n          FCurrentQueue = ( FCurrentQueue + 1 ) % 2;\n          FAsyncQueue = &FAsyncQueues[ FCurrentQueue ];\n        }\n    ```", "```kt\n        for ( CallQueue::iterator i = LocalQueue->begin();\n         i != LocalQueue->end(); ++i )\n         (*i)->Invoke();\n         LocalQueue->clear();\n      }\n    private:\n      size_t FCurrentQueue;\n\n      typedef std::vector< clPtr<iAsyncCapsule> > CallQueue;\n      std::vector<CallQueue> FAsyncQueues;\n\n      CallQueue* FAsyncQueue;\n      Mutex FDemultiplexerMutex;\n    };\n    ```", "```kt\nclass ResponseThread: public iThread, public AsyncQueue\n{\npublic:\n  virtual void Run() { while (true) { DemultiplexEvents(); } }\n};\nResponseThread* Responder;\n```", "```kt\nclass RequestThread: public iThread\n{\npublic:\n  virtual void Run()\n  {\n    while ( true )\n    {\n      Responder->EnqueueCapsule( new TestCall() );\n      Sleep(1000);\n    }\n  }\n};\n```", "```kt\nclass TestCall: public iAsyncCapsule\n{\npublic:\n  virtual void Invoke() { printf(\"Test\\n\"); }\n};\n```", "```kt\nint main()\n{\n   (Responder = new ResponseThread())->Start();\n   (new RequestThread())->Start();\n    while (true) {}\n    return 0;\n}\n```", "```kt\nTest\nTest\nTest\n…\n```", "```kt\n    void DownloadTask::Run()\n    {\n      clPtr<DownloadTask> Guard( this );\n      CURL* C = curl_easy_init();\n    ```", "```kt\n      curl_easy_setopt( C, CURLOPT_URL, FURL.c_str() );\n      curl_easy_setopt( C, CURLOPT_FOLLOWLOCATION, 1 );\n      curl_easy_setopt( C, CURLOPT_NOPROGRESS, false );\n      curl_easy_setopt( C, CURLOPT_FAILONERROR, true );\n      curl_easy_setopt( C, CURLOPT_MAXCONNECTS, 10 );\n      curl_easy_setopt( C, CURLOPT_MAXFILESIZE, DownloadSizeLimit );\n      curl_easy_setopt( C, CURLOPT_WRITEFUNCTION, &MemoryCallback );\n      curl_easy_setopt( C, CURLOPT_WRITEDATA, this );\n      curl_easy_setopt( C, CURLOPT_PROGRESSFUNCTION,\n        &ProgressCallback );\n      curl_easy_setopt( C, CURLOPT_PROGRESSDATA, this );\n      curl_easy_setopt( C, CURLOPT_CONNECTTIMEOUT, 30 );\n      curl_easy_setopt( C, CURLOPT_TIMEOUT, 60 );\n    ```", "```kt\n      curl_easy_setopt( C, CURLOPT_SSL_VERIFYPEER, 0 );\n      curl_easy_setopt( C, CURLOPT_SSL_VERIFYHOST, 0 );\n    ```", "```kt\n      FCurlCode = curl_easy_perform( Curl );\n    ```", "```kt\n      curl_easy_getinfo( Curl, CURLINFO_RESPONSE_CODE, &FRespCode );\n      curl_easy_cleanup( Curl );\n    ```", "```kt\n      if ( FDownloader ) { FDownloader->CompleteTask( this ); }\n    }\n    ```", "```kt\nvolatile bool g_ShouldExit = false;\n\nclass TestCallback: public DownloadCompleteCallback\n{\npublic:\n  TestCallback() {}\n```", "```kt\n  virtual void Invoke()\n  {\n    printf(\"Download complete\\n\");\n    printf(\"%s\\n\", (unsigned char*)FResult->GetData());\n    g_ShouldExit = true;\n  }\n};\n\nint main()\n{\n  Curl_Load();\n  iAsyncQueue* Events = new iAsyncQueue();\n  Downloader* d = new Downloader();\n  d->FEventQueue = Events;\n  …\n  d->DownloadURL(\n  \"http://api.flickr.com/services/rest/?method=flickr.test.echo&name=value\", 1, new TestCallback()\n);\n```", "```kt\n  while (!g_ShouldExit)\n  {\n    Events->DemultiplexEvents();\n  }\n  …\n}\n```", "```kt\nstruct sAdapterInfo\n{\n```", "```kt\n  char FName[256];\n```", "```kt\n  char FIP[128];\n```", "```kt\n  char FID[256];\n};\n```", "```kt\n    bool Net_EnumerateAdapters( std::vector<sAdapterInfo>& Adapters )\n    {\n      struct ifaddrs* MyAddrs, *ifa;\n      void* in_addr;\n      char buf[64];\n    ```", "```kt\n      if ( getifaddrs( &MyAddrs ) != 0 ) { return false; }\n      …\n    ```", "```kt\n      for ( ifa = MyAddrs; ifa != NULL; ifa = ifa->ifa_next )\n      {\n        if ( ( ifa->ifa_addr == NULL ) ||\n        !( ifa->ifa_flags & IFF_UP ) ) { continue; }\n    ```", "```kt\n        switch ( ifa->ifa_addr->sa_family )\n        {\n          case AF_INET:\n          { in_addr = &( ( struct sockaddr_in* )\n          ifa->ifa_addr )->sin_addr;   break; }\n\n          case AF_INET6:\n          { in_addr = &( ( struct sockaddr_in6* )\n          ifa->ifa_addr )->sin6_addr; break; }\n\n          default:\n            continue;\n        }\n    ```", "```kt\n        if ( inet_ntop( ifa->ifa_addr->sa_family,in_addr, buf, sizeof( buf ) ) )\n        {\n          sAdapterInfo Info;\n          strcpy( Info.FName, ifa->ifa_name );\n          strcpy( Info.FIP, buf );\n          sprintf( Info.FID, \"%d\", Idx );\n          Adapters.push_back( Info );\n          Idx++;\n        }\n      }\n    ```", "```kt\n      freeifaddrs( MyAddrs );\n    ```", "```kt\n  int main()\n  {\n    std::vector<sAdapterInfo> a;\n    Net_EnumerateAdapters( a );\n\n    for(size_t i = 0 ; i < a.size() ; i++)\n    {\n      printf(\"[%d] %s\\n\", i + 1, a[i].FIP);\n    }\n    return 0;\n  }\n```", "```kt\n<uses-permission\nandroid:name=\"android.permission.INTERNET\"/>\n<uses-permission\nandroid:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n```", "```kt\n      while ( !IsPendingExit() )\n      {\n        LTCPSocket* NewSocket = in->Accept();\n        if ( NewSocket != 0 )\n        {\n          // Add new thread\n          HTTPRequestThread* T = new HTTPRequestThread();\n          T->FServer = this;\n          T->FSocket = NewSocket;\n          T->Start();\n        }\n      }\n    ```", "```kt\ng_Server = new HTTPServerThread();\n```", "```kt\nif ( !Adapters.empty() )\n{\n  g_Server->FBindAddress = Adapters[0].FIP;\n}\n```", "```kt\ng_Server->Start();\n```"]