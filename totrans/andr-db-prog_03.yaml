- en: Chapter 3. SQLite Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we kicked our database building up a notch – transforming
    a simple schema involving just one, lone table, into a complex schema involving
    three interdependent tables. And now that we have a solid foundation in developing
    custom SQLite databases for Android, it's time to put the icing on the cake.
  prefs: []
  type: TYPE_NORMAL
- en: Though in theory, we could have one universal `get()` query which returns to
    us all columns of every row in our database as a `Cursor` object, and then filter
    and manipulate each row for our desired data – we can do better. Don't get me
    wrong – Java is fast – but when it comes to dealing with potentially thousands
    of rows of data on relatively limited memory, why not optimize things and let
    SQL do what it does best – that is, query for things!
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, we will focus on striking the right balance between parsing
    and filtering your data on the Android client side (that is, with the Java interface),
    and building a more advanced SQL query and parsing/filtering your data in the
    SQLite database itself.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for building SQLite queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s establish the different ways in which we can build a query. Just
    like we saw earlier, the most low-level method for querying the SQLite database
    is through the `SQLiteDatabase` class''s `rawQuery()` method, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method is primarily for those with a strong background in SQL, as you pass
    SQL queries directly into the method as the first parameter. If your SQL query
    involves any sort of `WHERE` filter, then the second parameter allows you to pass
    in these filter values (we'll see several examples of this in use soon).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second query method the `SQLiteDatabase` class provides you with is a convenience
    wrapper for submitting queries – with the `query()` method (something we also
    saw earlier) any actual SQL programming is hidden and, instead, all parts of the
    query are passed in as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With alternative `query()` methods containing parameters for `distinct` and
    `limit` constraints. Again, the previous parameters should be relatively self-explanatory,
    but all these methods will make the most sense when seen together for one given
    query. However, before moving on to those examples, let's take a look at the third
    method for building SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This third method is one we haven''t seen yet and comes from the `SQLiteQueryBuilder`
    class. Instead of having to submit raw SQL queries, or having to deal with convenience
    methods, which still may seem intimidating to those completely new to SQL, the
    Android platform decided to provide an entire convenience class to help developers
    interact with their SQLite databases as seamlessly as possible. Though this class
    has many methods associated with it (and I invite you to browse the developer
    docs online for more details), the following are some of the more important methods
    that we''ll be highlighting later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous method is a convenience method for constructing a `SELECT` statement,
    which can be used then for a group of `SELECT` statements that will be joined
    through a `UNION` operator in the `buildUnionQuery()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A method which allows you to pass in a set of `SELECT` statements (potentially
    constructed using the `buildQuery()` convenience method) and constructs a query
    that will return the `UNION` of those subqueries is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Builds a SQL query with the given parameters, similar to the `SQLiteDatabase`
    class''s `query()` method but simply returns the query as a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The above allows you to set your current query as `DISTINCT` rows only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Allows you to set the list of tables to query and if multiple tables are passed,
    in then it allows you to perform a `JOIN` on those tables.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we have a list of all the different methods available to us, let's
    explore some basic SQLite queries and look at how we would perform relatively
    simple queries using each of the methods described previously!
  prefs: []
  type: TYPE_NORMAL
- en: SELECT statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using our `Students` schema from [Chapter 2](ch02.html "Chapter 2. Using a
    SQLite Database"), *Using a SQLite Database*, let''s begin with a glimpse at what
    our `Students` table looks like at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Id | Name | State | Grade |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Jason Wei | IL | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Du Chung | AR | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | George Tang | CA | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Mark Bocanegra | CA | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Bobby Wei | IL | 12 |'
  prefs: []
  type: TYPE_TB
- en: 'In this way, for each query that we do, we''ll know exactly what results we
    should expect and, thus, we can validate our queries. Before we dive right, in
    here''s a list of what we''ll cover in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT` statements with column specifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WHERE` filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND/OR` operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISTINCT` clause'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIMIT` clause'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''ll be a lot to take in at once, especially for those with no prior SQL
    experience, but once you learn these basic building blocks, you''ll be well on
    your way to building longer, more complex queries. And so, let''s begin with the
    most basic `SELECT` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that in the first method, we're simply passing in the standard
    SQL query, while in the second method we are breaking down the query into its
    different parameters (that is, its table name, its selection filters, and so on).
    Finally, in the last method, which we notice looks very similar to the second
    method (for now), we again break down the query into its different parameters,
    but instead of returning a `Cursor`, our method returns the query as a String,
    which we can then execute as a raw query. The reasoning behind this is that one
    of SQLiteQueryBuilder's strengths is that you can specify multiple queries and
    submit them all at the same time and effectively perform a `UNION` SQL query -
    but again we will play with this functionality later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the results from those queries and see if we can
    validate the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELECT statements](img/8123OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looks pretty good to me! We see that each method was able to return all rows
    of our table as expected. Under the third method, we can also see the query that
    was constructed using our `SQLiteQueryBuilder` class and indeed verify that the
    SQL query we submitted in the first method matches that built-in the third method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, say you have a large table with thousands of rows of data and with tens
    of columns - for the sake of both efficiency and memory, it''s often suggested
    in practice that you don''t return the entire table with your queries but, instead,
    refine your queries to only return those columns of data of interest! And so,
    let''s take a look at how we can specify which columns to return in our `SELECT`
    queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And so, we see that the overall structure of the query is the same for all
    three methods, but in methods two and three, we pass in a `String[]` containing
    the columns of data that we want. Again, just to verify that our queries are behaving
    the way we want them to, here''s the output of those queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELECT statements](img/8123OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And so we see that indeed we are able to return each student, along with their
    respective states. Finally again, notice the query that is constructed in the
    third method and compare it to the raw SQL query that was passed to the first
    method – they should match exactly and they do.
  prefs: []
  type: TYPE_NORMAL
- en: WHERE filters and SQL operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, oftentimes it''s important to be able to filter your data not just by
    columns but also by column values! This is where the `WHERE` filter comes in handy
    and these `WHERE` filters will definitely be the most-used clause you will run
    into as a database developer. On that note, let''s take a look at how these `WHERE`
    filters (also known as selection parameters in Android) are implemented with our
    three query-building methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the first method, we can see how a standard SQL `WHERE` clause is formatted.
    Knowing this, with our second and third methods we see that, we can just pass
    into the selection parameter a string formatted like the `WHERE` clause but omitting
    the `WHERE` itself (this is automatically appended to your query for you). This
    can explicitly be seen with the constructed query returned by our `SQLiteQueryBuilder`
    class in the third method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WHERE filters and SQL operators](img/8123OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just like with any programming language, you can filter logic through the use
    of `AND/OR` operators; the same applies to SQL and, specifically, with SQL `WHERE`
    filters. Instead of asking for all rows which satisfy one set of conditions, you
    can write queries which would return rows that satisfy all given conditions, or
    more loosely, just one of several given conditions. An example of this is as follows,
    where instead of only returning students from Illinois, we utilize the SQL `OR`
    operator and also ask for students from Arkansas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you''ll notice that the syntax is, again, very similar to the earlier
    example, but this time we''ve injected an `OR` operator into the `WHERE` filter
    (selection parameter) and have placed two selection arguments (that is, the ''?'')
    instead of one. It''s important to note that the order of arguments contained
    in your `String[]` is important more specifically, that the first String in your
    array will correspond to the first ''?'' place card, and so on. And of course,
    if you want to use the `AND` operator, then just apply the previous syntax but
    replacing `OR` with `AND`. Taking a quick peak at the output, we see as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WHERE filters and SQL operators](img/8123OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And so now our buddy Du has popped into the result set!
  prefs: []
  type: TYPE_NORMAL
- en: DISTINCT and LIMIT clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Powering on, let''s take a look at the `DISTINCT` clause in SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `DISTINCT` clause is also relatively straightforward it allows you to specify
    in your query that for the given columns you only want to return a subset of rows
    which have distinct values for that column. Notice that I emphasize for the given
    columns, as in order for the `DISTINCT` clause to be meaningful, a column must
    be specified in your query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my previous example, we''ll notice a couple of things. First off, in our
    query, notice that we follow the `DISTINCT` clause with the column that we want
    it to apply to namely the `State` column. Essentially, we''re asking my query
    to return to us a subtable with all of the distinct states in my database. Said
    another way, we want to know what states our students come from and only want
    one row per state. Another thing worth mentioning is that we''ve switched the
    `query()` statement that we were previously using in the second method - this
    time switching it to a more general `query()` method which has parameters for
    specifying a `DISTINCT` clause. The results for this query were:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DISTINCT and LIMIT clauses](img/8123OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Which is indeed the case for our current table! And last but not least, let''s
    take a look at the `LIMIT` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LIMIT` clause simply allows you to limit how many rows to return. The
    `LIMIT` clause takes on two formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LIMIT n, m`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIMIT n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first format tells the query to return just m rows (that is, limiting how
    many rows to return) starting from row n. The second format simply tells the query
    to return the first n rows which satisfy the given conditions. The first format
    definitely provides us with more flexibility, but, unfortunately, neither the
    second nor the third method allows us to take advantage of this format (due to
    the way that it automatically constructs the query for us), while the first format
    (the raw SQL query) can execute any valid SQL query. This is a small example of
    the versatility that executing raw SQL queries gives us, and is a perfect example
    of trading versatility for convenience and abstraction. In any case, let''s just
    make one last sanity check here to make sure our queries are actually only returning
    three rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DISTINCT and LIMIT clauses](img/8123OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yup - looks good to me! In all methods, even though we didn't specify any `WHERE`
    filters, we were still only returned the first three valid results, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at a number of clauses built-into the SQL language
    which allow us to have control over our data. By introducing these clauses one
    by one, the hope was that you could first see all of the pieces of the puzzle.
    Then, when the time comes for you to implement your own database, you'll be able
    to put the pieces together and execute powerful queries which quickly return meaningful
    data. However, before we wrap up this chapter, let's look at some advanced queries,
    which will take more time to master and understand, but again will add another
    tool under your belt.
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY and GROUP BY clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at some of the more advanced and more nuanced
    features of the SQL language as well as their implementations in the various SQL
    convenience classes of Android. Again, before we dive in and attack these features,
    here''s a list of what we''ll be covering in this next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ORDER BY` clauses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROUP BY` clauses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HAVING` filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JOINS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So let''s look at `ORDER BY` clauses in SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the syntax for the `ORDERBY` clause is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So in the first method, we see this syntax in action, and then in the latter
    two methods, we see that we simply need to pass in the column name followed by
    either `ASC` or `DESC` (as a String) into the `ORDERBY` parameter of the respective
    query methods. In the latter two methods, the syntax is essentially the same,
    and so I won''t go into too much detail here, but the important part is simply
    to know the components of an SQL `ORDERBY` clause. In all three methods shown,
    we are sorting our resulting subtable by the state column, and so to validate
    our query, we check the output and see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ORDER BY and GROUP BY clauses](img/8123OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, indeed, we see that the resulting rows are sorted in ascending order by
    the state. Furthermore, just like with the basic queries, we can see the outputted
    SQL query that is created by the `SQLiteQueryBuilder` class, and can verify that
    this is the same query that is executed in our first method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, moving on to `GROUPBY` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is again crucial to understand the structure of a `GROUPBY` query,
    as it is unlike any of the previous clauses or filters that we have seen. The
    structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The trickiest part is in the `aggregate_function(your_column)` segment of the
    query. In our case, we use what's known as the `COUNT()` function in SQL, which,
    as its name suggests, simply counts the number of rows returned in a query (or
    subquery) and returns the counted value. You can use any number of `aggregate_functions`
    in SQL, but for now let's stick with `COUNT()` and later when we discuss SQL Functions,
    I'll list out some of the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is simple – first we''re selecting a column to group our data
    by (in our case, by state), and then we''re telling the query to return two columns:
    the first is simply the states themselves, and the second is the number of times
    that state appears in our table (that is, the aggregate number of states in our
    table). You''ll also notice that in both the second and third methods, the way
    the `GROUPBY` query is done is pretty simple, but the only tricky part is specifying
    the column name with the `COUNT()` function wrapped around it (see how we declare
    the String `colName)`. Once you do that, the rest is straightforward and behaves
    just like a standard `SELECT` query with columns! Note that the `COUNT()` function
    also takes a * as a parameter, which simply returns a count of all the rows in
    the subtable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, let''s see what our output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ORDER BY and GROUP BY clauses](img/8123OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And voila! Just as we expected – our queries return each state followed by their
    respective frequencies!
  prefs: []
  type: TYPE_NORMAL
- en: HAVING filters and Aggregate functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, with `GROUPBY` clauses come the `HAVING` filters. The `HAVING` filter is
    to be used only with a `GROUPBY` clause, and taking the previous queries as an
    example, say we want to group by the number of states in our table, but we only
    care about states that appear a certain number of times. With the `HAVING` filter,
    we can essentially phrase our query such that it groups by the number of states,
    and then only returns those states having a total count greater or less than some
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code and pay close attention to how I structure
    my query (it will look very similar to the `GROUPBY` query but with an extra filter
    at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And so you have it. Again, notice the structure of my query in the first method
    and notice how it translates into the `HAVING` parameter of the query convenience
    methods in the second and third methods. Let''s see now how the query did and
    whether or not it eliminated AR from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HAVING filters and Aggregate functions](img/8123OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Perfect - pretty straightforward. Earlier we ran into the `COUNT()` aggregate
    function, which along with `SUM()` and `AVG()` are amongst the most popular of
    the aggregate functions (see here for the full list: [http://www.sqlite.org/lang_aggfunc.html)](http://www.sqlite.org/lang_aggfunc.html)).
    These functions, like their names suggest, either count the total number of rows
    returned in a particular column of your subtable, or sum of the values of that
    column in your subtable, or average of the values of that column in your subtable,
    and so on. First, let''s examine some of these aggregate functions, listed as
    follows (notice how the column names change):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here we use each of the three methods to test out a different aggregate
    function. The results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HAVING filters and Aggregate functions](img/8123OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After referencing the state of the table from earlier, you can quickly validate
    the outputted numbers and confirm that the functions are indeed doing as they
    should. Outside of aggregate functions (which are typically used for numerical-typed
    columns), SQLite also provides you with an assortment of other core functions
    that help you manipulate everything from Strings to Date types, and so on. A complete
    list of these core functions can be found [http://www.sqlite.org/lang_corefunc.html](http://www.sqlite.org/lang_corefunc.html)
    but for now, let''s just take a look at a couple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, here is the associated output of these core functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HAVING filters and Aggregate functions](img/8123OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, as far as how much of a performance boost running some of these functions
    in SQLite as opposed to just doing them on the Java side, this is debatable and
    is highly dependent on the size of your database and the function you are calling.
    For instance, some string manipulation functions may not offer as much of a performance
    boost as other more complex aggregate functions. In fact, this SQLite to Java
    comparison is something we'll look more into in the next section, but regardless,
    it's always better to be aware of the functions available to you in SQLite and
    add them to your arsenal of weapons!
  prefs: []
  type: TYPE_NORMAL
- en: 'And lastly, it''s about time we looked at the benefits of using the `SQLiteQueryBuilder`
    (until now, much of the syntax was very similar to just the `query()` method in
    `SQLiteDatabase)` and see how we can leverage this convenience class to perform
    more complicated joins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, let me point out a couple of things specific to `JOIN` statements. In
    essence, a `JOIN` statement allows you to connect two tables based on some column
    values. For example, in our case, our schema was built so that we would have a
    table for classes and each class would be a mapping between the student ID and
    the course ID. But, let's say that we want to quickly know not just what the class
    mappings are but also the course's name for each mapping (that is, the name of
    the course and who is taking that class). Instead of having to return all the
    class mappings as well as the course listings (that is, asking for two tables
    back) and then manually doing these lookups, we can use an SQL `JOIN` statement
    to return a joint table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, because when doing `JOIN` statements we are asking for multiple tables
    back, oftentimes when you ask for specific columns to return, you''ll need to
    specify what table the column comes from. For instance, consider a situation where
    both tables have ID fields - in this case, simply asking for the ID column will
    cause an error, as it''s ambiguous which table''s ID column you really want. This
    is what we''re doing when we initiate the strings `courseIdCol, classIdCol`, and
    `classCourseIdCol`, and the syntax is simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in our `SQLiteQueryBuilder` class, we use the method `setTables()` to
    format our `JOIN` statement. Again, you can see the exact syntax that we used
    in the previous example, but the general format is first you specify the two tables
    that you want to join and then you tell the query what kind of `JOIN` you want
    (in our case, we want to use an `INNER JOIN)`. Afterwards, you need to tell the
    query what two columns to perform the `JOIN` on, and again, in our case, we want
    to connect the two tables by the course ID, and so we specify the course ID column
    of our `Class` table and also specify the corresponding course ID column of our
    `Course` table. By doing this, the `JOIN` statement knows that for each class
    mapping, it should take the course ID and then go to the `Course` table and find
    that corresp onding course ID and append that row of the table to the `Class`
    table. For an in-depth discussion on both the different kinds of JOINs as well
    as the syntax for each, I invite you to look at [http://www.w3schools.com/sql/sql_join.asp](http://www.w3schools.com/sql/sql_join.asp)
    and read through the documentation. The output for the previous `JOIN` statement
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HAVING filters and Aggregate functions](img/8123OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And so you can immediately see both the syntax of the query as well as the results.
  prefs: []
  type: TYPE_NORMAL
- en: SQL vs. Java performance comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So just how powerful and efficient is the SQL language? In the previous two
    sections, we explored both basic and more advanced features of SQL – all of whose
    functionality (in theory) could be mimicked with just Java (that is, just do a
    bare-bones `SELECT` statement to get back the entire table and parse it with Java
    `if` statements, and so on). However, it's time to explore if there's an actual
    added advantage to filtering and manipulating our data on the SQLite end (as opposed
    to on the Java end), and if so, how much of an advantage it provides. And so,
    to start, we'll need a much bigger data set to better illustrate the improvements
    in performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a new table under a new schema which simply has a column for
    name, state, and income – think of this as a United States database with each
    family''s name, the state they live in, and their family income. The table has
    17,576 rows - still not a lot considering the magnitude of some real application
    tables - but hopefully this test table will illustrate some of these performance
    differences. Let''s begin with the `WHERE` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'On the SQLite side, we''re simply using a `WHERE` filter which returns to us
    all families in our table that have a family income of over 500,000\. On the Java
    side, we get back the entire table and loop through each row and use an `if` statement
    to perform the same filtering. We can verify that the outputted rows are the same,
    and at the same time look at the speeds of the two methods for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL vs. Java performance comparisons](img/8123OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So we see that here there''s almost a 5x boost in performance! Next, let''s
    take a look at the performance boost gained when using the `GROUPBY` clause. On
    the SQLite side, we''ll simply be doing a `GROUPBY` statement on the states column
    and will ask to count up how many families are from each state. Then, on the Java
    side, we''ll ask for the whole table back and manually go through each row, using
    a standard `Map` object to keep track of each state and its respective count as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s see how well we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL vs. Java performance comparisons](img/8123OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So we see that in this case, the performance boost was there but less noticeable,
    giving us a 33 percent boost in efficiency. It''s important to note that these
    stated statistics are highly dependent on the schema and size of your tables,
    so take these numbers with a grain of salt. However, the goal of these little
    experiments is to just give us an idea of how these two methodologies compare.
    Lastly, let''s take a look at how a built-in aggregate function like `avg()` in
    SQL compares with Java. The code for both methodologies is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And taking a quick look at what the output gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL vs. Java performance comparisons](img/8123OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And wow – enough said. The results for both methods are the same, but when using
    the SQL function you saw a 16x gain in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by focusing on the Android OS and by looking at
    what types of query methods are at your disposal. We saw that there are three
    well-known ways to interact with the SQLite database, some more 'convenient' than
    the others, and some more flexible and powerful than the others.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also saw that though each method had its pros and cons, all three
    query methods could ultimately perform the same kinds of queries, just using different
    sets of syntax or using different sets of parameters. This is when we moved away
    from the methods themselves and focused more on the query itself, starting with
    simple queries, which ranged from the most basic `SELECT` queries to more involved
    queries that allowed you to specify specific columns and rows. And later, we talked
    about more advanced queries, which ranged from `ORDERBY` and `GROUPBY` queries
    to the most complex and involved `JOIN` statements.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, being the curious and performance-minded programmers that we are,
    we spent the last section comparing the speeds of SQL and Java implementing a
    variety of queries in both SQL and Java and then running them to look at the respective
    speeds. We saw that in each case, being able to embed your desired functionality
    into an SQL query granted you a performance boost when compared to executing that
    same functionality in Java (in one case it gave us as much as a 16x performance
    boost). And so, the moral of the story for this section is that when possible,
    find ways to manipulate your data on the SQL side as opposed to the Java side,
    as it will help you optimize speed as well as memory usage!
  prefs: []
  type: TYPE_NORMAL
- en: But before moving on, let's take a second to synthesize what we've learned so
    far. Earlier in [Chapter 2](ch02.html "Chapter 2. Using a SQLite Database"), *Using
    a SQLite Database*, we learned about implementing SQLite database schemas in your
    Android application, and just now we learned about all the different features
    that are built into SQL which ultimately allow you to work with your data in extremely
    powerful, efficient ways. But now, what if you want to tap into existing data
    on the user's Android device? Each Android device contains a wealth of data, much
    of which is available for external applications to query, and so it's important
    to keep this in mind when developing your application. Furthermore, what if you
    want to expose your database and schemas to other applications? What if you're
    building a task list application and you want to allow other applications (perhaps
    calendar-based applications) to query for the user's existing tasks? All of these
    things are don e through what's called a `ContentProvider`, and it's in the next
    two chapters that we flush out this extremely important class in Android.
  prefs: []
  type: TYPE_NORMAL
