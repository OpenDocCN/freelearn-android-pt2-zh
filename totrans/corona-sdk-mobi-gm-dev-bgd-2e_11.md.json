["```kt\nstore = require(\"store\")\n```", "```kt\nstore.init( listener )\n```", "```kt\nfunction transactionCallback( event )\n  local transaction = event.transaction\n  if transaction.state == \"purchased\" then\n    print(\"Transaction successful!\")\n    print(\"productIdentifier\", transaction.productIdentifier)\n    print(\"receipt\", transaction.receipt)\n    print(\"transactionIdentifier\", transaction.identifier)\n    print(\"date\", transaction.date)\n\n    elseif  transaction.state == \"restored\" then\n    print(\"Transaction restored (from previous session)\")\n    print(\"productIdentifier\", transaction.productIdentifier)\n    print(\"receipt\", transaction.receipt)\n    print(\"transactionIdentifier\", transaction.identifier)\n    print(\"date\", transaction.date)\n    print(\"originalReceipt\", transaction.originalReceipt)\n    print(\"originalTransactionIdentifier\", transaction.originalIdentifier)\n    print(\"originalDate\", transaction.originalDate)\n\n    elseif transaction.state == \"cancelled\" then\n    print(\"User cancelled transaction\")\n\n    elseif transaction.state == \"failed\" then\n    print(\"Transaction failed, type:\", transaction.errorType, transaction.errorString)\n\n    else\n    print(\"unknown event\")\n    end\n\n    -- Once we are done with a transaction, call this to tell the store\n    -- we are done with the transaction.\n    -- If you are providing downloadable content, wait to call this until\n    -- after the download completes.\n    store.finishTransaction( transaction )\nend\n\nstore.init( \"apple\", transactionCallback )\n```", "```kt\nstore.loadProducts( arrayOfProductIdentifiers, listener )\n```", "```kt\n-- Contains your Product ID's set in iTunes Connect\nlocal listOfProducts = \n{\n  \"com.mycompany.InAppPurchaseExample.Consumable\",\n  \"com.mycompany.InAppPurchaseExample.NonConsumable\",\n  \"com.mycompany.InAppPurchaseExample.Subscription\",\n}\n\nfunction loadProductsCallback ( event )\n  print(\"showing valid products\", #event.products)\n  for i=1, #event.products do\n    print(event.products[i].title)\n    print(event.products[i].description)\n    print(event.products[i].price)\n    print(event.products[i].productIdentifier)\n  end\n\n  print(\"showing invalidProducts\", #event.invalidProducts)\n    for i=1, #event.invalidProducts do\n      print(event.invalidProducts[i])\nend\nend\n\nstore.loadProducts( listOfProducts, loadProductsCallback )\n```", "```kt\nevent.products\n```", "```kt\nevent.invalidProducts\n```", "```kt\n    if store.canMakePurchases then\n      store.purchase( listOfProducts )\n    else\n      print(\"Store purchases are not available\")\n    end\n```", "```kt\nstore.purchase( arrayOfProducts )\n```", "```kt\nstore.purchase{ \"com.mycompany.InAppPurchaseExample.Consumable\"}\n```", "```kt\nstore.finishTransaction( transaction )\n```", "```kt\nstore.finishTransaction( transaction )\n```", "```kt\nstore.restore()\n```", "```kt\nfunction transactionCallback( event )\n  local transaction = event.transaction\n  if transaction.state == \"purchased\" then\n    print(\"Transaction successful!\")\n    print(\"productIdentifier\", transaction.productIdentifier)\n    print(\"receipt\", transaction.receipt)\n    print(\"transactionIdentifier\", transaction.identifier)\n    print(\"date\", transaction.date)\n\n  elseif  transaction.state == \"restored\" then\n    print(\"Transaction restored (from previous session)\")\n    print(\"productIdentifier\", transaction.productIdentifier)\n    print(\"receipt\", transaction.receipt)\n    print(\"transactionIdentifier\", transaction.identifier)\n    print(\"date\", transaction.date)\n    print(\"originalReceipt\", transaction.originalReceipt)\n    print(\"originalTransactionIdentifier\", transaction.originalIdentifier)\n    print(\"originalDate\", transaction.originalDate)\n\n  elseif transaction.state == \"cancelled\" then\n      print(\"User cancelled transaction\")\n\n  elseif transaction.state == \"failed\" then\n    print(\"Transaction failed, type:\", transaction.errorType, transaction.errorString)\n\n  else\n    print(\"unknown event\")\n  end\n\n  -- Once we are done with a transaction, call this to tell the store\n  -- we are done with the transaction.\n  -- If you are providing downloadable content, wait to call this until\n  -- after the download completes.\n  store.finishTransaction( transaction )\nend\n\nstore.init( transactionCallback )\nstore.restore()\n```", "```kt\n    local composer = require( \"composer\" )\n    local scene = composer.newScene()\n\n    local ui = require(\"ui\")\n    local movieclip = require( \"movieclip\" )\n    local store = require(\"store\")\n\n    ---------------------------------------------------------------------------------\n    -- BEGINNING OF YOUR IMPLEMENTATION\n    ---------------------------------------------------------------------------------\n\n    local menuTimer\n\n    -- AUDIO\n    local tapSound = audio.loadSound( \"tapsound.wav\" )\n\n    --***************************************************\n\n    -- saveValue() --> used for saving high score, etc.\n\n    --***************************************************\n    local saveValue = function( strFilename, strValue )\n      -- will save specified value to specified file\n      local theFile = strFilename\n      local theValue = strValue\n\n      local path = system.pathForFile( theFile, system.DocumentsDirectory )\n\n      -- io.open opens a file at path. returns nil if no file found\n      local file = io.open( path, \"w+\" )\n      if file then\n        -- write game score to the text file\n        file:write( theValue )\n        io.close( file )\n      end\n    end\n\n    --***************************************************\n\n    -- loadValue() --> load saved value from file (returns loaded value as string)\n\n    --***************************************************\n    local loadValue = function( strFilename )\n      -- will load specified file, or create new file if it doesn't exist\n\n      local theFile = strFilename\n\n      local path = system.pathForFile( theFile, system.DocumentsDirectory )\n\n      -- io.open opens a file at path. returns nil if no file found\n      local file = io.open( path, \"r\" )\n      if file then\n        -- read all contents of file into a string\n        local contents = file:read( \"*a\" )\n        io.close( file )\n        return contents\n      else\n        -- create file b/c it doesn't exist yet\n        file = io.open( path, \"w\" )\n        file:write( \"0\" )\n        io.close( file )\n        return \"0\"\n      end\n    end\n\n    -- DATA SAVING\n    local level2Unlocked = 1\n    local level2Filename = \"level2.data\"\n    local loadedLevel2Unlocked = loadValue( level2Filename )\n    ```", "```kt\n    -- Called when the scene's view does not exist:\n    function scene:create( event )\n      local sceneGroup = self.view\n\n      -- completely remove maingame and options\n      composer.removeScene( \"mainmenu\" )\n      composer.removeScene( \"level1\" )\n      composer.removeScene( \"level2\" )\n\n      print( \"\\nlevelselect: create event\" )\n    end\n    ```", "```kt\n    function scene:show( event )\n      local sceneGroup = self.view\n\n      print( \"levelselect: show event\" )\n\n      local listOfProducts = \n      {\n        -- These Product IDs must already be set up in your store\n        -- Replace Product ID with a valid one from iTunes Connect\n        \"com.companyname.appname.NonConsumable\", -- Non Consumable In-App Purchase\n      }\n    ```", "```kt\n      local validProducts = {} \n        local invalidProducts = {}\n\n        local unpackValidProducts = function()\n            print (\"Loading product list\")\n            if not validProducts then\n                native.showAlert( \"In-App features not available\", \"initStore() failed\", { \"OK\" } )\n            else\n              print( \"Found \" .. #validProducts .. \" valid items \")\n                for i=1, #invalidProducts do\n                  -- Debug:  display the product info \n                    native.showAlert( \"Item \" .. invalidProducts[i] .. \" is invalid.\",{ \"OK\" } )\n                    print(\"Item \" .. invalidProducts[i] .. \" is invalid.\")\n                end\n\n            end\n        end\n    ```", "```kt\n      local loadProductsCallback = function( event )\n        -- Debug info for testing\n            print(\"loadProductsCallback()\")\n            print(\"event, event.name\", event, event.name)\n            print(event.products)\n            print(\"#event.products\", #event.products)\n\n            validProducts = event.products\n            invalidProducts = event.invalidProducts    \n            unpackValidProducts ()\n        end\n    ```", "```kt\n      local transactionCallback = function( event )\n        if event.transaction.state == \"purchased\" then \n          print(\"Transaction successful!\")\n            saveValue( level2Filename, tostring(level2Unlocked) \n        elseif event.transcation.state == \"restored\" then \n          print(\"productIdentifier\", event.transaction.productIdentifier)\n          print(\"receipt\", event.transaction.receipt)\n          print(\"transactionIdentifier\", event.transaction.transactionIdentifier)\n          print(\"date\", event.transaction.date)\n          print(\"originalReceipt\", event.transaction.originalReceipt)\n        elseif event.transaction.state == \"cancelled\" then\n          print(\"Transaction cancelled by user.\")\n        elseif event.transaction.state == \"failed\" then\n          print(\"Transaction failed, type: \", event.transaction.errorType, event.transaction.errorString)\n          local alert = native.showAlert(\"Failed \", infoString,{ \"OK\" })\n        else\n          print(\"Unknown event\")\n          local alert = native.showAlert(\"Unknown \", infoString,{ \"OK\" })\n        end\n        -- Tell the store we are done with the transaction.\n        store.finishTransaction( event.transaction )\n        end\n\n        local setupMyStore = function(event)\n          store.loadProducts( listOfProducts, loadProductsCallback)\n          print (\"After store.loadProducts(), waiting for callback\")\n        end\n    ```", "```kt\n      local backgroundImage = display.newImageRect( \"levelSelectScreen.png\", 480, 320 )\n      backgroundImage.x = 240; backgroundImage.y = 160\n      sceneGroup:insert( backgroundImage )\n\n      local level1Btn = movieclip.newAnim({\"level1btn.png\"}, 200, 60)\n      level1Btn.x = 240; level1Btn.y = 100\n      sceneGroup:insert( level1Btn )\n\n      local function level1touch( event )\n        if event.phase == \"ended\" then\n          audio.play( tapSound )\n          composer.gotoScene( \"loadlevel1\", \"fade\", 300  )\n        end\n      end\n      level1Btn:addEventListener( \"touch\", level1touch )\n      level1Btn:stopAtFrame(1)\n    ```", "```kt\n      -- LEVEL 2\n      local level2Btn = movieclip.newAnim({\"levelLocked.png\",\"level2btn.png\"}, 200, 60)\n      level2Btn.x = 240; level2Btn.y = 180\n      sceneGroup:insert( level2Btn )\n    ```", "```kt\n      local onBuyLevel2Touch = function( event )\n        if event.phase == \"ended\" and level2Unlocked ~= tonumber(loadedLevel2Unlocked) then\n          audio.play( tapSound )\n          composer.gotoScene( \"mainmenu\", \"fade\", 300  )\n    ```", "```kt\n        local buyLevel2 = function ( product ) \n          print (\"Congrats! Purchasing \" ..product)\n\n         -- Purchase the item\n          if store.canMakePurchases then \n            store.purchase( {validProducts[1]} ) \n          else\n            native.showAlert(\"Store purchases are not available, please try again later\",  { \"OK\" } ) – Will occur only due to phone setting/account restrictions\n          end \n        end \n        -- Enter your product ID here\n         -- Replace Product ID with a valid one from iTunes Connect\n     buyLevel2(\"com.companyname.appname.NonConsumable\")\n\n    ```", "```kt\n        elseif event.phase == \"ended\" and level2Unlocked == tonumber(loadedLevel2Unlocked) then\n          audio.play( tapSound )\n          composer.gotoScene( \"loadlevel2\", \"fade\", 300  )\n        end\n      end\n      level2Btn:addEventListener( \"touch\", onBuyLevel2Touch )\n\n      if level2Unlocked == tonumber(loadedLevel2Unlocked) then\n        level2Btn:stopAtFrame(2)\n      end\n    ```", "```kt\n      store.init( \"apple\", transactionCallback) \n        timer.performWithDelay (500, setupMyStore)\n    ```", "```kt\n      local closeBtn\n\n      local onCloseTouch = function( event )\n        if event.phase == \"release\" then\n\n          audio.play( tapSound )\n          composer.gotoScene( \"loadmainmenu\", \"fade\", 300  )\n\n        end\n      end\n\n      closeBtn = ui.newButton{\n        defaultSrc = \"closebtn.png\",\n        defaultX = 100,\n        defaultY = 30,\n        overSrc = \"closebtn.png\",\n        overX = 105,\n        overY = 35,\n        onEvent = onCloseTouch,\n        id = \"CloseButton\",\n        text = \"\",\n        font = \"Helvetica\",\n        textColor = { 255, 255, 255, 255 },\n        size = 16,\n        emboss = false\n      }\n\n      closeBtn.x = 80; closeBtn.y = 280\n      closeBtn.isVisible = false\n      sceneGroup:insert( closeBtn )\n\n      menuTimer = timer.performWithDelay( 200, function() closeBtn.isVisible = true; end, 1 )\n\n    end\n    ```", "```kt\n    -- Called when scene is about to move offscreen:\n    function scene:hide()\n\n      if menuTimer then timer.cancel( menuTimer ); end\n\n        print( \"levelselect: hide event\" )\n\n      end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying levelselect's view\" )\n    end\n\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\n\n    return scene\n    ```"]