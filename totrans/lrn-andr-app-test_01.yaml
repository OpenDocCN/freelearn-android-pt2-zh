- en: Chapter 1. Getting Started with Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 开始测试
- en: Firstly, I will avoid introductions to Android since it is covered in many books
    already, and I am inclined to believe that if you are reading a book that covers
    this more advanced topic, you will have already started with Android development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将避免介绍Android，因为它在许多书中已经有所涉及，我倾向于相信，如果你正在阅读一本涵盖这个更高级话题的书，那么你已经开始了Android开发。
- en: I will be reviewing the main concepts behind testing, and the techniques, frameworks,
    and tools available to deploy your testing strategy on Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将回顾测试背后的主要概念，以及部署在Android上的测试策略的技术、框架和工具。
- en: 'After this overview, we can put the concepts learned into practice. In this
    chapter we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此概述之后，我们可以将所学到的概念付诸实践。在本章中，我们将涵盖以下内容：
- en: Setting up the infrastructure to test on Android
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上设置测试的基础设施
- en: Running unit tests using JUnit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JUnit运行单元测试
- en: Creating an Android instrumentation test project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Android仪器测试项目
- en: Running multiple tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个测试
- en: We will be creating a simple Android project and its companion tests. The main
    project will be bare bones so that you can concentrate on the testing components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的Android项目及其伴随的测试。主项目将非常基础，以便你可以专注于测试组件。
- en: I would suggest that new developers with no Android testing experience read
    this book. If you have more experience with Android projects and have been using
    testing techniques for them, you might read this chapter as a revision or reaffirmation
    of the concepts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议没有Android测试经验的新开发者阅读这本书。如果你在Android项目上有更多经验，并且已经在使用测试技术，你可以将这一章作为复习或对概念的再次确认。
- en: Why, what, how, and when to test?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为何、什么、如何以及何时进行测试？
- en: You should understand that early bug detection saves a huge amount of project
    resources and reduces software maintenance costs. This is the best known reason
    to write tests for your software development project. Increased productivity will
    soon be evident.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该明白，早期发现错误可以节省大量的项目资源并降低软件维护成本。这是为你的软件开发项目编写测试的最佳已知原因。生产力的提高将很快显现。
- en: Additionally, writing tests will give you a deeper understanding of the requirements
    and the problem to be solved. You will not be able to write tests for a piece
    of software you don't understand.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编写测试将使你更深入地理解需求和要解决的问题。对于你不理解的软件，你将无法为其编写测试。
- en: This is also the reason behind the approach of writing tests to clearly understand
    legacy or third-party code and having the testing infrastructure to confidently
    change or update the codebase.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是编写测试以清楚地理解遗留代码或第三方代码的方法背后的原因，以及拥有测试基础设施以自信地更改或更新代码库。
- en: The more the code is covered by your tests, the higher the likelihood of discovering
    hidden bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试覆盖的代码越多，发现隐藏错误的可能性就越高。
- en: If, during this coverage analysis, you find that some areas of your code are
    not exercised, additional tests should be added to cover this code as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在覆盖率分析期间，你发现你的代码某些部分没有被测试，应该添加额外的测试来覆盖这部分代码。
- en: 'To help in this request, enter Jacoco ([http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)),
    an open source toolkit that measures and reports Java code coverage. It supports
    various coverage types, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助实现这一要求，请使用Jacoco（[http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)），这是一个开源工具套件，用于测量和报告Java代码覆盖率。它支持以下各种覆盖率类型：
- en: Class
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Method
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Block
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块
- en: Line
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行
- en: Coverage reports can also be obtained in different output formats. Jacoco is
    supported to some degree by the Android framework, and it is possible to build
    a Jacoco instrumented version of an Android app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告也可以以不同的输出格式获取。Jacoco在某种程度上得到了Android框架的支持，并且可以构建一个Android应用程序的Jacoco检测版本。
- en: We will be analyzing the use of Jacoco on Android to guide us to full test coverage
    of our code in [Chapter 9](part0079_split_000.html#page "Chapter 9. Alternative
    Testing Tactics"), *Alternative Testing Tactics*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](part0079_split_000.html#page "Chapter 9. Alternative Testing Tactics")，*替代测试策略*中分析在Android上使用Jacoco的情况，以指导我们实现代码的全面测试覆盖。
- en: 'This screenshot shows how a Jacoco code coverage report is displayed as an
    HTML file that shows green lines when the code has been tested:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕截图显示了一个Jacoco代码覆盖率报告，该报告显示为一个HTML文件，当代码经过测试时，显示为绿色行：
- en: '![Why, what, how, and when to test?](img/00002.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![为何、什么、如何以及何时进行测试？](img/00002.jpeg)'
- en: By default, the Jacoco gradle plugin isn't supported in Android Studio; therefore,
    you cannot see code coverage in your IDE, and so code coverage has to be viewed
    as separate HTML reports. There are other options available with other plugins
    such as Atlassian's Clover or Eclipse with EclEmma.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Android Studio 不支持 Jacoco gradle 插件；因此，你无法在 IDE 中看到代码覆盖率，所以代码覆盖率必须作为单独的
    HTML 报告查看。其他插件，如 Atlassian 的 Clover 或带有 EclEmma 的 Eclipse，也提供了其他选项。
- en: Tests should be automated, and you should run some or all tests every time you
    introduce a change or addition to your code in order to ensure that all the conditions
    that were met before are still met, and that the new code satisfies the tests
    as expected.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应当自动化，并且每次你对代码进行更改或添加时，都应该运行一些或全部的测试，以确保之前满足的所有条件仍然满足，并且新代码能够如预期那样通过测试。
- en: This leads us to the introduction of **Continuous Integration**, which will
    be discussed in detail in [Chapter 5](part0057_split_000.html#page "Chapter 5. Discovering
    Continuous Integration"), *Discovering Continuous Integration*, enabling the automation
    of tests and the building process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们介绍了**持续集成**，这将在[第五章](part0057_split_000.html#page "第五章. 发现持续集成")《发现持续集成》中详细讨论，它使得测试和构建过程的自动化成为可能。
- en: If you don't use automated testing, it is practically impossible to adopt Continuous
    Integration as part of the development process, and it is very difficult to ensure
    that changes would not break existing code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用自动化测试，实际上将无法把持续集成作为开发过程的一部分，并且很难确保更改不会破坏现有代码。
- en: Having tests stops you from introducing new bugs into already completed features
    when you touch the code base. These regressions are easily done, and tests are
    a barrier to this happening. Further, you can now catch and find problems at compile
    time, that is, when you are developing, rather than receiving them as feedback
    when your users start complaining.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有测试可以防止你在接触代码库时，将新的错误引入已经完成的功能中。这些回归很容易发生，而测试是防止这种情况发生的屏障。此外，你现在可以在编译时捕捉和发现问题，即在你开发时，而不是在用户开始抱怨时收到反馈。 '
- en: What to test
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该测试什么
- en: Strictly speaking, you should test every statement in your code, but this also
    depends on different criteria and can be reduced to testing the main path of execution
    or just some key methods. Usually, there's no need to test something that can't
    be broken; for example, it usually makes no sense to test getters and setters
    as you probably won't be testing the Java compiler on your own code, and the compiler
    would have already performed its tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，你应该测试你的代码中的每一条语句，但这也取决于不同的标准，可以简化为测试执行的主路径或仅一些关键方法。通常，无需测试那些不可能出错的内容；例如，测试
    getters 和 setters 通常没有意义，因为你可能不会在自己的代码上测试 Java 编译器，而且编译器已经执行了其测试。
- en: In addition to your domain-specific functional areas that you should test, there
    are some other areas of an Android application that you should consider. We will
    be looking at these in the following sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你应该测试的特定于域的功能区域之外，还有一些其他需要考虑的 Android 应用程序区域。我们将在以下部分查看这些内容。
- en: Activity lifecycle events
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动生命周期事件
- en: You should test whether your activities handle lifecycle events correctly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该测试你的活动是否正确处理了生命周期事件。
- en: If your activity should save its state during the `onPause()` or `onDestroy()`
    events and later be able to restore it in `onCreate(Bundle` `savedInstanceState)`,
    then you should be able to reproduce and test all these conditions and verify
    that the state was correctly saved and restored.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的活动需要在`onPause()`或`onDestroy()`事件期间保存其状态，并在之后的`onCreate(Bundle savedInstanceState)`中恢复它，那么你应该能够复现并测试所有这些条件，并验证状态是否正确保存和恢复。
- en: Configuration change events should also be tested as some of these events cause
    the current Activity to be recreated. You should test whether the handling of
    the event is correct and that the newly created Activity preserves the previous
    state. Configuration changes are triggered even by a device rotation, so you should
    test your application's ability to handle these situations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也应该测试配置更改事件，因为其中一些事件会导致当前活动被重新创建。你应该测试事件处理是否正确，以及新创建的活动是否保持了之前的状态。配置更改甚至可以由设备旋转触发，因此你应该测试你的应用程序处理这些情况的能力。
- en: Database and filesystem operations
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库和文件系统操作
- en: Database and filesystem operations should be tested to ensure that the operations
    and any errors are handled correctly. These operations should be tested in isolation
    at the lower system level, at a higher level through `ContentProviders`, or from
    the application itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应该测试数据库和文件系统操作，以确保操作和任何错误都能被正确处理。这些操作应该在较低的操作系统级别孤立测试，通过`ContentProviders`在较高级别测试，或者直接从应用程序测试。
- en: To test these components in isolation, Android provides some mock objects in
    the `android.test.mock` package. A simple way to think of a mock is as a drop-in
    replacement for the real object, where you have more control of the object's behavior.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了孤立测试这些组件，Android在`android.test.mock`包中提供了一些模拟对象。简单来说，可以将模拟对象视为真实对象的直接替代品，在这里您可以更控制对象的行为。
- en: Physical characteristics of the device
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备的物理特性
- en: Before shipping your application, you should be sure that all of the different
    devices it can be run on are supported, or at least you should detect the unsupported
    situation and take pertinent measures.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布您的应用程序之前，您应该确保它可以在所有不同的设备上运行，或者至少应该检测到不受支持的情况并采取适当的措施。
- en: 'The characteristics of the devices that you should test are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该测试的设备特性包括：
- en: Network capabilities
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络功能
- en: Screen densities
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕密度
- en: Screen resolutions
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕分辨率
- en: Screen sizes
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕尺寸
- en: Availability of sensors
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器的可用性
- en: Keyboard and other input devices
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘和其他输入设备
- en: GPS
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPS
- en: External storage
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部存储
- en: In this respect, an Android emulator can play an important role because it is
    practically impossible to have access to all of the devices with all of the possible
    combinations of features, but you can configure emulators for almost every situation.
    However, as mentioned before, leave your final tests for actual devices where
    the real users will run the application so you get feedback from a real environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，Android模拟器可以发挥重要作用，因为实际上不可能访问到具有所有可能功能组合的所有设备，但您可以为几乎每种情况配置模拟器。然而，如前所述，将最终的测试留给实际设备，以便真实用户可以运行应用程序，从而从真实环境中获得反馈。
- en: Types of tests
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Testing comes in a variety of frameworks with differing levels of support from
    the Android SDK and your IDE of choice. For now, we are going to concentrate on
    how to test Android apps using the instrumented Android testing framework, which
    has full SDK and ASide support, and later on, we will discuss the alternatives.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试拥有多种框架，它们获得来自Android SDK和您选择的IDE不同程度上的支持。现在，我们将集中讨论如何使用具有完全SDK和ASide支持的instrumented
    Android测试框架来测试Android应用，稍后，我们将讨论其他选择。
- en: Testing can be implemented at any time in the development process, depending
    on the test method employed. However, we will be promoting testing at an early
    stage of the development cycle, even before the full set of requirements has been
    defined and the coding process has been started.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据采用的测试方法，测试可以在开发过程的任何时间实施。然而，我们将提倡在开发周期的早期阶段进行测试，甚至在完整的需求集被定义和编码过程开始之前。
- en: There are several types of tests depending on the code being tested. Regardless
    of its type, a test should verify a condition and return the result of this evaluation
    as a single Boolean value that indicates its success or failure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据被测试的代码，有几种不同类型的测试。无论其类型如何，测试应该验证一个条件，并将此评估的结果作为一个单一的布尔值返回，以指示测试的成功或失败。
- en: Unit tests
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are tests written by programmers for other programmers, and they
    should isolate the component under tests and be able to test it in a repeatable
    way. That's why unit tests and mock objects are usually placed together. You use
    mock objects to isolate the unit from its dependencies, to monitor interactions,
    and also to be able to repeat the test any number of times. For example, if your
    test deletes some data from a database, you probably don't want the data to be
    actually deleted and, therefore, not found the next time the test is ran.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是由程序员编写的，面向其他程序员的测试，它应该隔离被测试的组件，并能以一种可重复的方式进行测试。这就是为什么单元测试和模拟对象通常放在一起的原因。您使用模拟对象来隔离单元与其依赖项，监控交互，并能够多次重复测试。例如，如果您的测试从数据库中删除了一些数据，您可能不希望数据真的被删除，这样在下一次运行测试时数据就找不到了。
- en: JUnit is the de facto standard for unit tests on Android. It's a simple open
    source framework for automating unit testing, originally written by Erich Gamma
    and Kent Beck.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是Android上单元测试的事实标准。它是一个简单的开源框架，用于自动化单元测试，最初由Erich Gamma和Kent Beck编写。
- en: Android test cases use JUnit 3 (this is about to change to JUnit 4 in an impending
    Google release, but as of the time of this writing, we are showing examples with
    JUnit 3). This version doesn't have annotations, and uses introspection to detect
    the tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Android 测试用例使用 JUnit 3（这即将在即将发布的 Google 版本中更改为 JUnit 4，但截至本文撰写之时，我们展示的是使用 JUnit
    3 的示例）。这个版本没有注解，并使用内省来检测测试。
- en: 'A typical Android-instrumented JUnit test would be something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 Android 仪器化 JUnit 测试可能如下所示：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com](http://www.packtpub.com)的账户下载你所购买的所有 Packt 书籍的示例代码文件。如果你在其他地方购买了这本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)注册，我们会直接将文件通过电子邮件发送给你。
- en: The following sections explain the components that can be used to build up a
    test case. Note that these components and the pattern of working with a test case
    are not unique to unit tests, and they can be deployed for the other test types
    that we will discuss in the following sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将解释可用于构建测试用例的组件。请注意，这些组件以及与测试用例工作的模式不仅限于单元测试，它们也可以用于后续部分将要讨论的其他测试类型。
- en: The setUp() method
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`setUp()`方法'
- en: This method is called to initialize the fixture (fixture being the test and
    its surrounding code state).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法被调用来初始化测试夹具（测试夹具是指测试及其周围代码状态）。
- en: Overriding it, you have the opportunity to create objects and initialize fields
    that will be used by tests. It's worth noting that this setup occurs *before*
    every test.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重写此方法，你可以有机会创建对象并初始化测试中将要使用的字段。值得注意的是，此设置在*每个测试之前*发生。
- en: The tearDown() method
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`tearDown()`方法'
- en: This method is called to finalize the fixture.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法被调用来最终确定测试夹具。
- en: Overriding it, you can release resources used by the initialization or tests.
    Again, this method is invoked *after* every test.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重写它，你可以释放初始化或测试中使用的资源。同样，此方法在*每个测试之后*被调用。
- en: For example, you can release a database or close a network connection here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在该方法中释放数据库或关闭网络连接。
- en: There are more methods you can hook into before and after your test methods,
    but these are used rarely, and will be explained as we bump into them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试方法之前和之后，还有更多可以挂钩的方法，但这些方法很少使用，我们将在遇到时进行解释。
- en: Outside the test method
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试方法外部
- en: JUnit is designed in a way that the entire tree of test instances is built in
    one pass, and then the tests are executed in a second pass. Therefore, the test
    runner holds strong references to all test instances for the duration of the test
    execution. This means that for very large and very long test runs with many Test
    instances, none of the tests may be garbage collected until the entire test is
    run. This is particularly important in Android and while testing on limited devices
    as some tests may fail not because of an intrinsic failure but because of the
    amount of memory needed to run the application, in addition to its tests exceeding
    the device limits.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 设计的方式是在一次遍历中构建整个测试实例树，然后在第二次遍历中执行测试。因此，测试运行器在测试执行期间会保持对所有测试实例的强引用。这意味着在包含许多测试实例的大型和长时间测试运行中，所有测试在完整测试运行结束之前都不会被垃圾回收。这对于
    Android 和在有限设备上进行测试尤为重要，因为有些测试可能不是因为内在的失败，而是因为运行应用程序及其测试所需的内存量超过了设备限制而失败。
- en: Therefore, if you allocate external or limited resources in a test, such as
    `Services` or `ContentProviders`, you are responsible for freeing those resources.
    Explicitly setting an object to null in the `tearDown()` method, for example,
    allows it to be garbage collected before the end of the entire test run.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在测试中分配了外部或有限资源，如`Services`或`ContentProviders`，你有责任释放这些资源。例如，在`tearDown()`方法中显式地将对象设置为
    null，允许在完整测试运行结束之前对其进行垃圾回收。
- en: Inside the test method
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试方法内部
- en: All `public` `void` methods whose names start with `test` will be considered
    as a test. As opposed to JUnit 4, JUnit 3 doesn't use annotations to discover
    the tests; instead, it uses introspection to find their names. There are some
    annotations available in the Android test framework such as `@SmallTest`, `@MediumTest`,
    or `@LargeTest`, which don't turn a simple method into a test but organize them
    in different categories. Ultimately, you will have the ability to run tests for
    a single category using the test runner.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以`test`开头的`public` `void`方法都将被视为测试。与JUnit 4不同，JUnit 3不使用注解来发现测试，而是通过内省来查找它们的名字。Android测试框架中提供了一些注解，如`@SmallTest`、`@MediumTest`或`@LargeTest`，它们不会将一个简单方法转换为测试，而是将它们组织在不同的类别中。最终，你将能够使用测试运行器只运行单个类别的测试。
- en: As a rule of thumb, name your tests in a descriptive way and use nouns and the
    condition being tested. Also, remember to test for exceptions and wrong values
    instead of just testing positive cases.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，按照经验法则，以描述性的方式命名你的测试，并使用名词和被测试的条件。同时，记得测试异常和错误值，而不仅仅是测试正面情况。
- en: 'For example, some valid tests and naming could be:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些有效的测试和命名可能为：
- en: '`testOnCreateValuesAreLoaded()`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testOnCreateValuesAreLoaded()`'
- en: '`testGivenIllegalArgumentThenAConversionErrorIsThrown()`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testGivenIllegalArgumentThenAConversionErrorIsThrown()`'
- en: '`testConvertingInputToStringIsValid()`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testConvertingInputToStringIsValid()`'
- en: During the execution of the test, some conditions, side effects, or method returns
    should be compared against the expectations. To ease these operations, JUnit provides
    a full set of `assert*` methods to compare the expected results from the test
    to the actual results after running them, throwing exceptions if the conditions
    are not met. Then, the test runner handles these exceptions and presents the results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试执行期间，应将某些条件、副作用或方法返回与预期进行比较。为了简化这些操作，JUnit提供了一整套`assert*`方法，用于将测试的预期结果与运行后的实际结果进行比较，如果不满足条件，则抛出异常。然后，测试运行器处理这些异常并显示结果。
- en: 'These methods, which are overloaded to support different arguments, include:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被重载以支持不同的参数，包括：
- en: '`assertTrue()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue()`'
- en: '`assertFalse()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse()`'
- en: '`assertEquals()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals()`'
- en: '`assertNull()`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull()`'
- en: '`assertNotNull()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotNull()`'
- en: '`assertSame()`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSame()`'
- en: '`assertNotSame()`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotSame()`'
- en: '`fail()`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail()`'
- en: 'In addition to these JUnit assert methods, Android extends Assert in two specialized
    classes, providing additional tests:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些JUnit断言方法，Android在两个专门的类中扩展了Assert，提供了额外的测试：
- en: '`MoreAsserts`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoreAsserts`'
- en: '`ViewAsserts`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewAsserts`'
- en: Mock objects
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟对象
- en: Mock objects are mimic objects used instead of calling the real domain objects
    to enable testing units in isolation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是代替调用真实领域对象以实现单独测试单元的模仿对象。
- en: Generally, this is accomplished to verify that the correct methods are called,
    but they can also be of great help to isolate your tests from the surrounding
    code and be able to run the tests independently and ensure repeatability.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是为了验证是否调用了正确的方法，但它们也可以帮助你的测试与周围代码隔离，能够独立运行测试并确保可重复性。
- en: The Android testing framework supports mock objects that you will find very
    useful when writing tests. You need to provide some dependencies to be able to
    compile the tests. There are also external libraries that can be used when mocking.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Android测试框架支持模拟对象，这在编写测试时非常有用。你需要提供一些依赖关系才能编译测试。还有一些外部库可以在模拟时使用。
- en: 'Several classes are provided by the Android testing framework in the `android.test.mock`
    package:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Android测试框架在`android.test.mock`包中提供了多个类：
- en: '`MockApplication`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockApplication`'
- en: '`MockContentProvider`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContentProvider`'
- en: '`MockContentResolver`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContentResolver`'
- en: '`MockContext`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContext`'
- en: '`MockCursor`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockCursor`'
- en: '`MockDialogInterface`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockDialogInterface`'
- en: '`MockPackageManager`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockPackageManager`'
- en: '`MockResources`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockResources`'
- en: Almost any component of the platform that could interact with your Activity
    can be created by instantiating one of these classes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎平台中任何可能与你的Activity交互的组件都可以通过实例化这些类之一来创建。
- en: However, they are not real implementations but stubs, the idea being you extend
    one of these classes to create a real mock object and override the methods you
    want to implement. Any methods you do not override will throw an `UnsupportedOperationException`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们并不是真正的实现，而是存根。你需要扩展这些类之一来创建一个真正的模拟对象并覆盖你想实现的方法。任何你没有覆盖的方法将抛出`UnsupportedOperationException`。
- en: Integration tests
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are designed to test the way individual components work together.
    Modules that have been unit tested independently are now combined together to
    test the integration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试旨在测试各个组件一起工作的情况。已经独立进行单元测试的模块现在被组合在一起，以测试集成情况。
- en: Usually, Android Activities require some integration with the system infrastructure
    to be able to run. They need the Activity lifecycle provided by the `ActivityManager`,
    and access to resources, the filesystem, and databases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Android活动需要与系统基础设施集成才能运行。它们需要`ActivityManager`提供的活动生命周期，以及访问资源、文件系统和数据库。
- en: The same criteria apply to other Android components such as `Services` or `ContentProviders`
    that need to interact with other parts of the system to achieve their duty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的标准适用于其他需要与系统其他部分交互以完成任务的Android组件，如`Services`或`ContentProviders`。
- en: In all these cases, there are specialized test classes provided by the Android
    testing framework that facilitates the creation of tests for these components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，Android测试框架提供了一些专门的测试类，便于为这些组件创建测试。
- en: UI tests
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面测试
- en: User Interface tests test the visual representation of your application, such
    as how a dialog looks or what UI changes are made when a dialog is dismissed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面测试检查应用程序的视觉表现，例如对话框的外观或当对话框被关闭时UI的变化。
- en: Special considerations should be taken if your tests involve UI components.
    As you may have already known, only the main thread is allowed to alter the UI
    in Android. Thus, a special annotation `@UIThreadTest` is used to indicate that
    a particular test should be run on that thread and it would have the ability to
    alter the UI. On the other hand, if you only want to run parts of your test on
    the UI thread, you may use the `Activity.runOnUiThread(Runnable` `r)` method that
    provides the corresponding `Runnable`, which contains the testing instructions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试涉及到UI组件，应该特别考虑。你可能已经知道，在Android中只允许主线程修改UI。因此，使用特殊的注解`@UIThreadTest`来指示特定的测试应该在那个线程上运行，并且能够修改UI。另一方面，如果你只想在UI线程上运行测试的部分内容，你可以使用`Activity.runOnUiThread(Runnable
    r)`方法，该方法提供了相应的`Runnable`，其中包含测试指令。
- en: 'A helper class `TouchUtils` is also provided to aid in the UI test creation,
    allowing the generation of the following events to send to the Views, such as:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一个帮助类`TouchUtils`，以辅助UI测试的创建，允许生成以下事件发送到视图：
- en: Click
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击
- en: Drag
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动
- en: Long click
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长按
- en: Scroll
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动
- en: Tap
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击
- en: Touch
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸
- en: By these means, you can actually remote control your application from the tests.
    Also, Android has recently introduced Espresso for UI instrumented tests, and
    we will be covering this in [Chapter 3](part0037_split_000.html#page "Chapter 3. Baking
    with Testing Recipes"), *Baking with Testing Recipes*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方式，你实际上可以从测试中远程控制你的应用程序。另外，Android最近引入了Espresso用于UI自动化测试，我们将在[第3章](part0037_split_000.html#page
    "第3章. 测试配方烘焙")*测试配方烘焙*中进行介绍。
- en: Functional or acceptance tests
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试或验收测试
- en: In agile software development, functional or acceptance tests are usually created
    by business and Quality Assurance (QA) people, and expressed in a business domain
    language. These are high-level tests to assert the completeness and correctness
    of a user story or feature. They are created ideally through collaboration between
    business customers, business analysts, QA, testers, and developers. However, the
    business customers (product owners) are the primary owners of these tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷软件开发中，功能测试或验收测试通常由业务和质量管理（QA）人员创建，并使用业务领域语言表达。这些是高层次的测试，用于验证用户故事或功能的完整性和正确性。理想情况下，这些测试是通过业务客户、业务分析师、QA、测试人员和开发人员的协作创建的。然而，业务客户（产品所有者）是这些测试的主要所有者。
- en: 'Some frameworks and tools can help in this field, such as Calabash ([http://calaba.sh](http://calaba.sh))
    or most notably FitNesse ([http://www.fitnesse.org](http://www.fitnesse.org)),
    which can be easily integrated, up to some point, into the Android development
    process, and will let you create acceptance tests and check their results as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架和工具可以在这个领域提供帮助，例如Calabash（[http://calaba.sh](http://calaba.sh)）或特别值得一提的是FitNesse（[http://www.fitnesse.org](http://www.fitnesse.org)），它们在一定程度上可以轻松集成到Android开发过程中，并允许你创建验收测试并检查结果如下：
- en: '![Functional or acceptance tests](img/00003.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![功能测试或验收测试](img/00003.jpeg)'
- en: Lately, within acceptance testing, a new trend named **Behavior-driven** **Development**
    has gained some popularity, and in a very brief description, it can be understood
    as a cousin of Test-driven Development. It aims to provide a common vocabulary
    between business and technology people in order to increase mutual understanding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 近期，在验收测试中，一种名为**行为驱动开发**（Behavior-driven Development）的新趋势逐渐流行起来。简而言之，它可以被视为测试驱动开发（Test-driven
    Development）的近亲。其目标是为商业和技术人员提供一个共同的词汇，以增加相互理解。
- en: 'Behavior-driven Development can be expressed as a framework of activities based
    on three principles (more information can be found at [http://behaviour-driven.org](http://behaviour-driven.org)):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 行为驱动开发可以表达为一个基于三个原则的活动框架（更多信息可以在 [http://behaviour-driven.org](http://behaviour-driven.org)
    找到）：
- en: Business and technology should refer to the same system in the same way
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业和技术应当以相同的方式指代同一系统
- en: Any system should have an identified, verifiable value to the business
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何系统都应该对商业有一个明确且可验证的价值
- en: Upfront analysis, design, and planning, all have a diminishing return
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前期的分析、设计和规划，其回报都在递减
- en: To apply these principles, business people are usually involved in writing test
    case scenarios in a high-level language and use a tool such as **jbehave** ([http://jbehave.org](http://jbehave.org)).
    In the following example, these scenarios are translated into Java code that expresses
    the same test scenario.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这些原则，商业人员通常会参与用高级语言编写测试案例场景，并使用如**jbehave**（[http://jbehave.org](http://jbehave.org)）之类的工具。在以下示例中，这些场景被翻译成了表达相同测试场景的
    Java 代码。
- en: Test case scenario
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试案例场景
- en: As an illustration of this technique, here is an oversimplified example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这项技术的说明，这里有一个过于简化的例子。
- en: 'The scenario, as written by a product owner, is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 产品所有者编写的场景如下：
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It would be translated into something similar to:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它会被翻译成类似这样的东西：
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This allows both the programmers and the business users to speak the language
    of the domain (in this case, temperature conversions), and both are able to relate
    it back to their day-to-day work.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序员和商业用户都能够使用领域语言（在本例中是温度转换），并且都能够将其与日常工作联系起来。
- en: Performance tests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests measure performance characteristics of the components in a
    repeatable way. If performance improvements are required by some part of the application,
    the best approach is to measure performance before and after a change is introduced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试以可重复的方式测量组件的性能特性。如果应用程序的某些部分需要性能改进，最佳的方法是在引入更改前后测量性能。
- en: As is widely known, premature optimization does more harm than good, so it is
    better to clearly understand the impact of your changes on the overall performance.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，过早的优化弊大于利，因此最好清楚地了解你的更改对整体性能的影响。
- en: The introduction of the **Dalvik JIT** compiler in Android 2.2 changed some
    optimization patterns that were widely used in Android development. Nowadays,
    every recommendation about performance improvements in the Android developer's
    site is backed up by performance tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.2 中引入的**Dalvik JIT**编译器改变了一些在 Android 开发中广泛使用的优化模式。如今，Android 开发者网站上关于性能改进的每一条建议都有性能测试作为支撑。
- en: System tests
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试
- en: 'The system is tested as a whole, and the interaction between the components,
    software, and hardware is exercised. Normally, system tests include additional
    classes of tests such as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 系统作为一个整体进行测试，组件、软件和硬件之间的交互得到锻炼。通常，系统测试包括如下额外的测试类别：
- en: GUI tests
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI 测试
- en: Smoke tests
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒烟测试
- en: Mutation tests
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异测试
- en: Performance tests
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Installation tests
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装测试
- en: Android Studio and other IDE support
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android Studio 和其他 IDE 支持
- en: JUnit is fully supported by Android Studio, and it lets you create tested Android
    projects. Furthermore, you can run the tests and analyze the results without leaving
    the IDE (to some extent).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 完全得到 Android Studio 的支持，它允许你创建经过测试的 Android 项目。此外，你还可以在不离开 IDE 的情况下运行测试并分析结果（在一定程度上）。
- en: This also provides a more subtle advantage; being able to run the tests from
    the IDE allows you to debug the tests that are not behaving correctly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这还提供了一个更微妙的优点；能够从 IDE 中运行测试，允许你调试那些行为不正确的测试。
- en: 'In the following screenshot, we can see how ASide runs **19 unit tests**, taking
    1.043 seconds, with **0** **Errors** and **0** **Failure**s detected. The name
    of each test and its duration is also displayed. If there were a failure, the
    **Failure** **Trace** would show the related information, as shown in the following
    screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们可以看到ASide运行了**19个单元测试**，耗时1.043秒，检测到**0**个**错误**和**0**个**失败**。每个测试的名称及其持续时间也显示出来。如果出现失败，**失败**
    **追踪**将显示相关信息，如下面的截图所示：
- en: '![Android Studio and other IDE support](img/00004.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio和其他IDE支持](img/00004.jpeg)'
- en: There is also Android support in Eclipse IDE using the Android Development Tools
    plugin.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse IDE也通过使用Android Development Tools插件支持安卓。
- en: Even if you are not developing in an IDE, you can find support to run the tests
    with gradle (check [http://gradle.org](http://gradle.org) if you are not familiar
    with this tool). The tests are run using the command `gradle connectedAndroidTest`.
    This will install and run the tests for the debug build on a connected Android
    device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不在IDE中开发，你也可以找到支持使用gradle运行测试的方法（如果你不熟悉这个工具，请查看[http://gradle.org](http://gradle.org)）。测试是通过使用命令`gradle
    connectedAndroidTest`运行的。这将安装并在连接的安卓设备上为调试版本运行测试。
- en: This is actually the same method that Android Studio uses under the hood. ASide
    will just run the Gradle commands to build the project and run the tests, although
    with selective compilation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上与Android Studio在后台使用的方法相同。ASide将运行Gradle命令来构建项目并运行测试，尽管是选择性编译。
- en: Java testing framework
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java测试框架
- en: The Java testing framework is the backbone of Android testing, and sometimes,
    you can get away without writing Android-specific code. This can be a good thing,
    because as we continue on our testing quest, you will notice that we deploy Android
    framework tests to a device, and this has an impact on the speed of our tests,
    that is, the speed we get feedback from a pass or a fail.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Java测试框架是安卓测试的支柱，有时你可以不编写针对安卓特定的代码。这可以是一件好事，因为随着我们继续测试任务，你会注意到我们将安卓框架测试部署到设备上，这对我们测试的速度有影响，即我们从测试通过或失败中获取反馈的速度。
- en: If you architect your app in a clever way, you can create pure Java classes
    that can be tested in isolation away from Android. The two main benefits of this
    are increased speed of feedback from test results, and also, to quickly plug together
    libraries and code snippets to create powerful test suites, you can use the near
    ten years of experience of other programmers doing Java testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你巧妙地架构你的应用程序，你可以创建纯Java类，可以在脱离安卓的环境中进行隔离测试。这样做的两个主要好处是提高测试结果反馈的速度，并且可以快速将库和代码片段组合起来创建强大的测试套件，你可以利用其他程序员近十年的Java测试经验。
- en: Android testing framework
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓测试框架
- en: Android provides a very advanced testing framework that extends the industry
    standard JUnit library with specific features that are suitable to implement all
    of the testing strategies and types we mentioned before. In some cases, additional
    tools are needed, but the integration of these tools is, in most of the cases,
    simple and straightforward.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了一个非常先进的测试框架，它扩展了行业标准JUnit库，具有适合实现我们之前提到的所有测试策略和类型的具体特性。在某些情况下，需要额外的工具，但大多数情况下，这些工具的集成是简单直接的。
- en: 'Most relevant key features of the Android testing environment include:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓测试环境最相关的主要特性包括：
- en: Android extensions to the JUnit framework that provide access to Android system
    objects
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓扩展了JUnit框架，提供访问安卓系统对象的功能
- en: An instrumentation framework that lets the tests control and examine the application
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许测试控制和检查应用程序的仪器化框架
- en: Mock versions of commonly used Android system objects
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用安卓系统对象的模拟版本
- en: Tools to run single tests or test suites, with or without instrumentation
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单个测试或测试套件的工具，可以选择是否使用仪器化
- en: Support to manage tests and test projects in Android Studio and at the command
    line
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持在Android Studio和命令行中管理和测试测试项目和测试
- en: Instrumentation
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪器化
- en: The instrumentation framework is the foundation of the testing framework. Instrumentation
    controls the application under tests and permits the injection of mock components
    required by the application to run. For example, you can create mock Contexts
    before the application starts and let the application use it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器化框架是测试框架的基础。仪器化控制被测应用程序，并允许注入应用程序运行所需的模拟组件。例如，你可以在应用程序启动之前创建模拟上下文，并让应用程序使用它。
- en: All the interactions of the application with the surrounding environment can
    be controlled using this approach. You can also isolate your application in a
    restricted environment to be able to predict the results that force the values
    returned by some methods, or that mock persistent and unchanged data for the `ContentProvider's`
    databases or even the filesystem content.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以控制应用与周围环境的所有交互。你还可以在受限环境中隔离你的应用，以便能够预测某些方法返回的强制值，或者为 `ContentProvider`
    的数据库甚至文件系统内容模拟持久且不变的数据。
- en: A standard Android project has its instrumentation tests in a correlated source
    folder called `androidTest`. This creates a separate application that runs tests
    on your application. There is no `AndroidManifest` here as it is automatically
    generated. The instrumentation can be customized inside the Android closure of
    your `build.gradle` file, and these changes are reflected in the autogenerated
    `AndroidManifest`. However, you can still run your tests with the default settings
    if you choose to change nothing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准的 Android 项目将在一个关联的源文件夹 `androidTest` 中拥有它的仪器测试，这创建了一个在应用上运行测试的独立应用。这里没有
    `AndroidManifest`，因为它是自动生成的。你可以在 `build.gradle` 文件中的 Android 闭包内自定义仪器，这些更改将反映在自动生成的
    `AndroidManifest` 中。但是，如果你选择不做任何更改，你仍然可以使用默认设置运行你的测试。
- en: 'Examples of things you can change are the test application package name, your
    test runner, or how to toggle performance-testing features:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改的一些示例包括测试应用包名、你的测试运行器，或者如何切换性能测试特性：
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the Instrumentation package (`testApplicationId`) is a different package
    to the main application. If you don't change this yourself, it will default to
    your main application package with the `.test` suffix added.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Instrumentation 包（`testApplicationId`）与主应用是不同的包。如果你不自己更改这个，它将默认使用你的主应用包，并在后面加上
    `.test` 后缀。
- en: Then, the Instrumentation test runner is declared, which can be helpful if you
    create custom annotations to allow special behavior; for example, each test runs
    twice upon failure. In the case of not declaring a runner, the default custom
    runner `android.test.InstrumentationTestRunner` is used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明了仪器测试运行器，如果你创建自定义注释以允许特殊行为，这将很有帮助；例如，每次测试失败时运行两次。如果没有声明运行器，将使用默认的自定义运行器
    `android.test.InstrumentationTestRunner`。
- en: At the moment, `testHandleProfiling` and `testFunctionalTest` are undocumented
    and unused, so watch out for when we are told what we can do with these. Setting
    `testCoverageEnabled` to true will allow you to gather code coverage reports using
    Jacoco. We will come back to this later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`testHandleProfiling` 和 `testFunctionalTest` 尚未记录且未被使用，因此请留意当我们被告知可以如何使用这些功能时。将
    `testCoverageEnabled` 设置为 true 将允许你使用 Jacoco 收集代码覆盖率报告。我们稍后会回到这个话题。
- en: Also, notice that both the application being tested and the tests themselves
    are Android applications with their corresponding APKs installed. Internally,
    they will be sharing the same process and thus have access to the same set of
    features.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，请注意，被测试的应用和测试本身都是 Android 应用，并安装有相应的 APK。在内部，它们将共享同一个进程，因此可以访问相同的功能集。
- en: When you run a test application, the **Activity** **Manager** ([http://developer.android.com/intl/de/reference/android/app/ActivityManager.html](http://developer.android.com/intl/de/reference/android/app/ActivityManager.html))
    uses the instrumentation framework to start and control the test runner, which
    in turn uses instrumentation to shut down any running instances of the main application,
    starts the test application, and then starts the main application in the same
    process. This allows various aspects of the test application to work directly
    with the main application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个测试应用时，**活动管理器**（[http://developer.android.com/intl/de/reference/android/app/ActivityManager.html](http://developer.android.com/intl/de/reference/android/app/ActivityManager.html)）使用仪器框架来启动和控制测试运行器，后者又使用仪器来关闭主应用的任何运行实例，启动测试应用，然后在同一进程中启动主应用。这使得测试应用的各个方面能够直接与主应用交互。
- en: Gradle
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle
- en: Gradle is an advanced build toolkit that allows you to manage dependencies and
    define a custom login to build your project. The Android build system is a plugin
    on top of Gradle, and this is what gives you the domain-specific language discussed
    previously such as setting a `testInstrumentationRunner`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是一个高级构建工具集，它允许你管理依赖项并定义自定义登录以构建你的项目。Android 构建系统是建立在 Gradle 之上的一个插件，正是它为你提供了前面讨论过的特定领域语言，例如设置
    `testInstrumentationRunner`。
- en: The idea of using Gradle is that it allows you to build your Android apps from
    the command line for machines without using an IDE such as a continuous integration
    machine. Also, with first line integration of Gradle into the building of projects
    in Android Studio, you get the exact same custom build configuration from the
    IDE or command line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gradle 的理念是它允许你从命令行构建你的 Android 应用，而不需要使用 IDE，例如持续集成机器。此外，随着 Gradle 集成到 Android
    Studio 中的项目构建中，你从 IDE 或命令行获得完全相同的自定义构建配置。
- en: Other benefits include being able to customize and extend the build process;
    for example, each time your CI builds your project, you could automatically upload
    a beta APK to the Google play store. You can create multiple APKs with different
    features using the same project, for example, one version that targets Google
    play in an app purchase and another that targets the Amazon app store's coin payments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 其他好处包括能够自定义和扩展构建过程；例如，每次你的 CI 构建项目时，你可以自动将测试版 APK 上传到 Google Play 商店。你可以使用相同的项目创建具有不同功能的多个
    APK，例如，一个针对 Google Play 应用内购买的版本，另一个针对亚马逊应用商店的硬币支付版本。
- en: Gradle and the Android Gradle plugin make for a powerful combination, and so,
    we will be using this build framework throughout the rest of the samples in this
    book.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 和 Android Gradle 插件是一个强大的组合，因此，在本书的剩余示例中，我们将使用这个构建框架。
- en: Test targets
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试目标
- en: During the evolution of your development project, your tests would be targeted
    to different devices. From simplicity, flexibility, and speed of testing on an
    emulator to the unavoidable final testing on the specific device you are intending
    your application to be run upon, you should be able to run your application on
    all of them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发项目的发展过程中，你的测试将针对不同的设备。从在模拟器上的简单性、灵活性和测试速度，到不可避免地在特定设备上进行最终测试，你应当能够在所有这些设备上运行你的应用程序。
- en: There are also some intermediate cases such as running your tests on a local
    JVM virtual machine, on the development computer, or on a **Dalvik** virtual machine
    or Activity, depending on the case.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些中间情况，例如在本地 JVM 虚拟机上、开发计算机上或根据情况在 **Dalvik** 虚拟机或活动上运行你的测试。
- en: Every case has its pros and cons, but the good news is that you have all of
    these alternatives available to run your tests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都有其优缺点，但好消息是，你有所有这些可用的选择来运行你的测试。
- en: The emulator is probably the most powerful target as you can modify almost every
    parameter from its configuration to simulate different conditions for your tests.
    Ultimately, your application should be able to handle all of these situations,
    so it's much better to discover the problems upfront than when the application
    has been delivered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器可能是最强大的目标，因为你几乎可以修改其配置中的每个参数来模拟不同的测试条件。最终，你的应用程序应该能够处理所有这些情况，所以最好提前发现这些问题，而不是在应用程序交付后再发现。
- en: The real devices are a requirement for performance tests, as it is somewhat
    difficult to extrapolate performance measurements from a simulated device. You
    will enjoy the real user experience only when using the real device. Rendering,
    scrolling, flinging, and other cases should be tested before delivering the application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 真实设备是性能测试的要求，因为从模拟设备中推断性能测量有些困难。只有在使用真实设备时，你才能享受到真实的用户体验。渲染、滚动、抛动和其他情况在交付应用程序之前应该被测试。
- en: Creating the Android project
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Android 项目
- en: We will create a new Android project. This is done from the ASide menu by going
    to **File** | **New Project**. This then leads us through the wysiwyg guide to
    create a project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 Android 项目。这可以通过访问 ASide 菜单，选择**文件** | **新建项目**来完成。这将引导我们通过 wysiwyg
    向导来创建项目。
- en: 'In this particular case, we are using the following values for the required
    component names (clicking on the **Next** button in between screens):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，我们为所需的组件名称使用以下值（在屏幕间点击**下一步**按钮）：
- en: 'Application name: AndroidApplicationTestingGuide'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序名称：AndroidApplicationTestingGuide
- en: 'Company domain: blundell.com'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司域名：blundell.com
- en: 'Form factor: Phone and Tablet'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式因素：手机和平板电脑
- en: 'Minimum SDK: 17'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小 SDK 版本：17
- en: 'Add an Activity: Blank Activity (go with default names)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个活动：空白活动（使用默认名称）
- en: 'The following screenshot shows the start of the form editor for reference:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了表单编辑器开始的参考：
- en: '![Creating the Android project](img/00005.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Android 项目](img/00005.jpeg)'
- en: When you click on **Finish** and the application is created, it will automatically
    generate the `androidTest` source folder under the `app/src` directory, and this
    is where you can add your instrumented test cases.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**完成**并且应用程序创建后，它将自动在`app/src`目录下生成`androidTest`源文件夹，你可以在这里添加你的仪器测试用例。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Alternatively, to create an androidTest folder for an existing Gradle Android
    project, you can select the src folder and then go to **File** | **New** | **Directory**.
    Then, write `androidTest/java` in the dialog prompt. When the project rebuilds,
    the path will then automatically be added so that you can create tests.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要为现有的Gradle Android项目创建一个androidTest文件夹，你可以选择src文件夹，然后转到**文件** | **新建** |
    **目录**。然后在对话框提示中写入`androidTest/java`。当项目重建时，该路径将自动添加，以便你可以创建测试。
- en: Package explorer
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包资源管理器
- en: After having created our project, the project view should look like one of the
    images shown in the following screenshot. This is because ASide has multiple ways
    to show the project outline. On the left, we can note the existence of the two
    source directories, one colored green for the test source and the other blue for
    the project source. On the right, we have the new Android project view that tries
    to simplify the hierarchy by compressing useless and merging functionally similar
    folders.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，项目视图应该与以下截图所示的一个图像类似。这是因为ASide有多个展示项目大纲的方式。在左侧，我们可以注意到两个源目录的存在，一个用于测试源，显示为绿色，另一个用于项目源，显示为蓝色。在右侧，我们有新的Android项目视图，它试图通过压缩无用的和合并功能相似的文件夹来简化层次结构。
- en: 'Now that we have the basic infrastructure set up, it''s time for us to start
    adding some tests, as shown in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本的基础设施，是时候开始添加一些测试了，如下面的截图所示：
- en: '![Package explorer](img/00006.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![包资源管理器](img/00006.jpeg)'
- en: There's nothing to test right now, but as we are setting up the fundamentals
    of a Test-driven Development discipline, we are adding a dummy test just to get
    acquainted with the technique.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在没有什么可以测试的，但当我们正在建立测试驱动开发（Test-driven Development）的基础时，我们添加了一个虚拟测试，只是为了熟悉这项技术。
- en: The `src/androidTest/java` folder in your `AndroidApplicationTestingGuide` project
    is the perfect place to add the tests. You could declare a different folder if
    you really wanted to, but we're sticking to defaults. The package should be the
    same as the corresponding package of the component being tested.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AndroidApplicationTestingGuide`项目中的`src/androidTest/java`文件夹是添加测试的完美位置。如果你真的想要，可以声明一个不同的文件夹，但我们坚持使用默认设置。包应该与被测试组件的相应包相同。
- en: Right now, we are not concentrating on the content of the tests but on the concepts
    and placement of those tests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们关注的是测试的概念和位置，而不是测试内容。
- en: Creating a test case
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试用例
- en: As described before, we are creating our test cases in the `src/androidTest/java`
    folder of the project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在项目的`src/androidTest/java`文件夹中创建我们的测试用例。
- en: You can create the file manually by right-clicking on the package and selecting
    New... | Java Class. However, in this particular case, we'll take advantage of
    ASide to create our JUnit TestCase. Open the class under test (in this case, MainActivity)
    and hover over the class name until you see a lightbulb (or press *Ctrl*/*Command*
    + `1`). Select **Create Test** from the menu that appears.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过右键点击包并选择新建... | Java类手动创建文件。然而，在这个特定的情况下，我们将利用ASide来创建我们的JUnit测试用例。打开待测试的类（在本例中，是MainActivity），并在类名上悬停，直到你看到一个灯泡（或者按*Ctrl*/*Command*
    + `1`）。从出现的菜单中选择**创建测试**。
- en: '![Creating a test case](img/00007.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![创建测试用例](img/00007.jpeg)'
- en: 'These are the values that we should enter when we create the test case:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试用例时，我们应该输入以下这些值：
- en: '**Testing library**: JUnit 3'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试库**: JUnit 3'
- en: '**Class name**: MainActivityTest'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类名**: MainActivityTest'
- en: '**Superclass**: junit.framework.TestCase'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超类**: junit.framework.TestCase'
- en: '**Destination package**: com.blundell.tut'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标包**: com.blundell.tut'
- en: '**Superclass**: junit.framework.TestCase'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超类**: junit.framework.TestCase'
- en: '**Generate**: Select none'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成**: 选择无'
- en: After entering all the required values, our JUnit test case creation dialog
    would look like this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输入所有必需的值后，我们的JUnit测试用例创建对话框将如下所示。
- en: As you can see, you could also have checked one of the methods of the class
    to generate an empty test method stub. These stub methods may be useful in some
    cases, but you have to consider that testing should be a behavior-driven process
    rather than a method-driven one.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你也可以检查类的一个方法以生成一个空的测试方法存根。这些存根方法在某些情况下可能很有用，但你要考虑测试应该是一个行为驱动的过程，而不是一个方法驱动的过程。
- en: '![Creating a test case](img/00008.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![创建测试用例](img/00008.jpeg)'
- en: The basic infrastructure for our tests is in place; what is left is to add a
    dummy test to verify that everything is working as expected. We now have a test
    case template, so the next step is to start completing it to suit our needs. To
    do it, open the recently created test class and add the `testSomething()` test.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的基本基础设施已经就位；剩下的就是添加一个虚拟测试，以验证一切是否按预期工作。现在我们有了测试用例模板，下一步是开始完善它以满足我们的需求。为此，打开最近创建的测试类并添加`testSomething()`测试。
- en: 'We should have something like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有类似这样的内容：
- en: '[PRE4]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The no-argument constructor is needed to run a specific test from the command
    line, as explained later using am instrumentation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 无参数构造函数是运行从命令行指定的特定测试所必需的，稍后使用am instrumentation时会解释这一点。
- en: 'This test will always fail, presenting the message: **Not** **implemented yet**.
    In order to do this, we will use the fail method from the `junit.framework.Assert`
    class that fails the test with the given message.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将始终失败，并显示消息：**尚未实现**。为了做到这一点，我们将使用`junit.framework.Assert`类中的fail方法，该方法会使用给定的消息使测试失败。
- en: Test annotations
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试注解
- en: Looking carefully at the test definition, you might notice that we decorated
    the test using the `@SmallTest` annotation, which is a way to organize or categorize
    our tests and run them separately.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看测试定义，你可能会注意到我们使用了`@SmallTest`注解来装饰测试，这是一种组织或分类我们的测试并单独运行它们的方法。
- en: 'There are other annotations that can be used by the tests, such as:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他测试可以使用的注解，例如：
- en: '| Annotation | Description |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 描述 |'
- en: '| --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@SmallTest` | Marks a test that should run as part of the small tests. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `@SmallTest` | 标记为作为小型测试的一部分运行的测试。 |'
- en: '| `@MediumTest` | Marks a test that should run as part of the medium tests.
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `@MediumTest` | 标记为作为中型测试的一部分运行的测试。 |'
- en: '| `@LargeTest` | Marks a test that should run as part of the large tests. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `@LargeTest` | 标记为作为大型测试的一部分运行的测试。 |'
- en: '| `@Smoke` | Marks a test that should run as part of the smoke tests. The `android.test.suitebuilder.SmokeTestSuiteBuilder`
    will run all tests with this annotation. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `@Smoke` | 标记为作为冒烟测试的一部分运行的测试。`android.test.suitebuilder.SmokeTestSuiteBuilder`将运行所有带有此注解的测试。
    |'
- en: '| `@FlakyTest` | Use this annotation on the `InstrumentationTestCase` class''
    test methods. When this is present, the test method is re-executed if the test
    fails. The total number of executions is specified by the tolerance, and defaults
    to 1\. This is useful for tests that may fail due to an external condition that
    could vary with time.For example, to specify a tolerance of 4, you would annotate
    your test with: `@FlakyTest(tolerance=4)`. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `@FlakyTest` | 在`InstrumentationTestCase`类的测试方法上使用此注解。当存在此注解时，如果测试失败，将重新执行测试方法。执行的总次数由容差指定，默认为1。这对于可能因随时间变化的外部条件而失败的测试很有用。例如，要指定容差为4，你可以使用以下注解：`@FlakyTest(tolerance=4)`。
    |'
- en: '| `@UIThreadTest` | Use this annotation on the `InstrumentationTestCase` class''
    test methods. When this is present, the test method is executed on the application''s
    main thread (or UI thread).As instrumentation methods may not be used when this
    annotation is present, there are other techniques if, for example, you need to
    modify the UI and get access to the instrumentation within the same test.In such
    cases, you can resort to the `Activity.runOnUIThread()` method that allows you
    to create any Runnable and run it in the UI thread from within your test:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '| `@UIThreadTest` | 在`InstrumentationTestCase`类的测试方法上使用此注解。当存在此注解时，测试方法将在应用程序的主线程（或UI线程）上执行。由于在存在此注解时可能无法使用instrumentation方法，因此，例如，如果你需要在同一测试中修改UI并获取instrumentation的访问权限，则可以使用其他技术。在这种情况下，你可以使用`Activity.runOnUIThread()`方法，它允许你创建任何Runnable并在UI线程中从你的测试中运行它。|'
- en: '[PRE5]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `@Suppress` | Use this annotation on test classes or test methods that should
    not be included in a test suite.This annotation can be used at the class level,
    where none of the methods in that class are included in the test suite, or at
    the method level, to exclude just a single method or a set of methods. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `@Suppress` | 在不应该包含在测试套件中的测试类或测试方法上使用此注解。此注解可以用在类级别，这样该类中的所有方法都不会包含在测试套件中；或者用在方法级别，仅排除一个或一组方法。
    |'
- en: Now that we have the tests in place, it's time to run them, and that's what
    we are going to do next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了测试用例，现在是时候运行它们了，接下来我们将要进行这一步。
- en: Running the tests
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: There are several ways of running our tests, and we will analyze them here.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种运行我们的测试的方法，我们将在下面进行分析。
- en: Additionally, as mentioned in the previous section about annotations, tests
    can be grouped or categorized and run together, depending on the situation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如前文关于注解的部分所述，根据情况，测试可以分组或分类并一起运行。
- en: Running all tests from Android Studio
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Android Studio运行所有测试
- en: This is perhaps the simplest method if you have adopted ASide as your development
    environment. This will run all the tests in the package.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经采用ASide作为你的开发环境，这可能是最简单的方法。这将运行包中的所有测试。
- en: Select the app module in your project and then go to **Run** | **(android icon)
    All Tests**.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中选择应用模块，然后转到 **运行** | **(安卓图标) 所有测试**。
- en: If a suitable device or emulator is not found, you will be asked to start or
    connect one.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到合适的设备或模拟器，系统会提示你启动或连接一个。
- en: 'The tests are then run, and the results are presented inside the Run perspective,
    as shown in the following screenshot:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后运行，结果会在运行视图中展示，如下面的屏幕截图所示：
- en: '![Running all tests from Android Studio](img/00009.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![从Android Studio运行所有测试](img/00009.jpeg)'
- en: 'A more detailed view of the results and the messages produced during their
    execution can also be obtained in the LogCat view within the Android DDMS perspective,
    as shown in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android DDMS视图中，也可以在LogCat视图中获得测试执行期间产生的结果和消息的更详细视图，如下面的屏幕截图所示：
- en: '![Running all tests from Android Studio](img/00010.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![从Android Studio运行所有测试](img/00010.jpeg)'
- en: Running a single test case from your IDE
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从你的IDE运行单个测试用例
- en: There is an option to run a single test case from ASide, should you need to.
    Open the file where the test resides, right-click on the method name you want
    to run, and just like you run all the tests, select **Run** | **(android icon)
    testMethodName**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，也可以从ASide运行单个测试用例。打开存放测试的文件，右键点击你想要运行的方法名，就像运行所有测试一样，选择 **运行** | **(安卓图标)
    testMethodName**。
- en: When you run this, as usual, only this test will be executed. In our case, we
    have only one test, so the result will be similar to the screenshot presented
    earlier.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个时，像往常一样，只有这个测试会被执行。在我们的例子中，我们只有一个测试，所以结果将类似于前面展示的屏幕截图。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Running a single test like this is a shortcut that actually creates a run configuration
    for you that is specific to that one method. If you want to look into the details
    of this, from the menu, select **Run** | **Edit Configurations**, and under **Android
    Tests**, you should be able to see a configuration with the name of the test you
    just executed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样运行单个测试是一个快捷方式，实际上为你创建了一个针对该方法的特定运行配置。如果你想查看这方面的详细信息，从菜单中选择 **运行** | **编辑配置**，在
    **Android测试** 下，你应该能看到你刚刚执行的测试的配置名称。
- en: Running from the emulator
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模拟器运行
- en: 'The default system image used by the emulator has the Dev Tools application
    installed, providing several handy tools and settings. Among these tools, we can
    find a rather long list, as is shown in the following screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器使用的默认系统映像中安装了Dev Tools应用程序，提供了许多便捷的工具和设置。在这些工具中，我们可以找到一个相当长的列表，如下面的屏幕截图所示：
- en: '![Running from the emulator](img/00011.jpeg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![从模拟器运行](img/00011.jpeg)'
- en: 'Now, we are interested in **Instrumentation**, which is the way to run our
    tests. This application lists all of the packages installed that define instrumentation
    tag tests in their project. We can run the tests by selecting our tests based
    on the package name, as shown in the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们关注的是**Instrumentation**，这是我们运行测试的方法。此应用程序列出了所有在项目中定义了instrumentation标签测试的已安装包。我们可以根据包名选择我们的测试，如下面的屏幕截图所示：
- en: '![Running from the emulator](img/00012.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![从模拟器运行](img/00012.jpeg)'
- en: When the tests are run in this way, the results can be seen through DDMS / LogCat,
    as described in the previous section.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行测试时，结果可以通过DDMS / LogCat查看，如前一部分所述。
- en: Running tests from the command line
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从命令行运行测试
- en: Finally, tests can be run from the command line too. This is useful if you want
    to automate or script the process.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以从命令行运行测试。如果你想要自动化或脚本化这个过程，这很有用。
- en: To run the tests, we use the am instrument command (strictly speaking, the am
    command and instrument subcommand), which allows us to run instrumentations specifying
    the package name and some other options.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们使用am instrument命令（严格来说，是am命令和instrument子命令），它允许我们通过指定包名和其他一些选项来运行测试。
- en: You might wonder what "am" stands for. It is short for Activity Manager, a main
    component of the internal Android infrastructure that is started by the System
    Server at the beginning of the boot process, and it is responsible for managing
    Activities and their life cycle. Additionally, as we can see here, it is also
    responsible for Activity instrumentation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道“am”代表什么。它是Activity Manager的简称，是Android内部基础设施的主要组成部分，系统服务器在启动过程中启动它，并负责管理Activities及其生命周期。此外，如我们所见，它也负责Activity的测试。
- en: 'The general usage of the am instrument command is:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: am instrument命令的一般用法是：
- en: '[PRE6]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This table summarizes the most common options:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了最常用的选项：
- en: '| Option | Description |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-r` | Prints raw results. This is useful to collect raw performance data.
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 打印原始结果。这有助于收集原始性能数据。 |'
- en: '| `-e <NAME> <VALUE>` | Sets arguments by name. We will examine its usage shortly.
    This is a generic option argument that allows us to set the `<name, value>` pairs.
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `-e <NAME> <VALUE>` | 通过名称设置参数。我们很快就会讨论其用法。这是一个通用选项参数，允许我们设置`<名称, 值>`对。 |'
- en: '| `-p <FILE>` | Writes profiling data to an external file. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `-p <FILE>` | 将分析数据写入外部文件。 |'
- en: '| `-w` | Waits for instrumentation to finish before exiting. This is normally
    used in commands. Although not mandatory, it''s very handy, as otherwise, you
    will not be able to see the test''s results. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `-w` | 在退出之前等待测试完成。这通常用于命令中。虽然不是强制性的，但非常有用，否则你将无法看到测试结果。 |'
- en: To invoke the am command, we will be using the adb shell command or, if you
    already have a shell running on an emulator or device, you can issue the am command
    directly in the shell command prompt.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用am命令，我们将使用adb shell命令，或者如果你已经在模拟器或设备上运行了shell，可以直接在shell命令提示符中发出am命令。
- en: Running all tests
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: 'This command line will open the adb shell and then run all tests with the exception
    of performance tests:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令行将打开adb shell，然后运行除性能测试之外的所有测试：
- en: '[PRE7]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Failure in `testSomething`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`testSomething`的失败：'
- en: '[PRE8]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the package you declare with `–w` is the package of your instrumentation
    tests, not the package of the application under test.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`–w`声明的包是你的测试包，而不是被测应用包。
- en: Running tests from a specific test case
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从特定测试用例运行测试
- en: 'To run all the tests in a specific test case, you can use:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行特定测试用例中的所有测试，你可以使用：
- en: '[PRE9]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running a specific test by name
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过名称运行特定测试
- en: 'Additionally, we have the alternative of specifying which test we want to run
    in the command line:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在命令行中指定要运行的测试：
- en: '[PRE10]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This test cannot be run in this way unless we have a no-argument constructor
    in our test case; that is the reason we added it before.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们的测试用例中有一个无参数构造函数，否则不能以这种方式运行此测试；这就是我们之前添加它的原因。
- en: Running specific tests by category
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按类别运行特定测试
- en: As mentioned before, tests can be grouped into different categories using annotations
    (Test Annotations), and you can run all tests in this category.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以使用注解（测试注解）将测试分组到不同的类别中，你可以运行此类别中的所有测试。
- en: 'The following options can be added to the command line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在命令行中添加以下选项：
- en: '| Option | Description |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-e unit true` | This runs all unit tests. These are tests that are not derived
    from `InstrumentationTestCase` (and are not performance tests). |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `-e unit true` | 这运行所有单元测试。这些测试不是从`InstrumentationTestCase`派生的（也不是性能测试）。
    |'
- en: '| `-e func true` | This runs all functional tests. These are tests that are
    derived from `InstrumentationTestCase`. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `-e func true` | 这运行所有功能测试。这些测试是从`InstrumentationTestCase`派生的。 |'
- en: '| `-e perf true` | This includes performance tests. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `-e perf true` | 这包括性能测试。 |'
- en: '| `-e size {small &#124; medium &#124; large}` | This runs small, medium, or
    large tests depending on the annotations added to the tests. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `-e size {small &#124; medium &#124; large}` | 这将根据添加到测试的注解运行小型、中型或大型测试。
    |'
- en: '| `-e annotation <annotation-name>` | This runs tests annotated with this annotation.
    This option is mutually exclusive with the size option. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `-e annotation <注解名称>` | 这将运行带有此注解的测试。此选项与大小选项互斥。 |'
- en: In our example, we annotated the test method `testSomething()` with `@SmallTest`.
    So this test is considered to be in that category, and is thus run eventually
    with other tests that belong to that same category, when we specify the test size
    as small.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将测试方法`testSomething()`用`@SmallTest`进行了注解。因此，这个测试被认为属于那个类别，并且当我们指定测试大小为小型时，最终会与其他属于同一类别的测试一起运行。
- en: 'This command line will run all the tests annotated with `@SmallTest`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行将运行所有带有`@SmallTest`注解的测试：
- en: '[PRE11]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running tests using Gradle
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Gradle运行测试
- en: 'Your gradle build script can also help you run the tests and this will actually
    do the previous commands under the hood. Gradle can run your tests with this command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Gradle构建脚本也可以帮助你运行测试，这实际上会在幕后执行前面的命令。Gradle可以用以下命令运行你的测试：
- en: '[PRE12]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating a custom annotation
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建自定义注解
- en: In case you decide to sort the tests by a criterion other than their size, a
    custom annotation can be created and then specified in the command line.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定按照除大小之外的其他标准对测试进行排序，可以创建自定义注解，然后在命令行中指定。
- en: 'As an example, let''s say we want to arrange our tests according to their importance,
    so we create an annotation `@VeryImportantTest`, which we will use in any class
    where we write tests (`MainActivityTest` for example):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想根据测试的重要性来安排它们，因此我们创建了一个注解`@VeryImportantTest`，我们将在编写测试的任何类中使用它（例如`MainActivityTest`）：
- en: '[PRE13]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Following this, we can create another test and annotate it with `@VeryImportantTest`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们可以创建另一个测试并用`@VeryImportantTest`进行注解：
- en: '[PRE14]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, as we mentioned before, we can include this annotation in the am instrument
    command line to run only the annotated tests:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如我们之前提到的，我们可以将此注解包含在am instrument命令行中，只运行带注解的测试：
- en: '[PRE15]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running performance tests
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行性能测试
- en: We will be reviewing performance test details in [Chapter 8](part0072_split_000.html#page
    "Chapter 8. Testing and Profiling Performance"), *Testing and Profiling Performance*,
    but here, we will introduce the available options to the am instrument command.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](part0072_split_000.html#page "第8章.测试和性能分析")，*测试和性能分析*中回顾性能测试的细节，但在这里，我们将介绍am
    instrument命令可用的选项。
- en: 'To include performance tests on your test run, you should add this command
    line option:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试运行中包含性能测试，你应该添加这个命令行选项：
- en: '`-e perf true`: This includes performance tests'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e perf true`：这包括性能测试'
- en: Dry run
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 干运行
- en: Sometimes, you might only need to know what tests will be run instead of actually
    running them.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只需要知道将要运行哪些测试，而不是实际运行它们。
- en: 'This is the option you need to add to your command line:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要添加到命令行的选项：
- en: '`-e log true`: This displays the tests to be run instead of running them'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e log true`：这显示将要运行的测试，而不是实际运行它们。'
- en: This is useful if you are writing scripts around your tests or perhaps building
    other tools.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写测试脚本或可能构建其他工具，这会很有用。
- en: Debugging tests
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试测试
- en: You should assume that your tests might have bugs too. In such a case, usual
    debugging techniques apply, for example, adding messages through LogCat.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该假设你的测试也可能有错误。在这种情况下，适用常规的调试技术，例如，通过LogCat添加消息。
- en: If a more sophisticated debugging technique is needed, you should attach the
    debugger to the test runner.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更复杂的调试技术，你应该将调试器附加到测试运行器上。
- en: In order to do this without giving up on the convenience of the IDE and not
    having to remember hard-to-memorize command-line options, you can **Debug Run**
    your run configurations. Thus, you can set a breakpoint in your tests and use
    it. To toggle a breakpoint, you can select the desired line in the editor and
    left-click on the margin.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不放弃IDE的便利性的同时做到这一点，并且不需要记住难以记忆的命令行选项，你可以**调试运行**你的运行配置。这样，你可以在测试中设置断点并使用它。要切换断点，你可以在编辑器中选择所需的行，并在边缘处左键点击。
- en: Once it is done, you will be in a standard debugging session, and the debug
    window should be available to you.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将进入一个标准的调试会话，调试窗口应该可供你使用。
- en: It is also possible to debug your tests from the command line; you can use code
    instructions to wait for your debugger to attach. We won't be using this command;
    if you want more details, they can be found at ([http://developer.android.com/reference/android/test/InstrumentationTestRunner.html](http://developer.android.com/reference/android/test/InstrumentationTestRunner.html)).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行调试测试也是可能的；你可以使用代码指令等待调试器附加。我们不使用这个命令；如果你需要更多详细信息，可以在([http://developer.android.com/reference/android/test/InstrumentationTestRunner.html](http://developer.android.com/reference/android/test/InstrumentationTestRunner.html))找到。
- en: Other command-line options
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他命令行选项
- en: 'The am instrument command accepts other `<name, value>` pairs beside the previously
    mentioned ones:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: am instrument命令接受除了前面提到的`<名称, 值>`对之外的其它对：
- en: '| Name | Value |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 值 |'
- en: '| --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `debug` | `true`. Set break points in your code. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `debug` | `true`。在代码中设置断点。 |'
- en: '| `package` | This is a fully qualified package name of one or several packages
    in the test application. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `package` | 这是测试应用中一个或多个完全限定包的名称。 |'
- en: '| `class` | A fully qualified test case class to be executed by the test runner.
    Optionally, this could include the test method name separated from the class name
    by a hash (#). |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `class` | 一个由测试运行器执行的完全限定测试用例类。可选地，这可以包括由哈希(#)与类名分隔的测试方法名称。 |'
- en: '| `coverage` | `true`. Runs the EMMA code coverage and writes the output to
    a file that can also be specified. We will dig into the details about supporting
    EMMA code coverage for our tests in [Chapter 9](part0079_split_000.html#page "Chapter 9. Alternative
    Testing Tactics"), *Alternative Testing Tactics*. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `coverage` | `true`。运行EMMA代码覆盖率，并将输出写入可以指定的文件中。我们将在[第9章](part0079_split_000.html#page
    "第9章. 替代测试策略")，*替代测试策略*中详细介绍如何为我们的测试支持EMMA代码覆盖率。'
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have reviewed the main techniques and tools behind testing on Android. Having
    acquired this knowledge, it will let us begin our journey so that we can start
    exploiting the benefits of testing in our software development projects.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经回顾了Android测试背后的主要技术和工具。掌握了这些知识后，我们可以开始我们的旅程，以便在我们软件开发项目中利用测试的好处。
- en: 'So far, we have visited the following subjects:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了以下主题：
- en: We briefly analyzed the whys, whats, hows, and whens of testing. Henceforth,
    we will concentrate more on exploring the hows, now that you're giving testing
    the importance it deserves.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要分析了测试的原因、内容、方法和时机。现在，既然你已经给予了测试应有的重视，我们将更专注于探索如何进行测试。
- en: We enumerated the different and most common types of tests you would need in
    your projects, described some of the tools we can count on our testing toolbox,
    and provided an introductory example of a JUnit unit test to better understand
    what we are discussing.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们列举了在项目中可能需要的不同和最常见的测试类型，描述了一些我们可以依赖的测试工具箱中的工具，并提供了一个JUnit单元测试的介绍性示例，以便更好地理解我们正在讨论的内容。
- en: We also created our first Android project with tests, using the Android Studio
    IDE and Gradle.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用Android Studio IDE和Gradle创建了我们第一个带有测试的Android项目。
- en: We also created a simple test class to test the Activity in our project. We
    haven't added any useful test cases yet, but adding those simple ones was intended
    to validate our infrastructure.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还创建了一个简单的测试类来测试项目中的Activity。我们还没有添加任何有用的测试用例，但添加这些简单的用例是为了验证我们的基础设施。
- en: We also ran this simple test from our IDE and from the command line to understand
    the alternatives we have. In this process, we mentioned the Activity Manager and
    its command line incarnation am.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还从IDE和命令行运行了这个简单的测试，以了解我们有哪些替代方案。在这个过程中，我们提到了活动管理器及其命令行化身am。
- en: We created a custom annotation to sort our tests and demonstrate how we can
    separate or differentiate suites of tests.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义注解来排序我们的测试，并演示如何分离或区分测试套件。
- en: In the next chapter, we will start analyzing the mentioned techniques, frameworks,
    and tools in much greater detail, and provide examples of their usage.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地分析提到的技术、框架和工具，并提供它们使用示例。
