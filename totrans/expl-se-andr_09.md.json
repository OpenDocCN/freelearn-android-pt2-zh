["```kt\nservice <name> <path> [ <argument>... ]\n```", "```kt\nService ril-daemon /system/bin/rild\n```", "```kt\nService ril-daemon /system/bin/rild\n class main\n socket rild stream 660 root radio\n socket rild-debug stream 660 radio system\n socket rild-ppp stream 660 radio system\n user root\n group radio cache inet misc audio sdcard_rw log\n\n```", "```kt\nsocket <name> <type> <perm> [ <user> [ <group> [ <context> ] ] ]\n\n```", "```kt\nroot@udoo:/dev/socket # ls -laZ | grep adb\nsrw-rw---- system system u:object_r:adbd_socket:s0 adbd\n\n```", "```kt\n$ sesearch -T -t adbd_socket $OUT/sepolicy\n\n```", "```kt\n$ grep -n fork system/core/init/init.c \n235: pid = fork();\n\n```", "```kt\n...\nNOTICE(\"starting '%s'\\n\", svc->name);\n\n  pid = fork();\n\n  if (pid == 0) {\n    struct socketinfo *si;\n    struct svcenvinfo *ei;\n    char tmp[32];\n    int fd, sz;\n\n    umask(077);\n    if (properties_inited()) {\n      get_property_workspace(&fd, &sz);\n      sprintf(tmp, \"%d,%d\", dup(fd), sz);\n      add_environment(\"ANDROID_PROPERTY_WORKSPACE\", tmp);\n    }\n\n    for (ei = svc->envvars; ei; ei = ei->next)\n      add_environment(ei->name, ei->value);\n\n    for (si = svc->sockets; si; si = si->next) {\n      int socket_type = (\n        !strcmp(si->type, \"stream\") ? SOCK_STREAM :\n          (!strcmp(si->type, \"dgram\") ? SOCK_DGRAM : SOCK_SEQPACKET));\n      int s = create_socket(si->name, socket_type,\n            si->perm, si->uid, si->gid, si->socketcon ?: scon);\n      if (s >= 0) {\n        publish_socket(si->name, s);\n      }\n...\n```", "```kt\n...\n    if (svc->seclabel) {\n      scon = strdup(svc->seclabel);\n      if (!scon) {\n        ERROR(\"Out of memory while starting '%s'\\n\", svc->name);\n        return;\n      }\n      } else {\n...\n```", "```kt\n...\n  if (socketcon)\n    setsockcreatecon(socketcon);\n\n  fd = socket(PF_UNIX, type, 0);\n  if (fd < 0) {\n    ERROR(\"Failed to open socket '%s': %s\\n\", name, strerror(errno));\n    return -1;\n  }\n\n  if (socketcon)\n    setsockcreatecon(NULL);\n...\n```", "```kt\n...\n  filecon = NULL;\n  if (sehandle) {\n    ret = selabel_lookup(sehandle, &filecon, addr.sun_path, S_IFSOCK);\n    if (ret == 0)\n      setfscreatecon(filecon);\n  }\n\n  ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));\n  if (ret) {\n    ERROR(\"Failed to bind socket '%s': %s\\n\", name, strerror(errno));\n    goto out_unlink;\n  }\n\n  setfscreatecon(NULL);\n  freecon(filecon);\n...\n```", "```kt\nif (svc->seclabel) {\nif (is_selinux_enabled() > 0 && setexeccon(svc->seclabel) < 0) {\nERROR(\"cannot setexeccon('%s'): %s\\n\", svc->seclabel, strerror(errno));\n_exit(127);\n}\n}\n```", "```kt\n$ grep -c type_transition rild.te \n0\n\n```", "```kt\n$ grep -n init_daemon_domain * | grep define\nte_macros:99:define(`init_daemon_domain', `\n\n```", "```kt\n...\n#####################################\n# init_daemon_domain(domain)\n# Set up a transition from init to the daemon domain\n# upon executing its binary.\ndefine(`init_daemon_domain', `\ndomain_auto_trans(init, $1_exec, $1)\ntmpfs_domain($1)\n')\n...\n```", "```kt\n...\n#####################################\n# domain_auto_trans(olddomain, type, newdomain)\n# Automatically transition from olddomain to newdomain\n# upon executing a file labeled with type.\n#\ndefine(`domain_auto_trans', `\n# Allow the necessary permissions.\ndomain_trans($1,$2,$3)\n# Make the transition occur by default.\ntype_transition $1 $2:process $3;\n')\n...\n```", "```kt\ntype_transition $1 $2:process $3;\n```", "```kt\ntype_transition init rild_exec:process rild;\n```", "```kt\nService adbd /sbin/adbd\n  class core\n  socket adbd stream 660 system system\n  disabled\n  seclabel u:r:adbd:s0\n```", "```kt\n$ adb shell ps -Z | grep init\nu:r:init:s0 root 1 0 /init\nu:r:init:s0 root 2267 1 /sbin/watchdogd\nu:r:init_shell:s0 root 2278 1 /system/bin/sh\n$ adb shell ps -Z | grep zygote\nu:r:zygote:s0 root 2285 1 zygote\n\n```", "```kt\nroot@udoo:/ # echo $$ \n2278\n\n```", "```kt\n$ sesearch -T -s init -t shell_exec -c process $OUT/root/sepolicy\n\n```", "```kt\n$ grep -n \"/system/bin/sh\" init.rc \n499:service console /system/bin/sh\n702:service wifi_mac /system/bin/sh /system/etc/check_wifi_mac.sh\n\n```", "```kt\nservice console /system/bin/sh\n class core\n console\n user root\n group root\n\n```", "```kt\n$ adb shell setprop ctl.stop console\n\n```", "```kt\nroot@udoo:/ # avc: denied { set } for property=ctl.console scontext=u:r:shell:s0 tcontext=u:e\n\n```", "```kt\n$ adb shell setprop ctl.start console\n\n```", "```kt\nservice console /system/bin/sh\n class core\n console\n user root\n group root\n seclabel u:r:shell:s0\n\n```", "```kt\nroot@udoo:/ # id -Z \nuid=0(root) gid=0(root) context=u:r:shell:s0\n\n```", "```kt\n$ adb shell ps -Z | grep \"system/bin/sh\"\nu:r:shell:s0 root 2279 1 /system/bin/sh\n\n```", "```kt\n# Set watchdog timer to 30 seconds and pet it every 10 seconds to get a 20 second margin\nservice watchdogd /sbin/watchdogd 10 20\n  class core\n  seclabel u:r:watchdogd:s0\n```", "```kt\n$ adb shell ps -Z | grep watchdog\nu:r:watchdogd:s0 root 2267 1 /sbin/watchdogd\n\n```", "```kt\ntype subshell, domain, shelldomain, mlstrustedsubject;\n# domain_auto_trans(olddomain, type, newdomain)\n# Automatically transition from olddomain to newdomain\n# upon executing a file labeled with type.\n#\ndomain_auto_trans(shell, shell_exec, subshell)\n\n```", "```kt\nroot@udoo:/ # id -Z\nuid=0(root) gid=0(root) context=u:r:shell:s0\n\n```", "```kt\nroot@udoo:/ # sh\nroot@udoo:/ # id -Z\nuid=0(root) gid=0(root) context=u:r:subshell:s0\n\n```", "```kt\nif (svc->seclabel) {\nif (is_selinux_enabled() > 0 && setexeccon(svc->seclabel) < 0) {\nERROR(\"cannot setexeccon('%s'): %s\\n\", svc->seclabel, strerror(errno));\n_exit(127);\n}\n}\n```"]