["```kt\nOpenssl s_client -showcerts -connect server.domain:443 </dev/null.\n```", "```kt\nopenssl genrsa –out my_private_key.pem 2048\n\n```", "```kt\nopenssl req -new -x509 -key my_private_key.pem -out mycert.crt -days 365\n\n```", "```kt\n    -----BEGIN CERTIFICATE-----\n    WgAwIBAgIDA1MHMA0GCSqGSIb3DQEBBQUAMDwxCzAJBgNVBAYTAlVTMRcwFQYDVQQK\n    …\n    -----END CERTIFICATE-----\n    ```", "```kt\n    $export CLASSPATH=libs/bcprov-jdk15on-149.jar\n\n    ```", "```kt\n    $ keytool -import -v -trustcacerts -alias 0 /\n    -file <(openssl x509 -in mycert.crt) /\n    -keystore customtruststore.bks /\n    -storetype BKS /\n    -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider /\n    -providerpath libs/bcprov-jdk15on-149.jar \n    -storepass androidcookbook \n\n    ```", "```kt\n    Trust this certificate? [no]: yes\n\n    ```", "```kt\n    private static final String STORE_PASSWORD = \"androidcookbook\";\n\n    private KeyStore loadKeyStore() throws Exception {\n        final KeyStore keyStore = KeyStore.getInstance(\"BKS\");\n        final InputStream inputStream = context.getResources().openRawResource(\n            R.raw.customtruststore);\n        try {\n          keyStore.load(inputStream, STORE_PASSWORD.toCharArray());\n          return keyStore;\n        } finally {\n          inputStream.close();\n        }\n      }\n    ```", "```kt\n    public class LocalTrustStoreMyHttpClient extends DefaultHttpClient {\n\n        @Override\n        protected ClientConnectionManager createClientConnectionManager() {\n          SchemeRegistry registry = new SchemeRegistry();\n          registry.register(new Scheme(\"http\", PlainSocketFactory\n              .getSocketFactory(), 80));\n          try {\n            registry.register(new Scheme(\"https\", new SSLSocketFactory(\n                loadKeyStore()), 443));\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          return new SingleClientConnManager(getParams(), registry);\n        }\n      }\n    ```", "```kt\n      public HttpResponse httpClientRequestUsingLocalKeystore(Stringurl)\n          throws ClientProtocolException, IOException {\n        HttpClient httpClient = new MyHttpClient();\n        HttpGet httpGet = new HttpGet(url);\n        HttpResponse response = httpClient.execute(httpGet);\n        return response;\n      }\n    ```", "```kt\n    public class LocalTrustStoreTrustManager implements X509TrustManager {\n\n      private X509TrustManager mTrustManager;\n\n      public LocalTrustStoreTrustManager(KeyStore localTrustStore) {\n        try {\n          TrustManagerFactory factory = TrustManagerFactory\n              .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n          factory.init(localTrustStore);\n\n          mTrustManager = findX509TrustManager(factory);\n          if (mTrustManager == null) {\n            throw new IllegalStateException(\n                \"Couldn't find X509TrustManager\");\n          }\n        } catch (GeneralSecurityException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void checkClientTrusted(X509Certificate[] chain, String authType)\n          throws CertificateException {\n        mTrustManager.checkClientTrusted(chain, authType);\n      }\n\n      @Override\n      public void checkServerTrusted(X509Certificate[] chain, String authType)\n          throws CertificateException {\n        mTrustManager.checkServerTrusted(chain, authType);\n      }\n\n      @Override\n      public X509Certificate[] getAcceptedIssuers() {\n        return mTrustManager.getAcceptedIssuers();\n      }\n\n      private X509TrustManager findX509TrustManager(TrustManagerFactory tmf) {\n        TrustManager trustManagers[] = tmf.getTrustManagers();\n        for (int i = 0; i < trustManagers.length; i++) {\n          if (trustManagers[i] instanceof X509TrustManager) {\n            return (X509TrustManager) trustManagers[i];\n          }\n        }\n        return null;\n      }\n\n    }\n    ```", "```kt\n      public InputStream uRLConnectionRequestLocalTruststore(String targetUrl)\n          throws Exception {\n        URL url = new URL(targetUrl);\n\n        SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, new TrustManager[] { new LocalTrustStoreTrustManager(\n            loadKeyStore()) }, new SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n\n        HttpsURLConnection urlHttpsConnection = (HttpsURLConnection) url.openConnection();\n        urlHttpsConnection.setRequestMethod(\"GET\");\n        urlHttpsConnection.connect();\n        return urlHttpsConnection.getInputStream();\n      }\n    ```", "```kt\npublic class TrustAllX509TrustManager implements X509TrustManager {\n\n  @Override\n  public void checkClientTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException {\n    // do nothing, trust all :(\n  }\n\n  @Override\n  public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException {\n    // do nothing, trust all :( \n  }\n\n  @Override\n  public X509Certificate[] getAcceptedIssuers() {\n    return null;\n  }\n}\n```", "```kt\n    public HttpResponse sampleRequest() throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"https://server.com/path?apikey=123\");\n        HttpResponse response = httpclient.execute(httpget);\n        return response;\n    }\n    ```", "```kt\n    public HttpResponse strongSampleRequest() throws Exception {\n        StrongHttpsClient httpclient = new StrongHttpsClient(context);\n        ch.boye.httpclientandroidlib.client.methods.HttpGet httpget = new HttpGet(\n            \"https://server.com/path?apikey=123\");\n        HttpResponse response = httpclient.execute();\n        return response;\n      }\n    ```", "```kt\n    httpclient.getStrongTrustManager().setNotifyVerificationFail(true)\n    ```", "```kt\n    httpclient.getStrongTrustManager().setVerifyChain(true);\n    ```", "```kt\n    httpclient.getStrongTrustManager().setCheckChainCrypto(true);\n    ```", "```kt\n    public class CalcPins {\n\n      private MessageDigest digest;\n\n      public CalcPins() throws Exception {\n        digest = MessageDigest.getInstance(\"SHA1\");\n      }\n\n      public static void main(String[] args) {\n        if ((args.length == 1) || (args.length == 2)) {\n          String[] hostAndPort = args[0].split(\":\");\n          String host = hostAndPort[0];\n          // if port blank assume 443\n          int port = (hostAndPort.length == 1) ? 443 : Integer\n              .parseInt(hostAndPort[1]);\n\n          try {\n            CalcPins calc = new CalcPins();\n            calc.fetchAndPrintPinHashs(host, port);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n        } else {\n          System.out.println(\"Usage: java CalcPins <host>[:port]\");\n          return;\n        }\n      }\n    ```", "```kt\n    public class PublicKeyExtractingTrustManager implements X509TrustManager {\n\n        public X509Certificate[] getAcceptedIssuers() {\n          throw new UnsupportedOperationException();\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n          throw new UnsupportedOperationException();\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n            throws CertificateException {\n          for (X509Certificate cert : chain) {\n            byte[] pubKey = cert.getPublicKey().getEncoded();\n            final byte[] hash = digest.digest(pubKey);\n            System.out.println(bytesToHex(hash));\n          }\n        }\n      }\n    ```", "```kt\n    public static String bytesToHex(byte[] bytes) {\n        final char[] hexArray = { '0', '1', '2', '3', '4', '5', '6', '7', '8','9', 'A', 'B', 'C', 'D', 'E', 'F' };\n        char[] hexChars = new char[bytes.length * 2];\n        int v;\n        for (int j = 0; j < bytes.length; j++) {\n          v = bytes[j] & 0xFF;\n          hexChars[j * 2] = hexArray[v >>> 4];\n          hexChars[j * 2 + 1] = hexArray[v & 0x0F];\n        }\n        return new String(hexChars);\n      }\n    ```", "```kt\n    private void fetchAndPrintPinHashs(String host, int port) throws Exception {\n        SSLContext context = SSLContext.getInstance(\"TLS\");\n        PublicKeyExtractingTrustManager tm = new PublicKeyExtractingTrustManager();\n        context.init(null, new TrustManager[] { tm }, null);\n        SSLSocketFactory factory = context.getSocketFactory();\n        SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n        socket.setSoTimeout(10000);\n        socket.startHandshake();\n        socket.close();\n      }\n    ```", "```kt\n    $ javac CalcPins.java \n    $ java -cp . CalcPins Android.com:443\n\n    ```", "```kt\n    $ java -jar calcpins.jar android.com:443\n\n    ```", "```kt\n    B3A3B5195E7C0D39B8FA68D41A64780F79FD4EE9\n    43DAD630EE53F8A980CA6EFD85F46AA37990E0EA\n    C07A98688D89FBAB05640C117DAA7D65B8CACC4E\n\n    ```", "```kt\n    private static String[] pins = new String[] {\n          \"B3A3B5195E7C0D39B8FA68D41A64780F79FD4EE9\",\n          \"43DAD630EE53F8A980CA6EFD85F46AA37990E0EA\",\n          \"C07A98688D89FBAB05640C117DAA7D65B8CACC4E\" };\n    ```", "```kt\n    public class PubKeyPinningTrustManager implements X509TrustManager {\n\n      private final String[] mPins;\n      private final MessageDigest mDigest;\n\n      public PubKeyPinningTrustManager(String[] pins)\n          throws GeneralSecurityException {\n        this.mPins = pins;\n        mDigest = MessageDigest.getInstance(\"SHA1\");\n      }\n\n      @Override\n      public void checkServerTrusted(X509Certificate[] chain, String authType)\n          throws CertificateException {\n        // validate all the pins\n        for (X509Certificate cert : chain) {\n          final boolean expected = validateCertificatePin(cert);\n          if (!expected) {\n            throw new CertificateException(\"could not find a validpin\");\n          }\n        }\n      }\n\n      @Override\n      public void checkClientTrusted(X509Certificate[] chain, String authType)\n          throws CertificateException {\n        // we are validated the server and so this is not implemented.\n        throw new CertificateException(\"Cilent valdation not implemented\");\n      }\n\n      @Override\n      public X509Certificate[] getAcceptedIssuers() {\n        return null;\n      }\n    ```", "```kt\n    private boolean validateCertificatePin(X509Certificate certificate)\n          throws CertificateException {\n        final byte[] pubKeyInfo = certificate.getPublicKey().getEncoded();\n        final byte[] pin = mDigest.digest(pubKeyInfo);\n        final String pinAsHex = bytesToHex(pin);\n        for (String validPin : mPins) {\n          if (validPin.equalsIgnoreCase(pinAsHex)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    ```", "```kt\n    TrustManager[] trustManagers = new TrustManager[] { new PubKeyPinningTrustManager(pins) };\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustManagers, null);\n        HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();\n        urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());\n        urlConnection.connect();\n    ```"]