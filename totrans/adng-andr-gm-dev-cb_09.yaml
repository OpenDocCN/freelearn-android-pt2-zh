- en: Chapter 9. AndEngine Extensions Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the purpose and usage of some of AndEngine''s
    most popular extensions. The following topics are included in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating live wallpapers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking with the multiplayer extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating high-resolution graphics with **scalable vector graphics** (**SVG**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color mapping with SVG texture regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the extensions overview chapter, we're going to begin to work with a number
    of classes that don't come packaged with AndEngine. There are many extensions
    that can be written to add various improvements or extra features to any default
    AndEngine game. In this chapter, we're going to be working with three main extensions
    that will allow us to create live wallpapers with AndEngine, create online games
    that allow multiple devices to connect directly to each other or a dedicated server,
    and finally, incorporate SVG files into our games as texture regions, allowing
    for high resolution and scalable graphics within our games.
  prefs: []
  type: TYPE_NORMAL
- en: 'AndEngine includes a relatively long list of extensions which can be included
    in our projects in order to make certain tasks easier to complete. Unfortunately,
    due to the number of extensions and the current state of some of them, we are
    limited in the number of extensions, which can be included within this chapter.
    However, most AndEngine extensions are relatively easy to use and include example
    projects which can be acquired from Nicolas Gramlich''s public GitHub repository
    – [https://github.com/nicolasgramlich](https://github.com/nicolasgramlich). The
    following is a list of additional AndEngine extensions, as well as a brief description
    describing its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AndEngineCocosBuilderExtension`: This extension allows developers to create
    games through the use of the **WYSIWYG** or **what you see is what you get** concept.
    This approach allows developers to build applications in a GUI based drag-and-drop
    environment using the CocosBuilder software for desktop computers. This extension
    can help make menu and level design as simple as placing objects on a screen and
    exporting the setup to a file which can be read in via the `AndEngineCocosBuilderExtension`
    extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndEngineAugmentedRealityExtension`: The augmented reality extension allows
    developers to easily convert an otherwise ordinary AndEngine activity into an
    augmented reality activity, which will display the device''s physical camera view
    on the screen. We are then able to attach entities over the top of the camera''s
    view displayed on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndEngineTexturePackerExtension`: This extension allows developers to import
    sprite sheets created through the use of the TexturePacker program for desktop
    computers. This program makes creating sprite sheets remarkably easy by allowing
    us to drag-and-drop our images into the program, export the finished sprite sheet
    into an AndEngine-readable format, and simply load it into our project with the
    `AndEngineTexturePackerExtension` extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndEngineTMXTiledMapExtensions`: This extension can greatly increase productivity
    in games based on the tiled map style of gameplay. With the use of a TMX tiled
    map editor, developers can simply drag-and-drop sprites/tiles onto a grid-based
    level editor in order to create levels. Once a level is created in the editor,
    simply export it to the `.tmx` file format and from there use the `AndEngineTMXTiledMapExtension`
    to load the level into our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating live wallpaper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The live wallpaper extension is a great addition to the AndEngine lineup of
    available Android development resources. With this extension, we can easily create
    wallpapers through the use of all the normal AndEngine classes we're used to using
    for our game development. In this topic, we're going to create a live wallpaper
    containing a simple particle system that spawns particles at the top of the screen.
    The wallpaper settings will include a value that allows a user to increase the
    speed of particle movement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe assumes that you have at least a basic knowledge of the Android
    SDK's `Activity` class as well as a general understanding of Android view objects,
    such as `SeekBars` and `TextViews`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Live wallpapers are not your typical Android activity. Instead, they are a service,
    which requires a slightly different approach in terms of setting a project up.
    Before visiting the code, let's go ahead and create the necessary folders and
    files for the live wallpaper.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the project named `LiveWallpaperExtensionExample` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the code to reside in each file in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or overwrite the current `main.xml` file in the `res/layout` folder,
    naming it `settings_main.xml`. This layout file will be used to create the settings
    activity layout where the wallpaper's properties are adjusted by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `xml` in the `res` folder. Within this folder, create
    a new `xml` file and name it `wallpaper.xml`. This file will be used as a reference
    to the wallpaper's icon, description, as well as a reference to the setting's
    activity which will be used to modify the wallpaper properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start off by populating all of the XML files in order to accommodate
    a live wallpaper service. These files include `settings_main.xml`, `wallpaper.xml`,
    and finally `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `settings_main.xml` layout file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step involves defining the `settings_main.xml` file as a layout for
    the settings activity of the wallpaper. There are no rules limiting a developer
    to a specific layout style, but the most common approach for a live wallpaper
    is a simple `TextView` with a corresponding `Spinner` used to provide a means
    of modification to the live wallpaper's adjustable values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `wallpaper.xml` file in the `res/xml/` folder. Import the following
    code to `wallpaper.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `AndroidManifest.xml` to suit the wallpaper service needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the third step, we must modify `AndroidManifest.xml` in order to allow our
    project to run as a wallpaper service. In the project''s `AndroidManifest.xml`
    file, replace all code inside of the `<manifest>` tags with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the three xml files have been taken care of, we can create the classes
    needed for the live wallpaper. We will be using three classes to handle the live
    wallpaper''s execution. These classes are `LiveWallpaperExtensionService.java`,
    `LiveWallpaperSettings.java`, and `LiveWallpaperPreferences.java`, which will
    be covered in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the live wallpaper preferences class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `LiveWallpaperPreferences.java` class is similar to that of the preferences
    class we covered in the *Saving and loading game data* section in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*. The main purpose
    of the preference class in this case is to handle the speed value of the spawned
    particles. The following methods are used for saving and loading the particle''s
    speed value. Note that we negate the `mParticleSpeed` value as we want the particles
    to travel toward the bottom of the screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the live wallpaper settings activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The live wallpaper's settings activity extends Android SDK's `Activity` class,
    using the `settings_main.xml` file as the activity's layout. This activity's purpose
    is to obtain a value for the `mParticleSpeed` variable depending on the progress
    of the `SeekBar` object. Once the settings activity is exited, the `mParticleSpeed`
    value is saved to our preferences.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the live wallpaper service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step involved for setting up our live wallpaper is to create the `LiveWallpaperExtensionService.java`
    class, containing the code for the live wallpaper service. In order to specify
    that we would like the class to use the live wallpaper extension class, we simply
    add `extends BaseLiveWallpaperService` to the `LiveWallpaperExtensionService.java`
    declaration. Once this is done we can see that setting up a `BaseLiveWallpaperService`
    class is very much the same as setting up a `BaseGameActivity` class from this
    point on, allowing us to load resources, apply sprites, or any other common AndEngine
    task we're already used to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is a rather big one if we look at the whole project, but fortunately
    most of the code related to the class files has already been discussed in previous
    sections, so don't be worried! For the sake of brevity we are going to omit the
    classes which have already been discussed in previous chapters. Take a look at
    the topics mentioned in the *See more...* subsection for a refresher if needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, all we're doing is creating a minimal Android `xml` layout
    to be used for the settings activity. It is quite possible to skip this step and
    use AndEngine's `BaseGameActivity` for the settings activity, but to keep things
    simple we are using a very basic `TextView/SeekBar` approach. This makes things
    convenient for both the developer, time-wise, as well as the user, for convenience.
    Try to keep this screen as clutter free as possible as it is meant to be a simple
    screen, with a simple purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we are creating the `wallpaper.xml` file to be used as a reference
    to a few specifications needed for the live wallpaper service in the `AndroidManifest.xml`
    file. This file is simply in place to store the service's properties, which include
    the package and class name or "link" to the settings activity to be launched by
    pressing the **Settings...** button during the wallpaper preview. `wallpaper.xml`
    also includes a reference to the icon to be used in the wallpaper selection window.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we are modifying the `AndroidManifest.xml` file to allow us to
    run the live wallpaper service as the main component for this project, rather
    than launching an activity. Within the `<service>` tags, we are including the
    `name`, `icon`, and `label` attributes for the wallpaper service. These attributes
    have the same purpose as they would for an activity. The other two attributes
    are `android:enabled="true"`, meaning that we'd like the wallpaper service to
    be enabled by default, as well as the `android:permission="android.permission.BIND_WALLPAPER"`
    attribute, meaning only the Android OS can bind to the service. The activity's
    attributes are similar, except we're including the `exported` and `theme` attributes
    and excluding the `enabled` and `permission` attributes. The `android:exported="true"`
    attribute states that the activity can be launched through outside processes while
    the theme attribute will alter the appearance of the settings activity UI.
  prefs: []
  type: TYPE_NORMAL
- en: Step four involves creating the preferences class that we will be using to store
    the values available for adjustment by the user. In this recipe, we're including
    a single value called `mParticleSpeed` within the preferences class with corresponding
    getter and setter methods. In a more complex live wallpaper we can build on this
    class, allowing us to easily add or remove variables for as many customizable
    properties to our wallpaper as we'd like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step five, we are creating the `Activity` class shown when a user presses
    the **Settings...** button on the live wallpaper preview screen. In this particular
    `Activity`, we''re obtaining the `settings_main.xml` file to be used as our layout,
    containing two `TextView` view types used to display labels and corresponding
    values, and one `SeekBar` to allow manipulation of the wallpaper''s adjustable
    values. The most important task for this `Activity` is to be able to save to the
    preference file once a user has selected their ideal speed. This is done by adjusting
    the `mParticleSpeed` variable when `SeekBar` realizes a user has moved the `SeekBar`
    slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as updating the `mParticleSpeed` value, the associating `TextView`
    is updated within this event. This value, however, is not actually saved to the
    preference file until the user leaves the settings activity, to avoid unnecessary
    overwriting to the preference file. In order to save the new value to the preference
    file, we can call `setParticleSpeed(mParticleSpeed)` from the `LiveWallpaperPreferences`
    singleton during minimization of the `Activity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the sixth and final step, we can finally start to code the visual aspects
    of our live wallpaper. In this particular wallpaper, we''re keeping it simple
    in terms of visual appeal, but we do cover what all necessary information for
    developing a wallpaper. If we take a look at the `LiveWallpaperExtensionService`
    class, a few of the key variables to pay attention to, include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''ve already discussed the `mParticleSpeed` variable throughout the
    other class explanations, it should be obvious at this point that we''ll be using
    this variable to finally determine the speed of the particles, as this is the
    class that will handle the `ParticleSystem` object. The other two ''ratio'' variables
    declared above are to help us keep a proper scaling ratio for our entities. These
    variables are needed in the event that a user tilts their device from landscape
    to portrait or vice versa, so that we can calculate the scale of the particles
    depending on the width and height of the surface view. This is to prevent our
    entities from being stretched or distorted upon orientation changes. Skipping
    to the bottom overridden method of this class, the following code determines the
    values for `mRatioX` and `mRatioY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that the `if` statement is checking whether or not the device
    is in landscape or portrait mode. If `pWidth` is greater than `pHeight`, it means
    the orientation is currently in landscape mode, setting the x and y scale ratios
    to the default 1 value. On the other hand, if the device is set to portrait mode,
    then we must recalculate the scale ratio for our particle entities.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `onSurfaceChanged()` method is taken care of, let's continue on to
    the remaining key points with the next up being preference management. Taking
    care of preferences is a fairly trivial task. First and foremost, we should initialize
    the preference file, in case it is the first time the wallpaper is launched. We
    do this by calling the `initPreferences(this)` method from the `LiveWallpaperPreferences`
    instance in `onCreateEngineOptions()`. We also need to override the `onResume()`
    method in order to load the `mParticleSpeed` variable with the value stored in
    the preference file by calling the `getParticleSpeed()` method from the `LiveWallpaperPreferences`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we come to the remaining setup step for the live wallpaper, which
    is setting up the particle system. This particular particle system is none too
    fancy, but it does include a `ParticleModifier` object, which includes some points
    to note. Since we''re adding an `IParticleModifier` interface to the particle
    system, we are given access to individual particles spawned by the system on every
    update to each particle. In the `onUpdateParticle()` method, we''ll be setting
    the particle''s speed based on the `mParticleSpeed` variable loaded in from the
    preference file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also adjust the scale of the particle if its scale is not equal to
    the `mRatioX/mRatioY` values to compensate for device orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's all it takes to set up a live wallpaper with AndEngine! Try playing around
    with the particle system, adding new customizable values to the settings, and
    see what you can come up with. With this extension, you'll be up and running,
    creating new live wallpapers in no time at all!
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Saving and loading game data* section in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with particle systems* section in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking with the multiplayer extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we come to the undoubtedly most popular aspect of game design. This is
    of course multiplayer gaming. In this project recipe, we're going to work with
    AndEngine's multiplayer extension in order to create a fully functional client
    and server directly onto the mobile device. Once we cover the range of classes
    and features that this extension includes to make network programming easier,
    you will be able to take your online gaming ideas and turn them into reality!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a multiplayer game can require quite a few components in order to satisfy
    the readability of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the project named `MultiplayerExtensionExample` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we're going to separate these different components into five
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Android project, naming it `MultiplayerExtensionExample`. Once
    the project is ready to go, create four new class files with the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MultiplayerExtensionExample.java`: The `BaseGameActivity` class for the recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiplayerServer.java`: The class containing the main server component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiplayerClient.java`: The class containing the main client component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerMessages.java`: The class containing messages meant to be sent from
    the server to clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClientMessages.java`: The class containing messages meant to be sent from
    clients to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the project''s `AndroidManifest.xml` file and add the following two `<uses-permission>`
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of keeping things relative throughout this recipe, we're going
    to work with each class in the order they were mentioned in the *Getting ready*
    section, starting with the `MultiplayerExtensionExample` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare and register the server/client messages for `mMessagePool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the scene touch listener to allow the sending of messages to and
    from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the dialog *switch* statement prompting users to select to either act
    as the server or client. In the event a server or client component is selected,
    we will initialize one of the two components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the activity''s `onDestroy()` method to terminate both the server
    and client components when the activity is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once all of the main activity's functionality is in place, we can move on to
    writing the server-side code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the server''s initialization method—creating the `SocketServer` object,
    which handles connections to the server''s clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Handle the client connection to the server. This involves registering client
    messages and defining how to handle them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the `SocketServer` object has been declared and initialized, we need to
    call its `start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `sendMessage()` server broadcasting method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `terminate()` method to shut down the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the server-side code out of the way, we will continue on to implement the
    client-side code in the `MultiplayerClient` class. The class is quite similar
    to the `MultiplayerServer` class, so we'll be omitting the unnecessary client-side
    steps from here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `Socket`, `SocketConnection`, and finally the `ServerConnector`
    to establish the connection with the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Handling the messages received from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating client and server messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ClientMessage` and `ServerMessage` are meant to act as bundles of data that
    are able to be sent and received to and from the server as well as to and from
    clients. In this recipe, we''re creating a message for both the client and server
    to handle sending information about where to draw points on the client devices.
    The variables stored in these messages include:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While reading and writing the data for communication is as simple as the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe's implementation of server/client communication, we're building
    an application that allows a server to be deployed directly on a mobile device.
    From here, other mobile devices are able to act as a client and connect to the
    aforementioned mobile server. Once the server has been established with at least
    one client, the server will begin to relay messages to all clients if a touch
    event is created by any client, drawing points on the screens of all connected
    clients. If this sounds a bit confusing, have no fear. It will all come together
    shortly!
  prefs: []
  type: TYPE_NORMAL
- en: In the first five steps, we're writing the `BaseGameActivity` class. This class
    is simply the entry point to the server and client, as well as a means to provide
    touch event capabilities for clients to draw onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we're registering the necessary `ServerMessage` and `ClientMessage`
    objects to our `mMessagePool`. The `mMessagePool` object is an extension of the
    `MultiPool` class in AndEngine. See the *Creating sprite pools* section in [Chapter
    8](ch08.html "Chapter 8. Maximizing Performance"), *Maximizing Performance*, for
    how to use the `MessagePool` class to recycle messages sent and received across
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we are setting up the scene with a scene touch listener interface
    whose purpose is to send messages across the network. Within the touch listener,
    we can use simple conditional statements to check whether or not the device is
    running as a client or a server with the line, `if(mServer != null)`, returning
    true if the device is running as a server. Additionally, we can call `if(mClient
    != null)` to check if the device is running as a client. A nested client check
    inside a server check would return true in the event of a device operating as
    both a client and a server. If a device is operating as a client, sending a message
    is as easy as obtaining a new message from `mMessagePool`, calling the `set(device_id,
    touchX, touchY, colorId)` method on the said message, then calling `mClient.sendMessage(message)`.
    Once the message is sent, we should always recycle it back into the pool so as
    to not waste memory. One final point to mention before moving on; in the nested
    client conditional, we're sending a server message rather than a client message.
    This is because the client, in this case, is also the server. This means we can
    skip over sending a client message to the server since the server already contains
    the touch event data.
  prefs: []
  type: TYPE_NORMAL
- en: Step three will most likely not be an ideal situation for most developers as
    we're using dialogs as a means to choose whether the device will act as a server
    or a client. This scenario is simply used to display how to initialize the components,
    so a dialog is not necessarily important. Choosing whether users should be able
    to host games or not is very much dependent on the game type and developer's idea,
    but this recipe at least covers how to set up a server if need be. Just keep in
    mind, when initializing a server, all we need to know is the **port number** .
    A client, on the other hand, needs to know a valid **server IP** and server port
    in order to establish a connection. Once the `MultiplayerServer` and/or `MultiplayerClient`
    classes have been constructed with these parameters, we can initialize the components.
    The purpose of the initialization will be covered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and final step for the `BaseGameActivity` class is to allow the activity
    to terminate the `MultiplayerServer` and `MultiplayerClient` connections in the
    event that the activity calls `onDestroy()`. This will shut down the communication
    threads and sockets before the application is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the `MultiplayerServer` code, let's take a look at the initialization
    of a server in step five. When creating a `SocketServer` object that a server
    uses in order to listen for new client connections, we must pass in the server's
    port number, as well as a `ClientConnectorListener` and a `SocketServerListener`.
    The `MultiplayerServer` class implements those two listeners, logging whenever
    the server starts up, stops, when a client connects to the server, and when a
    client disconnects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sixth step, we''re implementing the system which handles how the server
    will respond to incoming connections, and how to handle messages received by clients.
    The following points cover the process involved in the order they should be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '`protected SocketConnectionClientConnector newClientConnector(...)` is called
    when a new client has connected to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new `SocketConnectionClientConnector` is for the client to use as a
    means of communication between the new client and the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the `ClientMessages` you wish the server to recognize via `registerClientMessage(flag,
    message.class, messageHandlerInterface)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the `onHandleMessage()`method of the `messageHandlerInterface` interface,
    we handle any messages received from across the network. In this case, the server
    is simply relaying the client's message back to all connected clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the new `clientConnector` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These points outline the main functionality of server/client communication.
    In this recipe, we're using a single message in order to draw points on client
    devices, but for a more broad range of messages we can continue to call the `registerClientMessage()`
    method so long as the flag parameter matches up with the message type we're obtaining
    in the `onHandleMessage()` interface. Once all of the appropriate messages have
    been registered and we're finished with the client handling code, we can continue
    on to step seven and call `start()` on the `mSocketServer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step eight, we create the `sendMessage(message)` method for the server.
    The server''s variation of `sendMessage(message)` sends a broadcast message to
    all clients by simply looping through the client connector list, calling `sendServerMessage(message)`
    to each connector. If we wish to send a server message to individual clients,
    we can simply call `sendServerMessage(message)` on an individual ClientConnector.
    On the other end, we have the client''s variation of `sendMessage(message)`. The
    client''s `sendMessage()` method does not actually send a message to other clients;
    in fact, the client doesn''t communicate with other clients at all. A client''s
    job is to communicate with the server, which then communicates to the other clients.
    See the following figure for a better understanding of how our netwok communication
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, the process is outlined by the numbers. First, a client
    sends the message to the server. Once the server receives the message, it will
    loop through each of the `ClientConnector` objects in its client list, sending
    the broadcast to all clients.
  prefs: []
  type: TYPE_NORMAL
- en: The final step involved in creating the `MultiplayerServer` component is to
    create a method for terminating the `mSocketServer`. This method is called by
    `onDestroy()` in our main activity in order to destroy the communication thread
    when we are finished with it.
  prefs: []
  type: TYPE_NORMAL
- en: With all of the server-side code in place, we can move on to writing the client-side.
    The `MultiplayerClient` code is somewhat similar to the server's, with a few differences.
    When establishing a connection with the server, we must be a little bit more specific
    than in the server's initialization. First, we must create a new Socket with a
    specified IP address to connect to, along with a server port number. We then pass
    the `Socket` to a new `SocketConnection` object, used to establish an input/output
    stream on the socket. Once this is done we can then create our `ServerConnector`,
    whose purpose is to make the final connection between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: We're coming close to a full client/server communication project now! Step eleven
    is where the real magic happens—the client receiving server messages. In order
    to receive a server message, similar to the server implementation of receiving
    messages, we simply call `mServerConnector.registerServerMessage(...)` which then
    gives us the opportunity to fill in an interface for `onHandleMessage(serverConnector,
    serverMessage)`. Again, similar to the server-side implementation, we can class-cast
    the `serverMessage` object to an `AddPointServerMessage` class, allowing us to
    obtain the custom values stored in the message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with all of the server and client code out of the way, we come to the final
    step. This is, of course, creating the messages that will be used for `MessagePool`
    as well as the objects that we've been sending and receiving all over the place.
    There are two different types of Message objects that we need to be aware of.
    The first type is `ServerMessage`, which consists of messages that are meant to
    be *sent from the client and received/read by the server*. The other type of message
    is, you've guessed it, `ClientMessage`, which is meant to be *sent from the server
    and received/read by the client(s)*. By creating our own message classes, we can
    easily package together chunks of data represented by primitive datatypes and
    send them across the network. The primitive datatypes include `int`, `float`,
    `long`, `boolean`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the messages used in this recipe, we''re storing an ID, which is meant to
    tell us whether the message is sent from a client or the server, the x and y coordinates
    of every client touch event, and the currently selected color id for drawing.
    Each value should have its own corresponding *get* method so that we''re able
    to obtain message details whenever a message is received. Additionally, by overriding
    a client or server message, we must implement the `onReadTransmissionData(DataInputStream)`
    method which allows us to obtain the datatypes from the input stream and copy
    them to our member variables. We must also implement the `onWriteTransmissionData(DataOutputStream)`,
    which is used to write the member variables to the data stream and send it across
    the network. One thing we need to be aware of when creating the server and client
    messages is that data read into our receiving member variables are obtained in
    the same order they were sent. See the order of our server message read and write
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the preceding code in mind, we can be sure that if we write a message
    containing an `int`, `float`, `int`, `boolean`, and a `float` into the output
    stream, any device receiving the message will read in an `int`, `float`, `int`,
    `boolean`, and a `float` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating high-resolution graphics with SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to incorporate **scalable vector graphics** (**SVG**) into our
    mobile games is a serious benefit to development, and even more so when working
    with Android. The biggest benefit, and the one we''ll be covering in this topic,
    is the fact that SVG''s can be scaled to suit the device running our applications.
    No more having to create multiple PNG sets for larger displays, and even more
    importantly, no more having to deal with terribly pixelated graphics on large
    screen devices! In this topic we''re going to use the `AndEngineSVGTextureRegionExtension`
    extension to create high-resolution texture regions for our sprites. See the following
    screenshot for a standard resolution image scaled on the left-hand side, versus
    SVG on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating high-resolution graphics with SVG](img/8987OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While SVG assets can be very convincing when it comes to creating high-resolution
    graphics across multiple screen sizes, there are some downsides to them as well,
    in the `SVG` extension's current state. The `SVG` extension will not render all
    of the elements available, such as text and 3D shapes, for example. However, most
    of the necessary elements are available and will properly load during runtime,
    such as paths, gradients, fill-colors, and some shapes. Elements which fail to
    load will be displayed via the Logcat during SVG loaing.
  prefs: []
  type: TYPE_NORMAL
- en: It is a wise choice to remove the elements which are not supported by the `SVG`
    extension from SVG files as they can influence loading times, which is the other
    negative aspect when it comes to using the `SVG` extension. The `SVG` textures
    will take considerably longer to load than PNG files as they must first be converted
    to PNG before loading to memory. It is not uncommon to see `SVG` textures take
    up to two or three times longer than the equivalent PNG images, depending on how
    many elements are included in each SVG. The most common workaround is to save
    the `SVG` textures to the device in PNG format during the first launch of the
    application. Every subsequent launch would then load the PNG images in order to
    reduce load time while keeping device-specific image resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the project named `WorkingWithSVG` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a `SVG` texture region is an easy task to accomplish with big results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to your average `TextureRegion`, first we require a `BuildableBitmapTextureAtlas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''ve got a texture atlas setup, we can create the `SVG` texture
    regions through the use of the `SVGBitmapTextureAtlasTextureRegionFactory` singleton:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see, creating an `SVG` texture region is not much different from your
    average `TextureRegion`. The only real difference between the two in terms of
    instantiation is the fact that we have to enter a `width` and `height` value as
    the final two parameters. This is because, unlike your average raster image format
    whose width and height are more or less hardcoded due to the fixed pixel positions,
    `SVG` pixel positions can be scaled up or down to any size we'd like. If we scale
    the `SVG` texture region, the vector's coordinates will simply adjust themselves
    in order to continue to produce a clear, precise image. Once the `SVG` texture
    region is built, we can apply it to a sprite as we would any other texture region.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all fine and dandy, knowing how to create the `SVG` texture region,
    but there''s more to it than that. After all, the beauty of being able to use
    SVG images in our games is the ability to scale the image depending on the device''s
    display size. In this way we can avoid having to load larger images for smaller
    screened devices in order to accommodate for tablets, and we won''t have to make
    our tablet users suffer by creating small texture regions in order to conserve
    memory. The `SVG` extension actually makes it quite simple for us to deal with
    the idea of scaling depending on display size. The following code shows us how
    we can implement a mass-scaling factor to all `SVG` texture regions created. This
    will allow us to avoid having to create different sized texture regions manually,
    depending on dispay size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be copied and pasted into the `onCreateEngineOptions()`
    method of an activity. All that needs to be done is to decide on the scale factors
    you''d like to apply to the SVG''s depending on device size! From this point on,
    we can create a single `SVG` texture region and, depending on the display size,
    the texture region will scale accordingly. For example, we can load up a texture
    region like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We may define the texture region's width and height values to `32`, but by adjusting
    the scale factor in the factory class, the texture region would be built to `80x80`
    by multiplying the specified value by the scale factor for a `DENSITY_XHIGH` display.
    Just be careful when handling texture regions with autoscaling factors. The scale
    will also increase the space they consume within the `BuildableBitmapTextureAtlas`
    object and may cause errors if exceeded, as with any other `TextureRegion`.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Different types of textures* section in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color mapping with SVG texture regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A useful aspect of `SVG` texture regions is the fact that we are able to easily
    map the texture's colors. This technique is common in games that allow users to
    select custom colors for their player's character, be it clothing and accessory
    color, hair color, skin color, terrain themes, and much more. In this topic, we're
    going to use the `ISVGColorMapper` interface while building our `SVG` texture
    regions in order to create customized color sets for our sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into the coding side of color mapping, we need to create an SVG
    image with preset colors. We can think of these preset colors as our *map*. One
    of the most preferred SVG editors amongst many developers is called **Inkscape**
    , which is a free, very easy to use, and full-featured editor. Inkscape can be
    downloaded from the following link, [http://inkscape.org/download/](http://inkscape.org/download/),
    or feel free to work with another SVG editor of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Color mapping might sound like it will be a tedious job, but in reality it's
    actually very easy to accomplish. All we need is to keep a little bit of consistency
    between the `SVG` image and the code. Keeping this in mind, the idea of creating
    multicolored, single source textures can be a very quick task. The steps below
    include the process starting from drawing the `SVG` image to allow for easy color
    mapping, as well as writing the code for mapping colors to specific areas of the
    `SVG` image within our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing our `SVG` image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to easily map colors to an `SVG` texture region during runtime, we
    need to draw an `SVG` image in the editor of our choice. This involves color-coding
    the different segments of our images for easy recognition in our `ISVGColorMapper`
    interface. The following figure depicts a shape with defined color values that
    are displayed on the left of the figure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/8987OS_09_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Implementing the `ISVGColorMapper` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just prior to creating the `SVG` texture region via `SVGBitmapTextureAtlasTextureRegionFactory`,
    we will define our `ISVGColorMapper` interface in relation to our `SVG` image.
    If we look at the conditionals in the following code, we can see that we are checking
    for the same color values found in the preceding figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, once the interface has been defined, we can pass it in as the final
    parameter when creating the texture region. Once this is done, creating a new
    sprite with the `SVG` texture region will yield the color values defined within
    the color mapper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just a brief lesson on colors before we start; if you're looking at this recipe's
    code and are confused about the *random* values selected for our conditionals
    and color results, it's very simple. Each color component, red, green and blue,
    can be supplied a color value anywhere between 0 and 255\. passing a value of
    0 to a color component would result in no contribution from that color, while
    passing 255 would be considered to be *full* color contribution. With this in
    mind, we know that if all color components return a value of 0, we will be passing
    the color black to our texture region's path. If we pass a value of 255 to the
    red component, while passing 0 for both green and blue, we know that the texture
    region's path will be a bright red color.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look back at the figure in the *How to do it...* section, we can
    see **alpha, red, green, and blue** (**ARGB**) color values with arrows pointing
    to the area on the circle that they represent. These will not directly affect
    the end result of our texture region''s colors; they are simply in place so that
    we can gain a reference to each portion of the circle within our color mapper
    interface. Note that the very first, most outer portion of the circle, is bright
    red at a value of 255\. With that in mind, see the following condition within
    our color mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The conditional statement in the preceding code will check for any path of the
    `SVG` image which contains a pure red value with no contributions from green or
    blue, returning a pure blue color instead. This is how the swapping of colors
    occurs, and this is how we can map colors to our images! Knowing this, it is entirely
    possible to create many different sets of colors for our `SVG` images, but for
    each color set, we must provide a separate texture region.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important key point to note is that we should include a returning value
    that will return the default path''s color values in the event that none of our
    conditions are met. This allows us to leave out conditionals for smaller details
    such as the `SVG` image''s outline, or other colors, and instead fill them in
    as they appear in the image if we were to open it in our favorite `SVG` editor.
    This should be included as the final `else` statement in the color mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *How it works...* section of this recipe, we covered how to change the
    colors of static `SVG` image paths. Without putting too much thought into the
    idea of creating color themes as mentioned above, it might sound like this is
    the be-all-end-all to creating more objects, terrain, characters, and so on. The
    truth is that, in this day and age, a lot of games need variance in order to create
    an appealing asset. By variance, we are of course referring to gradients. If we
    think back to the conditionals we'd written above, we are checking for absolute
    color values before returning a customized color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, working with gradients is not too difficult as we can adjust the
    gradient''s **Stop Color** and the interpolation between colors will automatically
    be handled for us! We can think of a *stop* as a color-defining point of the gradient
    which interpolates between other *stops* as distance increases. This is what causes
    the gradient''s blending effect and this also plays a role in the ease of creating
    color themes through the use of the same method described in this recipe. See
    the following screenshot for a gradient that starts out as a pure red color `RGB{255,
    0, 0}`, to pure green `RGB{0, 255, 0}`, and finally to blue `RGB{0, 0, 255}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/8987OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to use the above gradient in an `SVG` image, we could easily apply
    color mapping with proper interpolation between the color stops by simply modifying
    the specific color at the position of each stop. The following code will change
    the gradient to appear red, green, and yellow, rather than having blue as the
    third color stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating high-resolution graphics with SVG* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
