- en: Chapter 2. Presenting Data for Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the first chapter we covered the basic creation of a project, and how to
    put together a simple user interface. We backed our first `Activity` with enough
    code to dynamically generate some buttons that the user can use to answer our
    multiple-choice questions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*So now we can capture some data, but what about displaying data? One large
    advantage of software is its ability to present and filter very large volumes
    of data quickly and in an easy-to-read format. In this chapter we will look at
    a series of Android widgets that are designed exclusively for presenting data.*'
  prefs: []
  type: TYPE_NORMAL
- en: Most Android data-centric classes are built on top of `Adapter` objects, and
    thus extend the `AdapterView` . An `Adapter` can be thought of as a cross between
    a Swing Modelclass, and a renderer (or presenter). An `Adapter` object is used
    to create `View` objects for data objects that your software needs to display
    to the user. This pattern allows the software to maintain and work with a data-model
    and only create a graphical `View` for each of the data objects when one is actually
    needed. This doesn't just help conserve memory, but it is also more logical from
    a development point of view. As a developer you work with your own data objects
    instead of trying to keep your data in graphical widgets (which are often not
    the most robust of structures).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common `AdapterView` classes you''ll encounter are: `ListView`, `Spinner`
    , and `GridView` . In this chapter we''ll introduce the `ListView` class and `GridView`,
    and explore the various ways they can be used and how they can be styled.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing and selecting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListView` class is probably the most common way to display lists of data.
    It's backed by a `ListAdapter` object, which is responsible for both holding the
    data and rendering the data objects in a `View`. A `ListView` includes built-in
    scrolling, so there's no need to wrap it in a `ScrollView`.
  prefs: []
  type: TYPE_NORMAL
- en: ListView choice modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ListView` class allows for three basic modes of item selection, as defined
    by its constants: `CHOICE_MODE_NONE`, `CHOICE_MODE_SINGLE`, and `CHOICE_MODE_MULTIPLE`.
    The mode for a `ListView` can be set by using the `android:choiceMode` attribute
    in your layout XML file, or by using the `ListView.setChoiceMode` method in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Choice modes and items**'
  prefs: []
  type: TYPE_NORMAL
- en: The choice mode of a `ListView` changes the way the `ListView` structure behaves,
    but not the way it looks. The look of a `ListView` is defined mostly by the `ListAdapter`,
    which provides `View` objects for each of the items that should appear in the
    `ListView`
  prefs: []
  type: TYPE_NORMAL
- en: No selection mode – CHOICE_MODE_NONE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a desktop system, this would make no sense—a list that doesn't allow the
    user to choose anything? However, it's the default mode of an Android `ListView`.
    The reason is it makes sense when your user is navigating by touch. The default
    mode of a `ListView` allows the user to tap on one of the elements, and trigger
    an action. As a result of this behavior, there's no need for a "Next" button,
    or anything similar. So the default mode for a `ListView` is to act like a menu.
    The following screenshot is a default `ListView` object displaying a list of different
    strings from a `String` array Java object, taken from one of the default `ApiDemos`
    examples in Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '![No selection mode – CHOICE_MODE_NONE](img/4484_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Single selection mode – CHOICE_MODE_SINGLE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this mode, the `ListView` acts more like a desktop `List` widget. It has
    the notion of the current selection, and tapping on a list item does nothing more
    than selecting it. This behavior is nice for things like configuration or settings,
    where the user expects the application to remember his or her current selection.
    Another place a single selection list becomes useful is when there are other interactive
    widgets on the screen. However, be careful not to put too much information in
    a single `Activity`. It's quite common for a `ListView` to occupy almost an entire
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Single-choice selection: It doesn''t directly change the way your list items
    appear. The look and feel of your list items is defined entirely by the `ListAdapter`
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android does, however, provide a collection of sensible defaults in the system
    resources. In the `android` package you will find an `R` class. It''s a programmatic
    way to access the system''s default resources. If you wanted to create a single-choice
    `ListView` with a `<string-array>` of colors in it, you could use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case we use the provided `ArrayAdapter` class from the `android.widget`
    package. In the second parameter we referenced the Android layout resource named
    `simple_list_item_single_choice`. This resource is defined by the Android system
    as a default way to display items in a `ListView` with `CHOICE_MODE_SINGLE`. Most
    typically this is a label with a `RadioButton` for each object in the `ListAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Single selection mode – CHOICE_MODE_SINGLE](img/4484_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiple selection mode – CHOICE_MODE_MULTIPLE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In multi-selection mode, the `ListView` replaces the radio buttons of single-selection
    mode with normal checkboxes. This design structure is often used on desktops and
    web-based systems as well. Checkboxes are easily recognized by users, and make
    it easy to go back and turn options off again. If you wish to use a standard `ListAdapter`,
    Android provides you with the `android.R.layout.simple_list_item_multiple_choice`
    resource as a useful default: A label with a `CheckBox` for each object in the
    `ListAdapter`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple selection mode – CHOICE_MODE_MULTIPLE](img/4484_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding header and footer widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Headers and footers in a `ListView` allow you to put additional widgets at
    the top and bottom of the `List`. The header and footer widgets are by default
    treated as though they are items in a list (as though they come from your `ListAdapter`).
    This means that you will be able to select them as though they are data elements
    in the `List` structure. A very simple example of a header item could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Often you don''t want your headers and footers to be items in the `ListView`,
    but instead a label or group of labels identifying parts of the `ListView`, or
    providing other information. In this case you need to tell the `ListView` that
    your header or footer views are not selectable list items. This can be done by
    using the extended implementation of `addHeaderView` or `addFooterView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ListView` class integrates headers and footers so tightly into the list
    structure that you can also provide an `Object` that it will return from the `Ad`
    `apterView.getItemAtPosition(index)` method. In our previous example we have provided
    `null`. Each header item will offset the index of subsequent views by one (as
    though you are adding new items to the `ListView`). The third parameter tells
    the `ListView` whether the header or footer should be counted as a selectable
    list item (in our previous example it shouldn't).
  prefs: []
  type: TYPE_NORMAL
- en: If you are used to desktop widgets, the header and footer widgets on an Android
    `ListView` will have a bit of a surprise for you. They will scroll with the rest
    of the list items, and won't stay attached to the top and bottom of the `ListView`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple ListView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To introduce the `ListView` class, we'll start a new example which will be enhanced
    by various subsequent sections of this chapter. The first `Activity` we will create
    will use a simple `ListView` populated from a `<string-array>` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a fast food menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To continue with the food and eating theme, let's build a simple application
    that allows us to order various types of fast food, and get it delivered! The
    user will first select where they want to order from, and then select the various
    foodstuffs that they want to eat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `android` project using the Android command-line tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `/res/values/strings.xml` file in your favorite editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a string-array structure listing the various fast-food restaurants our
    users can order from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `/res/layout/main.xml` file in your favorite editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any widget that is inside the default `LinearLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `<ListView>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the `<ListView>` element an ID of `restaurant`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the width and height of the `ListView` to `fill_parent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we have a string-array resource of the content we want to populate the
    `ListView` with, we can reference it directly in our layout XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you''ve completed the specified steps, you should have a `main.xml` layout
    file that looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you install your application into the emulator, and run it, you'll be presented
    with a screen where you can select from the list of restaurants specified in your
    string-array resource. Notice that the `choiceMode` on the `ListView` is left
    as `CHOICE_MODE_NONE`, making this into a more direct menu where the user selects
    their restaurant and is instantly transported to its menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened](img/4484_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we used the `android:entries` attribute in the layout XML file
    to specify a reference to a string-array resource with our desired list items
    in it. Normally, using an `AdapterView` requires you to create an `Adapter` object
    to create `View` objects for each of the data objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `android:entries` attribute allows you to specify the data contents
    of the `ListView` from your layout resource, instead of requiring you to write
    the normal Java code associated with an `AdapterView`. It, however, does have
    two disadvantages to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: The `View` objects created by the generated `ListAdapter` will always be the
    system-specified defaults, and so cannot be easily themed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot define data objects that will be represented in the `ListView`. Since
    string-arrays are easily localized, your application will rely on the index locations
    of items to determine what they indicate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may notice that at the top of the screenshot, the label `Where should we
    order from?` is not the application default. The label for an `Activity` is defined
    in the `AndroidManifest.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Styling the standard ListAdapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard `ListAdapter` implementations require each item be represented
    in a `TextView` item. The default single-choice and multiple-choice items are
    built using a `CheckedTextView`, and while there are plenty of other `TextView`
    implementations in Android, it does limit our options a bit. However, the standard
    `ListAdapter` implementations are very convenient and provide solid implementations
    for the most common listing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Since a `ListView` with `CHOICE_MODE_NONE` is a lot like a menu, wouldn't it
    be nice to change the items into `Button` objects instead of normal `TextView`
    items? Technically, a `ListView` can contain any widget that extends `TextView`.
    However, some implementations are more suitable than others (for example, a `ToggleButtonView`
    won't maintain the specified text-value when the user touches it).
  prefs: []
  type: TYPE_NORMAL
- en: Defining standard dimensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example we'll be creating various menus for the application. In order
    to maintain a consistent look and feel, we should define a set of standard dimensions
    which will be used in each of our layout files. This way we can redefine the sizes
    for different types of screens. There's nothing more frustrating for a user than
    only being able to see a partial item because it's been sized bigger than their
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new resource file to contain the dimensions. The file should be named
    `res/values/dimens.xml`. Copy the following code into the new XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare two height dimensions for the list items: `item_outer_height` and
    `item_inner_height`. The `item_outer_height` will be the height of the list items,
    while the `item_inner_height` is the height of any `View` object contained inside
    the list item.'
  prefs: []
  type: TYPE_NORMAL
- en: The `padding` dimension at the end of the file is used to define a standard
    amount of whitespace between two visual elements. This is defined as `dp` so it
    will remain constant based on the DPI of the screen (instead of scaling according
    to the font size preferences of the user).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sizing of interactive items**'
  prefs: []
  type: TYPE_NORMAL
- en: In this styling, you'll notice that the `item_outer_height` and `menu_item_height`
    are `48sp` and `52sp`, which makes the items in the `ListView` rather large. The
    standard size of a list view item in Android is `48sp`. The height of a list item
    is critical. If your users have large fingers, they will struggle to tap on their
    target list item if you make them too small.
  prefs: []
  type: TYPE_NORMAL
- en: This is a general "good practice" for Android user interface design. If the
    user needs to touch it, make it big.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – improving the restaurant list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The list of restaurants we put together earlier is nice, but it's a menu. In
    order to further emphasize the menu, the text should stand out more. In order
    to style a `ListView` with a standard `ListAdapter` implementation, you will need
    to specify the `ListAdapter` object in your Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `res/layout` directory named `menu_item.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the root XML element as a `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the Android resource XML namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Center the text in the `TextView` widget by setting its gravity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We assign the `textSize` of the `TextView` to our standard `item_text_size`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The default color of the text of `TextView` is a bit gray, we want it to be
    white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want the width of the `TextView` to be the same as the `ListView` that contains
    it. Since this is for our main menu, its height is `menu_item_height`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a styled `TextView` resource, we can incorporate it into our
    menu. Open the `SelectRestaurantActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate` method, after you use `setContentView`, we need a reference
    to the `ListView` we created earlier in `main.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the restaurants `ListAdapter` to a new `ArrayAdapter` containing the string-array
    of restaurants we created in our `values.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first created a new layout XML resource containing the styled `TextView`
    that we wanted to be used for each list item in our restaurant''s `ListView`.
    The `menu_item.xml` file you wrote should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unlike our previous layout resources, `menu_item.xml` contained no `ViewGroup`
    (such as `LinearLayout`). This is due to the fact that the `ArrayAdapter` will
    attempt to cast the root `View` of the `menu_item.xml` file to a `TextView`. So,
    if we nested the `TextView` in a `ViewGroup` of some sort, we'd get a `ClassCastException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also created an `ArrayAdapter` instance to reference both our `menu_item`
    XML resource, and the string-array of restaurants we created earlier. This action
    eliminates the use of the `android:entries` attribute on the `ListView` in the
    `main.xml` layout XML resource. If you want, you can remove that attribute. Your
    `onCreate` method in `SelectRestaurantActivity` should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Try re-installing the application into the emulator with Apache Ant, and you''ll
    now be greeted by a screen that looks a lot more like a menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened](img/4484_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero – developing a multiple-choice question application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try going back to the multiple-choice question application we wrote in [Chapter
    1](ch01.html "Chapter 1. Developing a Simple Activity"), *Developing a Simple
    Activity*. It uses `LinearLayout` and `Button` objects to display the possible
    answers to the questions, but it also uses string-arrays for the answers. Try
    modifying the application to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `ListView` instead of a `LinearLayout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style the `ListView` with `Button` objects, as we styled our restaurant menu
    with `TextView` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you have some margin between the `Button` list items so that they're
    not too close to each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to order food, we often want to order more than one of the same
    item. The `ListView` implementation, and the standard `ListAdapter` implementations
    allow for us to select a **Cheese Burger** item, but not for us to request **3
    Cheese Burgers**. In order to display a menu of different foods that the user
    can order in multiple quantities, we need a customized `ListAdapter` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a menu for The Burger Place
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each restaurant in our main menu, we are going to build a separate `Activity`
    class. In reality, this is not a great idea, but it allows us to investigate different
    ways of organizing and displaying the menu data. Our first stop is **The Burger
    Place**, for which we present the user with a list of burgers, and let them tap
    the ones they want on the screen. Each time they tap a list item, they order another
    burger. We will display the number of burgers they are ordering in bold to the
    left of the burger's name. Next to burgers that they aren't ordering, there should
    be no number (this allows the user to see what they are ordering at a quick glance).
  prefs: []
  type: TYPE_NORMAL
- en: The Burger class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to display the menu, we need a simple `Burger` data object. The `Burger`
    class will hold a name to be displayed in the menu, and the number of `Burger`
    the user is ordering. Create a `Burger.java` file in the root package of your
    project with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that there are no getters and setters in the preceding code, and
    that both the `name` and `count` fields are declared as package-protected. In
    versions of Android prior to 2.2, methods incurred a heavy expense when compared
    to a straight field lookup. Since this class will be a small part of the rendering
    procedure (we will be extracting data from it for display), we should make sure
    we incur as little expense as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a Burger item layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do in order to create a nice looking menu for **The Burger
    Place** is to design the menu items. This is done in much the same way as the
    styling of the restaurant list with a layout XML resource. However, since we will
    be building the `ListAdapter` ourselves this time, we are not forced to use a
    single `TextView`, but can instead build a more complex layout.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new XML file in the `res/layout` directory named `burger_item.xml`.
    This file will be used for each burger in the `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root of the layout as a `horizontal LinearLayout` (note the height,
    which will be the height of each item in the `ListView`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, declare a `TextView`, which we will use as a `counter` for the number
    of burgers being ordered. We will later access this through its ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `counter` text size is exactly the same as all of the other list items
    in the application. However, it should be `bold`, so it can be easily identified
    and read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want the `counter` to be square, so set the width and height exactly
    the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to center the text inside the `counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll also need a text space to display the name of the burger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The text size is standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want a little bit of space between the `counter` and the `text` label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The label''s width should fill the `ListView`, but we want the size of both
    `TextView` objects to be the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The text of the label should be centered vertically, to match the location
    of the `counter`. However, the label should be left-aligned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ve just built a very nice `LinearLayout ViewGroup` which will be rendered
    for each of the burgers we sell from **The Burger Place**. Since the `counter
    TextView` is a separate object from the label, it can be independently styled
    and managed. This makes things much more flexible going forward if we want to
    apply additional styles to them independently. Your complete `burger_item.xml`
    file should now appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – presenting Burger objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard `ListAdapter` classes work well if your data objects are either
    strings or easily represented as strings. In order to display our `Burger` objects
    nicely on the screen, we need to write a custom `ListAdapter` class. Fortunately,
    Android provides us with a nice skeleton class for `ListAdapter` implementations
    named `BaseAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class named `BurgerAdapter`, and have it extend from the `android.widget.BaseAdapter`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An `Adapter` is part of the presentation layer, but is also the underlying
    model of the `ListView`. In the `BurgerAdapter` we store an array of `Burger`
    objects which we assign in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Adapter.getCount()` and `Adapter.getItem(int)` methods directly
    on top of the array of `Burger` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An `Adapter` is also expected to provide identifiers for the various items,
    we will just return their index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When an `Adapter` is asked for a `View` of a list item, it may be given an
    existing `View` object that could be reused. We will implement a simple method
    to handle this case, and if required, inflate the `burger_item.xml` file we wrote
    earlier using the `LayoutInflator` class from the `android.view` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The most important method for us in the `BurgerAdapter` is the `getView` method.
    This is where the `ListView` will ask us for a `View` object to represent each
    list item it needs to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to fetch the correct `View` for a given item, you''ll first need to
    use the `getViewGroup` method to ensure you have the `burger_item.xml ViewGroup`
    to display the `Burger` item in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll be populating these two `TextView` objects with the data from the `Burger`
    object at the requested `index`. The `counter` widget needs to be hidden from
    the user if the current `count` is zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just wrote a custom `Adapter` class to present an array of `Burger` objects
    to the user in a `ListView`. When a `ListView` invokes the `Adapter.getView` method,
    it will attempt to pass in the `View` object that was returned from a previous
    call to `Adapter.getView`. A `View` object will be created for each item in the
    `ListView`. However, when the data displayed by the `ListView` changes, the `ListView`
    will ask the `ListAdapter` to reuse each of the `View` objects it generated the
    first time around. It's important to try and honor this behavior, since it has
    a direct impact on the responsiveness of your application. In our preceding example,
    we implemented the `getViewGroup` method so that it would take this requirement
    into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getViewGroup` method is also used to inflate the `burger_item.xml` file
    we wrote. We do this using a `LayoutInflator` object, which is exactly how the
    `Activity.setContentView(int)` method loads XML layout resources. The `Context`
    object which we fetch from our `parent ViewGroup` (which will generally be the
    `ListView`) defines where we will load the layout resource from. If the user hasn''t
    selected a `Burger`, we hide the counter `TextView` using the `View.setVisibility`
    method. In AWT and Swing, the `setVisible` method takes a `Boolean` parameter,
    whereas in Android, `setVisibility` takes an `int` value. The reason for this
    is that Android treats visibility as part of the layout process. In our case we
    want the `counter` to disappear, but still take up its space in the layout, which
    will keep the `text` labels left-aligned with each other. If we wanted the counter
    to vanish and take up no space, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`ListView` objects will automatically handle the highlighting of a selected
    item. This includes when the user holds their finger on the item, and when they
    use a track-pad or directional buttons to navigate the `ListView`. When an item
    is highlighted, its background generally changes color, according to standard
    UI conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: However, using widgets in a `ListView` that in some way directly captures user
    input (that is, a `Button` or `EditText`) will cause the `ListView` to stop showing
    the selection highlighting for that widget. In fact, it will stop the `ListView`
    from registering `OnItemClick` events completely.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Custom separators in a ListView**'
  prefs: []
  type: TYPE_NORMAL
- en: If you override the `isEnabled(int index)` method of `ListAdapter`, you can
    strategically disable specified items in the `ListView`. A common use of this
    is to turn certain items into logical separators. For example, a section separator
    in an alphabetically sorted list, containing the first letter of all items in
    the next "section".
  prefs: []
  type: TYPE_NORMAL
- en: Creating TheBurgerPlaceActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to put the `Burger` menu on the screen, and to allow the user to order
    items, we need a new `Activity` class. We need to know when the user touches the
    items in the list, for which we will need to implement the `OnItemClickListener`
    interface. When a specific event occurs (in this case the user touches a specific
    item in the `ListView`), objects registered as listeners will have a related method
    invoked with the details of the event that occurred. Android provides a simple
    `ListActivity` class to provide some default layout and utility methods for this
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing TheBurgerPlaceActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to present a `ListView` of `Burger` objects with the `BurgerAdapter`
    class, we will need to create an `Activity` implementation for **The Burger Place**.
    The new `Activity` will also be responsible for listening to "touch" or "click"
    events on the items in the `ListView`. When the user touches one of the items,
    we need to update the model and `ListView` to reflect that the user has ordered
    another `Burger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class in the root package of your project named `TheBurgerPlaceActivity`,
    and make sure it extends `ListActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Override the `Activity.onCreate` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `super.onCreate` to allow normal Android startup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an instance of `BurgerAdapter` with some `Burger` objects, and set it
    as the `ListAdapter` for the `ListActivity` code to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement the `onListItemClicked` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This implementation of `TheBurgerPlaceActivity` has a simple hard-coded list
    of `Burger` objects to display to the user and creates a `BurgerAdapter` to turn
    these objects into the `burger_item View` objects which we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: When the user taps a list item, we increment the `count` of the related `Burger`
    object in the `onItemClick` method. We then call `notifyDataSetInvalidated()`
    on the `BurgerAdapter`. This method will inform the `ListView` that the underlying
    data has changed. When the data changes, the `ListView` will re-invoke the `Adapter.getView`
    method for each item in the `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: The items in a `ListView` are represented by effectively static `View` objects.
    This means that the `Adapter` must be allowed to update or recreate that `View`
    when the data model is updated. A common alternative is to fetch the `View` representing
    your updated data, and update it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Registering and starting TheBurgerPlaceActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to start the new `Activity` class from our restaurant menu, you will
    need to register it in the `AndroidManifest.xml` file. First, open the `AndroidManifest.xml`
    file in an editor or IDE, and copy the following `<activity>` code into the `<application>...</application>`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the `Activity`, you''ll need to go back to `SelectRestaurantActivity`
    and implement the `OnItemClickListener` interface. After setting the `Adapter`
    on the `restaurants ListView`, set `SelectRestaurantActivity` as the `OnItemClickListener`
    of the `restaurants ListView`. You can start `TheBurgerPlaceActivity` using an
    `Intent` object in the `onItemClick` method. Your `SelectRestaurantActivity` class
    should now look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When you reinstall the application and start it up in the emulator, you'll be
    able to navigate to **The Burger Place** and place an order for burgers. Pressing
    the hardware "Back" button in **The Burger Place** menu will take you back to
    the restaurant menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering and starting TheBurgerPlaceActivity](img/4484_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting the choice mode on a `ListView` object to `CHOICE_MODE_SINGLE` will:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `RadioButton` to each item.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do nothing (this is the default).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the `ListView` track a "selected" item.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `ListAdapter` defines how a `ListView` displays its items. When will it be
    asked to reuse a `View` for an item object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the data model is invalidated or changed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On every item, for rubber-stamping.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `ListView` redraws itself.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a `ListView` is scrollable, header and footer objects will be positioned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Above and below the scrolling items.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Horizontally alongside each other, above and below the scrolling items.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrolling with the other items.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the ExpandableListView class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListView` class is great for displaying small to medium amounts of data,
    but there are times when it will flood your user with far too much information.
    Think about an email application. If your user is a heavy email user, or subscribes
    to a few mailing lists, they may well have several hundred emails in a folder.
    Even though they may not need to scroll beyond the first few, seeing the scrollbar
    shrink to a few pixels in size doesn't have a good psychological effect on your
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In desktop mail clients, you will often group the email list by time: Today,
    yesterday, this week, this month, and forever (or something similar). Android
    includes the `ExpandableListView` for this type of grouping. Each item is nested
    inside a group, and a group can be displayed or hidden by the user. It''s a bit
    like a tree view, but always nested to exactly one level (you can''t display an
    item outside a group).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Massive ExpandableListView groups**'
  prefs: []
  type: TYPE_NORMAL
- en: There are times where even an `ExpandableListView` will not be enough to keep
    the amount of data to a reasonable length. In these cases, consider giving your
    user the first few items in the group and adding a special **View More** item
    at the end. Alternatively, use a `ListView` for the groups, and a separate `Activity`
    for the nested items.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ExpandableListAdapter implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the `ExpandableList` class includes two levels of detail, it can''t work
    against a normal `ListAdapter` which only handles a single level. Instead, it
    includes the `ExpandableListAdapter` which uses two sets of methods: one set for
    the group level and another set for the item level. When implementing a custom
    `ExpandableListAdapter`, it''s generally easiest to have your `ExpandableListAdapter`
    implementation inherit from the `BaseExpandableListAdapter`, as it provides implementations
    for event registration and triggering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExpandableListAdapter` will place an arrow pointer on the left side of
    each group item to indicate whether the group is open or closed (much like a drop-down/combobox).
    The arrow is rendered on top of the group''s `View` object as returned by the
    `ExpandableListAdapter`. To stop your group label from being partly obscured by
    this arrow, you''ll need to add padding to your list item `View` structures. The
    default padding for a list item is available as the theme parameter `expandableListPreferredItemPaddingLeft`,
    which you can make use of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In order to keep your `ExpandableListView` looking consistent, it's a good idea
    to add the same amount of padding to the normal (child) items of the `ExpandableListView`
    (to keep their text aligned with that of their parent group), unless you are putting
    an item on the left-hand side, such as an icon or checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero - ordering customized pizzas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the `Mick's Pizza` example, we're going to create a menu of categorized
    pizza toppings. Each topping consists of a name, whether it's 'on' or 'off' the
    pizza, or 'extra' (for example, extra cheese). Use two `TextView` objects arranged
    horizontally for each item. The right `TextView` can hold the name of the topping.
    The left `TextView` can be empty when toppings are not included, `On` when toppings
    are included, and `Extra` for toppings that the user wants more than the usual
    amount.
  prefs: []
  type: TYPE_NORMAL
- en: Create an object model with `ToppingCatagory` objects, containing a name and
    an array of `PizzaTopping` objects. You'll want to store some state whether each
    topping is ordered, and in what quantity.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also want to implement a `PizzaToppingAdapter` class, extending the `BaseExpandableListAdapter`
    class. Make use of the default Android `simple_expandable_list_item_1` layout
    resource for the group label, and a new customized layout resource for the item
    labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user taps on a pizza topping, it changes its status between the three
    values: **Off**, **On**, and **Extra**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `ListView.getAdapter()` method will not return your `ExpandableListAdapter`
    implementation, but a wrapper instead. To fetch the original `ExpandableListAdapter`,
    you will need to use the `getExpandableListAdapter()` method. You will also want
    to make use of the `ExpandableListView. OnChildClickListener` interface to receive
    click events.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your new `Activity` is complete, you should have a screen which looks
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero - ordering customized pizzas](img/4484_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the GridView class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `GridView` is a `ListView` with a fixed number of columns, arranged left-to-right,
    top-to-bottom. The standard (un-themed) Android application menu is arranged like
    a `GridView`. The `GridView` class makes use of a `ListAdapter` in the exact same
    format as `ListView`. However, because of its fixed column count, a `GridView`
    is very well suited for lists of icons.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using GridViews effectively**'
  prefs: []
  type: TYPE_NORMAL
- en: A `GridView` can display significantly more information on a single screen than
    a `ListView`, at the expense of not being able to show as much text information.
    From a usability point of view, icons are often easier to work with than text.
    Icons can be recognized more quickly than text, thanks to their colors. When you
    have information that can be represented using icons, it's a good idea to display
    it as such. However, remember that icons need to be unique within a single screen
    preferably within the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: For our next example, we're going to build the **Four Buckets 'o Fruit** menu,
    using `GridView`. The `GridView` will have an icon for each item on the menu,
    and the name of the item below the icon. So, when complete, it will look much
    like the standard Android application menu. This next example will focus less
    on the implementation of the `ListAdapter`, since it's largely the same as the
    `ListAdapter` we built for **The Burger Place**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Icons on touchscreen devices**'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to think about icons on a touchscreen device. They need to be
    even more self-explanatory than usual, or be accompanied by some text. With a
    touchscreen, it's very hard to provide any sort of contextual help, such as a
    tool-tip. If the user is touching the object, it's often obscured by their finger
    and/or hand, making the icon and tool-tip invisible.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the fruit icon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to display the various types of fruits as icons, we will need to create
    a layout XML file. Each icon in the `GridView` will be represented as an instance
    of this layout, in exactly the same way as list items are represented in a `ListView`.
    We create each item as an `ImageView` for the icon, with a `TextView` below it
    for the label.
  prefs: []
  type: TYPE_NORMAL
- en: Create a file in the `res/layout` directory named `fruit_item.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of the icon as a vertical `LinearLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `ImageView` element that will serve as our icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the `TextView` element that will serve as the label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fruit_item.xml` file is a very simple layout for our menu icons, and could
    be used for many other types of icons represented as a grid. `ImageView` objects
    will, by default, attempt to scale their content to their size. In our previous
    example, the root `LinearLayout` has the width and height defined as `fill_parent`.
    When placed in a `GridView` as a single item, using `fill_parent` as a size will
    cause the `LinearLayout` to fill the space provided for that grid item (not the
    entire `GridView`).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying icons in a GridView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need an object model and `ListAdapter` in order to display the fruits to
    the user in a `GridView`. The adapter is fairly straightforward at this point.
    It's a normal `ListAdapter` implementation built on top of an item class and the
    layout XML we defined for the icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each item of fruit, we will need an object holding both the fruit''s name
    and icon. Create a `FruitItem` class in the root package with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we referenced the icon image for the fruit as an integer.
    When we reference application resources and IDs in Android, it's always with an
    integer. For this example we're assuming that all of the different types of fruit
    each have an icon as an application resource. Another option would be to hold
    a reference to a `Bitmap` object in each `FruitItem`. However, this would have
    meant holding the full image in memory when the `FruitItem` is potentially not
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the Android Asset Packaging Tool to recognize and store the icons,
    you will need to put them in the `res/drawable` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Android Image Resources**'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it's considered a good practice in Android to store bitmap images
    as PNG files. Since you will be accessing these files from your code, make sure
    they have Java-friendly filenames. The PNG format (unlike JPG) is lossless, can
    have various different color depths, and correctly handles transparency. This
    generally makes it a great image format on the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – building the fruit menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the **Four Buckets 'o Fruit** menu, we're going to need a `ListAdapter`
    implementation to render the `FruitItem` objects into the `fruit_item.xml` layout
    resources. We'll also need a layout resource for the `GridView` which we will
    load in our new `Activity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `FruitAdapter` extending `BaseAdapter` in the root
    package of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FruitAdapter` needs to hold and represent an array of `FruitItem` objects.
    Implement the class using the same structure as the `BurgerAdapter`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ListAdapter.getView` method, set the label and icon as defined in the
    `fruit_item.xml` layout resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new layout resource to hold the `GridView` that we will use for the
    **Four Buckets 'o Fruit** menu, and name it `res/layout/four_buckets.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the new layout resource with a three column `GridView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new `four_buckets.xml` layout resource has nothing but a `GridView`. This
    is unlike the other layout resources we've written so far, especially since the
    `GridView` has no ID. For this example, the fruit menu `Activity` will contain
    nothing but the `GridView`, so there's no need for an ID reference or layout structure.
    We also specified horizontal and vertical spacing of `5dip`. A `GridView` object's
    default is to have no spacing between its cells, which makes for fairly squashed
    content. In order to space things out a bit, we ask for some whitespace between
    each of the cells.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the FourBucketsActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are working with a layout resource with only a `GridView`, and no ID
    reference, we're going to walk through the creation of the `Activity` step-by-step.
    Unlike previous `Activity` implementations, we will need a direct reference to
    the `GridView` defined in `four_buckets.xml`, and this means loading it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new class in your project''s root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onCreate` method, and invoke the super implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the `LayoutInflator` instance for your `Activity` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inflate the `four_buckets.xml` resource and cast its contents directly to a
    `GridView` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `ListAdapter` of the `view` object to a new instance of the `FruitAdapter`
    class, and populate the new `FruitAdapter` with some `FruitItem` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `setContentView` to make the `GridView` your root `View` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Register your `FourBucketsActivity` class in your `AndroidManifest.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a case to the `SelectRestaurantActivity` to start the new `FourBucketsActivity`
    when the user selects it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just completed the **Four Buckets 'o Fruit** menu. If you re-install the
    application into your emulator, you'll now be able to go and order fruits (just
    be careful to have the 16 ton weight ready in case the delivery guy attacks you).
  prefs: []
  type: TYPE_NORMAL
- en: If you look through the `Activity` documentation, you'll notice that while there's
    a `setContentView` method, there's no corresponding `getContentView` method. Take
    a closer look and you will notice the `addContentView` method. An `Activity` object
    may have any number of `View` objects attached to it as "content". This precludes
    any useful implementation of a `getContentView` method.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get around this limitation, we inflated the layout ourselves. The
    `getLayoutInflator()` method used is simply a shortcut for `LayoutInflator.from(this)`.
    Instead of using an ID and `findViewById`, we simply cast the `View` returned
    directly to a `GridView`, since that's all that our `four_buckets.xml` file contains
    (much the same way the `ArrayAdapter` class works with `TextView` objects). If
    we wanted to make things a little more abstract, we could have cast it to an `AdapterView<ListAdapter>`,
    in which case we could have swapped in implementation in the file with a `ListView`.
    However, this wouldn't have been very useful for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now re-install and run the application, your new `FourBucketsActivity`
    will present you with a screen similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero – Sam's Sushi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last restaurant on the menu is `Sam''s Sushi`. Try using the `Spinner`
    class along with a `GridView` to create a composite sushi menu. Place the spinner
    at the top of the screen, with options for different types of sushi:'
  prefs: []
  type: TYPE_NORMAL
- en: Sashimi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maki Roll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nigiri
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oshi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: California Roll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fashion Sandwich
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hand Roll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below the `Spinner`, use a `GridView` to display icons for each different type
    of fish that the user can order. Here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuna
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yellowtail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salmon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sea Urchin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shrimp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Spinner` class makes use of the `SpinnerAdapter` instead of a `ListAdapter`.
    The `SpinnerAdapter` includes an additional `View` object which represents the
    drop-down menu. This is most typically a reference to the `android.R.layout.simple_dropdown_item_1line`
    resource. However, for this example, however, you can probably make use of the
    `android:entries` attribute on the `Spinner` XML element.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data display is one of the most common requirements of a mobile application,
    and Android has many different options available. The `ListView` is probably one
    of the most commonly used widgets in the standard Android suite, and styling it
    allows it to be used to display varying amounts of data, from one line menu items
    to multi-line to-do notes.
  prefs: []
  type: TYPE_NORMAL
- en: The `GridView` is effectively a tabular version of `ListView`, and is well suited
    for presenting the user with icon views. Icons have enormous advantages over text,
    since they can be recognized much more quickly by the user. Icons can also take
    up significantly less space, and in a `GridView`, you could easily fit four to
    six icons in a portrait screen without making the user interface cluttered or
    more difficult to work it. This also frees up precious screen space for other
    items to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom `Adapter` classes not only allows you to take complete control
    over the styling of the `ListView`, but also determine where the data comes from,
    and how it's loaded. You could, for example, load the data directly from a web
    service by using an `Adapter` which generates dummy `View` objects until the web
    service responds with actual data. Take a good look at the default `Adapter` implementations,
    they will generally serve your requirements, especially when coupled with a custom
    layout resource.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at some less generic, more specialized
    `View` classes that Android provides. As with almost everything in Android, the
    defaults may be specific, but they can be customized in any number of ways to
    fit some very unusual purposes.
  prefs: []
  type: TYPE_NORMAL
