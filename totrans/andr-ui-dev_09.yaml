- en: Chapter 9. Styling Android Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 样式化安卓应用
- en: '*Up to this point we''ve been working with the standard Android themes and
    styling. From a consistency point of view, this is a very good thing, since the
    application will blend properly with the device''s theming (if it has any). However,
    there are times when you need to be able to define your own styling. This styling
    may only apply to a single widget, or it may apply to the entire application.
    In any of these cases, you''ll need to know what tools you have available from
    Android in order to decide how best to approach the problem at hand.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们一直在使用标准的Android主题和样式。从一致性的角度来看，这是一个非常好的事情，因为应用将与设备的主题（如果有的话）很好地融合。然而，有时候你需要能够定义自己的样式。这种样式可能只适用于单个小部件，也可能适用于整个应用。在这些情况下，你需要了解Android为你提供了哪些工具，以便决定如何最佳地解决问题。*'
- en: There is more to styling than just making your application look good. Also,
    what you think would look good, another person may hate. It's also about making
    the application more useful to your users. This may involve making sure that your
    application looks right no matter which language the user chooses. It may involve
    additional colors for some chosen widgets, or it may simply involve implementing
    a landscape layout for some key screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 样式设计不仅仅是让应用看起来好看。另外，你认为好看的，别人可能不喜欢。这也是关于让应用对用户更有用的问题。这可能涉及到确保无论用户选择哪种语言，应用看起来都是正确的。可能涉及到为某些选定的小部件添加额外的颜色，或者简单地实现某些关键屏幕的横屏布局。
- en: In the previous chapter, we looked at the overall choices that can be made when
    designing certain screens of an application. The chapter also looked at the idea
    of using `WebView` as a container for content and widgets. One of the advantages
    of using a `WebView` is the fact that you then have CSS at your disposal. As any
    web developer will tell you, using CSS makes advanced styling very easy to do.
    However, Android has a collection of styling tools built in as well, with the
    ability to achieve many of the same effects as CSS and in some cases the ability
    to do much more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了在设计应用某些屏幕时可以做出的整体选择。该章节还介绍了使用`WebView`作为内容和窗口小部件容器的想法。使用`WebView`的一个优点是你可以使用CSS。正如任何Web开发者都会告诉你的，使用CSS可以使高级样式设计变得非常容易。然而，Android也内置了一系列样式工具，能够实现许多与CSS相同的效果，并且在某些情况下能做得更多。
- en: Making a single button on the screen appear to be different makes it stand out
    against all of the other widgets. This helps draw attention to the fact that it
    does something different than anything else on the screen; it does something special.
    You may also want a rendered line between two groups of widgets in order to inform
    the user that they have a logical separation. Much like trying to understand someone
    else's source code, getting to grips with a new application is getting to understand
    someone else's logic. Correctly styling your application can go a long way to
    helping the user understand what your thinking was when building the application,
    while also providing them with cues as to what they are expected to do. If you
    need to provide instructions on how the application should be used, you have failed
    in your effort to design and style the application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让屏幕上的单个按钮看起来与众不同，使其与其他所有小部件区分开来。这有助于引起注意，使其与屏幕上的其他任何东西不同，它有特殊的作用。你可能还希望在两组小部件之间绘制一条线，以告知用户它们之间存在逻辑上的分隔。就像尝试理解别人的源代码一样，掌握一个新应用就是理解别人的逻辑。正确地样式化你的应用可以大大帮助用户理解你在构建应用时的思路，同时为他们提供关于预期操作的提示。如果你需要提供如何使用应用的说明，那么你在设计和样式化应用方面的努力就失败了。
- en: 'In this chapter, we''ll be exploring how Android allows you to style the various
    widgets it provides, and therefore how to adopt your own styles and themes. We''ll
    also work through examples where custom styling can be used to make the application
    easier to use for the user. We''ll cover topics such as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Android如何允许你为其提供的小部件设置样式，以及如何采用你自己的样式和主题。我们还将通过示例来展示自定义样式如何使用户更容易使用应用。我们将涵盖如下主题：
- en: Defining styling resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义样式资源
- en: The different types of graphical resources that can be used for styling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于样式设计的不同类型的图形资源
- en: Creating and using nine-patch images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用九宫格图片
- en: Handling changes in the device configuration at runtime
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时处理设备配置的变化
- en: Defining styles that are portable across different devices and screens
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可跨不同设备和屏幕移植的样式
- en: Working with style resources
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式资源
- en: The first point of attack when dealing with Android styling is to understand
    how the style values work. An application has the ability to define any number
    of styles, much like the ability to define strings and string arrays as resources.
    The style resources are used to define a series of defaults for certain user interface
    elements, in much the same way as a CSS rule can define styling attributes. The
    main difference is that in Android, the styles can override any XML attribute
    defined for a given widget class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Android样式时的首要切入点是了解样式值是如何工作的。应用程序能够定义任意数量的样式，就像定义字符串和字符串数组资源一样。样式资源用于为某些用户界面元素定义一系列默认值，这与CSS规则定义样式属性的方式非常相似。主要区别在于，在Android中，样式可以覆盖为给定小部件类定义的任何XML属性。
- en: The following table gives a quick comparison of Android style resources and
    CSS stylesheets. They have many common features, but behave quite differently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下表快速比较了Android样式资源和CSS样式表。它们有许多共同特征，但行为却大相径庭。
- en: '| Android style resources | CSS stylesheets |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Android样式资源 | CSS样式表 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| May apply to any XML attribute | Have a purpose-defined set of attributes
    they can define or alter |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 可应用于任何XML属性 | 有一个目的明确的属性集，它们可以定义或更改 |'
- en: '| May inherit from a parent style | Cascade together in order of definition
    to form complex styles |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 可以从父样式继承 | 按定义顺序级联形成复杂样式 |'
- en: '| Must be explicitly applied to a `View`, `Activity`, or `Application` | Are
    matched to document elements by their selector |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 必须明确应用于`View`、`Activity`或`Application` | 通过选择器与文档元素匹配 |'
- en: '| Are defined as plain XML | Defined using specialized grammar |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 以普通XML定义 | 使用专用语法定义 |'
- en: Android styles cascade in a manner similar to the way CSS rules do. However,
    the definition of this cascading owes more to a Java class hierarchy. Each style
    may declare a parent style from which it will inherit parameters. Once inherited,
    these parameters may be selectively overridden by the new style. It's always a
    good idea to have a parent style, as the device manufacturer may have modified
    the defaults, allowing you to continue to fit-in with the first-party software
    installed on the users device while creating your own new styles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android样式的级联方式与CSS规则类似。然而，这种级联的定义更多地归功于Java类层次结构。每个样式都可以声明一个父样式，从中继承参数。一旦继承，这些参数可能会被新样式选择性地覆盖。拥有一个父样式总是一个好主意，因为设备制造商可能已经修改了默认值，这样你就可以在创建自己的新样式的同时，与用户设备上安装的第一方软件保持一致。
- en: A style declaration cannot simply override the styles of all the available `TextView`
    objects. Instead you must either import the style for a specified widget on the
    widget declaration, or reference the style in your manifest file as a theme, in
    order to apply either to a single `Activity` or to your entire application. For
    starters, we'll focus on simply building styles and applying them to single widgets.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 样式声明不能简单地覆盖所有可用的`TextView`对象的样式。相反，你必须要在小部件声明中为特定小部件导入样式，或者在清单文件中引用样式作为主题，以应用于单个`Activity`或整个应用程序。首先，我们将重点放在构建样式并将其应用于单个小部件上。
- en: 'Styles, like dimensions, strings and string-arrays, are value resources. When
    creating a styling element, you can place it in any XML file in the `res/values`
    directory (although it''s best to keep your resources separate and place the styles
    in a `styles.xml` file). Like all XML resources in the `values` directory, the
    root element is expected to be `<resources>`, after which you will list your `<style>`
    elements. The following is a simple style that can be used to style any `TextView`
    as a header:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 样式与尺寸、字符串和字符串数组一样，都是值资源。创建样式元素时，可以将其放在`res/values`目录下的任何XML文件中（尽管最好是将资源分开，并将样式放在`styles.xml`文件中）。与`values`目录中的所有XML资源一样，根元素应为`<resources>`，之后你会列出你的`<style>`元素。以下是一个简单的样式，可用于将任何`TextView`设置为标题：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The name attribute in the above `<style>` element is mandatory, while the parent
    attribute optionally determines which style to use for the default items (in this
    case, the default appearance of a `TextView` object). The following code snippet
    declares a `TextView` with the `TitleStyle` we declared above as its style:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the lack of the `android` namespace prefix in the preceding example.
    Applying a style effectively happens at compile time, when the resources are converted
    into binary data for packaging. When applying the additional attributes, any items
    declared on the `<style>` element that are not available on the widget the style
    is being applied to, are simply ignored. This, in theory, allows you to create
    more abstract styles and apply them to many different widgets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextView` along with the `TitleStyle` applied, will render as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with style resources](img/4484_09_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Who Overrides Whom?**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When applying a style to a widget, Activity, or application, it's important
    to know the order of overrides. Each style overrides the style information of
    its parent (if it has one), while each widget will override any style information
    from any styles applied to it. This means that while you can apply an `android:text`
    style item to a `TextView` object, it's generally not very useful since any `android:text`
    attribute on the `TextView` will override the value specified in the style.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Using shape resources
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's all very fine and well being able to change the size and color of the fonts
    in a widget, but what about fundamentally changing the way in which that widget
    is rendered? We've already worked a little bit with XML drawable objects, but
    there is much more that can be done with them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The work done so far with the XML drawable structures has been confined to putting
    default images in widgets designed to have an image. However, all widgets in Android
    are designed to have images. The `background` attribute of the `View` class allows
    you to pass in any `drawable` resource, combined with style resources. This becomes
    a very powerful tool. When a shape resource is loaded in Java code, it's returned
    as a `Drawable` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The shapes that are available to you are in the `android.graphics.drawable.shapes`
    package, other than the `Shape` class which is the abstract class from which the
    other classes in the package inherit. You reference these classes through XML
    files in the `res/drawable` directory. However, unlike the layout XML resources,
    shapes are more limited:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: You don't have direct access to the class attributes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only create a single shape per shape file
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot paint arbitrary paths (that is diagonal lines or bezier curves)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all their limitations however, shapes are extremely useful and important
    because:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: They scale to the dimensions of the widget they are attached to
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes them perfectly suited for creating borders and/or background structures
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also differentiate between the outline and fill of the shape
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还区分了形状的外框和填充
- en: How shapes behave
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状的行为
- en: Each shape structure that you can define behaves slightly differently to each
    of the others, not just in the way it's rendered, but also in what attributes
    apply to it. Since shape resources are fairly limited in how complex they can
    become, they are also somewhat limited in their use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义的每个形状结构与其他形状略微不同，不仅在渲染方式上，而且在于哪些属性适用于它。由于形状资源的复杂性有限，它们的使用也相对有限。
- en: Rendering lines
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染线条
- en: The line shape in Android is always a straight horizontal line, vertically centered
    in the widget. Earlier we used the line shape as a placeholder image in the memory
    game. However, a much more common use of the line shape is as a vertical separator.
    The line shape is common when used with a `ListView`. A line shape doesn't allow
    for gradient fills, so it is always a solid color (defaulting to black). However,
    the line shape does allow for the full set of attributes in the `stroke` element
    to be used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，线条形状始终是居中于小部件内部的直线。之前我们在记忆游戏中将线条形状用作占位图像。然而，线条形状更常见的用法是作为垂直分隔符。线条形状在与`ListView`一起使用时很常见。线条形状不支持渐变填充，因此它总是实心颜色（默认为黑色）。但是，线条形状允许使用`stroke`元素中的所有属性。
- en: 'A simple white line can be defined in just a few lines, and will generally
    serve well as a separator in a `ListView` or similar structure. The following
    code snippet is such a line definition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的白色线条可以在几行代码中定义，通常可以用作`ListView`或类似结构中的分隔符。以下是一个线条定义的代码片段：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Time for action – drawing a broken line
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——绘制断线
- en: All of the shapes defined in Android allow you to use the `<stroke>` element
    to define a dotted or dashed line structure, but it's really best shown-off on
    the line element. If we increase the width of the line and define a dash pattern
    with dash segments double the size of the spacing, we get a line that looks much
    like a "cut" or "tear" line on a printed page. This is a great way to make harder
    separators on a user-interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Android中定义的所有形状都允许你使用`<stroke>`元素来定义点线或虚线结构，但它在线元素上表现得最为出色。如果我们增加线条宽度并定义一个与间隔大小两倍的虚线模式，我们得到的线条看起来就像打印页面上的一条“切割”或“撕裂”线。这是在用户界面上制作更硬分隔线的好方法。
- en: Create a new shape resource XML file in the `res/drawable` directory named `line.xml`
    and open this file in an editor or IDE.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/drawable`目录下创建一个新的形状资源XML文件，命名为`line.xml`，并在编辑器或IDE中打开这个文件。
- en: 'Declare the root element of the file as a `line shape`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的根元素声明为`line shape`：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Declare a stroke element for the new line with a `width` of `3sp`, a white
    color, a `dashGap` of `5sp`, and a `dashWidth` of `10sp`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的笔画元素，为新线条设置`width`为`3sp`，颜色为白色，`dashGap`为`5sp`，以及`dashWidth`为`10sp`：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Close the shape declaration:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束形状声明：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `shape` resource you just created will display a dashed line. The dashes
    in the line have a spacing of exactly half the length of the dashes themselves.
    The sizes are set relative to the user's preferred font size, so the dashes will
    grow and shrink according to the users preferences.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才创建的`shape`资源将显示一个虚线。线中的虚线间距正好是虚线长度的一半。大小是相对于用户首选字体大小设置的，因此虚线会根据用户偏好增大或缩小。
- en: 'The following is a screenshot of this line running with the default emulator
    settings:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此线条在默认模拟器设置下运行的屏幕截图：
- en: '![What just happened?](img/4484_09_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_09_05.jpg)'
- en: Rendering rectangles
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染矩形
- en: Rectangles are the most commonly used shape resource since `View` objects take
    up a rectangular space on the screen (even if they don't use every pixel of that
    space). The rectangle shape includes the ability to have rounded corners, where
    each corner may optionally have a different radius.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形是使用最广泛的形状资源，因为`View`对象在屏幕上占据一个矩形空间（即使它们没有使用该空间的所有像素）。矩形形状包括拥有圆角的能力，每个角可以选择性地有不同的半径。
- en: 'With no additional style information, a basic rectangle declaration will render
    a filled black box with no visible outline. However, rectangles are better suited
    to creating outlines which can be used to either draw attention to a single widget,
    or isolate a group of widgets from all of the others on the screen. A simple white
    rectangle border can be built copying the following code-snippet into a file named
    `res/drawable/border.xml`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有额外的样式信息，基本的矩形声明将渲染一个没有可见轮廓的填充黑色方块。然而，矩形更适合创建轮廓，可以用来单独吸引一个小部件的注意，或将一组小部件从屏幕上的其他所有小部件中隔离开来。一个简单的白色矩形边框可以通过将以下代码片段复制到名为`res/drawable/border.xml`的文件中构建：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The padding element in this shape will cause any `View` object it's used in
    to increase the size of it's padding by `8dip`. This will stop the contents of
    the widget from intersecting the border rendered by the shape resource.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个形状中的填充元素将导致任何使用它的`View`对象将其填充大小增加`8dip`。这将阻止小部件的内容与形状资源渲染的边框相交。
- en: Time for action – creating a rounded border
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建圆角边框
- en: A rectangular shape may also have its corners curved in order to make a rounded
    rectangle. A rounded rectangle is useful for styling buttons, or creating cleaner
    looking borders.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形形状也可能对其角进行圆滑处理，以形成一个圆角矩形。圆角矩形对于设置按钮样式或创建更干净的边框非常有用。
- en: Create a new shape resource XML file in the `res/drawable` directory named `rounded_border.xml`
    and open this file in an editor or IDE.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/drawable`目录中创建一个名为`rounded_border.xml`的新形状资源XML文件，并在编辑器或IDE中打开此文件。
- en: 'Declare the root element of the file as a `rectangle shape`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的根元素声明为`矩形形状`：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Set the rectangle stroke to `2dip` wide and white in color:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩形描边设置为`2dip`宽，颜色为白色：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Pad the rectangle with `8dip` of empty space:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`8dip`的空白空间填充矩形：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Curve the corners by `4dip`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角落曲线半径设置为`4dip`：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Close the shape declaration:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭形状声明：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*What just happened?*'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'To apply the rounded border you just created to a `View` object, you have several
    different options available to you, the most simple of which is to apply it directly
    as a background. For this, you would reference the shape as though it were any
    other image file in the drawable directory. Earlier, we declared a `TitleStyle`
    and applied it to a `TextView` with the word `Header` as its content. If you applied
    the new `rounded_border` to this `TextView`, the `TextView` declaration in the
    layout resource would look something more like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你刚刚创建的圆角边框应用于`View`对象，你有几种不同的选项，最简单的是直接作为背景应用。为此，你可以像引用drawable目录中的任何其他图像文件一样引用该形状。之前，我们声明了一个`TitleStyle`并将其应用于包含单词`Header`的`TextView`。如果你将新的`rounded_border`应用于这个`TextView`，布局资源中的`TextView`声明可能看起来更像这样：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you could apply this border to the `TitleStyle`, which would
    then apply the new border to every widget assigned the `TitleStyle`, which is
    rather fitting for headers and title widgets:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以将此边框应用于`TitleStyle`，这样就会将新边框应用于分配了`TitleStyle`的每个小部件，这对于标题和标题小部件来说非常合适：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Either of these will result in the exact same rendering of the new widget. The
    implementation decision is really a matter of what you are trying to achieve.
    Styles are the best way to keep commonality between different widgets that are
    used for the same purpose.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会导致新小部件的渲染完全相同。实现的决定实际上取决于你试图达到的目标。样式是保持用于相同目的的不同小部件之间共性的最佳方式。
- en: 'Using the above style on a `TextView` will result in a nice header widget that
    looks as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TextView`上使用上述样式将得到一个看起来很不错的标题小部件，如下所示：
- en: '![What just happened?](img/4484_09_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/4484_09_02.jpg)'
- en: Rendering ovals
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染椭圆
- en: The oval shape is exactly what the name implies—an ellipse. An oval is more
    limited in its use than a rectangle, unless the widget drawing on top of it is
    best bordered by a circle or ellipse, such as an analogue clock. That said, an
    oval, or rather a circle is a very useful shape to use as an image in your user-interfaces.
    A perfect example is a symbol to inform the user whether they are connected to
    the Internet or not, or whether a widget is valid or not. Using an oval shape
    for such a purpose is exactly the same as using a bitmap. However, the oval can
    be scaled according the users' preferences without any loss of quality, while
    you would need several differently-sized bitmap images to achieve a similar effect
    (even then, some of the bitmaps would require scaling).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted an oval shape to represent an invalid widget (for example, to
    show that two password entries don''t match when the user is selecting a password),
    then it would be best to color the oval in red. In the following code-snippet,
    we declare an oval shape as XML with a grey border and a red fill:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding case, we use the `<solid>` element to fill the oval with a
    plain red color, while using the `<stroke>` element to surround it with a thin
    grey outline. Also, notice the lack of sizing on the `shape` elements. As previously
    stated, their dimensions are inherited from the width they are placed in, either
    as a background, or in the case of an `ImageView`, as the content of the widget.
    If you want to place this oval shape into an `ImageView`, you would specify it
    in the `src` attribute, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code is about the right size for a validation icon to sit next
    to a widget, while scaling the icon up or down is as easy as changing the width
    and height of the `ImageView`. If you use `wrap_content` as the size of the `ImageView`,
    it will be sized as zero-by-zero pixels, and will effectively vanish off the screen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a screenshot of four different sizes of the same oval, each scaled
    to double the size of the previous (starting off with the 8x8 dip on the left):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering ovals](img/4484_09_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Time for action – applying a gradient to an oval shape
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous screenshot shows that while the oval looks okay, it's not going
    to be very visually appealing when surrounded by the gradient painted widgets
    which make up the default Android toolkit. In order to get the little oval to
    fit in nicely, it needs to look more like a ball, which requires a simple radial
    gradient to be applied.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shape resource XML file in the `res`/`drawable` directory named
    `ball.xml` and open this file in an editor or IDE.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of the file as an `oval`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of declaring a `solid` color as the fill, declare a `gradient` fill
    starting with a light grey and ending in red:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the thin light grey outline of the oval in a `stroke` element:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Close the shape declaration:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*What just happened?*'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, the affected radius of a radial gradient doesn't scale with the
    rest of the image, leaving a very small gradient area when you scale the image
    to large sizes. The effect in this case is that while the smallest version of
    the image looks great, the larger versions look terrible. At the time of writing
    this book, there is no direct way to work around this limitation. Instead, you
    will need to tie the size of your oval shape to the size of the `ImageView` if
    you want to use a radial gradient.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_09_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Rendering rings
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ring shape is also circular in its rendering, but serves a very different
    purpose to the oval shape. While the oval shape's content area is everything inside
    the outline space, a ring shape's content area is a circle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the logical difference between the two shapes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering rings](img/4484OS_09_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: The ring shape also how two outlines, one on the outside and another on the
    inside (as shown in the preceding diagram). Combine this with the ability to fill
    the ring's content area with a gradient and you have the perfect shape to use
    for progress spinners (the default Android indeterminate progress spinner it built
    with a ring).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – rendering a spinner ring
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a shape will assume that it's being used as part of a `LevelListDrawable`,
    and may not appear unless you disable this behavior. You do this by specifying
    the `useLevel` attribute as `false` on the shape element. If you don't disable
    this functionality, the ring will not render correctly, or at all.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shape resource XML file in the `res/drawable` directory named `spinner.xml`
    and open this file in an editor or IDE.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the root element of the file as a `ring shape`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `ring` shape requires its relative thickness to be set on the `shape` declaration:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finish the `shape` declaration by turning off the `useLevel` functionality:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Declare a `sweep` gradient centered in the oval:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Outline the `ring` with a thin white border:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'End the `shape` declaration:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened*'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sweep gradient is another form of radial gradient. Instead of extending
    out from the center of the image, it sweeps in a circle like the hands of a clock.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The image on the left-hand side is a rectangle filled with the `sweep` gradient;
    while the image on the right-hand side is the `ring` shape. As you can see, the
    two effects are quite different. The image on the right-hand side is based on
    the image used by Android 1.6 for the indeterminate spinner.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened](img/4484_09_07b.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Defining layers
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've only defined shapes as single-element images. It's possible to
    combine these shapes into more complex images. These images are combined together
    in layers, which is a commonly used graphics structure. In Android, this is done
    with a `layer-list` structure. A `layer-list` is not a type of shape, but it is
    a `Drawable` structure which means it can be used in place of a normal bitmap
    image.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Layered image resources are not confined to being used with vector `Drawable`
    structures such as the shapes we've already talked about. A layered `Drawable`
    object may also include some layers that are bitmap images, or any other `Drawable`
    type that can be defined.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: For each layer in a `layer-list`, you need to define an `<item>` element. The
    item element is used to declare optional meta-information such as an ID for the
    layer (which can be used to retrieve the `Drawable` object for that layer in your
    Java code). You can also declare location offsets or padding for the layer in
    the item element. While you can reference a layer as an external `Drawable` resource,
    you are also able to inline the `Drawable` object inside the `<item>` element,
    allowing you to compose various different `Drawable` structures in a single file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sizing your layers**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Only the first `<item>` of a `layer-list` will be sized according to the widget
    it's placed in. All other layers will be sized to their "natural" size. For a
    bitmap image, this is the size it is rendered in. For a `<shape>` element, the
    natural size is 0x0\. In order to specify a natural size for a `<shape>`, you'll
    need to give the `<shape>` a `<size>` child-element with an `android:width` and
    `android:height` attribute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted a two-layer image to act as a large green button, you would probably
    declare a layer for a grey rounded rectangle as a background, and another layer
    for a green oval to look something like a light, or ball on top of the grey background.
    Such a `layer-list` could look something similar to the following code-snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding snippet, there are only `shape` layers, but you could easily
    add in a bitmap layer by referencing the bitmap resource on the `<item>` element,
    as in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Stretching using nine-patch images
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you want a border that is more than a simple line, for
    example, if you want to add a shadow. On a web-page, you'll commonly find various
    HTML tricks used to insert eight or nine images into a box so that the content
    can be scaled while the border remains intact. In Android, this technique is called
    a "nine-patch" image because it consists of nine different parts. A nine-patch
    image in Android is handled specially when it's rendered at sizes larger than
    its original size. In order to identify these images as special, they have a `.9.png`
    extension (and must be valid `PNG` files).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: A nine-patch image combines a border and a background in a single image. The
    background area will grow when the content becomes too large for the image, and
    the border areas of the image will be scaled up so that no "holes" are left.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, you can start off by thinking about a nine-patch image as shown
    in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Stretching using nine-patch images](img/4484_09_09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: The arrows in the diagram indicate the conceptual "border" areas that will grow
    in size according to the size of the center "content" area. The corners of a nine-patch
    image will be entirely unaffected by any scaling that takes place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Creating nine-patch images
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a nine-patch image, you'll need a decent image editing application.
    I personally make use of the **Gimp** application (available for free at [http://www.gimp.org](http://www.gimp.org)),
    although you may prefer to use another application. Whatever application you use,
    it must be able to write out **Portable Network Graphics** (**PNG** ) files, and
    should also be able to zoom to fairly extreme levels. The entire data in a nine-patch
    image is actually encoded into the image file, meaning there is no need for an
    XML file to tell Android what parts of the image are border areas, and what parts
    must not be affected by scaling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Unlike CSS boxes that appear on web pages, the size manipulation done on a nine-patch
    image in Android is nearest-neighbor scaling. **Nearest-neighbor scaling** doesn't
    attempt to improve the quality of the scaled image in any way, the pixels simply
    become larger solid blocks of color. While this works excellently for gradient
    content backgrounds (provided they aren't forced to grow too large), it may cause
    your image to have some strange artifacts to it. Since currently there is no color
    interpolation performed during the scaling, some effects may look rather strange
    when they are scaled. Scaling also takes longer than simple image copying, so
    bear this in mind when sizing the image, it may need to get a lot larger than
    you think. However, this also means that nine-patch images are far more flexible
    than those you might know from the Web.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two images are scaled-up versions of the same 32x32 pixel nine-patch
    image:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating nine-patch images](img/4484_09_10b.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'The image on the left-hand side is the raw PNG file that can be used as a nine-patch
    image. The image on the right-hand side is the same image with a part of it highlighted
    to show which areas will be scaled. The top, bottom-left, and right areas will
    be scaled only horizontally or vertically, while the center area will be stretched
    to fit the size of the content. The following image is the same image being used
    as the background of a `TextView` object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating nine-patch images](img/4484_09_12.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: So, the black lines on the left-hand side and top of the image tell Android
    what parts of the image to scale, but what do the lines on the right and bottom
    signify? These two lines determine where to place the content of the widget, much
    like the `<padding>` element in a `<shape>` resource.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To get to grips with how your nine-patch image will be rendered and the possible
    ways it can be scaled, Android provides you with a utility in the `tools` directory
    of an Android SDK installation. The `draw9patch` utility renders your nine-patch
    scaled to various shapes and sizes, and allows you to effectively debug the image
    before using it in your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using bitmap images in Android
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are a major part of styling your application. They are used for icons,
    borders, backgrounds, logos, and many other purposes. Android does its best to
    make sure the images you use as resources render as well as possible across the
    different types of screens used on Android devices.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Android's automatic handling of images if far from perfect. However, there are
    times when you will need several different variations of the same image for your
    application to look right on all of the different devices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Handling different screen sizes
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with any bitmap image in Android, it's very important to consider
    that your application will be run on a variety of different screens, both different
    sizes and densities. When working on very large screens (such as those found on
    a laptop or tablet), you will want to use larger images than you use on an extremely
    small screen. While nine-patch images go a long way to keep things simple, they
    are still scaled with a nearest-neighbor algorithm, and this may start to show
    on a large screen with a larger font-size than you anticipated.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You can provide images of different sizes in your resources directory. For each
    screen size, you can provide a different `drawable` directory. The resource loading
    tools will automatically pick files from the directory that most closely matches
    the current device configuration. You don't need a copy of every resource in each
    of these directories, but only the ones you want to provide a more suitable alternative
    for. The resource loader will fall back on looser matching directories when it
    attempts to find a resource file to load.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Android recognizes five important parameters with regards to the size of a
    screen. While you can specify parameters that relate to the exact number of pixels
    on the screen, this is not a good idea as you won''t easily be able to cater to
    all of the different screen sizes. Instead, it''s best to stick to the five parameters
    that Android provides:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`small`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`medium`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`large`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notlong`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three parameters are directly related to the size of the screen,
    while the last two are related to whether the screen is "traditional" (such as
    VGA) or has a "wide" (such as WVGA) format. These parameters can be mixed together
    in various combinations such as:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`/res/drawable-small/`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res/drawable-medium-long/`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res/drawable-large-notlong/`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding examples are all valid resource directories that can be used
    to override file in the normal `drawable` directory. You can''t combine parameters
    that contradict each other, such as:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`/res/drawable-small-large/`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res/drawable-long-notlong/`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding cases, you will receive an error from the resource packaging
    tool. Whenever you work with bitmap images, it's important to consider these size
    parameters, since some devices have screens very different from the one that the
    emulator shows by default.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Handling different screen densities
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Screen density** generally refers to the number of pixels packed into a given
    physical space (that is, dots-per-inch or DPI). It also has a relationship to
    the size of the pixels on the screen. While most Android devices have medium or
    high-density screens, a large number of cheaper devices make use of a relatively
    low-density screen.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does this affect nine-patch and bitmap images? The same reason it affects
    font rendering—the lower the density, the worse anti-aliasing and shadows look.
    The best way to explain this is with images. In the following images, the one
    on the left is a simple rounded-rectangle as it would appear on a high-density
    screen. The image on the right is similar to how the same image would render on
    a low-density screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling different screen densities](img/4484_09_13b.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Although both are the same source image rendered at the same physical size,
    a reduction in the number of pixels available makes the image look blocky on a
    low-density screen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two images are taken from the bottom-right corner, and enlarged
    to illustrate in better detail what happens:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling different screen densities](img/4484_09_15b.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Again, these images are configured to take up the same amount of physical space.
    If an image's size is specified in screen-pixels, it will take up much more physical
    space on a low-density screen. This is one of the reasons it's recommended that
    you size images in Android using the "density-independent-pixels" (`dp` or `dip`)
    unit instead of the normal pixels (`px`) unit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'As with screen sizes, Android provides a series of configuration parameters
    that can be used to provide different resources for different screen densities.
    The parameters available for selecting a screen-density can be mixed with those
    selecting based on the screen-size. The following is a list of parameters Android
    makes available for resources to be provided based on the screen-density of the
    current device:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`ldpi`: Low-density screens (~120dpi)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdpi`: Medium-density screens (~160dpi)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hdpi`: High-density screens (~260dpi)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodpi`: Special case'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final "special case" can be used when you have a nine-patch image, or a
    bitmap image, that you don't want scaled according to device density. Android,
    by default, will re-scale an image in an attempt to keep the image's physical
    size as close to the intended size as possible. An image in a `nodpi` directory
    will not be scaled automatically by Android, and will be rendered on a pixel-for-pixel
    basis.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个“特殊情况”可以在你有一个不希望根据设备密度缩放的九宫格图像或位图图像时使用。默认情况下，Android 会重新缩放图像，以尝试使图像的物理尺寸尽可能接近预期的尺寸。`nodpi`
    目录中的图像不会被 Android 自动缩放，而是按像素对像素进行渲染。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Different density icons**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同密度的图标**'
- en: There are times when a large high-resolution icon does not scale down very well.
    In these cases, it's often a good idea to design entirely different icons for
    low-density screens.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时大尺寸的高分辨率图标并不能很好地缩小。在这些情况下，为低密度屏幕设计完全不同的图标通常是一个好主意。
- en: Handling configuration changes
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理配置变更
- en: When you provide Android with different resource directories relating to various
    possible hardware configurations, the resource loader will attempt to match the
    best resource files for the device that your application is running on. However,
    not all of the configuration parameters relate directly to the hardware, but instead
    describe the device state or some software configuration parameter. Examples of
    these types of parameters are the device language, network IDs, and device orientation.
    These parameters may change while your application is running. The most common
    example being the device orientation. Android has a built-in mechanism to handle
    such changes for you, and for the most part you won't need any special Java code
    to handle these changes. However, it is strongly desirable to at least provide
    resource files for some of these parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为 Android 提供与各种可能的硬件配置相关的不同资源目录时，资源加载器将尝试为运行你应用程序的设备匹配最佳的资源文件。然而，并非所有的配置参数都直接与硬件相关，而是描述设备状态或某些软件配置参数。这些参数的例子包括设备语言、网络
    ID 和设备方向。这些参数可能会在应用程序运行时发生变化。最常见的例子就是设备方向。Android 有一个内置机制来为你处理这些变化，在大多数情况下，你不需要任何特殊的
    Java 代码来处理这些变化。然而，至少为其中一些参数提供资源文件是非常可取的。
- en: When a configuration parameter changes, Android will store any of your `Activity`
    state in a `Bundle` object, and then shut down the `Activity`. It will then start
    up a new instance of the `Activity` object with the new configuration parameters,
    and restore the state from the `Bundle` object. All of the default Android widgets
    will store their current state before your `Activity` is shut down by the system.
    This means you don't generally need to perform any special handling for the configuration
    changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置参数发生变化时，Android 会将你的 `Activity` 状态存储在一个 `Bundle` 对象中，然后关闭 `Activity`。之后，系统会以新的配置参数启动
    `Activity` 的新实例，并从 `Bundle` 对象中恢复状态。所有默认的 Android 控件都会在系统关闭你的 `Activity` 之前存储它们当前的状态。这意味着通常你不需要为配置变更执行任何特殊处理。
- en: Providing landscape layouts
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供横屏布局
- en: 'So far through the book, we''ve only built portrait layouts. Unlike a desktop
    or web system, a mobile application''s orientation by default is portrait (hence
    the configuration parameters `long` and `notlong` as opposed to `wide` and `narrow`).
    One of the great things about having the Android platform is that an accelerometer
    is a required piece of hardware, which means that your application can respond
    to the orientation of the device. Thanks to Android''s configuration handling
    (as mentioned previously), you, as a developer, don''t need to do anything except
    provide alternative landscape layout resources, assuming you don''t build major
    parts of your user interface in Java. In order to provide layouts which are specific
    to either a portrait or a landscape orientation, you place the specific versions
    of your layout''s XML resources in directories configured with the following resource
    configuration parameters:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这本书中只构建了竖屏布局。与桌面或网页系统不同，移动应用程序的默认方向是竖屏（因此配置参数是 `long` 和 `notlong` 而不是
    `wide` 和 `narrow`）。拥有 Android 平台的好处之一是它必须包含加速度计这一硬件，这意味着你的应用程序可以响应设备的方向。得益于 Android
    的配置处理（如前所述），作为开发者的你除了提供替代的横屏布局资源外，不需要做任何事情，假设你没有在 Java 中构建用户界面的大部分内容。为了提供特定于竖屏或横屏方向的布局，你可以将布局的特定版本的
    XML 资源放置在以下配置参数配置的目录中：
- en: '`port`: Portrait-specific layouts'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：针对竖屏的布局'
- en: '`land`: Landscape-specific layouts'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`land`：特定于横向的布局'
- en: When the screen is longer vertically than horizontally (that is, portrait orientation),
    using a simple vertically-oriented `LinearLayout` to layout an input form makes
    quite a lot of sense. Any input widgets you make use of will be positioned below
    their labels and so have more horizontal space to display their data. The additional
    horizontal space allows for labels to include more information as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕竖向比横向长（即肖像模式）时，使用一个简单的垂直方向的`LinearLayout`来布局一个输入表单是非常有意义的。你所使用的任何输入控件都会被放置在它们标签的下方，因此它们有更多的水平空间来显示数据。额外的水平空间使得标签可以包含更多信息。
- en: 'The following diagram illustrates the difference between these two layout concepts:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这两种布局概念之间的区别：
- en: '![Providing landscape layouts](img/4484OS_09_17.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![提供横向布局](img/4484OS_09_17.jpg)'
- en: The layout method used on the right is very common in a web or desktop system,
    and will work well on a mobile device if the size of the labels and input widgets
    are small enough.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧使用的布局方法在网页或桌面系统中非常常见，如果标签和输入控件的大小足够小，在移动设备上也会工作得很好。
- en: When switching to a landscape orientation, the dramatic increase in horizontal
    space coupled with the massive loss in vertical space makes the vertical `LinearLayout`
    a terrible choice. If you are working with a simple input form, then a landscape
    layout should use `TableLayout` or `RelativeLayout` to position the labels on
    the same lines as the input widgets they relate to.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当切换到横向模式时，水平空间的显著增加和垂直空间的巨大损失使得垂直`LinearLayout`成为一个糟糕的选择。如果你正在处理一个简单的输入表单，那么横向布局应该使用`TableLayout`或`RelativeLayout`来将标签放置在与它们相关的输入控件同一行上。
- en: Providing text input on a landscape layout
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在横向布局上提供文本输入
- en: 'When building your landscape layouts, you need to carefully consider what parts
    of the user interface are most important. If your screen is being used to compose
    an e-mail or a document, your landscape layout could be almost identical to the
    portrait layout. However, such a layout has a mostly hidden enemy: the software
    keyboard. On a portrait layout, the software keyboard will confine itself to the
    bottom of the screen and consume a relatively small amount of space (about a quarter
    to one-third of the available screen space). On a landscape layout however, the
    software keyboard can consume as much as half of your vertical screen space, making
    it very hard to build content-centric landscape layouts. If your layout is strongly
    input-driven, it may make sense to either remove parts of your user-interface
    when the orientation is landscape, re-working your user interface so that the
    software keyboard won''t get in the way.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的横向布局时，你需要仔细考虑用户界面的哪些部分最重要。如果屏幕被用来编写电子邮件或文档，你的横向布局可能与纵向布局几乎相同。然而，这样的布局有一个几乎隐藏的敌人：软件键盘。在纵向布局中，软件键盘会限制在屏幕底部，并占用相对较小的空间（大约四分之一到三分之一的可用屏幕空间）。然而，在横向布局中，软件键盘可能会占用你一半的垂直屏幕空间，使得构建以内容为中心的横向布局变得非常困难。如果你的布局是强烈以输入驱动的，那么在横屏模式下移除用户界面的一部分，或者重新设计用户界面，使得软件键盘不会妨碍，可能是合理的。
- en: 'Android does provide a series of configuration parameters which will tell you
    about the keyboard on the device on which your application is running. It''s a
    good idea to take all of the possibilities into account when building your application.
    The following is a short list of the possible keyboard situations that your application
    may be faced with:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了一系列的配置参数，可以告诉您关于运行您应用程序设备上的键盘信息。在构建应用程序时考虑所有可能性是一个好主意。以下是应用程序可能面临的一些可能的键盘情况简短列表：
- en: Software Keyboard only
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有软件键盘
- en: Hardware Keyboard
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件键盘
- en: Hardware Keyboard available; Software Keyboard in use
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件键盘可用；软件键盘在使用中
- en: 'On top of these possibilities, devices with smaller screens will often make
    use of a 12-key keyboard instead of a full QWERTY keyboard. If this is a software
    keyboard (which it often is), the keyboard may take as much as 80 percent of your
    available screen space. This problem if often handled by Android opening a "text
    input" screen when a text-input box is activated by the user. You can determine
    the different states of keyboard availability, and the type of keyboard used,
    with the following configuration parameters:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些可能性，屏幕较小的设备通常会使用12键键盘而不是全QWERTY键盘。如果这是软件键盘（通常是这种情况），键盘可能占用高达80%的屏幕空间。当用户激活文本输入框时，Android通常会通过打开“文本输入”屏幕来处理这个问题。你可以通过以下配置参数确定键盘的可使用状态和使用的键盘类型：
- en: '`nokeys`: Software keyboard only'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nokeys`：仅限软件键盘'
- en: '`qwerty`: A full hardware keyboard is available'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qwerty`：可以使用完整的硬件键盘'
- en: '`12key`: A 12-key hardware phone-keyboard is available'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`12key`：可以使用12键硬件手机键盘'
- en: '`keysexposed`: The user has a keyboard visible, whether it''s hardware or software'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keysexposed`：用户可以看到键盘，无论是硬件还是软件的'
- en: '`keyshidden`: There isn''t any keyboard currently visible'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyshidden`：当前没有任何键盘可见'
- en: '`keyssoft`: The user will use a software keyboard (though it may not be visible)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyssoft`：用户将使用软件键盘（尽管它可能不可见）'
- en: When designing your screens, consider that the software keyboard may take up
    to half of your vertical space. Ensure that content areas will scroll, while vital
    widgets will always remain visible on the screen. If a chat application is simply
    wrapped in `ScrollView`, the input `EditView` object may become invisible when
    the software keyboard is visible. It's important not just to consider how the
    screen will look, but how it will react to the changes that your users will throw
    at it. Finally, it's vital to test how your screen will look and behave with and
    without a software keyboard.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计屏幕时，请考虑软件键盘可能占用你一半的垂直空间。确保内容区域可以滚动，而重要的控件将始终在屏幕上可见。如果一个聊天应用程序简单地被包裹在`ScrollView`中，当软件键盘可见时，输入`EditView`对象可能会变得不可见。考虑屏幕的外观不仅仅是如何，还要考虑它将如何应对用户可能带来的变化。最后，测试屏幕在有无软件键盘的情况下看起来和表现如何是至关重要的。
- en: Altering screen content
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改屏幕内容
- en: One of the great advantages of the Android XML layout format is the decoupling
    it provides. Portrait and landscape layouts are often quite different from each
    other, and users may individually find a preferred orientation from which to use
    your application. A not-very-common, but useful trick when designing the new layouts,
    is the ability to add or remove "non-functional" elements from the two different
    layouts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Android XML布局格式的一大优势是它提供的解耦。竖屏和横屏布局通常彼此差异很大，用户可能会分别找到一个更喜欢的方向来使用你的应用程序。在设计新布局时，一个不太常见但有用的技巧是能够从两个不同的布局中添加或删除“非功能性”元素。
- en: In a simple example, you may want to abbreviate the text in labels for the portrait
    layout and include some icons as graphical hints, while for the landscape layout,
    you may want icons double the size and two-line labels, all on the same line as
    your input field.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的例子中，你可能想要在竖屏布局中缩写标签文本，并包含一些图标作为图形提示，而在横屏布局中，你可能希望图标大小加倍并使用两行标签，所有这些都位于输入字段同一行。
- en: 'The following diagram illustrates this concept:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下图阐述了这一概念：
- en: '![Altering screen content](img/4484OS_09_18.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![更改屏幕内容](img/4484OS_09_18.jpg)'
- en: On the landscape layout in the preceding diagram, you could make use of an additional
    `TextView` element for the sub-text on the label. Assuming your Java code doesn't
    look for the additional `TextView` object, your application will run perfectly.
    The ability to alter the actual structure of the user interface, and not just
    its layout, is a very important consideration when designing alternative layouts
    for an `Activity`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图表的横屏布局中，你可以使用额外的`TextView`元素来显示标签的子文本。假设你的Java代码没有寻找额外的`TextView`对象，你的应用程序将完美运行。在设计`Activity`的替代布局时，能够更改用户界面的实际结构而不仅仅是布局，这是一个非常重要的考虑因素。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The look and feel of an application is vital. A single change to color or font
    can make or break a screen's usability. At the same time, over-styling an application
    can make it feel out-of-place on the user's device. An alien look and feel will
    drive users away from the application towards those that look and feel more familiar
    and comfortable to them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的外观和感觉至关重要。对颜色或字体的一次更改就可能会影响屏幕的可用性。同时，过度设计应用程序可能会让它在使用者的设备上显得不协调。一个陌生的外观和感觉会将用户从该应用程序推向那些看起来和感觉更熟悉和舒适的应用程序。
- en: Android provides an extremely powerful set of capabilities with the style resource
    structure. When combined with the ability to place your graphics in resource files
    and override the defaults, you can effectively re-style any widget. Using styles
    also helps with the maintenance of your application as you will only need to change
    styling in the style resources and not on each widget declaration of a particular
    style.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用样式资源结构提供了一系列极其强大的功能。结合将你的图形放置在资源文件中并覆盖默认值的能力，你可以有效地重新设计任何小部件。使用样式也有助于维护你的应用程序，因为你只需要在样式资源中更改样式，而不是在每个特定样式的部件声明中进行更改。
- en: Keeping most of your widget graphics as `<shape>` resources will ensure the
    most consistent look and feel possible for your application. However, this is
    not always practical. When you need to provide bitmap resources, it's vital to
    provide different images for the various screen sizes and densities the user may
    be working with.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的大部分小部件图形作为 `<shape>` 资源，将确保你的应用程序具有尽可能一致的外观和感觉。然而，这并不总是实用的。当你需要提供位图资源时，为用户可能使用的各种屏幕尺寸和密度提供不同的图像至关重要。
- en: Styling an application also includes the layout and the ability for the application
    to adapt to the device it's running on. Having a great idea is only half of an
    application's appeal, its styling and execution are critical to its survival in
    the "wild". Attention to detail is a powerful tool that will draw users to your
    application. Applications that "just work" are always favored over those that
    require time and effort to work with.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的风格设计还包括布局以及应用程序适应其运行设备的能力。拥有一个伟大的想法仅是应用程序吸引力的的一半，其风格和执行对它在“野外”的生存至关重要。关注细节是一个强大的工具，将吸引用户使用你的应用程序。那些“即开即用”的应用程序总是比那些需要时间和精力才能使用的应用程序更受欢迎。
- en: Make use of the various screen-sizes and densities provided to you by the Android
    emulator to ensure that your application will look good on as many devices as
    possible. Don't forget that many devices don't have hardware keyboards and that
    the software keyboard can take as much as half of your screen space.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Android 模拟器提供的各种屏幕尺寸和密度，以确保你的应用程序能在尽可能多的设备上看起来良好。不要忘记，许多设备没有硬件键盘，而且软件键盘可能会占用你屏幕空间的一半。
- en: In the next chapter, we'll be extending this styling knowledge into the overall
    design and theming of an application. We'll be building a styled application with
    many of the provided layouts and will be performing fairly extensive styling.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这种样式知识扩展到应用程序的整体设计和主题。我们将构建一个具有许多提供布局的样式化应用程序，并进行相当广泛的样式设计。
