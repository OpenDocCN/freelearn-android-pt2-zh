- en: Chapter 9. Styling Android Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 样式化安卓应用
- en: '*Up to this point we''ve been working with the standard Android themes and
    styling. From a consistency point of view, this is a very good thing, since the
    application will blend properly with the device''s theming (if it has any). However,
    there are times when you need to be able to define your own styling. This styling
    may only apply to a single widget, or it may apply to the entire application.
    In any of these cases, you''ll need to know what tools you have available from
    Android in order to decide how best to approach the problem at hand.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们一直在使用标准的Android主题和样式。从一致性的角度来看，这是一个非常好的事情，因为应用将与设备的主题（如果有的话）很好地融合。然而，有时候你需要能够定义自己的样式。这种样式可能只适用于单个小部件，也可能适用于整个应用。在这些情况下，你需要了解Android为你提供了哪些工具，以便决定如何最佳地解决问题。*'
- en: There is more to styling than just making your application look good. Also,
    what you think would look good, another person may hate. It's also about making
    the application more useful to your users. This may involve making sure that your
    application looks right no matter which language the user chooses. It may involve
    additional colors for some chosen widgets, or it may simply involve implementing
    a landscape layout for some key screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 样式设计不仅仅是让应用看起来好看。另外，你认为好看的，别人可能不喜欢。这也是关于让应用对用户更有用的问题。这可能涉及到确保无论用户选择哪种语言，应用看起来都是正确的。可能涉及到为某些选定的小部件添加额外的颜色，或者简单地实现某些关键屏幕的横屏布局。
- en: In the previous chapter, we looked at the overall choices that can be made when
    designing certain screens of an application. The chapter also looked at the idea
    of using `WebView` as a container for content and widgets. One of the advantages
    of using a `WebView` is the fact that you then have CSS at your disposal. As any
    web developer will tell you, using CSS makes advanced styling very easy to do.
    However, Android has a collection of styling tools built in as well, with the
    ability to achieve many of the same effects as CSS and in some cases the ability
    to do much more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了在设计应用某些屏幕时可以做出的整体选择。该章节还介绍了使用`WebView`作为内容和窗口小部件容器的想法。使用`WebView`的一个优点是你可以使用CSS。正如任何Web开发者都会告诉你的，使用CSS可以使高级样式设计变得非常容易。然而，Android也内置了一系列样式工具，能够实现许多与CSS相同的效果，并且在某些情况下能做得更多。
- en: Making a single button on the screen appear to be different makes it stand out
    against all of the other widgets. This helps draw attention to the fact that it
    does something different than anything else on the screen; it does something special.
    You may also want a rendered line between two groups of widgets in order to inform
    the user that they have a logical separation. Much like trying to understand someone
    else's source code, getting to grips with a new application is getting to understand
    someone else's logic. Correctly styling your application can go a long way to
    helping the user understand what your thinking was when building the application,
    while also providing them with cues as to what they are expected to do. If you
    need to provide instructions on how the application should be used, you have failed
    in your effort to design and style the application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让屏幕上的单个按钮看起来与众不同，使其与其他所有小部件区分开来。这有助于引起注意，使其与屏幕上的其他任何东西不同，它有特殊的作用。你可能还希望在两组小部件之间绘制一条线，以告知用户它们之间存在逻辑上的分隔。就像尝试理解别人的源代码一样，掌握一个新应用就是理解别人的逻辑。正确地样式化你的应用可以大大帮助用户理解你在构建应用时的思路，同时为他们提供关于预期操作的提示。如果你需要提供如何使用应用的说明，那么你在设计和样式化应用方面的努力就失败了。
- en: 'In this chapter, we''ll be exploring how Android allows you to style the various
    widgets it provides, and therefore how to adopt your own styles and themes. We''ll
    also work through examples where custom styling can be used to make the application
    easier to use for the user. We''ll cover topics such as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Android如何允许你为其提供的小部件设置样式，以及如何采用你自己的样式和主题。我们还将通过示例来展示自定义样式如何使用户更容易使用应用。我们将涵盖如下主题：
- en: Defining styling resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义样式资源
- en: The different types of graphical resources that can be used for styling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于样式设计的不同类型的图形资源
- en: Creating and using nine-patch images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用九宫格图片
- en: Handling changes in the device configuration at runtime
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时处理设备配置的变化
- en: Defining styles that are portable across different devices and screens
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可跨不同设备和屏幕移植的样式
- en: Working with style resources
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式资源
- en: The first point of attack when dealing with Android styling is to understand
    how the style values work. An application has the ability to define any number
    of styles, much like the ability to define strings and string arrays as resources.
    The style resources are used to define a series of defaults for certain user interface
    elements, in much the same way as a CSS rule can define styling attributes. The
    main difference is that in Android, the styles can override any XML attribute
    defined for a given widget class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 处理Android样式时的首要切入点是了解样式值是如何工作的。应用程序能够定义任意数量的样式，就像定义字符串和字符串数组资源一样。样式资源用于为某些用户界面元素定义一系列默认值，这与CSS规则定义样式属性的方式非常相似。主要区别在于，在Android中，样式可以覆盖为给定小部件类定义的任何XML属性。
- en: The following table gives a quick comparison of Android style resources and
    CSS stylesheets. They have many common features, but behave quite differently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下表快速比较了Android样式资源和CSS样式表。它们有许多共同特征，但行为却大相径庭。
- en: '| Android style resources | CSS stylesheets |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Android样式资源 | CSS样式表 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| May apply to any XML attribute | Have a purpose-defined set of attributes
    they can define or alter |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 可应用于任何XML属性 | 有一个目的明确的属性集，它们可以定义或更改 |'
- en: '| May inherit from a parent style | Cascade together in order of definition
    to form complex styles |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 可以从父样式继承 | 按定义顺序级联形成复杂样式 |'
- en: '| Must be explicitly applied to a `View`, `Activity`, or `Application` | Are
    matched to document elements by their selector |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 必须明确应用于`View`、`Activity`或`Application` | 通过选择器与文档元素匹配 |'
- en: '| Are defined as plain XML | Defined using specialized grammar |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 以普通XML定义 | 使用专用语法定义 |'
- en: Android styles cascade in a manner similar to the way CSS rules do. However,
    the definition of this cascading owes more to a Java class hierarchy. Each style
    may declare a parent style from which it will inherit parameters. Once inherited,
    these parameters may be selectively overridden by the new style. It's always a
    good idea to have a parent style, as the device manufacturer may have modified
    the defaults, allowing you to continue to fit-in with the first-party software
    installed on the users device while creating your own new styles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android样式的级联方式与CSS规则类似。然而，这种级联的定义更多地归功于Java类层次结构。每个样式都可以声明一个父样式，从中继承参数。一旦继承，这些参数可能会被新样式选择性地覆盖。拥有一个父样式总是一个好主意，因为设备制造商可能已经修改了默认值，这样你就可以在创建自己的新样式的同时，与用户设备上安装的第一方软件保持一致。
- en: A style declaration cannot simply override the styles of all the available `TextView`
    objects. Instead you must either import the style for a specified widget on the
    widget declaration, or reference the style in your manifest file as a theme, in
    order to apply either to a single `Activity` or to your entire application. For
    starters, we'll focus on simply building styles and applying them to single widgets.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 样式声明不能简单地覆盖所有可用的`TextView`对象的样式。相反，你必须要在小部件声明中为特定小部件导入样式，或者在清单文件中引用样式作为主题，以应用于单个`Activity`或整个应用程序。首先，我们将重点放在构建样式并将其应用于单个小部件上。
- en: 'Styles, like dimensions, strings and string-arrays, are value resources. When
    creating a styling element, you can place it in any XML file in the `res/values`
    directory (although it''s best to keep your resources separate and place the styles
    in a `styles.xml` file). Like all XML resources in the `values` directory, the
    root element is expected to be `<resources>`, after which you will list your `<style>`
    elements. The following is a simple style that can be used to style any `TextView`
    as a header:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 样式与尺寸、字符串和字符串数组一样，都是值资源。创建样式元素时，可以将其放在`res/values`目录下的任何XML文件中（尽管最好是将资源分开，并将样式放在`styles.xml`文件中）。与`values`目录中的所有XML资源一样，根元素应为`<resources>`，之后你会列出你的`<style>`元素。以下是一个简单的样式，可用于将任何`TextView`设置为标题：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The name attribute in the above `<style>` element is mandatory, while the parent
    attribute optionally determines which style to use for the default items (in this
    case, the default appearance of a `TextView` object). The following code snippet
    declares a `TextView` with the `TitleStyle` we declared above as its style:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`<style>`元素中的`name`属性是必填项，而`parent`属性可选，它决定了使用哪个样式作为默认项（在这种情况下，是`TextView`对象的默认外观）。以下代码片段声明了一个使用我们上面声明的`TitleStyle`作为其样式的`TextView`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the lack of the `android` namespace prefix in the preceding example.
    Applying a style effectively happens at compile time, when the resources are converted
    into binary data for packaging. When applying the additional attributes, any items
    declared on the `<style>` element that are not available on the widget the style
    is being applied to, are simply ignored. This, in theory, allows you to create
    more abstract styles and apply them to many different widgets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前一个例子中缺少了`android`命名空间前缀。实际上，在编译时，当资源被转换成二进制数据以便打包时，应用样式是有效的。当应用额外的属性时，任何在`<style>`元素上声明但应用样式的部件上不可用的项都会被忽略。理论上，这允许你创建更抽象的样式，并将它们应用于许多不同的部件。
- en: 'The `TextView` along with the `TitleStyle` applied, will render as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用了`TitleStyle`的`TextView`将如下渲染：
- en: '![Working with style resources](img/4484_09_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![使用样式资源](img/4484_09_01.jpg)'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Who Overrides Whom?**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁覆盖了谁？**'
- en: When applying a style to a widget, Activity, or application, it's important
    to know the order of overrides. Each style overrides the style information of
    its parent (if it has one), while each widget will override any style information
    from any styles applied to it. This means that while you can apply an `android:text`
    style item to a `TextView` object, it's generally not very useful since any `android:text`
    attribute on the `TextView` will override the value specified in the style.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当对部件、活动或应用应用样式时，了解覆盖的顺序很重要。每个样式都会覆盖其父样式（如果有）的样式信息，同时每个部件将覆盖应用在它上面的任何样式信息。这意味着虽然你可以将`android:text`样式项应用于`TextView`对象，但这通常并不十分有用，因为`TextView`上的任何`android:text`属性都会覆盖样式中指定的值。
- en: Using shape resources
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用形状资源
- en: It's all very fine and well being able to change the size and color of the fonts
    in a widget, but what about fundamentally changing the way in which that widget
    is rendered? We've already worked a little bit with XML drawable objects, but
    there is much more that can be done with them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 能够改变部件中字体的大小和颜色当然很好，但如何从根本上改变该部件的渲染方式呢？我们已经使用过一些 XML 可绘制对象，但还可以用它们做更多的事情。
- en: The work done so far with the XML drawable structures has been confined to putting
    default images in widgets designed to have an image. However, all widgets in Android
    are designed to have images. The `background` attribute of the `View` class allows
    you to pass in any `drawable` resource, combined with style resources. This becomes
    a very powerful tool. When a shape resource is loaded in Java code, it's returned
    as a `Drawable` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，使用 XML 可绘制结构的工作仅限于为设计有图像的部件放置默认图片。然而，在 Android 中所有部件都被设计为可以拥有图像。`View`类的`background`属性允许你传入任何`drawable`资源，结合样式资源。这成为了一个非常强大的工具。当在
    Java 代码中加载形状资源时，它会被返回为一个`Drawable`对象。
- en: 'The shapes that are available to you are in the `android.graphics.drawable.shapes`
    package, other than the `Shape` class which is the abstract class from which the
    other classes in the package inherit. You reference these classes through XML
    files in the `res/drawable` directory. However, unlike the layout XML resources,
    shapes are more limited:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可供你使用的形状在`android.graphics.drawable.shapes`包中，除了`Shape`类，这是一个抽象类，该包中的其他类都继承自它。你通过在`res/drawable`目录中的
    XML 文件引用这些类。然而，与布局 XML 资源不同，形状的使用更为有限：
- en: You don't have direct access to the class attributes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能直接访问类的属性
- en: You can only create a single shape per shape file
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你每个形状文件只能创建一个单一形状
- en: You cannot paint arbitrary paths (that is diagonal lines or bezier curves)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能绘制任意的路径（即对角线或贝塞尔曲线）
- en: 'For all their limitations however, shapes are extremely useful and important
    because:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些限制，形状非常有用且重要，因为：
- en: They scale to the dimensions of the widget they are attached to
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会缩放到所附加部件的尺寸
- en: This makes them perfectly suited for creating borders and/or background structures
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得它们非常适合创建边框和/或背景结构
- en: They also differentiate between the outline and fill of the shape
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还区分了形状的外框和填充
- en: How shapes behave
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状的行为
- en: Each shape structure that you can define behaves slightly differently to each
    of the others, not just in the way it's rendered, but also in what attributes
    apply to it. Since shape resources are fairly limited in how complex they can
    become, they are also somewhat limited in their use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义的每个形状结构与其他形状略微不同，不仅在渲染方式上，而且在于哪些属性适用于它。由于形状资源的复杂性有限，它们的使用也相对有限。
- en: Rendering lines
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染线条
- en: The line shape in Android is always a straight horizontal line, vertically centered
    in the widget. Earlier we used the line shape as a placeholder image in the memory
    game. However, a much more common use of the line shape is as a vertical separator.
    The line shape is common when used with a `ListView`. A line shape doesn't allow
    for gradient fills, so it is always a solid color (defaulting to black). However,
    the line shape does allow for the full set of attributes in the `stroke` element
    to be used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，线条形状始终是居中于小部件内部的直线。之前我们在记忆游戏中将线条形状用作占位图像。然而，线条形状更常见的用法是作为垂直分隔符。线条形状在与`ListView`一起使用时很常见。线条形状不支持渐变填充，因此它总是实心颜色（默认为黑色）。但是，线条形状允许使用`stroke`元素中的所有属性。
- en: 'A simple white line can be defined in just a few lines, and will generally
    serve well as a separator in a `ListView` or similar structure. The following
    code snippet is such a line definition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的白色线条可以在几行代码中定义，通常可以用作`ListView`或类似结构中的分隔符。以下是一个线条定义的代码片段：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Time for action – drawing a broken line
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——绘制断线
- en: All of the shapes defined in Android allow you to use the `<stroke>` element
    to define a dotted or dashed line structure, but it's really best shown-off on
    the line element. If we increase the width of the line and define a dash pattern
    with dash segments double the size of the spacing, we get a line that looks much
    like a "cut" or "tear" line on a printed page. This is a great way to make harder
    separators on a user-interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Android中定义的所有形状都允许你使用`<stroke>`元素来定义点线或虚线结构，但它在线元素上表现得最为出色。如果我们增加线条宽度并定义一个与间隔大小两倍的虚线模式，我们得到的线条看起来就像打印页面上的一条“切割”或“撕裂”线。这是在用户界面上制作更硬分隔线的好方法。
- en: Create a new shape resource XML file in the `res/drawable` directory named `line.xml`
    and open this file in an editor or IDE.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/drawable`目录下创建一个新的形状资源XML文件，命名为`line.xml`，并在编辑器或IDE中打开这个文件。
- en: 'Declare the root element of the file as a `line shape`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的根元素声明为`line shape`：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Declare a stroke element for the new line with a `width` of `3sp`, a white
    color, a `dashGap` of `5sp`, and a `dashWidth` of `10sp`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的笔画元素，为新线条设置`width`为`3sp`，颜色为白色，`dashGap`为`5sp`，以及`dashWidth`为`10sp`：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Close the shape declaration:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束形状声明：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `shape` resource you just created will display a dashed line. The dashes
    in the line have a spacing of exactly half the length of the dashes themselves.
    The sizes are set relative to the user's preferred font size, so the dashes will
    grow and shrink according to the users preferences.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才创建的`shape`资源将显示一个虚线。线中的虚线间距正好是虚线长度的一半。大小是相对于用户首选字体大小设置的，因此虚线会根据用户偏好增大或缩小。
- en: 'The following is a screenshot of this line running with the default emulator
    settings:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此线条在默认模拟器设置下运行的屏幕截图：
- en: '![What just happened?](img/4484_09_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_09_05.jpg)'
- en: Rendering rectangles
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染矩形
- en: Rectangles are the most commonly used shape resource since `View` objects take
    up a rectangular space on the screen (even if they don't use every pixel of that
    space). The rectangle shape includes the ability to have rounded corners, where
    each corner may optionally have a different radius.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形是使用最广泛的形状资源，因为`View`对象在屏幕上占据一个矩形空间（即使它们没有使用该空间的所有像素）。矩形形状包括拥有圆角的能力，每个角可以选择性地有不同的半径。
- en: 'With no additional style information, a basic rectangle declaration will render
    a filled black box with no visible outline. However, rectangles are better suited
    to creating outlines which can be used to either draw attention to a single widget,
    or isolate a group of widgets from all of the others on the screen. A simple white
    rectangle border can be built copying the following code-snippet into a file named
    `res/drawable/border.xml`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有额外的样式信息，基本的矩形声明将渲染一个没有可见轮廓的填充黑色方块。然而，矩形更适合创建轮廓，可以用来单独吸引一个小部件的注意，或将一组小部件从屏幕上的其他所有小部件中隔离开来。一个简单的白色矩形边框可以通过将以下代码片段复制到名为`res/drawable/border.xml`的文件中构建：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The padding element in this shape will cause any `View` object it's used in
    to increase the size of it's padding by `8dip`. This will stop the contents of
    the widget from intersecting the border rendered by the shape resource.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个形状中的填充元素将导致任何使用它的`View`对象将其填充大小增加`8dip`。这将阻止小部件的内容与形状资源渲染的边框相交。
- en: Time for action – creating a rounded border
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建圆角边框
- en: A rectangular shape may also have its corners curved in order to make a rounded
    rectangle. A rounded rectangle is useful for styling buttons, or creating cleaner
    looking borders.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形形状也可能对其角进行圆滑处理，以形成一个圆角矩形。圆角矩形对于设置按钮样式或创建更干净的边框非常有用。
- en: Create a new shape resource XML file in the `res/drawable` directory named `rounded_border.xml`
    and open this file in an editor or IDE.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/drawable`目录中创建一个名为`rounded_border.xml`的新形状资源XML文件，并在编辑器或IDE中打开此文件。
- en: 'Declare the root element of the file as a `rectangle shape`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的根元素声明为`矩形形状`：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Set the rectangle stroke to `2dip` wide and white in color:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩形描边设置为`2dip`宽，颜色为白色：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Pad the rectangle with `8dip` of empty space:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`8dip`的空白空间填充矩形：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Curve the corners by `4dip`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角落曲线半径设置为`4dip`：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Close the shape declaration:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭形状声明：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*What just happened?*'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'To apply the rounded border you just created to a `View` object, you have several
    different options available to you, the most simple of which is to apply it directly
    as a background. For this, you would reference the shape as though it were any
    other image file in the drawable directory. Earlier, we declared a `TitleStyle`
    and applied it to a `TextView` with the word `Header` as its content. If you applied
    the new `rounded_border` to this `TextView`, the `TextView` declaration in the
    layout resource would look something more like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你刚刚创建的圆角边框应用于`View`对象，你有几种不同的选项，最简单的是直接作为背景应用。为此，你可以像引用drawable目录中的任何其他图像文件一样引用该形状。之前，我们声明了一个`TitleStyle`并将其应用于包含单词`Header`的`TextView`。如果你将新的`rounded_border`应用于这个`TextView`，布局资源中的`TextView`声明可能看起来更像这样：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you could apply this border to the `TitleStyle`, which would
    then apply the new border to every widget assigned the `TitleStyle`, which is
    rather fitting for headers and title widgets:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以将此边框应用于`TitleStyle`，这样就会将新边框应用于分配了`TitleStyle`的每个小部件，这对于标题和标题小部件来说非常合适：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Either of these will result in the exact same rendering of the new widget. The
    implementation decision is really a matter of what you are trying to achieve.
    Styles are the best way to keep commonality between different widgets that are
    used for the same purpose.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会导致新小部件的渲染完全相同。实现的决定实际上取决于你试图达到的目标。样式是保持用于相同目的的不同小部件之间共性的最佳方式。
- en: 'Using the above style on a `TextView` will result in a nice header widget that
    looks as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TextView`上使用上述样式将得到一个看起来很不错的标题小部件，如下所示：
- en: '![What just happened?](img/4484_09_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/4484_09_02.jpg)'
- en: Rendering ovals
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染椭圆
- en: The oval shape is exactly what the name implies—an ellipse. An oval is more
    limited in its use than a rectangle, unless the widget drawing on top of it is
    best bordered by a circle or ellipse, such as an analogue clock. That said, an
    oval, or rather a circle is a very useful shape to use as an image in your user-interfaces.
    A perfect example is a symbol to inform the user whether they are connected to
    the Internet or not, or whether a widget is valid or not. Using an oval shape
    for such a purpose is exactly the same as using a bitmap. However, the oval can
    be scaled according the users' preferences without any loss of quality, while
    you would need several differently-sized bitmap images to achieve a similar effect
    (even then, some of the bitmaps would require scaling).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆形正如其名所示——一个椭圆。椭圆形的使用比矩形更为受限，除非在其上绘制的组件最好由圆形或椭圆形边框，例如一个模拟时钟。也就是说，椭圆形，或者说圆形，在用户界面中作为图像使用非常有效。一个完美的例子就是通知用户他们是否连接到互联网，或者一个组件是否有效。出于这样的目的使用椭圆形与使用位图是相同的。然而，椭圆形可以根据用户的偏好进行缩放，而不会损失任何质量，而使用位图，你需要多个不同大小的位图图像来实现类似的效果（即便如此，一些位图可能还需要缩放）。
- en: 'If we wanted an oval shape to represent an invalid widget (for example, to
    show that two password entries don''t match when the user is selecting a password),
    then it would be best to color the oval in red. In the following code-snippet,
    we declare an oval shape as XML with a grey border and a red fill:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个椭圆形来表示一个无效的组件（例如，当用户在选择密码时显示两个密码输入不匹配），那么最好是将椭圆形涂成红色。在以下代码片段中，我们以XML格式声明了一个带有灰色边框和红色填充的椭圆形：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding case, we use the `<solid>` element to fill the oval with a
    plain red color, while using the `<stroke>` element to surround it with a thin
    grey outline. Also, notice the lack of sizing on the `shape` elements. As previously
    stated, their dimensions are inherited from the width they are placed in, either
    as a background, or in the case of an `ImageView`, as the content of the widget.
    If you want to place this oval shape into an `ImageView`, you would specify it
    in the `src` attribute, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `<solid>` 元素以纯红色填充椭圆形，同时使用 `<stroke>` 元素为其围绕一个细的灰色轮廓。还要注意 `shape`
    元素上没有尺寸设置。如之前所述，它们的尺寸是从它们被放置的宽度中继承的，可以作为背景，或者在 `ImageView` 的情况下，作为组件的内容。如果你想要将这个椭圆形放入
    `ImageView` 中，你会在 `src` 属性中指定它，如下所示：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code is about the right size for a validation icon to sit next
    to a widget, while scaling the icon up or down is as easy as changing the width
    and height of the `ImageView`. If you use `wrap_content` as the size of the `ImageView`,
    it will be sized as zero-by-zero pixels, and will effectively vanish off the screen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码对于作为一个组件旁边的验证图标来说大小正合适，而将图标放大或缩小就像改变 `ImageView` 的宽度和高度一样简单。如果你使用 `wrap_content`
    作为 `ImageView` 的大小，它将被设置为零像素乘零像素，实际上会从屏幕上消失。
- en: 'Following is a screenshot of four different sizes of the same oval, each scaled
    to double the size of the previous (starting off with the 8x8 dip on the left):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是同一个椭圆形四种不同大小的截图，每一个都是前一个的两倍大小（从左边的8x8 dip开始）：
- en: '![Rendering ovals](img/4484_09_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![渲染椭圆形](img/4484_09_03.jpg)'
- en: Time for action – applying a gradient to an oval shape
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——给椭圆形应用渐变
- en: The previous screenshot shows that while the oval looks okay, it's not going
    to be very visually appealing when surrounded by the gradient painted widgets
    which make up the default Android toolkit. In order to get the little oval to
    fit in nicely, it needs to look more like a ball, which requires a simple radial
    gradient to be applied.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示，虽然椭圆形看起来还可以，但当它被组成默认安卓工具包的渐变绘制组件包围时，它不会非常吸引人。为了让这个小椭圆形更好地融入，它需要看起来更像一个球，这需要应用一个简单的径向渐变。
- en: Create a new shape resource XML file in the `res`/`drawable` directory named
    `ball.xml` and open this file in an editor or IDE.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res`/`drawable` 目录中创建一个新的形状资源XML文件，命名为 `ball.xml`，并在编辑器或IDE中打开这个文件。
- en: 'Declare the root element of the file as an `oval`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的根元素声明为 `oval`：
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of declaring a `solid` color as the fill, declare a `gradient` fill
    starting with a light grey and ending in red:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其声明一个 `solid` 颜色作为填充，不如声明一个从浅灰色开始到红色结束的 `gradient` 填充：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the thin light grey outline of the oval in a `stroke` element:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stroke` 元素中定义椭圆形的细浅灰色轮廓：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Close the shape declaration:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束形状声明：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*What just happened?*'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Unfortunately, the affected radius of a radial gradient doesn't scale with the
    rest of the image, leaving a very small gradient area when you scale the image
    to large sizes. The effect in this case is that while the smallest version of
    the image looks great, the larger versions look terrible. At the time of writing
    this book, there is no direct way to work around this limitation. Instead, you
    will need to tie the size of your oval shape to the size of the `ImageView` if
    you want to use a radial gradient.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，径向渐变的受影响半径不会随图像的其他部分一起缩放，当你将图像放大到较大尺寸时，渐变区域会变得非常小。在这种情况下，效果就是最小的图像看起来很棒，而较大的版本看起来则很糟糕。在撰写本书时，还没有直接的方法来解决这个限制。相反，如果你想要使用径向渐变，需要将椭圆形的大小与`ImageView`的大小绑定起来。
- en: '![What just happened?](img/4484_09_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/4484_09_04.jpg)'
- en: Rendering rings
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染环
- en: The ring shape is also circular in its rendering, but serves a very different
    purpose to the oval shape. While the oval shape's content area is everything inside
    the outline space, a ring shape's content area is a circle.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ring`形状在渲染上也是圆形的，但它与椭圆形形状的目的非常不同。虽然椭圆形形状的内容区域是轮廓空间内的所有内容，但环形状的内容区域是一个圆圈。'
- en: 'The following diagram illustrates the logical difference between the two shapes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了两种形状之间的逻辑差异：
- en: '![Rendering rings](img/4484OS_09_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![渲染环](img/4484OS_09_06.jpg)'
- en: The ring shape also how two outlines, one on the outside and another on the
    inside (as shown in the preceding diagram). Combine this with the ability to fill
    the ring's content area with a gradient and you have the perfect shape to use
    for progress spinners (the default Android indeterminate progress spinner it built
    with a ring).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ring`形状也有两个轮廓，一个在外部，另一个在内部（如前图所示）。将这一点与填充环内容区域的能力结合起来，你就有了用于进度旋转器（默认的Android不确定进度旋转器就是用环构建的）的完美形状。'
- en: Time for action – rendering a spinner ring
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——渲染一个旋转环
- en: By default, a shape will assume that it's being used as part of a `LevelListDrawable`,
    and may not appear unless you disable this behavior. You do this by specifying
    the `useLevel` attribute as `false` on the shape element. If you don't disable
    this functionality, the ring will not render correctly, or at all.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，形状会假设它作为`LevelListDrawable`的一部分被使用，除非你禁用这个行为，否则可能不会出现。你通过在形状元素上指定`useLevel`属性为`false`来实现这一点。如果你不禁用这个功能，环可能无法正确渲染，或者根本不会渲染。
- en: Create a new shape resource XML file in the `res/drawable` directory named `spinner.xml`
    and open this file in an editor or IDE.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/drawable`目录中创建一个新的形状资源XML文件，命名为`spinner.xml`，并在编辑器或IDE中打开这个文件。
- en: 'Start the root element of the file as a `ring shape`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的根元素作为`ring shape`开始：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `ring` shape requires its relative thickness to be set on the `shape` declaration:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ring`形状需要在`shape`声明中设置其相对厚度：'
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finish the `shape` declaration by turning off the `useLevel` functionality:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过关闭`useLevel`功能来完成`shape`声明：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Declare a `sweep` gradient centered in the oval:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个在椭圆形中心居中的`sweep`渐变：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Outline the `ring` with a thin white border:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用细白边框勾勒出`ring`：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'End the `shape` declaration:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束`shape`声明：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened*'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: The sweep gradient is another form of radial gradient. Instead of extending
    out from the center of the image, it sweeps in a circle like the hands of a clock.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描渐变是径向渐变的另一种形式。它不是从图像中心向外扩展，而是像时钟的指针一样在圆圈中扫描。
- en: The image on the left-hand side is a rectangle filled with the `sweep` gradient;
    while the image on the right-hand side is the `ring` shape. As you can see, the
    two effects are quite different. The image on the right-hand side is based on
    the image used by Android 1.6 for the indeterminate spinner.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图像是一个用`sweep`渐变填充的矩形；而右侧的图像是`ring`形状。如你所见，这两个效果非常不同。右侧的图像基于Android 1.6用于不确定旋转指示器的图像。
- en: '![What just happened](img/4484_09_07b.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么](img/4484_09_07b.jpg)'
- en: Defining layers
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义图层
- en: So far, we've only defined shapes as single-element images. It's possible to
    combine these shapes into more complex images. These images are combined together
    in layers, which is a commonly used graphics structure. In Android, this is done
    with a `layer-list` structure. A `layer-list` is not a type of shape, but it is
    a `Drawable` structure which means it can be used in place of a normal bitmap
    image.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅将形状定义为单一元素的图像。可以将这些形状组合成更复杂的图像。这些图像以图层的形式组合在一起，这是一种常用的图形结构。在Android中，这是通过`layer-list`结构完成的。`layer-list`不是一种形状类型，但它是一个`Drawable`结构，这意味着它可以替代普通的位图图像。
- en: Layered image resources are not confined to being used with vector `Drawable`
    structures such as the shapes we've already talked about. A layered `Drawable`
    object may also include some layers that are bitmap images, or any other `Drawable`
    type that can be defined.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 分层图像资源不仅限于与我们前面讨论过的形状等矢量`Drawable`结构一起使用。分层的`Drawable`对象也可能包括一些位图图像图层，或任何其他可以定义的`Drawable`类型。
- en: For each layer in a `layer-list`, you need to define an `<item>` element. The
    item element is used to declare optional meta-information such as an ID for the
    layer (which can be used to retrieve the `Drawable` object for that layer in your
    Java code). You can also declare location offsets or padding for the layer in
    the item element. While you can reference a layer as an external `Drawable` resource,
    you are also able to inline the `Drawable` object inside the `<item>` element,
    allowing you to compose various different `Drawable` structures in a single file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`layer-list`中的每一层，你需要定义一个`<item>`元素。`item`元素用于声明可选的元信息，如图层的ID（这可以在你的Java代码中用于检索该图层的`Drawable`对象）。你还可以在`item`元素中声明图层的位置偏移或内边距。虽然你可以将图层作为外部的`Drawable`资源引用，但你也可以在`<item>`元素内内联`Drawable`对象，从而允许你在单个文件中组合各种不同的`Drawable`结构。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Sizing your layers**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整你的图层大小**'
- en: Only the first `<item>` of a `layer-list` will be sized according to the widget
    it's placed in. All other layers will be sized to their "natural" size. For a
    bitmap image, this is the size it is rendered in. For a `<shape>` element, the
    natural size is 0x0\. In order to specify a natural size for a `<shape>`, you'll
    need to give the `<shape>` a `<size>` child-element with an `android:width` and
    `android:height` attribute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`layer-list`中的第一个`<item>`将根据其所在的组件大小进行调整。所有其他图层将被调整为它们的“自然”大小。对于位图图像，这是它渲染的大小。对于`<shape>`元素，自然大小是0x0。为了指定`<shape>`的“自然”大小，你需要为`<shape>`提供一个带有`android:width`和`android:height`属性的`<size>`子元素。'
- en: 'If you wanted a two-layer image to act as a large green button, you would probably
    declare a layer for a grey rounded rectangle as a background, and another layer
    for a green oval to look something like a light, or ball on top of the grey background.
    Such a `layer-list` could look something similar to the following code-snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个双层图像充当一个大的绿色按钮，你可能会声明一个灰色圆角矩形的图层作为背景，再声明一个绿色椭圆形的图层，使其看起来像是在灰色背景上的一个光点或球体。这样的`layer-list`可能看起来类似于以下的代码片段：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding snippet, there are only `shape` layers, but you could easily
    add in a bitmap layer by referencing the bitmap resource on the `<item>` element,
    as in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，只有`shape`图层，但你可以轻松地通过在`<item>`元素中引用位图资源，来添加一个位图图层，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Stretching using nine-patch images
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用九宫格图像进行拉伸
- en: There are times when you want a border that is more than a simple line, for
    example, if you want to add a shadow. On a web-page, you'll commonly find various
    HTML tricks used to insert eight or nine images into a box so that the content
    can be scaled while the border remains intact. In Android, this technique is called
    a "nine-patch" image because it consists of nine different parts. A nine-patch
    image in Android is handled specially when it's rendered at sizes larger than
    its original size. In order to identify these images as special, they have a `.9.png`
    extension (and must be valid `PNG` files).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要一个比简单线条更复杂的边框，例如，如果你想添加阴影。在网页上，你通常会找到各种HTML技巧，将八张或九张图片插入一个盒子中，以便在保持边框完整的同时缩放内容。在Android中，这种技术称为“九宫格”图像，因为它由九个不同的部分组成。在Android中，当九宫格图像以大于其原始尺寸的大小渲染时，会特别处理。为了将这些图像标识为特殊的，它们有一个`.9.png`扩展名（必须是有效的`PNG`文件）。
- en: A nine-patch image combines a border and a background in a single image. The
    background area will grow when the content becomes too large for the image, and
    the border areas of the image will be scaled up so that no "holes" are left.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 九宫格图像将边框和背景结合在单一图像中。当内容变得过大而无法适应图像时，背景区域将会扩大，图像的边框区域也会被缩放，以避免留下“空洞”。
- en: 'Conceptually, you can start off by thinking about a nine-patch image as shown
    in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，你可以从以下图表所示的九宫格图像开始思考：
- en: '![Stretching using nine-patch images](img/4484_09_09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用九宫格图像进行拉伸](img/4484_09_09.jpg)'
- en: The arrows in the diagram indicate the conceptual "border" areas that will grow
    in size according to the size of the center "content" area. The corners of a nine-patch
    image will be entirely unaffected by any scaling that takes place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的箭头指出了根据中心“内容”区域大小而变大的概念性“边界”区域。九宫格图像的角落将完全不受任何缩放的影响。
- en: Creating nine-patch images
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建九宫格图像
- en: In order to create a nine-patch image, you'll need a decent image editing application.
    I personally make use of the **Gimp** application (available for free at [http://www.gimp.org](http://www.gimp.org)),
    although you may prefer to use another application. Whatever application you use,
    it must be able to write out **Portable Network Graphics** (**PNG** ) files, and
    should also be able to zoom to fairly extreme levels. The entire data in a nine-patch
    image is actually encoded into the image file, meaning there is no need for an
    XML file to tell Android what parts of the image are border areas, and what parts
    must not be affected by scaling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建九宫格图像，你需要一个像样的图像编辑应用程序。我个人使用**Gimp**应用程序（在[http://www.gimp.org](http://www.gimp.org)免费提供），尽管你可能更喜欢使用其他应用程序。无论你使用什么应用程序，它都必须能够输出**Portable
    Network Graphics** (**PNG**)文件，并且还应该能够放大到相当高的程度。九宫格图像中的所有数据实际上都编码在图像文件中，这意味着不需要XML文件来告诉Android图像的哪些部分是边框区域，哪些部分在缩放时不应受到影响。
- en: Unlike CSS boxes that appear on web pages, the size manipulation done on a nine-patch
    image in Android is nearest-neighbor scaling. **Nearest-neighbor scaling** doesn't
    attempt to improve the quality of the scaled image in any way, the pixels simply
    become larger solid blocks of color. While this works excellently for gradient
    content backgrounds (provided they aren't forced to grow too large), it may cause
    your image to have some strange artifacts to it. Since currently there is no color
    interpolation performed during the scaling, some effects may look rather strange
    when they are scaled. Scaling also takes longer than simple image copying, so
    bear this in mind when sizing the image, it may need to get a lot larger than
    you think. However, this also means that nine-patch images are far more flexible
    than those you might know from the Web.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与网页上出现的CSS盒子不同，Android中对九宫格图像的大小调整是通过最近邻缩放完成的。**最近邻缩放**并不试图以任何方式改善缩放图像的质量，像素只是变成了更大颜色块。这对于渐变内容背景来说效果很好（只要它们没有被强制变得过大），但它可能导致你的图像出现一些奇怪的艺术效果。由于当前在缩放过程中没有进行颜色插值，某些效果在缩放时可能看起来相当奇怪。缩放也比简单的图像复制耗时更长，因此在调整图像大小时请记住这一点，它可能需要比你想象的要大得多。然而，这也意味着九宫格图像比你在网上可能了解的图像要灵活得多。
- en: 'The following two images are scaled-up versions of the same 32x32 pixel nine-patch
    image:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两张图像是同一32x32像素九宫格图像的放大版本：
- en: '![Creating nine-patch images](img/4484_09_10b.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![创建九宫格图像](img/4484_09_10b.jpg)'
- en: 'The image on the left-hand side is the raw PNG file that can be used as a nine-patch
    image. The image on the right-hand side is the same image with a part of it highlighted
    to show which areas will be scaled. The top, bottom-left, and right areas will
    be scaled only horizontally or vertically, while the center area will be stretched
    to fit the size of the content. The following image is the same image being used
    as the background of a `TextView` object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图像是原始的PNG文件，可用作九宫格图像。右侧的图像是同一图像的一部分被突出显示，以展示哪些区域将被缩放。顶部、底部左侧和右侧的区域将仅水平或垂直缩放，而中心区域将被拉伸以适应内容的大小。以下图像是作为`TextView`对象的背景使用的同一图像：
- en: '![Creating nine-patch images](img/4484_09_12.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![创建九宫格图像](img/4484_09_12.jpg)'
- en: So, the black lines on the left-hand side and top of the image tell Android
    what parts of the image to scale, but what do the lines on the right and bottom
    signify? These two lines determine where to place the content of the widget, much
    like the `<padding>` element in a `<shape>` resource.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，图像左侧和顶部上的黑色线条告诉安卓系统要缩放图像的哪些部分，但右侧和底部的线条表示什么呢？这两条线决定了如何放置小部件内容的位置，类似于`<shape>`资源中的`<padding>`元素。
- en: To get to grips with how your nine-patch image will be rendered and the possible
    ways it can be scaled, Android provides you with a utility in the `tools` directory
    of an Android SDK installation. The `draw9patch` utility renders your nine-patch
    scaled to various shapes and sizes, and allows you to effectively debug the image
    before using it in your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解你的九宫格图像将如何渲染以及可能的缩放方式，安卓系统在Android SDK安装的`tools`目录中提供了一个实用工具。`draw9patch`工具将你的九宫格图像渲染成各种形状和大小，并允许你在将图像用于应用程序之前有效地调试图像。
- en: Using bitmap images in Android
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在安卓中使用位图图像
- en: Images are a major part of styling your application. They are used for icons,
    borders, backgrounds, logos, and many other purposes. Android does its best to
    make sure the images you use as resources render as well as possible across the
    different types of screens used on Android devices.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是塑造你的应用程序风格的重要组成部分。它们用于图标、边框、背景、标志等许多其他用途。安卓系统尽力确保你使用的资源图像能在安卓设备上的不同类型屏幕上尽可能好地渲染。
- en: Android's automatic handling of images if far from perfect. However, there are
    times when you will need several different variations of the same image for your
    application to look right on all of the different devices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统对图片的自动处理远非完美。然而，有时你需要为应用程序提供同一图像的多种不同变体，以使其在各种不同的设备上看起来都正确。
- en: Handling different screen sizes
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不同的屏幕尺寸
- en: When working with any bitmap image in Android, it's very important to consider
    that your application will be run on a variety of different screens, both different
    sizes and densities. When working on very large screens (such as those found on
    a laptop or tablet), you will want to use larger images than you use on an extremely
    small screen. While nine-patch images go a long way to keep things simple, they
    are still scaled with a nearest-neighbor algorithm, and this may start to show
    on a large screen with a larger font-size than you anticipated.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓中处理任何位图图像时，非常重要的一点是要考虑到你的应用程序将在各种不同大小和密度的屏幕上运行。在非常大的屏幕（如在笔记本电脑或平板电脑上找到的屏幕）上工作時，你需要使用比在非常小的屏幕上更大的图像。虽然九宫格图像在很大程度上简化了事情，但它们仍然使用最近邻算法进行缩放，这可能会在比你预期更大的屏幕和字体大小上开始显现。
- en: You can provide images of different sizes in your resources directory. For each
    screen size, you can provide a different `drawable` directory. The resource loading
    tools will automatically pick files from the directory that most closely matches
    the current device configuration. You don't need a copy of every resource in each
    of these directories, but only the ones you want to provide a more suitable alternative
    for. The resource loader will fall back on looser matching directories when it
    attempts to find a resource file to load.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在资源目录中提供不同大小的图片。对于每种屏幕尺寸，你可以提供不同的`drawable`目录。资源加载工具会自动从与当前设备配置最接近的目录中选择文件。你不需要在每个目录中都有一份每种资源的副本，只需提供那些你希望有更合适替代品的资源。当尝试查找要加载的资源文件时，资源加载器会在匹配度较低的目录中回退查找。
- en: 'Android recognizes five important parameters with regards to the size of a
    screen. While you can specify parameters that relate to the exact number of pixels
    on the screen, this is not a good idea as you won''t easily be able to cater to
    all of the different screen sizes. Instead, it''s best to stick to the five parameters
    that Android provides:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统识别出与屏幕尺寸相关的五个重要参数。虽然你可以指定与屏幕上确切像素数相关的参数，但这不是一个好主意，因为你无法轻易地适应所有不同的屏幕尺寸。相反，最好坚持使用安卓系统提供的五个参数：
- en: '`small`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`small`'
- en: '`medium`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`medium`'
- en: '`large`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`large`'
- en: '`long`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`notlong`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notlong`'
- en: 'The first three parameters are directly related to the size of the screen,
    while the last two are related to whether the screen is "traditional" (such as
    VGA) or has a "wide" (such as WVGA) format. These parameters can be mixed together
    in various combinations such as:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数直接与屏幕尺寸相关，而后两个参数与屏幕是否为“传统”（如VGA）格式或“宽屏”（如WVGA）格式有关。这些参数可以以各种组合方式混合，例如：
- en: '`/res/drawable-small/`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/res/drawable-small/`'
- en: '`/res/drawable-medium-long/`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/res/drawable-medium-long/`'
- en: '`/res/drawable-large-notlong/`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/res/drawable-large-notlong/`'
- en: 'The preceding examples are all valid resource directories that can be used
    to override file in the normal `drawable` directory. You can''t combine parameters
    that contradict each other, such as:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子都是有效的资源目录，可用于覆盖正常`drawable`目录中的文件。您不能组合相互矛盾的参数，例如：
- en: '`/res/drawable-small-large/`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/res/drawable-small-large/`'
- en: '`/res/drawable-long-notlong/`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/res/drawable-long-notlong/`'
- en: In the preceding cases, you will receive an error from the resource packaging
    tool. Whenever you work with bitmap images, it's important to consider these size
    parameters, since some devices have screens very different from the one that the
    emulator shows by default.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，您将收到资源打包工具的错误信息。每当您处理位图图像时，考虑到这些尺寸参数很重要，因为有些设备的屏幕与默认模拟器显示的屏幕有很大不同。
- en: Handling different screen densities
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不同的屏幕密度
- en: '**Screen density** generally refers to the number of pixels packed into a given
    physical space (that is, dots-per-inch or DPI). It also has a relationship to
    the size of the pixels on the screen. While most Android devices have medium or
    high-density screens, a large number of cheaper devices make use of a relatively
    low-density screen.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**屏幕密度**通常指的是在给定物理空间内填充的像素数量（即每英寸点数或DPI）。它还与屏幕上像素的大小有关。虽然大多数Android设备具有中等或高密度屏幕，但大量较便宜的设备使用相对低密度的屏幕。'
- en: 'Why does this affect nine-patch and bitmap images? The same reason it affects
    font rendering—the lower the density, the worse anti-aliasing and shadows look.
    The best way to explain this is with images. In the following images, the one
    on the left is a simple rounded-rectangle as it would appear on a high-density
    screen. The image on the right is similar to how the same image would render on
    a low-density screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么会影响到九宫格和位图图像呢？同样的原因也影响到了字体渲染——密度越低，抗锯齿和阴影效果看起来越差。解释这个现象最好的方式是用图像来说明。在以下图片中，左边的是在高密度屏幕上显示的简单圆角矩形。右边的图片类似于在低密度屏幕上渲染的同一图像：
- en: '![Handling different screen densities](img/4484_09_13b.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![处理不同的屏幕密度](img/4484_09_13b.jpg)'
- en: Although both are the same source image rendered at the same physical size,
    a reduction in the number of pixels available makes the image look blocky on a
    low-density screen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两张图片源自同一张图片，且以相同的物理尺寸渲染，但像素数量的减少使得在低密度屏幕上图像看起来变得块状。
- en: 'The following two images are taken from the bottom-right corner, and enlarged
    to illustrate in better detail what happens:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两张图片是从右下角截取的，并放大以更详细地说明发生的情况：
- en: '![Handling different screen densities](img/4484_09_15b.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![处理不同的屏幕密度](img/4484_09_15b.jpg)'
- en: Again, these images are configured to take up the same amount of physical space.
    If an image's size is specified in screen-pixels, it will take up much more physical
    space on a low-density screen. This is one of the reasons it's recommended that
    you size images in Android using the "density-independent-pixels" (`dp` or `dip`)
    unit instead of the normal pixels (`px`) unit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些图片被配置为占据相同的物理空间。如果图像的尺寸以屏幕像素指定，那么在低密度屏幕上它将占据更多的物理空间。这就是为什么推荐在Android中使用“密度独立像素”（`dp`或`dip`）单位而不是普通像素（`px`）单位来设置图像大小的一个原因。
- en: 'As with screen sizes, Android provides a series of configuration parameters
    that can be used to provide different resources for different screen densities.
    The parameters available for selecting a screen-density can be mixed with those
    selecting based on the screen-size. The following is a list of parameters Android
    makes available for resources to be provided based on the screen-density of the
    current device:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与屏幕尺寸一样，Android提供了一系列配置参数，可用于为不同屏幕密度的设备提供不同的资源。选择屏幕密度的参数可以与基于屏幕尺寸选择的参数混合使用。以下是Android提供的可用于根据当前设备的屏幕密度提供资源的参数列表：
- en: '`ldpi`: Low-density screens (~120dpi)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldpi`：低密度屏幕（约120dpi）'
- en: '`mdpi`: Medium-density screens (~160dpi)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdpi`：中等密度屏幕（约160dpi）'
- en: '`hdpi`: High-density screens (~260dpi)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hdpi`：高密度屏幕（约260dpi）'
- en: '`nodpi`: Special case'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodpi`：特殊情况'
- en: The final "special case" can be used when you have a nine-patch image, or a
    bitmap image, that you don't want scaled according to device density. Android,
    by default, will re-scale an image in an attempt to keep the image's physical
    size as close to the intended size as possible. An image in a `nodpi` directory
    will not be scaled automatically by Android, and will be rendered on a pixel-for-pixel
    basis.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个“特殊情况”可以在你有一个不希望根据设备密度缩放的九宫格图像或位图图像时使用。默认情况下，Android 会重新缩放图像，以尝试使图像的物理尺寸尽可能接近预期的尺寸。`nodpi`
    目录中的图像不会被 Android 自动缩放，而是按像素对像素进行渲染。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Different density icons**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同密度的图标**'
- en: There are times when a large high-resolution icon does not scale down very well.
    In these cases, it's often a good idea to design entirely different icons for
    low-density screens.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时大尺寸的高分辨率图标并不能很好地缩小。在这些情况下，为低密度屏幕设计完全不同的图标通常是一个好主意。
- en: Handling configuration changes
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理配置变更
- en: When you provide Android with different resource directories relating to various
    possible hardware configurations, the resource loader will attempt to match the
    best resource files for the device that your application is running on. However,
    not all of the configuration parameters relate directly to the hardware, but instead
    describe the device state or some software configuration parameter. Examples of
    these types of parameters are the device language, network IDs, and device orientation.
    These parameters may change while your application is running. The most common
    example being the device orientation. Android has a built-in mechanism to handle
    such changes for you, and for the most part you won't need any special Java code
    to handle these changes. However, it is strongly desirable to at least provide
    resource files for some of these parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为 Android 提供与各种可能的硬件配置相关的不同资源目录时，资源加载器将尝试为运行你应用程序的设备匹配最佳的资源文件。然而，并非所有的配置参数都直接与硬件相关，而是描述设备状态或某些软件配置参数。这些参数的例子包括设备语言、网络
    ID 和设备方向。这些参数可能会在应用程序运行时发生变化。最常见的例子就是设备方向。Android 有一个内置机制来为你处理这些变化，在大多数情况下，你不需要任何特殊的
    Java 代码来处理这些变化。然而，至少为其中一些参数提供资源文件是非常可取的。
- en: When a configuration parameter changes, Android will store any of your `Activity`
    state in a `Bundle` object, and then shut down the `Activity`. It will then start
    up a new instance of the `Activity` object with the new configuration parameters,
    and restore the state from the `Bundle` object. All of the default Android widgets
    will store their current state before your `Activity` is shut down by the system.
    This means you don't generally need to perform any special handling for the configuration
    changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置参数发生变化时，Android 会将你的 `Activity` 状态存储在一个 `Bundle` 对象中，然后关闭 `Activity`。之后，系统会以新的配置参数启动
    `Activity` 的新实例，并从 `Bundle` 对象中恢复状态。所有默认的 Android 控件都会在系统关闭你的 `Activity` 之前存储它们当前的状态。这意味着通常你不需要为配置变更执行任何特殊处理。
- en: Providing landscape layouts
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供横屏布局
- en: 'So far through the book, we''ve only built portrait layouts. Unlike a desktop
    or web system, a mobile application''s orientation by default is portrait (hence
    the configuration parameters `long` and `notlong` as opposed to `wide` and `narrow`).
    One of the great things about having the Android platform is that an accelerometer
    is a required piece of hardware, which means that your application can respond
    to the orientation of the device. Thanks to Android''s configuration handling
    (as mentioned previously), you, as a developer, don''t need to do anything except
    provide alternative landscape layout resources, assuming you don''t build major
    parts of your user interface in Java. In order to provide layouts which are specific
    to either a portrait or a landscape orientation, you place the specific versions
    of your layout''s XML resources in directories configured with the following resource
    configuration parameters:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这本书中只构建了竖屏布局。与桌面或网页系统不同，移动应用程序的默认方向是竖屏（因此配置参数是 `long` 和 `notlong` 而不是
    `wide` 和 `narrow`）。拥有 Android 平台的好处之一是它必须包含加速度计这一硬件，这意味着你的应用程序可以响应设备的方向。得益于 Android
    的配置处理（如前所述），作为开发者的你除了提供替代的横屏布局资源外，不需要做任何事情，假设你没有在 Java 中构建用户界面的大部分内容。为了提供特定于竖屏或横屏方向的布局，你可以将布局的特定版本的
    XML 资源放置在以下配置参数配置的目录中：
- en: '`port`: Portrait-specific layouts'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：针对竖屏的布局'
- en: '`land`: Landscape-specific layouts'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`land`：特定于横向的布局'
- en: When the screen is longer vertically than horizontally (that is, portrait orientation),
    using a simple vertically-oriented `LinearLayout` to layout an input form makes
    quite a lot of sense. Any input widgets you make use of will be positioned below
    their labels and so have more horizontal space to display their data. The additional
    horizontal space allows for labels to include more information as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕竖向比横向长（即肖像模式）时，使用一个简单的垂直方向的`LinearLayout`来布局一个输入表单是非常有意义的。你所使用的任何输入控件都会被放置在它们标签的下方，因此它们有更多的水平空间来显示数据。额外的水平空间使得标签可以包含更多信息。
- en: 'The following diagram illustrates the difference between these two layout concepts:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这两种布局概念之间的区别：
- en: '![Providing landscape layouts](img/4484OS_09_17.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![提供横向布局](img/4484OS_09_17.jpg)'
- en: The layout method used on the right is very common in a web or desktop system,
    and will work well on a mobile device if the size of the labels and input widgets
    are small enough.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧使用的布局方法在网页或桌面系统中非常常见，如果标签和输入控件的大小足够小，在移动设备上也会工作得很好。
- en: When switching to a landscape orientation, the dramatic increase in horizontal
    space coupled with the massive loss in vertical space makes the vertical `LinearLayout`
    a terrible choice. If you are working with a simple input form, then a landscape
    layout should use `TableLayout` or `RelativeLayout` to position the labels on
    the same lines as the input widgets they relate to.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当切换到横向模式时，水平空间的显著增加和垂直空间的巨大损失使得垂直`LinearLayout`成为一个糟糕的选择。如果你正在处理一个简单的输入表单，那么横向布局应该使用`TableLayout`或`RelativeLayout`来将标签放置在与它们相关的输入控件同一行上。
- en: Providing text input on a landscape layout
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在横向布局上提供文本输入
- en: 'When building your landscape layouts, you need to carefully consider what parts
    of the user interface are most important. If your screen is being used to compose
    an e-mail or a document, your landscape layout could be almost identical to the
    portrait layout. However, such a layout has a mostly hidden enemy: the software
    keyboard. On a portrait layout, the software keyboard will confine itself to the
    bottom of the screen and consume a relatively small amount of space (about a quarter
    to one-third of the available screen space). On a landscape layout however, the
    software keyboard can consume as much as half of your vertical screen space, making
    it very hard to build content-centric landscape layouts. If your layout is strongly
    input-driven, it may make sense to either remove parts of your user-interface
    when the orientation is landscape, re-working your user interface so that the
    software keyboard won''t get in the way.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的横向布局时，你需要仔细考虑用户界面的哪些部分最重要。如果屏幕被用来编写电子邮件或文档，你的横向布局可能与纵向布局几乎相同。然而，这样的布局有一个几乎隐藏的敌人：软件键盘。在纵向布局中，软件键盘会限制在屏幕底部，并占用相对较小的空间（大约四分之一到三分之一的可用屏幕空间）。然而，在横向布局中，软件键盘可能会占用你一半的垂直屏幕空间，使得构建以内容为中心的横向布局变得非常困难。如果你的布局是强烈以输入驱动的，那么在横屏模式下移除用户界面的一部分，或者重新设计用户界面，使得软件键盘不会妨碍，可能是合理的。
- en: 'Android does provide a series of configuration parameters which will tell you
    about the keyboard on the device on which your application is running. It''s a
    good idea to take all of the possibilities into account when building your application.
    The following is a short list of the possible keyboard situations that your application
    may be faced with:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了一系列的配置参数，可以告诉您关于运行您应用程序设备上的键盘信息。在构建应用程序时考虑所有可能性是一个好主意。以下是应用程序可能面临的一些可能的键盘情况简短列表：
- en: Software Keyboard only
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有软件键盘
- en: Hardware Keyboard
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件键盘
- en: Hardware Keyboard available; Software Keyboard in use
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件键盘可用；软件键盘在使用中
- en: 'On top of these possibilities, devices with smaller screens will often make
    use of a 12-key keyboard instead of a full QWERTY keyboard. If this is a software
    keyboard (which it often is), the keyboard may take as much as 80 percent of your
    available screen space. This problem if often handled by Android opening a "text
    input" screen when a text-input box is activated by the user. You can determine
    the different states of keyboard availability, and the type of keyboard used,
    with the following configuration parameters:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些可能性，屏幕较小的设备通常会使用12键键盘而不是全QWERTY键盘。如果这是软件键盘（通常是这种情况），键盘可能占用高达80%的屏幕空间。当用户激活文本输入框时，Android通常会通过打开“文本输入”屏幕来处理这个问题。你可以通过以下配置参数确定键盘的可使用状态和使用的键盘类型：
- en: '`nokeys`: Software keyboard only'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nokeys`：仅限软件键盘'
- en: '`qwerty`: A full hardware keyboard is available'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qwerty`：可以使用完整的硬件键盘'
- en: '`12key`: A 12-key hardware phone-keyboard is available'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`12key`：可以使用12键硬件手机键盘'
- en: '`keysexposed`: The user has a keyboard visible, whether it''s hardware or software'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keysexposed`：用户可以看到键盘，无论是硬件还是软件的'
- en: '`keyshidden`: There isn''t any keyboard currently visible'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyshidden`：当前没有任何键盘可见'
- en: '`keyssoft`: The user will use a software keyboard (though it may not be visible)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyssoft`：用户将使用软件键盘（尽管它可能不可见）'
- en: When designing your screens, consider that the software keyboard may take up
    to half of your vertical space. Ensure that content areas will scroll, while vital
    widgets will always remain visible on the screen. If a chat application is simply
    wrapped in `ScrollView`, the input `EditView` object may become invisible when
    the software keyboard is visible. It's important not just to consider how the
    screen will look, but how it will react to the changes that your users will throw
    at it. Finally, it's vital to test how your screen will look and behave with and
    without a software keyboard.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计屏幕时，请考虑软件键盘可能占用你一半的垂直空间。确保内容区域可以滚动，而重要的控件将始终在屏幕上可见。如果一个聊天应用程序简单地被包裹在`ScrollView`中，当软件键盘可见时，输入`EditView`对象可能会变得不可见。考虑屏幕的外观不仅仅是如何，还要考虑它将如何应对用户可能带来的变化。最后，测试屏幕在有无软件键盘的情况下看起来和表现如何是至关重要的。
- en: Altering screen content
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改屏幕内容
- en: One of the great advantages of the Android XML layout format is the decoupling
    it provides. Portrait and landscape layouts are often quite different from each
    other, and users may individually find a preferred orientation from which to use
    your application. A not-very-common, but useful trick when designing the new layouts,
    is the ability to add or remove "non-functional" elements from the two different
    layouts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Android XML布局格式的一大优势是它提供的解耦。竖屏和横屏布局通常彼此差异很大，用户可能会分别找到一个更喜欢的方向来使用你的应用程序。在设计新布局时，一个不太常见但有用的技巧是能够从两个不同的布局中添加或删除“非功能性”元素。
- en: In a simple example, you may want to abbreviate the text in labels for the portrait
    layout and include some icons as graphical hints, while for the landscape layout,
    you may want icons double the size and two-line labels, all on the same line as
    your input field.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的例子中，你可能想要在竖屏布局中缩写标签文本，并包含一些图标作为图形提示，而在横屏布局中，你可能希望图标大小加倍并使用两行标签，所有这些都位于输入字段同一行。
- en: 'The following diagram illustrates this concept:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下图阐述了这一概念：
- en: '![Altering screen content](img/4484OS_09_18.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![更改屏幕内容](img/4484OS_09_18.jpg)'
- en: On the landscape layout in the preceding diagram, you could make use of an additional
    `TextView` element for the sub-text on the label. Assuming your Java code doesn't
    look for the additional `TextView` object, your application will run perfectly.
    The ability to alter the actual structure of the user interface, and not just
    its layout, is a very important consideration when designing alternative layouts
    for an `Activity`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图表的横屏布局中，你可以使用额外的`TextView`元素来显示标签的子文本。假设你的Java代码没有寻找额外的`TextView`对象，你的应用程序将完美运行。在设计`Activity`的替代布局时，能够更改用户界面的实际结构而不仅仅是布局，这是一个非常重要的考虑因素。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The look and feel of an application is vital. A single change to color or font
    can make or break a screen's usability. At the same time, over-styling an application
    can make it feel out-of-place on the user's device. An alien look and feel will
    drive users away from the application towards those that look and feel more familiar
    and comfortable to them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的外观和感觉至关重要。对颜色或字体的一次更改就可能会影响屏幕的可用性。同时，过度设计应用程序可能会让它在使用者的设备上显得不协调。一个陌生的外观和感觉会将用户从该应用程序推向那些看起来和感觉更熟悉和舒适的应用程序。
- en: Android provides an extremely powerful set of capabilities with the style resource
    structure. When combined with the ability to place your graphics in resource files
    and override the defaults, you can effectively re-style any widget. Using styles
    also helps with the maintenance of your application as you will only need to change
    styling in the style resources and not on each widget declaration of a particular
    style.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用样式资源结构提供了一系列极其强大的功能。结合将你的图形放置在资源文件中并覆盖默认值的能力，你可以有效地重新设计任何小部件。使用样式也有助于维护你的应用程序，因为你只需要在样式资源中更改样式，而不是在每个特定样式的部件声明中进行更改。
- en: Keeping most of your widget graphics as `<shape>` resources will ensure the
    most consistent look and feel possible for your application. However, this is
    not always practical. When you need to provide bitmap resources, it's vital to
    provide different images for the various screen sizes and densities the user may
    be working with.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的大部分小部件图形作为 `<shape>` 资源，将确保你的应用程序具有尽可能一致的外观和感觉。然而，这并不总是实用的。当你需要提供位图资源时，为用户可能使用的各种屏幕尺寸和密度提供不同的图像至关重要。
- en: Styling an application also includes the layout and the ability for the application
    to adapt to the device it's running on. Having a great idea is only half of an
    application's appeal, its styling and execution are critical to its survival in
    the "wild". Attention to detail is a powerful tool that will draw users to your
    application. Applications that "just work" are always favored over those that
    require time and effort to work with.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的风格设计还包括布局以及应用程序适应其运行设备的能力。拥有一个伟大的想法仅是应用程序吸引力的的一半，其风格和执行对它在“野外”的生存至关重要。关注细节是一个强大的工具，将吸引用户使用你的应用程序。那些“即开即用”的应用程序总是比那些需要时间和精力才能使用的应用程序更受欢迎。
- en: Make use of the various screen-sizes and densities provided to you by the Android
    emulator to ensure that your application will look good on as many devices as
    possible. Don't forget that many devices don't have hardware keyboards and that
    the software keyboard can take as much as half of your screen space.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Android 模拟器提供的各种屏幕尺寸和密度，以确保你的应用程序能在尽可能多的设备上看起来良好。不要忘记，许多设备没有硬件键盘，而且软件键盘可能会占用你屏幕空间的一半。
- en: In the next chapter, we'll be extending this styling knowledge into the overall
    design and theming of an application. We'll be building a styled application with
    many of the provided layouts and will be performing fairly extensive styling.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这种样式知识扩展到应用程序的整体设计和主题。我们将构建一个具有许多提供布局的样式化应用程序，并进行相当广泛的样式设计。
