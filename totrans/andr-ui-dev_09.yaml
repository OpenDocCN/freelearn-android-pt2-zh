- en: Chapter 9. Styling Android Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Up to this point we''ve been working with the standard Android themes and
    styling. From a consistency point of view, this is a very good thing, since the
    application will blend properly with the device''s theming (if it has any). However,
    there are times when you need to be able to define your own styling. This styling
    may only apply to a single widget, or it may apply to the entire application.
    In any of these cases, you''ll need to know what tools you have available from
    Android in order to decide how best to approach the problem at hand.*'
  prefs: []
  type: TYPE_NORMAL
- en: There is more to styling than just making your application look good. Also,
    what you think would look good, another person may hate. It's also about making
    the application more useful to your users. This may involve making sure that your
    application looks right no matter which language the user chooses. It may involve
    additional colors for some chosen widgets, or it may simply involve implementing
    a landscape layout for some key screens.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the overall choices that can be made when
    designing certain screens of an application. The chapter also looked at the idea
    of using `WebView` as a container for content and widgets. One of the advantages
    of using a `WebView` is the fact that you then have CSS at your disposal. As any
    web developer will tell you, using CSS makes advanced styling very easy to do.
    However, Android has a collection of styling tools built in as well, with the
    ability to achieve many of the same effects as CSS and in some cases the ability
    to do much more.
  prefs: []
  type: TYPE_NORMAL
- en: Making a single button on the screen appear to be different makes it stand out
    against all of the other widgets. This helps draw attention to the fact that it
    does something different than anything else on the screen; it does something special.
    You may also want a rendered line between two groups of widgets in order to inform
    the user that they have a logical separation. Much like trying to understand someone
    else's source code, getting to grips with a new application is getting to understand
    someone else's logic. Correctly styling your application can go a long way to
    helping the user understand what your thinking was when building the application,
    while also providing them with cues as to what they are expected to do. If you
    need to provide instructions on how the application should be used, you have failed
    in your effort to design and style the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be exploring how Android allows you to style the various
    widgets it provides, and therefore how to adopt your own styles and themes. We''ll
    also work through examples where custom styling can be used to make the application
    easier to use for the user. We''ll cover topics such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining styling resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different types of graphical resources that can be used for styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using nine-patch images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling changes in the device configuration at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining styles that are portable across different devices and screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with style resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first point of attack when dealing with Android styling is to understand
    how the style values work. An application has the ability to define any number
    of styles, much like the ability to define strings and string arrays as resources.
    The style resources are used to define a series of defaults for certain user interface
    elements, in much the same way as a CSS rule can define styling attributes. The
    main difference is that in Android, the styles can override any XML attribute
    defined for a given widget class.
  prefs: []
  type: TYPE_NORMAL
- en: The following table gives a quick comparison of Android style resources and
    CSS stylesheets. They have many common features, but behave quite differently.
  prefs: []
  type: TYPE_NORMAL
- en: '| Android style resources | CSS stylesheets |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| May apply to any XML attribute | Have a purpose-defined set of attributes
    they can define or alter |'
  prefs: []
  type: TYPE_TB
- en: '| May inherit from a parent style | Cascade together in order of definition
    to form complex styles |'
  prefs: []
  type: TYPE_TB
- en: '| Must be explicitly applied to a `View`, `Activity`, or `Application` | Are
    matched to document elements by their selector |'
  prefs: []
  type: TYPE_TB
- en: '| Are defined as plain XML | Defined using specialized grammar |'
  prefs: []
  type: TYPE_TB
- en: Android styles cascade in a manner similar to the way CSS rules do. However,
    the definition of this cascading owes more to a Java class hierarchy. Each style
    may declare a parent style from which it will inherit parameters. Once inherited,
    these parameters may be selectively overridden by the new style. It's always a
    good idea to have a parent style, as the device manufacturer may have modified
    the defaults, allowing you to continue to fit-in with the first-party software
    installed on the users device while creating your own new styles.
  prefs: []
  type: TYPE_NORMAL
- en: A style declaration cannot simply override the styles of all the available `TextView`
    objects. Instead you must either import the style for a specified widget on the
    widget declaration, or reference the style in your manifest file as a theme, in
    order to apply either to a single `Activity` or to your entire application. For
    starters, we'll focus on simply building styles and applying them to single widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Styles, like dimensions, strings and string-arrays, are value resources. When
    creating a styling element, you can place it in any XML file in the `res/values`
    directory (although it''s best to keep your resources separate and place the styles
    in a `styles.xml` file). Like all XML resources in the `values` directory, the
    root element is expected to be `<resources>`, after which you will list your `<style>`
    elements. The following is a simple style that can be used to style any `TextView`
    as a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The name attribute in the above `<style>` element is mandatory, while the parent
    attribute optionally determines which style to use for the default items (in this
    case, the default appearance of a `TextView` object). The following code snippet
    declares a `TextView` with the `TitleStyle` we declared above as its style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice the lack of the `android` namespace prefix in the preceding example.
    Applying a style effectively happens at compile time, when the resources are converted
    into binary data for packaging. When applying the additional attributes, any items
    declared on the `<style>` element that are not available on the widget the style
    is being applied to, are simply ignored. This, in theory, allows you to create
    more abstract styles and apply them to many different widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextView` along with the `TitleStyle` applied, will render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with style resources](img/4484_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Who Overrides Whom?**'
  prefs: []
  type: TYPE_NORMAL
- en: When applying a style to a widget, Activity, or application, it's important
    to know the order of overrides. Each style overrides the style information of
    its parent (if it has one), while each widget will override any style information
    from any styles applied to it. This means that while you can apply an `android:text`
    style item to a `TextView` object, it's generally not very useful since any `android:text`
    attribute on the `TextView` will override the value specified in the style.
  prefs: []
  type: TYPE_NORMAL
- en: Using shape resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's all very fine and well being able to change the size and color of the fonts
    in a widget, but what about fundamentally changing the way in which that widget
    is rendered? We've already worked a little bit with XML drawable objects, but
    there is much more that can be done with them.
  prefs: []
  type: TYPE_NORMAL
- en: The work done so far with the XML drawable structures has been confined to putting
    default images in widgets designed to have an image. However, all widgets in Android
    are designed to have images. The `background` attribute of the `View` class allows
    you to pass in any `drawable` resource, combined with style resources. This becomes
    a very powerful tool. When a shape resource is loaded in Java code, it's returned
    as a `Drawable` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shapes that are available to you are in the `android.graphics.drawable.shapes`
    package, other than the `Shape` class which is the abstract class from which the
    other classes in the package inherit. You reference these classes through XML
    files in the `res/drawable` directory. However, unlike the layout XML resources,
    shapes are more limited:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't have direct access to the class attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only create a single shape per shape file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot paint arbitrary paths (that is diagonal lines or bezier curves)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all their limitations however, shapes are extremely useful and important
    because:'
  prefs: []
  type: TYPE_NORMAL
- en: They scale to the dimensions of the widget they are attached to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes them perfectly suited for creating borders and/or background structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also differentiate between the outline and fill of the shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How shapes behave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each shape structure that you can define behaves slightly differently to each
    of the others, not just in the way it's rendered, but also in what attributes
    apply to it. Since shape resources are fairly limited in how complex they can
    become, they are also somewhat limited in their use.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The line shape in Android is always a straight horizontal line, vertically centered
    in the widget. Earlier we used the line shape as a placeholder image in the memory
    game. However, a much more common use of the line shape is as a vertical separator.
    The line shape is common when used with a `ListView`. A line shape doesn't allow
    for gradient fills, so it is always a solid color (defaulting to black). However,
    the line shape does allow for the full set of attributes in the `stroke` element
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple white line can be defined in just a few lines, and will generally
    serve well as a separator in a `ListView` or similar structure. The following
    code snippet is such a line definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – drawing a broken line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the shapes defined in Android allow you to use the `<stroke>` element
    to define a dotted or dashed line structure, but it's really best shown-off on
    the line element. If we increase the width of the line and define a dash pattern
    with dash segments double the size of the spacing, we get a line that looks much
    like a "cut" or "tear" line on a printed page. This is a great way to make harder
    separators on a user-interface.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shape resource XML file in the `res/drawable` directory named `line.xml`
    and open this file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of the file as a `line shape`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a stroke element for the new line with a `width` of `3sp`, a white
    color, a `dashGap` of `5sp`, and a `dashWidth` of `10sp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the shape declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shape` resource you just created will display a dashed line. The dashes
    in the line have a spacing of exactly half the length of the dashes themselves.
    The sizes are set relative to the user's preferred font size, so the dashes will
    grow and shrink according to the users preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of this line running with the default emulator
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering rectangles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rectangles are the most commonly used shape resource since `View` objects take
    up a rectangular space on the screen (even if they don't use every pixel of that
    space). The rectangle shape includes the ability to have rounded corners, where
    each corner may optionally have a different radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'With no additional style information, a basic rectangle declaration will render
    a filled black box with no visible outline. However, rectangles are better suited
    to creating outlines which can be used to either draw attention to a single widget,
    or isolate a group of widgets from all of the others on the screen. A simple white
    rectangle border can be built copying the following code-snippet into a file named
    `res/drawable/border.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The padding element in this shape will cause any `View` object it's used in
    to increase the size of it's padding by `8dip`. This will stop the contents of
    the widget from intersecting the border rendered by the shape resource.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a rounded border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rectangular shape may also have its corners curved in order to make a rounded
    rectangle. A rounded rectangle is useful for styling buttons, or creating cleaner
    looking borders.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shape resource XML file in the `res/drawable` directory named `rounded_border.xml`
    and open this file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of the file as a `rectangle shape`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the rectangle stroke to `2dip` wide and white in color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pad the rectangle with `8dip` of empty space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Curve the corners by `4dip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the shape declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply the rounded border you just created to a `View` object, you have several
    different options available to you, the most simple of which is to apply it directly
    as a background. For this, you would reference the shape as though it were any
    other image file in the drawable directory. Earlier, we declared a `TitleStyle`
    and applied it to a `TextView` with the word `Header` as its content. If you applied
    the new `rounded_border` to this `TextView`, the `TextView` declaration in the
    layout resource would look something more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could apply this border to the `TitleStyle`, which would
    then apply the new border to every widget assigned the `TitleStyle`, which is
    rather fitting for headers and title widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Either of these will result in the exact same rendering of the new widget. The
    implementation decision is really a matter of what you are trying to achieve.
    Styles are the best way to keep commonality between different widgets that are
    used for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the above style on a `TextView` will result in a nice header widget that
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering ovals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The oval shape is exactly what the name implies—an ellipse. An oval is more
    limited in its use than a rectangle, unless the widget drawing on top of it is
    best bordered by a circle or ellipse, such as an analogue clock. That said, an
    oval, or rather a circle is a very useful shape to use as an image in your user-interfaces.
    A perfect example is a symbol to inform the user whether they are connected to
    the Internet or not, or whether a widget is valid or not. Using an oval shape
    for such a purpose is exactly the same as using a bitmap. However, the oval can
    be scaled according the users' preferences without any loss of quality, while
    you would need several differently-sized bitmap images to achieve a similar effect
    (even then, some of the bitmaps would require scaling).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted an oval shape to represent an invalid widget (for example, to
    show that two password entries don''t match when the user is selecting a password),
    then it would be best to color the oval in red. In the following code-snippet,
    we declare an oval shape as XML with a grey border and a red fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, we use the `<solid>` element to fill the oval with a
    plain red color, while using the `<stroke>` element to surround it with a thin
    grey outline. Also, notice the lack of sizing on the `shape` elements. As previously
    stated, their dimensions are inherited from the width they are placed in, either
    as a background, or in the case of an `ImageView`, as the content of the widget.
    If you want to place this oval shape into an `ImageView`, you would specify it
    in the `src` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is about the right size for a validation icon to sit next
    to a widget, while scaling the icon up or down is as easy as changing the width
    and height of the `ImageView`. If you use `wrap_content` as the size of the `ImageView`,
    it will be sized as zero-by-zero pixels, and will effectively vanish off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a screenshot of four different sizes of the same oval, each scaled
    to double the size of the previous (starting off with the 8x8 dip on the left):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering ovals](img/4484_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – applying a gradient to an oval shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous screenshot shows that while the oval looks okay, it's not going
    to be very visually appealing when surrounded by the gradient painted widgets
    which make up the default Android toolkit. In order to get the little oval to
    fit in nicely, it needs to look more like a ball, which requires a simple radial
    gradient to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shape resource XML file in the `res`/`drawable` directory named
    `ball.xml` and open this file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of the file as an `oval`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of declaring a `solid` color as the fill, declare a `gradient` fill
    starting with a light grey and ending in red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the thin light grey outline of the oval in a `stroke` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the shape declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, the affected radius of a radial gradient doesn't scale with the
    rest of the image, leaving a very small gradient area when you scale the image
    to large sizes. The effect in this case is that while the smallest version of
    the image looks great, the larger versions look terrible. At the time of writing
    this book, there is no direct way to work around this limitation. Instead, you
    will need to tie the size of your oval shape to the size of the `ImageView` if
    you want to use a radial gradient.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering rings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ring shape is also circular in its rendering, but serves a very different
    purpose to the oval shape. While the oval shape's content area is everything inside
    the outline space, a ring shape's content area is a circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the logical difference between the two shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering rings](img/4484OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ring shape also how two outlines, one on the outside and another on the
    inside (as shown in the preceding diagram). Combine this with the ability to fill
    the ring's content area with a gradient and you have the perfect shape to use
    for progress spinners (the default Android indeterminate progress spinner it built
    with a ring).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – rendering a spinner ring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a shape will assume that it's being used as part of a `LevelListDrawable`,
    and may not appear unless you disable this behavior. You do this by specifying
    the `useLevel` attribute as `false` on the shape element. If you don't disable
    this functionality, the ring will not render correctly, or at all.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shape resource XML file in the `res/drawable` directory named `spinner.xml`
    and open this file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the root element of the file as a `ring shape`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ring` shape requires its relative thickness to be set on the `shape` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish the `shape` declaration by turning off the `useLevel` functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `sweep` gradient centered in the oval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Outline the `ring` with a thin white border:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'End the `shape` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sweep gradient is another form of radial gradient. Instead of extending
    out from the center of the image, it sweeps in a circle like the hands of a clock.
  prefs: []
  type: TYPE_NORMAL
- en: The image on the left-hand side is a rectangle filled with the `sweep` gradient;
    while the image on the right-hand side is the `ring` shape. As you can see, the
    two effects are quite different. The image on the right-hand side is based on
    the image used by Android 1.6 for the indeterminate spinner.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened](img/4484_09_07b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've only defined shapes as single-element images. It's possible to
    combine these shapes into more complex images. These images are combined together
    in layers, which is a commonly used graphics structure. In Android, this is done
    with a `layer-list` structure. A `layer-list` is not a type of shape, but it is
    a `Drawable` structure which means it can be used in place of a normal bitmap
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Layered image resources are not confined to being used with vector `Drawable`
    structures such as the shapes we've already talked about. A layered `Drawable`
    object may also include some layers that are bitmap images, or any other `Drawable`
    type that can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: For each layer in a `layer-list`, you need to define an `<item>` element. The
    item element is used to declare optional meta-information such as an ID for the
    layer (which can be used to retrieve the `Drawable` object for that layer in your
    Java code). You can also declare location offsets or padding for the layer in
    the item element. While you can reference a layer as an external `Drawable` resource,
    you are also able to inline the `Drawable` object inside the `<item>` element,
    allowing you to compose various different `Drawable` structures in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sizing your layers**'
  prefs: []
  type: TYPE_NORMAL
- en: Only the first `<item>` of a `layer-list` will be sized according to the widget
    it's placed in. All other layers will be sized to their "natural" size. For a
    bitmap image, this is the size it is rendered in. For a `<shape>` element, the
    natural size is 0x0\. In order to specify a natural size for a `<shape>`, you'll
    need to give the `<shape>` a `<size>` child-element with an `android:width` and
    `android:height` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted a two-layer image to act as a large green button, you would probably
    declare a layer for a grey rounded rectangle as a background, and another layer
    for a green oval to look something like a light, or ball on top of the grey background.
    Such a `layer-list` could look something similar to the following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, there are only `shape` layers, but you could easily
    add in a bitmap layer by referencing the bitmap resource on the `<item>` element,
    as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Stretching using nine-patch images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you want a border that is more than a simple line, for
    example, if you want to add a shadow. On a web-page, you'll commonly find various
    HTML tricks used to insert eight or nine images into a box so that the content
    can be scaled while the border remains intact. In Android, this technique is called
    a "nine-patch" image because it consists of nine different parts. A nine-patch
    image in Android is handled specially when it's rendered at sizes larger than
    its original size. In order to identify these images as special, they have a `.9.png`
    extension (and must be valid `PNG` files).
  prefs: []
  type: TYPE_NORMAL
- en: A nine-patch image combines a border and a background in a single image. The
    background area will grow when the content becomes too large for the image, and
    the border areas of the image will be scaled up so that no "holes" are left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, you can start off by thinking about a nine-patch image as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stretching using nine-patch images](img/4484_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The arrows in the diagram indicate the conceptual "border" areas that will grow
    in size according to the size of the center "content" area. The corners of a nine-patch
    image will be entirely unaffected by any scaling that takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating nine-patch images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a nine-patch image, you'll need a decent image editing application.
    I personally make use of the **Gimp** application (available for free at [http://www.gimp.org](http://www.gimp.org)),
    although you may prefer to use another application. Whatever application you use,
    it must be able to write out **Portable Network Graphics** (**PNG** ) files, and
    should also be able to zoom to fairly extreme levels. The entire data in a nine-patch
    image is actually encoded into the image file, meaning there is no need for an
    XML file to tell Android what parts of the image are border areas, and what parts
    must not be affected by scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike CSS boxes that appear on web pages, the size manipulation done on a nine-patch
    image in Android is nearest-neighbor scaling. **Nearest-neighbor scaling** doesn't
    attempt to improve the quality of the scaled image in any way, the pixels simply
    become larger solid blocks of color. While this works excellently for gradient
    content backgrounds (provided they aren't forced to grow too large), it may cause
    your image to have some strange artifacts to it. Since currently there is no color
    interpolation performed during the scaling, some effects may look rather strange
    when they are scaled. Scaling also takes longer than simple image copying, so
    bear this in mind when sizing the image, it may need to get a lot larger than
    you think. However, this also means that nine-patch images are far more flexible
    than those you might know from the Web.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two images are scaled-up versions of the same 32x32 pixel nine-patch
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating nine-patch images](img/4484_09_10b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The image on the left-hand side is the raw PNG file that can be used as a nine-patch
    image. The image on the right-hand side is the same image with a part of it highlighted
    to show which areas will be scaled. The top, bottom-left, and right areas will
    be scaled only horizontally or vertically, while the center area will be stretched
    to fit the size of the content. The following image is the same image being used
    as the background of a `TextView` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating nine-patch images](img/4484_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the black lines on the left-hand side and top of the image tell Android
    what parts of the image to scale, but what do the lines on the right and bottom
    signify? These two lines determine where to place the content of the widget, much
    like the `<padding>` element in a `<shape>` resource.
  prefs: []
  type: TYPE_NORMAL
- en: To get to grips with how your nine-patch image will be rendered and the possible
    ways it can be scaled, Android provides you with a utility in the `tools` directory
    of an Android SDK installation. The `draw9patch` utility renders your nine-patch
    scaled to various shapes and sizes, and allows you to effectively debug the image
    before using it in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Using bitmap images in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are a major part of styling your application. They are used for icons,
    borders, backgrounds, logos, and many other purposes. Android does its best to
    make sure the images you use as resources render as well as possible across the
    different types of screens used on Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Android's automatic handling of images if far from perfect. However, there are
    times when you will need several different variations of the same image for your
    application to look right on all of the different devices.
  prefs: []
  type: TYPE_NORMAL
- en: Handling different screen sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with any bitmap image in Android, it's very important to consider
    that your application will be run on a variety of different screens, both different
    sizes and densities. When working on very large screens (such as those found on
    a laptop or tablet), you will want to use larger images than you use on an extremely
    small screen. While nine-patch images go a long way to keep things simple, they
    are still scaled with a nearest-neighbor algorithm, and this may start to show
    on a large screen with a larger font-size than you anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: You can provide images of different sizes in your resources directory. For each
    screen size, you can provide a different `drawable` directory. The resource loading
    tools will automatically pick files from the directory that most closely matches
    the current device configuration. You don't need a copy of every resource in each
    of these directories, but only the ones you want to provide a more suitable alternative
    for. The resource loader will fall back on looser matching directories when it
    attempts to find a resource file to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android recognizes five important parameters with regards to the size of a
    screen. While you can specify parameters that relate to the exact number of pixels
    on the screen, this is not a good idea as you won''t easily be able to cater to
    all of the different screen sizes. Instead, it''s best to stick to the five parameters
    that Android provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '`small`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`medium`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`large`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notlong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three parameters are directly related to the size of the screen,
    while the last two are related to whether the screen is "traditional" (such as
    VGA) or has a "wide" (such as WVGA) format. These parameters can be mixed together
    in various combinations such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/res/drawable-small/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res/drawable-medium-long/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res/drawable-large-notlong/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding examples are all valid resource directories that can be used
    to override file in the normal `drawable` directory. You can''t combine parameters
    that contradict each other, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/res/drawable-small-large/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res/drawable-long-notlong/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding cases, you will receive an error from the resource packaging
    tool. Whenever you work with bitmap images, it's important to consider these size
    parameters, since some devices have screens very different from the one that the
    emulator shows by default.
  prefs: []
  type: TYPE_NORMAL
- en: Handling different screen densities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Screen density** generally refers to the number of pixels packed into a given
    physical space (that is, dots-per-inch or DPI). It also has a relationship to
    the size of the pixels on the screen. While most Android devices have medium or
    high-density screens, a large number of cheaper devices make use of a relatively
    low-density screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does this affect nine-patch and bitmap images? The same reason it affects
    font rendering—the lower the density, the worse anti-aliasing and shadows look.
    The best way to explain this is with images. In the following images, the one
    on the left is a simple rounded-rectangle as it would appear on a high-density
    screen. The image on the right is similar to how the same image would render on
    a low-density screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling different screen densities](img/4484_09_13b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although both are the same source image rendered at the same physical size,
    a reduction in the number of pixels available makes the image look blocky on a
    low-density screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two images are taken from the bottom-right corner, and enlarged
    to illustrate in better detail what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling different screen densities](img/4484_09_15b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, these images are configured to take up the same amount of physical space.
    If an image's size is specified in screen-pixels, it will take up much more physical
    space on a low-density screen. This is one of the reasons it's recommended that
    you size images in Android using the "density-independent-pixels" (`dp` or `dip`)
    unit instead of the normal pixels (`px`) unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with screen sizes, Android provides a series of configuration parameters
    that can be used to provide different resources for different screen densities.
    The parameters available for selecting a screen-density can be mixed with those
    selecting based on the screen-size. The following is a list of parameters Android
    makes available for resources to be provided based on the screen-density of the
    current device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldpi`: Low-density screens (~120dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdpi`: Medium-density screens (~160dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hdpi`: High-density screens (~260dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodpi`: Special case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final "special case" can be used when you have a nine-patch image, or a
    bitmap image, that you don't want scaled according to device density. Android,
    by default, will re-scale an image in an attempt to keep the image's physical
    size as close to the intended size as possible. An image in a `nodpi` directory
    will not be scaled automatically by Android, and will be rendered on a pixel-for-pixel
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Different density icons**'
  prefs: []
  type: TYPE_NORMAL
- en: There are times when a large high-resolution icon does not scale down very well.
    In these cases, it's often a good idea to design entirely different icons for
    low-density screens.
  prefs: []
  type: TYPE_NORMAL
- en: Handling configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you provide Android with different resource directories relating to various
    possible hardware configurations, the resource loader will attempt to match the
    best resource files for the device that your application is running on. However,
    not all of the configuration parameters relate directly to the hardware, but instead
    describe the device state or some software configuration parameter. Examples of
    these types of parameters are the device language, network IDs, and device orientation.
    These parameters may change while your application is running. The most common
    example being the device orientation. Android has a built-in mechanism to handle
    such changes for you, and for the most part you won't need any special Java code
    to handle these changes. However, it is strongly desirable to at least provide
    resource files for some of these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When a configuration parameter changes, Android will store any of your `Activity`
    state in a `Bundle` object, and then shut down the `Activity`. It will then start
    up a new instance of the `Activity` object with the new configuration parameters,
    and restore the state from the `Bundle` object. All of the default Android widgets
    will store their current state before your `Activity` is shut down by the system.
    This means you don't generally need to perform any special handling for the configuration
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Providing landscape layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far through the book, we''ve only built portrait layouts. Unlike a desktop
    or web system, a mobile application''s orientation by default is portrait (hence
    the configuration parameters `long` and `notlong` as opposed to `wide` and `narrow`).
    One of the great things about having the Android platform is that an accelerometer
    is a required piece of hardware, which means that your application can respond
    to the orientation of the device. Thanks to Android''s configuration handling
    (as mentioned previously), you, as a developer, don''t need to do anything except
    provide alternative landscape layout resources, assuming you don''t build major
    parts of your user interface in Java. In order to provide layouts which are specific
    to either a portrait or a landscape orientation, you place the specific versions
    of your layout''s XML resources in directories configured with the following resource
    configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`port`: Portrait-specific layouts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`land`: Landscape-specific layouts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the screen is longer vertically than horizontally (that is, portrait orientation),
    using a simple vertically-oriented `LinearLayout` to layout an input form makes
    quite a lot of sense. Any input widgets you make use of will be positioned below
    their labels and so have more horizontal space to display their data. The additional
    horizontal space allows for labels to include more information as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the difference between these two layout concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing landscape layouts](img/4484OS_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The layout method used on the right is very common in a web or desktop system,
    and will work well on a mobile device if the size of the labels and input widgets
    are small enough.
  prefs: []
  type: TYPE_NORMAL
- en: When switching to a landscape orientation, the dramatic increase in horizontal
    space coupled with the massive loss in vertical space makes the vertical `LinearLayout`
    a terrible choice. If you are working with a simple input form, then a landscape
    layout should use `TableLayout` or `RelativeLayout` to position the labels on
    the same lines as the input widgets they relate to.
  prefs: []
  type: TYPE_NORMAL
- en: Providing text input on a landscape layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building your landscape layouts, you need to carefully consider what parts
    of the user interface are most important. If your screen is being used to compose
    an e-mail or a document, your landscape layout could be almost identical to the
    portrait layout. However, such a layout has a mostly hidden enemy: the software
    keyboard. On a portrait layout, the software keyboard will confine itself to the
    bottom of the screen and consume a relatively small amount of space (about a quarter
    to one-third of the available screen space). On a landscape layout however, the
    software keyboard can consume as much as half of your vertical screen space, making
    it very hard to build content-centric landscape layouts. If your layout is strongly
    input-driven, it may make sense to either remove parts of your user-interface
    when the orientation is landscape, re-working your user interface so that the
    software keyboard won''t get in the way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android does provide a series of configuration parameters which will tell you
    about the keyboard on the device on which your application is running. It''s a
    good idea to take all of the possibilities into account when building your application.
    The following is a short list of the possible keyboard situations that your application
    may be faced with:'
  prefs: []
  type: TYPE_NORMAL
- en: Software Keyboard only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware Keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware Keyboard available; Software Keyboard in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On top of these possibilities, devices with smaller screens will often make
    use of a 12-key keyboard instead of a full QWERTY keyboard. If this is a software
    keyboard (which it often is), the keyboard may take as much as 80 percent of your
    available screen space. This problem if often handled by Android opening a "text
    input" screen when a text-input box is activated by the user. You can determine
    the different states of keyboard availability, and the type of keyboard used,
    with the following configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nokeys`: Software keyboard only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qwerty`: A full hardware keyboard is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`12key`: A 12-key hardware phone-keyboard is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keysexposed`: The user has a keyboard visible, whether it''s hardware or software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyshidden`: There isn''t any keyboard currently visible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyssoft`: The user will use a software keyboard (though it may not be visible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When designing your screens, consider that the software keyboard may take up
    to half of your vertical space. Ensure that content areas will scroll, while vital
    widgets will always remain visible on the screen. If a chat application is simply
    wrapped in `ScrollView`, the input `EditView` object may become invisible when
    the software keyboard is visible. It's important not just to consider how the
    screen will look, but how it will react to the changes that your users will throw
    at it. Finally, it's vital to test how your screen will look and behave with and
    without a software keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Altering screen content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the great advantages of the Android XML layout format is the decoupling
    it provides. Portrait and landscape layouts are often quite different from each
    other, and users may individually find a preferred orientation from which to use
    your application. A not-very-common, but useful trick when designing the new layouts,
    is the ability to add or remove "non-functional" elements from the two different
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In a simple example, you may want to abbreviate the text in labels for the portrait
    layout and include some icons as graphical hints, while for the landscape layout,
    you may want icons double the size and two-line labels, all on the same line as
    your input field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Altering screen content](img/4484OS_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the landscape layout in the preceding diagram, you could make use of an additional
    `TextView` element for the sub-text on the label. Assuming your Java code doesn't
    look for the additional `TextView` object, your application will run perfectly.
    The ability to alter the actual structure of the user interface, and not just
    its layout, is a very important consideration when designing alternative layouts
    for an `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The look and feel of an application is vital. A single change to color or font
    can make or break a screen's usability. At the same time, over-styling an application
    can make it feel out-of-place on the user's device. An alien look and feel will
    drive users away from the application towards those that look and feel more familiar
    and comfortable to them.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides an extremely powerful set of capabilities with the style resource
    structure. When combined with the ability to place your graphics in resource files
    and override the defaults, you can effectively re-style any widget. Using styles
    also helps with the maintenance of your application as you will only need to change
    styling in the style resources and not on each widget declaration of a particular
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping most of your widget graphics as `<shape>` resources will ensure the
    most consistent look and feel possible for your application. However, this is
    not always practical. When you need to provide bitmap resources, it's vital to
    provide different images for the various screen sizes and densities the user may
    be working with.
  prefs: []
  type: TYPE_NORMAL
- en: Styling an application also includes the layout and the ability for the application
    to adapt to the device it's running on. Having a great idea is only half of an
    application's appeal, its styling and execution are critical to its survival in
    the "wild". Attention to detail is a powerful tool that will draw users to your
    application. Applications that "just work" are always favored over those that
    require time and effort to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Make use of the various screen-sizes and densities provided to you by the Android
    emulator to ensure that your application will look good on as many devices as
    possible. Don't forget that many devices don't have hardware keyboards and that
    the software keyboard can take as much as half of your screen space.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be extending this styling knowledge into the overall
    design and theming of an application. We'll be building a styled application with
    many of the provided layouts and will be performing fairly extensive styling.
  prefs: []
  type: TYPE_NORMAL
