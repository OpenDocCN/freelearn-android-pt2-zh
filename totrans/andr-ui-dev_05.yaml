- en: Chapter 5. Developing Non-linear Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 开发非线性布局
- en: '*Non-linear layouts are normally a completely fundamental subject of user interface
    design. However, on a device with a small screen (as many Android devices are),
    it doesn''t always make sense. That said, Android devices can be turned to landscape
    mode, where suddenly you have an abundance of horizontal space, and limited vertical
    space. In these situations (and as we''ll see, in many other situations as well),
    you will want to work with a layout other than the plain old `LinearLayout` structure
    we''ve worked with so far.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*非线性布局通常是完全的用户界面设计的基础课题。然而，在屏幕较小的设备上（许多Android设备都是如此），这样做并不总是合理的。也就是说，Android设备可以切换到横屏模式，突然之间你就有大量的水平空间，而垂直空间有限。在这些情况下（以及我们将要看到的其他许多情况下），你会想要使用除了我们至今为止使用的普通`LinearLayout`结构之外的布局。*'
- en: '*The real power of Android layouts comes from the same place as the power of
    the old Java AWT `LayoutManagers`—by combining the different layout classes with
    each other. For example, combining a `FrameLayout` with other `ViewGroup` implementations
    allows you to layer various parts of the user interface on top of each other.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Android布局的真正强大之处与旧的Java AWT `LayoutManagers`的强大之处相同——通过将不同的布局类相互组合。例如，将`FrameLayout`与其他`ViewGroup`实现相结合，允许你将用户界面的各个部分层层叠加。*'
- en: It's important to consider how your layout will act on screens of different
    sizes. While Android does allow you to select different layouts based on the screen
    size of the device, this means that you will have to maintain multiple layouts
    for the different screen sizes and densities which your application will encounter
    in the wild. As far as possible you should make use of the tools that Android
    provides, and work with layouts that will scale according to the size of the various
    `View` objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你的布局在不同大小的屏幕上的表现是很重要的。虽然Android允许你根据设备屏幕大小选择不同的布局，但这意味着你将不得不为不同的屏幕大小和密度维护多个布局，这些屏幕大小和密度将在野外遇到你的应用程序。尽可能使用Android提供的工具，并使用会根据各种`View`对象的大小进行缩放的布局。
- en: In this chapter, we'll look into the various other layout styles that Android
    provides us with by default, and investigate various alternative uses for each
    one of them. We'll also take a closer look at how you specify parameters for different
    layouts, and how they can help in usability, as opposed to simply putting your
    widgets in a particular order.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Android默认提供的各种其他布局样式，并研究每种布局的各种替代用途。我们还会更详细地了解如何为不同的布局指定参数，以及它们如何帮助提高可用性，而不仅仅是将你的小部件按特定顺序排列。
- en: Time for action – creating a layouts example project
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建一个布局示例项目
- en: Before we walk through each of the layouts, we need a common project inside
    which we will showcase each of them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逐一了解每种布局之前，我们需要一个公共项目，在其中展示每一种布局。
- en: 'From a command prompt, create a new project named **Layouts**:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符中，创建一个名为**Layouts**的新项目：
- en: '[PRE0]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Delete the standard `res/layout/main.xml` layout resource file.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除标准的`res/layout/main.xml`布局资源文件。
- en: Open the `res/values/strings.xml` file in an editor or IDE.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`res/values/strings.xml`文件。
- en: 'Add a new `<string-array>` by the name of `layouts` to the file:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中添加一个名为`layouts`的新`<string-array>`：
- en: '[PRE1]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following items to the new `<string-array>` element:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向新的`<string-array>`元素中添加以下项目：
- en: '[PRE2]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the `LayoutSelectorActivity` source file in your editor or IDE.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`LayoutSelectorActivity`源文件。
- en: 'Have the class inherit from `ListActivity` instead of `Activity`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让类从`ListActivity`继承，而不是从`Activity`继承：
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `onCreate` method, set the contents of your `ListActivity` you declared
    in the `strings.xml` resource file to your `layouts` array:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，将你在`strings.xml`资源文件中声明的`ListActivity`的内容设置为你`layouts`数组：
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Override the `onListItemClick` method:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onListItemClick`方法：
- en: '[PRE5]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `switch` statement on the `position` parameter:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`position`参数上创建一个`switch`语句：
- en: '[PRE6]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a `default` clause (the only one for now) to let yourself know that you
    haven''t implemented an example for the selected item yet:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`default`子句（目前唯一的一个），以让你知道你还没有为所选项目实现示例：
- en: '[PRE7]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The new project will serve as a basis for each of the examples in this chapter.
    For each layout we work through, we'll build a new `Activity` that will become
    part of this application. Currently, the application consists of only a menu for
    accessing each of the layout examples. The idea as of now is to fill each one
    with something interesting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目将作为本章每个示例的基础。对于我们要探讨的每个布局，我们将构建一个新的`Activity`，这将成为这个应用程序的一部分。目前，该应用程序只包含一个菜单，用于访问每个布局示例。现在的想法是给每个示例填充一些有趣的内容。
- en: In this chapter, we will explore not just the basic layouts, but also how they
    can be made to interact with each other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不仅探讨基本布局，还会了解它们如何相互作用。
- en: FrameLayout
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`FrameLayout`的使用'
- en: The `FrameLayout` class anchors each of its widgets at the top-left corner of
    itself. This means each child widget is drawn on top of the previous one. This
    can be used to simulate a `CardLayout` from AWT by using `View.setVisible` to
    show one of the children while hiding all the others (this is effectively how
    `TabHost` works).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameLayout`类将每个控件锚定在其自身的左上角。这意味着每个子控件都会在之前的控件上绘制。这可以通过使用`View.setVisible`来模拟AWT中的`CardLayout`，即显示一个子控件同时隐藏所有其他子控件（这正是`TabHost`的工作原理）。'
- en: As `FrameLayout` actually paints all of its visible children, it can be used
    to layer the child widgets on top of each other. It produces very strange effects
    in some cases, while in other cases it can be amazingly useful. For example, darkening
    out all of the widgets except one can be achieved by using a semi-transparent
    `View` object and a `FrameLayout`. The inactive widgets are the first layer in
    the `FrameLayout`, a semi-transparent `View` object is the second, and the active
    widgets are the third.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FrameLayout`实际上会绘制所有可见的子视图，因此可以用来将子控件层层叠加。在某些情况下，它会产生非常奇特的效果，而在其他情况下，它可能非常有用。例如，通过使用半透明的`View`对象和一个`FrameLayout`，可以实现除一个控件外所有控件变暗的效果。不活跃的控件是`FrameLayout`中的第一层，半透明的`View`对象是第二层，活跃的控件是第三层。
- en: Common uses
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用途
- en: The most common use of `FrameLayout` is probably in combination with `TabHost`—to
    hold the content `View` objects for each tab. You can also use it to simulate
    a more desktop feel, by layering widgets on top of each other. It can also be
    used very effectively in games, to display the in-game menu, or draw an animated
    background behind the game's main menu.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameLayout`最常见的用法可能是与`TabHost`结合使用——为每个标签页持有内容`View`对象。你也可以用它来模拟更像是桌面应用的感觉，通过将控件层层叠加。在游戏中也非常有效，可以用来显示游戏内的菜单，或者在游戏主菜单后面绘制动画背景。'
- en: By combining a `FrameLayout` object with widgets that also take up the entire
    screen, you can make use of the `gravity` attribute to place objects more precisely
    on top of other widgets. For this, you'll generally want each of the `FrameLayout`
    children to be a `ViewGroup` of some sort, since they generally don't paint in
    a background unless told to (leaving the lower layers visible).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`FrameLayout`对象与占据整个屏幕的控件结合使用，可以利用`gravity`属性将对象更精确地放置在其他控件之上。为此，通常希望每个`FrameLayout`的子控件都是某种`ViewGroup`，因为除非特别指定，否则它们通常不会在背景中绘制（让下面的图层保持可见）。
- en: A `FrameLayout` is also capable of displaying a `foreground`. While all `View`
    objects have a `background` attribute, `FrameLayout` includes a `foreground` (which
    is also an optional `Drawable`). The `foreground` will be painted on top of all
    of the child widgets, allowing a "frame" to be displayed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameLayout`还能够显示`前景`。虽然所有`View`对象都有`背景`属性，但`FrameLayout`包含一个`前景`（这也是一个可选的`Drawable`）。`前景`会在所有子控件之上绘制，允许显示一个“框架”。'
- en: Time for action – developing a FrameLayout example
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践时间——开发一个`FrameLayout`示例。
- en: To really understand what a `FrameLayout` does, and how it can be used, it's
    best to kick it around a bit with an example. In this example, we'll use a `FrameLayout`
    to layer some `Button` widgets on top of an `ImageView`, and show-and-hide a `TextView`
    message when one of the buttons is clicked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解`FrameLayout`的作用以及如何使用它，最好是通过一个示例来实践一下。在这个示例中，我们将使用`FrameLayout`将一些`Button`控件叠加在`ImageView`之上，并在点击其中一个按钮时显示和隐藏一个`TextView`消息。
- en: For this example to work, you're going to need an image to serve as a background
    image. I'm going to use a photo of one of my friends. As always, place your image
    in the `res/drawable` directory, and try to use a PNG file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例工作，你需要一张图片作为背景图。我将使用我朋友的一张照片。像往常一样，将你的图片放在`res/drawable`目录中，并尝试使用PNG文件。
- en: Create a new layout resource file named `res/layout/frame_layout.xml`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`res/layout/frame_layout.xml`的新布局资源文件。
- en: 'Declare the root element as a `FrameLayout` consuming all available space:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素声明为占用所有可用空间的`FrameLayout`：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the `FrameLayout`, create an `ImageView` to serve as the background
    image. It should scale to fill all the available space:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FrameLayout`内部，创建一个`ImageView`作为背景图像。它应该缩放以填满所有可用空间：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now create a vertical `LinearLayout` where we will place two `Button` objects
    at the bottom of the screen:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个垂直的`LinearLayout`，我们将在屏幕底部放置两个`Button`对象：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `Button` that we will use to toggle one of the child layers of our
    `FrameLayout` (creating a dialog-like effect):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Button`，我们将使用它来切换`FrameLayout`的一个子层（创建类似对话框的效果）：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create another `Button` to quit the demo and go back to the menu:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`Button`以退出演示并返回菜单：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After the `</LinearLayout>`, create a final `TextView` element that we will
    show and hide when the first button is clicked. By default it''s hidden:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`</LinearLayout>`之后，创建一个最终的`TextView`元素，我们将在点击第一个按钮时显示和隐藏它。默认情况下它是隐藏的：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new `FrameLayoutActivity` Java class in the root package of your project,
    and open the source file in your editor or IDE. The new class needs to extend
    from `Activity` and implement the `OnClickListener` class (for events from those
    two `Button` widgets):'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中创建一个新的`FrameLayoutActivity` Java类，并在编辑器或IDE中打开源文件。新类需要从`Activity`继承并实现`OnClickListener`类（用于那两个`Button`小部件的事件）：
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Override the `onCreate` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onCreate`方法：
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Invoke the `super.onCreate` method to get the `Activity` code working:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`super.onCreate`方法以使`Activity`代码工作：
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set the content layout to the `frame_layout` resource you just created:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容布局设置为刚才创建的`frame_layout`资源：
- en: '[PRE17]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Find the `overlay Button` widget you declared in the `frame_layout` resource
    file and create a reference to it:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`frame_layout`资源文件中找到你声明的`overlay Button`小部件并创建一个引用：
- en: '[PRE18]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Set its `OnClickListener` to the new `FrameLayoutActivity` object:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`OnClickListener`设置为新的`FrameLayoutActivity`对象：
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Find the `quit Button` widget:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找你声明的`quit Button`小部件：
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then set it''s `OnClickListener` to the `FrameLayoutActivity` object:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将它的`OnClickListener`设置为`FrameLayoutActivity`对象：
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `OnClickListener` interface requires us to implement an `onClick` method
    with the following signature:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnClickListener`接口要求我们实现一个具有以下签名的`onClick`方法：'
- en: '[PRE22]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `switch` statement on the ID of the `View` parameter:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`View`参数的ID创建一个`switch`语句：
- en: '[PRE23]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the `View` clicked by the user widget is the `overlay_button Button`, then
    use the following:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户点击的`View`是`overlay_button Button`，则使用以下代码：
- en: '[PRE24]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Fetch the `overlay View` object from the layout:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从布局中获取`overlay View`对象：
- en: '[PRE25]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Toggle its visibility according to its current state, then `break` from the
    switch:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据当前状态切换其可见性，然后从`switch`语句中`break`：
- en: '[PRE26]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the `View` clicked by the user widget is the `quit Button`, then use the
    following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户点击的`View`是`quit Button`，则使用以下代码：
- en: '[PRE27]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Invoke the `finish()` method, and `break` from the `switch` statement:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`finish()`方法，并从`switch`语句中`break`：
- en: '[PRE28]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Open the `LayoutSelectorActivity` Java source in your editor or IDE.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`LayoutSelectorActivity` Java源文件。
- en: 'In the `onListItemClick` method, create a new `case` in the `switch` statement,
    for `position` value `0`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onListItemClick`方法中，为`switch`语句创建一个新的`case`，用于`position`值为`0`的情况：
- en: '[PRE29]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Start the `FrameLayoutActivity` using an explicit `Intent`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用显式`Intent`启动`FrameLayoutActivity`：
- en: '[PRE30]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Open the `AndroidManifest.xml` file in an editor or IDE.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`AndroidManifest.xml`文件。
- en: 'Add the new `FrameLayoutActivity` to the manifest file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`FrameLayoutActivity`添加到清单文件中：
- en: '[PRE31]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*What just happened?*'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The new `FrameLayoutActivity` makes use of a simple three layer `FrameLayout`.
    We use an `ImageView` object to draw a nice background image, on top of which
    we placed our two buttons. While the third layer (the `TextView` widget) is invisible
    until the top button is clicked, it's important to note that not only is the background
    of the top `TextView` transparent, it also delegates click events to widgets that
    are technically underneath it (the `TextView` has a widget and height that consumes
    the entire `FrameLayout`). This will continue to work, even if the background
    of the `TextView` is opaque. It has more to do with the fact that the `TextView`
    is not "clickable". If you would have added an `OnClickListener` to the `overlay
    TextView` object, the button underneath it would have stopped working. This means
    you need to be careful how you layer widgets in a `FrameLayout` (although so long
    as one widget doesn't take up the same space as another, this won't become a problem
    for you).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`FrameLayoutActivity`使用了一个简单三层`FrameLayout`。我们使用`ImageView`对象绘制一个漂亮的背景图像，在其上放置了两个按钮。尽管第三层（`TextView`小部件）在顶部按钮被点击之前是不可见的，但需要注意的是，顶部`TextView`的背景不仅透明，而且还将点击事件委托给技术上位于其下的控件（`TextView`有一个消耗整个`FrameLayout`的控件和高度）。即使`TextView`的背景是不透明的，这也会继续工作。这更多是因为`TextView`不是“可点击”的。如果你为`overlay
    TextView`对象添加了一个`OnClickListener`，那么它下面的按钮将停止工作。这意味着你需要小心如何在`FrameLayout`中分层控件（尽管只要一个控件不占用另一个控件的空间，这对你来说不会成为问题）。
- en: In this example, we added a **Quit** button to the layout, and used the `finish()`
    method to close the `Activity` when the `Button` was clicked. You'll find that
    you generally don't use the `finish()` method directly since the user will mostly
    be moving forward through your application. If a user wants to go back, they will
    most often use the hardware "Back" button, or press the hardware "Home" button
    to exit your application entirely.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在布局中添加了一个**退出**按钮，并在点击`Button`时使用`finish()`方法关闭`Activity`。你会发现你通常不会直接使用`finish()`方法，因为用户通常会继续向前浏览你的应用程序。如果用户想要返回，他们通常会使用硬件“返回”按钮，或者按下硬件“主页”按钮完全退出你的应用程序。
- en: A final note on the above example—in the `frame_layout.xml` file, we declare
    the `overlay` as a `TextView` widget. However, in the Java code we access it using
    the `View` class instead of `TextView`. This is a simple case of decoupling. Unless
    you're working in a performance-centric piece of code, it's a good idea to reference
    your layout widgets as high up the class-tree as possible. This will allow you
    to modify your user interface much more quickly later on. In this case, you could
    change the simple `TextView` to an entire `LinearLayout` without the need to change
    the Java code at all.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上述示例的最后说明——在`frame_layout.xml`文件中，我们将`overlay`声明为一个`TextView`小部件。然而，在Java代码中，我们使用`View`类而不是`TextView`来访问它。这是一个简单的解耦例子。除非你正在处理一个以性能为中心的代码段，否则最好尽可能地将你的布局小部件引用到类树的高层。这样，你就可以在以后更快地修改用户界面。在这种情况下，你可以将简单的`TextView`更改为整个`LinearLayout`，而无需更改Java代码。
- en: Following are two screenshots of the `FrameLayout` example, with and without
    the `overlay TextView` enabled. This sort of layout is perfect for use in a game
    menu or a similar structure where you need to layer different widgets on top of
    each other.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`FrameLayout`示例的两张屏幕截图，分别是有和没有启用`overlay TextView`的情况。这种布局非常适合用于游戏菜单或类似结构中，在这些地方你需要将不同的控件层层叠加在一起。
- en: '![What just happened?](img/4484_05_01b.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/4484_05_01b.jpg)'
- en: Table Layout
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格布局
- en: The `Table Layout` arranges its children in a HTML-style grid. It's a bit like
    the AWT `Grid Layout` class, but with much more flexibility. Unlike most other
    layout classes in Android, `Table Layout` uses its own specialized direct-child
    `View` class, named `Table Row`. The `Table Layout` class also doesn't allow you
    to define the number of rows or columns (making it far more like an HTML `<` `table>`
    element). Instead, the number of rows and columns is calculated by the number
    of widgets in the `Table Layout` and its `Table Row` children.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table Layout`以HTML风格的网格排列其子项。它有点像AWT的`Grid Layout`类，但灵活性要大得多。与Android中的大多数其他布局类不同，`Table
    Layout`使用自己的专用直接子`View`类，名为`Table Row`。`Table Layout`类也不允许你定义行数或列数（使其更像一个HTML的`<table>`元素）。相反，行数和列数是由`Table
    Layout`及其`Table Row`子项中的控件数量计算得出的。'
- en: A cell in a `Table Layout` may consume any number of rows and columns, although
    the default for a `View` placed inside a `Table Row` is to take up exactly a single
    table cell. However, if you place a `View` as a direct child of a `Table Layout`,
    it will consume an entire row.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table Layout`中的单元格可以占用任意数量的行和列，尽管默认情况下，放在`Table Row`中的`View`会正好占据一个单元格。但是，如果你直接将`View`作为`Table
    Layout`的子项，它将占用整行。'
- en: '`Table Layout` is also a relative layout structure, which is vitally important
    when working with Android devices. Being able to align everything based on grid
    lines allows your user interface to scale from the lowest resolution on a tiny
    phone, to a high-density screen on a 7-inch tablet.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table Layout`也是一个相对布局结构，这在处理Android设备时至关重要。能够基于网格线对齐所有内容，使得用户界面可以从低分辨率的小手机扩展到7英寸平板电脑上的高密度屏幕。'
- en: The `android:gravity` attribute comes into play far more in a `Table Layout`
    than in many of the other layout classes. What looks great on a small screen may
    look completely different on a large screen, not due to the size of the screen,
    but instead due to the scaling of the fonts used. Be careful, especially with
    the vertical alignment of labels and widgets. The easiest way to start with this
    is to vertically center all of your table widgets, and work from there. Be sure
    to test any table based layout on a variety of screen resolutions and sizes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:gravity`属性在`Table Layout`中的使用远比其他布局类更为频繁。在小屏幕上看起来很棒的效果在大屏幕上可能会完全不同，这并不是因为屏幕的大小，而是因为所使用字体的缩放。特别是在标签和控件的垂直对齐上要小心。最简单的方法是先将所有表格控件垂直居中，然后在此基础上进行调整。务必在多种屏幕分辨率和尺寸上测试基于表格的布局。'
- en: Common uses
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用途
- en: Most commonly you'll find yourself using a `Table Layout` to arrange input form.
    It's also useful for laying out complex information, especially when making some
    `View` objects span several rows and columns. The most important trait of `Table
    Layout` comes from the fact that it aligns its cells in a very strict manner,
    and the fact that its a relative-size layout.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会发现自己使用`Table Layout`来排列输入表单。它也适用于布局复杂信息，特别是在让某些`View`对象跨越多行和多列时。`Table
    Layout`最重要的特点在于它以非常严格的方式对其单元格进行对齐，同时它是一个相对尺寸的布局。
- en: A `Table Layout` can also be used to achieve an effect similar to the AWT `Border
    Layout` class. Generally, when sizing a `Table Layout` to fit the entire screen,
    it becomes a very different tool to a simple grid, allowing you to fit a `Scroll
    View` in the middle of the control widgets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table Layout`也可以用来实现类似于AWT `Border Layout`类的效果。通常，在调整`Table Layout`以适应整个屏幕时，它变成了一个非常不同于简单网格的工具，允许你在控件中间放置一个`Scroll
    View`。'
- en: By using a `Table Layout` inside a `FrameLayout`, you can arrange a control
    `View` on top of a content `View` (think of the controls in Google Maps). Also,
    try to bear in mind that unlike an AWT `GridLayout`, the size of a `View` inside
    a `TabelLayout` is not attached to size of the table-cell in which it is placed.
    By making use of the `gravity` attribute (and possibly a layout margin), you can
    place a `View` object within the table-cell, leading to layouts that are far more
    user-friendly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`FrameLayout`内使用`Table Layout`，你可以在内容`View`（如Google Maps中的控件）上方排列一个控制`View`。还要注意，与AWT
    `GridLayout`不同，`TableLayout`内部的`View`尺寸并不附着在它所在的表格单元格尺寸上。通过使用`gravity`属性（可能还有布局边距），你可以在单元格内放置`View`对象，从而创建出更加用户友好的布局。
- en: Using TableLayout for a memory game
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在记忆游戏中使用TableLayout
- en: To demonstrate the `TableLayout`, I thought it would be fun to write a simple
    memory-card game. You're presented with a grid (in the form of a `TableLayout`)
    of "cards" which you can touch to effectively turn over. You can then attempt
    to match all these cards, with the contents that are displayed on the cards (you're
    only allowed to turn over two at a time). For this example, you'll need some images
    to place on the cards (I've re-used the fruit icons from the delivery example).
    In this application, we'll also be creating a simple placeholder image, in the
    form of an XML file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`TableLayout`，我认为编写一个简单的记忆卡牌游戏会很有趣。你面对的是一个网格（以`TableLayout`的形式），你可以触摸它来有效地翻转“卡片”。然后你可以尝试匹配所有这些卡片上的内容（每次只允许翻转两张）。在这个例子中，你需要在卡片上放置一些图片（我这里复用了交付示例中的水果图标）。在这个应用中，我们还将创建一个简单的占位符图片，以XML文件的形式。
- en: To create the placeholder image, create a new XML resource in the `res/drawable`
    directory, named `line.xml`. This will be a "shape" resource. Shape resources
    are very useful for creating simple, scalable shapes. Also, shape resource files
    can make use of any color, texture, or gradient which you can provide from your
    code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建占位符图像，在`res/drawable`目录中创建一个新的XML资源，名为`line.xml`。这将是一个“形状”资源。形状资源对于创建简单、可伸缩的形状非常有用。此外，形状资源文件可以使用代码提供的任何颜色、纹理或渐变。
- en: 'Copy the following code into the `line.xml` file in order to create the simple
    placeholder image for our example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们示例的简单占位符图像，将以下代码复制到`line.xml`文件中：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Time for action – developing a simple memory game
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——开发一个简单的记忆游戏
- en: Unlike almost all previous example, we'll generate the layout entirely in Java
    code in this game. The main reason for this is that the content is highly repetitive,
    each cell containing almost exactly the same widget. We use a `TableLayout` to
    create the grid, and display the "cards" in `ImageButton` widgets. To encapsulate
    the individual card behavior, we create a `MemoryCard` inner-class which holds
    a reference to the `ImageButton` it controls.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有之前的示例不同，在这个游戏中，我们将完全在Java代码中生成布局。这样做的主要原因是内容高度重复，每个单元格几乎包含完全相同的控件。我们使用`TableLayout`创建网格，并在`ImageButton`控件中显示“卡片”。为了封装单个卡片的行为，我们创建了一个`MemoryCard`内部类，它持有一个对它控制的`ImageButton`的引用。
- en: Create a new Java class in the root package of your project, and name it `TableLayoutActivity`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中创建一个新的Java类，并将其命名为`TableLayoutActivity`。
- en: 'Make the new class extend `Activity`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让新类继承`Activity`：
- en: '[PRE33]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You''ll need a timer in order to flip cards back over, so declare a `Handler`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个定时器来将卡片翻回，因此声明一个`Handler`：
- en: '[PRE34]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare an array of `MemoryCard` objects:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`MemoryCard`对象数组：
- en: '[PRE35]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We either have one or two cards turned over (that we want to keep track of).
    Declare a placeholder for the first:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要跟踪的卡片有一张或两张被翻过来。声明第一个的占位符：
- en: '[PRE36]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If there are two cards turned over, but they don''t match, we disable touch
    with a simple `boolean` switch (our event listeners will check this):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有两张卡片被翻过来，但它们不匹配，我们用一个简单的`boolean`开关禁用触摸（我们的事件监听器将检查这一点）：
- en: '[PRE37]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now declare an inner class named `MemoryCard` which implements the `OnClickListener`
    interface:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明一个名为`MemoryCard`的内部类，该类实现了`OnClickListener`接口：
- en: '[PRE38]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `MemoryCard` class holds a reference to an `ImageButton`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MemoryCard`类持有一个对`ImageButton`的引用：'
- en: '[PRE39]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `MemoryCard` class also has a value, which is a reference to the image
    resource on its face:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MemoryCard`类还有一个值，它是卡片正面的图像资源的引用：'
- en: '[PRE40]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, a `MemoryCard` uses a `boolean` value to remember its state (whether
    the face image, or the placeholder image is visible):'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`MemoryCard`使用一个`boolean`值来记住其状态（是显示正面图像还是占位符图像）：
- en: '[PRE41]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Declare a constructor for the `MemoryCard` class, it only needs to take the
    resource identifier for the face image:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`MemoryCard`类声明一个构造函数，它只需要获取正面图像的资源标识符：
- en: '[PRE42]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Store the `faceImage` resource identifier for later use:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`faceImage`资源标识符以供以后使用：
- en: '[PRE43]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new `ImageButton` object, using the `TableLayoutActivity` object as
    its `Context` (which the `ImageButton` will use to load the images):'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TableLayoutActivity`对象作为其`Context`（`ImageButton`将使用它来加载图像）创建一个新的`ImageButton`对象：
- en: '[PRE44]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Set the size of the `ImageButton` to a fixed 64 x 64 pixels:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ImageButton`的大小设置为固定的64x64像素：
- en: '[PRE45]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Set the scale-type so that icons are made to fit into the `ImageButton`, then
    set the image to the placeholder resource:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置缩放类型，使图标适合`ImageButton`，然后将图像设置为占位符资源：
- en: '[PRE46]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Assign the `MemoryCard` object as the `OnClickListener` of the `ImageButton`
    object:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MemoryCard`对象设置为`ImageButton`对象的`OnClickListener`：
- en: '[PRE47]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For convenience later on, the `MemoryCard` needs a `setFaceVisible` method,
    which will toggle between showing the placeholder and the `faceImage` resource:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便以后使用，`MemoryCard`需要一个`setFaceVisible`方法，该方法将在显示占位符和`faceImage`资源之间切换。
- en: '[PRE48]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `onClick` method in the `MemoryCard` class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MemoryCard`类中实现`onClick`方法：
- en: '[PRE49]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, make sure that the face isn''t currently visible (so we''re turned down),
    and that touch is enabled (and some other cards aren''t about to be turned face-down
    again):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确保当前脸部不可见（即我们已经翻面朝下），并且触摸功能已启用（其他一些卡片不会再次被翻面朝下）：
- en: '[PRE50]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If these conditions are met, we tell the `TableLayoutActivity` that we''ve
    been touched and want to be turned face-up:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果满足这些条件，我们告诉`TableLayoutActivity`我们已被触摸并希望被翻到正面朝上：
- en: '[PRE51]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the `MemoryCell` inner class, create a simple utility method in the `TableLayoutActivity`
    to create an ordered array of `MemoryCell` objects with a specific size:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MemoryCell` 内部类之后，在 `TableLayoutActivity` 中创建一个简单的工具方法，以特定大小创建有序的 `MemoryCell`
    对象数组：
- en: '[PRE52]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When we create each of the `MemoryCell` objects, we create them in pairs, and
    in the same sequence as was specified in our array of icon resources:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建每个 `MemoryCell` 对象时，我们会成对创建它们，并且按照我们在图标资源数组中指定的顺序：
- en: '[PRE53]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When complete, return the new array of `MemoryCell` objects:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，返回新的 `MemoryCell` 对象数组：
- en: '[PRE54]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now override the `onCreate` method:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重写 `onCreate` 方法：
- en: '[PRE55]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Invoke the `Activity.onCreate` method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `Activity.onCreate` 方法：
- en: '[PRE56]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now create a new `TableLayout` object, passing it the `TableLayoutActivity`
    as a `Context` for loading styles and resources:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的 `TableLayout` 对象，将其传递给 `TableLayoutActivity` 作为 `Context` 以加载样式和资源：
- en: '[PRE57]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'By default, we create a four-by-four grid:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，我们创建一个4x4的网格：
- en: '[PRE58]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then we shuffle it to randomize the order:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将其打乱以随机化顺序：
- en: '[PRE59]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create each of the required `TableRow` objects, and populate it with the `ImageButtons`,
    created by the `MemoryCard` objects in the grid:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的每个 `TableRow` 对象，并用由 `MemoryCard` 对象在网格中创建的 `ImageButtons` 填充它：
- en: '[PRE60]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Set the `Activity` content view to the `TableLayout` object:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Activity` 内容视图设置为 `TableLayout` 对象：
- en: '[PRE61]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we write the `onMemoryCardUncovered` method, which is called by the `MemoryCard.onClick`
    implementation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编写 `onMemoryCardUncovered` 方法，它由 `MemoryCard.onClick` 实现调用：
- en: '[PRE62]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, check to see if there is a currently `visible MemoryCard`, if not, the
    card touched by the user is turned face-up and we remember it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查当前是否有可见的 `MemoryCard`，如果没有，用户触摸的卡片将翻转到正面，并记住它：
- en: '[PRE63]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If there is already a face-up card, check to see if they have the same image.
    If the images are the same, disable the `ImageButton` widgets so we ignore the
    events:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经有一张正面朝上的卡片，检查它们是否具有相同的图像。如果图像相同，禁用 `ImageButton` 小部件，以便我们忽略事件：
- en: '[PRE64]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, if the face images don''t match, we turn the card touched by the user
    face-up and flip our `touchEnabled` switch so that the `MemoryCard` objects will
    ignore all other touch events for a second:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果正面图像不匹配，我们将用户触摸的卡片翻转到正面，并切换我们的 `touchEnabled` 开关，使 `MemoryCard` 对象将忽略所有其他触摸事件一秒钟：
- en: '[PRE65]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then we post a delayed message on our `Handler`, which will turn both cards
    face-up again and re-enable touch events:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `Handler` 上发布一个延迟的消息，它将再次翻转两张卡片并重新启用触摸事件：
- en: '[PRE66]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*What just happened*'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: In the previous example, it should be obvious to see why we wrote the layout
    code manually, building it in an XML file would have been terribly repetitive.
    You'll notice that the code creates a `TableRow` object as the direct children
    of the `TableLayout`, just as we would have in an XML file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们手动编写布局代码的原因应该很明了，如果用XML文件构建将会非常重复。你会注意到，代码创建了一个 `TableRow` 对象作为 `TableLayout`
    的直接子项，就像我们在XML文件中一样。
- en: The `onClick` method of `MemoryCard` uses the `touchEnabled` switch to determine
    whether or not to call `onMemoryCardUncovered`. However, neither does this stop
    the user from pressing the `ImageButton` objects, nor does it stop the objects
    from responding to the user (although they won't turn over). For a more user-friendly
    experience, it would be better to use the `setClickable` method on each of the
    enabled `ImageButton` objects, to stop them completely from reacting to the user's
    touch.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryCard` 的 `onClick` 方法使用 `touchEnabled` 开关来确定是否调用 `onMemoryCardUncovered`。然而，这既不能阻止用户按下
    `ImageButton` 对象，也不能阻止对象对用户做出反应（尽管它们不会翻转）。为了提供更友好的用户体验，最好对每个启用的 `ImageButton`
    对象使用 `setClickable` 方法，以完全阻止它们对用户的触摸做出反应。'
- en: When we create the `ImageButton` objects, we pre-size them at 64 x 64 pixels.
    While this is fine for the big emulator screen, there are plenty of devices that
    wouldn't fit the 4 x 4 grid of buttons on the screen. I would recommend you use
    an XML resource to create the `ImageButton` objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `ImageButton` 对象时，会将它们预设为64x64像素大小。这对于大屏幕模拟器来说可能没问题，但有很多设备无法容纳屏幕上的4x4按钮网格。我建议你使用XML资源来创建
    `ImageButton` 对象。
- en: 'The previous code uses `setLayoutParams(new TableRow.LayoutParams(64, 64));`
    to set the size of the `ImageButton` objects. It''s important to note that because
    we are placing the `ImageButton` objects into a `TableRow`, their `LayoutParams`
    must be of the type `TableRow.LayoutParams`. If you try changing to a generic
    `ViewGroup.LayoutParams`, then the user interface won''t layout (it''ll just be
    blank). Following are two screenshots of the working application:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`setLayoutParams(new TableRow.LayoutParams(64, 64));`来设置`ImageButton`对象的大小。需要注意的是，由于我们将`ImageButton`对象放入到`TableRow`中，它们的`LayoutParams`必须是`TableRow.LayoutParams`类型。如果你尝试改为通用的`ViewGroup.LayoutParams`，那么用户界面将不会布局（它会变成空白）。以下是应用程序运行的两个截图：
- en: '![What just happened](img/4484_05_03b.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么](img/4484_05_03b.jpg)'
- en: Have a go hero
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: The `TableLayout` example works great, but the location of the grid isn't great
    (on the top left of the screen), and having it against a black background is quite
    dull. Time to make it look great!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableLayout`示例效果很好，但网格的位置不佳（在屏幕左上角），并且将其放在黑色背景上相当单调。是时候让它看起来很棒了！'
- en: Start by using a `FrameLayout` to add a background image to the game. This will
    enhance the overall appeal of the game by adding more color. You should also take
    this opportunity to center the grid on the screen. Having it in the top left makes
    it look lopsided somehow.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`FrameLayout`为游戏添加一个背景图像。这将通过添加更多色彩来增强游戏的整体吸引力。你也应该借此机会将网格在屏幕上居中。将其放在左上角不知为何会显得不平衡。
- en: You should also try removing the `touchEnabled` switch, instead using `setClickable`
    on each of the `ImageButton` objects. This will stop them from providing a visual
    "press and release" feedback when you're about to turn cards face-down.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该尝试移除`touchEnabled`开关，改为在每个`ImageButton`对象上使用`setClickable`。这将阻止它们在你将牌面朝下时提供视觉上的“按下和释放”反馈。
- en: AbsoluteLayout/Custom Layouts
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AbsoluteLayout/自定义布局
- en: '**Do not use AbsoluteLayout! AbsoluteLayout is Deprecated!** That said, there
    are times when using the `AbsoluteLayout` class makes sense. So why shouldn''t
    you use the `AbsoluteLayout` class, and where should you use it? The answer to
    the first question is very simple—all of the child widgets of an `AbsoluteLayout`
    have their locations specified exactly, they don''t change size or location on
    different screens. It also makes your layout almost impossible to re-use (for
    example, importing it into another layout, or embedding it into another application).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要使用AbsoluteLayout！ AbsoluteLayout已被弃用！** 也就是说，有时使用`AbsoluteLayout`类是有意义的。那么你为什么不应该使用`AbsoluteLayout`类，你应该在什么时候使用它呢？第一个问题的答案很简单——`AbsoluteLayout`的所有子部件都有它们的确切位置，它们在不同屏幕上不会改变大小或位置。它还使你的布局几乎不可能被复用（例如，将其导入另一个布局，或嵌入到另一个应用程序中）。'
- en: 'If you''re going to work with an `AbsoluteLayout`, you should approach it in
    either one of the following two ways:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要使用`AbsoluteLayout`，你应该选择以下两种方法之一来接近它：
- en: Carefully build a separate layout XML for each different screen size.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细为每种不同的屏幕尺寸构建一个单独的布局XML。
- en: Write your layout data in Java code instead of XML.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java代码中编写你的布局数据，而不是在XML中。
- en: The first is impractical unless you specify that the application only runs on
    specific devices, and the layout cannot be used outside of your application. The
    second option however, opens up the "right" way—write a custom layout manager.
    Since `AbsoluteLayout` requires strict locations, and doesn't allow easy interaction
    with the measuring of child `View` objects, the best way to define layouts that
    don't fit well into any of the over layout classes is to define a custom layout
    in your own `ViewGroup` class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法不切实际，除非你指定应用程序只能在特定设备上运行，而且该布局不能在你的应用程序之外使用。然而，第二种方法开启了“正确”的道路——编写自定义布局管理器。由于`AbsoluteLayout`需要严格的位置，并且不允许与子`View`对象的测量轻松交互，定义不适合任何其他布局类的布局的最佳方法是
    在你自己的`ViewGroup`类中定义一个自定义布局。
- en: Developing your own Layouts
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发你自己的布局
- en: Since `AbsoluteLayout` is deprecated, and yet many people seem to insist on
    using it, this example will be to demonstrate not just how easy it is to write
    your own `ViewGroup` class defining a new layout, but also how easy it is to then
    integrate that layout into a layout XML resource. This will thus prove that there
    is no compelling reason to use an `AbsoluteLayout` (unless it really makes sense).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`AbsoluteLayout`已被弃用，但仍有很多人似乎坚持使用它，这个例子将展示如何编写自己的`ViewGroup`类定义一个新布局，以及将这个布局集成到布局XML资源中是多么容易。这将证明使用`AbsoluteLayout`并没有充分的理由（除非它真的有意义）。
- en: Time for action – creating a custom layout
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建自定义布局
- en: To really demonstrate the use of a custom layout, you need to try building something
    unusual. In the following example, you'll put together a `ViewGroup` that arranges
    its children in a nice circle. It's not a very brilliant layout, nor is it particularly
    useful, but circles are nice to look at, and it would provide useful negative
    space in the screen center (which could be filled using a `FrameLayout`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正展示自定义布局的使用，你需要尝试构建一些不寻常的东西。在以下示例中，你将组合一个以美观的圆形排列其子项的`ViewGroup`。这并不是一个特别出色的布局，也不特别实用，但圆形看起来很美观，并且它将在屏幕中心提供有用的空白空间（可以使用`FrameLayout`填充）。
- en: Create a new Java source file in the root package of the project named `CircleLayout.java`,
    and open it in your editor or IDE.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中创建一个名为`CircleLayout.java`的新Java源文件，并在编辑器或IDE中打开它。
- en: 'Declare the `CircleLayout` as extending the `ViewGroup` class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`CircleLayout`扩展自`ViewGroup`类：
- en: '[PRE67]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Declare the three `ViewGroup` constructors and have them delegate directly
    to the `ViewGroup` default constructors:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明三个`ViewGroup`构造函数，并直接将它们委托给`ViewGroup`的默认构造函数：
- en: '[PRE68]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''ll need to know the largest number of pixels taken up by a child `View`
    object''s width, and the largest number of pixels taken up by a child `View` object''s
    height. To avoid unnecessary overhead, we take this opportunity to `measure` the
    child `View` objects as well. Declare a utility method named `measureChildrenSizes`
    to perform these two operations:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要知道子`View`对象宽度占用的最大像素数，以及子`View`对象高度占用的最大像素数。为了避免不必要开销，我们借此机会也`测量`子`View`对象。声明一个名为`measureChildrenSizes`的实用方法来执行这两个操作：
- en: '[PRE69]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Declare an `int` to hold the maximum width and height we find:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`int`来保存我们找到的最大宽度和高度：
- en: '[PRE70]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create a `for` loop to iterate over each of the child `View` objects in this
    `CircleLayout` object:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`for`循环，遍历此`CircleLayout`对象中的每个子`View`对象：
- en: '[PRE71]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Declare a reference to `View` at the current index:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个对当前索引处`View`的引用：
- en: '[PRE72]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As a layout widget, your class will be responsible for setting the display
    size for all of it''s child widgets. In order to know a child widget''s desired
    width and height, you need to use the `measureChild` method in the `ViewGroup`
    class:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为布局组件，你的类需要负责为其所有子组件设置显示大小。为了知道子组件期望的宽度和高度，你需要在`ViewGroup`类中使用`measureChild`方法：
- en: '[PRE73]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Test the width and height of the child `View` object against the maximum width
    and height variables you created earlier:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试子`View`对象的宽度和高度，与你之前创建的最大宽度变量和高度变量进行比较：
- en: '[PRE74]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'At the end of the method, return an array containing the maximum width and
    height found during the procedure:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法末尾，返回一个包含在过程中找到的最大宽度和高度的数组：
- en: '[PRE75]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Implement the `onLayout` method of `ViewGroup`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ViewGroup`的`onLayout`方法：
- en: '[PRE76]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Calculate the width and height of our available space:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算我们可用空间的宽度和高度：
- en: '[PRE77]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Declare a variable to hold the number of child `View` objects:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量来保存子`View`对象的数量：
- en: '[PRE78]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Perform the measurement of all child `View` objects against the amount of available
    space:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有子`View`对象进行测量，以确定可用空间的大小：
- en: '[PRE79]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Subtract the maximum width and height from the available space so that all
    the child `View` objects will fit on the screen:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用空间中减去最大宽度和高度，以确保所有子`View`对象都能在屏幕上显示：
- en: '[PRE80]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Calculate the center point in the `CircleLayout`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`CircleLayout`中的中心点：
- en: '[PRE81]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `for` loop to iterate over each of the child `View` objects again:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`for`循环，再次遍历每个子`View`对象：
- en: '[PRE82]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Declare a variable to hold the current child `View` object:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量来保存当前的子`View`对象：
- en: '[PRE83]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Calculate the `x` and `y` locations of the child `View` object:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算子`View`对象的`x`和`y`位置：
- en: '[PRE84]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Invoke the layout method of the child `View` object with the calculated coordinates
    in the circle:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算出的圆中坐标调用子`View`对象的布局方法：
- en: '[PRE85]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '*What just happened?*'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `CircleLayout` class is a very simple implementation of a `ViewGroup`. Except
    for the requested width and height of its children, it has no special attributes
    that can be used in an XML resource. However, it will take notice of the sizing
    that you declare for its children, and so the `layout_width` and `layout_height`
    attributes will work normally.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircleLayout`类是一个非常简单的`ViewGroup`实现。除了其子项请求的宽度和高度外，它没有可以在XML资源中使用的特殊属性。然而，它会注意到你为子项声明的尺寸，因此`layout_width`和`layout_height`属性将正常工作。'
- en: It's important to note that in order to make use of a custom `View` or `ViewGroup`
    from a layout XML resource, you need to have all three default constructors overridden.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，为了从布局XML资源中使用自定义`View`或`ViewGroup`，你需要重写所有三个默认构造函数。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `LayoutInflater` will make use of one of these constructors to create instances
    of your class. If the one it wants to use isn't in place, you will get the dreaded
    **Force Close** dialog when you try and inflate the layout XML file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutInflater`将使用这些构造函数中的一个来创建你的类的实例。如果它想要使用的那个不存在，那么在尝试膨胀布局XML文件时，你会遇到可怕的**强制关闭**对话框。'
- en: The `CircleLayout` has its own utility method to handle the measuring of its
    child `View` objects. Generally, a `ViewGroup` would use the `V` `iewGroup.measureChildren`
    utility method to see that all of its child `View` objects are measured before
    performing the actual layout. However, we need to iterate over the list of child
    `View` objects in order to find the largest used width and height, so instead
    of performing the iteration three times, we perform the measurements ourselves.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircleLayout`有其自己的实用方法来处理其子`View`对象的测量。通常，`ViewGroup`会使用`ViewGroup.measureChildren`工具方法来确保其所有子`View`对象在执行实际布局之前都已被测量。然而，我们需要遍历子`View`对象列表以找到最大的宽度和高度，因此我们不是执行三次迭代，而是自己执行测量。'
- en: Using the CircleLayout
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CircleLayout
- en: 'To make use of your custom `ViewGroup` implementation, it''s good to know that
    Android has you covered as far as the XML layout resources are concerned. When
    you need to reference a custom `View` or `ViewGroup` class from an XML layout
    resource, you simply use the full class name instead of the simple class name.
    The following is a simple example of an XML layout that uses the `CircleLayout`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用自定义`ViewGroup`实现，了解Android在XML布局资源方面为你提供了支持是很有帮助的。当你需要从XML布局资源中引用自定义`View`或`ViewGroup`类时，只需使用完整的类名而不是简单的类名。以下是使用`CircleLayout`的XML布局的一个简单示例：
- en: '[PRE86]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Time for action – finishing the CircleLayout example
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践时间——完成CircleLayout示例
- en: We've got the `CicleLayout` implementation, but we should really include it
    in our "layouts" example now. To do that we'll need a layout resource XML file,
    a new `CircleLayoutActivity` class. We also need to register the new `Activity`
    with both, Android (in the manifest file), and with our `LayoutSelectorActivity`
    class (in its event listener).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了`CicleLayout`的实现，但现在我们真的应该将其包含在“layouts”示例中。为此，我们需要一个布局资源XML文件，一个新的`CircleLayoutActivity`类。我们还需要在Android（在清单文件中）和我们的`LayoutSelectorActivity`类（在其事件监听器中）注册新的`Activity`。
- en: Copy the preceding XML layout into a new file named `res/layout/circle_layout.xml`.
    It works best with around ten widgets added as children of the `CircleLayout ViewGroup`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的XML布局复制到一个名为`res/layout/circle_layout.xml`的新文件中。最好添加大约十个小部件作为`CircleLayout
    ViewGroup`的子项。
- en: Create a new Java source file in the root package of your project named `CircleLayoutActivity.java`.
    Open this in your editor or IDE.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中创建一个名为`CircleLayoutActivity.java`的新Java源文件。在编辑器或IDE中打开它。
- en: '`CircleLayoutActivity` must extend the `Activity` class:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CircleLayoutActivity`必须继承`Activity`类：'
- en: '[PRE87]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Override the `onCreate` method of `Activity`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`Activity`的`onCreate`方法：
- en: '[PRE88]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Invoke the super class:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用父类：
- en: '[PRE89]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Set the content view to the `circle_layout` layout resource:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容视图设置为`circle_layout`布局资源：
- en: '[PRE90]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Open the `AndroidManifest.xml` file in your editor or IDE.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`AndroidManifest.xml`文件。
- en: 'After the `TableLayoutActivity` declaration, declare the new `CircleLayoutActivity`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TableLayoutActivity`声明之后，声明新的`CircleLayoutActivity`：
- en: '[PRE91]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Open the `LayoutSelectorActivity` source file in your editor or IDE.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`LayoutSelectorActivity`源文件。
- en: 'In the `onListItemClick` method, before the `default case`, add a new `case`
    statement to start the `CircleLayoutActivity`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onListItemClick`方法中，在`default case`之前，添加一个新的`case`语句来启动`CircleLayoutActivity`：
- en: '[PRE92]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '*What just happened?*'
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You now have a new `Activity` implementation that uses your own customized `ViewGroup`
    implementation. Custom `ViewGroup` classes are not just useful when you have a
    hard-to-express layout that the standard `ViewGroup` implementations don't handle
    very well. A custom `ViewGroup` is also an option when the default `ViewGroup`
    implementations are too slow for a particular structure that you want to implement.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个使用自定义`ViewGroup`实现的新`Activity`实现。自定义`ViewGroup`类不仅在标准`ViewGroup`实现无法很好地处理难以表达的布局时有用。当默认的`ViewGroup`实现对于你想要实现的具体结构来说太慢时，自定义`ViewGroup`也是一个选项。
- en: The "layouts" example that you've been building in this chapter will now have
    a working **Custom Layout** menu item. Click it and you'll be presented with the
    following screenshot. Try adding widgets other than `Button` objects, and maybe
    even try throwing in a child `ViewGroup` and see what happens.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中一直在构建的“布局”示例现在将拥有一个可用的**自定义布局**菜单项。点击它，你会看到以下截图。尝试添加除`Button`对象之外的控件，甚至可以尝试加入一个子`ViewGroup`看看会发生什么。
- en: '![What just happened?](img/4484_05_05.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_05_05.jpg)'
- en: Pop quiz
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验
- en: Layout generally happens in two phases, what's the first phase called?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局通常分为两个阶段，第一个阶段叫什么？
- en: Pre-layout
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预布局
- en: Calculation
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算
- en: Parent layout
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父布局
- en: Measurement
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量
- en: What do the four parameters of the layout method signify?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局方法的四个参数表示什么？
- en: x, y, width, and height.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: x, y, 宽度, 高度。
- en: Left, top, right, and bottom.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左，上，右，下。
- en: The size of the parent `ViewGroup`.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父`ViewGroup`的大小。
- en: How can a custom `ViewGroup` implementation read layout XML attributes?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义`ViewGroup`实现如何读取布局XML属性？
- en: They are injected into setters by the `LayoutInflator`.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们通过`LayoutInflator`注入到setter方法中。
- en: They are loaded with the `View.getAttribute` method.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们通过`View.getAttribute`方法加载。
- en: They read it from the `AttributeSet` object passed into the `ViewGroup` constructor.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们从传递给`ViewGroup`构造函数的`AttributeSet`对象中读取。
- en: RelativeLayout
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RelativeLayout
- en: The `RelativeLayout` class is arguably the most powerful layout that Android
    provides. It's a relative layout, managing widgets of varying sizes, and aligning
    widgets against each other instead of against their parent or grid-lines. In some
    ways, `RelativeLayout` has a striking resemblance to the Swing `GroupLayout` class,
    although it is nowhere near as complex. Each widget in a `RelativeLayout` is positioned
    against either another widget, or against its parent (the `RelativeLayout` itself).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`类可以说是Android提供的最强大的布局。它是一个相对布局，管理大小不一的控件，并使控件相互对齐，而不是与它们的父控件或网格线对齐。在某种程度上，`RelativeLayout`与Swing的`GroupLayout`类非常相似，尽管它远没有后者复杂。`RelativeLayout`中的每个控件都是相对于另一个控件或其父控件（即`RelativeLayout`本身）来定位的。'
- en: '`RelativeLayout` calculates the location of each child in a single loop, so
    it relies strongly on the order in which you specify the children. However, this
    doesn''t mean that you must specify the widgets in the order they are displayed
    on the screen. Due to the nature of a `RelativeLayout`, the child widgets are
    often declared and displayed in a different order. This also requires that any
    user interface element used for aligning other widgets must have an ID assigned
    to it. This includes even non-interactive user interface elements which would
    normally not need an ID, must now be assigned one, even though they will never
    be used outside of the layout.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`通过单次循环计算每个子控件的位置，因此它非常依赖于你指定子控件的顺序。但这并不意味着你必须按照它们在屏幕上显示的顺序来指定控件。由于`RelativeLayout`的性质，子控件通常以不同的顺序声明和显示。这也要求任何用于对齐其他控件的用户界面元素必须分配一个ID。这包括通常不需要ID的非交互式用户界面元素，现在也必须分配一个ID，尽管它们永远不会在布局之外使用。'
- en: Using a `RelativeLayout` is extremely flexible, but may also require some careful
    planning. As with any user interface, it helps enormously to draw the layout on
    paper first. Once you have a paper diagram, you can start to plan how you will
    build the layout according to the rules specified by the `RelativeLayout` class.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RelativeLayout`非常灵活，但也可能需要一些仔细的规划。与任何用户界面一样，首先在纸上绘制布局会非常有帮助。一旦有了纸上的图表，你就可以开始根据`RelativeLayout`类的规则来规划如何构建布局了。
- en: Common uses
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用途
- en: The uses of `RelativeLayout` are very similar to those of `TableLayout`. It's
    great for drawing up forms and content views. However, `RelativeLayout` is not
    confined to the grid pattern of `TableLayout`, and can therefore create relationships
    between widgets that are physically far away from each other on the screen (that
    is, by aligning them with each other).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`的用途与`TableLayout`非常相似。它非常适合绘制表单和内容视图。然而，`RelativeLayout`并不局限于`TableLayout`的网格模式，因此可以创建屏幕上物理位置相隔较远的控件之间的关联（即通过相互对齐）。'
- en: '`RelativeLayout` positions and sizes a widget either according to other widgets
    in the same `RelativeLayout`, and/or according to the boundaries of the `RelativeLayout`
    itself. This means some widgets may be placed at the top of the screen, and you
    can align another group of widgets at the bottom of the screen, as shown in the
    following diagram.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout` 可以根据同一 `RelativeLayout` 中的其他组件以及/或者 `RelativeLayout` 边界来定位和设置组件的大小。这意味着某些组件可能被放置在屏幕顶部，而你可以将另一组组件对齐在屏幕底部，如下图所示。'
- en: '![Common uses](img/4484_05_06.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![常见用途](img/4484_05_06.jpg)'
- en: Integrating the RelativeLayout
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 RelativeLayout
- en: When faced with a contact editor, a `RelativeLayout` is the perfect tool to
    produce an easy-to-use user interface. For the next example, we build a very simple
    contact editing user interface including an image of the user.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 面对联系人编辑器时，`RelativeLayout` 是制作易于使用用户界面的完美工具。在下一个示例中，我们构建了一个非常简单的联系人编辑用户界面，包括用户图像。
- en: Time for action – creating a contact editor
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建一个联系人编辑器
- en: This example requires that some of the user interface elements are declared
    out-of-order (as discussed earlier). We'll also include **Save** and **Cancel**
    `Button` widgets at the bottom of the screen. This example goes back to declaring
    the user interface in a resource XML file rather than writing it in Java code.
    For this example, you'll need a placeholder image for the user's contact photo.
    A 64 x 64 pixel PNG file is about the right size to work with (I used a big smiley
    image).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例要求部分用户界面元素按非顺序声明（如之前讨论的）。我们还在屏幕底部包含了 **保存** 和 **取消** `Button` 组件。这个示例回到了在资源
    XML 文件中声明用户界面，而不是在 Java 代码中编写。对于此示例，你需要一个用户联系人照片的占位图像。一个 64x64 像素的 PNG 文件是合适的大小（我使用了一个大大的笑脸图像）。
- en: Start by creating a new XML layout file named `res/layout/relative_layout.xml`.
    Open this file in your editor or IDE.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 XML 布局文件，命名为 `res/layout/relative_layout.xml`。在你的编辑器或 IDE 中打开这个文件。
- en: 'Declare the root element as a full-screen `RelativeLayout`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素声明为全屏的 `RelativeLayout`：
- en: '[PRE93]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create an `ImageButton` that will have an icon of the user on it. The `ImageButton`
    should be aligned to the top-left of the screen, and have a place-holder image
    in it:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有用户图标的 `ImageButton`。`ImageButton` 应该与屏幕左上角对齐，并包含一个占位图像：
- en: '[PRE94]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Add an `EditText` where the user can type a contact''s name. Align this to
    the right bottom of the `ImageButton`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `EditText`，用户可以在其中输入联系人的姓名。将其与 `ImageButton` 右下对齐：
- en: '[PRE95]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now add a `TextView` to act as a label for the `EditText` widget. We align
    this to the right of the `ImageButton`, but above the `EditText`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个 `TextView` 作为 `EditText` 组件的标签。我们将这个标签与 `ImageButton` 右对齐，但位于 `EditText`
    之上：
- en: '[PRE96]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We''ll need an **Edit** `Button` to allow the user to edit the list of phone
    numbers for the contact. Position this on the right side of the screen, and below
    the `EditText`. We add a margin at the top of this `Button` to give a logical
    separation in the user interface:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个 **编辑** `Button` 以允许用户编辑联系人的电话号码列表。将此按钮放置在屏幕右侧，并位于 `EditText` 下方。我们在按钮顶部添加边距，以在用户界面中形成逻辑分隔：
- en: '[PRE97]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Create a nice big `TextView` as a label to the phone numbers, which we will
    list below the new `TextView` and **Edit** `Button`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个大的 `TextView` 作为电话号码的标签，我们将在新的 `TextView` 和 **编辑** `Button` 下方列出电话号码：
- en: '[PRE98]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now create a `TableLayout` to hold a list of the contact person''s phone numbers,
    center-align this `TableLayout` in the `RelativeLayout`, and position it below
    the **Contact Numbers** label with a slight margin:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个 `TableLayout` 以列出联系人电话号码，将这个 `TableLayout` 在 `RelativeLayout` 中居中对齐，并将其置于
    **Contact Numbers** 标签下方，并留有微小边距：
- en: '[PRE99]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Add two `TableRow` elements with some dummy content to the `TableLayout`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `TableLayout` 添加两个带有一些示例内容的 `TableRow` 元素：
- en: '[PRE100]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the **Save** `Button` positioned at the bottom-left of the screen:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个位于屏幕左下角的**保存** `Button`：
- en: '[PRE101]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Create a **Cancel** `Button` positioned at the bottom-right of the screen:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个位于屏幕右下角的**取消** `Button`：
- en: '[PRE102]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '*What just happened*'
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: Many of the user interface elements in the previous example are declared in
    an order that is contrary to the logical layout order, while others are positioned
    relative to the `RelativeLayout` itself and can therefore be placed anywhere in
    the XML file.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，许多用户界面元素是按照与逻辑布局顺序相反的顺序声明的，而其他元素则是相对于 `RelativeLayout` 本身定位的，因此可以放在
    XML 文件的任何位置。
- en: The **Contact Name** label and editor are positioned relative to the "contact
    photo", which in turn is relative to the screen (or `RelativeLayout`). However,
    because we want the label to appear directly above the editor, we need to declare
    and position the `EditText` element before the `TextView` element.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**联系人姓名**标签和编辑器相对于“联系人照片”定位，而“联系人照片”又相对于屏幕（或`RelativeLayout`）。然而，由于我们希望标签直接位于编辑器上方，因此我们需要在`TextView`元素之前声明并定位`EditText`元素。'
- en: The **Contact Name** `EditText` element uses a width of `fill_parent`, which
    in a `RelativeLayout` simply fills the available horizontal space (or vertical
    space if it's used on a widget's height). This is a useful feature when you want
    an element to simply consume the rest of a "line", or span across the entire screen
    (that is, for a dividing line). In a `RelativeLayout` you cannot use two layout
    attributes that conflict with the same axis of a widget. For example, you use
    the `layout_toRightOf` and `layout_alignRight` on the same `View` widget.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**联系人姓名**的`EditText`元素使用了`fill_parent`的宽度，在`RelativeLayout`中，这将简单地填充可用的水平空间（如果是用在控件的高度上则是垂直空间）。当你希望一个元素简单地占据“行”的剩余部分，或者横跨整个屏幕（例如，作为分割线）时，这是一个很有用的特性。在`RelativeLayout`中，你不能对同一个轴上的控件使用两个相互冲突的布局属性。例如，你不能在同一个`View`控件上同时使用`layout_toRightOf`和`layout_alignRight`。'
- en: Time for action – integration with the layout example
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——与布局示例集成
- en: The integration of the `RelativeLayout` example is almost identical to the integration
    of the custom `CircleLayout` example that you wrote earlier. Integration will
    require a new `Activity` implementation, and then we need to register it with
    Android and the `LayoutSelectorActivity`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`示例的集成与之前编写的自定义`CircleLayout`示例的集成几乎相同。集成将需要一个新的`Activity`实现，然后我们需要将其注册到Android和`LayoutSelectorActivity`中。'
- en: Create a new Java source file in the root package of the "layouts" example project,
    named `RelativeLayoutActivity.java`. Open this in your editor or IDE.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“layouts”示例项目的根包中创建一个新的Java源文件，命名为`RelativeLayoutActivity.java`。在你的编辑器或IDE中打开这个文件。
- en: 'The new `RelativeLayoutActivity` needs to extend the `Activity` class:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`RelativeLayoutActivity`需要扩展`Activity`类：
- en: '[PRE103]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Override the `onCreate` method:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onCreate`方法：
- en: '[PRE104]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Invoke the `super` class to set up its state:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`super`类来设置其状态：
- en: '[PRE105]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Set the content view of the new `Activity` to the `relative_layout` XML layout
    resource created earlier:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`Activity`的内容视图设置为之前创建的`relative_layout` XML布局资源：
- en: '[PRE106]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Open the `AndroidManifest.xml` file in your editor or IDE.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`AndroidManifest.xml`文件。
- en: 'Register `RelativeLayoutActivity` after `CircleLayoutActivity`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CircleLayoutActivity`之后注册`RelativeLayoutActivity`：
- en: '[PRE107]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Open `LayoutSelectorActivity` Java source code in your editor or IDE.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`LayoutSelectorActivity`的Java源代码。
- en: 'In the `onListItemClick` method, declare a new `case` statement before the
    `default` statement and start the new `RelativeLayoutActivity`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onListItemClick`方法中，在`default`语句之前声明一个新的`case`语句并启动新的`RelativeLayoutActivity`：
- en: '[PRE108]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '*What just happened?*'
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Now that the `RelativeLayoutActivity` is integrated with the rest of the layout
    example, you can fire up the emulator and take a look at the screen you just built.
    As you can see in the following screenshot, this design is much more user-friendly
    than most of the other designs we've built so far. The main reason for this is
    the ability to group and align widgets in ways that logically relate to each other,
    rather than being forced to confine to the requirements of the chosen `ViewGroup`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`RelativeLayoutActivity`已经与布局示例的其余部分集成在一起，你可以启动模拟器并查看你刚刚构建的屏幕。正如以下截图所示，这个设计比我们迄今为止构建的其他大多数设计都要用户友好。这主要是因为它能够以逻辑上相互关联的方式对控件进行分组和对其，而不是被迫局限于所选`ViewGroup`的要求。
- en: However, this flexibility doesn't come without a price. The `RelativeLayout`
    structures are far more easily broken than other `ViewGroup` implementations,
    and in many cases won't offer you much additional flexibility. In the preceding
    example, we embedded a `TableLayout` to display the list of contact numbers instead
    of displaying them directly under the `RelativeLayout` element. Not only is `TableLayout`
    better suited to this task, but it also allows us to center-align the numbers
    as a single group instead of aligning them to the left and right of the `RelativeLayout`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种灵活性并非没有代价。`RelativeLayout`结构比其他`ViewGroup`实现更容易被破坏，在许多情况下，它不会为你提供太多的额外灵活性。在上述示例中，我们嵌入了一个`TableLayout`来显示联系人号码列表，而不是直接在`RelativeLayout`元素下显示它们。不仅`TableLayout`更适合这项任务，它还允许我们将号码作为一个组居中排列，而不是将它们对齐到`RelativeLayout`的左右两侧。
- en: '`RelativeLayout` combined with either an embedded `ScrollView` or a `FrameLayout`
    is a brilliant way of providing toolbars for more content-centric user interfaces.
    When you have a media-centric user interface (with full-screen maps, video, photos,
    or something similar), using a `RelativeLayout` to arrange the tool buttons around
    the outside of the screen and then placing the actual content behind it with a
    `FrameLayout` works extremely well as can be seen in many Android applications
    such as Google Maps or the default browser application. This design also allows
    you to show or hide the tool buttons based on the user''s interaction with the
    application, giving them a better view of the media content when they are not
    interacting with the toolset.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RelativeLayout`与内嵌的`ScrollView`或`FrameLayout`结合使用，是提供以内容为中心的用户界面工具栏的绝佳方式。当你的用户界面以媒体为中心（如全屏地图、视频、照片或类似内容）时，使用`RelativeLayout`将工具按钮围绕屏幕边缘布局，并通过`FrameLayout`将实际内容置于其后，这在许多Android应用中都能看到，如谷歌地图或默认的浏览器应用。这种设计还允许你根据用户与应用的交互来显示或隐藏工具按钮，从而在用户不与工具集互动时，让他们更好地查看媒体内容。
- en: '![What just happened?](img/4484_05_07.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/4484_05_07.jpg)'
- en: SlidingDrawer
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动抽屉
- en: If you've used an un-themed Android installation (such as the emulator), or
    most themed versions of Android, then you've used a `SlidingDrawer`. It's the
    widget that drives the opening and closing of the launcher menu. While it is not
    exactly a layout in its own right, a `SlidingDrawer` allows you to make a large
    number of lesser-used widgets very quickly available to the user. This makes it
    an important widget to consider when developing a new user interface.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过未主题化的Android安装（如在模拟器中），或大多数主题化的Android版本，那么你已经使用过`SlidingDrawer`。这是推动启动器菜单打开和关闭的控件。虽然它本身并不是一个布局，但`SlidingDrawer`允许你快速向用户展示大量较少使用的控件。在开发新用户界面时，这使得它成为一个重要的控件考虑因素。
- en: Generally, it'll be a decision between using a menu and a `SlidingDrawer`. While
    a menu is great for displaying action items, a `SlidingDrawer` can display any
    content you want. However, a `SlidingDrawer` also has some restrictions on its
    use. For example, it requires that you place it within a `FrameLayout` or `RelativeLayout`
    instance (of which `FrameLayout` is far more typical) in order to function correctly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用菜单和`SlidingDrawer`之间需要做出选择。虽然菜单非常适合显示动作项，但`SlidingDrawer`可以显示你想要的任何内容。然而，`SlidingDrawer`对其使用也有一些限制。例如，它要求你将其放置在`FrameLayout`或`RelativeLayout`实例中（其中`FrameLayout`更为典型），以使其正确工作。
- en: A `SlidingDrawer` is in some ways a form of disclosure widget. It consists of
    a handle and content. By default, only the handle is visible on the screen, until
    the user touches or pulls the handle to open the `SlidingDrawer` and display the
    content section.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`SlidingDrawer`在某种程度上是一种揭示控件。它由一个手柄和内容部分组成。默认情况下，只有手柄在屏幕上是可见的，直到用户触摸或拉动手柄来打开`SlidingDrawer`并显示内容部分。'
- en: Common uses
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用途
- en: The open/close content nature of the `SlidingDrawer` class makes it ideal for
    the application launcher in Android. By default, it is hidden away so the desktop
    is visible and usable, until you tap the handle in order to view the list of available
    applications.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`SlidingDrawer`类的打开/关闭内容特性使其成为Android中应用启动器的理想选择。默认情况下，它是隐藏的，因此桌面可见且可用，直到你点击手柄以查看可用的应用程序列表。'
- en: This also makes `SlidingDrawer` a brilliant tool for building applications such
    as strategy games. Instead of giving your user all the available build options
    (for example), restrict the default screen view to the key map elements. When
    they want to build something, or check some status information, they can tap or
    drag open a `SlidingDrawer` from the bottom of the screen, revealing all the build/command
    options.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得 `SlidingDrawer` 成为构建策略游戏等应用程序的绝佳工具。例如，不要为用户提供所有可用的构建选项，而是将默认屏幕视图限制为关键地图元素。当用户想要构建某物或检查某些状态信息时，他们可以从屏幕底部轻触或拖动打开
    `SlidingDrawer`，从而显示所有构建/命令选项。
- en: Generally, when you have actions or information that the user won't need to
    interact often with, a `SlidingDrawer` is a great way to present it. It can also
    be opened and closed from your Java code when key events that require the user's
    attention occur.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当用户不需要经常与之交互的动作或信息时，`SlidingDrawer` 是一个展示它们的绝佳方式。当需要用户注意的关键事件发生时，它也可以从你的
    Java 代码中打开和关闭。
- en: The handle element of the `SlidingDrawer` is also a full `View` or `ViewGroup`,
    which allows you to put status messages in it. Another common use of the `slidingdrawer`
    widget is that the status bar at the top of most Android devices is often implemented
    as a `SlidingDrawer`. A summary is displayed on the handle when an event occurs,
    and the user can drag open the content to view the complete details of the most
    recent events.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`SlidingDrawer` 的 handle 元素也是一个完整的 `View` 或 `ViewGroup`，允许你在其中放置状态信息。`slidingdrawer`
    控件的另一个常见用途是，大多数 Android 设备顶部的状态栏通常实现为 `SlidingDrawer`。当事件发生时，在 handle 上显示摘要，用户可以拖开内容以查看最近事件的完整详情。'
- en: Creating a SlidingDrawer example
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 SlidingDrawer 示例
- en: To keep the `SlidingDrawer` example nice and simple, we're going to re-use the
    `CircleLayout` example with one main modification—the background color needs to
    change. If the background of a `SlidingDrawer` is not specifically set, the background
    will be transparent. Generally, this is undesirable since the content behind the
    open `SlidingDrawer` widget is then visible, and interferes with the content of
    the `SlidingDrawer`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `SlidingDrawer` 示例保持简洁，我们将重用 `CircleLayout` 示例，并进行一个主要修改——背景颜色需要改变。如果 `SlidingDrawer`
    的背景没有特别设置，背景将会是透明的。通常，这是不希望发生的，因为打开的 `SlidingDrawer` 控件背后的内容会变得可见，这会干扰 `SlidingDrawer`
    的内容。
- en: Time for action – creating a SlidingDrawer
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建一个 SlidingDrawer
- en: For this example, we'll be placing a `SlidingDrawer` widget on top of an image
    (I've once again chosen a photo of one of my friends as my background). For the
    handle of the `SlidingDrawer`, we'll make use of the line drawable XML file that
    was created for the `TableLayoutActivity`. For the content of the `SlidingDrawer`,
    we'll make use of the `circle_layout` resource.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将在一张图片上方放置一个 `SlidingDrawer` 控件（我再次选择了一位朋友的照片作为背景）。`SlidingDrawer` 的
    handle 将使用为 `TableLayoutActivity` 创建的线条可绘制 XML 文件。`SlidingDrawer` 的内容将使用 `circle_layout`
    资源。
- en: Open the `res/layout/circle_layout.xml` file in your editor or IDE.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或 IDE 中打开 `res/layout/circle_layout.xml` 文件。
- en: 'On the root element declaration, set the background attribute to black:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根元素声明中，将背景属性设置为黑色：
- en: '[PRE109]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Create a new layout resource file named `sliding_drawer.xml`, and open this
    file in your editor or IDE.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的布局资源文件，命名为 `sliding_drawer.xml`，并在你的编辑器或 IDE 中打开这个文件。
- en: 'Declare the root element of this layout as a `FrameLayout`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此布局的根元素声明为 `FrameLayout`：
- en: '[PRE110]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Inside the `FrameLayout`, create an `ImageView` to contain the background image.
    Remember to set the scale-type and size so the image fills the screen:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FrameLayout` 内部，创建一个 `ImageView` 以包含背景图像。记得设置缩放类型和大小，使图像充满屏幕：
- en: '[PRE111]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Declare the `SlidingDrawer` widget. You''ll need to forward-reference the handle
    and content widgets since they don''t exist yet:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `SlidingDrawer` 控件。由于 handle 和 content 控件尚未创建，你需要提前引用它们：
- en: '[PRE112]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Inside the `SlidingDrawer` element, create an `ImageView` with the placeholder
    `line` drawable resource that you created for the `TableLayoutActivity` earlier:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SlidingDrawer` 元素内部，创建一个 `ImageView`，使用之前为 `TableLayoutActivity` 创建的占位符 `line`
    可绘制资源：
- en: '[PRE113]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Also inside the `SlidingDrawer` element, include the `circle_layout` layout
    resource, assigning its ID as "content":'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SlidingDrawer` 元素内部，包含 `circle_layout` 布局资源，并将其 ID 分配为 "content"：
- en: '[PRE114]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '*What just happened?*'
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'You''ll notice that in the previous example, the `SlidingDrawer` adds the ID
    references to its handle and content widgets, while the widgets themselves appear
    to access these IDs instead of declaring them:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了，在之前的例子中，`SlidingDrawer`为其手柄和内容小部件添加了ID引用，而小部件本身似乎访问这些ID而不是声明它们：
- en: '[PRE115]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This is a side effect of how the `SlidingDrawer` class works. it needs the ID
    values before it needs the widgets themselves. This technique is much like a forward-reference,
    except the object is not technically created. The `@+` syntax tells the resource
    compiler that we are creating a new id, but not a new object. When we later declare
    the `ImageView` element using the `@id/handle` value as its `id`, we are in fact
    referencing the value that was generated when we declared the `SlidingDrawer`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SlidingDrawer`类工作方式的一个副作用。它需要ID值，然后才需要小部件本身。这种技术非常类似于向前引用，不同之处在于对象在技术上并没有被创建。`@+`语法告诉资源编译器我们正在创建一个新的id，但不是一个新对象。当我们后来使用`@id/handle`值作为其`id`声明`ImageView`元素时，实际上我们正在引用在声明`SlidingDrawer`时生成的值。
- en: Time for action – sliding drawer integration
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——滑动抽屉集成
- en: Now it's time to plug the `SlidingDrawer` example into the "layouts" example.
    This, like all the other integrations, involves a new `Activity`, and registering
    the new `Activity` with Android and `LayoutSelectorActivity`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将`SlidingDrawer`示例插入到“layouts”示例中了。这与其他所有集成一样，涉及一个新的`Activity`，以及将新的`Activity`注册到Android和`LayoutSelectorActivity`中。
- en: Create a new Java source file in the root package of the "layouts" example project
    named `SlidingDrawerActivity.java`. Open this in your editor or IDE.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“layouts”示例项目的根包中创建一个新的Java源文件，名为`SlidingDrawerActivity.java`。在你的编辑器或IDE中打开这个文件。
- en: 'The new `SlidingDrawerActivity` needs to extend the `Activity` class:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`SlidingDrawerActivity`需要扩展`Activity`类：
- en: '[PRE116]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Override the `onCreate` method:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onCreate`方法：
- en: '[PRE117]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Invoke the super class to set up its state:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用超类来设置其状态：
- en: '[PRE118]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Set the content view of the new `Activity` to the `sliding_drawer` XML layout
    resource created earlier:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新`Activity`的内容视图设置为之前创建的`sliding_drawer` XML布局资源：
- en: '[PRE119]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Open the `AndroidManifest.xml` file in your editor or IDE.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`AndroidManifest.xml`文件。
- en: 'Register the `SlidingDrawerActivity` after the `RelativeLayoutActivity` is
    declared:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明`RelativeLayoutActivity`之后注册`SlidingDrawerActivity`：
- en: '[PRE120]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Open the `LayoutSelectorActivity` Java source code in your editor or IDE.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开`LayoutSelectorActivity` Java源代码。
- en: 'In the `onListItemClick` method, declare a new `case` statement before the
    `default` statement and start the new `SlidingDrawerActivity`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onListItemClick`方法中，在`default`语句之前声明一个新的`case`语句，并启动新的`SlidingDrawerActivity`：
- en: '[PRE121]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '*What just happened?*'
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You've just completed all of the layout examples in this chapter. The `default`
    condition in your `switch` statement should never trigger again! The `SlidingDrawer`
    example is very simple, but demonstrates well how versatile this widget can be.
    If this example was (for instance) a paint application, the `SlidingDrawer` would
    be the perfect place to hide a list of the more complex painting functions available.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了本章中的所有布局示例。你的`switch`语句中的`default`条件不应该再次触发了！`SlidingDrawer`示例非常简单，但很好地展示了这个部件可以有多么灵活。如果这个例子是一个绘图应用程序，`SlidingDrawer`将是一个隐藏更多复杂绘图功能的完美地方。
- en: 'The handle of this `SlidingDrawer` example is a simple `ImageView`, but it
    can be any `View` or `ViewGroup` (a `TableLayout`, if you wanted). However, you
    want to avoid the handle becoming interactive (that is, a `Button` or `EditText`
    widget). An interactive widget in the handle will cause problems when the user
    touches it. Although the widget remains fully functional, and can be dragged up
    and down like a handle, touching it to start an interaction will cause the `SlidingDrawer`
    to open or close itself. To stop this from happening, you can optionally turn
    the "touch to toggle" option of the `SlidingDrawer` off with the `allowSingleTap`
    attribute:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SlidingDrawer`示例的手柄是一个简单的`ImageView`，但它可以是任何`View`或`ViewGroup`（如果你愿意，可以是`TableLayout`）。然而，你希望避免手柄变得可交互（即，一个`Button`或`EditText`小部件）。手柄中的交互式小部件会在用户触摸它时引起问题。尽管小部件完全功能正常，可以像手柄一样上下拖动，但触摸它以开始交互将导致`SlidingDrawer`打开或关闭。为了防止这种情况发生，你可以选择通过`allowSingleTap`属性关闭`SlidingDrawer`的“触摸切换”选项：
- en: '[PRE122]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: That said, having an `EditText` (or similar) as a handle for a `SlidingDrawer`
    makes very little sense, and is likely to make your users rather irritated with
    you. As far as possible, you should make sure that the handle of your `SlidingDrawer`
    widgets looks like something the user can drag. The default handle of the launcher
    application is a great example.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，将`EditText`（或类似的控件）作为`SlidingDrawer`的把手几乎是没有意义的，这很可能会让你的用户感到非常恼火。尽可能确保你的`SlidingDrawer`小部件的把手看起来像是用户可以拖动的东西。启动器应用程序的默认把手就是一个很好的例子。
- en: '![What just happened?](img/4484_05_08.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/4484_05_08.jpg)'
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Working through the examples in this chapter should have given you a good look
    into the layouts that are available by default in Android, as well as a look at
    how they are implemented (and how new ones can be implemented when needed). In
    most cases, these `ViewGroup` implementations will serve any layout needs you
    have, but it remains important to keep the following principals in mind when building
    Android layouts:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '通过本章示例的学习，应该能让你很好地了解Android默认提供的布局，以及它们是如何实现的（以及在需要时如何实现新的布局）。在大多数情况下，这些`ViewGroup`实现将满足你的任何布局需求，但在构建Android布局时，仍然需要牢记以下原则： '
- en: Different devices have different size and resolution screens
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的设备具有不同的大小和分辨率屏幕
- en: Use negative space (white space) and lines to separate groups of widgets
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用负空间（空白）和线条来分隔小部件组
- en: You will almost certainly need to modify the layout in the future
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你几乎肯定需要在将来修改布局
- en: That last point is particularly important when choosing to use the `RelativeLayout`
    class. While it offers your far more power than the other implementations, a badly
    put-together `RelativeLayout` can be very difficult and time consuming to maintain.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择使用`RelativeLayout`类时，最后一点尤为重要。虽然它比其他实现方式提供了更多的功能，但一个组合得不好的`RelativeLayout`可能会非常难以维护，且耗时。
- en: In the coming chapter, we'll take a look at how capturing input, and the validation
    of that input should be taken as a user interface design decision. We'll also
    work through some examples that can be used as a foundation for future user interface
    developments.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何捕获输入以及输入验证应当作为用户界面设计决策的一部分。我们还将通过一些示例来进行实践，这些示例可以作为未来用户界面开发的基础。
