- en: Chapter 5. Developing Non-linear Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Non-linear layouts are normally a completely fundamental subject of user interface
    design. However, on a device with a small screen (as many Android devices are),
    it doesn''t always make sense. That said, Android devices can be turned to landscape
    mode, where suddenly you have an abundance of horizontal space, and limited vertical
    space. In these situations (and as we''ll see, in many other situations as well),
    you will want to work with a layout other than the plain old `LinearLayout` structure
    we''ve worked with so far.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The real power of Android layouts comes from the same place as the power of
    the old Java AWT `LayoutManagers`—by combining the different layout classes with
    each other. For example, combining a `FrameLayout` with other `ViewGroup` implementations
    allows you to layer various parts of the user interface on top of each other.*'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to consider how your layout will act on screens of different
    sizes. While Android does allow you to select different layouts based on the screen
    size of the device, this means that you will have to maintain multiple layouts
    for the different screen sizes and densities which your application will encounter
    in the wild. As far as possible you should make use of the tools that Android
    provides, and work with layouts that will scale according to the size of the various
    `View` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look into the various other layout styles that Android
    provides us with by default, and investigate various alternative uses for each
    one of them. We'll also take a closer look at how you specify parameters for different
    layouts, and how they can help in usability, as opposed to simply putting your
    widgets in a particular order.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a layouts example project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we walk through each of the layouts, we need a common project inside
    which we will showcase each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a command prompt, create a new project named **Layouts**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the standard `res/layout/main.xml` layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `res/values/strings.xml` file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `<string-array>` by the name of `layouts` to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following items to the new `<string-array>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `LayoutSelectorActivity` source file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Have the class inherit from `ListActivity` instead of `Activity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreate` method, set the contents of your `ListActivity` you declared
    in the `strings.xml` resource file to your `layouts` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onListItemClick` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `switch` statement on the `position` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `default` clause (the only one for now) to let yourself know that you
    haven''t implemented an example for the selected item yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new project will serve as a basis for each of the examples in this chapter.
    For each layout we work through, we'll build a new `Activity` that will become
    part of this application. Currently, the application consists of only a menu for
    accessing each of the layout examples. The idea as of now is to fill each one
    with something interesting.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore not just the basic layouts, but also how they
    can be made to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: FrameLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FrameLayout` class anchors each of its widgets at the top-left corner of
    itself. This means each child widget is drawn on top of the previous one. This
    can be used to simulate a `CardLayout` from AWT by using `View.setVisible` to
    show one of the children while hiding all the others (this is effectively how
    `TabHost` works).
  prefs: []
  type: TYPE_NORMAL
- en: As `FrameLayout` actually paints all of its visible children, it can be used
    to layer the child widgets on top of each other. It produces very strange effects
    in some cases, while in other cases it can be amazingly useful. For example, darkening
    out all of the widgets except one can be achieved by using a semi-transparent
    `View` object and a `FrameLayout`. The inactive widgets are the first layer in
    the `FrameLayout`, a semi-transparent `View` object is the second, and the active
    widgets are the third.
  prefs: []
  type: TYPE_NORMAL
- en: Common uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common use of `FrameLayout` is probably in combination with `TabHost`—to
    hold the content `View` objects for each tab. You can also use it to simulate
    a more desktop feel, by layering widgets on top of each other. It can also be
    used very effectively in games, to display the in-game menu, or draw an animated
    background behind the game's main menu.
  prefs: []
  type: TYPE_NORMAL
- en: By combining a `FrameLayout` object with widgets that also take up the entire
    screen, you can make use of the `gravity` attribute to place objects more precisely
    on top of other widgets. For this, you'll generally want each of the `FrameLayout`
    children to be a `ViewGroup` of some sort, since they generally don't paint in
    a background unless told to (leaving the lower layers visible).
  prefs: []
  type: TYPE_NORMAL
- en: A `FrameLayout` is also capable of displaying a `foreground`. While all `View`
    objects have a `background` attribute, `FrameLayout` includes a `foreground` (which
    is also an optional `Drawable`). The `foreground` will be painted on top of all
    of the child widgets, allowing a "frame" to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – developing a FrameLayout example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To really understand what a `FrameLayout` does, and how it can be used, it's
    best to kick it around a bit with an example. In this example, we'll use a `FrameLayout`
    to layer some `Button` widgets on top of an `ImageView`, and show-and-hide a `TextView`
    message when one of the buttons is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: For this example to work, you're going to need an image to serve as a background
    image. I'm going to use a photo of one of my friends. As always, place your image
    in the `res/drawable` directory, and try to use a PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layout resource file named `res/layout/frame_layout.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element as a `FrameLayout` consuming all available space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `FrameLayout`, create an `ImageView` to serve as the background
    image. It should scale to fill all the available space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a vertical `LinearLayout` where we will place two `Button` objects
    at the bottom of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Button` that we will use to toggle one of the child layers of our
    `FrameLayout` (creating a dialog-like effect):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another `Button` to quit the demo and go back to the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `</LinearLayout>`, create a final `TextView` element that we will
    show and hide when the first button is clicked. By default it''s hidden:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `FrameLayoutActivity` Java class in the root package of your project,
    and open the source file in your editor or IDE. The new class needs to extend
    from `Activity` and implement the `OnClickListener` class (for events from those
    two `Button` widgets):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the `super.onCreate` method to get the `Activity` code working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the content layout to the `frame_layout` resource you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the `overlay Button` widget you declared in the `frame_layout` resource
    file and create a reference to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set its `OnClickListener` to the new `FrameLayoutActivity` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the `quit Button` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then set it''s `OnClickListener` to the `FrameLayoutActivity` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OnClickListener` interface requires us to implement an `onClick` method
    with the following signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `switch` statement on the ID of the `View` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `View` clicked by the user widget is the `overlay_button Button`, then
    use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the `overlay View` object from the layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Toggle its visibility according to its current state, then `break` from the
    switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `View` clicked by the user widget is the `quit Button`, then use the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the `finish()` method, and `break` from the `switch` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `LayoutSelectorActivity` Java source in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onListItemClick` method, create a new `case` in the `switch` statement,
    for `position` value `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `FrameLayoutActivity` using an explicit `Intent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `AndroidManifest.xml` file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the new `FrameLayoutActivity` to the manifest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new `FrameLayoutActivity` makes use of a simple three layer `FrameLayout`.
    We use an `ImageView` object to draw a nice background image, on top of which
    we placed our two buttons. While the third layer (the `TextView` widget) is invisible
    until the top button is clicked, it's important to note that not only is the background
    of the top `TextView` transparent, it also delegates click events to widgets that
    are technically underneath it (the `TextView` has a widget and height that consumes
    the entire `FrameLayout`). This will continue to work, even if the background
    of the `TextView` is opaque. It has more to do with the fact that the `TextView`
    is not "clickable". If you would have added an `OnClickListener` to the `overlay
    TextView` object, the button underneath it would have stopped working. This means
    you need to be careful how you layer widgets in a `FrameLayout` (although so long
    as one widget doesn't take up the same space as another, this won't become a problem
    for you).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added a **Quit** button to the layout, and used the `finish()`
    method to close the `Activity` when the `Button` was clicked. You'll find that
    you generally don't use the `finish()` method directly since the user will mostly
    be moving forward through your application. If a user wants to go back, they will
    most often use the hardware "Back" button, or press the hardware "Home" button
    to exit your application entirely.
  prefs: []
  type: TYPE_NORMAL
- en: A final note on the above example—in the `frame_layout.xml` file, we declare
    the `overlay` as a `TextView` widget. However, in the Java code we access it using
    the `View` class instead of `TextView`. This is a simple case of decoupling. Unless
    you're working in a performance-centric piece of code, it's a good idea to reference
    your layout widgets as high up the class-tree as possible. This will allow you
    to modify your user interface much more quickly later on. In this case, you could
    change the simple `TextView` to an entire `LinearLayout` without the need to change
    the Java code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Following are two screenshots of the `FrameLayout` example, with and without
    the `overlay TextView` enabled. This sort of layout is perfect for use in a game
    menu or a similar structure where you need to layer different widgets on top of
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_05_01b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Table Layout` arranges its children in a HTML-style grid. It's a bit like
    the AWT `Grid Layout` class, but with much more flexibility. Unlike most other
    layout classes in Android, `Table Layout` uses its own specialized direct-child
    `View` class, named `Table Row`. The `Table Layout` class also doesn't allow you
    to define the number of rows or columns (making it far more like an HTML `<` `table>`
    element). Instead, the number of rows and columns is calculated by the number
    of widgets in the `Table Layout` and its `Table Row` children.
  prefs: []
  type: TYPE_NORMAL
- en: A cell in a `Table Layout` may consume any number of rows and columns, although
    the default for a `View` placed inside a `Table Row` is to take up exactly a single
    table cell. However, if you place a `View` as a direct child of a `Table Layout`,
    it will consume an entire row.
  prefs: []
  type: TYPE_NORMAL
- en: '`Table Layout` is also a relative layout structure, which is vitally important
    when working with Android devices. Being able to align everything based on grid
    lines allows your user interface to scale from the lowest resolution on a tiny
    phone, to a high-density screen on a 7-inch tablet.'
  prefs: []
  type: TYPE_NORMAL
- en: The `android:gravity` attribute comes into play far more in a `Table Layout`
    than in many of the other layout classes. What looks great on a small screen may
    look completely different on a large screen, not due to the size of the screen,
    but instead due to the scaling of the fonts used. Be careful, especially with
    the vertical alignment of labels and widgets. The easiest way to start with this
    is to vertically center all of your table widgets, and work from there. Be sure
    to test any table based layout on a variety of screen resolutions and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Common uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most commonly you'll find yourself using a `Table Layout` to arrange input form.
    It's also useful for laying out complex information, especially when making some
    `View` objects span several rows and columns. The most important trait of `Table
    Layout` comes from the fact that it aligns its cells in a very strict manner,
    and the fact that its a relative-size layout.
  prefs: []
  type: TYPE_NORMAL
- en: A `Table Layout` can also be used to achieve an effect similar to the AWT `Border
    Layout` class. Generally, when sizing a `Table Layout` to fit the entire screen,
    it becomes a very different tool to a simple grid, allowing you to fit a `Scroll
    View` in the middle of the control widgets.
  prefs: []
  type: TYPE_NORMAL
- en: By using a `Table Layout` inside a `FrameLayout`, you can arrange a control
    `View` on top of a content `View` (think of the controls in Google Maps). Also,
    try to bear in mind that unlike an AWT `GridLayout`, the size of a `View` inside
    a `TabelLayout` is not attached to size of the table-cell in which it is placed.
    By making use of the `gravity` attribute (and possibly a layout margin), you can
    place a `View` object within the table-cell, leading to layouts that are far more
    user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Using TableLayout for a memory game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the `TableLayout`, I thought it would be fun to write a simple
    memory-card game. You're presented with a grid (in the form of a `TableLayout`)
    of "cards" which you can touch to effectively turn over. You can then attempt
    to match all these cards, with the contents that are displayed on the cards (you're
    only allowed to turn over two at a time). For this example, you'll need some images
    to place on the cards (I've re-used the fruit icons from the delivery example).
    In this application, we'll also be creating a simple placeholder image, in the
    form of an XML file.
  prefs: []
  type: TYPE_NORMAL
- en: To create the placeholder image, create a new XML resource in the `res/drawable`
    directory, named `line.xml`. This will be a "shape" resource. Shape resources
    are very useful for creating simple, scalable shapes. Also, shape resource files
    can make use of any color, texture, or gradient which you can provide from your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following code into the `line.xml` file in order to create the simple
    placeholder image for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – developing a simple memory game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike almost all previous example, we'll generate the layout entirely in Java
    code in this game. The main reason for this is that the content is highly repetitive,
    each cell containing almost exactly the same widget. We use a `TableLayout` to
    create the grid, and display the "cards" in `ImageButton` widgets. To encapsulate
    the individual card behavior, we create a `MemoryCard` inner-class which holds
    a reference to the `ImageButton` it controls.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class in the root package of your project, and name it `TableLayoutActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the new class extend `Activity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You''ll need a timer in order to flip cards back over, so declare a `Handler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an array of `MemoryCard` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We either have one or two cards turned over (that we want to keep track of).
    Declare a placeholder for the first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there are two cards turned over, but they don''t match, we disable touch
    with a simple `boolean` switch (our event listeners will check this):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now declare an inner class named `MemoryCard` which implements the `OnClickListener`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MemoryCard` class holds a reference to an `ImageButton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MemoryCard` class also has a value, which is a reference to the image
    resource on its face:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, a `MemoryCard` uses a `boolean` value to remember its state (whether
    the face image, or the placeholder image is visible):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a constructor for the `MemoryCard` class, it only needs to take the
    resource identifier for the face image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the `faceImage` resource identifier for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `ImageButton` object, using the `TableLayoutActivity` object as
    its `Context` (which the `ImageButton` will use to load the images):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the size of the `ImageButton` to a fixed 64 x 64 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the scale-type so that icons are made to fit into the `ImageButton`, then
    set the image to the placeholder resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the `MemoryCard` object as the `OnClickListener` of the `ImageButton`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For convenience later on, the `MemoryCard` needs a `setFaceVisible` method,
    which will toggle between showing the placeholder and the `faceImage` resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `onClick` method in the `MemoryCard` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, make sure that the face isn''t currently visible (so we''re turned down),
    and that touch is enabled (and some other cards aren''t about to be turned face-down
    again):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If these conditions are met, we tell the `TableLayoutActivity` that we''ve
    been touched and want to be turned face-up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `MemoryCell` inner class, create a simple utility method in the `TableLayoutActivity`
    to create an ordered array of `MemoryCell` objects with a specific size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we create each of the `MemoryCell` objects, we create them in pairs, and
    in the same sequence as was specified in our array of icon resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When complete, return the new array of `MemoryCell` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now override the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the `Activity.onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a new `TableLayout` object, passing it the `TableLayoutActivity`
    as a `Context` for loading styles and resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, we create a four-by-four grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we shuffle it to randomize the order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create each of the required `TableRow` objects, and populate it with the `ImageButtons`,
    created by the `MemoryCard` objects in the grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `Activity` content view to the `TableLayout` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we write the `onMemoryCardUncovered` method, which is called by the `MemoryCard.onClick`
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, check to see if there is a currently `visible MemoryCard`, if not, the
    card touched by the user is turned face-up and we remember it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there is already a face-up card, check to see if they have the same image.
    If the images are the same, disable the `ImageButton` widgets so we ignore the
    events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if the face images don''t match, we turn the card touched by the user
    face-up and flip our `touchEnabled` switch so that the `MemoryCard` objects will
    ignore all other touch events for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we post a delayed message on our `Handler`, which will turn both cards
    face-up again and re-enable touch events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, it should be obvious to see why we wrote the layout
    code manually, building it in an XML file would have been terribly repetitive.
    You'll notice that the code creates a `TableRow` object as the direct children
    of the `TableLayout`, just as we would have in an XML file.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` method of `MemoryCard` uses the `touchEnabled` switch to determine
    whether or not to call `onMemoryCardUncovered`. However, neither does this stop
    the user from pressing the `ImageButton` objects, nor does it stop the objects
    from responding to the user (although they won't turn over). For a more user-friendly
    experience, it would be better to use the `setClickable` method on each of the
    enabled `ImageButton` objects, to stop them completely from reacting to the user's
    touch.
  prefs: []
  type: TYPE_NORMAL
- en: When we create the `ImageButton` objects, we pre-size them at 64 x 64 pixels.
    While this is fine for the big emulator screen, there are plenty of devices that
    wouldn't fit the 4 x 4 grid of buttons on the screen. I would recommend you use
    an XML resource to create the `ImageButton` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code uses `setLayoutParams(new TableRow.LayoutParams(64, 64));`
    to set the size of the `ImageButton` objects. It''s important to note that because
    we are placing the `ImageButton` objects into a `TableRow`, their `LayoutParams`
    must be of the type `TableRow.LayoutParams`. If you try changing to a generic
    `ViewGroup.LayoutParams`, then the user interface won''t layout (it''ll just be
    blank). Following are two screenshots of the working application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened](img/4484_05_03b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TableLayout` example works great, but the location of the grid isn't great
    (on the top left of the screen), and having it against a black background is quite
    dull. Time to make it look great!
  prefs: []
  type: TYPE_NORMAL
- en: Start by using a `FrameLayout` to add a background image to the game. This will
    enhance the overall appeal of the game by adding more color. You should also take
    this opportunity to center the grid on the screen. Having it in the top left makes
    it look lopsided somehow.
  prefs: []
  type: TYPE_NORMAL
- en: You should also try removing the `touchEnabled` switch, instead using `setClickable`
    on each of the `ImageButton` objects. This will stop them from providing a visual
    "press and release" feedback when you're about to turn cards face-down.
  prefs: []
  type: TYPE_NORMAL
- en: AbsoluteLayout/Custom Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Do not use AbsoluteLayout! AbsoluteLayout is Deprecated!** That said, there
    are times when using the `AbsoluteLayout` class makes sense. So why shouldn''t
    you use the `AbsoluteLayout` class, and where should you use it? The answer to
    the first question is very simple—all of the child widgets of an `AbsoluteLayout`
    have their locations specified exactly, they don''t change size or location on
    different screens. It also makes your layout almost impossible to re-use (for
    example, importing it into another layout, or embedding it into another application).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re going to work with an `AbsoluteLayout`, you should approach it in
    either one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Carefully build a separate layout XML for each different screen size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write your layout data in Java code instead of XML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first is impractical unless you specify that the application only runs on
    specific devices, and the layout cannot be used outside of your application. The
    second option however, opens up the "right" way—write a custom layout manager.
    Since `AbsoluteLayout` requires strict locations, and doesn't allow easy interaction
    with the measuring of child `View` objects, the best way to define layouts that
    don't fit well into any of the over layout classes is to define a custom layout
    in your own `ViewGroup` class.
  prefs: []
  type: TYPE_NORMAL
- en: Developing your own Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `AbsoluteLayout` is deprecated, and yet many people seem to insist on
    using it, this example will be to demonstrate not just how easy it is to write
    your own `ViewGroup` class defining a new layout, but also how easy it is to then
    integrate that layout into a layout XML resource. This will thus prove that there
    is no compelling reason to use an `AbsoluteLayout` (unless it really makes sense).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a custom layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To really demonstrate the use of a custom layout, you need to try building something
    unusual. In the following example, you'll put together a `ViewGroup` that arranges
    its children in a nice circle. It's not a very brilliant layout, nor is it particularly
    useful, but circles are nice to look at, and it would provide useful negative
    space in the screen center (which could be filled using a `FrameLayout`).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java source file in the root package of the project named `CircleLayout.java`,
    and open it in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the `CircleLayout` as extending the `ViewGroup` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the three `ViewGroup` constructors and have them delegate directly
    to the `ViewGroup` default constructors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll need to know the largest number of pixels taken up by a child `View`
    object''s width, and the largest number of pixels taken up by a child `View` object''s
    height. To avoid unnecessary overhead, we take this opportunity to `measure` the
    child `View` objects as well. Declare a utility method named `measureChildrenSizes`
    to perform these two operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `int` to hold the maximum width and height we find:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `for` loop to iterate over each of the child `View` objects in this
    `CircleLayout` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a reference to `View` at the current index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a layout widget, your class will be responsible for setting the display
    size for all of it''s child widgets. In order to know a child widget''s desired
    width and height, you need to use the `measureChild` method in the `ViewGroup`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the width and height of the child `View` object against the maximum width
    and height variables you created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the method, return an array containing the maximum width and
    height found during the procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `onLayout` method of `ViewGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the width and height of our available space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable to hold the number of child `View` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform the measurement of all child `View` objects against the amount of available
    space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Subtract the maximum width and height from the available space so that all
    the child `View` objects will fit on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the center point in the `CircleLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `for` loop to iterate over each of the child `View` objects again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable to hold the current child `View` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `x` and `y` locations of the child `View` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the layout method of the child `View` object with the calculated coordinates
    in the circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CircleLayout` class is a very simple implementation of a `ViewGroup`. Except
    for the requested width and height of its children, it has no special attributes
    that can be used in an XML resource. However, it will take notice of the sizing
    that you declare for its children, and so the `layout_width` and `layout_height`
    attributes will work normally.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that in order to make use of a custom `View` or `ViewGroup`
    from a layout XML resource, you need to have all three default constructors overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `LayoutInflater` will make use of one of these constructors to create instances
    of your class. If the one it wants to use isn't in place, you will get the dreaded
    **Force Close** dialog when you try and inflate the layout XML file.
  prefs: []
  type: TYPE_NORMAL
- en: The `CircleLayout` has its own utility method to handle the measuring of its
    child `View` objects. Generally, a `ViewGroup` would use the `V` `iewGroup.measureChildren`
    utility method to see that all of its child `View` objects are measured before
    performing the actual layout. However, we need to iterate over the list of child
    `View` objects in order to find the largest used width and height, so instead
    of performing the iteration three times, we perform the measurements ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CircleLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make use of your custom `ViewGroup` implementation, it''s good to know that
    Android has you covered as far as the XML layout resources are concerned. When
    you need to reference a custom `View` or `ViewGroup` class from an XML layout
    resource, you simply use the full class name instead of the simple class name.
    The following is a simple example of an XML layout that uses the `CircleLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – finishing the CircleLayout example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've got the `CicleLayout` implementation, but we should really include it
    in our "layouts" example now. To do that we'll need a layout resource XML file,
    a new `CircleLayoutActivity` class. We also need to register the new `Activity`
    with both, Android (in the manifest file), and with our `LayoutSelectorActivity`
    class (in its event listener).
  prefs: []
  type: TYPE_NORMAL
- en: Copy the preceding XML layout into a new file named `res/layout/circle_layout.xml`.
    It works best with around ten widgets added as children of the `CircleLayout ViewGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java source file in the root package of your project named `CircleLayoutActivity.java`.
    Open this in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CircleLayoutActivity` must extend the `Activity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onCreate` method of `Activity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the super class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the content view to the `circle_layout` layout resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `AndroidManifest.xml` file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the `TableLayoutActivity` declaration, declare the new `CircleLayoutActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `LayoutSelectorActivity` source file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onListItemClick` method, before the `default case`, add a new `case`
    statement to start the `CircleLayoutActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have a new `Activity` implementation that uses your own customized `ViewGroup`
    implementation. Custom `ViewGroup` classes are not just useful when you have a
    hard-to-express layout that the standard `ViewGroup` implementations don't handle
    very well. A custom `ViewGroup` is also an option when the default `ViewGroup`
    implementations are too slow for a particular structure that you want to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The "layouts" example that you've been building in this chapter will now have
    a working **Custom Layout** menu item. Click it and you'll be presented with the
    following screenshot. Try adding widgets other than `Button` objects, and maybe
    even try throwing in a child `ViewGroup` and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layout generally happens in two phases, what's the first phase called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pre-layout
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parent layout
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Measurement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the four parameters of the layout method signify?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: x, y, width, and height.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Left, top, right, and bottom.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The size of the parent `ViewGroup`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a custom `ViewGroup` implementation read layout XML attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are injected into setters by the `LayoutInflator`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They are loaded with the `View.getAttribute` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They read it from the `AttributeSet` object passed into the `ViewGroup` constructor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: RelativeLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RelativeLayout` class is arguably the most powerful layout that Android
    provides. It's a relative layout, managing widgets of varying sizes, and aligning
    widgets against each other instead of against their parent or grid-lines. In some
    ways, `RelativeLayout` has a striking resemblance to the Swing `GroupLayout` class,
    although it is nowhere near as complex. Each widget in a `RelativeLayout` is positioned
    against either another widget, or against its parent (the `RelativeLayout` itself).
  prefs: []
  type: TYPE_NORMAL
- en: '`RelativeLayout` calculates the location of each child in a single loop, so
    it relies strongly on the order in which you specify the children. However, this
    doesn''t mean that you must specify the widgets in the order they are displayed
    on the screen. Due to the nature of a `RelativeLayout`, the child widgets are
    often declared and displayed in a different order. This also requires that any
    user interface element used for aligning other widgets must have an ID assigned
    to it. This includes even non-interactive user interface elements which would
    normally not need an ID, must now be assigned one, even though they will never
    be used outside of the layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `RelativeLayout` is extremely flexible, but may also require some careful
    planning. As with any user interface, it helps enormously to draw the layout on
    paper first. Once you have a paper diagram, you can start to plan how you will
    build the layout according to the rules specified by the `RelativeLayout` class.
  prefs: []
  type: TYPE_NORMAL
- en: Common uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The uses of `RelativeLayout` are very similar to those of `TableLayout`. It's
    great for drawing up forms and content views. However, `RelativeLayout` is not
    confined to the grid pattern of `TableLayout`, and can therefore create relationships
    between widgets that are physically far away from each other on the screen (that
    is, by aligning them with each other).
  prefs: []
  type: TYPE_NORMAL
- en: '`RelativeLayout` positions and sizes a widget either according to other widgets
    in the same `RelativeLayout`, and/or according to the boundaries of the `RelativeLayout`
    itself. This means some widgets may be placed at the top of the screen, and you
    can align another group of widgets at the bottom of the screen, as shown in the
    following diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Common uses](img/4484_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Integrating the RelativeLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When faced with a contact editor, a `RelativeLayout` is the perfect tool to
    produce an easy-to-use user interface. For the next example, we build a very simple
    contact editing user interface including an image of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a contact editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example requires that some of the user interface elements are declared
    out-of-order (as discussed earlier). We'll also include **Save** and **Cancel**
    `Button` widgets at the bottom of the screen. This example goes back to declaring
    the user interface in a resource XML file rather than writing it in Java code.
    For this example, you'll need a placeholder image for the user's contact photo.
    A 64 x 64 pixel PNG file is about the right size to work with (I used a big smiley
    image).
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new XML layout file named `res/layout/relative_layout.xml`.
    Open this file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element as a full-screen `RelativeLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `ImageButton` that will have an icon of the user on it. The `ImageButton`
    should be aligned to the top-left of the screen, and have a place-holder image
    in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `EditText` where the user can type a contact''s name. Align this to
    the right bottom of the `ImageButton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a `TextView` to act as a label for the `EditText` widget. We align
    this to the right of the `ImageButton`, but above the `EditText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll need an **Edit** `Button` to allow the user to edit the list of phone
    numbers for the contact. Position this on the right side of the screen, and below
    the `EditText`. We add a margin at the top of this `Button` to give a logical
    separation in the user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a nice big `TextView` as a label to the phone numbers, which we will
    list below the new `TextView` and **Edit** `Button`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a `TableLayout` to hold a list of the contact person''s phone numbers,
    center-align this `TableLayout` in the `RelativeLayout`, and position it below
    the **Contact Numbers** label with a slight margin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two `TableRow` elements with some dummy content to the `TableLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the **Save** `Button` positioned at the bottom-left of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a **Cancel** `Button` positioned at the bottom-right of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the user interface elements in the previous example are declared in
    an order that is contrary to the logical layout order, while others are positioned
    relative to the `RelativeLayout` itself and can therefore be placed anywhere in
    the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: The **Contact Name** label and editor are positioned relative to the "contact
    photo", which in turn is relative to the screen (or `RelativeLayout`). However,
    because we want the label to appear directly above the editor, we need to declare
    and position the `EditText` element before the `TextView` element.
  prefs: []
  type: TYPE_NORMAL
- en: The **Contact Name** `EditText` element uses a width of `fill_parent`, which
    in a `RelativeLayout` simply fills the available horizontal space (or vertical
    space if it's used on a widget's height). This is a useful feature when you want
    an element to simply consume the rest of a "line", or span across the entire screen
    (that is, for a dividing line). In a `RelativeLayout` you cannot use two layout
    attributes that conflict with the same axis of a widget. For example, you use
    the `layout_toRightOf` and `layout_alignRight` on the same `View` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – integration with the layout example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The integration of the `RelativeLayout` example is almost identical to the integration
    of the custom `CircleLayout` example that you wrote earlier. Integration will
    require a new `Activity` implementation, and then we need to register it with
    Android and the `LayoutSelectorActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java source file in the root package of the "layouts" example project,
    named `RelativeLayoutActivity.java`. Open this in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new `RelativeLayoutActivity` needs to extend the `Activity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the `super` class to set up its state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the content view of the new `Activity` to the `relative_layout` XML layout
    resource created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `AndroidManifest.xml` file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register `RelativeLayoutActivity` after `CircleLayoutActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `LayoutSelectorActivity` Java source code in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onListItemClick` method, declare a new `case` statement before the
    `default` statement and start the new `RelativeLayoutActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the `RelativeLayoutActivity` is integrated with the rest of the layout
    example, you can fire up the emulator and take a look at the screen you just built.
    As you can see in the following screenshot, this design is much more user-friendly
    than most of the other designs we've built so far. The main reason for this is
    the ability to group and align widgets in ways that logically relate to each other,
    rather than being forced to confine to the requirements of the chosen `ViewGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this flexibility doesn't come without a price. The `RelativeLayout`
    structures are far more easily broken than other `ViewGroup` implementations,
    and in many cases won't offer you much additional flexibility. In the preceding
    example, we embedded a `TableLayout` to display the list of contact numbers instead
    of displaying them directly under the `RelativeLayout` element. Not only is `TableLayout`
    better suited to this task, but it also allows us to center-align the numbers
    as a single group instead of aligning them to the left and right of the `RelativeLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RelativeLayout` combined with either an embedded `ScrollView` or a `FrameLayout`
    is a brilliant way of providing toolbars for more content-centric user interfaces.
    When you have a media-centric user interface (with full-screen maps, video, photos,
    or something similar), using a `RelativeLayout` to arrange the tool buttons around
    the outside of the screen and then placing the actual content behind it with a
    `FrameLayout` works extremely well as can be seen in many Android applications
    such as Google Maps or the default browser application. This design also allows
    you to show or hide the tool buttons based on the user''s interaction with the
    application, giving them a better view of the media content when they are not
    interacting with the toolset.'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SlidingDrawer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've used an un-themed Android installation (such as the emulator), or
    most themed versions of Android, then you've used a `SlidingDrawer`. It's the
    widget that drives the opening and closing of the launcher menu. While it is not
    exactly a layout in its own right, a `SlidingDrawer` allows you to make a large
    number of lesser-used widgets very quickly available to the user. This makes it
    an important widget to consider when developing a new user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it'll be a decision between using a menu and a `SlidingDrawer`. While
    a menu is great for displaying action items, a `SlidingDrawer` can display any
    content you want. However, a `SlidingDrawer` also has some restrictions on its
    use. For example, it requires that you place it within a `FrameLayout` or `RelativeLayout`
    instance (of which `FrameLayout` is far more typical) in order to function correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A `SlidingDrawer` is in some ways a form of disclosure widget. It consists of
    a handle and content. By default, only the handle is visible on the screen, until
    the user touches or pulls the handle to open the `SlidingDrawer` and display the
    content section.
  prefs: []
  type: TYPE_NORMAL
- en: Common uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The open/close content nature of the `SlidingDrawer` class makes it ideal for
    the application launcher in Android. By default, it is hidden away so the desktop
    is visible and usable, until you tap the handle in order to view the list of available
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: This also makes `SlidingDrawer` a brilliant tool for building applications such
    as strategy games. Instead of giving your user all the available build options
    (for example), restrict the default screen view to the key map elements. When
    they want to build something, or check some status information, they can tap or
    drag open a `SlidingDrawer` from the bottom of the screen, revealing all the build/command
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, when you have actions or information that the user won't need to
    interact often with, a `SlidingDrawer` is a great way to present it. It can also
    be opened and closed from your Java code when key events that require the user's
    attention occur.
  prefs: []
  type: TYPE_NORMAL
- en: The handle element of the `SlidingDrawer` is also a full `View` or `ViewGroup`,
    which allows you to put status messages in it. Another common use of the `slidingdrawer`
    widget is that the status bar at the top of most Android devices is often implemented
    as a `SlidingDrawer`. A summary is displayed on the handle when an event occurs,
    and the user can drag open the content to view the complete details of the most
    recent events.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SlidingDrawer example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep the `SlidingDrawer` example nice and simple, we're going to re-use the
    `CircleLayout` example with one main modification—the background color needs to
    change. If the background of a `SlidingDrawer` is not specifically set, the background
    will be transparent. Generally, this is undesirable since the content behind the
    open `SlidingDrawer` widget is then visible, and interferes with the content of
    the `SlidingDrawer`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a SlidingDrawer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we'll be placing a `SlidingDrawer` widget on top of an image
    (I've once again chosen a photo of one of my friends as my background). For the
    handle of the `SlidingDrawer`, we'll make use of the line drawable XML file that
    was created for the `TableLayoutActivity`. For the content of the `SlidingDrawer`,
    we'll make use of the `circle_layout` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `res/layout/circle_layout.xml` file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the root element declaration, set the background attribute to black:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new layout resource file named `sliding_drawer.xml`, and open this
    file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of this layout as a `FrameLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `FrameLayout`, create an `ImageView` to contain the background image.
    Remember to set the scale-type and size so the image fills the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `SlidingDrawer` widget. You''ll need to forward-reference the handle
    and content widgets since they don''t exist yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `SlidingDrawer` element, create an `ImageView` with the placeholder
    `line` drawable resource that you created for the `TableLayoutActivity` earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also inside the `SlidingDrawer` element, include the `circle_layout` layout
    resource, assigning its ID as "content":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll notice that in the previous example, the `SlidingDrawer` adds the ID
    references to its handle and content widgets, while the widgets themselves appear
    to access these IDs instead of declaring them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This is a side effect of how the `SlidingDrawer` class works. it needs the ID
    values before it needs the widgets themselves. This technique is much like a forward-reference,
    except the object is not technically created. The `@+` syntax tells the resource
    compiler that we are creating a new id, but not a new object. When we later declare
    the `ImageView` element using the `@id/handle` value as its `id`, we are in fact
    referencing the value that was generated when we declared the `SlidingDrawer`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sliding drawer integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to plug the `SlidingDrawer` example into the "layouts" example.
    This, like all the other integrations, involves a new `Activity`, and registering
    the new `Activity` with Android and `LayoutSelectorActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java source file in the root package of the "layouts" example project
    named `SlidingDrawerActivity.java`. Open this in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new `SlidingDrawerActivity` needs to extend the `Activity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the super class to set up its state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the content view of the new `Activity` to the `sliding_drawer` XML layout
    resource created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `AndroidManifest.xml` file in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register the `SlidingDrawerActivity` after the `RelativeLayoutActivity` is
    declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `LayoutSelectorActivity` Java source code in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onListItemClick` method, declare a new `case` statement before the
    `default` statement and start the new `SlidingDrawerActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've just completed all of the layout examples in this chapter. The `default`
    condition in your `switch` statement should never trigger again! The `SlidingDrawer`
    example is very simple, but demonstrates well how versatile this widget can be.
    If this example was (for instance) a paint application, the `SlidingDrawer` would
    be the perfect place to hide a list of the more complex painting functions available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handle of this `SlidingDrawer` example is a simple `ImageView`, but it
    can be any `View` or `ViewGroup` (a `TableLayout`, if you wanted). However, you
    want to avoid the handle becoming interactive (that is, a `Button` or `EditText`
    widget). An interactive widget in the handle will cause problems when the user
    touches it. Although the widget remains fully functional, and can be dragged up
    and down like a handle, touching it to start an interaction will cause the `SlidingDrawer`
    to open or close itself. To stop this from happening, you can optionally turn
    the "touch to toggle" option of the `SlidingDrawer` off with the `allowSingleTap`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: That said, having an `EditText` (or similar) as a handle for a `SlidingDrawer`
    makes very little sense, and is likely to make your users rather irritated with
    you. As far as possible, you should make sure that the handle of your `SlidingDrawer`
    widgets looks like something the user can drag. The default handle of the launcher
    application is a great example.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working through the examples in this chapter should have given you a good look
    into the layouts that are available by default in Android, as well as a look at
    how they are implemented (and how new ones can be implemented when needed). In
    most cases, these `ViewGroup` implementations will serve any layout needs you
    have, but it remains important to keep the following principals in mind when building
    Android layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: Different devices have different size and resolution screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use negative space (white space) and lines to separate groups of widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will almost certainly need to modify the layout in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That last point is particularly important when choosing to use the `RelativeLayout`
    class. While it offers your far more power than the other implementations, a badly
    put-together `RelativeLayout` can be very difficult and time consuming to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapter, we'll take a look at how capturing input, and the validation
    of that input should be taken as a user interface design decision. We'll also
    work through some examples that can be used as a foundation for future user interface
    developments.
  prefs: []
  type: TYPE_NORMAL
