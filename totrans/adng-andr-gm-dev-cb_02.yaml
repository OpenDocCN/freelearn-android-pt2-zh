- en: Chapter 2. Working with Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to start getting into displaying objects on the
    screen and various ways we can work with these objects. The topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AndEngine entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying primitives to a layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing a scene to life with sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying text to a layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using relative rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the `onManagedUpdate` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modifiers and entity modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to start working with all of the wonderful entities
    included in AndEngine. Entities provide us with a base foundation that every object
    displayed within our game world will rely on, be it the score text, the background
    image, the player's character, buttons, and everything else. One way to think
    of this is that any object in our game which has the ability to be placed, via
    AndEngine's coordinate system, is an entity at its most basic level. In this chapter,
    we're going to start working with `Entity` objects and many of its subtypes in
    order to allow us to make the most out of them in our own games.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AndEngine entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AndEngine game engine follows the **entity-component** model. The entity-component
    design is very common in a lot of game engines today, and for a good reason. It's
    easy to use, it's modular, and it is extremely useful in the sense that all game
    objects can be traced back to the single, most basic `Entity` object. The entity-component
    model can be thought of as the "entity" portion referring to the most basic level
    of the game engine's object system. The `Entity` class handles only the most basic
    data that our game objects rely on, such as position, rotation, color, attaching
    and detaching to and from the scene, and more. The "component" portion refers
    to the modular subtypes of the Entity class, such as the `Scene`, `Sprite`, `Text`,
    `ParticleSystem`, `Rectangle`, `Mesh`, and every other object which can be placed
    within our game. The components are meant to handle more specific tasks, while
    the entity is meant to act as a base foundation that all components will rely
    on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with the absolute most basic `Entity` method, we will attach an `Entity`
    object to a `Scene` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating and attaching an `Entity` object to the `Scene` object requires only
    the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two lines of code given here allow us to create and attach a basic `Entity`
    object to our `Scene` object. An `Entity` object that is defined as seen in the
    *How to do it...* section of this recipe will most commonly be used as a layer.
    The purpose of a layer will be discussed in the coming paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Entities are very important when developing games. In AndEngine, the fact of
    the matter is that all objects displayed on our scenes are derived from entities
    (including the `Scene` object itself!). In most cases, we can assume that the
    entity is either a visually displayed object such as a `Sprite`, `Text`, or `Rectangle`
    object on the scene, or a layer, such as the `Scene` object. Seeing as how broad
    the `Entity` class is, we're going to talk about each of the two uses for entities
    as if they were separate objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and arguably most important aspect of an entity is the layering capabilities.
    A layer is a very simple concept in game design; however, due to the amount of
    entities games tend to support during gameplay, things can quickly become confusing
    when first getting to know them. We must think of a layer as an object which has
    one parent and an unlimited amount of children unless otherwise defined. As the
    name suggests, the purpose of a layer is to apply our various entity objects on
    our scene in an organized fashion, which fortunately also gives us the ability
    to perform one action on the layer that will affect all of its children in unison,
    for example, repositioning and applying certain entity modifiers. We can assume
    that if we have a background, a mid-ground, and a foreground, that our game will
    have three separate layers. These three layers would appear in a specific order
    depending on the order they are attached to the scene, as if stacking pieces of
    paper on top of each other. The last piece of paper added to the stack will appear
    in front of the rest if we were to look down on that stack of paper. The same
    rule applies for `Entity` objects attached to a `Scene` object; this is shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8987OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous image depicts a basic game scene consisting of three `Entity` object
    layers. Each of the three layers has a specific purpose, which is to store all
    relative entities in terms of depth. The first layer applied to the scene is the
    background layer, including a sprite, which contains a blue sky and a sun. The
    second layer applied to the scene is the mid-ground layer. On this layer, we would
    find objects which are relative to the player, including the landscape the player
    walks on, collectable items, enemies, and more. Lastly, we have the foreground
    layer, used to display the front-most entities on the device's display. In the
    figure shown, the foreground layer is used to display the user interface, which
    includes a button, and two `Text` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at what a scene might look like with layers with child
    entities attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8987OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This figure shows how a scene would display entities on the screen in terms
    of depth/layering. At the bottom of the figure, we've got the device's display.
    We can see that **Background Layer** is attached to the **Scene** first, then
    **Player Layer** is attached. This means that the entities attached to the background
    will be displayed behind the **Player Layer** children. Keeping this in mind,
    the rule applies to the child entities as well. The first child attached to the
    layer will appear behind any subsequently attached object as far as depth goes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, one last vital topic relating to general AndEngine entities is Entity
    composition. One thing we should go over before moving on is the fact that *children
    inherit parent values!* This is an area where many new AndEngine developers run
    into issues when setting up multiple layers in their games. Everything from skew,
    scale, position, rotation, visibility, and more are all taken into account by
    child entities when their parent''s properties change. Take a look at the following
    figure, which displays the entity''s **position** composition in AndEngine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/978-1-849518-98-7_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First of all, we should know that in AndEngine's anchor center branch, coordinate
    systems start in the bottom-left corner of an entity. Increasing the x value will
    move the entity position to the right, and increasing the y value will move the
    entity position upward. Decreasing x/y values will have the opposite affect. With
    this in mind, we can see that the bigger rectangle which is attached to the **Scene**
    has its position set to coordinates **(6, 6)** on the **Scene**. Since the smaller
    rectangle is attached to the bigger rectangle, rather than its coordinate system
    being relative to the **Scene**, it is actually using the large rectangle's coordinate
    system. This means that the small rectangle's anchor center position will rest
    directly on position **(0, 0)** of the large rectangle's coordinate system. As
    we can see in the previous image, the **(0, 0)** position on the large rectangle's
    coordinate system is its bottom-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main difference between the older AndEngine branches and AndEngine's newest
    anchor center branch is the fact that positioning an entity no longer means we
    are setting the upper-left corner of an entity to a position on the coordinate
    system. Rather, the entity's center-point will be placed at the defined position,
    also seen in the previous figure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Entity` object in AndEngine includes many different methods which affect
    many aspects of the entity. These methods play a vital role in shaping the overall
    characteristics of `Entity` objects regardless of the entity''s subtype. It is
    a good idea to get to know how to manipulate entities in order to take full control
    over how the entities appear, react, store information, and much more. Use the
    following list to familiarize yourself with some of the most important methods
    of the `Entity` object, paired with their corresponding getter methods. Methods
    missing from this list will be covered in more detail in this and the following
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setVisible(pBoolean)` and `isVisible()`: This method can be used to set whether
    or not the entity is visible on the scene. Setting these methods to `true` will
    allow the entity to render, setting them to `false` will disable rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setChildrenVisible(pBoolean)` and `isChildrenVisible()`: Similar to the `setVisible(pBoolean)`
    method, except that it defines the visibility of the calling entity''s children
    and not itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setCullingEnabled(pBoolean)` and `isCullingEnabled()`: Entity culling can
    be a very promising performance optimization technique. See *Disabling rendering
    with entity culling* in [Chapter 8](ch08.html "Chapter 8. Maximizing Performance"),
    *Maximizing Performance*, for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collidesWith(pOtherEntity)`: This method is used to detect when the entity
    that is calling this method collides, or overlaps, with the `Entity` object supplied
    as this method''s parameter. If the entities are colliding, this method returns
    `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setIgnoreUpdate(pBoolean)` and `isIgnoreUpdate()`: Ignoring entity updates
    can provide noticeable performance improvements. See *Ignoring entity updates*
    in [Chapter 8](ch08.html "Chapter 8. Maximizing Performance"), *Maximizing Performance*,
    for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setChildrenIgnoreUpdate(pBoolean)` and `isChildrenIgnoreUpdate()`: Similar
    to the `setIgnoreUpdate(pBoolean)` method, except that it only affects the calling
    entity''s children and not itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRootEntity()`: This method will iterate through the entity''s parent until
    it reaches the root parent. Once the root parent is found, this method will return
    the root `Entity` object; in most cases, the root being our game''s `Scene` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTag(pInt)` and `getTag()`: This method can be used for storing an integer
    value within an entity. Typically used for setting up identification values to
    entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setParent(pEntity)` and `hasParent()`: Sets the parent entity to the entity
    calling this method. The `hasParent()` method returns a `true` or `false` value
    depending on whether or not the calling entity has a parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setZIndex(pInt)` and `getZIndex()`: Set the `Z` index of the calling entity.
    Entities with a greater value will appear in front of entities with a lesser value.
    By default, all entities have a `Z` index of `0`, meaning that they simply appear
    in the order they are attached. See the following `sortChildren()` method for
    more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortChildren()`: This method must be called on the parent of an entity or
    group of entities which have had their `Z` index modified before changes take
    effect on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setPosition(pX, pY)` or `setPosition(pEntity)`: This method can be used to
    set the position of an entity to specific x/y values, or it can be used to set
    to another entity''s position. Additionally, we can use the `setX(pX)` and `setY(pY)`
    methods to make changes to only a single axis position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getX()` and `getY()`: These methods are used to obtain the position of an
    entity in local coordinates; that is, relation to its parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setWidth(pWidth)` and `setHeight(pHeight)` or `setSize(pWidth, pHeight)`:
    These methods can be used to set the width and height of the calling entity. Additionally,
    we can use the `getWidth()` and `getHeight()` methods, which return their respective
    values in as a float datatype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setAnchorCenter(pAnchorCenterX, pAnchorCenterY)`: This method can be used
    to set the anchor center of the entity. The anchor center is the position within
    an `Entity` object that it will rotate around, skew from, and scale from. Additionally,
    modifying the anchor center values will relocate the entity''s "positioning" anchor
    from the default center-point. For example, if we move the anchor center position
    to the upper-left corner of an entity, calling `setPosition(0,0)` would place
    the entity''s upper-left corner to position `(0,0)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setColor(pRed, pGreen, pBlue)` and `getColor()`: This method can be used to
    set the color of an entity, from values ranging from `0.0f` for no color through
    to `1.0f` for full color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUserData(pObject)` and `getUserData(``)`: These two methods are incredibly
    useful when developing games with AndEngine. They allow us to store an object
    of our choice within the entity and modify it or retrieve it at any point in time.
    One possibility for user data storage would be to determine what type of weapon
    a player''s character is holding. Use these methods to the fullest!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying primitives to a layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AndEngine''s primitive types include `Line`, `Rectangle`, `Mesh`, and `Gradient`
    objects. In this topic, we''re going to focus on the `Mesh` class. Meshes are
    useful for creating more complex shapes in our games which can have an unlimited
    amount of uses. In this recipe, we''re going to use `Mesh` objects to build a
    house as seen in the the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying primitives to a layer](img/978-1-849518-98-7_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the class named `ApplyingPrimitives` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a `Mesh` object, we need to do a little bit more work than
    what's required for a typical `Rectangle` or `Line` object. Working with `Mesh`
    objects is useful for a number of reasons. They allow us to strengthen our skills
    as far as the OpenGL coordinate system goes, we can create oddly-shaped primitives,
    and we are able to alter individual vertice positions, which can be useful for
    certain types of animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step involved in creating `Mesh` objects is to create our buffer
    data which is used to specify the points that will make up the shape of the mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the buffer data is configred to our liking, we can go ahead and create
    the `Mesh` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's break down the process a little bit more in order to find out just how
    we ended up with a house made out of primitive `Mesh` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step one, we''re creating the `baseMesh` object''s buffer data. This buffer
    data is used to store points in 3D space. Every three values stored in the buffer
    data, separated by line-breaks, make up a single vertice in the 3D world. However,
    it should be understood that since we are working with a 2D game engine, the third
    value, which is the `Z` index, is of no use to us. For that reason, we have defined
    the third value for each vertice as the `UNUSED` constant declared within this
    recipe''s class, which is equal to `0`. The points are represented as `(x, y,
    z)` for each triangle, as to not get the order confused. See the following figure
    for a representation of the how the points defined in step one will draw a rectangle
    onto a mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/978-1-849518-98-7_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous figure represents the `baseMesh` object''s buffer data, or plotted
    points, as seen in the *How to do it...* section''s first step. The black lines
    represent the first set of points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second set of points in the `baseMesh` object''s buffer data is represented
    by the grey lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since `BASE_HEIGHT` is equal to `200` and `BASE_WIDTH` is equal to `400`, we
    can read that the first triangle's first point, which is `(0, BASE_HEIGHT)`, is
    located in the upper-left corner of the rectangular shape. Moving clockwise, the
    second point for the first triangle is located at position `(BASE_WIDTH, BASE_HEIGHT)`,
    which would be the upper-right corner of the rectangular shape. A triangle is
    obviously made up of three points, so this leaves us with one more vertice to
    plot. The last vertice of our first triangle is located at position `(BASE_WIDTH,
    0)`. As a personal challenge, use the scene graph in the previous figure to find
    out how the grey triangle's plotted points compare to the buffer data!
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we are taking our `baseMesh` object's buffer data and using it
    to build the `Mesh` object. The `Mesh` object is a subtype of the `Entity` class,
    so once we have created the `Mesh` object, we can reposition it, scale it, rotate
    it, and and make any other adjustments we need. The parameters, in the order they
    appear in the constructor are as follows; x axis position, y axis position, buffer
    data, vertex count, draw mode, and vertex buffer object manager. The first two
    and last parameters are typical for all entities, but the buffer data, vertex
    count and draw mode are new to us. The buffer data is the array which specifies
    the plotted vertices, which was covered in step one. The vertex count is simply
    the number of vertices that the buffer data contains. Every x, y, and z coordinate
    within our buffer data makes up a single vertice, which is why we are dividing
    the `baseBufferData.length` value by three for this parameter. And finally, `DrawMode`
    defines how the `Mesh` object will interpret the buffer data, which can drastically
    alter the resulting shape of the mesh. The different `DrawMode` types and purposes
    can be found within the *There's more...* section of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, you may notice that the "door", or rather the blue lines
    that represent the door are not created in the same manner as the roof and base
    `Mesh` objects. Instead, we''ve used lines rather than triangles to draw the outline
    of the door. Take a look at the following code, which is taken from the `doorBufferData`
    array, defining the points in which lines connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once again, if we draw a scene graph and plot these points similar to the previous
    figure representing the `baseMesh` object's points, we can actually connect the
    dots and the lines will result in a rectangular shape. It might seem confusing
    at first, especially when trying to create the shapes in our heads. The trick
    to getting started with drawing custom shapes from defined vertices is to keep
    a blank scene graph saved in a favorite document or image editing software. Create
    a scene graph similar to the `baseMesh` object's buffer data representation figure
    and use it to plot points, then simply copy the points to code!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to remember that the `(0,0)` position on the previous scene
    graph figure represents the center of the `Mesh` object. Since we are building
    the mesh vertices up and to the right, the anchor center position of the mesh
    will not represent the center of the manually-drawn shapes! This is very important
    to keep in mind when building `Mesh` objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating meshes can be a pretty daunting subject for beginners, but it''s a
    good idea to get used to them for many reasons. One of the main reasons for AndEngine
    developers is that it can help us to understand how OpenGL draws shapes to a display
    on a lower level, which in turn allows us to grasp the higher-level game development
    functions more easily. The following image contains the various `DrawMode` types
    that AndEngine has conveniently made available for us in order to create `Mesh`
    objects in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/978-1-849518-98-7_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous figure shows how vertices within our buffer data will be drawn
    to the scene by our `Mesh` object depending on the `DrawMode` type selected. Each
    **p#** in this figure represents a `vertice (x, y, and z value)` within our buffer
    data array. See the following points for an explanation of the image representations
    of each `DrawMode` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawMode.POINTS`: This selection allows us to draw single points for each
    vertice within the mesh''s buffer data. These points will not be connected by
    any lines; they will simply display a dot on the mesh for each point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawMode.LINES`: This selection allows us to draw individual lines on the
    mesh. Every two vertices will be connected by a line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawMode.LINE_STRIP`: This selection allows us to draw points on the mesh,
    with each point after the first point being connected to the previous point. For
    example, **p1** will be connected to **p0**, **p2** will be connected to **p1**,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawMode.LINE_LOOP`: This selection acts in a similar way to the `DrawMode.LINE_STRIP`
    type, however, the first point and the final point will also be connected by a
    line. This allows us to create closed shapes via lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawMode.TRIANGLES`:– This selection allows us to draw individual triangles
    on the mesh for each three vertices defined within our buffer data. We are required
    to keep our vertices at multiples of three for this draw mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawMode.TRIANGLE_FAN`: This selection allows us to draw coned or pyramidal-shaped
    meshes. As we can see in the previous figure, we start by specifying a point which
    defines the top-most point of the cone, then continue on to specify any number
    of base points for the shape. This draw mode requires three or more vertices to
    be defined within the buffer data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawMode.TRIANGLE_STRIP`: This selection allows us to easily create customized
    polygonal meshes. Every vertice defined in the buffer data after the third vertice
    of the initial triangle will result in a new triangle, creating a new "strip".
    See the figure representation for an example. This draw mode requires three or
    more vertices to be defined within the buffer data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing a scene to life with sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we come to the topic which might be considered to be the most necessary
    aspect to creating any 2D game. Sprites allow us to display 2D images on our scene
    which can be used to display buttons, characters/avatars, environments and themes,
    backgrounds, and any other entity in our game which may require representation
    by means of an image file. In this recipe, we'll be covering the various aspects
    of AndEngine's `Sprite` entities which will give us the information we need to
    continue to work with `Sprite` objects later on in more complex situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the inner-workings of how sprites are created, we need to
    understand how to create and manage AndEngine's `BitmapTextureAtlas`/`BuildableBitmapTextureAtlas`
    objects as well as the `ITextureRegion` object. For more information, please refer
    to the recipes, *Working with different types of textures* and *Applying texture
    options* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine
    Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: Once these recipes have been covered, create a new empty AndEngine project with
    the `BaseGameActivity` class, provide a PNG formatted image of any size up to
    1024 x 1024 pixels in dimension, naming it as `sprite.png` and place it in the
    `assets/gfx/` folder of the project, then continue to the *How to do it...* section
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sprites can be created and applied to our `Scene` object in just a few quick
    steps. We must first set up the necessary texture resources that the sprite will
    use, we must create the `Sprite` object, and then we must attach the `Sprite`
    object to our `Scene` object. See the following steps for more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating the texture resources in the `onCreateResources()`
    method of our `BaseGameActivity` class. Make sure the `mBitmapTextureAtlas` and
    `mSpriteTextureRegion` objects are global variables, so that they can be reached
    throughout the various life cycle methods of our activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the `Sprite` object. We can create and attach the `Sprite`
    object to the `Scene` object in either the `onCreateScene()` or the `onPopulateScene()`
    methods of our activity. The parameters to supply in its constructor include,
    in this order, the sprites initial x coordinate, initial y coordinate, `ITextureRegion`
    object, and finally the `mEngine` object''s vertex buffer object manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it might appear in the steps in the previous section, setting up the `mBitmapTextureAtlas`
    and `mSpriteTextureRegion` objects actually require more work than creating and
    setting up the `mSprite` object specifically. For this reason, it is encouraged
    to complete the two recipes mentioned in the *Getting started...* section beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we will create our `mBitmapTextureAtlas` and `mSpriteTextureRegion`
    objects, suitable to the needs of our `sprite.png` image. Feel free to use any
    texture options or texture format in this step. It is a very good idea to get
    to know them well.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've our `ITextureRegion` object created and it's ready for use, we can
    move to step two where we will create the `Sprite` object. Creating a sprite is
    a straightforward task. The first two parameters will be used to define the initial
    position of the sprite, relative to its center point. For the third parameter,
    we will pass in the `ITextureRegion` object that we created in step one in order
    to provide the sprite with its appearance as an image on the scene. Finally, we
    pass in the `mEngine.getVertexBufferObjectManager()` method, which is necessary
    for most entity subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: Once our `Sprite` object is created, we must attach it to the `Scene` object
    before it will be displayed on the device, or we can attach it to another `Entity`
    object which is already attached to the `Scene` object. See the *Understanding
    AndEngine entities* recipe given in this chapter for more information on entity
    composition, placement, and other various must-know aspects of `Entity` objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No game is complete without some sort of sprite animation. After all, a player
    can only return to a game so many times before getting bored in a game where the
    characters slide around the screen without moving their feet, don't swing their
    weapon when attacking an enemy, or even when a grenade simply disappears rather
    than causing a nice explosion effect. In this day and age, people want to play
    games which look and feel nice, and nothing says, "Nice!", like buttery smooth
    animating sprites, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Working with different types of textures* recipe in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*, we''d covered
    how to create a `TiledTextureRegion` object which allows us to import useable
    sprite sheets into our game as a texture. Now let''s find out how we can use that
    `TiledTextureRegion` object with an `AnimatedSprite` object in order to add some
    animation to our game''s sprites. For this demonstration, the code will be working
    with an image of 300 x 50 pixels in dimension. The sprite sheet can be something
    as simple as the following figure, just to get an idea of how to create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/978-1-849518-98-7_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sprite sheet in the previous figure can be used to create a `TiledTextureRegion`
    object with 12 columns and 1 row. Creating the `BuildableBitmapTextureAtlas` and
    `TiledTextureRegion` objects for this sprite sheet can be done with the following
    code. However, before importing this code, be sure to make a global declaration
    of the texture region—`TiledTextureRegion mTiledTextureRegion`—in your test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve got the `mTiledTextureRegion` sprite sheet to play with in
    our project, we can create and animate the `AnimatedSprite` object. If you are
    using a sprite sheet with black circles as seen in the previous figure, don''t
    forget to change the color of the `Scene` object to a non-black color so we can
    see the `AnimatedSprite` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating the `AnimatedSprite` object can be done following the steps in this
    recipe while creating a regular `Sprite` object. Once it's created, we are able
    to set up its animation data, including individual frame duration, first and last
    tile indices to animate through, and whether or not to loop the animation continuously.
    Note that the `frameDuration` array must be equal to the frame count! Failing
    to follow this rule will result in an `IllegalArgumentException` exception. Once
    the data has been set up, we can call the `animate()` method on the `AnimatedSprite`
    object, supplying all of the data and adding an `IAnimationListener` listener
    if we wish. As the comments in the listener suggest, we gain a large portion of
    control over the animations with AndEngine's `AnimatedSprite` class.
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenGL's dithering capability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing visually appealing games on the mobile platform, it is a likely
    scenario that we'll want to include some gradients in our images, especially when
    dealing with 2D graphics. Gradients are great for creating lighting effects, shadows,
    and many other objects we'd otherwise not be able to apply to a full 2D world.
    The problem lies in the fact that we're developing for mobile devices, so we unfortunately
    do not have an unlimited amount of resources at our disposal. Because of this,
    AndEngine down-samples the surface view color format to `RGB_565` by default.
    Regardless of the texture format we define within our textures, they will always
    be down-sampled before being displayed on the device. We could alter the color
    format applied to AndEngine's surface view, but it's likely that the performance-hit
    will not be worth it when developing larger games with many sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two separate screenshots of a simple sprite with a gradient texture;
    both textures are using the `RGBA_8888` texture format and `BILINEAR` texture
    filtering (the highest quality).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using OpenGL''s dithering capability](img/978-1-849518-98-7_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image on the right-hand side is applied to the `Scene` object without any
    modifications, while the image on the left-hand side has OpenGL's dithering capability
    enabled. The difference between the two otherwise identical images is immediately
    noticeable. Dithering is a great way for us to combat down-sampling applied by
    the surface view without us having to rely on maximum color quality formats. In
    short, by dithering low-levels of randomized noise within our image's colors,
    it results in a smoother finish which is found in the image to the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling dithering is simple to apply to our entities in AndEngine, but as
    with everything, it''s wise to pick and choose which textures apply dithering.
    The algorithm does add a little bit of extra overhead, where if used too often
    could result in a larger performance loss than simply reverting our surface view
    to `RGBA_8888`. In the following code, we are enabling dithering in our `preDraw()`
    method and disabling it in our `postDraw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Dithering can be applied to any subtype of AndEngine's `Shape` class (`Sprites`,
    `Text`, primitives, and so on.).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about OpenGL ES 2.0 and how to work with all of the different
    functions, visit the link at [http://www.khronos.org/opengles/sdk/docs/man/](http://www.khronos.org/opengles/sdk/docs/man/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *Working with Entities*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying texture options* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game
    Structure"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying text to a layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text is an important part of game development as it can be used to dynamically
    display point systems, tutorials, descriptions, and more. AndEngine also allows
    us to create text styles which suit individual game types better by specifying
    customized `Font` objects. In this recipe, we're going to create a `Text` object,
    which updates itself with the current system time as well as correct its position
    every time the length of the string grows or shrinks. This will prepare us for
    the use of `Text` objects in cases where we need to display scores, time, and
    other non-specific dynamic string situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying `Text` objects to our `Scene` object requires a working knowledge of
    AndEngine's font resources. Please perform the the recipe, Using AndEngine font
    resources in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *Working
    with Entities*, then proceed with the *How to do it...* section of this recipe.
    Refer to the class named `ApplyingText` in the code bundle for this recipe's activity
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When applying `Text` objects to our `Scene` object, we are required to create
    a `Font` object which will define the text''s style, and create the `Text` object
    itself. See the folllowing steps for the specific actions we must take in order
    to properly display a `Text` object on our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to creating any `Text` object is to prepare ourselves a `Font`
    object. The `Font` object will act as the resource which defines the style of
    the `Text` object. Additionally, we need to prepare the letters that we plan for
    the `Text` object to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we''re dealing with final strings which may never change, only the first
    two steps need to be covered. However, in this recipe we will need to override
    the `onManagedUpdate()` method of the `Text` entity in order to make adjustments
    to its string over time. In this case, we''re updating the time value of the string
    after every second passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By this point, we should already have an understanding of how to create the
    `Font` object as we had discussed it in the first chapter. If creating `Font`
    objects is not yet understood, please visit the recipe, *Using AndEngine font
    resources* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *Working
    with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we are simply creating a basic `Font` object which will create
    a rather generic style for our `Text` object. Once the `Font` object has been
    created, we are preparing only the necessary characters that will be displayed
    throughout the life of the `Text` object with the `mFont.prepareLetters()` method.
    Doing so allows us to avoid garbage collector invocations within the `Font` object.
    The values used in this recipe will obviously range from `0` to `9` as we are
    dealing with time, as well as the individual characters that make up the string,
    `Time:`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once step one is completed, we can move onto step two where we create the `Text`
    object. The `Text` object requires that we specify its initial position on the
    screen in x and y coordinates, the `Font` object to use as a style, the initial
    string to display, its maximum character count, and finally the vertex buffer
    object manager as needed by all `Entity` objects. However, since we''re dealing
    with a dynamically-updating `String` value for this `Text` object, which will
    require adjustments on the x axis, the parameters including the x coordinate as
    well as the initial string are not so important as they will be adjusted frequently
    during updates to the `Text` object. The most important parameter is the maximum
    character count. Failing to keep the `Text` object''s maximum character count
    below that of the value specified within this parameter will result in the application
    receiving an `ArrayIndexOutOfBoundsException` exception and will likely require
    termination. For this reason, we are adding up the length of the largest string
    as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the third step, we are overriding the `Text` object's `onManagedUpdate()`
    method in order to apply changes to the `Text` object's string after every second
    passed. At first, we simply obtain the device's current second value, using it
    to compare with the second value in the previous call to the `Text` object's `onManagedUpdate()`
    method. This allows us to avoid updating the `Text` object with the system time
    on every single update. If the previous second that the `Text` object's string
    was updated with is not the same as the new second value, then we continue on
    to obtain the current minute and hour values as well via the `Calendar.getInstance().get(HOUR)`
    method and `MINUTE` variation. Now that we've got all of the values, we build
    a new string containing the updated time, and call `setText(pString)` on the `Text`
    object to change the string it will display on the device.
  prefs: []
  type: TYPE_NORMAL
- en: However, due to the fact that each individual character width might have a different
    value, we also need to make corrections in the position in order to keep the full
    `Text` object on the screen. By default, the anchor position is set to the center
    of an `Entity` object, so by calling `this.setX(WIDTH - this.getWidth() * 0.5f)`,
    where `this` refers to the `Text` object, we position the entity's center-most
    point at the maximum screen width to the right, and then subtract half of the
    entity's width. This will allow the text to sit right along the edge of the screen
    even after its characters change the width of the `Text` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes our games may require a little bit of formatting to the `Text` object''s
    strings. In cases where we need to adjust the `Text` object''s horizontal alignment,
    apply auto-wrapping to the text if its string exceeds a certain width, or a leading
    space to the text, we can do these with some very easy-to-use methods. The following
    methods can be called directly on the `Text` object; for example, `mText.setLeading(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setAutoWrap(pAutoWrap)`: This method allows us to define whether or not, and
    if so, how a `Text` entity will perform auto-wrapping. The options we have for
    parameters include `AutoWrap.NONE`, `AutoWrap.LETTERS`, `AutoWrap.WORDS`, and
    `AutoWrap.CJK`. With `LETTERS`, line break won''t wait for a whitespace before
    breaking to a new line while `WORDS` will. The `CJK` variant is an option which
    allows auto-wrapping for Chinese, Japanese, and Korean characters. This method
    should be used alongside `setAutoWrapWidth(pWidth)`, where `pWidth` defines the
    maximum width of any single line within the `Text` object''s string, causing line-breaks
    when necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setHorizontalAlign(pHorizontalAlign)`: This method allows us to define the
    type of alignment the `Text` object''s string should follow. The parameters include
    `HorizontalAlign.LEFT`, `HorizontalAlign.CENTER`, and `HorizontalAlign.RIGHT`.
    The result is similar to what we''d see when setting alignment within a text editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLeading(pLeading)`: This method allows us to set a leading space at the
    beginning of the `Text` object''s string. The parameter required is a float value,
    which defines the leading width of the sring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using AndEngine font resources* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overriding the onManagedUpdate method* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using relative rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rotating entities relative to the position of other entities in 2D space is
    a great function to know. The uses for relative rotation are limitless and always
    seems to be a "hot topic" for newer mobile game developers. One of the more prominent
    examples of this technique being used is in tower-defense games, which allows
    a tower''s turret to aim towards the direction that an enemy, non-playable character
    is walking. In this recipe, we''re going to introduce a method of rotating our
    `Entity` objects in order to point them in the direction of a given x/y position.
    The following image displays how we will create an arrow on the scene, which will
    automatically point to the position of the circle image, wherever it moves to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using relative rotation](img/978-1-849518-98-7_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need to include two images for this recipe; one named `marble.png` at
    32 x 32 pixels in dimension and another named `arrow.png` at 31 pixels wide by
    59 pixels high. The marble can be any image. We will simply drag this image around
    the scene as we please. The arrow image should be in the shape of an arrow, with
    the arrowhead pointing directly upward on the image. See the screenshot in the
    introduction for an example of the images to include. Include these assets in
    an empty `BaseGameActivity` test project then please refer to the class named
    `RelativeRotation` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `IOnSceneTouchListener` listener in the `BaseGameActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `Scene` object''s `onSceneTouchListener` in the activity''s `onCreateScene()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Populate the `Scene` object with the marble and arrow sprites. The arrow sprite
    is positioned in the center of the scene, while the marble''s position is updated
    to the coordinates of any touch event location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Step four introduces the `onSceneTouchEvent()` method which handles the movement
    of the marble sprite via a touch event on the device''s display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this class, we're creating a sprite which is represented by an arrow image
    and placing it in the direct center of the screen, automatically pointing to a
    another sprite represented by a marble. The marble is draggable via touch events
    through the use of an `IOnSceneTouchListener` listener implementation within our
    `BaseGameActivity` class. We then register the touch listener to the `mScene`
    object. In situations where an entity rotates according to another entity's position,
    we'll have to include the rotation functionality in some method that is consistently
    updated, otherwise our arrow would not continuously react. We can do this through
    update threads, but in this instance we'll include that functionality in the `onSceneTouchEvent()`
    overridden method as the "target" will not actually move until we touch the scene
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we're allowing our activity to override the `onSceneTouchEvent()`
    method by implementing the `IOnSceneTouchListener` interface. Once we've implemented
    the touch listener, we can take care of step two and allow the `Scene` object
    to receive touch events and respond according to the code situated inside the
    activity's overridden `onSceneTouchEvent()` method. This is done with the `setOnSceneTouchListener(pSceneTouchListener)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In step four, the `if(pSceneTouchEvent.isActionMove())` conditional statement
    determines whether a finger is moving over the scene, updating the marble's position,
    and calculating the new rotation for the arrow sprite if the conditional statement
    returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first start by updating the marble''s position to the location of touch
    through the use of the `setPosition(pX, pY)` method as seen in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we subtract the pointer''s x/y coordinates from the target''s x/y coordinates.
    This gives us the difference between each of the sprites'' coordinates which will
    be used to calculate the angle between the two positions. In this case, the pointer
    is the `mArrowSprite` object and the target is the `mMarbleSprite` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, since AndEngine''s `setRotation(pRotation)` method uses degrees and
    the `atan2(pY, pX)` method returns radians, we must perform a simple conversion.
    We will use AndEngine''s `MathUtils` class which includes a `radToDeg(pRadian)`
    method to convert our angle value from radians to degrees. Once we obtain the
    correct angle in degrees, we will set the `mArrowSprite` object''s rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One last thing to note is that the `DEFAULT_IMAGE_ROTATION` value is an `int`
    value which represents `90` degrees. This value is simply used to offset the rotation
    of the `mArrowSprite` sprite, otherwise we would be required to properly rotate
    the image within our image editing software. If the pointer within our custom
    images is not facing the uppermost point of the image, this value may require
    adjustments in order to properly align the pointer with the target.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the onManagedUpdate method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overriding an `Entity` object's `onManagedUpdate()` method can be extremely
    useful in all types of situations. By doing so, we can allow our entities to execute
    code every time the entity is updated through the update thread, occuring many
    times per second unless the entity is set to ignore updates. There are so many
    possibilities including animating our entity, checking for collisions, producing
    timed events, and much more. Using our `Entity` objects's `onManagedUpdate()`
    method also saves us from having to create and register new timer handlers for
    time-based events for a single entity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of the `Entity` object in AndEngine. Please
    read through the entire recipe, *Understanding AndEngine entities* given in this
    chapter, then create a new empty AndEngine project with a `BaseGameActivity` class
    and refer to the class named `OverridingUpdates` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are creating two `Rectangle` objects. One rectangle will
    remain in the center of the scene, rotating consistently. The second rectangle
    will continuously move from left to right and bottom to top on the scene, resetting
    back to the left-hand side when it reaches the right, and resetting back to the
    bottom when it reaches the top of the scene. Additionally, the moving rectangle
    will turn green anytime it collides with the center rectangle. All of these movements
    and conditionals will be applied and executed through the use of each object's
    overridden `onManagedUpdate(pSecondsElapsed)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the first `Rectangle` object''s `onManagedUpdate()` method for continuous
    rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the second `Rectangle` object''s `onManagedUpdate()` method for continuous
    position updates, conditional checking, and collision detection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first `Rectangle` object that we created, we are overriding its `onManagedUpdate(pSecondsElapsed)`
    method to continuously update the rotation to a new value. For the second `Rectangle`
    object, we're moving it from the far left-hand side of the screen to the far right-hand
    side of the screen continuously. Once the second rectangle reaches the far right-hand
    side of the screen, it is repositioned back to the left-hand side and we raise
    the `Rectangle` object on the scene by half of the `Rectangle` object's height.
    Additionally, when the two rectangles overlap, the moving rectangle will change
    its color to green until they are no longer touching.
  prefs: []
  type: TYPE_NORMAL
- en: The code in step one allows us to create an event every time the entity is updated.
    In this specific overridden method, we're calculating a rotation offset for the
    `Rectangle` object based on the seconds passed since it was last updated. Because
    the entity is updated many times per second, depending on the number of frames
    per second the device is able to achieve, we multiply `pSecondsElapsed` by `25`
    in order to increase the rotation speed a bit. Otherwise, we'd be rotating our
    entity along the lines of `0.01` degrees every update which would take quite a
    while for an object to make a full revolution at that rate. We can use the `pSecondsElapsed`
    update to our advantage when dealing with updates in order to make modifications
    to events based on time passed since the last update.
  prefs: []
  type: TYPE_NORMAL
- en: Step two is a little bit more robust than the first step. In step two, we are
    overriding the second rectangle's `onManagedUpdate()` method in order to perform
    position-checking, collision-checking, and updating the rectangle's position on
    every update to the entity. To start off, we are declaring variables which will
    contain values such as the current position of the entity, the half width and
    half height values of the entity for proper offsetting from the anchor center,
    and the next update position used for checking the position. Doing so allows us
    to reduce the number of calculations needed throughout the entity's update. Applying
    poorly-optimized code in the update thread can lead to lowered frame rate very
    quickly. It is important to make as method calls and calculations as possible;
    for example, obtaining the `currentX` value five times throughout the `onManagedUpdate()`
    method would be more ideal than calling `this.getX()` five times.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on with the position-checking and updating in step two, we start
    off by determining whether the `Rectangle` object's anchor center plus half its
    width, which is represented by the `maxWidth` variable, is less than or equal
    to the `WIDTH` value that represents the furthest coordinate to the right of the
    display. If true, we proceed to increment the x coordinate of the `Rectangle`
    object by `incrementXValue`, which is equal to 5 pixels. On the other hand, we
    will either reset the `Rectangle` object back to the bottom-left corner of the
    scene if the `nextHeight` value is greater than or equal to our camera's `HEIGHT`
    value, or simply increase the `Rectangle` object's height by half its width and
    return it to the left-hand side of the display if the rectangle has not yet reached
    the top of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've got our collision-checking method within the `onManagedUpdate()`
    method of our second `Rectangle` object. By calling `this.collidesWith(mRectangleOne)`,
    we can determine whether or not the `this` object is overlapping with the object
    specified, or in this case, `mRectangleOne`. We will then make one additional
    check to determine whether or not the color is not already equal to the color
    we plan on changing the `Rectangle` object to if collision is detected; setting
    the `Rectangle` object to green if the conditions return `true`. However, `collidesWith()`
    can be a rather expensive collision-checking method if it is being performed by
    multiple `Entity` objects on every update! In this recipe, we're purely using
    this collision-checking method as an example. One option to look into would be
    to perform a lightweight distance detection between the two objects prior to performing
    the collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As briefly mentioned before, *all children receive the update call from their
    parent*. Child entities in this case also inherit the modified `pSecondsElapsed`
    value of the parent. We can even go as far as slowing our entire `Scene` object,
    including all of its children, by overriding its `onManagedUpdate()` method and
    reducing the `pSecondsElapsed` value like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Returning a value equal to half the `pSecondsElapsed` value to the `super` method
    would cause all entities attached to that `Scene` object to slow down by half
    in all aspects. That's just a little something to keep in mind when considering
    options for pausing or creating a slow motion effect for our games.
  prefs: []
  type: TYPE_NORMAL
- en: Using modifiers and entity modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AndEngine provides us with what are known as **modifiers** and **entity modifiers**.
    Through the use of these modifiers we can apply neat effects to our entities with
    great ease. These modifiers apply specific changes to an `Entity` object over
    a defined period of time, such as movement, scaling, rotation, and more. On top
    of that, we can include listeners and ease functions to entity modifiers for full
    control over how they work, making them some of the most powerful-to-use methods
    for applying certain types of animation to our `Scene` object in AndEngine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before continuing, we should mention that a modifier and an entity modifier
    in AndEngine are two different objects. A modifier is meant to be applied directly
    to an entity, causing modifications to an entity's properties over time, such
    as scaling, movement, and rotation. An entity modifier on the other hand, is meant
    to act as a container for any number of modifiers, which handle the order in which
    a group of modifiers are executed. This will be discussed more in depth throughout
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of the `Entity` object in AndEngine. Please
    read through the entire recipe, *Understanding AndEngine entities* given in this
    chapter, then create a new empty AndEngine project with a `BaseGameActivity` class
    and then refer to the *How to do it...* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''re going to cover AndEngine''s entity modifiers, including
    modifier listeners and ease functions to apply smooth transitional effects to
    the modifiers. If that sounds confusing, have no fear! AndEngine modifiers are
    actually very simple to work with and can be used to apply different types of
    animations to our `Entity` objects in as little as a few steps for basic modifiers.
    The following steps cover setting up an `Entity` object with a movement modifier
    which will ease us into further discussion of entity modifiers. Import the code
    in these steps to the `onPopulateScene()` method of the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and attach any type of entity to the `Scene` object. We will be applying
    entity modifiers to this entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we''ve got an entity placed on our `Scene` object, we can start to create
    our modifiers. In this step, we''ll be creating a `MoveModifier` object, which
    allows us to apply a positional change to an entity over time. But first, we will
    define its values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''ve got our `moveModifier` object created and set up as we''d like,
    we can register this modifier to any entity we wish with the following call, which
    will start the movement effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of entity modifiers is quite extensive, so we will start by jumping
    in to the steps. From there we will use the steps as a base foundation for us
    to dive deeper into more complex discussions and examples on the use of entity
    modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we're simply creating our `Entity` object, which is a `Rectangle`
    in this case, that we'll be using as our test subject for applying modifiers to.
    Simply add the code in this step to the `onPopulateScene()` method; this code
    shall remain untouched throughout our upcoming modifier and entity modifier "experiments".
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we will start to work with one of the most basic modifiers,
    which is of course the `MoveModifier` modifier. This modifier simply allows us
    define a start position for the movement, an ending position for the movement,
    and a duration, in seconds, that it will take to move from the starting point
    to the ending point. This is very simple stuff as we can see and what's most notable
    about modifiers is that, for the most part, this is all it really takes to set
    up most modifiers. All modifiers really require is a "from" value, a "to" value,
    and a duration defining the time in seconds in which "from-to" occurs. Keep that
    in mind and working with modifiers will be an absolute breeze for the most part!
  prefs: []
  type: TYPE_NORMAL
- en: Next, in our third step we simply apply our newly created `moveModifier` object
    to our `rectangle` object via the `registerEntityModifier(pModifier)` method.
    This will apply the `moveModifier` effect to the rectangle, first positioning
    it to its "from" coordinate, then move it to the "to" coordinates over a 3 second
    time span.
  prefs: []
  type: TYPE_NORMAL
- en: We know that to register a modifier or entity modifier to an `Entity` object,
    we can call `entity.registerEntityModifier(pEntityModifier)`, but we should also
    know that once we are finished with a modifier we should remove it from the `Entity`
    object. We can do this by either calling `entity.unregisterEntityModifier(pEntityModifier)`
    or if we want to remove all entity modifiers attached to an `Entity` object, we
    can call `entity.clearEntityModifiers()`. On the other hand, if a modifier or
    entity modifier runs its full duration and we're not quite ready to remove it
    from the entity, we must call `modifier.reset()` in order to replay the effect.
    Or if we'd like to make a small adjustment to the modifier before replaying the
    effect, we can call `modifier.reset(duration, fromValue, toValue)`. Where the
    parameters in the `reset` method would be relative to the type of modifier we're
    resetting.
  prefs: []
  type: TYPE_NORMAL
- en: The `moveModifier` object works, but it's dreadfully boring! After all, we're
    just moving a rectangle from the bottom-left corner of our scene to the upper-right
    corner. Fortunately, that's only just scratching the surface of modifier application.
    The following subheading contains a reference, and example where necessary, to
    all of the modifiers that AndEngine is capable of applying to our `Entity` objects.
  prefs: []
  type: TYPE_NORMAL
- en: AndEngine's modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a collection of all of the AndEngine modifiers that we are
    able to apply to our entities. The more advanced modifiers will be provided with
    a quick example code snippet. Feel free to try them out in your test project as
    we cover them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AlphaModifier`: Adjust the alpha value of an entity over time with this modifier.
    The parameters for the constructor include duration, from alpha, and to alpha,
    in that order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorModifier`: Adjust the color values of an entity over time with this modifier.
    The parameters for the constructor include duration, from red, to red, from green,
    to green, from blue, and to blue, in that order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DelayModifier`: This modifier is meant to be attributed to the entity modifier
    objects in order to provide a delay between one modifier being executed and another
    modifier being executed. The parameter includes duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FadeInModifier`: Based on the `AlphaModifier` class, the `FadeInModifier`
    modifier changes an entity''s alpha value from `0.0f` to `1.0f` over a defined
    duration, supplied in the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FadeOutModifier`: Similar to `FadeOutModifier`, except the alpha values are
    swapped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JumpModifier`: This modifier can be used to apply a "jump" motion to an entity.
    The parameters include duration, from x, to x, from y, to y, and jump height.
    These values will define the distance and height that the entity appears to jump
    over the defined duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MoveByModifier`: This modifier allows us to offset the position of an entity.
    The parameters include duration, x offset, and y offset, in that order. For example,
    specifying an offset of `-15` will move the entity to the left by 15 units on
    the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MoveXModifier` and `MoveYModifier`: These modifiers, similar to `MoveModifier`,
    allow us to provide movement to an entity. However, these methods apply the movement
    only on a single axis as determined by the method names. The parameters include
    duration, from coordinate, and to coordinate, in that order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotationAtModifier`: This modifier allows us to apply a rotation to the entity
    while offsetting the center of rotation. The parameters include duration, from
    rotation, to rotation, rotation center x, and rotation center y.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotationByModifier`: This modifier allows us to offset the entity''s current
    rotation value. The parameters include duration and rotation offset value. For
    example, providing a rotation offset value of `90` will rotate the entity ninety
    degrees clockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotationModifier`: This modifier allows us to rotate an entity from a specific
    value, to another specific value. The parameters include duration, from rotation,
    and to rotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScaleAtModifier`: This modifier allows us to scale an entity while offsetting
    the center of scaling. The parameters include duration, from scale, to scale,
    scale center x, and scale center y.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScaleModifier`: This modifier allows us to scale an entity from a specific
    value, to another specific value. The parameters include duration, from scale,
    and to scale, in that order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkewModifier`: This modifier allows us to skew an entity''s x and y values
    over time. The parameters include duration, from skew x, to skew x, from skew
    y, and to skew y, in that specific order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathModifier`: This modifier is relative to `MoveModifier`, except we are
    able to add as many "to" coordinates as we please. This allows us to create a
    path on the `Scene` object for the entity to follow by specifying pairs of x/y
    coordinates for the `PathModifier` modifier. See the following steps for a walkthrough
    on the topic of creating a `PathModifier` modifier for our entities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the way-points for the path. The way-point arrays for the x and y coordinates
    should have the same number of points, as they will be paired up in order to make
    a single x/y coordinate for `PathModifier`. We must have at least two points set
    in each of the arrays, as we''ll need at least a start and end point:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Path` object which we will use to pair the individual points in the
    separate arrays into way-points. We do this by iterating through the arrays and
    calling the `to(pX, pY)` method on the `path` object. Note that every time we
    call this method, we are adding an additional way-point to the `path` object:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, once we''ve defined our way-points, we can create the `PathModifier`
    object, supplying a duration as well as our `path` object as the parameters:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`CardinalSplineMoveModifier`: This is the final modifier we will be discussing.
    This modifier is relatively similar to the `PathModifier` modifier, except we
    are able to apply tension to the `Entity` object''s movement. This allows for
    a more fluid and smooth movement when approaching corners, or reversing direction,
    which looks quite nice actually. See the following steps for a walkthrough on
    the topic of creating a `CardinalSplineMoveModifier` modifier for our entities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step, similar to the `PathModifier` modifier, is to create our point
    arrays. In this example, we can copy the code from `PathModifier` example's first
    step. However, one difference between this modifier and the `PathModifier` object
    is that we require a minimum of 4 individual x and y points.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second step is to determine the number of control points, define the tension,
    and create a `CardinalSplineMoveModifierConfig` object. This is the `CardinalSplineMoveModifier`
    modifier''s equivalent of the `PathModifier` modifier''s `Path` object. The tension
    can be between `-1` and `1`, no more and no less. A tension of `-1` will leave
    the `Entity` object''s movement very loose, making extremely loose corners and
    changes in direction while a tension of `1` will react very much like the `PathModifier`
    modifier in the sense that it is very strict in its movements:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In step three, again very similar to the `PathModifier` modifier, we must pair
    the x/y coordinates within our point arrays, except in this case we''re storing
    them within the `config` object:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will simply define the duration for the movement, Create the `CardinalSplineMoveModifier`
    modifier, supply the duration and `config` object as parameters, and finally register
    the modifier to the `Entity` object:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now that we've got a solid understanding of the individual modifiers that we
    are able to apply to our entities, we will cover the three main entity modifiers
    in AndEngine and what they're used for.
  prefs: []
  type: TYPE_NORMAL
- en: AndEngine's entity modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AndEngine includes three entity modifier objects which are used for building
    complex animations for our `Entity` objects by combining two or more modifiers
    into a single event or sequence. The three different entity modifiers include
    the `LoopEntityModifier`, `ParallelEntityModifier`, and `SequenceEntityModifier`
    objects. Next, we describe the specifics of these entity modifiers and examples,
    displaying how they can be used to combine multiple modifiers into a single animation
    event.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoopEntityModifier`: This entity modifier allows us to loop a specified modifier
    either indefinitely or N number of times if supplied a second `int` parameter.
    This is the simplest of entity modifiers. Once we set up the `LoopEntityModifier`
    modifier, we can apply it directly to the `Entity` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ParallelEntityModifier`: This entity modifier allows us to combine an unlimited
    number of modifiers into a single animation. The modifiers supplied as parameters
    of this entity modifier will all run on the `Entity` object at the same time.
    This allows us to scale a modifier while rotating it, for example, as seen in
    the following example. Feel free to add more modifiers to the example for some
    practice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SequenceEntityModifier`: This entity modifier allows us to string together
    modifiers that will be executed sequentially on a single `Entity` object. This
    modifier is ideally the proper entity modifier to use the `DelayModifier` object
    as previously mentioned in the modifiers list. The following example displays
    an `Entity` object which moves from the bottom-left corner to the center of the
    screen, pauses for `2` seconds, then scales down to a scale factor of `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What's even more important to know is that we can add a `SequenceEntityModifier`
    modifier to a `ParallelEntityModifier` modifier, a `ParallelEntityModifier` modifier
    to a `LoopEntityModifier` modifier, or any other variation we can think of! This
    makes the possibilities of modifiers and entity modifiers extremely extensive
    and allows us to create incredibly complex animations for our entities with a
    rather significant amount of ease.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to the next topic, we should take a look at the extra features
    included for entity modifiers. There are two more parameters that we can pass
    to our entity modifiers which we haven't discussed yet; those being modifiers
    listeners and ease functions. These two classes can help to make our modifiers
    even more customized than we've already seen in the *How it works...* section!
  prefs: []
  type: TYPE_NORMAL
- en: The `IEntityModifierListener` listener can be used in order to fire events when
    a modifier starts and when a modifier finishes. In the following snippet, we're
    simply printing logs to logcat which notify us when the modifier has started and
    finished.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The previous code shows the skeleton of a modifier listener with basic log outputs.
    In a more relative scenario to game development, we could call `pItem.setVisible(false)`
    once the modifier is finished. For example, this could be useful for handling
    subtle falling leaves or raindrops in a scene that leaves the camera's view. However,
    what we decide to use the listener for is completely up to our own discretion.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll quickly discuss the ease functions in AndEngine. Ease functions
    are a great way to add an extra layer of "awesomeness" to our entity modifiers.
    After getting used to modifiers, it is likely that ease functions will really
    grow on you as they give modifiers that extra kick they need to make the perfect
    effects. The best way to explain an ease function is to think about a game where
    the menu buttons fall from the top of the screen and "bounce" into place. The
    bounce in this case would be our ease function taking effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, applying an ease function to a modifier is as easy as adding
    an extra parameter to the modifier's constructor. Often the hardest part is choosing
    which one to use as the list of ease functions is somewhat large. Take some time
    to look through the various ease functions provided by locating the `org.andengine.util.modifier.ease`
    package. Simply replace `EaseElasticIn` from the previous code with the ease function
    you'd like to test out, and rebuild the project to see it in action!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ease function reference**'
  prefs: []
  type: TYPE_NORMAL
- en: Download the **AndEngine – Examples** application from Google Play to your device.
    Open the application and locate the **Using EaseFunctions** example. While the
    example application is quite outdated compared to the latest AndEngine branch,
    the ease function example is still an absolutely effective tool for determining
    which ease functions best suit our own game's needs!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Particle systems** can provide our games with very attractive effects for
    many different events in our games, such as explosions, sparks, gore, rain, and
    much more. In this chapter, we''re going to cover AndEngine''s `ParticleSystem`
    classes which will be used to create customized particle effects that will suit
    our every need.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine. Please
    read through the entire recipes, *Working with different types of textures* in
    [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*, as well as *Understanding AndEngine entities* given in this chapter.
    Next, create a new empty AndEngine project with a `BaseGameActivity` class and
    import the code from the `WorkingWithParticles` class in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to begin creating particle effects in AndEngine, we require a bare
    minimum of three objects. These objects include an `ITextureRegion` object which
    will represent the individual particles spawned, a `ParticleSystem` object, and
    a `ParticleEmitter` object. Once we have these in place, we can begin to add what
    are known as particle initializers and particle modifiers to our particle system
    in order to create our own personalized effects. See the following steps for a
    walkthrough on how to set up a basic particle system in which we can build on.
  prefs: []
  type: TYPE_NORMAL
- en: The first step involves deciding the image we'd like our particle system to
    spawn. This can be any image, any color, and any size. Feel free to create an
    image and set up `BuildableBitmapTextureAtlas` and `ITextureRegion` to load the
    image into the test project's resources. For the sake of keeping things simple,
    please keep the image under 33 x 33 pixels in dimension for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `ParticleEmitter` object. For now we''ll be using a `PointParticleEmitter`
    object subtype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `ParticleSystem` object. We''ll be using the `BatchedSpriteParticleSystem`
    object implementation as it is the latest and greatest `ParticleSystem` object
    subtype included in AndEngine. It allows us to create large amounts of particles
    while greatly reducing overhead of the typical `SpriteParticleSystem` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the final step to creating a particle system, we will add any combination
    of particle emitters and particle modifiers and then attach the particle system
    to the `Scene` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems that working with particles for many new AndEngine developers is a
    rather difficult subject, but, in fact, it's quite the opposite. Creating particle
    effects in AndEngine is extremely simple, but as always, we should learn to walk
    before we can fly! In this recipe's steps, we're setting up a rather basic particle
    system. As the topic progresses, we will discuss and plug in additional modular
    components of the particle system in order to broaden our knowledge of the individual
    pieces that make up complex particle system effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we need to set up an `ITextureRegion` object to supply our
    particle system. The `ITextureRegion` object will visually represent each individual
    particle that spawns. The texture region can be of any size, but typically they
    will be between 2 x 2 to 32 x 32 pixels. Remember that the particle system is
    meant to spawn a large number of objects, so the smaller the `ITextureRegion`
    object, the better off the performance will be as far as the particle system goes.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we create our particle emitter and center it on the `Scene`
    object. The particle emitter is the component within a particle system that controls
    where particles will initially spawn. In this recipe, we are using a `PointParticleEmitter`
    object type, which simply spawns all particles in the exact same coordinates on
    the scene as defined by the `particleSpawnCenterX` and `particleSpawnCenterY`
    variables. AndEngine includes four other particle emitter types which will be
    discussed shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've got our particle emitter created and set up as we see fit, we can
    move onto the third step and create the `BatchedSpriteParticleSystem` object.
    The parameters that we are required to pass to the `BatchedSpriteParticleSystem`
    object include, in this order, the particle emitter, the minimum spawn rate of
    the particles, the maximum spawn rate, the maximum number of particles that can
    be simultaneously displayed, the `ITextureRegion` object that the particles should
    visually represent, and the `mEngine` object's vertex buffer object manager.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the fourth step we are adding an `AccelerationParticleInitializer`
    object, which will provide an accelerating movement to the particles so that they're
    not simply sitting where they spawn. We are also adding an `ExpireParticleInitializer`
    object, which is used to destroy particles after a defined amount of time. Without
    some sort of initializer or modifier removing particles, the `BatchedParticleSystem`
    object would eventually reach its maximum particle limit and discontinue particle
    spawning. Lastly, we're adding a `ScaleParticleModifier` object to the particle
    system which will change each particle's scale over time. These particle initializers
    and particle modifiers will be explained more in-depth shortly, for now, just
    know that this is the step where we'd apply them to the particle system. Once
    we've added our initializers and modifiers of choice, we attach the `particleSystem`
    object to the `Scene` object.
  prefs: []
  type: TYPE_NORMAL
- en: After completing these four steps, the particle system will begin to spawn particles.
    However, we may not always want the particles to spawn from a specific particle
    system. To disable particle spawning, we can make the call, `particleSystem.setParticlesSpawnEnabled(false)`,
    or `true` to re-enable particle spawning. Aside from this method, the `BatchedSpriteParticleSystem`
    object contains all of the ordinary functionality and methods of an `Entity` object.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the individual components of a particle system, see
    the following subtopics. These topics include particle emitters, particle initializers,
    and particle modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitter selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AndEngine includes a selection of five ready-to-use particle emitters which
    can alter the initial placement of particles on the scene, this is not to be confused
    with defining a particle emitter position. See the list of particle emitters for
    details on how each of them work. Please feel free to substitute the particle
    emitter in step two of the recipe with a particle emitter given in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PointParticleEmitter`: The most basic particle emitter of the bunch; this
    particle emitter causes all spawning particles to be initially spawned in the
    same defined position on the scene. There will be no variance in the position
    that particles spawn. However, general particle emitter position can change via
    a call to the `pointParticleEmitter.setCenter(pX, pY)` method, where `pX` and
    `pY` define the new coordinates to spawn particles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CircleOutlineParticleEmitter`: This particle emitter subtype will cause particles
    to spawn in positions outlining the shape of a circle. The parameters to include
    in this emitter''s constructor include the x coordinate, the y coordinate, and
    a radius which defines the overall size of the circle outline. See the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CircleParticleEmitter`: This particle emitter subtype will allow particles
    to spawn within any area of a circle opposed to just the outlining edge in the
    `CircleOutlineParticleEmitter` object. The `CircleParticleEmitter` object requires
    the same parameters in its constructor as the `CircleOutlineParticleEmitter` object.
    To test this particle emitter subtype, simply refactor the object in the `CircleOutlineParticleEmitter`
    example to use the `CircleParticleEmitter` object instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RectangleOutlineParticleEmitter`: This particle emitter subtype will cause
    the particles to spawn from four corners of a rectangle whose size is defined
    by the constructor parameters. Unlike the `CircleOutlineParticleEmitter` object,
    this particle emitter doesn''t allow particles to spawn around the full parameter
    of the rectangle. See the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RectangleParticleEmitter`: This particle emitter subtype allows for particles
    to spawn anywhere within the bounding area of a rectangle shape as defined by
    the constructor parameters. To test this particle emitter subtype, simply refactor
    the object in the `RectangleOutlineParticleEmitter` example to use the `RectangleParticleEmitter`
    object instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle initializer selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Particle initializers are of vital importance to particle systems. They provide
    us with the possibility to perform actions on each individual particle that is
    initially spawned. The greatest thing about these particle initializers is that
    they allow us to provide min/max values, giving us the opportunity to randomize
    the properties of spawned particles. Here, find a list of all of the particle
    initializers that AndEngine has to offer as well as examples of their use. Feel
    free to substitute the particle initializers in the recipe with those found in
    this list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following particle initializers can be added with a simple call to `particleSystem.addParticleInitializer(pInitializer)`.
    Additionally, they can be removed via `particleSystem.removeParticleInitializer(pInitializer)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExpireParticleInitializer`: We will start off with the most necessary particle
    initializer in the list. The `ExpireParticleInitializer` object provides a means
    of removing particles which have been alive for too long. If we were not to include
    some form of particle expiration, our particle would quickly run out of particles
    to spawn as all particle systems have a limit to the number of particles that
    can be active at any given time. The following example creates an `ExpireParticleModifier`
    object which causes individual particles to expire between `2` and `4` seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AccelerationParticleInitializer`: This initializer allows us to apply movement
    in the form of acceleration, causing the spawned particles to pick up speed before
    reaching the defined velocity. A positive value on the x or y axis will cause
    the particle to move up and to the right, while negative values will move the
    particle down and to the left. In the following example, the particles will be
    given min/max values which will cause particle movement direction to be random:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AlphaInitializer`: The `AlphaInitializer` object is pretty basic. It simply
    allows us to initialize particles with an undetermined alpha value. The following
    example will cause individual particles to spawn with an alpha value of between
    `0.5f` and `1f`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BlendFunctionParticleInitializer`: This particle initializer allows us to
    spawn particles with specific OpenGL blend functions applied to them. For more
    information on blend functions and results, there are many resources that can
    be found online. The following is an example using the `BlendFunctionParticleInitializer`
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ColorParticleInitializer`: The `ColorParticleInitializer` object allows us
    to provide our sprites with colors between min/max values. This allows us to randomize
    the color of each particle spawned. The following example will generate particles,
    each with a completely different random color:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GravityParticleInitializer`: This particle initializer allows us to spawn
    particles which will act as though they follow the rules of the earth''s gravity.
    The `GravityParticleInitializer` object requires no parameters in its constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RotationParticleInitializer`: The `RotationParticleInitializer` object allows
    us to define the min/max values for the particle''s rotation when spawned. The
    following example will cause individual particles to spawn anywhere between `0`
    and `359` degrees:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ScaleParticleInitializer`: The `ScaleParticleInitializer` object allows us
    to define the min/max values for the particle''s scale when spawned. The following
    example will allow particles to spawn with a scale factor of anywhere between
    `0.5f` and `1.5f`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`VelocityParticleInitializer`: This final particle initializer, similar to
    the `AccelerationParticleInitializer` object, allows us to provide movement to
    individual particles when spawned. However, this initializer causes the particles
    to move at a constant speed, and will not increase or decrease velocity over time
    unless manually configured to do so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the following section for a list of AndEngine's particle modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Particle modifier selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AndEngine's particle modifiers are useful in the development of complex particle
    systems. They allow us to provide changes to individual particles depending on
    how long they've been alive for. Similar to entity modifiers, particle modifiers
    are of the "from time-to time, from value-to value" format. Once again, feel free
    to add any of the particle modifiers in the list to your current test project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following particle modifiers can be added with a simple call to `particleSystem.addParticleModifier(pModifier)`.
    Additionally, they can be removed via `particleSystem.removeParticleModifier(pModifier)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`AlphaParticleModifier`: This modifier allows a particle to shift in alpha
    values between two points in time during a particle''s lifetime. In the following
    example, the modifier will transition from an alpha value of `1` to `0` over a
    duration of `1` second. The modifier will take effect `1` second after the particle
    has spawned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ColorParticleModifier`: This modifier will allow a particle to change in color
    between two points in time during a particle''s lifetime. The following modifier
    will cause particles to change from green to red over two seconds, with a from
    time of `0`. This means the transition will begin as soon as a particle is spawned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OffCameraExpireParticleModifier`: By adding this modifier to the particle
    system, particles that leave the view of our `Camera` object will be destroyed.
    We can use this as an alternative to the `ExpireParticleInitializer` object, but
    at least one of the two should be active on any particle system. The only parameter
    to supply to this modifier is our `Camera` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RotationParticleModifier`: This modifier allows us to change the rotation
    of particles between two points in time during a particle''s lifetime. The following
    example will cause particles to rotate `180` degrees between `1` and `4` seconds
    of a particle''s lifetime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ScaleParticleModifier`: The `ScaleParticleModifier` object allows us to change
    the scale of a particle between two points in time during a particle''s lifetime.
    The following example will cause particles to grow from a scale of `0.5f` to `1.5f`
    between `1` and `3` seconds of a particle''s lifetime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IParticleModifier`: Finally, we have the particle modifier interface which
    allows us to create our own modifications to individual particles in the event
    of particle initialization or on every update to a particle via the update thread.
    The following example displays how we can simulate a particle landing on the ground
    by disabling movement on the y axis once a particle reaches less than a value
    of `20` on the `Scene` object''s coordinate system. We can use this interface
    to virtually make any changes we''d like to particles as we see fit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we've covered all of the particle emitters, particle initializers,
    and particle modifiers, practice making more complex particle systems by combining
    any number of initializers and modifiers you'd like to your own systems!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
