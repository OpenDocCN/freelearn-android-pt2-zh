["```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n   animateLogic(); \n\n   long currentTime = System.currentTimeMillis(); \n\n   drawBackground(canvas); \n   drawEPGBody(canvas, currentTime, frScrollY); \n   drawTimeBar(canvas, currentTime); \n   drawCurrentTime(canvas, currentTime); \n\n   if (missingAnimations()) invalidate(); \n} \n\n```", "```kt\nprivate static final int BACKGROUND_COLOR = 0xFF333333; \nprivate void drawBackground(Canvas canvas) { \n    canvas.drawARGB(BACKGROUND_COLOR >> 24,  \n            (BACKGROUND_COLOR >> 16) & 0xff, \n            (BACKGROUND_COLOR >> 8) & 0xff,  \n            BACKGROUND_COLOR & 0xff); \n} \n```", "```kt\nprivate void drawTimeBar(Canvas canvas, long currentTime) { \n    calendar.setTimeInMillis(initialTimeValue - 120 * 60 * 1000); \n    calendar.set(Calendar.MINUTE, 0); \n    calendar.set(Calendar.SECOND, 0); \n    calendar.set(Calendar.MILLISECOND, 0); \n\n    long time = calendar.getTimeInMillis(); \n    float x = getTimeHorizontalPosition(time) - frScrollX + getWidth()\n             / 4.f; \n\n    while (x < getWidth()) { \n        if (x > 0) { \n            canvas.drawLine(x, 0, x, timebarHeight, paintTimeBar); \n        } \n\n        if (x + timeBarTextBoundaries.width() > 0) { \n            SimpleDateFormat dateFormatter = \n                    new SimpleDateFormat(\"HH:mm\", Locale.US); \n\n            String date = dateFormatter.format(new Date(time)); \n            canvas.drawText(date, \n                    x + programMargin, \n                    (timebarHeight - timeBarTextBoundaries.height()) /\n                    2.f + timeBarTextBoundaries.height(),paintTimeBar); \n        } \n\n        time += 30 * 60 * 1000; \n        x = getTimeHorizontalPosition(time) - frScrollX + getWidth() /\n            4.f; \n    } \n\n    canvas.drawLine(0, \n            timebarHeight, \n            getWidth(), \n            timebarHeight, \n            paintTimeBar); \n} \n```", "```kt\ncalendar.setTimeInMillis(initialTimeValue - 120 * 60 * 1000); \ncalendar.set(Calendar.MINUTE, 0); \ncalendar.set(Calendar.SECOND, 0); \ncalendar.set(Calendar.MILLISECOND, 0); \n\nlong time = calendar.getTimeInMillis();  \n```", "```kt\nprivate float getTimeHorizontalPosition(long ts) { \n    long timeDifference = (ts - initialTimeValue); \n    return timeDifference * timeScale; \n} \n```", "```kt\nprivate static final float DEFAULT_TIME_SCALE = 0.0001f;  \n```", "```kt\nfinal float screenDensity = getResources().getDisplayMetrics().density; \ntimeScale = DEFAULT_TIME_SCALE * screenDensity;  \n```", "```kt\nfloat x = getTimeHorizontalPosition(time) - frScrollX + getWidth() / 4.f; \nwhile (x < getWidth()) { \n\n    ... \n\n    time += 30 * 60 * 1000; // 30 minutes \n    x = getTimeHorizontalPosition(time) - frScrollX + getWidth() / 4.f; \n} \n\n```", "```kt\nif (x > 0) { \n    canvas.drawLine(x, 0, x, timebarHeight, paintTimeBar); \n} \n\n```", "```kt\nSimpleDateFormat dateFormatter = new SimpleDateFormat(\"HH:mm\", Locale.US); \nString date = dateFormatter.format(new Date(time)); \ncanvas.drawText(date, \n        x + programMargin, \n        (timebarHeight - timeBarTextBoundaries.height()) / 2.f \n                + timeBarTextBoundaries.height(), paintTimeBar); \n\n```", "```kt\nString date = null; \nif (dateFormatted.containsKey(time)) { \n    date = dateFormatted.get(time); \n} else { \n    date = dateFormatter.format(new Date(time)); \n    dateFormatted.put(time, date); \n} \n\n```", "```kt\nprivate void drawCurrentTime(Canvas canvas, long currentTime) { \n    float currentTimePos = frChNameWidth +\n    getTimeHorizontalPosition(currentTime) - frScrollX; \n    canvas.drawRect(currentTimePos - programMargin/2, \n            0, \n            currentTimePos + programMargin/2, \n            timebarHeight, \n            paintCurrentTime); \n\n    canvas.clipRect(frChNameWidth, 0, getWidth(), getHeight()); \n    canvas.drawRect(currentTimePos - programMargin/2, \n            timebarHeight, \n            currentTimePos + programMargin/2, \n            getHeight(), \n            paintCurrentTime); \n} \n\n```", "```kt\nint startChannel = (int) (frScrollY / channelHeight); \nverticalOffset -= startChannel * channelHeight; \nint endChannel = startChannel + (int) ((getHeight() -  timebarHeight) / channelHeight) + 1; \nif (endChannel >= channelList.length) endChannel = channelList.length - 1; \n```", "```kt\nprivate static final int CHANNEL_HEIGHT = 80; \n... \nchannelHeight = CHANNEL_HEIGHT * screenDensity; \n\n```", "```kt\ncanvas.save(); \ncanvas.clipRect(0, timebarHeight, getWidth(), getHeight()); \n\nfor (int i = startChannel; i <= endChannel; i++) { \n    float channelTop = (i - startChannel) * channelHeight -\n    verticalOffset +\n    timebarHeight; \n    float channelBottom = channelTop + channelHeight; \n\n    ... \n\n} \n\ncanvas.drawLine(frChNameWidth, timebarHeight, frChNameWidth, getHeight(), paintChannelText); \ncanvas.restore(); \n\n```", "```kt\nif (channelList[i].getIcon() != null) { \n    float iconMargin = (channelHeight -\n    channelList[i].getIcon().getHeight()) / 2;\n\n    canvas.drawBitmap(channelList[i].getIcon(), iconMargin, channelTop\n    + iconMargin, null); \n\n} else { \n    if (channelTargets[i] == null) { \n        channelTargets[i] = new ChannelIconTarget(channelList[i]); \n    } \n\n    Picasso.with(context) \n            .load(channelList[i] \n            .getIconUrl()) \n            .into(channelTargets[i]); \n} \n```", "```kt\nfor (int j = 0; j < programs.size(); j++) { \n    Program program = programs.get(j); \n\n    long st = program.getStartTime(); \n    long et = program.getEndTime(); \n\n    float programStartX = getTimeHorizontalPosition(st); \n    float programEndX = getTimeHorizontalPosition(et); \n\n    if (programStartX - frScrollX > getWidth()) break; \n    if (programEndX - frScrollX >= 0) { \n\n        ... \n\n    } \n} \n```", "```kt\ncanvas.drawRoundRect(horizontalOffset + programMargin + programStartX, \n       channelTop + programMargin, \n       horizontalOffset - programMargin + programEndX, \n       channelBottom - programMargin, \n       programMargin, \n       programMargin, \n       paintProgram); \n\ncanvas.save(); \ncanvas.clipRect(horizontalOffset + programMargin * 2 + programStartX, \n       channelTop + programMargin, \n       horizontalOffset - programMargin * 2 + programEndX, \n       channelBottom - programMargin); \n\npaintProgramText.getTextBounds(program.getName(), 0, program.getName().length(), textBoundaries); \nfloat textPosition = channelTop + textBoundaries.height() + ((channelHeight - programMargin * 2) - textBoundaries.height()) / 2; \ncanvas.drawText(program.getName(), \n           horizontalOffset + programMargin * 2 + programStartX, \n           textPosition, \n           paintProgramText); \ncanvas.restore(); \n\n```", "```kt\nif (st <= currentTime && et > currentTime) { \n    paintProgram.setColor(HIGHLIGHTED_PROGRAM_COLOR); \n    paintProgramText.setColor(Color.BLACK); \n} else { \n    paintProgram.setColor(PROGRAM_COLOR); \n    paintProgramText.setColor(Color.WHITE); \n} \n\n```", "```kt\nprivate void animateLogic() { \n    long currentTime = SystemClock.elapsedRealtime(); \n    accTime += currentTime - timeStart; \n    timeStart = currentTime; \n\n    while (accTime > TIME_THRESHOLD) { \n        scrollX += (scrollXTarget - scrollX) / 4.f; \n        scrollY += (scrollYTarget - scrollY) / 4.f; \n        chNameWidth += (chNameWidthTarget - chNameWidth) / 4.f; \n        accTime -= TIME_THRESHOLD; \n    } \n\n    float factor = ((float) accTime) / TIME_THRESHOLD; \n    float nextScrollX = scrollX + (scrollXTarget - scrollX) / 4.f; \n    float nextScrollY = scrollY + (scrollYTarget - scrollY) / 4.f; \n    float nextChNameWidth = chNameWidth + (chNameWidthTarget -\n                            chNameWidth) / 4.f; \n\n    frScrollX = scrollX * (1.f - factor) + nextScrollX * factor; \n    frScrollY = scrollY * (1.f - factor) + nextScrollY * factor; \n    frChNameWidth = chNameWidth * (1.f - factor) + nextChNameWidth *\n    factor; \n} \n\n```", "```kt\nif (!shortChannelMode) { \n    paintChannelText.getTextBounds(channelList[i].getName(), \n            0, \n            channelList[i].getName().length(), \n            textBoundaries); \n\n    canvas.drawText(channelList[i].getName(), \n            channelHeight - programMargin * 2, \n            (channelHeight - textBoundaries.height()) / 2 +\n             textBoundaries.height() + channelTop, \n            paintChannelText); \n} \n\n```", "```kt\nif (shortChannelMode) { \n    chNameWidthTarget = channelHeight * 2; \n    shortChannelMode = false; \n} else { \n    chNameWidthTarget = channelHeight; \n    shortChannelMode = true; \n}  \n```", "```kt\nprivate float dragX; \nprivate float dragY; \nprivate boolean dragged; \n\n... \n\n@Override \npublic boolean onTouchEvent(MotionEvent event) { \n\n    switch(event.getAction()) { \n        case MotionEvent.ACTION_DOWN: \n            dragX = event.getX(); \n            dragY = event.getY(); \n\n            getParent().requestDisallowInterceptTouchEvent(true); \n            dragged = false; \n            return true; \n\n        case MotionEvent.ACTION_UP: \n            if (!dragged) { \n                // touching inside the channel area, will toggle\n                   large/short channels \n                if (event.getX() < frChNameWidth) { \n                    switchNameWidth = true; \n                    invalidate(); \n                } \n            } \n\n            getParent().requestDisallowInterceptTouchEvent(false); \n            return true; \n\n        case MotionEvent.ACTION_MOVE: \n            float newX = event.getX(); \n            float newY = event.getY(); \n\n            scrollScreen(dragX - newX, dragY - newY); \n\n            dragX = newX; \n            dragY = newY; \n            dragged = true; \n            return true; \n        default: \n            return false; \n    } \n} \n\n```", "```kt\nprivate void scrollScreen(float dx, float dy) { \n    scrollXTarget += dx; \n    scrollYTarget += dy; \n\n    if (scrollXTarget < -chNameWidth) scrollXTarget = -chNameWidth; \n    if (scrollYTarget < 0) scrollYTarget = 0; \n\n    float maxHeight = channelList.length * channelHeight - getHeight()\n    + 1 + timebarHeight; \n    if (scrollYTarget > maxHeight) scrollYTarget = maxHeight; \n\n    invalidate(); \n} \n```", "```kt\nif (missingAnimations()) invalidate(); \n```", "```kt\nprivate static final float ANIM_THRESHOLD = 0.01f; \n\nprivate boolean missingAnimations() { \n    if (Math.abs(scrollXTarget - scrollX) > ANIM_THRESHOLD) \n    return true;\n\nif (Math.abs(scrollYTarget - scrollY) > ANIM_THRESHOLD)\n    return true;\n\nif (Math.abs(chNameWidthTarget - chNameWidth) > ANIM_THRESHOLD)\n    return true;\n\nreturn false;\n} \n```", "```kt\nscaleDetector = new ScaleGestureDetector(context,  \n    new ScaleGestureDetector.SimpleOnScaleGestureListener() {  \n\n    ... \n\n    }); \n\n```", "```kt\n@Override \npublic boolean onTouchEvent(MotionEvent event) { \n    scaleDetector.onTouchEvent(event); \n\n    if (zooming) { \n        zooming = false; \n        return true; \n    } \n\n    ... \n\n} \n\n```", "```kt\nscaleDetector = new ScaleGestureDetector(context, new ScaleGestureDetector.SimpleOnScaleGestureListener() { \n    private long focusTime; \n    private float scrollCorrection = 0.f; \n    @Override \n    public boolean onScaleBegin(ScaleGestureDetector detector) { \n        zooming = true; \n        focusTime = getHorizontalPositionTime(scrollXTarget +\n        detector.getFocusX() - frChNameWidth); \n        scrollCorrection = getTimeHorizontalPosition((focusTime)) -\n        scrollXTarget; \n        return true; \n    } \n\n    public boolean onScale(ScaleGestureDetector detector) { \n        timeScale *= detector.getScaleFactor(); \n        timeScale = Math.max(DEFAULT_TIME_SCALE * screenDensity / 2,  \n                        Math.min(timeScale, DEFAULT_TIME_SCALE *\n                        screenDensity * 4)); \n\n        // correct scroll position otherwise will move too much when\n           zooming \n        float current = getTimeHorizontalPosition((focusTime)) -\n        scrollXTarget; \n        float scrollDifference = current - scrollCorrection; \n        scrollXTarget += scrollDifference; \n        zooming = true; \n\n        invalidate(); \n        return true; \n    } \n\n    @Override \n    public void onScaleEnd(ScaleGestureDetector detector) { \n        zooming = true; \n    } \n}); \n\n```", "```kt\ntimeScale *= detector.getScaleFactor(); \ntimeScale = Math.max(DEFAULT_TIME_SCALE * screenDensity / 2,  \n                Math.min(timeScale, DEFAULT_TIME_SCALE * screenDensity\n                * 4)); \n```", "```kt\nfloat current = getTimeHorizontalPosition((focusTime)) - scrollXTarget; \nfloat scrollDifference = current - scrollCorrection; \nscrollXTarget += scrollDifference; \n\n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<resources> \n    <declare-styleable name=\"EPG\"> \n        <attr name=\"backgroundColor\" format=\"color\"/> \n        <attr name=\"programColor\" format=\"color\"/> \n        <attr name=\"highlightedProgramColor\" format=\"color\"/> \n        <attr name=\"currentTimeColor\" format=\"color\"/> \n        <attr name=\"channelTextColor\" format=\"color\"/> \n        <attr name=\"programTextColor\" format=\"color\"/> \n        <attr name=\"highlightedProgramTextColor\" format=\"color\"/> \n        <attr name=\"timeBarColor\" format=\"color\"/> \n\n        <attr name=\"channelHeight\" format=\"float\"/> \n        <attr name=\"programMargin\" format=\"float\"/> \n        <attr name=\"timebarHeight\" format=\"float\"/> \n    </declare-styleable> \n</resources> \n```", "```kt\nTypedArray ta = context.getTheme().obtainStyledAttributes(attrs, R.styleable.EPG, 0, 0); \ntry { \n    backgroundColor = ta.getColor(R.styleable.EPG_backgroundColor,\n    BACKGROUND_COLOR); \n    paintChannelText.setColor(ta.getColor(R.styleable.EPG_channelTextColor\n                          Color.WHITE)); \n    paintCurrentTime.setColor(ta.getColor(R.styleable.EPG_currentTimeColor,\n                          CURRENT_TIME_COLOR)); \n    paintTimeBar.setColor(ta.getColor(R.styleable.EPG_timeBarColor,\n                          Color.WHITE)); \n\n    highlightedProgramColor =\n    ta.getColor(R.styleable.EPG_highlightedProgramColor,\n        HIGHLIGHTED_PROGRAM_COLOR);\n\n    programColor = ta.getColor(R.styleable.EPG_programColor,\n    PROGRAM_COLOR);\n\n    channelHeight = ta.getFloat(R.styleable.EPG_channelHeight,\n    CHANNEL_HEIGHT) * screenDensity;\n\n    programMargin = ta.getFloat(R.styleable.EPG_programMargin,\n    PROGRAM_MARGIN) * screenDensity;\n\n    timebarHeight = ta.getFloat(R.styleable.EPG_timebarHeight,\n    TIMEBAR_HEIGHT) * screenDensity;\n\n    programTextColor = ta.getColor(R.styleable.EPG_programTextColor,\n    Color.WHITE);\n\n    highlightedProgramTextColor =\n    ta.getColor(R.styleable.EPG_highlightedProgramTextColor,\n        Color.BLACK);\n} finally { \n    ta.recycle(); \n} \n```", "```kt\n<attr name=\"channelHeight\" format=\"dimension\"/> \n<attr name=\"programMargin\" format=\"dimension\"/> \n<attr name=\"timebarHeight\" format=\"dimension\"/> \n```", "```kt\nchannelHeight = ta.getDimension(R.styleable.EPG_channelHeight, \n        CHANNEL_HEIGHT * screenDensity); \n\nprogramMargin = ta.getDimension(R.styleable.EPG_programMargin, \n        PROGRAM_MARGIN * screenDensity); \n\ntimebarHeight = ta.getDimension(R.styleable.EPG_timebarHeight, \n        TIMEBAR_HEIGHT * screenDensity); \n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<LinearLayout  \n\n    android:layout_width=\"match_parent\" \n    android:layout_height=\"match_parent\" \ntools:context=\"com.rrafols.packt.epg.MainActivity\"> \n\n    <com.rrafols.packt.epg.EPG \n        android:id=\"@+id/epg_view\" \n        android:layout_width=\"match_parent\" \n        android:layout_height=\"match_parent\" \n        app:channelHeight=\"80dp\"\n        app:highlightedProgramColor=\"#ffffdd20\"\n        app:highlightedProgramTextColor=\"#ff000000\"/>\n</LinearLayout>  \n```", "```kt\ninterface EPGCallback { \n    void programClicked(Channel channel, Program program); \n} \n\n```", "```kt\nif (event.getX() < frChNameWidth) { \n\n    ... \n\n} else { \n    clickProgram(event.getX(), event.getY()); \n} \n\n```", "```kt\nprivate void clickProgram(float x, float y) { \n    long ts = getHorizontalPositionTime(scrollXTarget + x -\n    frChNameWidth); \n    int channel = (int) ((y + frScrollY - timebarHeight) / \n    channelHeight); \n\n    ArrayList<Program> programs = channelList[channel].getPrograms(); \n    for (int i = 0; i < programs.size(); i++) { \n        Program pr = programs.get(i); \n        if (ts >= pr.getStartTime() && ts < pr.getEndTime()) { \n            if (callback != null) { \n                callback.programClicked(channelList[channel], pr); \n            } \n            break; \n        } \n    } \n}  \n```", "```kt\n@Override \nprotected void onCreate(Bundle savedInstanceState) { \n    super.onCreate(savedInstanceState); \n    setContentView(R.layout.activity_main); \n\n    EPG epg = (EPG) findViewById(R.id.epg_view); \n    epg.setCallback(new EPG.EPGCallback() { \n        @Override \n        public void programClicked(Channel channel, Program program) { \n            Log.d(\"EPG\", \"program clicked: \" + program.getName() + \"\n            channel: \" + channel.getName()); \n        } \n    }); \n\n    populateDummyChannelList(epg); \n} \n\n```"]