- en: Chapter 10. Third-Party Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 第三方库
- en: Xamarin supports a subset of the .NET framework, but for the most part includes
    all the standard APIs you would expect in the .NET base class libraries. Because
    of this, a large portion of C# open-source libraries can be used directly in Xamarin
    projects. Additionally, if an open source project doesn't have a Xamarin or portable
    class library version, porting the code to be used in a Xamarin project can often
    be very straightforward. Xamarin also supports calling native Objective-C and
    Java libraries, so we will explore these as additional means of reusing existing
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin支持.NET框架的一个子集，但大部分包括了您在.NET基类库中期望的所有标准API。因此，大量的C#开源库可以直接在Xamarin项目中使用。此外，如果一个开源项目没有Xamarin或可移植类库版本，将代码移植到Xamarin项目中通常非常直接。Xamarin还支持调用原生Objective-C和Java库，因此我们将探索这些作为重用现有代码的额外手段。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The Xamarin Component Store
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin组件商店
- en: Porting existing C# libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植现有的C#库
- en: Objective-C bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C绑定
- en: Java bindings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java绑定
- en: The Xamarin Component Store
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin组件商店
- en: The primary and obvious way to add third-party components to your project is
    via the Xamarin Component Store. The Component Store is fairly similar to the
    *NuGet package manager* that all C# developers are familiar with, except that
    the Component Store also contains premium components that are not free. All Xamarin
    components are also required to include full sample projects and a Getting Started
    guide, while NuGet does not inherently provide documentation in its packages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加第三方组件的主要且明显的方式是通过Xamarin组件商店。组件商店与所有C#开发者都熟悉的*NuGet包管理器*非常相似，不同之处在于组件商店还包含不免费的付费组件。所有Xamarin组件还必须包含完整的示例项目和入门指南，而NuGet在其包中并不固有地提供文档。
- en: 'All `Xamarin.iOS` and `Xamarin.Android` projects come with a `Components` folder.
    To get started, simply right-click on the folder, and select **Get More Components**
    to launch the store dialog, shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Xamarin.iOS`和`Xamarin.Android`项目都带有一个`Components`文件夹。要开始使用，只需右键点击该文件夹，选择**获取更多组件**来启动商店对话框，如下面的截图所示：
- en: '![The Xamarin Component Store](img/image00258.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin组件商店](img/image00258.jpeg)'
- en: At the time of writing this book, there are well over 200 components available
    to enhance your iOS and Android applications. This is a great place to find the
    most common components to use within your Xamarin applications. Each component
    is complete with artwork, possibly a demonstration video, reviews, and other information
    you would need before purchasing a premium component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，有超过200个组件可用于增强您的iOS和Android应用程序。这是寻找Xamarin应用程序中最常见组件的好地方。每个组件都附有插图、可能的演示视频、评论以及其他在购买付费组件之前需要的信息。
- en: 'The most well-known and useful components are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最知名且有用的组件如下：
- en: '**Json.NET**: This is the de facto standard for parsing and serializing JSON
    with C#'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Json.NET**：这是在C#中解析和序列化JSON的事实上的标准。 '
- en: '**RestSharp**: This is a commonly used simple REST client for .NET'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RestSharp**：这是一个在.NET中常用的简单REST客户端。'
- en: '**SQLite.NET**: This is a simple **Object Relational Mapping** (**ORM**) for
    working with local SQLite databases in your mobile applications'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite.NET**：这是一个简单的**对象关系映射**（**ORM**）工具，用于在移动应用程序中操作本地SQLite数据库。'
- en: '**Facebook SDK**: This is the standard SDK provided by Facebook for integrating
    its services into your apps'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Facebook SDK**：这是Facebook提供的标准软件开发工具包，用于将Facebook的服务集成到您的应用程序中。'
- en: '**Xamarin.Mobile**: This is a cross-platform library for accessing your device''s
    contacts, GPS, photo library, and camera with a common API'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xamarin.Mobile**：这是一个跨平台库，通过公共API访问设备的联系人、GPS、照片库和相机。'
- en: '**ZXing.Net.Mobile**: A .NET version of the popular barcode-scanning library,
    **ZXing** (**Zebra Crossing**).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ZXing.Net.Mobile**：流行的条形码扫描库**ZXing**（**Zebra Crossing**）的.NET版本。'
- en: Notice that some of these libraries are native Java or Objective-C libraries,
    while some are plain C#. Xamarin is built from the ground up to support calling
    native libraries, so the Component Store offers many of the common libraries that
    Objective-C or Java developers would leverage when developing mobile applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其中一些库是原生Java或Objective-C库，而有些则是纯C#库。Xamarin从底层开始构建，以支持调用原生库，因此组件商店提供了许多Objective-C或Java开发者在开发移动应用程序时会使用的常见库。
- en: 'You can also submit your own components to the Component Store. If you have
    a useful open source project or just want to earn a little extra cash, creating
    a component is simple. We won''t be covering it in this book, but navigate to
    [http://components.xamarin.com/submit](http://components.xamarin.com/submit) for
    full documentation on the subject, as shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将你自己的组件提交到组件商店。如果你有一个有用的开源项目，或者只是想赚点外快，创建一个组件很简单。我们在这本书中不会涉及，但可以访问[http://components.xamarin.com/submit](http://components.xamarin.com/submit)了解该主题的完整文档，如下面的截图所示：
- en: '![The Xamarin Component Store](img/image00259.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin组件商店](img/image00259.jpeg)'
- en: Porting existing C# libraries
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移现有C#库
- en: Even though Xamarin is becoming a popular platform, many open-source .NET libraries
    are simply not up to speed with supporting `Xamarin.iOS` and `Xamarin.Android`.
    But in these cases, you are definitely not out of luck. Often, if there is a Silverlight
    or Windows Phone version of the library, you can simply create an iOS or Android
    class library and add the files with no code changes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Xamarin正在成为一个流行的平台，但许多开源.NET库在支持`Xamarin.iOS`和`Xamarin.Android`方面还远远跟不上。但在这些情况下，你绝对不是没有机会。通常，如果库有Silverlight或Windows
    Phone版本，你可以简单创建一个iOS或Android类库，并添加文件，无需更改代码。
- en: To illustrate this process, let's port an open source project that doesn't have
    Xamarin or portable class library support. I have selected a dependency injection
    library called **Ninject**, due to its usefulness and relationship to ninjas.
    Find out more about the library at [http://www.ninject.org/](http://www.ninject.org/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个过程，让我们迁移一个没有Xamarin或可移植类库支持的的开源项目。我选择了一个名为**Ninject**的依赖注入库，因为它的实用性和与忍者的关联。更多关于该库的信息可以在[http://www.ninject.org/](http://www.ninject.org/)找到。
- en: 'Let''s begin setting up the library to work with Xamarin projects as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置库以与Xamarin项目一起工作，如下所示：
- en: First, download the source code for Ninject from [https://github.com/ninject/ninject](https://github.com/ninject/ninject).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从[https://github.com/ninject/ninject](https://github.com/ninject/ninject)下载Ninject的源代码。
- en: Create a new solution with an **iOS Class Library** project named `Ninject.iOS`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Ninject.iOS`的新的解决方案，其中包含一个**iOS类库**项目。
- en: Link in all the files from the `Ninject` main project. Make sure you use the
    **Add Existing Folder** dialog to speed up this process.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Ninject`主项目中的所有文件链接进来。确保使用**添加现有文件夹**对话框以加快此过程。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you aren't familiar with GitHub, I recommend downloading GitHub Desktop,
    a nice client app for either Windows or OS X found at [https://desktop.github.com/](https://desktop.github.com/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉GitHub，我建议下载GitHub桌面客户端，这是一个适用于Windows或OS X的优质客户端应用，可在[https://desktop.github.com/](https://desktop.github.com/)找到。
- en: 'Now try to build the `Ninject.iOS` project; you will get several compiler errors
    in a file named `DynamicMethodFactory.cs`, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试编译`Ninject.iOS`项目；你会在一个名为`DynamicMethodFactory.cs`的文件中遇到几个编译错误，如下面的截图所示：
- en: '![Porting existing C# libraries](img/image00260.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![迁移现有C#库](img/image00260.jpeg)'
- en: 'Open `DynamicMethodInjectorFactory.cs` and notice the following code at the
    top of the file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`DynamicMethodInjectorFactory.cs`文件，并注意文件顶部以下代码：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is not possible to use `System.Reflection.Emit` on iOS due to Apple's platform
    restrictions. Luckily, the library writers have created a preprocessor directive
    called `NO_LCG` (which stands for **Lightweight Code Generation**) to allow the
    library to run on platforms that do not support `System.Reflection.Emit`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于苹果平台的限制，在iOS上无法使用`System.Reflection.Emit`。幸运的是，库作者创建了一个名为`NO_LCG`（代表**轻量级代码生成**）的预处理器指令，以允许库在不支持`System.Reflection.Emit`的平台运行。
- en: 'To fix our iOS project, follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复我们的iOS项目，请按照以下步骤操作：
- en: Open the project options and navigate to the **Build** | **Compiler** section.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目选项，导航到**构建** | **编译器**部分。
- en: Add `NO_LCG` to the **Define Symbols** field for both **Debug** and **Release**
    in the **Configuration** dropdown.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**配置**下拉菜单中，为**调试**和**发布**的**定义符号**字段添加`NO_LCG`。
- en: Click on **OK** to save your changes.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以保存你的更改。
- en: If you compile the project now, it will be completed successfully and a `Ninject.iOS.dll`
    file will be created, which you can reference from any `Xamarin.iOS` project.
    You can also reference the `Ninject.iOS` project directly instead of using the
    `*.dll` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在编译项目，它将成功完成，并创建一个`Ninject.iOS.dll`文件，你可以从任何`Xamarin.iOS`项目中引用它。你也可以直接引用`Ninject.iOS`项目，而不是使用`*.dll`文件。
- en: At this point, you may wish to repeat the process to create a `Xamarin.Android`
    class library project. Luckily, `Xamarin.Android` supports `System.Reflection.Emit`,
    so you can skip adding the additional preprocessor directive if you wish.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能希望重复该过程以创建一个`Xamarin.Android`类库项目。幸运的是，`Xamarin.Android`支持`System.Reflection.Emit`，所以如果你愿意，可以跳过添加额外的预处理器指令。
- en: Objective-C bindings
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C绑定
- en: Xamarin has developed a sophisticated system for calling native Objective-C
    libraries from C# in iOS projects. The core of `Xamarin.iOS` uses this same technology
    to call native Apple APIs in **UIKit**, **CoreGraphics**, and other iOS frameworks.
    Developers can create iOS binding projects to expose Objective-C classes and methods
    to C# using simple interfaces and attributes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin开发了一个复杂的系统，用于在iOS项目中从C#调用本地Objective-C库。`Xamarin.iOS`的核心使用相同的技术来调用**UIKit**、**CoreGraphics**和其他iOS框架中的本地Apple
    API。开发者可以使用简单的接口和属性创建iOS绑定项目，将Objective-C类和方法暴露给C#。
- en: To aid in creating Objective-C bindings, Xamarin has created a small tool named
    **Objective Sharpie** that can process Objective-C header files for you and export
    the valid C# definitions to add to a binding project. This tool is a great starting
    point for most bindings and will get about 75% of your binding project working
    in most cases. You will want to hand-edit and fine-tune things to be more C#-friendly
    most of the time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助创建Objective-C绑定，Xamarin创建了一个名为**Objective Sharpie**的小工具，它可以处理Objective-C头文件并导出有效的C#定义，以便添加到绑定项目中。这个工具是大多数绑定的良好起点，在大多数情况下，它可以让你的绑定项目完成大约75%的工作。大多数时候，你可能想要手动编辑并精细调整，使其更友好地适应C#。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that iOS binding projects can be created in Visual Studio; however, Objective
    Sharpie is a command-line tool for OS X. It leverages tooling included with Xcode,
    so iOS binding development is best accomplished on Mac OS X.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，iOS绑定项目可以在Visual Studio中创建；然而，Objective Sharpie是一个OS X的命令行工具。它利用了Xcode中包含的工具，因此iOS绑定开发最好在Mac
    OS X上完成。
- en: As an example, we will write a binding for the Google Analytics library for
    iOS. It is a simple and useful library that can track user activities in your
    iOS or Android applications. At the time of writing, the version of the Google
    Analytics SDK is 3.17, so some of these instructions may change as new versions
    are released.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将为iOS编写Google Analytics库的绑定。这是一个简单且有用的库，可以跟踪你的iOS或Android应用程序中的用户活动。在编写时，Google
    Analytics SDK的版本是3.17，因此随着新版本的发布，这些说明可能会发生变化。
- en: 'Download and install Objective Sharpie from [https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/](https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/)
    and perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/](https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/)下载并安装Objective
    Sharpie，并执行以下步骤：
- en: Download the latest Google Analytics SDK for iOS available at [https://tinyurl.com/GoogleAnalyticsForiOS](https://tinyurl.com/GoogleAnalyticsForiOS).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://tinyurl.com/GoogleAnalyticsForiOS](https://tinyurl.com/GoogleAnalyticsForiOS)下载最新的iOS
    Google Analytics SDK。
- en: Create a new **iOS** | **Bindings Library** project named `GoogleAnalytics.iOS`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**iOS** | **绑定库**项目，名为`GoogleAnalytics.iOS`。
- en: Extract the contents of the zip file from step 1 and move the `GoogleAnalytics`
    folder into the same directory as the bindings project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一步中提取zip文件的内容，并将`GoogleAnalytics`文件夹移动到与绑定项目相同的目录中。
- en: Open **Terminal** and navigate to the same directory as the new project.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**终端**并导航到新项目的同一目录。
- en: 'Run **Objective Sharpie** with the following commands:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行**Objective Sharpie**：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Objective Sharpie will output two files: `ApiDefinitions.cs` and `Structs.cs`.
    The second two commands will copy the files over the top of the default files
    from the **Bindings Library** project template created.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Objective Sharpie将输出两个文件：`ApiDefinitions.cs`和`Structs.cs`。接下来的两个命令将把文件复制到由**绑定库**项目模板创建的默认文件之上。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that at the time of writing, the iOS 10 SDK is used in the preceding command.
    To discover what you need to put for the `--sdk` option, run `sharpie xcode --sdks`
    and you will see the value printed in the output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在编写此命令时，使用了iOS 10 SDK。要发现你需要为`--sdk`选项输入什么，请运行`sharpie xcode --sdks`，你将在输出中看到打印出的值。
- en: Now, if you return to your binding project, you'll notice that Objective Sharpie
    has generated an interface definition for every class discovered in the header
    files of the library. It has also generated many `enum` values that the library
    uses and changed casing and naming conventions to follow C# more closely where
    possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的绑定项目，你会注意到 Objective Sharpie 已经为库中头文件中发现的每个类生成了一个接口定义。它还生成了库使用的许多 `enum`
    值，并在可能的情况下更改大小写和命名约定以更接近 C#。
- en: 'As you read through the binding, you''ll notice several C# attributes that
    define different aspects about the Objective-C library, such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读绑定内容时，你会注意到几个 C# 属性，它们定义了关于 Objective-C 库的不同方面，例如以下内容：
- en: '`BaseType`: This declares an interface as an Objective-C class. The base class
    (also called superclass) is passed in to the attribute. If it has no base class,
    `NSObject` should be used.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseType`：这会将接口声明为一个 Objective-C 类。基类（也称为超类）会传递给属性。如果没有基类，应使用 `NSObject`。'
- en: '`Export`: This declares a method or property on an Objective-C class. A string
    that maps the Objective-C name to the C# name is passed in. Objective-C method
    names are generally in the following form: `myMethod:someParam:someOtherParam`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Export`：这会在 Objective-C 类上声明一个方法或属性。传递一个将 Objective-C 名称映射到 C# 名称的字符串。Objective-C
    方法名通常如下形式：`myMethod:someParam:someOtherParam`。'
- en: '`Static`: This marks a method or property as `static` in C#.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Static`：这会将方法或属性标记为 C# 中的 `static`。'
- en: '`Bind`: This is used on properties to map a getter or setter to a different
    Objective-C method. Objective-C properties can rename a getter or setter for a
    property.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind`：用于属性上，将 getter 或 setter 映射到不同的 Objective-C 方法。Objective-C 属性可以为属性的 getter
    或 setter 重命名。'
- en: '`NullAllowed`: This allows `null` to be passed to a method or property. By
    default, an exception is thrown if this occurs.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullAllowed`：这允许将 `null` 传递给方法或属性。默认情况下，如果发生这种情况，将抛出异常。'
- en: '`Field`: This declares an Objective-C field that is exposed as a public variable
    in C#.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Field`：这会声明一个 Objective-C 字段，在 C# 中作为公共变量暴露。'
- en: '`Model`: This identifies a class to `Xamarin.iOS` to have methods that can
    be optionally overridden. This is generally used on Objective-C delegates.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model`：这标识了一个类到 `Xamarin.iOS`，其方法可以选择性地被重写。这通常用于 Objective-C 委托。'
- en: '`Internal`: This flags the generated member with the C# internal keyword. It
    can be used to hide certain members that you don''t want to expose to the outside
    world.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Internal`：这用 C# 内部关键字标记生成的成员。它可以用来隐藏那些你不想暴露给外部世界的特定成员。'
- en: '`Abstract`: This identifies an Objective-C method as required, which goes hand
    in hand with `Model`. In C#, it will generate an abstract method.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abstract`：这标识了一个 Objective-C 方法为必需的，与 `Model` 密切相关。在 C# 中，它将生成一个抽象方法。'
- en: The only other rule to know is how to define constructors. Xamarin had to invent
    a convention for this, since C# interfaces do not support constructors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的唯一其他规则是如何定义构造函数。由于 C# 接口不支持构造函数，Xamarin 必须为此发明一个约定。
- en: 'To define a constructor besides the default one, use the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义除了默认构造函数之外的构造函数，请使用以下代码：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This would define a constructor on the class that takes in `RectangleF` as a
    parameter. The method name, `Constructor`, and the return type, `IntPtr`, signal
    the Xamarin compiler to generate a constructor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在类上定义一个构造函数，该构造函数以 `RectangleF` 作为参数。方法名 `Constructor` 和返回类型 `IntPtr` 会让 Xamarin
    编译器生成一个构造函数。
- en: 'Now, let''s return to our binding project to finish setting everything up.
    If you compile the project at this point, you''ll get a few compiler errors. Let''s
    fix them one by one, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的绑定项目以完成所有设置。如果在这一点上编译项目，你会得到几个编译错误。让我们逐一修复它们，如下所示：
- en: Add `libGoogleAnalyticsServices.a` and `libAdIdAccess.a` from the Google Analytics
    download as **Native References**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Google Analytics 下载中的 `libGoogleAnalyticsServices.a` 和 `libAdIdAccess.a` 添加为**本地引用**。
- en: Change the base type of the enums `GAILogLevel` and `GAIDispatchResult` found
    in `Structs.cs` to `ulong`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改 `Structs.cs` 中找到的枚举 `GAILogLevel` 和 `GAIDispatchResult` 的基类型为 `ulong`。
- en: Remove duplicate declarations of `[Static]` from the `Constants` class found
    in `ApiDefinitions.cs`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ApiDefinitions.cs` 中找到的 `Constants` 类中移除 `[Static]` 的重复声明。
- en: Remove all the `Verify` attributes. These are spots where Objective Sharpie
    was unsure of the operation it performed. In our example, all of them are fine,
    so it is safe to remove them.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有的 `Verify` 属性。这些是 Objective Sharpie 对其执行的操作不确定的地方。在我们的示例中，它们都是好的，所以安全地移除它们。
- en: 'At this point, if you tried to use the library in an iOS project you would
    get an error such as the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你尝试在iOS项目中使用该库，你会得到如下错误：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We need to define the other frameworks and libraries that the Objective-C library
    uses. This is very similar to how references work in C#. If we review the Google
    Analytics documentation, it says that you must add `CoreData`, `SystemConfiguration`,
    and `libsqlite3.dylib`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义Objective-C库使用的其他框架和库。这类似于C#中引用的工作方式。如果我们查看Google Analytics文档，它会告诉你必须添加`CoreData`、`SystemConfiguration`和`libsqlite3.dylib`。
- en: 'Right-click on the Native reference to `libGoogleAnalyticsServices`, choose
    **Properties**, and make the following changes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击到`libGoogleAnalyticsServices`的本地引用，选择**属性**，并进行以下更改：
- en: Set `Frameworks` to `CoreData SystemConfiguration`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Frameworks`设置为`CoreData SystemConfiguration`。
- en: Set `Linker Flags` to `-lsqlite3`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Linker Flags`设置为`-lsqlite3`。
- en: 'Native Objective-C libraries reference other libraries with one of the following
    options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 原生Objective-C库通过以下选项之一引用其他库：
- en: '**Frameworks**: Add them to the `Frameworks` value on the `LinkWith` attribute,
    delimited by spaces.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架**：将它们添加到`LinkWith`属性的`Frameworks`值中，用空格分隔。'
- en: '**Weak Frameworks**: Add them to the `WeakFrameworks` property on the `LinkWith`
    attribute in the same manner. Weak frameworks are libraries that can be ignored
    if they are not found. In this case, `AdSupport` was added in iOS 6; however,
    this library will still work on older versions of iOS.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱框架**：以同样的方式将它们添加到`LinkWith`属性的`WeakFrameworks`属性中。弱框架是可以忽略的库（如果找不到）。在这种情况下，iOS
    6中添加了`AdSupport`；然而，这个库仍然可以在旧版本的iOS上工作。'
- en: '**Dynamic Libraries**: Libraries such as `libz.dylib` can be declared in `LinkerFlags`.
    Generally, you drop the `.dylib` extension and replace `lib` with `-l`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态库**：如`libz.dylib`可以在`LinkerFlags`中声明。通常，去掉`.dylib`扩展名，并将`lib`替换为`-l`。'
- en: After these changes are implemented, you will be able to successfully use the
    library from iOS projects. For complete documentation on Objective-C bindings,
    visit the Xamarin documentation site at [https://developer.xamarin.com/guides/ios/](https://developer.xamarin.com/guides/ios/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，你将能够从iOS项目中成功使用该库。要了解有关Objective-C绑定的完整文档，请访问Xamarin文档网站：[https://developer.xamarin.com/guides/ios/](https://developer.xamarin.com/guides/ios/)。
- en: Java bindings
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java绑定
- en: In the same manner as iOS, Xamarin has provided full support for calling into
    Java libraries from C# with `Xamarin.Android`. The native Android SDKs function
    in this way and developers can leverage the `Android Java Bindings` project to
    take advantage of other native Java libraries in C#. The main difference here
    is that not a lot has to be done by hand in comparison to Objective-C bindings.
    The Java syntax is very similar to that of C#, so many mappings are exactly one-to-one.
    In addition, Java has metadata information included with its libraries, which
    Xamarin uses to automatically generate the C# code required for calling into Java.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS类似，Xamarin完全支持通过`Xamarin.Android`从C#调用Java库。原生Android SDK以这种方式工作，开发者可以利用`Android
    Java Bindings`项目在C#中利用其他原生Java库。这里的主要区别是，与Objective-C绑定相比，手动操作要少得多。Java语法与C#非常相似，因此许多映射都是一一对应的。此外，Java的库中包含了元数据信息，Xamarin利用这些信息自动生成调用Java所需的C#代码。
- en: As an example, let's make a binding for the Android version of the Google Analytics
    SDK. Before we begin, download the SDK at [https://developers.google.com/analytics/devguides/collection/android/v3/](https://developers.google.com/analytics/devguides/collection/android/v3/).
    At the time of writing, Google Analytics is being migrated to Google Play Services,
    but we will use this Java library as an exercise for creating Java bindings to
    be consumed by C#.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们为Google Analytics SDK的Android版本创建一个绑定。在开始之前，下载SDK：[https://developers.google.com/analytics/devguides/collection/android/v3/](https://developers.google.com/analytics/devguides/collection/android/v3/)。在撰写本文时，Google
    Analytics正在迁移到Google Play Services，但我们将使用这个Java库作为一个练习，用于创建供C#使用的Java绑定。
- en: 'Let''s begin creating a Java binding as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始创建Java绑定：
- en: Start a new `Android | Library | Bindings Library` project in Xamarin Studio.
    You may use the same solution as we did for iOS if you wish.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中启动一个全新的`Android | Library | Bindings Library`项目。如果你愿意，可以使用与iOS相同的解决方案。
- en: Name the project `GoogleAnalytics.Droid`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`GoogleAnalytics.Droid`。
- en: Add `libGoogleAnalyticsServices.jar` from the Android SDK to the project under
    the `Jars` folder.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Android SDK中将`libGoogleAnalyticsServices.jar`添加到项目下的`Jars`文件夹中。
- en: Build the project. You will get a few errors, which we'll address in a moment.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。你将得到一些错误，我们稍后会解决这些问题。
- en: Most of the time you spend working on Java bindings will be to fix small issues
    that prevent the generated C# code from compiling. But don't fret; a lot of libraries
    will work on the first try without having to make any changes at all. Generally,
    the larger the Java library is, the more work you have to do to get it working
    with C#.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Java绑定上花费的大部分时间将用于修复阻止生成的C#代码编译的小问题。但是不要担心；许多库在第一次尝试时无需进行任何更改就能正常工作。通常，Java库越大，你需要做的工作就越多，以使其与C#一起工作。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that if you get no errors upon first compile, but many warnings saying
    something to the effect of `unsupported major.minor version 52.0`, then you need
    to install a newer version of the Java JDK. Download JDK 1.8 from [http://tinyurl.com/XamarinJDK8](http://tinyurl.com/XamarinJDK8),
    and point Xamarin Studio or Visual Studio to the newer version of the JDK in settings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你首次编译时没有错误，但是有许多警告，提示类似于`unsupported major.minor version 52.0`的内容，那么你需要安装较新版本的Java
    JDK。从[http://tinyurl.com/XamarinJDK8](http://tinyurl.com/XamarinJDK8)下载JDK 1.8，并在设置中指向Xamarin
    Studio或Visual Studio的新版本JDK。
- en: 'The following are the types of issue you may run into:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到以下问题类型：
- en: '**Java obfuscation**: If the library is run through an obfuscation tool such
    as **ProGuard**, the class and method names may not be valid C# names.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java混淆**：如果库通过像**ProGuard**这样的混淆工具运行，那么类和方法名称可能不是有效的C#名称。'
- en: '**Covariant return types**: Java has different rules than C# does for return
    types in overridden methods in subclasses. For this reason, you may need to modify
    the return type for the generated C# code to compile.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协变返回类型**：Java对于子类中重写方法的返回类型有不同的规则。因此，你可能需要修改生成的C#代码的返回类型以编译通过。'
- en: '**Visibility**: The rules that Java has for accessibility are different from
    those of C#; the visibility of methods in subclasses can be changed. Sometimes
    you will have to change the visibility in C# to get it to compile.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**：Java的访问性规则与C#的不同；子类中方法的可见性可以改变。有时你需要在C#中改变可见性以使其编译通过。'
- en: '**Naming collisions**: Sometimes, the C# code generator can get things a bit
    wrong and generate two members or classes with the same name.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名冲突**：有时，C#代码生成器可能会犯一些错误，生成两个名称相同的成员或类。'
- en: '**Java generics**: The generic classes in Java can often cause issues in C#.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java泛型**：Java中的泛型类常常会在C#中引起问题。'
- en: Using XPath in Java bindings
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java绑定中使用XPath
- en: 'So, before we get started on solving these issues in our Java binding, let''s
    first clean up the namespaces in the project. Java namespaces are in the form
    `com.mycompany.mylibrary` by default, so let''s change the definition to match
    C# more closely. In the `Transforms` directory of the project, open `Metadata.xml`
    and add the following XML tag inside the root metadata node:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们开始解决Java绑定中的这些问题之前，首先让我们清理项目中的命名空间。默认情况下，Java命名空间的形式为`com.mycompany.mylibrary`，所以让我们将定义更改为更接近C#的形式。在项目的`Transforms`目录中，打开`Metadata.xml`，并在根元数据节点内添加以下XML标签：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `attr` node tells the Xamarin compiler what needs to be replaced, in the
    Java definition, with another value. In this case, we are replacing `managedName`
    of the package with `GoogleAnalytics.Tracking` because it will make much more
    sense in C#. The path value may look a bit strange, which is because it is using
    an XML matching query language named **XPath**. In general, just think of it as
    a pattern matching query for XML. For full documentation on XPath syntax, check
    out some of the many resources online, such as [http://w3schools.com/xpath](http://w3schools.com/xpath).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr`节点告诉Xamarin编译器需要替换Java定义中的什么内容，以另一个值。在这种情况下，我们将包的`managedName`替换为`GoogleAnalytics.Tracking`，因为它在C#中更有意义。路径值可能看起来有点奇怪，这是因为它使用了名为**XPath**的XML匹配查询语言。一般来说，可以把它看作是XML的模式匹配查询。要了解XPath语法的完整文档，请查看网络上的一些资源，例如[http://w3schools.com/xpath](http://w3schools.com/xpath)。'
- en: You may be asking yourself at this point, what is the XPath expression matching
    against? Return to Xamarin Studio and right-click on the solution at the top.
    Click on **Display Options** | **Show All Files**. Open `api.xml` under the `Debug`
    folder in `obj`. This is the Java definition file that describes all types and
    methods within the Java library. You may notice that the XML here directly correlates
    to the XPath expressions we'll be writing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问自己，XPath 表达式与什么匹配？回到 Xamarin Studio，在顶部的解决方案上右键点击。选择 **显示选项** | **显示所有文件**。在
    `obj` 文件夹下的 `Debug` 文件夹中打开 `api.xml`。这是 Java 定义文件，描述了 Java 库中的所有类型和方法。你可能注意到这里的
    XML 直接与我们即将编写的 XPath 表达式相关。
- en: For our next step, let's remove all the packages (or namespaces) we don't plan
    on using in this library. This is generally a good idea for large libraries, since
    you don't want to waste time fixing issues with parts of the library you won't
    even be calling from C#.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一步，让我们移除所有我们不打算在此库中使用的包（或命名空间）。对于大型库来说，这通常是个好主意，因为你不想浪费时间修复你甚至不会从 C# 调用的库部分的问题。
- en: 'Add the following declarations in `Metadata.xml`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Metadata.xml` 中添加以下声明：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that removing these namespaces does not actually remove the compiled Java
    code from your binding. It merely prevents the binding project from generating
    the C# code to use classes in this namespace.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，移除这些命名空间实际上并没有从你的绑定中删除编译后的 Java 代码。它只是阻止绑定项目生成使用此命名空间中的类的 C# 代码。
- en: 'Now when you build the library, we can start resolving issues. The first error
    you will receive will be something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你构建库时，我们可以开始解决问题。你收到的第一个错误将是如下所示的内容：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we locate `TrackerHandler` within the `api.xml` file, we''ll see the following
    class declaration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `api.xml` 文件中找到 `TrackerHandler`，我们会看到以下类声明：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, can you spot the problem? We need to fill out the `visibility` XML attribute,
    which for some reason is blank. Add the following line to `Metadata.xml`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你能发现问题所在吗？我们需要填写 `visibility` XML 属性，不知何故它是空的。在 `Metadata.xml` 中添加以下行：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This XPath expression will locate the `TrackerHandler` class inside the `com.google.analytics.tracking.android`
    package and change `visibility` to `public`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 XPath 表达式将在 `com.google.analytics.tracking.android` 包内定位 `TrackerHandler`
    类，并将 `visibility` 更改为 `public`。
- en: 'If you build the project now, it will complete successfully with a few warnings.
    In Java binding projects, it is a good idea to fix warnings where possible, since
    they generally indicate that a class or method is being omitted from the binding.
    Notice the following warning:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建项目，它将成功完成，但会有一些警告。在 Java 绑定项目中，尽可能修复警告是个好主意，因为它们通常表示一个类或方法被排除在绑定之外。注意以下警告：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To fix this issue, locate the type definition for `CampaignTrackingService`
    in `api.xml`, which would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，在 `api.xml` 中找到 `CampaignTrackingService` 的类型定义，如下所示：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The way to fix the issue here is to change the base class to the `Xamarin.Android`
    definition for `IntentService`. Add the following code to `Metadata.xml`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是将基类更改为 `Xamarin.Android` 对 `IntentService` 的定义。在 `Metadata.xml` 中添加以下代码：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This changes the `extends` attribute to use the `IntentService` found in `Mono.Android.dll`.
    I located the Java name for this class by opening `Mono.Android.dll` in Xamarin
    Studio''s **Assembly Browser** and looking at the `Register` attribute, as shown
    in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `extends` 属性更改为使用 `Mono.Android.dll` 中的 `IntentService`。我通过在 Xamarin Studio
    的 **程序集浏览器** 中打开 `Mono.Android.dll` 并查看 `Register` 属性找到了这个类的 Java 名称，如下面的截图所示：
- en: '![Using XPath in Java bindings](img/image00261.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![在 Java 绑定中使用 XPath](img/image00261.jpeg)'
- en: To inspect `*.dll` files in Xamarin Studio, you merely have to open them. You
    can also double-click on any assembly in the `References` folder in your project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中查看 `*.dll` 文件，你只需打开它们即可。你也可以在你的项目中的 `References` 文件夹里双击任何程序集。
- en: 'If you build the binding project now, we''re left with one last error, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建绑定项目，我们剩下最后一个错误，如下所示：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you navigate to the `api.xml` file, you can see the definition for `OnHandleIntent`
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到 `api.xml` 文件，你可以看到 `OnHandleIntent` 的定义如下：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see here that the Java method for this class is `public`, but the base
    class is `protected`. So, the best way to fix this is to change the C# version
    to `protected` as well. Writing an XPath expression to match this is a bit more
    complicated, but luckily, Xamarin has an easy way to retrieve it. If you double-click
    on the error message in the **Errors** pad of Xamarin Studio, you''ll see the
    following comment in the generated C# code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个类的 Java 方法是`public`，但基类是`protected`。因此，最好的解决办法是将 C# 版本也改为`protected`。编写一个匹配此条件的
    XPath 表达式要复杂一些，但幸运的是，Xamarin 有一个简单的方法来获取它。如果你在 Xamarin Studio 的**错误**面板中双击错误消息，你会在生成的
    C# 代码中看到以下注释：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Copy this value of `path`, and add the following to `Metadata.xml`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 复制`path`的值，并在`Metadata.xml`中添加以下内容：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we can build the project and only have warnings related to `[Obsolete]`
    members being overridden (nothing to worry about). The library is now ready for
    use within your `Xamarin.Android` projects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建项目，并且只有与`[Obsolete]`成员被覆盖相关的警告（无需担心）。这个库现在可以用于你的`Xamarin.Android`项目中了。
- en: 'However, if you start working with the library, notice how the parameter names
    for methods are `p0`, `p1`, `p2`, and so on. Here are a few method definitions
    of the `EasyTracker` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你开始使用这个库，会注意到方法的参数名称是`p0`、`p1`、`p2`等等。以下是`EasyTracker`类的几个方法定义：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can imagine how difficult it could be to consume a Java library without
    knowing the proper parameter names. The reason the parameters are named this way
    is because the Java metadata for its libraries does not include the information
    to set the proper name for each parameter. So, `Xamarin.Android` does the best
    thing it can and autonames each parameter sequentially.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，在不了解正确的参数名称的情况下使用 Java 库会有多困难。之所以这样命名参数，是因为 Java 库的元数据不包括为每个参数设置正确名称的信息。因此，`Xamarin.Android`尽其所能，按顺序自动为每个参数命名。
- en: 'To rename the parameters in this class, we can add the following to `Metadata.xml`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名这个类中的参数，我们可以在`Metadata.xml`中添加以下内容：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Upon rebuilding the binding project, this will effectively rename the parameters
    for these four methods in the `EasyTracker` class. At this time, I would recommend
    going through the classes you plan on using in your application and renaming the
    parameters so that it will make more sense to you. You might need to refer to
    the Google Analytics documentation to get the naming correct. Luckily, there is
    a `javadocs.zip` file included in the SDK that provides HTML references for the
    library.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新构建绑定项目时，这将有效地为`EasyTracker`类中的这四个方法重命名参数。此时，我建议你查看计划在应用程序中使用的类，并重命名这些参数，以便它们对你更有意义。你可能需要参考
    Google Analytics 的文档来确保命名正确。幸运的是，SDK 中包含了一个`javadocs.zip`文件，提供了库的 HTML 参考资料。
- en: For a full reference on implementing Java bindings, make sure to check out Xamarin's
    documentation site at [https://developer.xamarin.com/guides/android/](https://developer.xamarin.com/guides/android/).
    There are certainly more complicated scenarios than what we ran into when creating
    a binding for the Google Analytics library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关实现 Java 绑定的完整参考，请务必查看 Xamarin 的文档网站：[https://developer.xamarin.com/guides/android/](https://developer.xamarin.com/guides/android/)。我们在为
    Google Analytics 库创建绑定时遇到的肯定还有比这更复杂的情况。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added libraries from the Xamarin Component Store to Xamarin
    projects and ported an existing C# library, Ninject, to both `Xamarin.iOS` and
    `Xamarin.Android`. Next, we installed Objective Sharpie and explored its usage
    for generating Objective-C bindings. Finally, we wrote a functional Objective-C
    binding for the Google Analytics SDK for iOS and a Java binding for the Google
    Analytics SDK for Android. We also wrote several XPath expressions to clean up
    the Java binding.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从 Xamarin 组件商店向 Xamarin 项目添加了库，并将现有的 C# 库 Ninject 移植到了`Xamarin.iOS`和`Xamarin.Android`。接下来，我们安装了
    Objective Sharpie 并探索了其生成 Objective-C 绑定的用法。最后，我们为 iOS 的 Google Analytics SDK
    编写了一个功能性的 Objective-C 绑定，以及为 Android 的 Google Analytics SDK 编写了一个 Java 绑定。我们还编写了几个
    XPath 表达式来清理 Java 绑定。
- en: There are several available options for using existing third-party libraries
    from your `Xamarin.iOS` and `Xamarin.Android` applications. We looked at everything
    from using the Xamarin Component Store, porting existing code, and setting up
    Java and Objective-C libraries to be used from C#. In the next chapter, we will
    cover the `Xamarin.Mobile` library as a way to access a user's contacts, camera,
    and GPS location.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从您的 `Xamarin.iOS` 和 `Xamarin.Android` 应用程序中使用现有的第三方库，有几种可用的选项。我们从使用 Xamarin
    组件商店、移植现有代码，以及设置可供 C# 使用的 Java 和 Objective-C 库等方面进行了全面了解。在下一章中，我们将介绍 `Xamarin.Mobile`
    库，作为一种访问用户联系人、相机和 GPS 位置的方法。
