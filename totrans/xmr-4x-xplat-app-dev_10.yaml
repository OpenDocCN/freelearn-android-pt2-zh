- en: Chapter 10. Third-Party Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin supports a subset of the .NET framework, but for the most part includes
    all the standard APIs you would expect in the .NET base class libraries. Because
    of this, a large portion of C# open-source libraries can be used directly in Xamarin
    projects. Additionally, if an open source project doesn't have a Xamarin or portable
    class library version, porting the code to be used in a Xamarin project can often
    be very straightforward. Xamarin also supports calling native Objective-C and
    Java libraries, so we will explore these as additional means of reusing existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Xamarin Component Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting existing C# libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective-C bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Xamarin Component Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary and obvious way to add third-party components to your project is
    via the Xamarin Component Store. The Component Store is fairly similar to the
    *NuGet package manager* that all C# developers are familiar with, except that
    the Component Store also contains premium components that are not free. All Xamarin
    components are also required to include full sample projects and a Getting Started
    guide, while NuGet does not inherently provide documentation in its packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `Xamarin.iOS` and `Xamarin.Android` projects come with a `Components` folder.
    To get started, simply right-click on the folder, and select **Get More Components**
    to launch the store dialog, shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Xamarin Component Store](img/image00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At the time of writing this book, there are well over 200 components available
    to enhance your iOS and Android applications. This is a great place to find the
    most common components to use within your Xamarin applications. Each component
    is complete with artwork, possibly a demonstration video, reviews, and other information
    you would need before purchasing a premium component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most well-known and useful components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Json.NET**: This is the de facto standard for parsing and serializing JSON
    with C#'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RestSharp**: This is a commonly used simple REST client for .NET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLite.NET**: This is a simple **Object Relational Mapping** (**ORM**) for
    working with local SQLite databases in your mobile applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook SDK**: This is the standard SDK provided by Facebook for integrating
    its services into your apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin.Mobile**: This is a cross-platform library for accessing your device''s
    contacts, GPS, photo library, and camera with a common API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZXing.Net.Mobile**: A .NET version of the popular barcode-scanning library,
    **ZXing** (**Zebra Crossing**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that some of these libraries are native Java or Objective-C libraries,
    while some are plain C#. Xamarin is built from the ground up to support calling
    native libraries, so the Component Store offers many of the common libraries that
    Objective-C or Java developers would leverage when developing mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also submit your own components to the Component Store. If you have
    a useful open source project or just want to earn a little extra cash, creating
    a component is simple. We won''t be covering it in this book, but navigate to
    [http://components.xamarin.com/submit](http://components.xamarin.com/submit) for
    full documentation on the subject, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Xamarin Component Store](img/image00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Porting existing C# libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Xamarin is becoming a popular platform, many open-source .NET libraries
    are simply not up to speed with supporting `Xamarin.iOS` and `Xamarin.Android`.
    But in these cases, you are definitely not out of luck. Often, if there is a Silverlight
    or Windows Phone version of the library, you can simply create an iOS or Android
    class library and add the files with no code changes.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this process, let's port an open source project that doesn't have
    Xamarin or portable class library support. I have selected a dependency injection
    library called **Ninject**, due to its usefulness and relationship to ninjas.
    Find out more about the library at [http://www.ninject.org/](http://www.ninject.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin setting up the library to work with Xamarin projects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, download the source code for Ninject from [https://github.com/ninject/ninject](https://github.com/ninject/ninject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new solution with an **iOS Class Library** project named `Ninject.iOS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link in all the files from the `Ninject` main project. Make sure you use the
    **Add Existing Folder** dialog to speed up this process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you aren't familiar with GitHub, I recommend downloading GitHub Desktop,
    a nice client app for either Windows or OS X found at [https://desktop.github.com/](https://desktop.github.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try to build the `Ninject.iOS` project; you will get several compiler errors
    in a file named `DynamicMethodFactory.cs`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Porting existing C# libraries](img/image00260.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `DynamicMethodInjectorFactory.cs` and notice the following code at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to use `System.Reflection.Emit` on iOS due to Apple's platform
    restrictions. Luckily, the library writers have created a preprocessor directive
    called `NO_LCG` (which stands for **Lightweight Code Generation**) to allow the
    library to run on platforms that do not support `System.Reflection.Emit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix our iOS project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project options and navigate to the **Build** | **Compiler** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `NO_LCG` to the **Define Symbols** field for both **Debug** and **Release**
    in the **Configuration** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to save your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you compile the project now, it will be completed successfully and a `Ninject.iOS.dll`
    file will be created, which you can reference from any `Xamarin.iOS` project.
    You can also reference the `Ninject.iOS` project directly instead of using the
    `*.dll` file.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may wish to repeat the process to create a `Xamarin.Android`
    class library project. Luckily, `Xamarin.Android` supports `System.Reflection.Emit`,
    so you can skip adding the additional preprocessor directive if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin has developed a sophisticated system for calling native Objective-C
    libraries from C# in iOS projects. The core of `Xamarin.iOS` uses this same technology
    to call native Apple APIs in **UIKit**, **CoreGraphics**, and other iOS frameworks.
    Developers can create iOS binding projects to expose Objective-C classes and methods
    to C# using simple interfaces and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: To aid in creating Objective-C bindings, Xamarin has created a small tool named
    **Objective Sharpie** that can process Objective-C header files for you and export
    the valid C# definitions to add to a binding project. This tool is a great starting
    point for most bindings and will get about 75% of your binding project working
    in most cases. You will want to hand-edit and fine-tune things to be more C#-friendly
    most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that iOS binding projects can be created in Visual Studio; however, Objective
    Sharpie is a command-line tool for OS X. It leverages tooling included with Xcode,
    so iOS binding development is best accomplished on Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will write a binding for the Google Analytics library for
    iOS. It is a simple and useful library that can track user activities in your
    iOS or Android applications. At the time of writing, the version of the Google
    Analytics SDK is 3.17, so some of these instructions may change as new versions
    are released.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install Objective Sharpie from [https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/](https://developer.xamarin.com/guides/cross-platform/macios/binding/objective-sharpie/)
    and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest Google Analytics SDK for iOS available at [https://tinyurl.com/GoogleAnalyticsForiOS](https://tinyurl.com/GoogleAnalyticsForiOS).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **iOS** | **Bindings Library** project named `GoogleAnalytics.iOS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the contents of the zip file from step 1 and move the `GoogleAnalytics`
    folder into the same directory as the bindings project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Terminal** and navigate to the same directory as the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run **Objective Sharpie** with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Objective Sharpie will output two files: `ApiDefinitions.cs` and `Structs.cs`.
    The second two commands will copy the files over the top of the default files
    from the **Bindings Library** project template created.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that at the time of writing, the iOS 10 SDK is used in the preceding command.
    To discover what you need to put for the `--sdk` option, run `sharpie xcode --sdks`
    and you will see the value printed in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you return to your binding project, you'll notice that Objective Sharpie
    has generated an interface definition for every class discovered in the header
    files of the library. It has also generated many `enum` values that the library
    uses and changed casing and naming conventions to follow C# more closely where
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you read through the binding, you''ll notice several C# attributes that
    define different aspects about the Objective-C library, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseType`: This declares an interface as an Objective-C class. The base class
    (also called superclass) is passed in to the attribute. If it has no base class,
    `NSObject` should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Export`: This declares a method or property on an Objective-C class. A string
    that maps the Objective-C name to the C# name is passed in. Objective-C method
    names are generally in the following form: `myMethod:someParam:someOtherParam`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Static`: This marks a method or property as `static` in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bind`: This is used on properties to map a getter or setter to a different
    Objective-C method. Objective-C properties can rename a getter or setter for a
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NullAllowed`: This allows `null` to be passed to a method or property. By
    default, an exception is thrown if this occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Field`: This declares an Objective-C field that is exposed as a public variable
    in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model`: This identifies a class to `Xamarin.iOS` to have methods that can
    be optionally overridden. This is generally used on Objective-C delegates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Internal`: This flags the generated member with the C# internal keyword. It
    can be used to hide certain members that you don''t want to expose to the outside
    world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Abstract`: This identifies an Objective-C method as required, which goes hand
    in hand with `Model`. In C#, it will generate an abstract method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only other rule to know is how to define constructors. Xamarin had to invent
    a convention for this, since C# interfaces do not support constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a constructor besides the default one, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This would define a constructor on the class that takes in `RectangleF` as a
    parameter. The method name, `Constructor`, and the return type, `IntPtr`, signal
    the Xamarin compiler to generate a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s return to our binding project to finish setting everything up.
    If you compile the project at this point, you''ll get a few compiler errors. Let''s
    fix them one by one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `libGoogleAnalyticsServices.a` and `libAdIdAccess.a` from the Google Analytics
    download as **Native References**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the base type of the enums `GAILogLevel` and `GAIDispatchResult` found
    in `Structs.cs` to `ulong`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove duplicate declarations of `[Static]` from the `Constants` class found
    in `ApiDefinitions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all the `Verify` attributes. These are spots where Objective Sharpie
    was unsure of the operation it performed. In our example, all of them are fine,
    so it is safe to remove them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, if you tried to use the library in an iOS project you would
    get an error such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We need to define the other frameworks and libraries that the Objective-C library
    uses. This is very similar to how references work in C#. If we review the Google
    Analytics documentation, it says that you must add `CoreData`, `SystemConfiguration`,
    and `libsqlite3.dylib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the Native reference to `libGoogleAnalyticsServices`, choose
    **Properties**, and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `Frameworks` to `CoreData SystemConfiguration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Linker Flags` to `-lsqlite3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Native Objective-C libraries reference other libraries with one of the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frameworks**: Add them to the `Frameworks` value on the `LinkWith` attribute,
    delimited by spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weak Frameworks**: Add them to the `WeakFrameworks` property on the `LinkWith`
    attribute in the same manner. Weak frameworks are libraries that can be ignored
    if they are not found. In this case, `AdSupport` was added in iOS 6; however,
    this library will still work on older versions of iOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Libraries**: Libraries such as `libz.dylib` can be declared in `LinkerFlags`.
    Generally, you drop the `.dylib` extension and replace `lib` with `-l`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After these changes are implemented, you will be able to successfully use the
    library from iOS projects. For complete documentation on Objective-C bindings,
    visit the Xamarin documentation site at [https://developer.xamarin.com/guides/ios/](https://developer.xamarin.com/guides/ios/).
  prefs: []
  type: TYPE_NORMAL
- en: Java bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same manner as iOS, Xamarin has provided full support for calling into
    Java libraries from C# with `Xamarin.Android`. The native Android SDKs function
    in this way and developers can leverage the `Android Java Bindings` project to
    take advantage of other native Java libraries in C#. The main difference here
    is that not a lot has to be done by hand in comparison to Objective-C bindings.
    The Java syntax is very similar to that of C#, so many mappings are exactly one-to-one.
    In addition, Java has metadata information included with its libraries, which
    Xamarin uses to automatically generate the C# code required for calling into Java.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's make a binding for the Android version of the Google Analytics
    SDK. Before we begin, download the SDK at [https://developers.google.com/analytics/devguides/collection/android/v3/](https://developers.google.com/analytics/devguides/collection/android/v3/).
    At the time of writing, Google Analytics is being migrated to Google Play Services,
    but we will use this Java library as an exercise for creating Java bindings to
    be consumed by C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin creating a Java binding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new `Android | Library | Bindings Library` project in Xamarin Studio.
    You may use the same solution as we did for iOS if you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `GoogleAnalytics.Droid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `libGoogleAnalyticsServices.jar` from the Android SDK to the project under
    the `Jars` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project. You will get a few errors, which we'll address in a moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of the time you spend working on Java bindings will be to fix small issues
    that prevent the generated C# code from compiling. But don't fret; a lot of libraries
    will work on the first try without having to make any changes at all. Generally,
    the larger the Java library is, the more work you have to do to get it working
    with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you get no errors upon first compile, but many warnings saying
    something to the effect of `unsupported major.minor version 52.0`, then you need
    to install a newer version of the Java JDK. Download JDK 1.8 from [http://tinyurl.com/XamarinJDK8](http://tinyurl.com/XamarinJDK8),
    and point Xamarin Studio or Visual Studio to the newer version of the JDK in settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the types of issue you may run into:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java obfuscation**: If the library is run through an obfuscation tool such
    as **ProGuard**, the class and method names may not be valid C# names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Covariant return types**: Java has different rules than C# does for return
    types in overridden methods in subclasses. For this reason, you may need to modify
    the return type for the generated C# code to compile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility**: The rules that Java has for accessibility are different from
    those of C#; the visibility of methods in subclasses can be changed. Sometimes
    you will have to change the visibility in C# to get it to compile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming collisions**: Sometimes, the C# code generator can get things a bit
    wrong and generate two members or classes with the same name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java generics**: The generic classes in Java can often cause issues in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XPath in Java bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, before we get started on solving these issues in our Java binding, let''s
    first clean up the namespaces in the project. Java namespaces are in the form
    `com.mycompany.mylibrary` by default, so let''s change the definition to match
    C# more closely. In the `Transforms` directory of the project, open `Metadata.xml`
    and add the following XML tag inside the root metadata node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `attr` node tells the Xamarin compiler what needs to be replaced, in the
    Java definition, with another value. In this case, we are replacing `managedName`
    of the package with `GoogleAnalytics.Tracking` because it will make much more
    sense in C#. The path value may look a bit strange, which is because it is using
    an XML matching query language named **XPath**. In general, just think of it as
    a pattern matching query for XML. For full documentation on XPath syntax, check
    out some of the many resources online, such as [http://w3schools.com/xpath](http://w3schools.com/xpath).
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking yourself at this point, what is the XPath expression matching
    against? Return to Xamarin Studio and right-click on the solution at the top.
    Click on **Display Options** | **Show All Files**. Open `api.xml` under the `Debug`
    folder in `obj`. This is the Java definition file that describes all types and
    methods within the Java library. You may notice that the XML here directly correlates
    to the XPath expressions we'll be writing.
  prefs: []
  type: TYPE_NORMAL
- en: For our next step, let's remove all the packages (or namespaces) we don't plan
    on using in this library. This is generally a good idea for large libraries, since
    you don't want to waste time fixing issues with parts of the library you won't
    even be calling from C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following declarations in `Metadata.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that removing these namespaces does not actually remove the compiled Java
    code from your binding. It merely prevents the binding project from generating
    the C# code to use classes in this namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you build the library, we can start resolving issues. The first error
    you will receive will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we locate `TrackerHandler` within the `api.xml` file, we''ll see the following
    class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, can you spot the problem? We need to fill out the `visibility` XML attribute,
    which for some reason is blank. Add the following line to `Metadata.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This XPath expression will locate the `TrackerHandler` class inside the `com.google.analytics.tracking.android`
    package and change `visibility` to `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build the project now, it will complete successfully with a few warnings.
    In Java binding projects, it is a good idea to fix warnings where possible, since
    they generally indicate that a class or method is being omitted from the binding.
    Notice the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this issue, locate the type definition for `CampaignTrackingService`
    in `api.xml`, which would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The way to fix the issue here is to change the base class to the `Xamarin.Android`
    definition for `IntentService`. Add the following code to `Metadata.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the `extends` attribute to use the `IntentService` found in `Mono.Android.dll`.
    I located the Java name for this class by opening `Mono.Android.dll` in Xamarin
    Studio''s **Assembly Browser** and looking at the `Register` attribute, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using XPath in Java bindings](img/image00261.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To inspect `*.dll` files in Xamarin Studio, you merely have to open them. You
    can also double-click on any assembly in the `References` folder in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build the binding project now, we''re left with one last error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to the `api.xml` file, you can see the definition for `OnHandleIntent`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see here that the Java method for this class is `public`, but the base
    class is `protected`. So, the best way to fix this is to change the C# version
    to `protected` as well. Writing an XPath expression to match this is a bit more
    complicated, but luckily, Xamarin has an easy way to retrieve it. If you double-click
    on the error message in the **Errors** pad of Xamarin Studio, you''ll see the
    following comment in the generated C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy this value of `path`, and add the following to `Metadata.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can build the project and only have warnings related to `[Obsolete]`
    members being overridden (nothing to worry about). The library is now ready for
    use within your `Xamarin.Android` projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you start working with the library, notice how the parameter names
    for methods are `p0`, `p1`, `p2`, and so on. Here are a few method definitions
    of the `EasyTracker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can imagine how difficult it could be to consume a Java library without
    knowing the proper parameter names. The reason the parameters are named this way
    is because the Java metadata for its libraries does not include the information
    to set the proper name for each parameter. So, `Xamarin.Android` does the best
    thing it can and autonames each parameter sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rename the parameters in this class, we can add the following to `Metadata.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Upon rebuilding the binding project, this will effectively rename the parameters
    for these four methods in the `EasyTracker` class. At this time, I would recommend
    going through the classes you plan on using in your application and renaming the
    parameters so that it will make more sense to you. You might need to refer to
    the Google Analytics documentation to get the naming correct. Luckily, there is
    a `javadocs.zip` file included in the SDK that provides HTML references for the
    library.
  prefs: []
  type: TYPE_NORMAL
- en: For a full reference on implementing Java bindings, make sure to check out Xamarin's
    documentation site at [https://developer.xamarin.com/guides/android/](https://developer.xamarin.com/guides/android/).
    There are certainly more complicated scenarios than what we ran into when creating
    a binding for the Google Analytics library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added libraries from the Xamarin Component Store to Xamarin
    projects and ported an existing C# library, Ninject, to both `Xamarin.iOS` and
    `Xamarin.Android`. Next, we installed Objective Sharpie and explored its usage
    for generating Objective-C bindings. Finally, we wrote a functional Objective-C
    binding for the Google Analytics SDK for iOS and a Java binding for the Google
    Analytics SDK for Android. We also wrote several XPath expressions to clean up
    the Java binding.
  prefs: []
  type: TYPE_NORMAL
- en: There are several available options for using existing third-party libraries
    from your `Xamarin.iOS` and `Xamarin.Android` applications. We looked at everything
    from using the Xamarin Component Store, porting existing code, and setting up
    Java and Objective-C libraries to be used from C#. In the next chapter, we will
    cover the `Xamarin.Mobile` library as a way to access a user's contacts, camera,
    and GPS location.
  prefs: []
  type: TYPE_NORMAL
