- en: Chapter 3. Testing Your Physical Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important steps during software development is **testing**.
    When we are testing software components, we are using a testing framework to write
    unit tests, and maybe integration tests, that are useful to reproduce bugs and
    to check the expected behavior of our application. In physical applications, this
    process isn't so easy because we have to test how our sketch interacts with hardware
    circuits.
  prefs: []
  type: TYPE_NORMAL
- en: We will add to the LedLamp application all the required features to implement
    an easy way to find anomalies in the circuit, so that we can avoid complex debug
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Further details about electronic components and circuits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding components to a circuit so they can be tested by a sketch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the first test for circuit debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the circuit test from your prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a testable circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During Android application writing, we may use the internal testing framework
    to write instrumentation tests. With them, we can check the behavior of an application
    at all levels of the Android stack, including user interface stress tests. However,
    in our UDOO projects, we make use of Android to interact with the onboard microcontroller
    to control and collect data from physical devices. When we have a good features
    coverage through tests in our Android application, and when it matches all our
    requirements, it's more likely that our first problems will be related to hardware
    faults and anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we will not cover the Android unit testing framework because it's
    not required to make your first steps in hardware prototyping. However, bear in
    mind that you should learn how to write Android tests because it's a must to improve
    the quality of your software. You can find more information in the official documentation
    at [http://developer.android.com/training/activity-testing/index.html](http://developer.android.com/training/activity-testing/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we built our first prototype using many electronic
    components, such as an LED and a resistor, and we wrote an Android application
    to act as a devices controller. This is a good starting point, because we already
    have a working device in which we can add another feature. To keep the circuit
    simple, we will add an independent LED from the first one, to make our appliance
    capable of turning on and off two different devices. We need to make some changes
    to the LedLamp circuit to connect the second LED to the UDOO board. Take a look
    at the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a testable circuit](img/1942OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To achieve the preceding schema, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the connection from the positive line of the power bus, because we need
    to control different components from different pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the ground connected to the negative line of the power bus because we are
    connecting all grounds together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put two *220 Ohm resistors* to connect the negative legs to the negativepower
    bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect positive legs to UDOO pinouts 2 and 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the previous chapter, we connected the resistor to the positive leg, while
    now we are connecting the negative one. Both configurations are correct because
    when the LED and the resistor are connected in series, the current will flow through
    them with the same intensity. We can find that circuits are similar to highways,
    while cars are like electric charges. If cars encounter one or many roadblocks,
    they start to slow down at every point of the highway, and it doesn't matter if
    they are near or far from the roadblock. So, even if the resistor is at the end
    of the circuit, the right amount of current will flow through the LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the circuit includes a new LED, we have to change our sketch so it
    can fit our needs with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the sketch, add the following object-like macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the new LED in the `setup()` function, as you can see in the highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `executor()`function so that the new LED behaves
    like the first one that we have already programmed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the accessory descriptor at the top of the file to update the sketch
    version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Changing the version number is always a good practice that you should be aware
    of. In our case, this is also a requirement because we have to inform Android
    that the hardware behavior has changed. As you saw in [Chapter 2](ch02.html "Chapter 2. Know
    Your Tools"), *Know your Tools*, when versions defined in Android and Arduino
    mismatch, the Android application will not communicate with the microcontroller,
    and this prevents unexpected behaviors, especially when the hardware is changed.
    Indeed, if we deploy the new sketch again, we can see that Android will not find
    any available application to manage the accessory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step where the prototype will work again, is to update the Android
    application starting from its user interface and logic, so that it becomes capable
    to manage the new device. To achieve this goal, we should take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new switch button into `res/layout/activity_light_switch.xml` file, below
    the `firstLed` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the `LightSwitch` activity at the top of the class, the following declaration
    to store the state of the second LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code under the `switchLight()` method to pilot the second
    LED according to the sketch switch case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `usb_accessory_filter.xml` descriptor file under `res/xml/` with
    the new hardware version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are matching the version of the sketch so Android knows that this application
    can manage the connected accessory again. After deploying the new application,
    we can use the prototype to turn on and off the two connected LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a diagnostic mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a working prototype, it's time to add a functionality that we can use to
    test our circuit. Even if we are tempted to put our hands on code, we need first
    to simulate a physical damage that causes a fault in the prototype. Because we
    don't want to really damage one of our LEDs, we can always alter the circuit components
    to reproduce an anomaly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we can simulate that the resistor connected to pin 3 has a broken leg.
    If this occurs, the circuit is interrupted and this prevents the current from
    flowing through the LED. To reproduce this problem in our breadboard, we can simply
    remove the first resistor, as we can see in the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a diagnostic mode](img/1942OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have simulated our first hardware fault. If we open the Android application
    and use the on/off switches, we can see that the second LED works as expected
    while the first one stops working. However, none of the software components notice
    anything because they are agnostic to what happens under the hood. If such problems
    occurs, we are lost because we start software and hardware debugging without knowing
    in which part we should put our attention to find the fault.
  prefs: []
  type: TYPE_NORMAL
- en: When the software doesn't work, we usually use a debugger. Unfortunately, when
    we deal with electric circuits, we don't have so many tools and we may need to
    implement something on our own. A good starting point is to add a functionality
    to the prototype so it can debug itself through a **diagnostic** mode. This mode
    should *simulate and mimic the real behaviors of our circuit*, but in a controlled
    way. Diagnostic mode is really helpful to identify the cause of anomalies in our
    prototype when the problem is not related to a software bug.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The diagnostic mode is the first step we should follow to find anomalies. However,
    when we find a hardware fault, we should start using other tools such as a *multimeter*,
    which has the capability to measure voltage, current, and resistance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start to implement this mode in our sketch, we need to connect a
    *push button* that we will use to enable the diagnostic mode. We need to add this
    component to our breadboard, as you can see in the left part of the following
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a diagnostic mode](img/1942OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The procedure to add components to the breadboard, as shown in the schema,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the push button to the middle of our breadboard so that the legs in the
    same vertical line aren't connected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left leg of the button to pin +5V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the right leg of the button to pin 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of a *10 KOhm* resistor to the right leg of the button and
    the other side to the negative line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through these connections, we read a digital signal from pin 4 when we press
    the push button because the *current chooses the path with lesser resistance*,
    like water does. In our case, the mechanical switch will create a connection between
    the +5V and the 4 pins, and because the resistance of this path is greatly inferior
    to the *10 KOhm* present in the ground path, UDOO will read this voltage difference
    and convert it into a digital signal. When the switch is open, the only available
    path is pin 4 and the ground so UDOO reads no voltage differences. This allows
    us to know whether the switch is pressed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a physical hardware switch, we need to activate the diagnostic
    mode when users press the push button. To detect the button press, we should change
    the sketch according to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted declarations, just after the ADK initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need the button state for each reading phase so that we can save the state
    during the current and the previous reading. The `lastPress` variable will contain
    the timestamp when the button was pressed last time. We set the button status
    to `LOW` because we state that no current flows through the button and this means
    that it's not pressed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the top of the sketch, define the following object-like macros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set the BUTTON pin 4 and a DEBOUNCE value that refers to the number of milliseconds
    that should elapse before our code starts to evaluate the button press again.
    The use of this threshold is required because it prevents the reading of false
    positive. If we omit this part, when the button is pressed, the sketch will detect
    thousands of readings because the UDOO reading phase is faster than our reaction
    to release the push button. This value is called **debounce threshold**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure the button pin mode in the `setup()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move the content of the `loop()` function into a new one called the `readCommand()`
    function so that it matches the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With an empty `loop()` function, we should add in it the reading phase with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are storing the value of the button using the built-in `digitalRead()` function,
    which abstracts the complexity to read the voltage difference from the chosen
    pin. Then, we are checking if the current state is different from the previous,
    so we are sure that the button is pressed exactly in this moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, we also need to check whether the time since we press the push button
    exceeds the debounce threshold. We use the built-in `millis()` function, which
    returns the number of milliseconds since the UDOO board has started the current
    program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the press button event is caught, we set the `lastPress` value and show a
    visual feedback to notify users that the diagnostic mode is about to start. In
    any case, we are saving the previous button state and continuing with the standard
    execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes the diagnostic mode requires activation and deactivation phases. In
    our case, we are keeping the process simple so the diagnostic mode runs only once
    after the button is pressed. In other projects, we may need a more complex activation
    mechanism that we can isolate in a standalone function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a last step, implement the `startDiagnostic()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The diagnostic function should mimic all, or almost all, possible behaviors
    of our circuit. In this case, we turn on and off the first and the second LED
    and, as the last test, we power them on together. In a diagnostic mode, it's important
    to use internal functions to reproduce the circuit actions. This helps us to test
    the `executor()` function's inputs so that we are sure that we have mapped all
    expected inputs sent by the Android application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a diagnostic function, we have to deploy our LedLamp sketch
    once again and push the button to start the diagnosis. As expected, only one LED
    should turn on because of the virtually broken resistor. Now we can connect the
    resistor again and start the diagnostic mode to test if the LED connection has
    been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have delved into hardware testing to enhance the quality
    of our projects. We found how valuable this process is because, with this approach,
    we can isolate hardware faults from software bugs.
  prefs: []
  type: TYPE_NORMAL
- en: We added another LED to our previous prototype so that we can control multiple
    devices from the Android application. Then, we simulated a hardware fault in one
    of the electric components, removing one resistor from the circuit to produce
    a controlled anomaly. This led us to write our own diagnostic mode to find these
    kinds of faults quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The first step was to add a push button to our prototype that we can use to
    start the diagnostic mode and then we used this functionality to mimic all the
    possible circuit behaviors to find the broken resistor easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we start a new prototype from scratch, which is capable
    of collecting data from the environment, through a new set of electronic components.
    We will also write an Android application capable of reading these values sent
    from the sketch and to visualize the processed data.
  prefs: []
  type: TYPE_NORMAL
