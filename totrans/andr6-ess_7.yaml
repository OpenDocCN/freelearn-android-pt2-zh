- en: Chapter 7. Chrome Custom Tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wanted to add a **WebView** to your application? Maybe you've
    wanted to add browsing for a few web pages and show some relevant content from
    within your application? I know I had to. On almost every occasion, I was reluctant
    to use the WebView feature as this was one of the ugliest parts of the app.
  prefs: []
  type: TYPE_NORMAL
- en: You can clearly see that the WebView feature is a web portion and the UI was
    added quite a few Android versions back, which caused my OCD UI/UX sense go kaboom.
    One of the newest additions released by Google was **Chrome custom tabs**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore Chrome custom tabs and try to explain and
    demonstrate the benefits of using it instead of the plain old WebView:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Chrome custom tab?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use Chrome custom tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation guide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a Chrome custom tab?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, most of us know tabs from every day Internet browsing. It doesn't really
    matter which browser you use; all browsers support tabs and multiple tabs' browsing.
    This allows us to have more than one website open at the same time and navigate
    between the opened instances. In Android, things are much the same, but when using
    WebView, you don't have tabs.
  prefs: []
  type: TYPE_NORMAL
- en: What is WebView?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebView is the part in the Android OS that's responsible for rendering web pages
    in most Android apps. If you see web content in an Android app, chances are you're
    looking at WebView. The major exceptions to this rule are some of the Android
    browsers, such as Chrome, Firefox, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In Android 4.3 and lower, WebView uses code based on Apple's **Webkit**. In
    Android 4.4 and higher, WebView is based on the **Chromium** project, which is
    the open source base of Google Chrome. In Android 5.0, WebView was decoupled into
    a separate app that allowed timely updates through Google Play without requiring
    firmware updates to be issued, and the same technique was used with Google Play
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk again about a simple scenario: we want to display web content
    (URL-related) in our application. We have two options: either launch a browser
    or build our own in-app browser using WebView. Both options have trade-offs or
    disadvantages if we write them down. A browser is an external application and
    you can''t really change its UI; while using it, you push the users to other apps
    and you may lose them in *the wild*. On the other hand, using WebView will keep
    the users tightly inside. However, actually dealing with all possible actions
    in WebView is quite an overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: Google heard our rant and came to the rescue with Chrome custom tabs. Now we
    have better control over the web content in our application, and we can stitch
    web content into our app in a cleaner, prettier manner.
  prefs: []
  type: TYPE_NORMAL
- en: Customization options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chrome custom tabs allow several modifications and tweaks:'
  prefs: []
  type: TYPE_NORMAL
- en: The toolbar color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter and exit animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom actions for the toolbar and overflow menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prestarted and prefetched content for faster loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use Chrome custom tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since WebView came out, applications have been using it in multiple ways,
    embedding content—local static content inside the APK and dynamic content as loading
    web pages that were not designed for mobile devices at the beginning. Later on
    we saw the rise of the mobile web era complete with hybrid applications).
  prefs: []
  type: TYPE_NORMAL
- en: Chrome custom tabs are a bit more than just loading local content or mobile-compatible
    web content. They should be used when you load web data and want to allow simple
    implementation and easier code maintenance and, furthermore, make the web content
    part of your application—as if it's always there within your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the reasons why you should use custom tabs are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy implementation: you use the support library when required or just add
    extras to your `View` intent. It''s that simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In app UI modifications, you can do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the toolbar color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add/change the action button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add custom menu items to the overflow menu
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set and create custom in/out animations when entering the tab or exiting to
    the previous location
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Easier navigation and navigation logic: you can get a callback notifying you
    about an external navigation, if required. You know when the user navigates to
    web content and where they should return when done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chrome custom tabs allow added performance optimizations that you can use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can keep the engine running, so to speak, and actually give the custom tab
    a head start to start itself and do some warm up prior to using it. This is done
    without interfering or taking away precious application resources.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can provide a URL to load in advance in the background while waiting for
    other user interactions. This speeds up the user-visible page loading time and
    gives the user a sense of blazing fast application where all the content is just
    a click away.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While using the custom tab, the application won't be evicted as the application
    level will still be in the foreground even though the tab is on top of it. So,
    we remain at the top level for the entire usage time (unless a phone call or some
    other user interaction leads to a change).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the same Chrome container means that users are already signed in to sites
    they connected to in the past; specific permissions that were granted previously
    apply here as well; even fill data, autocomplete, and sync work here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome custom tabs allow us give the users the latest browser implementation
    on pre-Lollipop devices where WebView is not the latest version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, we have a couple of features integrated into Chrome custom
    tabs. The first customizes the UI and interaction with the custom tabs. The second
    allows pages to be loaded faster and keeps the application alive.
  prefs: []
  type: TYPE_NORMAL
- en: Can we use Chrome custom tabs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start using custom tabs, we want to make sure they''re supported.
    Chrome custom tabs expose a service, so the best check for support is to try and
    bind to the service. Success means that custom tabs are supported and can be used.
    You can check out this gist, which shows a helper how to to check it, or check
    the project source code later on at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://gist.github.com/MaTriXy/5775cb0ff98216b2a99d](https://gist.github.com/MaTriXy/5775cb0ff98216b2a99d)'
  prefs: []
  type: TYPE_NORMAL
- en: After checking and learning that support exists, we will start with the UI and
    interaction part.
  prefs: []
  type: TYPE_NORMAL
- en: Custom UI and tab interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will use the well-known `ACTION_VIEW` intent action, and by appending
    extras to the intent sent to Chrome, we will trigger changes in the UI. Remember
    that the `ACTION_VIEW` intent is compatible with all browsers, including Chrome.
    There are some phones without Chrome out there, or there are instances where the
    device's default browser isn't Chrome. In these cases, the user will navigate
    to the specific browser application.
  prefs: []
  type: TYPE_NORMAL
- en: Intent is a convenient way to pass that extra data we want Chrome to get.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t use any of these flags when calling to the Chrome custom tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLAG_ACTIVITY_NEW_TASK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLAG_ACTIVITY_NEW_DOCUMENT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before using the API, we need to add it to our `gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to use the custom tab support library in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an extra from the custom tabs support library; it's used
    to match the session. It must be included in the intent when opening a custom
    tab. It can be null if there is no need to match any service-side sessions with
    the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have a sample project to show the options for the UI called **ChubbyTabby**
    at [https://github.com/MaTriXy/ChubbyTabby](https://github.com/MaTriXy/ChubbyTabby).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go over the important parts here as well. Our main interaction comes
    from a special builder from the support library called `CustomTabsIntent.Builder`;
    this class will help us build the intent we need for the custom tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to notice here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every menu item uses a pending intent; if you don''t know what a pending intent
    is, head to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/android/app/PendingIntent.html](http://developer.android.com/reference/android/app/PendingIntent.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we set custom icons, such as *close* buttons or an *action* button, for
    that matter, we use bitmaps and we must decode the bitmap prior to passing it
    to the builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting animations is easy and you can use animations' XML files that you created
    previously; just make sure that you test the result before releasing the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot is an example of a Chrome custom tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UI and tab interaction](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The custom action button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As developers, we have full control over the action buttons presented in our
    custom tab. For most use cases, we can think of a share action or maybe a more
    common option that your users will perform. The action button is basically a bundle
    with an icon of the action button and a pending intent that will be called by
    Chrome when your user hits the action button. The icon should be 24 dp in height
    and 24-48 dp in width according to specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a custom menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Chrome custom tabs usually have a three-icon row with **Forward**,
    **Page Info**, and **Refresh** on top at all times and **Find in page** and **Open
    in Browser (Open in Chrome** can appear as well) at the footer of the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, developers, have the ability to add and customize up to three menu items
    that will appear between the icon row and foot items as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a custom menu](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The menu we see is actually represented by an array of bundles, each with menu
    text and a pending intent that Chrome will call on our behalf when the user taps
    the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Configuring custom enter and exit animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nothing is complete without a few animations to tag along. This is no different,
    as we have two transitions to make: one for the custom tab to enter and another
    for its exit; we have the option to set a specific animation for each start and
    exit animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Chrome warm-up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, after we finish setting up the intent with the intent builder, we
    should call `CustomTabsIntent.launchUrl (Activity context, Uri url)`, which is
    a nonstatic method that will trigger a new custom tab activity to load the URL
    and show it in the custom tab. This can take up quite some time and impact the
    impression of smoothness the app provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'We all know that users demand a near-instantaneous experience, so Chrome has
    a service that we can connect to and ask it to warm up the browser and its native
    components. Calling this will ask Chrome to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The DNS preresolution of the URL's main domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DNS preresolution of the most likely subresources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preconnection to the destination, including HTTPS/TLS negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process to warm up Chrome is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a navigation callback to get notified upon finishing the page load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the service, call `warmup` to start Chrome behind the scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `newSession`; this session is used for all requests to the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell Chrome which pages the user is likely to load with `mayLaunchUrl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the intent with the session ID generated in step 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting to the Chrome service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connecting to the Chrome service involves dealing with **Android Interface Definition
    Language** (**AIDL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t know about AIDL, read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/guide/components/aidl.html](http://developer.android.com/guide/components/aidl.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface is created with AIDL, and it automatically creates a proxy service
    class for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we check for the Chrome package name; in our sample project, we have a
    special method to check whether Chrome is present in all variations. After we
    set the package, we bind to the service and get a `CustomTabsClient` object that
    we can use until we''re disconnected from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we bind to the service, we can call the proper methods we need.
  prefs: []
  type: TYPE_NORMAL
- en: Warming up the browser process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flags are currently not being used, so we pass `0` for now.
  prefs: []
  type: TYPE_NORMAL
- en: The warm-up procedure loads native libraries and the browser process required
    to support custom tab browsing later on. This is asynchronous, and the return
    value indicates whether the request has been accepted or not. It returns `true`
    to indicate success.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new tab session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The new tab session is used as the grouping object tying the `mayLaunchUrl`
    call, the `VIEW` intent that we build, and the tab generated altogether. We can
    get a callback associated with the created session that would be passed for any
    consecutive `mayLaunchUrl` calls. This method returns `CustomTabsSession` when
    a session is created successfully; otherwise, it returns `Null`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the prefetching URL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method will notify the browser that a navigation to this URL will happen
    soon. Make sure to `warmup()` prior to calling this method – this is a must. The
    most likely URL has to be specified first, and we can send an optional list of
    other likely URLs (`otherLikelyBundles`). The list have to be sorted in a descending
    order and the optional list may be ignored. A new call to this method will lower
    the priority of previous calls and can result in URLs not being prefetched. Boolean
    values inform us whether the operation has been completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Custom tabs connection callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a callback triggered upon each navigation event in the custom tab.
    The `int navigationEvent` element is one of the six that defines the state the
    page is in. Refer to the following code for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about a newly added feature, Chrome custom tabs, which allows us
    to embed web content into our application and modify the UI. Chrome custom tabs
    allow us to provide a fuller, faster in-app web experience for our users. We use
    the Chrome engine under the hood, which allows faster loading than regular WebViews
    or loading the entire Chrome (or another browser) application.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that we can preload pages in the background, making it appear as if our
    data is blazing fast. We can customize the look and feel of our Chrome tab so
    that it matches our app. Among the changes we saw were the toolbar color, transition
    animations, and even the addition of custom actions to the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Custom tabs also benefit from Chrome features such as saved passwords, autofill,
    tap to search, and sync; these are all available within a custom tab. For developers,
    integration is quite easy and requires only a few extra lines of code in the basic
    level. The support library helps with more complex integration, if required.
  prefs: []
  type: TYPE_NORMAL
- en: This is a Chrome feature, which means you get it on any Android device where
    the latest versions of Chrome are installed. Remember that the Chrome custom tab
    support library changes with new features and fixes, which is the same as other
    support libraries, so please update your version and make sure that you use the
    latest API to avoid any issues.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will take a deep breath and look at some of the new
    authentication/security features Android Marshmallow has to offer.
  prefs: []
  type: TYPE_NORMAL
