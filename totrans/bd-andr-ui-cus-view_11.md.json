["```kt\nprivate float dragX; \nprivate float dragY; \n\n@Override \npublic boolean onTouchEvent(MotionEvent event) { \n   switch(event.getAction()) { \n       case MotionEvent.ACTION_DOWN: \n           dragX = event.getX(); \n           dragY = event.getY(); \n\n           getParent().requestDisallowInterceptTouchEvent(true); \n           return true; \n\n       case MotionEvent.ACTION_UP: \n           getParent().requestDisallowInterceptTouchEvent(false); \n           return true; \n\n       case MotionEvent.ACTION_MOVE: \n           float newX = event.getX(); \n           float newY = event.getY(); \n\n           angleTarget -= (dragX - newX) / 3.f; \n\n           dragX = newX; \n           dragY = newY; \n           return true; \n       default: \n           return false; \n   } \n} \n```", "```kt\nprivate float angle = 0.f; \nprivate float angleTarget = 0.f; \nprivate float angleFr = 0.f; \n\nprivate void animateLogic() { \n    long currentTime = SystemClock.elapsedRealtime(); \n    accTime += currentTime - timeStart; \n    timeStart = currentTime; \n\n    while (accTime > TIME_THRESHOLD) { \n        angle += (angleTarget - angle) / 4.f; \n        accTime -= TIME_THRESHOLD; \n    } \n\n    float factor = ((float) accTime) / TIME_THRESHOLD; \n    float nextAngle = angle + (angleTarget - angle) / 4.f; \n\n    angleFr = angle * (1.f - factor) + nextAngle * factor; \n} \n```", "```kt\n@Override \npublic void onSurfaceChanged(GL10 unused, int width, int height) { \n    GLES20.glViewport(0, 0, width, height); \n\n    float ratio = (float) width / height; \n    Matrix.perspectiveM(mProjectionMatrix, 0, 90, ratio, 0.1f, 7.f); \n} \n```", "```kt\n@Override \npublic void onDrawFrame(GL10 unused) { \nanimateLogic();\n    GLES20.glClearColor(1.0f, 0.0f, 0.0f, 1.0f); \n    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT); \n\n    Matrix.setLookAtM(mViewMatrix, 0, \n            0, 0, -3, \n            0f, 0f, 0f, \n            0f, 1.0f, 0.0f); \n\n    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);\n    Matrix.rotateM(mMVPMatrix, 0, angleFr, 0.f, 1.f, 0.f);\n    Matrix.rotateM(mMVPMatrix, 0, 5.f, 1.f, 0.f, 0.f);\n    GLES20.glUseProgram(shaderProgram); \n    int positionHandle = GLES20.glGetAttribLocation(shaderProgram, \"vPosition\"); \n    GLES20.glVertexAttribPointer(positionHandle, 3, \n            GLES20.GL_FLOAT, false, \n            0, vertexBuffer); \n\n    int texCoordHandle = GLES20.glGetAttribLocation(shaderProgram, \"aTex\"); \n    GLES20.glVertexAttribPointer(texCoordHandle, 2, GLES20.GL_FLOAT, false, \n                                 0, texBuffer); \n    int mMVPMatrixHandle = GLES20.glGetUniformLocation(shaderProgram,\n                           \"uMVPMatrix\"); \n\n    GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0); \n\n    int texHandle = GLES20.glGetUniformLocation(shaderProgram, \"sTex\"); \n    GLES20.glActiveTexture(GLES20.GL_TEXTURE0); \n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); \n    GLES20.glUniform1i(texHandle, 0); \n\n    GLES20.glEnable(GLES20.GL_DEPTH_TEST); \n    GLES20.glEnableVertexAttribArray(texHandle); \n    GLES20.glEnableVertexAttribArray(positionHandle); \n    GLES20.glDrawElements( \n            GLES20.GL_TRIANGLES, index.length, \n            GLES20.GL_UNSIGNED_SHORT, indexBuffer); \n\n    GLES20.glDisableVertexAttribArray(positionHandle); \n    GLES20.glDisableVertexAttribArray(texHandle); \n    GLES20.glDisable(GLES20.GL_DEPTH_TEST); \n} \n```", "```kt\nprivate GestureDetectorCompat gestureDetector =  \n        new GestureDetectorCompat(context, new MenuGestureListener()); \n```", "```kt\n@Override \npublic boolean onTouchEvent(MotionEvent event) { \n    return gestureDetector.onTouchEvent(event); \n} \n```", "```kt\nclass MenuGestureListener extends  \n        GestureDetector.SimpleOnGestureListener { \n   @Override \n   public boolean onDown(MotionEvent e) { \n       scroller.forceFinished(true); \n       return true; \n   } \n\n   @Override \n   public boolean onScroll(MotionEvent e1, MotionEvent e2, float\n   distanceX,\n   float distanceY) { \n       scroller.computeScrollOffset(); \n       int lastX = scroller.getCurrX(); \n\n       scroller.forceFinished(true); \n       scroller.startScroll(lastX, 0, -(int) (distanceX + 0.5f), 0); \n       return true; \n   } \n\n   @Override \n   public boolean onFling(MotionEvent e1, MotionEvent e2, float \n   velocityX, float velocityY) { \n       scroller.computeScrollOffset(); \n       int lastX = scroller.getCurrX(); \n\n       scroller.forceFinished(true); \n       scroller.fling(lastX,\n             0, \n             (int) (velocityX/4.f),\n             0, \n             -360*100,\n             360*100,\n             0,\n             0); \n       return true; \n   } \n} \n```", "```kt\nMatrix.rotateM(mMVPMatrix, 0, scroller.getCurrX(), 0.f, 1.f, 0.f); \n```", "```kt\nif (scroller.isFinished()) { \n    int lastX = scroller.getCurrX(); \n    int modulo = lastX % 90; \n    int snapX = (lastX / 90) * 90; \n    if (modulo >= 45) snapX += 90; \n    if (modulo <- 45) snapX -= 90; \n\n    if (lastX != snapX) { \n        scroller.startScroll(lastX, 0, snapX - lastX, 0); \n    } \n} \n```", "```kt\nint face = lastX / 90; \nint snapX = face * 90; \n```", "```kt\ninterface OnMenuClickedListener { \n    void menuClicked(int option); \n} \n```", "```kt\nprivate OnMenuClickedListener listener; \n\npublic void setOnMenuClickedListener(OnMenuClickedListener listener) { \n    this.listener = listener; \n} \n```", "```kt\n@Override \npublic boolean onSingleTapUp(MotionEvent e) { \n    scroller.computeScrollOffset(); \n    int angle = scroller.getCurrX(); \n    int face = (angle / 90) % 4; \n    if (face < 0) face += 4; \n\n    if (listener != null) listener.menuClicked(face); \n    return true; \n} \n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<LinearLayout \n\n    android:id=\"@+id/activity_main\" \n    android:layout_width=\"match_parent\" \n    android:layout_height=\"match_parent\" \n    android:orientation=\"vertical\" \n    android:padding=\"@dimen/activity_vertical_margin\" \n    tools:context=\"com.packt.rrafols.draw.MainActivity\"> \n\n<com.packt.rrafols.draw.GLDrawer \nandroid:id=\"@+id/gldrawer\"\n        android:layout_width=\"match_parent\" \n        android:layout_height=\"match_parent\"/> \n</LinearLayout> \n```", "```kt\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    GLDrawer glDrawer = (GLDrawer) findViewById(R.id.gldrawer);\n    glDrawer.setOnMenuClickedListener(new\n    GLDrawer.OnMenuClickedListener() {\n        @Override\n        public void menuClicked(int option) {\n            Log.i(\"Example36-Menu3D\", \"option clicked \" + option);\n        }\n    });\n}\n```", "```kt\nprivate float quadCoords[] = { \n        -1.f, -1.f, -1.0f,  // 0 \n        -1.f,  1.f, -1.0f,  // 1 \n         1.f,  1.f, -1.0f,  // 2 \n         1.f, -1.f, -1.0f,  // 3 \n\n        -1.f, -1.f,  1.0f,  // 4 \n        -1.f,  1.f,  1.0f,  // 5 \n         1.f,  1.f,  1.0f,  // 6 \n         1.f, -1.f,  1.0f,   // 7 \n\n        -1.f, -1.f, -1.0f,  // 8 - 0 \n        -1.f, -1.f,  1.0f,  // 9 - 4 \n         1.f, -1.f,  1.0f,  // 10 - 7 \n         1.f, -1.f, -1.0f,  // 11 - 3 \n\n        -1.f,  1.f, -1.0f,  // 12 - 1 \n        -1.f,  1.f,  1.0f,  // 13 - 5 \n         1.f,  1.f,  1.0f,  // 14 - 6 \n         1.f,  1.f, -1.0f,  // 15 - 2 \n\n        -1.f, -1.f, -1.0f,  // 16 - 0 \n        -1.f, -1.f,  1.0f,  // 17 - 4 \n        -1.f,  1.f,  1.0f,  // 18 - 5 \n        -1.f,  1.f, -1.0f,  // 19 - 1 \n\n         1.f, -1.f, -1.0f,  // 20 - 3 \n         1.f, -1.f,  1.0f,  // 21 - 7 \n         1.f,  1.f,  1.0f,  // 22 - 6 \n         1.f,  1.f, -1.0f   // 23 - 2 \n}; \n\nprivate short[] index = { \n        0, 1, 2,        // front \n        0, 2, 3,        // front \n        4, 5, 6,        // back \n        4, 6, 7,        // back \n        8, 9,10,        // top \n        8,11,10,        // top \n       12,13,14,        // bottom \n       12,15,14,        // bottom \n       16,17,18,        // left \n       16,19,18,        // left \n       20,21,22,        // right \n       20,23,22         // right \n};  \n```", "```kt\nfloat colors[] = { \n        0.0f, 1.0f, 0.0f, 1.0f, \n        0.0f, 1.0f, 0.0f, 1.0f, \n        0.0f, 1.0f, 0.0f, 1.0f, \n        0.0f, 1.0f, 0.0f, 1.0f, \n\n        0.0f, 0.0f, 1.0f, 1.0f, \n        0.0f, 0.0f, 1.0f, 1.0f, \n        0.0f, 0.0f, 1.0f, 1.0f, \n        0.0f, 0.0f, 1.0f, 1.0f, \n\n        0.0f, 0.0f, 0.0f, 1.0f, \n        0.0f, 0.0f, 0.0f, 1.0f, \n        0.0f, 0.0f, 0.0f, 1.0f, \n        0.0f, 0.0f, 0.0f, 1.0f, \n\n        1.0f, 1.0f, 1.0f, 1.0f, \n        1.0f, 1.0f, 1.0f, 1.0f, \n        1.0f, 1.0f, 1.0f, 1.0f, \n        1.0f, 1.0f, 1.0f, 1.0f, \n\n        1.0f, 1.0f, 0.0f, 1.0f, \n        1.0f, 1.0f, 0.0f, 1.0f, \n        1.0f, 1.0f, 0.0f, 1.0f, \n        1.0f, 1.0f, 0.0f, 1.0f, \n\n        1.0f, 0.0f, 1.0f, 1.0f, \n        1.0f, 0.0f, 1.0f, 1.0f, \n        1.0f, 0.0f, 1.0f, 1.0f, \n        1.0f, 0.0f, 1.0f, 1.0f \n}; \n```", "```kt\nByteBuffer cbb = ByteBuffer.allocateDirect(colors.length * (Float.SIZE / 8)); \ncbb.order(ByteOrder.nativeOrder()); \n\ncolorBuffer = cbb.asFloatBuffer(); \ncolorBuffer.put(colors); \ncolorBuffer.position(0); \n```", "```kt\nprivate final String vertexShaderCode = \n        \"uniform mat4 uMVPMatrix;\" + \n        \"attribute vec4 vPosition;\" + \n        \"attribute vec4 aColor;\" + \n        \"varying vec4 vColor;\" + \n        \"void main() {\" + \n        \"  gl_Position = uMVPMatrix * vPosition;\" + \n        \"  vColor = aColor;\" + \n        \"}\"; \n\nprivate final String fragmentShaderCode = \n        \"precision mediump float;\" + \n        \"varying vec4 vColor;\" + \n        \"void main() {\" + \n        \"  gl_FragColor = vColor;\" + \n        \"}\"; \n```", "```kt\npublic void setColors(int[] faceColors) { \n    glRenderer.setColors(faceColors); \n} \n```", "```kt\nprivate void setColors(int[] faceColors) { \n    colors = new float[4 * 4 * faceColors.length]; \n    int wOffset = 0; \n    for (int faceColor : faceColors) { \n        float[] color = hexToRGBA(faceColor); \n        for(int j = 0; j < 4; j++) { \n            colors[wOffset++] = color[0]; \n            colors[wOffset++] = color[1]; \n            colors[wOffset++] = color[2]; \n            colors[wOffset++] = color[3]; \n        } \n    } \n    ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length *\n    (Float.SIZE /8)); \n    cbb.order(ByteOrder.nativeOrder()); \n\n    colorBuffer = cbb.asFloatBuffer(); \n    colorBuffer.put(colors); \n    colorBuffer.position(0); \n} \n```", "```kt\nprivate float[] hexToRGBA(int color) { \n    float[] out = new float[4]; \n\n    int a = (color >> 24) & 0xff; \n    int r = (color >> 16) & 0xff; \n    int g = (color >>  8) & 0xff; \n    int b = (color      ) & 0xff; \n\n    out[0] = ((float) r) / 255.f; \n    out[1] = ((float) g) / 255.f; \n    out[2] = ((float) b) / 255.f; \n    out[3] = ((float) a) / 255.f; \n    return out; \n} \n```", "```kt\nglDrawer.setColors(new int[] { \n        0xff4a90e2, \n        0xff161616, \n        0xff594236, \n        0xffff5964, \n        0xff8aea92, \n        0xffffe74c \n}); \n```", "```kt\nprivate float planeCoords[] = { \n        -1.f, -1.f, -1.4f, \n        -1.f,  1.f, -1.4f, \n         1.f,  1.f, -1.4f, \n         1.f, -1.f, -1.4f, \n}; \n\nprivate short[] planeIndex = { \n        0, 1, 2, \n        0, 2, 3 \n}; \n\nprivate float texCoords[] = { \n        1.f, 1.f, \n        1.f, 0.f, \n        0.f, 0.f, \n        0.f, 1.f \n}; \n```", "```kt\nprivate final String vertexShaderCodeText = \n        \"uniform mat4 uMVPMatrix;\" + \n        \"attribute vec4 vPosition;\" + \n        \"attribute vec2 aTex;\" + \n        \"varying vec2 vTex;\" + \n        \"void main() {\" + \n        \"  gl_Position = uMVPMatrix * vPosition;\" + \n        \"  vTex = aTex;\" + \n        \"}\"; \n\nprivate final String fragmentShaderCodeText = \n        \"precision mediump float;\" + \n        \"uniform sampler2D sTex;\" + \n        \"varying vec2 vTex;\" + \n        \"void main() {\" + \n        \"  gl_FragColor = texture2D(sTex, vTex);\" + \n        \"}\"; \n```", "```kt\nprivate void initBuffers() { \n    ByteBuffer vbb = ByteBuffer.allocateDirect(quadCoords.length  \n            * (Float.SIZE / 8)); \n    vbb.order(ByteOrder.nativeOrder()); \n\n    vertexBuffer = vbb.asFloatBuffer(); \n    vertexBuffer.put(quadCoords); \n    vertexBuffer.position(0); \n\n    ByteBuffer ibb = ByteBuffer.allocateDirect(index.length \n            * (Short.SIZE / 8)); \n    ibb.order(ByteOrder.nativeOrder()); \n\n    indexBuffer = ibb.asShortBuffer(); \n    indexBuffer.put(index); \n    indexBuffer.position(0); \n\n    ByteBuffer cbb = ByteBuffer.allocateDirect(colors.length \n            * (Float.SIZE / 8)); \n    cbb.order(ByteOrder.nativeOrder()); \n\n    colorBuffer = cbb.asFloatBuffer(); \n    colorBuffer.put(colors); \n    colorBuffer.position(0); \n\n    vbb = ByteBuffer.allocateDirect(planeCoords.length \n            * (Float.SIZE / 8)); \n    vbb.order(ByteOrder.nativeOrder()); \n\n    vertexTextBuffer = vbb.asFloatBuffer(); \n    vertexTextBuffer.put(planeCoords); \n    vertexTextBuffer.position(0); \n\n    ibb = ByteBuffer.allocateDirect(planeIndex.length \n            *  (Short.SIZE / 8)); \n    ibb.order(ByteOrder.nativeOrder()); \n\n    indexTextBuffer = ibb.asShortBuffer(); \n    indexTextBuffer.put(planeIndex); \n    indexTextBuffer.position(0); \n\n    ByteBuffer tbb = ByteBuffer.allocateDirect(texCoords.length \n            * (Float.SIZE / 8)); \n    tbb.order(ByteOrder.nativeOrder()); \n\n    texBuffer = tbb.asFloatBuffer(); \n    texBuffer.put(texCoords); \n    texBuffer.position(0); \n}              \n```", "```kt\nprivate void initShaders() { \n    int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode); \n    int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, \n    fragmentShaderCode); \n\n    shaderProgram = GLES20.glCreateProgram(); \n    GLES20.glAttachShader(shaderProgram, vertexShader); \n    GLES20.glAttachShader(shaderProgram, fragmentShader); \n    GLES20.glLinkProgram(shaderProgram); \n\n    vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexShaderCodeText); \n    fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER,\n    fragmentShaderCodeText); \n\n    shaderTextProgram = GLES20.glCreateProgram(); \n    GLES20.glAttachShader(shaderTextProgram, vertexShader); \n    GLES20.glAttachShader(shaderTextProgram, fragmentShader); \n    GLES20.glLinkProgram(shaderTextProgram); \n} \n```", "```kt\nprivate Bitmap createBitmapFromText(String text) { \n    Bitmap out = Bitmap.createBitmap(512, 512,\n    Bitmap.Config.ARGB_8888); \n    out.eraseColor(0x00000000); \n\n    Paint textPaint = new Paint(); \n    textPaint.setAntiAlias(true); \n    textPaint.setColor(0xffffffff); \n    textPaint.setTextSize(60); \n    textPaint.setStrokeWidth(2.f); \n    textPaint.setStyle(Paint.Style.FILL); \n\n    Rect textBoundaries = new Rect(); \n    textPaint.getTextBounds(text, 0, text.length(), textBoundaries); \n\n    Canvas canvas = new Canvas(out); \n    for (int i = 0; i < 2; i++) { \n        canvas.drawText(text, \n                (canvas.getWidth() - textBoundaries.width()) / 2.f, \n                (canvas.getHeight() - textBoundaries.height()) / 2.f + \n                 textBoundaries.height(), textPaint); \n        textPaint.setColor(0xff000000); \n        textPaint.setStyle(Paint.Style.STROKE); \n    } \n    return out; \n} \n```", "```kt\nprivate int loadTexture(int resId) { \n    final int[] textureIds = new int[1]; \n    GLES20.glGenTextures(1, textureIds, 0); \n\n    if (textureIds[0] == 0) return -1; \n\n    // do not scale the bitmap depending on screen density \n    final BitmapFactory.Options options = new BitmapFactory.Options(); \n    options.inScaled = false; \n\n    final Bitmap textureBitmap =\n    BitmapFactory.decodeResource(getResources(),\n    resId, options); \n    attachBitmapToTexture(textureIds[0], textureBitmap); \n\n    return textureIds[0]; \n} \n```", "```kt\nprivate void attachBitmapToTexture(int textureId, Bitmap textureBitmap) { \n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); \n\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); \n\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); \n\n    GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE); \n\n    GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, \n            GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE); \n\n    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, textureBitmap, 0); \n} \n```", "```kt\nprivate int generateTextureFromText(String text) { \n    final int[] textureIds = new int[1]; \n    GLES20.glGenTextures(1, textureIds, 0); \n\n    Bitmap textureBitmap = createBitmapFromText(text); \n    attachBitmapToTexture(textureIds[0], textureBitmap); \n    textureBitmap.recycle(); \n    return textureIds[0]; \n} \n```", "```kt\n@Override \npublic void onSurfaceCreated(GL10 unused, EGLConfig config) { \n    initBuffers(); \n    initShaders(); \n\n    textureId = new int[4]; \n    for (int i = 0; i < textureId.length; i++) { \n        textureId[i] = generateTextureFromText(\"Option \" + (i + 1)); \n    } \n} \n```", "```kt\nGLES20.glUseProgram(shaderTextProgram); \npositionHandle = GLES20.glGetAttribLocation(shaderTextProgram, \"vPosition\"); \n\nGLES20.glVertexAttribPointer(positionHandle, 3, \n        GLES20.GL_FLOAT, false, \n        0, vertexTextBuffer); \n\nint texCoordHandle = GLES20.glGetAttribLocation(shaderTextProgram, \"aTex\"); \nGLES20.glVertexAttribPointer(texCoordHandle, 2, \n        GLES20.GL_FLOAT, false, \n        0, texBuffer); \n\nint texHandle = GLES20.glGetUniformLocation(shaderTextProgram, \"sTex\"); \nGLES20.glActiveTexture(GLES20.GL_TEXTURE0); \nGLES20.glEnable(GLES20.GL_BLEND); \nGLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA); \n\nfor (int i = 0; i < 4; i++) { \n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[i]); \n    GLES20.glUniform1i(texHandle, 0); \n\n    mMVPMatrixHandle = GLES20.glGetUniformLocation(shaderTextProgram,\n    \"uMVPMatrix\"); \n    GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix,\n    0); \n\n    GLES20.glEnableVertexAttribArray(texHandle); \n    GLES20.glEnableVertexAttribArray(positionHandle); \n    GLES20.glDrawElements( \n            GLES20.GL_TRIANGLES, planeIndex.length, \n            GLES20.GL_UNSIGNED_SHORT, indexTextBuffer); \n\n    GLES20.glDisableVertexAttribArray(positionHandle); \n    GLES20.glDisableVertexAttribArray(texHandle); \n\n    Matrix.rotateM(mMVPMatrix, 0, -90.f, 0.f, 1.f, 0.f); \n} \n\nGLES20.glDisable(GLES20.GL_BLEND); \nGLES20.glDisable(GLES20.GL_DEPTH_TEST); \n```", "```kt\npublic void setNumOptions(int options) { \n    double halfAngle = Math.PI / options; \n    float[] coords = new float[options * 3 * 4]; \n    int offset = 0; \n    for (int i = 0; i < options; i++) { \n        float angle = (float) (i * 2.f * Math.PI / options \n                - Math.PI / 2.f - halfAngle); \n\n        float nextAngle = (float) ((i + 1) * 2.f * Math.PI / options \n                - Math.PI / 2.f - halfAngle); \n\n        float x0 = (float) Math.cos(angle) * 1.2f; \n        float x1 = (float) Math.cos(nextAngle) * 1.2f; \n        float z0 = (float) Math.sin(angle) * 1.2f; \n        float z1 = (float) Math.sin(nextAngle) * 1.2f; \n\n        coords[offset++] = x0; \n        coords[offset++] = -1.f; \n        coords[offset++] = z0; \n\n        coords[offset++] = x1; \n        coords[offset++] = -1.f; \n        coords[offset++] = z1; \n\n        coords[offset++] = x0; \n        coords[offset++] = 1.f; \n        coords[offset++] = z0; \n\n        coords[offset++] = x1; \n        coords[offset++] = 1.f; \n        coords[offset++] = z1; \n    } \n\n    short[] index = new short[options * 6]; \n    for (int i = 0; i < options; i++) { \n        index[i * 6 + 0] = (short) (i * 4 + 0); \n        index[i * 6 + 1] = (short) (i * 4 + 1); \n        index[i * 6 + 2] = (short) (i * 4 + 3); \n\n        index[i * 6 + 3] = (short) (i * 4 + 0); \n        index[i * 6 + 4] = (short) (i * 4 + 2); \n        index[i * 6 + 5] = (short) (i * 4 + 3); \n    } \n\n    glRenderer.setCoordinates(options, coords, index); \n} \n```", "```kt\nprivate void setCoordinates(int options, float[] coords, short[] index) { \n    this.quadCoords = coords; \n    this.index = index; \n    this.options = options; \n} \n```", "```kt\n@Override \npublic void onSurfaceCreated(GL10 unused, EGLConfig config) { \n    initBuffers(); \n    initShaders(); \n\n    textureId = new int[options]; \n    for (int i = 0; i < textureId.length; i++) { \n        textureId[i] = generateTextureFromText(\"Option \" + (i + 1)); \n    } \n\n    faceAngle = 360.f / options; \n} \n```", "```kt\n@Override \nprotected void onCreate(Bundle savedInstanceState) { \n    super.onCreate(savedInstanceState); \n\n    setContentView(R.layout.activity_main); \n\n    GLDrawer glDrawer = (GLDrawer) findViewById(R.id.gldrawer); \n    glDrawer.setOnMenuClickedListener(new\n    GLDrawer.OnMenuClickedListener() { \n        @Override \n        public void menuClicked(int option) { \n            Log.i(\"Example37-Menu3D\", \"option clicked \" + option); \n        } \n    }); \n    glDrawer.setColors(new int[] { \n            0xff4a90e2, \n            0xff161616, \n            0xff594236, \n            0xffff5964, \n            0xff8aea92, \n            0xffffe74c \n    }); \n\n    glDrawer.setNumOptions(6); \n} \n```"]