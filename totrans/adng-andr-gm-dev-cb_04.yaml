- en: Chapter 4. Working with Cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover AndEngine''s various camera objects and advanced camera
    control. The topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the camera object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the camera area with the bound camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a closer look with zoom cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating smooth moves with a smooth camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinch-zoom camera functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stitching a background together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a HUD to the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching a controller to the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a split screen game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AndEngine includes three types of cameras, not including the base `Camera` object,
    which allow us to control (more specifically) how the camera behaves. Cameras
    can play many different roles in a game, and in some cases, we may find ourselves
    in need of more than one camera. This chapter is going to cover some of the different
    purposes and ways we can use AndEngine's `Camera` objects in order to apply more
    advanced camera functionality into our own games.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the camera object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cameras can have many purposes when it comes to designing a large-scale game,
    but its main objective is to display a particular area of the game world on the
    device's display. This topic is going to introduce the base `Camera` class, covering
    the general aspects of the camera in order to provide a reference for future camera
    use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cameras are important in game development as they control what we see on the
    device. Creating our camera is as easy as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `WIDTH` and `HEIGHT` values will define the area of the game's scene that
    will be displayed on the device.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s important to get to know the main functions of a camera in order to make
    the most of it in our projects. All of the different cameras inherit the methods
    found in this topic. Let''s take a look at some of the most necessary camera methods
    needed for AndEngine development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positioning the camera**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Camera` object follows the same coordinate system as entities. Setting
    the camera''s coordinates to `(0,0)`, for example, will set the center point of
    the camera to the defined coordinates. Additionally, increasing the x value moves
    the camera to the right-hand side and increasing the y value moves the camera
    upward. Decreasing the values will have the opposite effect. In order to relocate
    the camera to center on a defined location, we can call the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would not have any effect on the default camera position
    (assuming that the `WIDTH` and `HEIGHT` values were used to define the camera's
    width and height). This would set the camera's center to the "center" of our scene,
    which is naturally equal to half the camera `WIDTH` and `HEIGHT` values when the
    `Camera` object is created. The preceding method call could be used in a situation
    where we'd like to reset the camera back to its initial position, which is useful
    in cases where a camera moves during gameplay, but should return to its initial
    position when a user returns to the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving the camera without setting specific coordinates can be achieved through
    the `offsetCenter(x,y)` method, where the `x` and `y` values define the distance
    to offset the camera in scene coordinates. This method adds the specified parameter
    values to the camera''s current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can obtain the camera''s center x and y coordinates through
    the use of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Adjusting the camera''s width and height**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The camera''s initial width and height can be adjusted via the camera''s `set()`
    method. We can also set the camera''s minimum/maximum x and y values by calling
    methods such as `setXMin()`/`setXMax()` and `setYMin()`/`setYMax()`. The following
    code will cause the camera width to shrink by half, while sustaining the initial
    camera height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that while shrinking the camera width, we lose visibility on the
    pixels and any entities outside of the defined area. Additionally, shrinking or
    extending the camera's width and height may cause entities to appear stretched
    or squeezed. Generally, modifying the camera's width and height are not necessary
    in the development of a typical game.
  prefs: []
  type: TYPE_NORMAL
- en: The `Camera` object also allows us to obtain the camera's current min/max width
    and height values by calling `getXMin()`/`getXMax()` and `getYMin()`/`getYMax()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visibility checking**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Camera` class allows us to check if specific `Entity` objects are visible
    within the camera''s view. `Entity` object subtypes include, but are not limited
    to, the `Line` and `Rectangle` primitives, `Sprite`, and `Text` objects, as well
    as all of their subtypes such as `TiledSprite` and `ButtonSprite` objects and
    more. Visibility checking can be called through the use of the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Visibility checks can be very useful for many games in order to re-use objects
    which might leave the camera's view, to name one scenario. This can allow us to
    limit the overall number of objects created in situations where we may have many
    objects being spawned, which eventually leave the camera view. Instead, we can
    re-use objects which leave the camera view.
  prefs: []
  type: TYPE_NORMAL
- en: '**The chase entity functionality**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often times, games require the camera to follow an `Entity` object as it moves
    around the screen, such as in a side-scroller. We can easily set up our camera
    to follow entities wherever they move in the game world by calling a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will apply the camera position to the specified entity's
    position on every update to the camera. This ensures that the entity stays in
    the center of the camera at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the majority of recipes in this book, we are specifying a camera width of
    800 pixels and a camera height of 480 pixels. However, these values are entirely
    up to the developer and should be defined by the needs of the game. These specific
    values are chosen for this book's recipes due to the fact that they are relatively
    suitable for both small and large screen devices.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the camera area with the bound camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BoundCamera` object allows us to define specific bounds on the camera's
    area, limiting the distance the camera can travel on both the x and y axis. This
    camera is useful in situations where the camera may follow a player, but still
    not exceed the level bounds if the user travels close to a wall.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `BoundCamera` object creation requires the same parameters as a regular
    `Camera` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BoundCamera` object extends the ordinary `Camera` object, giving us all
    of the original functionality of a camera as described in the *Introducing the
    camera object* recipe, which is given in this chapter. In fact, unless we configure
    a bounded area on the `BoundCamera` object, we are ideally working with a basic
    `Camera` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before our camera will apply restrictions to its available movement area, we
    must define the available area in which the camera is free to move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will set up the camera bounds starting from position `(0,0)`
    in scene coordinates through to `(3200,480)` since we are multiplying the camera's
    width by four times for the maximum x area, allowing the camera to scroll four
    times the camera's width. The camera will not respond to changes on the y axis
    as the bound height is set to the same value as the camera's height.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introducing the camera object* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a closer look with zoom cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AndEngine's `BoundCamera` and `Camera` objects do not support zooming in and
    out by default. If we would like to allow zooming of the camera, we can create
    a `ZoomCamera` object which extends the `BoundCamera` class. This object includes
    all of the functionality of its inherited classes, including creating camera bounds.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ZoomCamera` object, similar to `BoundCamera`, requires no additional parameters
    to be defined while creating the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to apply zoom effects to the camera, we can call the `setZoomFactor(factor)`
    method, where `factor` is the magnification we would like to apply to our `Scene`
    object. Zooming in and out can be achieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When handling the camera's zoom factor, we must know that a factor of `1` is
    equal to the default factor of the `Camera` class. A zoom factor greater than
    `1` will zoom the camera into the scene, while any value less than `1` will zoom
    the camera out.
  prefs: []
  type: TYPE_NORMAL
- en: The math involved for handling the zoom factor is very basic. The camera will
    simply divide the zoom factor by our camera's `WIDTH` and `HEIGHT` values, effectively
    causing the camera to "zoom". If our camera's width is `800`, then a zoom factor
    of `1.5f` will zoom the camera inward, ultimately setting the camera's width to
    `533.3333` which will limit the amount of area of the scene that is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getMinX()`, `getMaxX()`, `getMinY()`, `getMaxY()`, `getWidth()`, and `getHeight()`
    values returned by the `ZoomCamera` object in a situation where a zoom factor
    (not equal to 1) is applied, will automatically have had their values divided
    by the zoom factor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling bounds on a zoom camera with a factor not equal to 1 will have an effect
    on the total available area the camera is able to pan. Assuming that the bounds
    are set from 0 to 800 for the bounds' minimum and maximum x values, if the camera
    width is equal to 800 there will not be any movement allowed on the x axis. In
    the event we zoom the camera in, the camera's width will decrease, allowing for
    slack in the movement of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the event that a zoom factor is defined which would cause the camera's width
    or height to exceed the camera bounds, the zoom factor would be applied to the
    camera, but there would be no movement allowed on the exceeded axis.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introducing the camera object* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Limiting camera area with the bound camera* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating smooth moves with a smooth camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SmoothCamera` object is the most advanced of the four cameras to choose
    from. This camera allows for all of the different types of camera functionality
    (bounds, zooming, and so on) with an additional option to apply a defined velocity
    to the camera's movement speed upon setting a new position for the camera. The
    result may appear as if the camera "eases" in and out of movement, allowing for
    rather subtle camera movements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This camera type is the only one of the four which requires additional parameters
    to be defined in the constructor. These extra parameters include the maximum x
    and y velocities in which the camera can travel and the maximum zoom factor change
    which handles the speed that the camera will zoom in and out. Let''s take a look
    at what this camera creation will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we're creating a camera that applies a smooth transitional affect
    to camera movement and zooming. Unlike the other three camera types, rather than
    directly setting the camera center to the defined position with `setCenter(x,y)`,
    the camera uses the `maxVelocityX`, `maxVelocityY`, and `maxZoomFactorChange`
    variables to define how fast the camera will move from point A to point B. Increasing
    the velocities will cause the camera to make faster movements.
  prefs: []
  type: TYPE_NORMAL
- en: There are two options, both for camera movement and camera zooming for the `SmoothCamera`
    class. We can allow the camera to move or zoom smoothly by calling the default
    camera methods for these tasks (`camera.setCenter()` and `camera.setZoomFactor()`).
    On the other hand, sometimes we need to reposition our camera immediately. This
    can be done by calling the `camera.setCenterDirect()` and `camera.setZoomFactorDirect()`
    methods respectively. These methods are most commonly used in order to reset the
    position of a smooth camera.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Introducing the camera object* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Limiting camera area with the bound camera* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Taking a closer look with zoom cameras* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinch-zoom camera functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AndEngine includes a small list of "detector" classes which can be used in combination
    with scene touch events. This topic is going to cover the use of the `PinchZoomDetector`
    class in order to allow zooming of the camera by pressing two fingers on the display,
    moving them closer or further apart to adjust the zoom factor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the class named `ApplyingPinchToZoom` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow these steps for a walkthrough on setting up the pinch-to-zoom functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we must do is implement the appropriate listeners into our
    class. Since we''ll be working with touch events, we''ll need to include the `IOnSceneTouchListener`
    interface. Additionally, we''ll need to implement the `IPinchZoomDetectorListener`
    interface to handle changes in the camera''s zoom factor pending touch events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreateScene()` method of the `BaseGameActivity` class, set the `Scene`
    object''s touch listener to the `this` activity since we are letting the `BaseGameActivity`
    class implement the touch listener classes. We will also create and enable the
    `mPinchZoomDetector` object within this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the implemented `onSceneTouchEvent()` method of the `BaseGameActivity` class,
    we must pass the touch events to the `mPinchZoomDetector` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will obtain the initial zoom factor of the `ZoomCamera` object when
    the `mPinchZoomDetector` object registers that a user is applying two fingers
    to the display. We will use the `onPinchZoomStarted()` method, which is implemented
    via the `IPinchZoomDetectorListener` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will make changes to the `ZoomCamera` object''s zoom factor in the
    event that a pinching motion is detected on the display. This code will be placed
    in both the `onPinchZoom()` and `onPinchZoomFinished()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are overriding the scene touch events which take place on
    our scene, passing the touch events to the `PinchZoomDetector` object, which will
    handle the zoom functionality of the `ZoomCamera` object. The following steps
    will guide us through the process of how pinch-zooming works. Because we're working
    with zoom factors in this activity, we'll need to use either a `ZoomCamera` class
    or a `SmoothCamera` class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the first two steps for this recipe, we're implementing the required listeners
    and registering them to the `mScene` object and the `mPinchZoomDetector` object.
    Since the `ApplyingPinchToZoom` activity is implementing the listeners, we can
    pass `this`, which represents our `BaseGameActivity` class, to the `mScene` object
    as the touch listener. We can also pass this activity as the pinch detection listener.
    Once the pinch detector is created, we can enable or disable it by calling the
    `setEnabled(pSetEnabled)` method.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we are passing the `pSceneTouchEvent` object to the `onTouchEvent()`
    method of the pinch detector. Doing so will allow the pinch detector to obtain
    specific touch coordinates which will be used internally to calculate zoom factors
    based on finger positions.
  prefs: []
  type: TYPE_NORMAL
- en: Upon pressing two fingers on the screen, the pinch detector will fire the code
    snippet displayed in step four. We must obtain the initial zoom factor of the
    camera at this point in order to properly offset the zoom factor when the touch
    coordinates change.
  prefs: []
  type: TYPE_NORMAL
- en: The final step involves calculating the offset zoom factor and applying it to
    the `ZoomCamera` object. By multiplying the initial zoom factor by the zoom factor
    change calculated by the `PinchZoomDetector` object, we can successfully offset
    the zoom factor of the camera. Once we've calculated the value for our `newZoomFactor`
    object, we call `setZoomFactor(newZoomFactor)` in order to change the zoom level
    of our camera.
  prefs: []
  type: TYPE_NORMAL
- en: Containing the zoom factor within a specific range is as simple as adding an
    `if` statement, specifying the minimum and/or maximum zoom factors required for
    our needs. In this case, our camera cannot zoom out further than `0.5f` or zoom
    in closer than `1.5f`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Taking a closer look with zoom cameras* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stitching a background together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although AndEngine''s `Scene` object allows us to set a background for the
    scene, this is not always a viable solution for our projects. In order to allow
    panning and zooming of the background, we can stitch together multiple texture
    regions and apply them directly to the scene as sprites. This topic is going to
    cover stitching two 800 x 480 texture regions together in order to create a larger
    pan-able and zoom-able background. The idea behind background stitching is to
    allow for portions of a scene to be displayed in smaller chunks. This gives us
    the opportunity to create smaller texture sizes as to not exceed the 1024 x 1024
    maximum texture size for most devices. Additionally, we can enable culling so
    that segments of the scene are not drawn when they aren''t displayed onscreen
    in order to improve performance. See the following figure for a look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stitching a background together](img/8987OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting started...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perform the recipe, *Pinch-zoom camera functionality*, which is given in this
    chapter for an understanding of how pinch-to-zoom works. Additionally, we must
    prepare two separate 800 x 480 images, similar to the previous figure in this
    recipe's introduction, in PNG format, then refer to the class named `StitchedBackground`
    in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Background stitching is a simple concept which involves placing two or more
    sprites directly beside each other, on top of each other, or below each other
    in order to appear to have one single, large sprite. In this recipe, we''re going
    to cover how to do this in order to avoid the dreaded texture bleeding effect.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create our `BuildableBitmapTextureAtlas` and `ITextureRegion`
    objects. It is very important that the texture atlas is the exact same size as
    our image files in order to avoid texture bleeding. Also, we must not include
    any padding or spacing during the build process of the texture atlas. The following
    code will create the left-hand side texture atlas and texture region, however
    the same code will apply for the right-hand side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the texture resources are in place, we can move to the `onPopulateScene()`
    method of the activity where we will create and apply the sprites to the `Scene`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Background stitching can be used in many different scenarios in order to avoid
    certain problems. These problems range from excessive texture sizes which lead
    to incompatibility on certain devices, static backgrounds which do not respond
    to changes in camera position or zoom factor, and performance issues to name a
    few. In this recipe, we're creating a large background which is created by stitching
    together two `Sprite` objects side-by-side, each representing a different `TextureRegion`
    object. The result is a large background which is double the size of the camera's
    width at 1600 x 480 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases when dealing with stitched backgrounds which allow scrolling of
    the scene, we'll need to enable some camera bounds in order to stop updating camera
    position if it attempts to exceed the background's area. We can use a `ZoomCamera`
    object to do this, setting the bounds to the predetermined size of the background.
    Since we're working with two PNG images, each 800 x 480 pixels stitched side-by-side,
    it's safe to say coordinates `(0,0)` to `(1600 x 480)` will suffice for the camera
    bounds.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in step one, there are a few rules we must follow when creating large-scale
    backgrounds with this approach. The image size must be exactly the same as the
    `BuildableBitmapTextureAtlas` texture atlas size! Failing to follow this rule
    will likely cause artifacts to occur between the sprites periodically, which is
    very distracting to the player. This also means that we should not include more
    than one `ITextureRegion` object in a `BuildableBitmapTextureAtlas` object that
    is meant for background stitching. Padding and spacing is also one of the features
    we should avoid in this case. However, following these rules, we are still able
    to apply the `TextureOptions.BILINEAR` texture filtering to the texture atlas
    and it will not cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we continue on to create the `Sprite` objects. There's nothing
    special here; we simply create one `Sprite` object in a given position, then set
    up the next sprite directly beside the first. For backgrounds which are extremely
    large and diverse, this method of stitching textures together can help to dramatically
    reduce the performance cost of an application by allowing us to stop rendering
    smaller segments of a background which are no longer visible. This feature is
    called **culling**. See *Disabling rendering with entity culling* in [Chapter
    8](ch08.html "Chapter 8. Maximizing Performance"), *Maximizing Performance*, for
    more information on how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Designing Your Menu*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Taking a closer look with zoom cameras* given in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pinch-zoom camera functionality* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Disabling rendering with entity culling* in [Chapter 8](ch08.html "Chapter 8. Maximizing
    Performance"), *Maximizing Performance*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a HUD to the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **HUD** (**Heads-Up Display** ) can be a very useful component for even the
    simplest of games. The purpose of the HUD is to contain a set of buttons, text,
    or any other `Entity` object in order to supply the user with an interface. The
    HUD has two key points; the first being that the HUD's children will always be
    visible onscreen, regardless of whether or not the camera changes position. The
    second point is the fact that the HUD's children will always be shown in front
    of the scene's children. In this chapter, we're going to be applying a HUD to
    the camera in order to supply users with an interface during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the following code into the `onCreateEngineOptions()` method of any
    `BaseGameActivity` of your choice, substituting the camera type in this code snippet
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with a `HUD` class is generally a very easy task. The usefulness of
    a `HUD` class can range drastically depending on the type of game being created,
    but in any case, there are a few things we must know before deciding to use this
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `HUD` entities will not change positions upon camera movement. Once their
    position is defined, the entity will remain in that position onscreen unless otherwise
    set via `setPosition()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HUD` entities will always appear on top of any `Scene` entity, regardless
    of z-index, order of application, or any other scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Culling should *not* be applied to entities which are to be attached to the
    `HUD` class in any circumstance. Culling affects an `Entity` object on the `HUD`
    class the same way it would affect the `Entity` object on the `Scene` object,
    even though the `Entity` object does not appear to move off-screen. This will
    cause what seems like randomly disappearing `HUD` entities. Just don't do it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the code found in the *How to do it...* section, we can see that it''s very
    easy to set up the `HUD` class. Creating and applying the `HUD` object to the
    camera can be done in as little as the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From this point, we can treat the `HUD` object as if it were any other layer
    in our game in terms of applying entities.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a controller to the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the type of game we are creating, there are many possible solutions
    for player interactivity. AndEngine includes two separate classes, one of which
    simulates a directional control pad called a `DigitalOnScreenControl`, the other
    which simulates a joystick called an `AnalogOnScreenControl`. This topic is going
    to introduce AndEngine's `AnalogOnScreenControl` class, but working with this
    class will give us enough info to use either controller.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires two separate assets which will act as the base of the
    controller and the knob of the controller. Before moving on to the *How to do
    it...* section, please include an image called `controller_base.png` and `controller_knob.png`
    to the `assets/gfx` folder in a project of your choice. The images may look something
    like the following figure, with the base being 128 x 128 pixels and the knob being
    64 x 64 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started...](img/8987OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've got the two necessary assets in place for our controller, we can
    start coding it. First of all, we can start by creating the `ITextureRegion` and
    `BuildableBitmapTextureAtlas` objects that will hold each of the controller's
    assets. No special steps are required for the controller texture atlas or texture
    regions; simply create them as we would for an ordinary sprite. As usual, do this
    in the `onCreateResources()` method of an activity of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `ITextureRegion` objects have been coded and are ready for use within
    the activity, we can create the `AnalogOnScreenControl` class in the `onCreateScene()`
    method of our activity object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see, a few of the parameters are no different from what we would define
    while creating a `Sprite` object. The first five parameters are self-explanatory.
    The sixth parameter `(0.1f)` is the "time between updates" parameter. This value
    controls how often the events within the `onControlChange()` method are fired.
    More CPU-intensive code may benefit from increased time between updates, while
    less complex code may have no problem with a very low update time.
  prefs: []
  type: TYPE_NORMAL
- en: The last parameter we have to include in the controller's constructor is `IanalogOnScreenControlListener`,
    which handles events based on whether the controller was simply clicked or whether
    the controller is pressed and held in an offset position.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the `onControlChange()` event, we can obtain the current position
    of the controllers knob via the `pValueX` and `pValueY` variables. These values
    contain the x and y offsets of the controller. In this recipe, we are using the
    x and y offsets of the knob to move the camera's position, also giving us an idea
    of how we can put these variables to use in order to move other entities such
    as a player's sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coordinate conversion can be very useful in situations where a `Scene` object
    relies on a number of entities to act as base layers for a game's sprites. It's
    not uncommon for games which contain many parents, each with their own set of
    children, to need to obtain a child's position relative to the `Scene` object
    at one point or another. This isn't a problem in situations where each of the
    layers remain at the same (0, 0) coordinates on the scene throughout the entire
    game. On the other hand, when our layers start to move around, child positions
    will move with the parent but their coordinates on the layer will remain the same.
    This topic is going to cover converting scene coordinates to local coordinates
    in order to allow nested entities to be properly positioned on the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Import the following code to the `onCreateScene()` method of any `BaseGameActivity`
    of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in this recipe is to create and apply a `Rectangle` object to
    the `Scene` object. This `Rectangle` object will act as the parent entity to another
    `Rectangle` object. We set its color to blue in order to differentiate between
    the two rectangles when they overlap since the parent `Rectangle` object will
    constantly be moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add the child `Rectangle` object to the first `Rectangle` object
    we had created. This `Rectangle` object will not move; instead, it will remain
    in the center of the screen while its parent continues to move around. This `Rectangle`
    object will be making use of coordinate conversion in order to hold its position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `onCreateScene()` method above creates a `Scene` object which contains two
    separate `Rectangle` entities. The first `Rectangle` entity will be attached directly
    to the `Scene` object. The second `Rectangle` entity will be attached to the first
    `Rectangle` entity. The first `Rectangle` entity, named `rectangleLayer`, will
    constantly be moving from left to right and right to left. Typically, this would
    cause its child's position to follow the same movement pattern, but in this recipe
    we're using coordinate conversion in order to allow the child `Rectangle` entity
    to remain still as its parent moves.
  prefs: []
  type: TYPE_NORMAL
- en: The `rectangle` object in this recipe includes two variables named `convertToMidSceneX`
    and `convertToMidSceneY`. These variables simply hold the position in `Scene`
    coordinates that we would like to convert the local coordinates to. As we can
    see, their coordinates are defined to the middle of the scene. Within the `onManagedUpdate()`
    method of the `rectangle` object, we then use the `rectangleLayer.convertSceneCoordinatesToLocalCoordinates(convertToMidSceneX,
    convertToMidSceneY)` method, passing the resulting coordinates to a float array.
    What this does is basically asks the `rectangleLayer` object, "Where is position
    x/y on the scene in your opinion?" Since the `rectangleLayer` object is attached
    directly to the `Scene` object, it can easily determine where specific `Scene`
    coordinates are as it relies on the native `Scene` coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: When attempting to access the returned coordinates, we can access `convertedCoordinates[0]`
    to obtain the converted x coordinate and use `convertedCoordinates[1]` to obtain
    the converted y coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: On top of converting `Scene` to local `Entity` coordinates, we can also convert
    local `Entity` to `Scene` coordinates, touch event coordinates, camera coordinates,
    and a whole slew of other options. However, once we obtain a basic understanding
    of coordinate conversion, starting with this recipe, the rest of the conversion
    methods will seem very similar to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a split screen game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will introduce the `DoubleSceneSplitScreenEngine` class, most commonly
    used in games which allow multiple players to play their own instance of a game
    on each half of the display. The `DoubleSceneSplitScreenEngine` class allows us
    to provide each half of the device's display with its own `Scene` and `Camera`
    objects, giving us full control over what each half of the display will see.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the class named `SplitScreenExample` in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up our game to allow two separate `Scene` objects requires us to take
    a slightly different approach when initially setting up the `BaseGameActivity`
    class. However, once we have set up the separate `Scene` objects, managing them
    is actually very similar to if we were dealing with only one scene, aside from
    the fact that we've only got half of the original display space per scene. Perform
    the following steps to gain an understanding of how to set up the `DoubleSceneSplitScreenEngine`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we must take care of is decreasing the `WIDTH` value by half,
    since each camera will require half of the device''s display. Attempting to fit
    800 pixels in width onto each camera will cause noticeable skewing of objects
    on each scene. While we are declaring variables, we will also set up two `Scene`
    objects and two `Camera` objects which will be needed for the `DoubleSceneSplitScreenEngine`
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create two separate `SmoothCamera` objects in the `onCreateEngineOptions()`
    method of the `BaseGameActivity` class. These cameras will be used for displaying
    separate views for each half of the display. In this recipe, we''re applying automatic
    zooming in order to show the results of `DoubleSceneSplitScreenEngine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One more task to take care of in the `onCreateEngineOptions()` method of our
    `BaseGameActivity` class is to create the `EngineOptions` object, passing the
    `mCameraOne` object as the main camera. Additionally, chances are the scenes might
    require simultaneous touch events, so we will enable multitouch as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the fourth step, we will override the `BaseGameActivity` class'' `onCreateEngine()`
    method in order to create a `DoubleSceneSplitScreenEngine` object rather than
    the default `Engine` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving onto the `onCreateScene()` method, we will create the two `Scene` objects,
    set them up how we choose, and finally set each `Scene` object to the `DoubleSceneSplitScreenEngine`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that both of our `Camera` objects are set up and both of our `Scene` objects
    are set up and attached to the engine, we can start attaching `Entity` objects
    to each `Scene` object as we see fit, simply by specifying which `Scene` object
    to attach to as usual. This code should be placed within the `onPopulateScene()`
    method of the `BaseGameActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with the `DoubleSceneSplitScreenEngine` class, we can assume that
    our project will need two of everything if we are setting up for a multiplayer
    game. More specifically, we need two `Scene` objects for each half of the screen
    as well as two `Camera` objects. Due to the fact that we are splitting the viewing
    area of each `Camera` object in half, we shall reduce the `WIDTH` value of our
    cameras by half. Camera dimensions of 400 pixels in width by 480 pixels in height
    are reasonable in most cases, which allow us to keep a proper perspective on entities
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we are setting up two `SmoothCamera` objects which will
    automatically zoom in and out of their respective scenes in order to supply a
    visual result to this recipe. However, the `DoubleSceneSplitScreenEngine` class
    can use any variation of the `Camera` object, including the most basic type without
    causing any issue.
  prefs: []
  type: TYPE_NORMAL
- en: In the third step, we're continuing on to create the `EngineOptions` object.
    We supply the `mCameraOne` object as the `pCamera` parameter in the `EngineOptions`
    constructor, just as we would in any ordinary instance. Additionally, we are enabling
    multitouch in the `EngineOptions` object in order to allow simultaneous touch
    events to register for each `Scene` object. Ignoring the multitouch setup will
    result in each scene having to wait until the other scene is not being pressed
    down on before it can register touch events.
  prefs: []
  type: TYPE_NORMAL
- en: In step four, we create the `DoubleSceneSplitScreenEngine` object, passing in
    the `pEngineOptions` parameter created in the previous step as well as the second
    `Camera` object—`mCameraTwo`. At this point in code, we've now got both of our
    cameras registered to the engine; the first was registered within the `EngineOptions`
    object, and the second passed as a parameter to the `DoubleSceneSplitScreenEngine`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Step five includes the `onCreateScene()` method of the `BaseGameActivity` class,
    where we will create and set up each of the two `Scene` objects how we would like.
    At the most basic level, this involves creating the `Scene` objects, enabling
    and setting up or disabling the scene's background, setting the scene's user data
    to store its respective camera, and finally passing the `Scene` object to our
    `mEngine` object. While the second `Scene` object requires us to call the `setSecondScene(mSceneTwo)`
    method on our `mEngine` object, the `mSceneOne` object is passed to the `Engine`
    object as in any `BaseGameActivity`; in the `pOnCreateSceneCallback.onCreateSceneFinished(mSceneOne)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the sixth step, we are now "out of the woods", so to speak. At this point,
    we are finished setting up the engine, scenes, and cameras and we can now start
    to populate each scene however we'd like. The possibilities are quite extensive
    in terms of what we can do at this point, including using the second scene as
    a mini-map, a view for a multiplayer game, an alternative perspective on the first
    scene, and much more. Selecting which `Scene` object to attach an `Entity` object
    to at this point would be as simple as calling either `mSceneOne.attachChild(pEntity)`
    or `mSceneTwo.attachChild(pEntity)`.
  prefs: []
  type: TYPE_NORMAL
