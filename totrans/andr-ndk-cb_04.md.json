["```kt\n        import android.opengl.GLSurfaceView;\n        ……\n        public class MyActivity extends Activity {\n          private GLSurfaceView mGLView;\n          @Override\n          public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            mGLView = new MySurfaceView(this);\n                   setContentView(mGLView);\n          }\n        }\n        ```", "```kt\n        public class MySurfaceView extends GLSurfaceView {\n          private MyRenderer mRenderer;\n          public MySurfaceView(Context context) {\n            super(context);\n            mRenderer = new MyRenderer();\n            this.setRenderer(mRenderer);\n            this.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n          }\n        }\n        ```", "```kt\n        public class MyRenderer implements GLSurfaceView.Renderer{\n          @Override\n          public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n            naInitGL1x();\n          }\n          @Override\n          public void onDrawFrame(GL10 gl) {\n            naDrawGraphics();\n          }\n          @Override\n          public void onSurfaceChanged(GL10 gl, int width, int height) {\n            naSurfaceChanged(width, height);\n          }\n          ......\n        }\n        ```", "```kt\n    void naInitGL1x(JNIEnv* env, jclass clazz) {\n      glDisable(GL_DITHER);  \n      glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);    glShadeModel(GL_SMOOTH);    }\n\n    void naSurfaceChanged(JNIEnv* env, jclass clazz, int width, int height) {\n      glViewport(0, 0, width, height);\n      float ratio = (float) width / (float)height;\n      glMatrixMode(GL_PROJECTION);\n      glLoadIdentity();\n      glOrthof(-ratio, ratio, -1, 1, 0, 1);  }\n\n    void naDrawGraphics(JNIEnv* env, jclass clazz) {\n      glClear(GL_COLOR_BUFFER_BIT);\n      glMatrixMode(GL_MODELVIEW);\n      glLoadIdentity();\n      glTranslatef(0.3f, 0.0f, 0.0f);    //move to the right\n      glScalef(0.2f, 0.2f, 0.2f);        // Scale down\n      mTriangle.draw();\n      glLoadIdentity();\n      glTranslatef(-0.3f, 0.0f, 0.0f);    //move to the left\n      glScalef(0.2f, 0.2f, 0.2f);      // Scale down\n    glRotatef(45.0, 0.0, 0.0, 1.0);  //rotate\n      mSquare.draw();\n    }\n    ```", "```kt\n    void Triangle::draw() {\n      glEnableClientState(GL_VERTEX_ARRAY);\n      glVertexPointer(3, GL_FLOAT, 0, vertices);\n      glColor4f(0.5f, 0.5f, 0.5f, 0.5f);      //set the current color\n      glDrawArrays(GL_TRIANGLES, 0, 9/3);\n      glDisableClientState(GL_VERTEX_ARRAY);\n    }\n    ```", "```kt\n    void Square::draw() {\n      glEnableClientState(GL_VERTEX_ARRAY);\n      glEnableClientState(GL_COLOR_ARRAY);\n      glVertexPointer(3, GL_FLOAT, 0, vertices);\n      glColorPointer(4, GL_FLOAT, 0, colors);\n      glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, indices);\n      glDisableClientState(GL_VERTEX_ARRAY);\n      glDisableClientState(GL_COLOR_ARRAY);\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := TwoDG1\n    LOCAL_SRC_FILES := Triangle.cpp Square.cpp TwoDG1.cpp\n    LOCAL_LDLIBS := -lGLESv1_CM -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    public class MySurfaceView extends GLSurfaceView {\n      private MyRenderer mRenderer;\n      private float mPreviousX;\n       private float mPreviousY;\n       private final float TOUCH_SCALE_FACTOR = 180.0f / 320;\n      public MySurfaceView(Context context) {\n        super(context);\n        mRenderer = new MyRenderer();\n        this.setRenderer(mRenderer);\n        //control whether continuously drawing or on-demand\n        this.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n      }\n\n      public boolean onTouchEvent(final MotionEvent event) {\n        float x = event.getX();\n           float y = event.getY();\n           switch (event.getAction()) {\n           case MotionEvent.ACTION_MOVE:\n               float dx = x - mPreviousX;\n               float dy = y - mPreviousY;\n               mRenderer.mAngleX += dx * TOUCH_SCALE_FACTOR;\n               mRenderer.mAngleY += dy * TOUCH_SCALE_FACTOR;\n               requestRender();\n           }\n           mPreviousX = x;\n           mPreviousY = y;\n           return true;\n       }\n    }\n    ```", "```kt\n    public class MyRenderer implements GLSurfaceView.Renderer{\n       public float mAngleX;\n       public float mAngleY;\n      @Override\n      public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n        naInitGL1x();\n      }\n      @Override\n      public void onDrawFrame(GL10 gl) {\n        naDrawGraphics(mAngleX, mAngleY);\n      }\n      @Override\n      public void onSurfaceChanged(GL10 gl, int width, int height) {\n        naSurfaceChanged(width, height);\n      }\n    }\n    ```", "```kt\n    void naInitGL1x(JNIEnv* env, jclass clazz) {\n      glDisable(GL_DITHER);\n      glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);    glEnable(GL_CULL_FACE);    \n      glClearDepthf(1.0f);  glEnable(GL_DEPTH_TEST);  \n      glDepthFunc(GL_LEQUAL);    //type of depth test\n      glShadeModel(GL_SMOOTH);    \n      glLightModelx(GL_LIGHT_MODEL_TWO_SIDE, 0);\n      float globalAmbientLight[4] = {0.5, 0.5, 0.5, 1.0};\n      glLightModelfv(GL_LIGHT_MODEL_AMBIENT, globalAmbientLight);\n      GLfloat lightOneDiffuseLight[4] = {1.0, 1.0, 1.0, 1.0};\n      GLfloat lightOneSpecularLight[4] = {1.0, 1.0, 1.0, 1.0};\n      glLightfv(GL_LIGHT0, GL_DIFFUSE, lightOneDiffuseLight);\n      glLightfv(GL_LIGHT0, GL_SPECULAR, lightOneSpecularLight);\n      glEnable(GL_LIGHTING);\n      glEnable(GL_LIGHT0);\n    }\n    void naSurfaceChanged(JNIEnv* env, jclass clazz, int width, int height) {\n      glViewport(0, 0, width, height);\n       float ratio = (float) width / height;\n       glMatrixMode(GL_PROJECTION);\n       glLoadIdentity();\n       glOrthof(-ratio, ratio, -1, 1, -10, 10);\n    }\n    void naDrawGraphics(JNIEnv* env, jclass clazz, float pAngleX, float pAngleY) {\n      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n       glMatrixMode(GL_MODELVIEW);\n       glLoadIdentity();\n       glRotatef(pAngleX, 0, 1, 0);  //rotate around y-axis\n       glRotatef(pAngleY, 1, 0, 0);  //rotate around x-axis\n      glScalef(0.3f, 0.3f, 0.3f);      // Scale down\n    mCube.lighting();\n      mCube.draw();\n      float lightOnePosition[4] = {0.0, 0.0, 1.0, 0.0};  \n      glLightfv(GL_LIGHT0, GL_POSITION, lightOnePosition);\n    }\n    ```", "```kt\n    void Cube::draw() {\n      glEnableClientState(GL_VERTEX_ARRAY);\n      glVertexPointer(3, GL_FLOAT, 0, vertices);\n      glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_BYTE, indices);\n      glDisableClientState(GL_VERTEX_ARRAY);\n    }\n    void Cube::lighting() {\n      GLfloat cubeOneAmbientFraction[4] = {0.0, 0.5, 0.5, 1.0};\n      GLfloat cubeOneDiffuseFraction[4] = {0.8, 0.0, 0.0, 1.0};\n      GLfloat cubeSpecularFraction[4] = {0.0, 0.0, 0.0, 1.0};\n      GLfloat cubeEmissionFraction[4] = {0.0, 0.0, 0.0, 1.0};\n      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, cubeOneAmbientFraction);\n      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, cubeOneDiffuseFraction);\n      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, cubeSpecularFraction);\n      glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, cubeEmissionFraction);\n      glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 60.0);\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := CubeG1\n    LOCAL_SRC_FILES := Cube.cpp CubeG1.cpp\n    LOCAL_LDLIBS := -lGLESv1_CM -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    float lightOnePosition[4] = {0.0, 0.0, 1.0, 0.0};  \n    glLightfv(GL_LIGHT0, GL_POSITION, lightOnePosition);\n    ```", "```kt\n    glEnable(GL_LIGHTING);\n    ```", "```kt\n    glEnable(GL_LIGHTx);\n    ```", "```kt\n    public class MyRenderer implements GLSurfaceView.Renderer{\n       public float mAngleX;\n       public float mAngleY;\n       private Context mContext;\n       public MyRenderer(Context pContext) {\n         super();\n         mContext = pContext;\n       }\n      @Override\n      public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n        //call native methods to load the textures\n        LoadTexture(R.drawable.dice41, mContext, 0);\n        LoadTexture(R.drawable.dice42, mContext, 1);\n        LoadTexture(R.drawable.dice43, mContext, 2);\n        LoadTexture(R.drawable.dice44, mContext, 3);\n        LoadTexture(R.drawable.dice45, mContext, 4);\n        LoadTexture(R.drawable.dice46, mContext, 5);\n        naInitGL1x();\n      }\n    … …\n      private void LoadTexture(int resId, Context context, int texIdx) {\n        //Get the texture from the Android resource directory\n        InputStream is = context.getResources().openRawResource(resId);\n        Bitmap bitmap = null;\n        try {\n          BitmapFactory.Options options = new BitmapFactory.Options();\n          options.inPreferredConfig = Bitmap.Config.ARGB_8888;\n          bitmap = BitmapFactory.decodeStream(is, null, options);\n          naLoadTexture(bitmap, bitmap.getWidth(), bitmap.getHeight(), texIdx);\n        } finally {\n          try {\n            is.close();\n            is = null;\n          } catch (IOException e) {\n          }\n        }\n        if (null != bitmap) {\n          bitmap.recycle();\n        }\n      }\n    }\n    ```", "```kt\n    void naLoadTexture(JNIEnv* env, jclass clazz, jobject pBitmap, int pWidth, int pHeight, int pId) {\n      int lRet;\n      AndroidBitmapInfo lInfo;\n      void* l_Bitmap;\n      GLint format;\n      GLenum type;\n      if ((lRet = AndroidBitmap_getInfo(env, pBitmap, &lInfo)) < 0) {\n        return;\n      }\n      if (lInfo.format == ANDROID_BITMAP_FORMAT_RGB_565) {\n        format = GL_RGB;\n        type = GL_UNSIGNED_SHORT_5_6_5;\n      } else if (lInfo.format == ANDROID_BITMAP_FORMAT_RGBA_8888) {\n        format = GL_RGBA;\n        type = GL_UNSIGNED_BYTE;\n      } else {\n        return;\n      }\n      if ((lRet = AndroidBitmap_lockPixels(env, pBitmap, &l_Bitmap)) < 0) {\n        return;\n      }\n      glGenTextures(1, &texIds[pId]);\n      glBindTexture(GL_TEXTURE_2D, texIds[pId]);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n      glTexImage2D(GL_TEXTURE_2D, 0, format, pWidth, pHeight, 0, format, type, l_Bitmap);\n      AndroidBitmap_unlockPixels(env, pBitmap);\n    }\n    void naInitGL1x(JNIEnv* env, jclass clazz) {\n      glDisable(GL_DITHER);  \n      glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);  \n      glEnable(GL_CULL_FACE);    \n      glClearDepthf(1.0f);  \n      glEnable(GL_DEPTH_TEST);  \n      glDepthFunc(GL_LEQUAL);    \n      glShadeModel(GL_SMOOTH);   \n      mCube.setTexCoords(texIds);\n      glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n      glEnable(GL_TEXTURE_2D);\n    }\n    Cube.cpp: drawing the cube and mapping texture\n    void Cube::draw() {\n      glEnableClientState(GL_VERTEX_ARRAY);\n      glEnableClientState(GL_TEXTURE_COORD_ARRAY);  // Enable texture-coords-array\n      glFrontFace(GL_CW);\n\n      glBindTexture(GL_TEXTURE_2D, texIds[0]);\n      glTexCoordPointer(2, GL_FLOAT, 0, texCoords);\n      glVertexPointer(3, GL_FLOAT, 0, vertices);\n      glDrawElements(GL_TRIANGLES, 18, GL_UNSIGNED_BYTE, indices);\n\n    ….\n      glDisableClientState(GL_VERTEX_ARRAY);\n      glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := DiceG1\n    LOCAL_SRC_FILES := Cube.cpp DiceG1.cpp\n    LOCAL_LDLIBS := -lGLESv1_CM -llog -ljnigraphics\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    @Override\n    public void onSurfaceCreated(GL10 gl, EGLConfig config) {\n        String vertexShaderStr = LoadShaderStr(mContext, R.raw.vshader);\n        String fragmentShaderStr = LoadShaderStr(mContext, R.raw.fshader);\n        naInitGL20(vertexShaderStr, fragmentShaderStr);\n    }\n    @Override\n    public void onDrawFrame(GL10 gl) {\n      naDrawGraphics(mAngleX, mAngleY);\n    }\n    @Override\n    public void onSurfaceChanged(GL10 gl, int width, int height) {\n      naSurfaceChanged(width, height);\n    }\n    ```", "```kt\n    …\n    void Cube::draw(GLuint pvPositionHandle) {\n      glVertexAttribPointer(pvPositionHandle, 3, GL_FLOAT, GL_FALSE, 0, vertices);\n      glEnableVertexAttribArray(pvPositionHandle);\n      glDrawArrays(GL_TRIANGLES, 0, 36);\n    }\n    ...\n    ```", "```kt\n        GLuint loadShader(GLenum shaderType, const char* pSource) {\n           GLuint shader = glCreateShader(shaderType);\n           if (shader) {\n               glShaderSource(shader, 1, &pSource, NULL);\n               glCompileShader(shader);\n               GLint compiled = 0;\n               glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n               if (!compiled) {\n                   GLint infoLen = 0;\n                   glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n                   if (infoLen) {\n                       char* buf = (char*) malloc(infoLen);\n                       if (buf) {\n                           glGetShaderInfoLog(shader, infoLen, NULL, buf);\n                           free(buf);\n                       }\n                       glDeleteShader(shader);\n                       shader = 0;\n                   }\n               }\n           }\n           return shader;\n        }\n        ```", "```kt\n        GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {\n           GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);\n           GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);\n           GLuint program = glCreateProgram();\n           if (program) {\n               glAttachShader(program, vertexShader);\n               glAttachShader(program, pixelShader);\n               glLinkProgram(program);\n           }\n           return program;\n        }\n        ```", "```kt\n        void naInitGL20(JNIEnv* env, jclass clazz, jstring vertexShaderStr, jstring fragmentShaderStr) {\n          glDisable(GL_DITHER);  \n          glClearColor(0.0f, 0.0f, 0.0f, 1.0f);  \n        glClearDepthf(1.0f);  \n          glEnable(GL_DEPTH_TEST);  \n          glDepthFunc(GL_LEQUAL);    \n            const char *vertexStr, *fragmentStr;\n          vertexStr = env->GetStringUTFChars(vertexShaderStr, NULL);\n          fragmentStr = env->GetStringUTFChars(fragmentShaderStr, NULL);\n          setupShaders(vertexStr, fragmentStr);\n          env->ReleaseStringUTFChars(vertexShaderStr, vertexStr);\n          env->ReleaseStringUTFChars(fragmentShaderStr, fragmentStr);\n          gvPositionHandle = glGetAttribLocation(gProgram, \"vPosition\");\n          gmvP = glGetUniformLocation(gProgram, \"mvp\");\n\n        }\n        ```", "```kt\n        void naDrawGraphics(JNIEnv* env, jclass clazz, float pAngleX, float pAngleY) {\n          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n          glClearColor(0.0, 0.0, 0.0, 1.0f);\n          glUseProgram(gProgram);\n        //  GL1x: glRotatef(pAngleX, 0, 1, 0);  //rotate around y-axis\n        //  GL1x: glRotatef(pAngleY, 1, 0, 0);  //rotate around x-axis\n          //rotate\n          rotate_matrix(pAngleX, 0.0, 1.0, 0.0, aRotate);\n          rotate_matrix(pAngleY, 1.0, 0.0, 0.0, aModelView);\n          multiply_matrix(aRotate, aModelView, aModelView);\n        //  GL1x: glScalef(0.3f, 0.3f, 0.3f);      // Scale down\n          scale_matrix(0.5, 0.5, 0.5, aScale);\n          multiply_matrix(aScale, aModelView, aModelView);\n        // GL1x: glTranslate(0.0f, 0.0f, -3.5f);\n          translate_matrix(0.0f, 0.0f, -3.5f, aTranslate);\n          multiply_matrix(aTranslate, aModelView, aModelView);\n        //  gluPerspective(45, aspect, 0.1, 100);\n          perspective_matrix(45.0, (float)gWidth/(float)gHeight, 0.1, 100.0, aPerspective);\n          multiply_matrix(aPerspective, aModelView, aMVP);\n          glUniformMatrix4fv(gmvP, 1, GL_FALSE, aMVP);\n          mCube.draw(gvPositionHandle);\n        }\n        ```", "```kt\n        attribute vec4 vPosition;\n        uniform mat4 mvp;\n        void main() \n        {\n           gl_Position = mvp * vPosition;\n        }\n        ```", "```kt\n        void main()\n        {\n           gl_FragColor = vec4(0.0,0.5,0.0,1.0);\n        }\n        ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := CubeG2\n    LOCAL_SRC_FILES := matrix.cpp Cube.cpp CubeG2.cpp\n    LOCAL_LDLIBS := -lGLESv2 -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    <uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" />\n    ```", "```kt\n    … …\n    public void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    myView = new MySurfaceView(this);\n    this.setContentView(myView);\n    }\n    protected void onResume() {\n    super.onResume();\n    myView.startRenderer();\n    }\n    … …\n    protected void onStop() {\n    super.onStop();\n    myView.destroyRender();\n    }\n    … …\n    ```", "```kt\n    public class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback {\n    … …\n    public MySurfaceView(Context context) {\n    super(context);\n    this.getHolder().addCallback(this);\n    }\n    … …\n    public boolean onTouchEvent(final MotionEvent event) {\n    float x = event.getX();\n    float y = event.getY();\n    switch (event.getAction()) {\n    case MotionEvent.ACTION_MOVE:\n        float dx = x - mPreviousX;\n        float dy = y - mPreviousY;\n        mAngleX += dx * TOUCH_SCALE_FACTOR;\n        mAngleY += dy * TOUCH_SCALE_FACTOR;\n        naRequestRenderer(mAngleX, mAngleY);\n    }\n    mPreviousX = x;\n    mPreviousY = y;\n    return true;\n    }\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width,int height) {\n    naSurfaceChanged(holder.getSurface());\n    }\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {}\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n    naSurfaceDestroyed();\n    }\n    }\n    ```", "```kt\n        void Renderer::renderAFrame(float pAngleX, float pAngleY) {\n        pthread_mutex_lock(&mMutex);\n        mAngleX = pAngleX; mAngleY = pAngleY;\n        mRendererEvent = RTE_DRAW_FRAME;\n        pthread_mutex_unlock(&mMutex);\n        pthread_cond_signal(&mCondVar); \n        }\n        ```", "```kt\n        void Renderer::renderThreadRun() {\n            bool ifRendering = true;\n            while (ifRendering) {\n                pthread_mutex_lock(&mMutex);\n                pthread_cond_wait(&mCondVar, &mMutex);\n                switch (mRendererEvent) {\n                … …\n                    case RTE_DRAW_FRAME:\n                        mRendererEvent = RTE_NONE;\n                        pthread_mutex_unlock(&mMutex);\n                        if (EGL_NO_DISPLAY!=mDisplay) {\n                    naDrawGraphics(mAngleX, mAngleY);\n                    eglSwapBuffers(mDisplay, mSurface);\n                    }\n                        }\n                        break;\n                    ……\n                }\n        }\n        }\n        ```", "```kt\n        bool Renderer::initDisplay() {\n        const EGLint attribs[] = {\n            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n            EGL_BLUE_SIZE, 8,\n            EGL_GREEN_SIZE, 8,\n            EGL_RED_SIZE, 8,\n            EGL_NONE};\n        EGLint width, height, format;\n        EGLint numConfigs;\n        EGLConfig config;\n        EGLSurface surface;\n        EGLContext context;\n        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n        eglInitialize(display, 0, 0);\n        eglChooseConfig(display, attribs, &config, 1, &numConfigs);\n        eglGetConfigAttrib(display, config, EGL_NATIVE_VISUAL_ID, &format);\n        ANativeWindow_setBuffersGeometry(mWindow, 0, 0, format);\n        surface = eglCreateWindowSurface(display, config, mWindow, NULL);\n        context = eglCreateContext(display, config, NULL, NULL);\n        if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE) {\n            return -1;\n        }\n        eglQuerySurface(display, surface, EGL_WIDTH, &width);\n        eglQuerySurface(display, surface, EGL_HEIGHT, &height);\n          … ...\n        }\n        ```", "```kt\n        void naSurfaceChanged(JNIEnv* env, jclass clazz, jobject pSurface) {\n        gWindow = ANativeWindow_fromSurface(env, pSurface);\n        gRenderer->initEGLAndOpenGL1x(gWindow);\n        }\n        ```", "```kt\n        void naRequestRenderer(JNIEnv* env, jclass clazz, float pAngleX, float pAngleY) {\n        gRenderer->renderAFrame(pAngleX, pAngleY);\n        }\n        ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE := EGLDemo\n    LOCAL_SRC_FILES := Cube.cpp OldRenderMethods.cpp Renderer.cpp EGLDemo.cpp\n    LOCAL_LDLIBS := -llog -landroid -lEGL -lGLESv1_CM\n    include $(BUILD_SHARED_LIBRARY)\n    ```"]