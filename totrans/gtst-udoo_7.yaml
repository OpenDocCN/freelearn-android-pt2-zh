- en: Chapter 7. Using Android APIs for Human Interaction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用Android API进行人机交互
- en: 'The advent of personal computers in the 1980s started a new challenge: making
    computers and computation useful for and usable by hobbyists, students, and, in
    more general terms, technology enthusiasts. These people needed an easy way to
    control their machines, so human and computer interaction quickly became an open
    research field aimed at improving usability and resulting in the development of
    graphical user interfaces and new input devices. In the last decade, other interaction
    patterns such as voice recognition, voice synthesis, motion tracking, and many
    others were used in commercial applications, a great improvement that indirectly
    caused the evolution of objects such as phones, tablets, and glasses into a new
    kind of smarter devices.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪80年代个人电脑的出现开启了一个新的挑战：让电脑和计算对业余爱好者、学生以及更广泛的技术爱好者有用和可用。这些人需要一个简单的方法来控制他们的机器，因此人机交互迅速成为一个开放的研究领域，旨在提高可用性，并导致了图形用户界面和新型输入设备的发展。在过去的十年中，诸如语音识别、语音合成、动作追踪等其他的交互模式在商业应用中被使用，这一巨大改进间接导致了电话、平板和眼镜等物体向新型智能设备的演变。
- en: The goal of this chapter is to take advantage of these new interaction patterns
    using a subset of Android APIs enhancing the Chronotherm prototype with a new
    set of features, thus making it a little bit smarter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是利用这些新的交互模式，使用Android API的一个子集来增强Chronotherm原型，增加一组新功能，使其变得更加智能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Extending prototypes with Android APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Android API扩展原型
- en: Using voice recognition to control our prototype
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语音识别来控制我们的原型
- en: Giving feedback to users through voice synthesis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过语音合成向用户提供反馈
- en: Extending prototypes with Android APIs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Android API扩展原型
- en: The Chronotherm application is designed to turn on a boiler when the detected
    temperature exceeds the user's temperature setpoint. In the previous prototype,
    we created a settings page in which users can set their preferences for each hour
    of the day. We can extend the prototype behavior, giving our users the ability
    to store more than one setpoint configuration. In this way, we could provide preset
    management that users can activate according to different factors such as the
    day of the week or the current season.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Chronotherm应用程序旨在当检测到的温度超过用户的温度设定点时启动锅炉。在之前的原型中，我们创建了一个设置页面，用户可以设置他们每天每个小时的偏好。我们可以扩展原型的行为，让用户能够存储不止一个设定点配置。这样，我们可以提供预设管理，用户可以根据不同的因素，如星期几或当前季节来激活。
- en: While adding this feature, we have to bear in mind that this isn't a desktop
    application, so we should avoid the creation of a new bunch of overwhelming user
    interfaces. The Chronotherm application could be deployed in the users home and,
    because they are usually noiseless places, we can take into consideration the
    use of **voice recognition** to get the users input. This approach will remove
    the need for other activities to create or edit stored presets. In the meantime,
    we have to take into account that we need to provide feedback when the voice recognition
    process ends so that users know whether their command was accepted or not. Even
    if we can solve this problem using small popups or notifications, we can provide
    a better user experience using **voice synthesis** to give feedback to our users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此功能时，我们必须牢记这并不是一个桌面应用程序，因此我们应避免创建一组新的令人眼花缭乱的界面。Chronotherm应用程序可以部署在用户的家中，由于这些地方通常很安静，我们可以考虑使用**语音识别**来获取用户的输入。这种方法将消除创建或编辑存储预设的其他活动的需要。同时，我们必须考虑到在语音识别过程结束时我们需要提供反馈，以便用户知道他们的命令是否被接受。即使我们可以使用小弹窗或通知来解决此问题，但使用**语音合成**来向用户提供反馈可以带来更好的用户体验。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Voice recognition and synthesis are features that we can use to give a new kind
    of interaction to our applications. However, we have to bear in mind that these
    components could create serious accessibility issues for people with visual, physical,
    or hearing loss limitations. Every time we want to create a good project, we have
    to work really hard to make beautiful applications that can be used by everyone.
    Android helps us a lot with the **accessibility framework**, so, for future projects,
    remember to follow all best practices available at [https://developer.android.com/guide/topics/ui/accessibility/index.html](https://developer.android.com/guide/topics/ui/accessibility/index.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别和合成是可以用来为我们的应用程序提供新型交互的功能。然而，我们必须牢记，这些组件可能会为视障、身体障碍或听障人士带来严重的可访问性问题。每次我们想要创建一个好的项目时，都必须努力工作，以制作出既美观又可供每个人使用的应用程序。安卓通过**可访问性框架**为我们提供了很大帮助，因此，在未来的项目中，请记得遵循[https://developer.android.com/guide/topics/ui/accessibility/index.html](https://developer.android.com/guide/topics/ui/accessibility/index.html)上提供的所有最佳实践。
- en: The Android SDK exposes a set of APIs that we can use to interact with the installed
    text-to-speech service and voice input methods, but **Vanilla Android** shipped
    in UDOO does not provide them out of the box. For our code to work, we need to
    install an application for voice recognition and another one implementing text-to-speech
    functionalities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓SDK提供了一系列API，我们可以用它们与安装的文字转语音服务和语音输入法进行交互，但是UDOOU盘自带的**原生安卓**并没有直接提供这些功能。为了让我们的代码工作，我们需要安装一个用于语音识别的应用程序，以及另一个实现文字转语音功能的应用。
- en: For example, almost any Android device on the market comes with such applications
    already installed as part of the **Google Mobile Services** suite. For more details
    on this topic, follow the link [http://www.udoo.org/guide-how-to-install-gapps-on-udoo-running-android/](http://www.udoo.org/guide-how-to-install-gapps-on-udoo-running-android/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，市场上几乎任何安卓设备都预装了作为**谷歌移动服务**套件一部分的这类应用程序。有关此主题的更多详细信息，请点击链接[http://www.udoo.org/guide-how-to-install-gapps-on-udoo-running-android/](http://www.udoo.org/guide-how-to-install-gapps-on-udoo-running-android/)。
- en: Improving user settings
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进用户设置
- en: Before we proceed with our implementation of the voice recognition service,
    we need to change how settings are stored in our physical application. At the
    moment, we're using the Chronotherm application's shared preferences in which
    we store the chosen setpoint for each `SeekBar` class. According to new requirements,
    this is no longer suitable for our application because we need to persist different
    setpoints for each preset. Moreover, we need to persist the current activated
    preset and all these changes force us to design a new user interface together
    with a new settings system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实现语音识别服务之前，需要改变物理应用程序中设置存储的方式。目前，我们正在使用Chronotherm应用程序的共享偏好设置，我们在其中存储每个`SeekBar`类选择的设定点。根据新要求，这不再适合我们的应用程序，因为我们需要为每个预设持久化不同的设定点。此外，我们需要持久化当前激活的预设，所有这些变化都迫使我们设计一个新的用户界面以及一个新的设置系统。
- en: 'We can take a look at the following screenshot to find what changes we should
    take:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下截图来看看需要做出哪些改变：
- en: '![Improving user settings](img/1942OS_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![改进用户设置](img/1942OS_07_01.jpg)'
- en: 'The first required step is to update our user interface. Following the suggestion
    in the above mock-up, we should:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新我们的用户界面。根据上述草图的建议，我们应该：
- en: Add a new `TextView` at the top of the layout that shows the name of the current
    preset. The name should be changed while loading the activity and whenever the
    user activates a new preset.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局顶部添加一个新的`TextView`，显示当前预设的名称。在加载活动时以及用户激活新预设时，应更改名称。
- en: 'To achieve the preceding layout, update the `activity_overview.xml` file under
    `res/layout/` with the following changes inside the header `LinearLayout` where
    the `TextClock` and the `boiler_status` views are located:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述布局，更新`res/layout/`目录下的`activity_overview.xml`文件，在包含`TextClock`和`boiler_status`视图的头部`LinearLayout`中进行以下更改：
- en: 'Change the `TextClock` view, replacing the `layout_width` attribute with the
    highlighted code and adding the `layout_weight` attribute:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`TextClock`视图，用高亮代码替换`layout_width`属性，并添加`layout_weight`属性：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Change the layout of the `boiler_status` `TextView` as we did in the previous
    step:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照上一步的操作，更改`boiler_status` `TextView`的布局：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following `TextView` between the preceding components to show the activated
    preset:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个组件之间添加以下`TextView`以显示激活的预设：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the top of the `Overview` class, add the reference for the `current_preset`
    view with the highlighted code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Overview` 类的顶部，使用高亮代码添加 `current_preset` 视图的引用：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `Overview` `onCreate` callback, get the view reference with the following
    code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Overview` 的 `onCreate` 回调中，使用以下代码获取视图引用：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot is what we obtain through the preceding layout:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是通过前面的布局获得的：
- en: '![Improving user settings](img/1942OS_07_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![改善用户设置](img/1942OS_07_02.jpg)'
- en: Storing preset configurations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储预设配置
- en: 'As previously discussed, we should change how user setpoints are stored and
    retrieved within the Chronotherm application. The idea is to isolate access to
    the application''s shared preferences in a new `Preset` class that exposes the
    following methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如先前讨论的，我们应该改变 Chronotherm 应用程序中用户设置点的存储和检索方式。想法是将对应用程序共享首选项的访问隔离在一个新的 `Preset`
    类中，该类公开以下方法：
- en: A `set()` method to save a setpoint configuration corresponding to a preset
    name. The array of setpoint values is serialized in a comma-separated string and
    saved using the preset name as the key.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `set()` 方法，用于保存与预设名称对应的设置点配置。设置点值数组被序列化为逗号分隔的字符串，并使用预设名称作为键进行保存。
- en: A `get()` method to return stored setpoints for the given preset name. The setpoint
    string is deserialized and returned as an array of values.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `get()` 方法，用于返回给定预设名称的存储设置点。设置点字符串被反序列化并作为值数组返回。
- en: A `getCurrent()` method to return the name of the latest activated preset.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `getCurrent()` 方法，用于返回最新激活预设的名称。
- en: A `setCurrent()` method to promote the given preset name as the latest activated
    preset.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `setCurrent()` 方法，用于将给定的预设名称提升为最新激活的预设。
- en: 'To create the `Preset` class, proceed with the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `Preset` 类，请按照以下步骤操作：
- en: Create the `Preset` class in the `chronotherm` package.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chronotherm` 包中创建 `Preset` 类。
- en: 'Add the following declarations at the top of the `Preset` class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Preset` 类的顶部添加以下声明：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We put the preferences name we used in the previous chapter in a variable called
    `SHARED_PREF`. The `CURRENT_PRESET` key is used to get or set the currently used
    preset. The `NO_PRESET` assignment defines the value that is returned by default
    when no presets are found. This handles the first application run case showing
    the **NO PRESET ACTIVATED** screen when no preset is found.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将前一章中使用的偏好设置名称放在一个名为 `SHARED_PREF` 的变量中。`CURRENT_PRESET` 键用于获取或设置当前使用的预设。`NO_PRESET`
    赋值定义了在没有找到预设时返回的默认值。这处理了首次运行应用程序的情况，在没有找到预设时显示 **NO PRESET ACTIVATED** 屏幕。
- en: 'Add the `set()` method at the bottom of the `Preset` class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Preset` 类的底部添加 `set()` 方法：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding method expects the `values` array that represents the user's setpoints
    for the given preset `name` variable. We use the `TextUtils` class to serialize
    the values array in a comma-separated string while using the preset `name` variable
    as the key.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的方法期望 `values` 数组，该数组表示给定预设 `name` 变量的用户设置点。我们使用 `TextUtils` 类将值数组序列化为逗号分隔的字符串，同时使用预设
    `name` 变量作为键。
- en: 'Add the `get()` method at the bottom of the `Preset` class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Preset` 类的底部添加 `get()` 方法：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We fill the `values` array with the setpoints retrieved through the preset `name`
    variable. We know the values are comma-serialized, so we split and parse the string,
    adding each value to the preceding array. If we do not find any match with the
    given preset `name` variable, we return an empty array.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们用预设的 `name` 变量获取到的设置点填充 `values` 数组。我们知道这些值是以逗号分隔的序列化字符串，因此我们将其拆分并解析，将每个值添加到前面的数组中。如果我们没有找到与给定预设
    `name` 变量相匹配的内容，我们将返回一个空数组。
- en: 'Add the `getCurrent()` method at the bottom of the class to return the currently
    activated preset:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部添加 `getCurrent()` 方法，以返回当前激活的预设：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `setCurrent()` method at the bottom of the class to store the currently
    activated preset:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部添加 `setCurrent()` 方法，以存储当前激活的预设：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have a formal representation of the user's presets, we should adapt
    both the activities to reflect the latest changes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了用户预设的正式表示，我们应该调整这两个活动以反映最新的变化。
- en: Using presets among activities
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在活动间使用预设
- en: 'We begin with the `Overview` activity that should load the current preset during
    the activity''s resuming phase. If a preset is activated, we should change the
    `current_preset` `TextView` with the preset name. To achieve this step, we should
    replace the `readPreferences` method with the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`概览`活动开始，该活动应在活动恢复阶段加载当前预设。如果激活了预设，我们应该将`current_preset` `TextView`更改为预设名称。为实现此步骤，我们应该用以下代码替换`readPreferences`方法：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to adapt the `Settings` activity with a new behavior, summarized
    in the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使`设置`活动适应以下步骤总结的新行为：
- en: When users open the `Settings` activity, the voice recognition system should
    ask for preset name.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户打开`设置`活动时，语音识别系统应该请求预设名称。
- en: If the given preset is found, we should load the preset's setpoints and update
    all temperature bars. When users save the new preferences, the old setpoints are
    updated.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到给定的预设，我们应该加载预设的设定点，并更新所有温度条。当用户保存新偏好时，旧的设定点将被更新。
- en: If the given preset is not found, there is no need to update the temperature
    bars. When users save the new preferences, a new preset entry is stored with the
    given setpoints.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到给定的预设，则无需更新温度条。当用户保存新偏好时，将使用给定的设定点存储新的预设条目。
- en: 'We still don''t have all the components needed to implement the first step
    because we''re missing the voice recognition implementation. In the meantime,
    we can update how presets are stored and retrieved in this activity through the
    following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有实现第一步所需的所有组件，因为我们缺少语音识别实现。与此同时，我们可以通过以下步骤更新此活动中的预设存储和检索方式：
- en: 'At the top of the class, add the highlighted variable that will store the recognized
    preset name:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，添加突出显示的变量，该变量将存储识别的预设名称：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `onCreate()` callback of the `Settings` activity, remove the `readPreferences()`
    method's call.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`设置`活动的`onCreate()`回调中，移除`readPreferences()`方法的调用。
- en: 'Update the `readPreferences()` member function so it loads values for the given
    preset name (when available) and returns values denoting whether this preset is
    found or not. We can implement this behavior with the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`readPreferences()`成员函数，使其加载给定预设名称（如果可用）的值，并返回表示是否找到此预设的值。我们可以通过以下代码实现此行为：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the `savePreferences()` method so it uses the `Preset` class to store
    or update the given setpoints:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`savePreferences()`方法，使其使用`Preset`类来存储或更新给定的设定点：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Through these steps, we have changed preset management in both activities. We
    still need to complete the `Settings` activity because we're missing the recognition
    phase. We will complete these steps later, after the implementation of voice recognition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们在两个活动中都改变了预设管理。我们仍然需要完成`设置`活动，因为我们缺少识别阶段。我们将在实现语音识别后，稍后完成这些步骤。
- en: 'The last, missing step in adapting the Chronotherm application to the new preset
    management is to change the temperature check in the `SensorThread` parameter.
    Indeed, the `isBelowSetpoint` method should retrieve the values of the activated
    preset matching this setpoint with the last temperature reading. If any preset
    is selected, it should turn off the boiler by default. We could achieve this behavior
    by changing the `isBelowSetpoint` method with the highlighted code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Chronotherm应用程序适应新的预设管理的最后一步，是更改`SensorThread`参数中的温度检查。实际上，`isBelowSetpoint`方法应该检索与最后温度读数匹配的激活预设的此设定点的值。如果选择了任何预设，它应该默认关闭锅炉。我们可以通过用突出显示的代码更改`isBelowSetpoint`方法来实现此行为：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This ends the `Preset` configuration process and now we can proceed with implementing
    voice recognition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了`预设`配置过程，现在我们可以继续实现语音识别。
- en: Implementing voice recognition
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现语音识别
- en: Now that our prototype can handle different presets, we should provide a fast
    way to change, create, or edit user presets through voice recognition. One of
    the easiest ways to manage voice recognition is to use Android's `Intent` messaging
    object to delegate this action to another application component. As we discussed
    at the beginning of the chapter, if we install and configure a compliant voice
    input application, Android can use it for voice recognition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的原型可以处理不同的预设，我们应该提供一种快速的方法，通过语音识别来更改、创建或编辑用户预设。管理语音识别的最简单方法之一是使用Android的`Intent`消息对象，将此操作委托给另一个应用程序组件。正如我们在本章开头所讨论的，如果我们安装并配置了一个符合要求的语音输入应用程序，Android可以使用它进行语音识别。
- en: 'The main goal is to provide an abstract class that will be extended by our
    activities in order to manage recognition callback, while avoiding code repetition.
    The overall design is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是提供一个抽象类，供我们的活动扩展以管理识别回调，同时避免代码重复。整体设计如下：
- en: We should provide a common interface for activities that need voice recognition.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为需要语音识别的活动提供一个通用接口。
- en: We should provide a `startRecognition()` method to launch the recognition activity
    through the `Intent` object.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该提供一个`startRecognition()`方法，通过`Intent`对象启动识别活动。
- en: We should implement the `onActivityResult()` callback that will be called by
    the launched activity when voice recognition ends. In this callback, we use the
    best among all the results produced during the voice recognition process.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该实现`onActivityResult()`回调，当启动的活动完成语音识别时将调用此回调。在这个回调中，我们使用在语音识别过程中产生的所有结果中最好的一个。
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Job delegation is one of the most useful features of the Android operating system.
    If you need more information about how it works under the hood, take a look at
    the Android official documentation at [http://developer.android.com/guide/components/intents-filters.html](http://developer.android.com/guide/components/intents-filters.html).
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作业委托是Android操作系统最有用的功能之一。如果你需要更多信息了解它的工作原理，请查看Android官方文档 [http://developer.android.com/guide/components/intents-filters.html](http://developer.android.com/guide/components/intents-filters.html)。
- en: 'The preceding abstraction to reuse voice recognition capability can be achieved
    with the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可以实现重用语音识别能力的先前抽象：
- en: 'Add in the `IRecognitionListener` interface in the `chronotherm` package that
    defines the `onRecognitionDone()` callback used to send back the result to the
    caller activity. We can achieve this with the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chronotherm`包中添加`IRecognitionListener`接口，定义`onRecognitionDone()`回调，用于将结果发送回调用活动。我们可以通过以下代码实现这一点：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a new package called `voice` and add a new abstract class called `RecognizerActivity`.
    This class should be defined as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`voice`的新包，并添加一个名为`RecognizerActivity`的新抽象类。该类应定义如下：
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a public method to initialize the recognition phase, delegating the responsibility
    for retrieving the results, with the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共方法来初始化识别阶段，并将获取结果的责任委托给以下代码：
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `requestCode` parameter is the recognition `Intent` identifier and is used
    by the caller activity to properly identify the result and how to handle it. The
    `what` parameter is used to provide an on-screen message if the external application
    supports it.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`requestCode`参数是识别`Intent`的标识符，由调用活动使用以正确识别结果以及如何处理它。`what`参数用于提供屏幕消息，如果外部应用程序支持的话。'
- en: 'Add the `onActivityResult()` callback to extract the best result and pass it
    to the caller activity through the common interface:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`onActivityResult()`回调以提取最佳结果，并通过通用接口将其传递给调用活动：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using voice recognition to add or edit presets
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用语音识别添加或编辑预设
- en: 'Through the `RecognizerActivity` class, we delegate the hard work to the Android
    framework. According to the nature of the activity, we should handle results in
    different ways. We start using voice inputs with the `Settings` activity asking
    the name of the preset we want to create or edit during the activity creation
    phase. If the preset exists, we should load stored setpoints and update them during
    the save process. Otherwise, we should create a new record in our preferences.
    To achieve this behavior, perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`RecognizerActivity`类，我们将繁重的工作委托给Android框架。根据活动的性质，我们应该以不同的方式处理结果。我们在活动创建阶段使用`Settings`活动开始使用语音输入，询问我们想要创建或编辑的预设名称。如果预设存在，我们应在保存过程中加载存储的设定点并更新它们。否则，我们应在偏好设置中创建新的记录。为了实现这种行为，请执行以下步骤：
- en: 'From the `Settings` class, extend `RecognizerActivity` in line with the following
    snippet:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下代码片段，从`Settings`类扩展`RecognizerActivity`：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare the intent request code that we will use to identify and handle the
    recognized result. At the top of the class, add the highlighted code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明我们将用于识别和处理识别结果的意图请求代码。在类的顶部，添加以下高亮代码：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the bottom of the `onCreate()` callback, add the following code to start
    voice recognition as soon as possible:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`回调的底部，添加以下代码以尽快开始语音识别：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `onRecognitionDone()` callback, required by the `IRecognitionListener`
    interface previously defined, to handle the results returned from the recognition
    intent. At the bottom of the class, add the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onRecognitionDone()`回调，这是之前定义的`IRecognitionListener`接口所要求的，以处理识别意图返回的结果。在类的底部，添加以下代码：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the recognition is related to the `VOICE_SETTINGS` intent code, the `bestMatch`
    argument is passed to the `readPreferences` parameter that loads and sets all
    temperature bars with preset setpoints. The `mEditingPreset` variable is set so
    that we can reuse the preset name during the save process.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果识别与`VOICE_SETTINGS`意图代码相关，则将`bestMatch`参数传递给`readPreferences`参数，该参数加载并设置所有带有预设设定点的温度条。设置`mEditingPreset`变量，以便在保存过程中我们可以重用预设名称。
- en: We have made all required changes for the `Settings` activity and now can proceed
    to use voice recognition in the `Overview` activity to load and set the activated
    preset.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对`Settings`活动做了所有必要的更改，现在可以在`Overview`活动中使用语音识别来加载和设置激活的预设。
- en: Using voice recognition to change active presets
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用语音识别来更改激活的预设
- en: 'Now that users can store different presets, we have to provide a way to change
    activated setpoints in the `Overview` activity. Previously, we added a `TextView`
    class showing the name of the current preset; to keep the interface lean, we could
    use this component also to start voice recognition. The user can change the active
    preset through the current flow:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 既然用户可以存储不同的预设，我们就必须提供一种在`Overview`活动中更改激活的设定点的方法。之前，我们添加了一个显示当前预设名称的`TextView`类；为了保持界面简洁，我们可以使用这个组件来启动语音识别。用户可以通过当前流程更改激活的预设：
- en: When users click on the **TextView** option, the system should start voice recognition
    to get the preset name.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击**TextView**选项时，系统应启动语音识别以获取预设名称。
- en: If the preset is found, the activated preset should be replaced with the one
    chosen by the user and the `Overview` temperature bars should be updated.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了预设，应该用用户选择的预设替换激活的预设，并更新`Overview`的温度条。
- en: If the preset is not found, nothing should happen.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到预设，则不应有任何反应。
- en: 'To achieve the preceding interaction flow, proceed with the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现上述交互流程，请按照以下步骤进行：
- en: 'As we did for the `Settings` activity, extend the `RecognizerActivity` class
    from the `Overview` class, in line with the following snippet:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们对`Settings`活动所做的那样，从`Overview`类扩展`RecognizerActivity`类，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Declare the intent request code that we will use to identify and handle the
    recognized result. At the top of the class, add the highlighted code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明我们将用来识别和处理识别结果的意图请求代码。在类的顶部，添加高亮代码：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At the bottom of the class, add a method to start the preset name recognition:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部，添加一个方法来启动预设名称识别：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the `onRecognitionDone()` callback to handle the results returned
    from the recognition intent. Within this method, we call the `setPreset()` member
    function to update the active preset and load temperature setpoints, if the given
    preset is found. At the bottom of the class, add the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onRecognitionDone()`回调以处理识别意图返回的结果。在这个方法中，我们调用`setPreset()`成员函数来更新激活的预设并加载温度设定点，如果找到了给定的预设。在类的底部，添加以下代码：
- en: '[PRE26]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `setPreset()` method to handle the best recognized result. At
    the bottom of the class, add the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setPreset()`方法来处理最佳识别结果。在类的底部，添加以下代码：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Connect the `changePreset()` method that starts voice recognition with the
    `TextView` component. In the `activity_overview.xml` file under `res/layout/`,
    make the `current_preset` view clickable with the highlighted code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将启动语音识别的`changePreset()`方法与`TextView`组件连接起来。在`res/layout/`下的`activity_overview.xml`文件中，通过高亮代码使`current_preset`视图可点击：
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this last section, we have created an abstraction to handle voice recognition
    through Android intents and we have updated the `Settings` and the `Overview`
    activities to use it. Now we can upload the Chronotherm application and start
    using the application again with presets and voice recognition features.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一节，我们创建了一个抽象层来通过Android意图处理语音识别，并且更新了`Settings`和`Overview`活动以使用它。现在我们可以上传Chronotherm应用程序，并再次使用带有预设和语音识别功能的应用程序。
- en: Improving user interaction with voice synthesis
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进用户与语音合成的交互
- en: 'Even if the Chronotherm application is working correctly, we have at least
    one more thing to do: providing proper feedback to let users know the action that
    was taken. Indeed, both activities fail to provide any visual feedback about what
    the recognized input is; for this reason, we decided to introduce the voice synthesis
    API within the initial design.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Chronotherm应用程序工作正常，我们至少还有一件事要做：提供适当的反馈，让用户知道已采取的行动。实际上，这两个活动都没有提供关于识别输入的任何视觉反馈；因此，我们决定在初始设计中引入语音合成API。
- en: 'Because we want to share the synthesis procedure across different activities,
    we could create a manager that abstracts the synthesis API with a common initialization.
    The idea is to provide a class that exposes the method to start voice recognition
    with the given string; we implement it in the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望在不同的活动中共享合成过程，我们可以创建一个管理器，通过共同的初始化抽象合成API。这个想法是提供一个类，它公开了一个方法，使用给定的字符串开始语音识别；我们按照以下步骤实现它：
- en: Create the `VoiceManager` class inside the `voice` package.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`voice`包内创建`VoiceManager`类。
- en: 'Initialize the class with the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码初始化类：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This class implements the `OnInitListener` interface that defines the callback
    that should be invoked after initializing the `TextToSpeech` engine. We store
    the current `TextToSpeech` instance that we will use in the following snippets
    as a variable.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类实现了`OnInitListener`接口，该接口定义了在初始化`TextToSpeech`引擎后应调用的回调。我们存储当前的`TextToSpeech`实例，我们将在以下代码段中使用它作为一个变量。
- en: 'Override the `onInit()` method so that it sets the US locale if the `TextToSpeech`
    instance service initialization is successful:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onInit()`方法，使其在`TextToSpeech`实例服务初始化成功时设置美国地区：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the class constructor in which we should initialize the text-to-speech
    service with the given activity `Context`. Inside the class, write the following
    code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类构造函数，在其中使用给定的活动`Context`初始化文本转语音服务。在类内部，编写以下代码：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `speak()` method that proxies the given text to the `TextToSpeech`
    instance, by adding the following code at the bottom of the class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`speak()`方法，通过在类底部添加以下代码，将给定文本代理给`TextToSpeech`实例：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `TextToSpeech.speak` method uses a queuing strategy to make this method
    asynchronous. When it's called, the synthesis request is appended in the queue
    and, when the service is initialized, it will get processed. The queue mode could
    be defined as the second parameter of the speak method. We can find more information
    about the text-to-speech service at
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TextToSpeech.speak`方法采用队列策略使其异步化。调用该方法时，合成请求会被添加到队列中，并在服务初始化后进行处理。队列模式可以作为speak方法的第二个参数进行定义。我们可以在以下链接找到关于文本转语音服务的更多信息：'
- en: '[http://developer.android.com/reference/android/speech/tts/TextToSpeech.html](http://developer.android.com/reference/android/speech/tts/TextToSpeech.html)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/reference/android/speech/tts/TextToSpeech.html](http://developer.android.com/reference/android/speech/tts/TextToSpeech.html)'
- en: Providing feedback to users
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向用户提供反馈
- en: 'We should now adapt our activities to use the simple abstraction implemented
    in the preceding class. We begin with the `Overview` activity in which we should
    initialize the `VoiceManager` instance and use it in the `setPreset()` method
    to provide proper feedback whether we have found the recognized preset or not.
    To use the synthesis API in the `Overview` activity, perform the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该调整我们的活动以使用前面类中实现的简单抽象。我们从`Overview`活动开始，初始化`VoiceManager`实例，并在`setPreset()`方法中使用它，以提供是否找到识别的预设的正确反馈。要在`Overview`活动中使用合成API，请执行以下步骤：
- en: 'At the top of the class, add the highlighted code between the declaration of
    variables:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部，在变量声明之间添加高亮显示的代码：
- en: '[PRE33]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the bottom of the `onCreate()` callback, initialize the `VoiceManager` instance
    as shown in the following code snippet:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`回调的底部，按以下代码片段所示初始化`VoiceManager`实例：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Update the `setPreset()` method with the highlighted code so that it calls
    the synthesis API to provide feedback during preset activation:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用高亮显示的代码更新`setPreset()`方法，使其在预设激活期间调用合成API以提供反馈：
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The prototype is almost done and we only need to repeat the preceding steps
    for the `Settings` activity. In this activity, we should initialize the `VoiceManager`
    parameter and make use of the synthesis API in the `onRecognitionDone()` callback.
    There we should provide feedback to users about what the recognized preset is
    and whether it''s going to be created or edited according to retrieved setpoints.
    To use the synthesis API in the `Settings` activity, perform the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 原型几乎完成，我们只需要对`Settings`活动重复前面的步骤。在这个活动中，我们应该初始化`VoiceManager`参数，并在`onRecognitionDone()`回调中使用合成API。在那里，我们应该告知用户识别的预设是什么，以及根据检索到的设定点，它是将被创建还是编辑。要在`Settings`活动中使用合成API，请执行以下步骤：
- en: 'At the top of the class, declare the `VoiceManager` variable in line with the
    highlighted code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，按照高亮代码声明`VoiceManager`变量：
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At the bottom of the `onCreate()` callback, initialize the `VoiceManager` instance:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`回调的底部，初始化`VoiceManager`实例：
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update the `onRecognitionDone()` callback so that it calls the synthesis API
    to provide proper feedback:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`onRecognitionDone()`回调，使其调用合成API以提供适当的反馈：
- en: '[PRE38]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have completed enhancing our prototype with voice recognition and synthesis.
    The last, missing task is to upload the application again and check whether everything
    works as expected. Then we can update the Chronotherm application in the `app/build.gradle`
    file with a `0.2.0` version.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对原型的增强，加入了语音识别和合成功能。最后缺失的任务是再次上传应用程序，并检查一切是否如预期般工作。然后我们可以将Chronotherm应用程序在`app/build.gradle`文件中更新为`0.2.0`版本。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we managed to introduce numerous features with little work.
    We learned how to produce a lean and quick user interface with the help of voice
    recognition and synthesis.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过少量工作成功引入了许多功能。我们学会了如何利用语音识别和合成，制作一个精简且快速的用户界面。
- en: We started our journey creating a new way to store the user's presets, one that
    required refactoring for both activities and for `SensorThread` temperature checking.
    We proceed with the first implementation of voice recognition and, to simplify
    our work, we created a generic activity class extended from the `Settings` and
    `Overview` activities. This allowed us to abstract some common behavior, making
    it easy to call the recognition intent within different parts of our code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了一段旅程，创造了一种新的存储用户预设的方法，这需要对活动和`SensorThread`温度检查进行重构。我们继续进行语音识别的第一个实现，并且为了简化我们的工作，我们创建了一个从`Settings`和`Overview`活动扩展的通用活动类。这使得我们能够抽象出一些常见行为，便于在不同的代码部分调用识别意图。
- en: As the last step, we prepared the voice synthesis manager to easily use the
    Android text-to-speech engine. Indeed, we use this component to provide feedback
    after the recognition process, when users are changing their settings and the
    current activated preset.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们准备了语音合成管理器，以便轻松使用Android的文本到语音引擎。实际上，我们使用这个组件在识别过程后，当用户更改设置和当前激活的预设时提供反馈。
- en: In the next chapter, we will add network capabilities to the Chronotherm application
    so that it will be able to retrieve forecast data; using this information, we
    will make a slightly better algorithm to decide whether to turn our boiler on
    or off.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为Chronotherm应用程序添加网络功能，以便它能够检索天气预报数据；使用这些信息，我们将制作一个稍微更好的算法来决定是否打开或关闭我们的锅炉。
