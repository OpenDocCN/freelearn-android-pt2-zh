["```kt\n    class iIStream: public iObject\n    {\n    public:\n      virtual void    Seek( const uint64 Position ) = 0;\n      virtual uint64  Read( void* Buf, const uint64 Size ) = 0;\n      virtual bool    Eof() const = 0;\n      virtual uint64  GetSize() const = 0;\n      virtual uint64  GetPos() const = 0;\n    ```", "```kt\n      virtual const ubyte*  MapStream() const = 0;\n      virtual const ubyte*  MapStreamFromCurrentPos() const = 0;\n    };\n    ```", "```kt\n    class iOStream: public iObject\n    {\n    public:\n      virtual void   Seek( const uint64 Position ) = 0;\n      virtual uint64 GetFilePos() const = 0;\n      virtual uint64 Write( const void* B, const uint64 Size ) = 0;\n    };\n    ```", "```kt\n    class FileMapper: public iIStream\n    {\n    public:\n      explicit FileMapper( clPtr<iRawFile> File );\n      virtual ~FileMapper();\n      virtual std::string GetVirtualFileName() const{ return FFile->GetVirtualFileName(); }\n      virtual std::string  GetFileName() const{ return FFile->GetFileName(); }\n    ```", "```kt\n      virtual uint64 BlockRead( void* Buf, const uint64 Size )\n      {\n        uint64 RealSize =( Size > GetBytesLeft() ) ? GetBytesLeft() : Size;\n    ```", "```kt\n        if ( RealSize < 0 ) { return 0; }\n        memcpy( Buf, ( FFile->GetFileData() + FPosition ),static_cast<size_t>( RealSize ) );\n    ```", "```kt\n        FPosition += RealSize;\n        return RealSize;\n      }\n\n      virtual void Seek( const uint64 Position )     \n      { FPosition  = Position; }\n      virtual uint64 GetFileSize() const\n      { return FFile->GetFileSize(); }\n      virtual uint64 GetFilePos()  const\n      { return FPosition; }\n      virtual bool         Eof() const        \n      { return ( FPosition >= GetFileSize() ); }\n\n      virtual const ubyte* MapStream() const\n      { return FFile->GetFileData(); }\n      virtual const ubyte* MapStreamFromCurrentPos() const \n      { return ( FFile->GetFileData() + FPosition ); }\n    private:\n      clPtr<iRawFile> FFile;\n      uint64          FPosition;\n    };\n    ```", "```kt\n    class iRawFile: public iObject\n    {\n    public:\n      iRawFile() {};\n      virtual ~iRawFile() {};\n      void        SetVirtualFileName( const std::string& VFName );void        SetFileName( const std::string& FName );std::string GetVirtualFileName() const;\n      std::string GetFileName();\n      virtual const ubyte* GetFileData() const = 0;\n      virtual uint64       GetFileSize() const = 0;\n    protected:\n      std::string    FFileName;\n      std::string    FVirtualFileName;\n    };\n    ```", "```kt\n#if defined( _WIN32 )\nconst char PATH_SEPARATOR = '\\\\';\n#else\nconst char PATH_SEPARATOR = '/';\n#endif\n```", "```kt\ninline std::string Arch_FixFileName(const std::string& VName)\n{\n  std::string s( VName );\n  std::replace( s.begin(), s.end(), '\\\\', PATH_SEPARATOR );\n  std::replace( s.begin(), s.end(), '/', PATH_SEPARATOR );\n  return s;\n}\n```", "```kt\n      ubyte*    FFileData;\n      uint64    FSize;\n    ```", "```kt\n    #ifdef _WIN32\n      HANDLE     FMapFile;\n      HANDLE     FMapHandle;\n    #else\n      int        FFileHandle;\n    #endif\n    ```", "```kt\n    bool RawFile::Open( const string& FileName,const string& VirtualFileName )\n    {\n    ```", "```kt\n    #ifdef OS_WINDOWS\n      FMapFile = (void*)CreateFileA( FFileName.c_str(),GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL );\n    #else\n      FFileHandle = open( FileName.c_str(), O_RDONLY );\n      if ( FFileHandle == -1 )\n      {\n        FFileData = NULL;\n        FSize = 0;\n      }\n    #endif\n    ```", "```kt\n    #ifdef OS_WINDOWS\n      FMapHandle = (void*)CreateFileMapping( ( HANDLE )FMapFile,NULL, PAGE_READONLY, 0, 0, NULL );\n      FFileData = (Lubyte*)MapViewOfFile((HANDLE)FMapHandle,FILE_MAP_READ, 0, 0, 0 );\n      DWORD dwSizeLow = 0, dwSizeHigh = 0;\n      dwSizeLow = ::GetFileSize( FMapFile, &dwSizeHigh );\n      FSize = ((uint64)dwSizeHigh << 32) | (uint64)dwSizeLow;\n    #else\n      struct stat FileInfo;\n     fstat( FFileHandle, &FileInfo );\n      FSize = static_cast<uint64>( FileInfo.st_size );\n      FFileData = (Lubyte*) mmap(NULL, FSize, PROT_READ,MAP_PRIVATE, FFileHandle, 0 );\n      close( FFileHandle );\n    #endif\n      return true;\n    }\n    ```", "```kt\n    bool RawFile::Close()\n    {\n    #ifdef OS_WINDOWS\n      if ( FFileData  ) UnmapViewOfFile( FFileData );\n      if ( FMapHandle ) CloseHandle( (HANDLE)FMapHandle );\n      CloseHandle( (HANDLE)FMapFile );\n    #else\n      if ( FFileData ) munmap( (void*)FFileData, FSize );\n    #endif\n      return true;\n    }\n    ```", "```kt\n      virtual const ubyte* GetFileData() { return FFileData; }\n      virtual uint64       GetFileSize() { return FSize;     }\n    ```", "```kt\n  clPtr<RawFile> F = new RawFile();\n  F->Open(\"SomeFileName\");\n  clPtr<FileMapper> FM = new FileMapper(F);\n```", "```kt\n    class FileWriter: public iOStream\n    {\n    public:\n      FileWriter(): FPosition( 0 ) {}\n      virtual ~FileWriter() { Close(); }\n\n      bool Open( const std::string& FileName )\n      {\n        FFileName = FileName;\n    ```", "```kt\n    #ifdef _WIN32\n        FMapFile = CreateFile( FFileName.c_str(),GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, NULL );\n        return !( FMapFile == ( void* )INVALID_HANDLE_VALUE );\n    #else\n        FMapFile = open( FFileName.c_str(), O_WRONLY|O_CREAT );\n        FPosition = 0;\n        return !( FMapFile == -1 );\n    #endif\n      }\n    ```", "```kt\n      void Close()\n      {\n    #ifdef _WIN32\n        CloseHandle( FMapFile );\n    #else\n        if ( FMapFile != -1 ) { close( FMapFile ); }\n    #endif\n      }\n      virtual std::string GetFileName() const { return FFileName; }\n      virtual uint64      GetFilePos() const { return FPosition; }\n      virtual void        Seek( const uint64 Position )\n      {\n    #ifdef _WIN32\n        SetFilePointerEx( FMapFile,*reinterpret_cast<const LARGE_INTEGER*>( &Position ),NULL, FILE_BEGIN );\n    #else\n        if ( FMapFile != -1 )\n        { lseek( FMapFile, Position, SEEK_SET ); }\n    #endif\n        FPosition = Position;\n      }\n    ```", "```kt\n      virtual uint64 Write( const void* Buf, const uint64 Size )\n      {\n    #ifdef _WIN32\n        DWORD written;\n        WriteFile( FMapFile, Buf, DWORD( Size ),&written, NULL );\n    #else\n        if ( FMapFile != -1 ) { write( FMapFile, Buf, Size ); }\n    #endif\n        FPosition += Size;\n        return Size;\n      }\n    private:\n      std::string FFileName;\n    #ifdef _WIN32\n      HANDLE FMapFile;\n    #else\n      int    FMapFile;\n    #endif\n      uint64    FPosition;\n    };\n    ```", "```kt\nclass Blob: public iObject\n{\npublic:\n  Blob();\n  virtual ~Blob();\n```", "```kt\n  void SetExternalData( void* Ptr, size_t Sz );\n```", "```kt\n  void* GetData();\n  …\n```", "```kt\n  size_t GetSize() const;\n```", "```kt\n  bool OwnsData() const;\n  …\n```", "```kt\n  bool AppendBytes( void* Data, size_t Size );\n…\n};\n```", "```kt\nclass MemFileWriter: public iOStream\n{\npublic:\n  MemFileWriter(clPtr<Blob> Container);\n```", "```kt\n  virtual void    Seek( const uint64 Position )\n  {\n    if ( Position > FContainer->GetSize() )\n    {\n```", "```kt\n      if ( Position > FMaxSize - 1 ) { return; }\n```", "```kt\n      if ( !FContainer->SafeResize(static_cast<size_t>( Position ) + 1 ))\n     { return; }\n    }\n    FPosition = Position;\n  }\n```", "```kt\n  virtual uint64    Write( const void* Buf, const uint64 Size )\n  {\n    uint64 ThisPos = FPosition;\n```", "```kt\n    Seek( ThisPos + Size );\n    if ( FPosition + Size > FMaxSize ) { return 0; }\n    void* DestPtr = ( void* )( &( ( ( ubyte* )(FContainer->GetData() ) )[ThisPos] ) );\n```", "```kt\n    memcpy( DestPtr, Buf, static_cast<size_t>( Size ) );\n    return Size;\n  }\n}\nprivate:\n  …\n};\n```", "```kt\n    class ManagedMemRawFile: public iRawFile\n    {\n    public:\n      ManagedMemRawFile(): FBlob( NULL ) {}\n      virtual const ubyte* GetFileData() const\n      { return ( const ubyte* )FBlob->GetData(); }\n      virtual uint64       GetFileSize() const\n      { return FBlob->GetSize(); }\n      void SetBlob( const clPtr<Blob>& Ptr )\n      { FBlob = Ptr; }\n    private:\n      clPtr<Blob> FBlob;\n    };\n    ```", "```kt\n    class MemRawFile: public iRawFile\n    {\n    public:\n      virtual const ubyte* GetFileData() const\n\n      { return (const ubyte*) FBuffer; }\n      virtual uint64 GetFileSize() const\n      { return FBufferSize; }\n\n      void CreateFromString( const std::string& InString );\n      void CreateFromBuffer( const void* Buf, uint64 Size );\n      void CreateFromManagedBuffer( const void* Buf, uint64 Size );\n    private:\n      bool        FOwnsBuffer;\n      const void* FBuffer;\n      uint64      FBufferSize;\n    };\n    ```", "```kt\n    class iMountPoint: public iObject\n    {\n    public:\n    ```", "```kt\n      virtual bool FileExists( const string& VName ) const = 0;\n    ```", "```kt\n      virtual string MapName( const string& VName ) const = 0;\n    ```", "```kt\n      virtual clPtr<iRawFile> CreateReader(const string& Name ) const = 0;\n    };\n    ```", "```kt\n    class PhysicalMountPoint: public iMountPoint\n    {\n    public:\n      explicit PhysicalMountPoint(const std::string& PhysicalName);\n      virtual bool FileExists(const std::string& VirtualName ) const\n      { return FS_FileExistsPhys( MapName( VirtualName ) ); }\n      virtual std::string  MapName(const std::string& VirtualName ) const\n      {\n        return ( FS_IsFullPath( VirtualName ) ) ?VirtualName : ( FPhysicalName + VirtualName );\n      }\n    ```", "```kt\n      virtual clPtr<iRawFile> CreateReader(const std::string& VirtualName ) const\n      {\n        std::string PhysName = FS_IsFullPath( VirtualName ) ?VirtualName : MapName( VirtualName );\n        clPtr<RawFile> File = new RawFile();\n        return !File->Open( FS_ValidatePath( PhysName ),VirtualName ) ? NULL : File;\n      }\n    private:\n      std::string FPhysicalName;\n    };\n    ```", "```kt\n    class FileSystem: public iObject\n    {\n    public:\n     void Mount( const std::string& PhysicalPath );\n      void AddAlias(const std::string& Src,const std::string& Prefix );\n      std::string VirtualNameToPhysical(const std::string& Path ) const;\n      bool FileExists( const std::string& Name ) const;\n    private:\n      std::vector< clPtr<iMountPoint> > FMountPoints;\n    };\n    ```", "```kt\nclass AliasMountPoint: public iMountPoint\n{\npublic:\n  AliasMountPoint( const clPtr<iMountPoint>& Src );\n  virtual ~AliasMountPoint();\n```", "```kt\n  void    SetAlias( const std::string& Alias )\n  {\n    FAlias = Alias;\n    Str_AddTrailingChar( &FAlias, PATH_SEPARATOR );\n  }\n…\n  virtual clPtr<iRawFile> CreateReader(const std::string& VirtualName ) const\n{ return FMP->CreateReader( FAlias + VirtualName ); }\nprivate:\n```", "```kt\n  std::string FAlias;\n```", "```kt\n  clPtr<iMountPoint> FMP;\n};\n```", "```kt\n    static voidpf ZCALLBACK zip_fopen( voidpf opaque,const void* filename, int mode )\n    {\n      ( ( iIStream* )opaque )->Seek( 0 );\n      return opaque;\n    }\n    ```", "```kt\n    static uLong ZCALLBACK zip_fread( voidpf opaque, voidpf stream,void* buf, uLong size )\n    {\n      iIStream* S = ( iIStream* )stream;\n      int64_t CanRead = ( int64 )size;\n      int64_t Sz = S->GetFileSize();\n      int64_t Ps = S->GetFilePos();\n      if ( CanRead + Ps >= Sz ) { CanRead = Sz - Ps; }\n      if ( CanRead > 0 )\n      { S->BlockRead( buf, (uint64_t)CanRead ); }\n      else\n      { CanRead = 0; }\n      return ( uLong )CanRead;\n    }\n    ```", "```kt\n    static ZPOS64_T ZCALLBACK zip_ftell( voidpf opaque, voidpf stream )\n    {\n      return ( ZPOS64_T )( ( iIStream* )stream )->GetFilePos();\n    }\n    ```", "```kt\n    static long ZCALLBACK zip_fseek ( voidpf  opaque, voidpf stream,ZPOS64_T offset, int origin )\n    {\n      iIStream* S = ( iIStream* )stream;\n      int64 NewPos = ( int64 )offset;\n      int64 Sz = ( int64 )S->GetFileSize();\n      switch ( origin )\n      {\n        case ZLIB_FILEFUNC_SEEK_CUR:\n          NewPos += ( int64 )S->GetFilePos();\n          break;\n        case ZLIB_FILEFUNC_SEEK_END:\n          NewPos = Sz - 1 - NewPos;\n          break;\n        case ZLIB_FILEFUNC_SEEK_SET:\n          break;\n        default:\n          return -1;\n      }\n      if ( NewPos >= 0 && ( NewPos < Sz ) )\n      { S->Seek( ( uint64 )NewPos ); }\n      else\n      { return -1; }\n      return 0;\n    }\n    ```", "```kt\n    static int ZCALLBACK zip_fclose(voidpf op, voidpf s) { return 0; }\n    static int ZCALLBACK zip_ferror(voidpf op, voidpf s) { return 0; }\n    ```", "```kt\n    void fill_functions( iIStream* Stream, zlib_filefunc64_def* f )\n    {\n      f->zopen64_file = zip_fopen;\n      f->zread_file = zip_fread;\n      f->zwrite_file = NULL;\n      f->ztell64_file = zip_ftell;\n      f->zseek64_file = zip_fseek;\n      f->zclose_file = zip_fclose;\n      f->zerror_file = zip_ferror;\n      f->opaque = Stream;\n    }\n    ```", "```kt\n    bool ArchiveReader::Enumerate_ZIP()\n    {\n      iIStream* TheSource = FSourceFile;\n\n      zlib_filefunc64_def ffunc;\n      fill_functions( TheSource, &ffunc );\n      unzFile uf = unzOpen2_64( \"\", &ffunc );\n      unz_global_info64 gi;\n      int err = unzGetGlobalInfo64( uf, &gi );\n    ```", "```kt\n      for ( uLong i = 0; i < gi.number_entry; i++ )\n      {\n        char filename_inzip[256];\n        unz_file_info64 file_info;\n        err = unzGetCurrentFileInfo64( uf, &file_info,filename_inzip, sizeof( filename_inzip ),NULL, 0, NULL, 0 );\n        if ( err != UNZ_OK ) { break; }\n        if ( ( i + 1 ) < gi.number_entry )\n        {\n          err = unzGoToNextFile( uf );\n        }\n    ```", "```kt\n        sFileInfo Info;\n        std::string TheName = Arch_FixFileName(filename_inzip);\n        Info.FCompressedSize = file_info.compressed_size;\n        Info.FSize = file_info.uncompressed_size;\n        FFileInfos.push_back( Info );\n        FFileNames.push_back( TheName );\n      }\n      unzClose( uf );\n      return true;\n    }\n    ```", "```kt\n    class ArchiveReader: public iObject\n    {\n    public:\n      ArchiveReader();\n      virtual ~ArchiveReader();\n    ```", "```kt\n      bool    OpenArchive( const clPtr<iIStream>& Source );\n    ```", "```kt\n      bool    ExtractSingleFile( const std::string& FName,const std::string& Password,const clPtr<iOStream>& FOut );\n    ```", "```kt\n      bool    CloseArchive();\n    ```", "```kt\n      bool    FileExists( const std::string& FileName ) const\n      { return ( GetFileIdx( FileName ) > -1 ); }\n    …\n    ```", "```kt\n      struct sFileInfo\n      {\n    ```", "```kt\n        uint64 FOffset;\n    ```", "```kt\n        uint64 FSize;\n    ```", "```kt\n        uint64 FCompressedSize;\n    ```", "```kt\n        void* FSourceData;\n      };\n      …\n    };\n    ```", "```kt\nclass ArchiveMountPoint: public iMountPoint\n{\npublic:\n  ArchiveMountPoint( const clPtr<ArchiveReader>& R );\n```", "```kt\n  virtual clPtr<iRawFile> CreateReader(\n    const std::string&  VirtualName ) const\n  {\n    std::string FName = Arch_FixFileName( VirtualName );\n    MemRawFile* File = new MemRawFile();\n    File->SetFileName( VirtualName );\n    File->SetVirtualFileName( VirtualName );\n    const void* DataPtr = FReader->GetFileData( FName );\n    uint64 FileSize = FReader->GetFileSize( FName );\n    File->CreateFromManagedBuffer( DataPtr, FileSize );\n    return File;\n  }\n```", "```kt\n  virtual bool FileExists(const std::string& VirtualName ) const\n  {\n  return\n  FReader->FileExists(Arch_FixFileName(VirtualName));\n  }\n  virtual std::string      MapName(const std::string& VirtualName ) const\n  { return VirtualName; }\nprivate:\n  clPtr<ArchiveReader> FReader;\n};\n```", "```kt\n    int ExtractCurrentFile_ZIP( unzFile uf,const char* password, const clPtr<iOStream>& fout )\n    {\n      char filename_inzip[256];\n      int err = UNZ_OK;\n      void* buf;\n      uInt size_buf;\n      unz_file_info64 file_info;\n      err = unzGetCurrentFileInfo64( uf, &file_info,filename_inzip, sizeof( filename_inzip ),NULL, 0, NULL, 0 );\n      if ( err != UNZ_OK ) { return err; }\n      uint64_t file_size = ( uint64_t )file_info.uncompressed_size;\n      uint64_t total_bytes = 0;\n      unsigned char _buf[WRITEBUFFERSIZE];\n      size_buf = WRITEBUFFERSIZE;\n      buf = ( void* )_buf;\n      if ( buf == NULL ) { return UNZ_INTERNALERROR; }\n    ```", "```kt\n      err = unzOpenCurrentFilePassword( uf, password );\n    ```", "```kt\n      do\n      {\n        err = unzReadCurrentFile( uf, buf, size_buf );\n        if ( err < 0 )\n      { break; }\n        if ( err > 0 )\n      { total_bytes += err; fout->Write( buf, err ); }\n      }\n      while ( err > 0 );\n      int close_err = unzCloseCurrentFile ( uf );\n      …\n    }\n    ```", "```kt\n    bool ArchiveReader::ExtractSingleFile( const string& FName,const string& Password, const clPtr<iOStream>& FOut )\n    {\n      int err = UNZ_OK;\n      LString ZipName = FName;\n      std::replace ( ZipName.begin(), ZipName.end(), '\\\\', '/' );\n      clPtr<iIStream> TheSource = FSourceFile;\n      TheSource->Seek(0);\n    ```", "```kt\n      zlib_filefunc64_def ffunc;\n      fill_functions( FSourceFile.GetInternalPtr(), &ffunc );\n      unzFile uf = unzOpen2_64( \"\", &ffunc );\n      if ( unzLocateFile( uf, ZipName.c_str(), 0) != UNZ_OK )\n      {\n        return false;\n      }\n      err = ExtractCurrentFile_ZIP( uf,Password.empty() ? NULL : Password.c_str(), FOut );\n      unzClose( uf );\n      return ( err == UNZ_OK );\n    }\n    ```", "```kt\n  clPtr<RawFile> File = new RawFile();\n  File->Open( \"test.zip\", \"\" );\n  clPtr<ArchiveReader> a = new ArchiveReader();\n  a->OpenArchive( new FileMapper(File) );\n```", "```kt\n    class Bitmap: public iObject\n    {\n    public:\n      Bitmap( const int W, const int H)\n      {\n        size_t Size = W * H * 3;\n        if ( !Size ) { return; }\n\n        FWidth  = W;\n        FHeight = H;\n\n        FBitmapData = (ubyte*)malloc( Size );\n        memset(FBitmapData, 0xFF, Size);\n      }\n      virtual ~Bitmap() { free(FBitmapData); }\n      void Load2DImage( clPtr<iIStream> Stream )\n      {\n        free( FBitmapData );\n        FBitmapData = read_bmp_mem(Stream->MapStream(), &FWidth, &FHeight );\n      }\n    …\n    ```", "```kt\n      int FWidth;\n      int FHeight;\n    ```", "```kt\n      ubyte* FBitmapData;\n    };\n    ```", "```kt\n    class LoadOp_Image: public iTask\n    {\n    public:\n      LoadOp_Image( clPtr<Bitmap> Bmp, clPtr<iIStream> IStream ):FBmp( Bmp ), FStream( IStream ) {}\n\n      virtual void Run()\n      {\n        FBmp->Load2DImage( FStream );\n        g_Events->EnqueueCapsule(new LoadCompleteCapsule(FBmp) );\n      }\n    private:\n      clPtr<Bitmap>  FBmp;\n      clPtr<iIStream> FStream;\n    };\n    ```", "```kt\n    class LoadCompleteCapsule: public iAsyncCapsule\n    {\n    public:\n      LoadCompleteCapsule(clPtr<Bitmap> Bmp): FBmp(Bmp) {}\n      virtual void Invoke()\n      {\n        // … copy FBmp to g_FrameBuffer … \n      }\n    private:\n      clPtr<Bitmap> FBmp;\n    };\n    ```", "```kt\n    clPtr<Bitmap> LoadImg( const std::string& FileName )\n    {\n      clPtr<iIStream> IStream = g_FS->CreateReader(FileName);\n      clPtr<Bitmap> Bmp = new Bitmap(1, 1);\n      g_Loader->AddTask( new LoadOp_Image( Bmp, IStream ) );\n      return Bmp;\n    }\n    ```", "```kt\n      g_FS = new FileSystem();\n      g_FS->Mount(\".\");\n    ```", "```kt\n      g_Events = new iAsyncQueue();\n      g_Loader = new WorkerThread();\n      g_Loader->Start( iThread::Priority_Normal );\n    ```", "```kt\n      clPtr<Bitmap> Bmp = LoadImg(\"test.bmp\");\n    ```", "```kt\n    protected String GetDefaultExternalStoragePrefix()\n    {\n      String Suffix = \"/external_sd/Android/data/\";\n      return Environment.getExternalStorageDirectory().getPath() +Suffix + getApplication().getPackageName();\n    }\n    ```", "```kt\n    String ExternalStoragePrefix = GetDefaultExternalStoragePrefix();\n    String state = Environment.getExternalStorageState();\n    ```", "```kt\n    if ( !Environment.MEDIA_MOUNTED.equals( state ) ||Environment.MEDIA_MOUNTED_READ_ONLY.equals( state ) )\n    {\n    ExternalStoragePrefix = this.getDir(getApplication().getPackageName(), MODE_PRIVATE).getPath();\n    }\n    ```", "```kt\n    try\n    {\n      new File( ExternalStoragePrefix ).mkdirs();\n      File F = new File(ExternalStoragePrefix + \"/engine.log\" );\n      F.createNewFile();\n      F.delete();\n    }\n    catch (IOException e)\n    {\n      Log.e( \"App6\", \"Falling back to internal storage\" );\n      ExternalStoragePrefix = this.getDir(getApplication().getPackageName(), MODE_PRIVATE).getPath();\n    }\n    ```", "```kt\n    OnCreateNative( ExternalStoragePrefix );\n    public static native void OnCreateNative(StringExternalStorage);\n    ```", "```kt\nextern std::string g_ExternalStorage;\nextern \"C\"\n{\n  JNIEXPORT void JNICALLJava_com_packtpub_ndkcookbook_app6_App6Activity_OnCreateNative(JNIEnv* env, jobject obj, jstring Path )\n  {\n    g_ExternalStorage = ConvertJString( env, Path );\n    OnStart();\n  }\n}\n```", "```kt\nstd::string ConvertJString(JNIEnv* env, jstring str)\n{\n  if ( !str ) std::string();\n  const jsize len = env->GetStringUTFLength(str);\n  const char* strChars = env->GetStringUTFChars(str,(jboolean *)0);\n  std::string Result(strChars, len);\n  env->ReleaseStringUTFChars(str, strChars);\n  return Result;\n}\n```", "```kt\nI/App6    (27043): External storage path:/storage/emulated/0/external_sd/Android/data/com.packtpub.ndkcookbook.app6\n```", "```kt\nExternal storage path: C:\\Users\\Author\\Documents\\ndkcookbook\\App6\n```", "```kt\n<uses-permissionandroid:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```"]