- en: Advanced 2D Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级2D渲染
- en: 'Being able to draw more complex primitives or use a composition of them is
    critical to making the user experience of our custom view awesome, useful, and
    special. So far, we''ve been using some drawing and rendering operations on our
    custom view, but if we check the Android documentation closely, that''s a much
    reduced set of what Android provides to developers. We have drawn some primitives,
    saved and restored our `canvas` state, and applied some clipping operations, but
    that''s only the top thin layer. In this chapter, we''ll see these operations
    again, but we''ll also see few new drawing operations and how we can use everything
    together. We''ll cover the following topics in more detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够绘制更复杂的原始图形或使用它们的组合对于使我们的自定义视图的用户体验变得出色、实用和特别至关重要。到目前为止，我们在自定义视图中使用了一些绘制和渲染操作，但如果我们仔细查看Android文档，这只是Android为开发者提供的一小部分功能。我们已经绘制了一些原始图形，保存和恢复了我们的`canvas`状态，并应用了一些剪辑操作，但这只是冰山一角。在本章中，我们将再次看到这些操作，但我们将看到一些新的绘制操作以及如何将它们一起使用。我们将更详细地介绍以下主题：
- en: Drawing operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图操作
- en: Masking and clipping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙版和剪辑
- en: Gradients
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐变
- en: Putting it all together
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把它们放在一起
- en: Drawing operations
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图操作
- en: As we've just mentioned, we have already seen and used some drawing operations,
    but that was only the envelope of what's inside. We'll see new drawing operations
    and how to combine them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，我们已经看到并使用了一些绘图操作，但这只是冰山一角。我们将看到新的绘图操作以及如何将它们结合使用。
- en: Bitmaps
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位图
- en: 'Let''s start by drawing bitmaps or images. Instead of having a white background,
    we''ll use an image as background for our custom view. Using the source code from
    our previous example, we could do some very simple modifications to draw an image:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从绘制位图或图像开始。我们不是使用白色背景，而是将图像作为我们自定义视图的背景。使用我们之前示例的源代码，我们可以做一些非常简单的修改来绘制图像：
- en: 'First, let''s define a `Bitmap` object that will hold a reference to the image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个`Bitmap`对象来保存对图像的引用：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To start, let''s initialize it with the application icon we already have on
    our application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用已有的应用程序图标来初始化它：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`BitmapFactory` provides us several ways to load and decode images.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapFactory`为我们提供了多种加载和解码图像的方法。'
- en: 'Once we have the image loaded, we can draw it on our `onDraw()` method by calling
    the `drawBitmap(Bitmap bitmap, float left, float top, Paint paint)` method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载了图像之后，可以在`onDraw()`方法中通过调用`drawBitmap(Bitmap bitmap, float left, float
    top, Paint paint)`方法来绘制图像：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we don't need anything special from our `Paint` object, we've set it to `null`;
    we'll use it later in this book, but for the moment, just ignore it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不需要从`Paint`对象中得到任何特别的东西，所以我们将其设置为`null`；我们将在本书稍后使用它，但现在，只需忽略它。
- en: 'If `backgroundBitmap` is `null`, it means that it couldn''t load the image;
    so, for safety, we should always check. This code will just draw the icon on the
    top-left corner of our custom view, although we could change its position by setting
    either different coordinates-here we used `0`,`0`-or applying a transformation
    to our `canvas` like we did before. For example, we can rotate the image based
    on the angle selected by the user:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`backgroundBitmap`为`null`，这意味着它无法加载图像；因此，为了安全起见，我们应始终检查。这段代码只会在我们自定义视图的左上角绘制图标，尽管我们可以通过设置不同的坐标（这里我们使用了`0`，`0`）或对我们的`canvas`应用之前做过的变换来改变其位置。例如，我们可以根据用户选择的角度来旋转图像：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we've added the center of the image as the pivot point, or otherwise
    will rotate by its top-left corner.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将图像的中心作为轴心点，否则将以其左上角为中心旋转。
- en: There are other ways to draw images; Android has another method for drawing
    an image from a source `Rect` to a destination `Rect`. The `Rect` object allows
    us to store four coordinates and use it as a rectangle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以绘制图像；Android提供了另一种方法，可以从源`Rect`绘制到目标`Rect`。`Rect`对象允许我们存储四个坐标并将其用作矩形。
- en: The method `drawBitmap(Bitmap bitmap, Rect source, Rect dest, Paint paint)`
    is very useful for drawing a portion of an image into any other size we want.
    This method will take care of scaling the selected portion of the image to fill
    the destination rectangle. For example, we could use the following code if we
    wanted to draw the right half of the image scaled to the whole custom view size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBitmap(Bitmap bitmap, Rect source, Rect dest, Paint paint)`方法非常适用于将图像的一部分绘制成我们想要的任何其他大小。这个方法会处理缩放选定部分的图像以填充目标矩形。例如，如果我们想绘制图像的右半部分并缩放到整个自定义视图的大小，我们可以使用以下代码。'
- en: 'First, let''s define the background `Bitmap` and two `Rect`; one to hold the
    source dimensions and other for the destination:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义背景 `Bitmap` 和两个 `Rect`；一个用于保存源尺寸，另一个用于目标尺寸：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, let's instantiate them on the class constructor. It's not a good practice
    to do it on the `onDraw()` method, as we should avoid allocating memory to methods
    that are called on every frame or every time we draw our custom view. Doing so
    will trigger additional garbage collector cycles and affect performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在类构造函数中实例化它们。在 `onDraw()` 方法中这样做不是一个好习惯，因为我们应该避免为每次帧调用或每次绘制自定义视图的方法分配内存。这样做会触发额外的垃圾收集周期，影响性能。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, `Rect` initializes the four coordinates to 0 but here, for clarity,
    we set the top and the left coordinates to 0\. If the image was loaded successfully,
    we set the right and bottom to the width and height of the image, respectively.
    As we want to draw only the right half of the image only, we update the left border
    to half the width of the image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Rect` 会将四个坐标初始化为 0，但在这里，为了清晰起见，我们将顶部和左侧坐标设置为 0。如果图像加载成功，我们将右侧和底部分别设置为图像的宽度和高度。由于我们只想绘制图像的右半部分，因此我们将左侧边界更新为图像宽度的一半。
- en: 'On the `onDraw()` method, we set the right and bottom coordinates of the destination
    `Rect` to the width and height of the custom view and we draw the image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onDraw()` 方法中，我们将目标 `Rect` 的右侧和底部坐标设置为自定义视图的宽度和高度，然后我们绘制图像：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s check the result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下结果：
- en: '![](img/0da5787f-9638-4cf0-846e-56f9a313f84e.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0da5787f-9638-4cf0-846e-56f9a313f84e.png)'
- en: 'We can see it doesn''t abide by the aspect ratio of the image, but let''s solve
    it by computing the ratio of the smaller dimension, either horizontal or vertical,
    and scale it by this ration. Then, apply it to the other dimension. We will see
    the following code after calculating the image ratio:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它并不遵循图像的宽高比，但我们可以通过计算较小维度（水平或垂直）的比例并以此比例进行缩放来解决它。然后，将这个比例应用到另一个维度上。计算图像比例后，我们将看到以下代码：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also draw a `Bitmap` using a transformation `Matrix`. To do so, we can
    create a new instance of `Matrix` and apply a transformation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用变换 `Matrix` 绘制 `Bitmap`。为此，我们可以创建 `Matrix` 的新实例并应用变换：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create an instance on the constructor. Do not create an instance on the `onDraw()`
    instance, as it will pollute the memory and trigger unnecessary garbage collection,
    as mentioned earlier:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中创建实例。不要在 `onDraw()` 实例中创建实例，因为这将污染内存并触发不必要的垃圾收集，如前所述：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please be careful with the matrix operation order; there are also post-operations
    and pre-operations. Check the matrix class documentation for more information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意矩阵操作顺序；也有后操作和前操作。更多信息请查看矩阵类文档。
- en: On the `onDraw()` method, just draw `Bitmap` using the `drawBitmap (Bitmap bitmap,
    Matrix matrix, Paint paint)` method and using the `matrix` we've initialized on
    our class constructor. In this example, we also used a `null Paint` object to
    simplify, as we don't need anything specific from the `Paint` object here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onDraw()` 方法中，只需使用 `drawBitmap (Bitmap bitmap, Matrix matrix, Paint paint)`
    方法绘制 `Bitmap`，并使用我们在类构造函数中初始化的 `matrix`。在这个例子中，我们还使用了 `null Paint` 对象以简化，因为在这里我们不需要从
    `Paint` 对象获取任何特定内容。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Although these are the most common methods to draw a `Bitmap` onto a `Canvas`,
    there are a few more methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些是将 `Bitmap` 绘制到 `Canvas` 上最常见的方法，但还有更多方法。
- en: Furthermore, check the `Example12-Drawing` folder on the GitHub repository to
    see the full source code of this example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请查看 GitHub 存储库中的 `Example12-Drawing` 文件夹，以查看此示例的完整源代码。
- en: Using the Paint class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Paint 类
- en: We've been drawing some primitives until now, but `Canvas` provides us with
    many more primitive rendering methods. We'll briefly cover some of them, but first,
    let's first talk about the `Paint` class as we haven't introduced it properly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止我们一直在绘制一些基本图形，但 `Canvas` 为我们提供了更多基本渲染方法。我们将简要介绍其中一些，但首先，让我们正式介绍一下 `Paint`
    类，因为我们还没有完全介绍它。
- en: According to the official definition, the `Paint` class holds the style and
    color information about how to draw primitives, text, and bitmaps. If we check
    the examples we've been building, we created a `Paint` object on our class constructor
    or on the `onCreate` method, and we used it to draw primitives later on our `onDraw()`
    method. As, for instance, if we set our background Paint instance `Style` to `Paint.Style.FILL`,
    it'll fill the primitive, but we can change it to `Paint.Style.STROKE` if we only
    want to draw the border or the strokes of the silhouette. We can draw both using
    `Paint.Style.FILL_AND_STROKE`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方定义，`Paint`类保存了关于如何绘制基本图形、文本和位图的风格和颜色信息。如果我们检查我们一直在构建的示例，我们在类构造函数中或在`onCreate`方法中创建了一个`Paint`对象，并在后面的`onDraw()`方法中使用它来绘制基本图形。例如，如果我们把背景`Paint`实例的`Style`设置为`Paint.Style.FILL`，它会填充基本图形，但如果我们只想绘制边框或轮廓的笔触，我们可以将其更改为`Paint.Style.STROKE`。我们可以同时使用`Paint.Style.FILL_AND_STROKE`来绘制两者。
- en: 'To see `Paint.Style.STROKE` in action, we''ll draw a black border on top of
    our selected colored bar in our custom View. Let''s start by defining a new `Paint`
    object called `indicatorBorderPaint` and initialize it on our class constructor:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到`Paint.Style.STROKE`的效果，我们将在自定义视图中的选定彩色栏上方绘制一个黑色边框。首先，在类构造函数中定义一个新的`Paint`对象，名为`indicatorBorderPaint`，并初始化它：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We also defined a constant with the size of the border line and set the stroke
    width to this size. If we set the width to `0`, Android guaranties it'll use a
    single pixel to draw the line. As we want to draw a thick black border, this is
    not our case right now. In addition, we set the stroke `Cap` to `Paint.Cap.BUTT`
    to avoid the stroke overflowing its path. There are two more Caps we can use,
    `Paint.Cap.SQUARE` and `Paint.Cap.ROUND`. These last two will end the stroke,
    respectively, with a circle, rounding the stroke, or a square.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个常量来设置边框线的尺寸，并将笔触宽度设置为这个尺寸。如果我们把宽度设置为`0`，Android保证会使用一个像素来绘制线条。由于我们现在想要绘制一条粗黑的边框，所以这不是我们的情况。此外，我们将笔触线帽设置为`Paint.Cap.BUTT`，以避免笔触溢出路径。还有两种线帽可以使用，`Paint.Cap.SQUARE`和`Paint.Cap.ROUND`。最后这两种线帽会分别以圆形（使笔触变圆）或方形结束笔触。
- en: Let's quickly see the differences between the three Caps and also introduce
    the `drawLine` primitive.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解三种线帽之间的区别，并介绍`drawLine`这个基本图形绘制方法。
- en: 'First of all, we create an array with all three Caps, so we can easily iterate
    between them and create a more compact code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含所有三种线帽的数组，这样我们可以轻松地在它们之间迭代，并编写更紧凑的代码：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, on our `onDraw()` method, let''s draw a line using each of the Caps using
    the `drawLine(float startX, float startY, float stopX, float stopY, Paint paint)`
    method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`onDraw()`方法中，让我们使用`drawLine(float startX, float startY, float stopX,
    float stopY, Paint paint)`方法，用每种线帽绘制一条线：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll have a result similar to the following image. As we can see, the line
    is slightly shorter when using the `Paint.Cap.BUTT` stroke `Cap`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似以下图像的结果。如我们所见，当使用`Paint.Cap.BUTT`作为笔触线帽时，线条会稍微短一些：
- en: '![](img/3682b626-e67f-48b8-aa8b-536408294391.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3682b626-e67f-48b8-aa8b-536408294391.png)'
- en: 'Also, as we saw before, we set the `AntiAlias` flag to true on the `Paint`
    object. If this flag is enabled, all operations that support it will smooth the
    corners of what they are drawing. Let''s compare the differences with this flag
    enabled and disabled:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如我们之前所看到的，我们在`Paint`对象上设置了`AntiAlias`标志为true。如果启用了这个标志，所有支持它的操作都会平滑它们正在绘制的图形的角。让我们比较一下启用和禁用这个标志时的差异：
- en: '![](img/d379d55a-4833-4c1d-b931-374de6124d95.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d379d55a-4833-4c1d-b931-374de6124d95.png)'
- en: On the left, we've the three lines with the `AntiAlias` flag enabled, and on
    the right, we've the same three lines with the `AntiAlias` flag disabled. We can
    only appreciate a difference on the rounded edges, but the result is smoother
    and nicer. Not all operations and primitives support it and might have an impact
    on performance, so we need to be careful when using this flag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边，我们启用了`AntiAlias`标志的三条线，在右边，我们禁用了`AntiAlias`标志的同样三条线。我们只能在圆角上看到差异，但结果更平滑、更美观。并非所有的操作和基本图形都支持这个标志，并且可能会影响性能，因此在使用这个标志时需要小心。
- en: We can also draw multiple lines using another method called `drawLine(float[]
    points, int offset, int count, Paint paint)` or its simpler form `drawLine(float[]
    points, Paint paint)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一个名为`drawLine(float[] points, int offset, int count, Paint paint)`的方法或其简化形式`drawLine(float[]
    points, Paint paint)`来绘制多条线。
- en: This method will draw a single line for each set of the four entries into the
    array; it would be like calling `drawLine(array[index], array[index + 1], array[index
    + 2], array[index +3], paint)`, incrementing the index by `4`, and repeating this
    process until the end of the array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将为数组中的每组四个条目绘制一条线；这就像调用`drawLine(array[index], array[index + 1], array[index
    + 2], array[index +3], paint)`，将索引增加`4`，并重复此过程直到数组末尾。
- en: On the first method, we could also specify the amount of lines to draw and from
    which offset we start inside the array.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们还可以指定要绘制的线条数量以及从数组内部哪个偏移量开始。
- en: 'Now, let''s go to the task we had and draw the border:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来完成我们之前的任务并绘制边框：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s simply drawing the same arc, but with this new `Paint`. One small detail:
    as the border width grows centered from where it''s drawing the stroke, we need
    to reduce the size of the arc by `BORDER_SIZE /2`. Let''s see the result:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是用这个新的`Paint`绘制相同的圆弧。一个小细节：由于边框宽度从绘制笔划的位置中心向外增长，我们需要将圆弧的大小减少`BORDER_SIZE /
    2`。让我们看看结果：
- en: '![](img/3f04c547-60cf-4301-b7d6-a3eade43e39f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f04c547-60cf-4301-b7d6-a3eade43e39f.png)'
- en: 'We''re missing the inner border, but that''s normal because, if we remember
    from our previous chapters, that part is there because we''re clipping it out,
    not because `drawArc` is drawing it that way. We can do a small trick to draw
    this internal border. We''ll draw another arc with the size of the clipping area,
    but just the stroke:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少内部边框，但这很正常，因为如果我们从之前的章节中记得，这部分存在是因为我们将其裁剪掉了，而不是因为`drawArc`以这种方式绘制。我们可以用一个小技巧来绘制这个内部边框。我们将绘制一个与裁剪区域大小相同的圆弧，但只绘制边框：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we''ve applied the same logic with the border size, but the other way
    around: we draw the arc slightly bigger instead of smaller.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对边框大小应用了相同的逻辑，但反过来：我们绘制稍微大一点的圆弧，而不是小一点的。
- en: 'Let''s see the results:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/be9fb693-b67d-4b2d-a9e1-855d5230794b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be9fb693-b67d-4b2d-a9e1-855d5230794b.png)'
- en: We've mentioned earlier in this book, but it's important not to create new `Paint`
    objects in the `onDraw()` method or basically, in any method that will be called
    every time a frame is drawn. We might be tempted as, in some cases, it feels convenient;
    however, avoid the temptation and create the objects in the class constructor
    or just reuse the objects. We can change the `Paint` class instance properties
    and reuse it to paint with different colors or with different styles.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书的一开始提到过，但重要的是不要在`onDraw()`方法中或基本上在任何每次绘制帧时都会被调用的方法中创建新的`Paint`对象。在某些情况下，我们可能觉得这样做很方便；然而，抵制诱惑，在类构造函数中创建对象或仅仅复用对象。我们可以更改`Paint`类实例属性并复用它来绘制不同的颜色或样式。
- en: Find the entire source code of this example in the `Example13-Paint` folder
    on the GitHub repository.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库的`Example13-Paint`文件夹中找到这个例子的完整源代码。
- en: We'll be playing more with the `Paint` object and its properties, but now, let's
    move to drawing more primitives.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更多地玩转`Paint`对象及其属性，但现在，让我们开始绘制更多的基础图形。
- en: Drawing more primitives
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制更多的基础图形
- en: 'Let''s start by the simplest drawing operations: `drawColor(int color)`, `drawARGB(int
    a, int r, int g, int b)`, `drawRGB(int r, int g, int b),` and `drawPaint(Paint
    paint)`. These will fill the entire `canvas`, taking into account the clipping
    area.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的绘图操作开始：`drawColor(int color)`，`drawARGB(int a, int r, int g, int b)`，`drawRGB(int
    r, int g, int b)`，以及`drawPaint(Paint paint)`。这些将填充整个`canvas`，考虑到裁剪区域。
- en: Let's move forward to `drawRect()` and `drawRoundRect()`. These two methods
    are quite simple too, `drawRect()` will draw a rectangle and `drawRoundRect()`
    will draw a rectangle with rounded borders.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`drawRect()`和`drawRoundRect()`。这两个方法也非常简单，`drawRect()`将绘制一个矩形，而`drawRoundRect()`将绘制具有圆角边框的矩形。
- en: We can use both methods directly, specifying the coordinates or using `Rect`.
    Let's create a simple example that will draw a new random rounded rectangle every
    time the view is drawn or it’s `onDraw()` method is called.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用这两种方法，指定坐标或使用`Rect`。让我们创建一个简单的例子，它将在每次绘制视图或调用其`onDraw()`方法时绘制一个新的随机圆角矩形。
- en: 'To start, lets define two `ArrayLists`; one will hold the coordinates and the
    other will hold the color information of that rectangle:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义两个`ArrayLists`；一个将保存矩形的坐标，另一个将保存矩形的颜色信息：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also declared a `Paint` object that we''ll use to draw all the rounded rectangles.
    Let''s now initialize them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了一个`Paint`对象，用于绘制所有圆角矩形。现在让我们来初始化它们：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've set the paint object style to `Paint.Style.FILL` and set the `AntiAlias`
    flag, but we haven't set the color. We'll do so before drawing each rectangle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 paint 对象的样式设置为 `Paint.Style.FILL` 并设置了 `AntiAlias` 标志，但我们还没有设置颜色。我们将在绘制每个矩形之前这样做。
- en: 'Let''s now implement our `onDraw()` method. To start, we''ll add four new random
    coordinates. As `Math.random()` returns a value from `0` to `1`, we multiply it
    by the current view width and height to get a proper view coordinate. We also
    generate a new random color with full opacity:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现我们的 `onDraw()` 方法。首先，我们将添加四个新的随机坐标。由于 `Math.random()` 返回从 `0` 到 `1` 的值，我们将其乘以当前视图的宽度和高度以获得适当的视图坐标。我们还生成了一个具有完全不透明度的新随机颜色：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, we'll loop with all the random points we added and take the `4` of them
    at the time, assuming the first two will be the starting X and Y and the latter
    two will be the ending X and Y coordinates of the rectangle. We hardcoded `40`
    as the angle of the rounded edges. We can play with this value to change the amount
    of roundness.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历我们添加的所有随机点，并一次取 `4` 个，假设前两个将是矩形的起始 X 和 Y，后两个将是矩形的结束 X 和 Y 坐标。我们将圆角的角度硬编码为
    `40`。我们可以调整这个值来改变圆角的大小。
- en: 'We''ve introduced bitwise operations on colors. We know we can store a color
    in a 32-bit integer value, and usually, in ARGB format. That gives us 8 bits for
    each component. Doing bitwise operations, we can easily manipulate colors. For
    more information on bitwise operations, please refer to:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了颜色上的位运算。我们知道可以将颜色存储在32位整数值中，通常是以 ARGB 格式。这样每个分量就有8位。通过位运算，我们可以轻松地操作颜色。关于位运算的更多信息，请参考：
- en: '[https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[位运算](https://en.wikipedia.org/wiki/Bitwise_operation)。'
- en: To finish, if we have less than `100` rectangles or `400` coordinates in our
    array, we post an `Invalidate` event delayed by `20` milliseconds. It is only
    for demonstration purposes and to show that it is adding and drawing more rectangles.
    The `drawRoundRect()` method can easily be changed by `drawRect()` by just removing
    the two hardcoded `40`s as the angle of the rounded edges.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们数组中的矩形少于 `100` 个或坐标少于 `400` 个，我们会发送一个延迟 `20` 毫秒的 `Invalidate` 事件。这只是为了演示目的，并显示它正在添加和绘制更多的矩形。通过仅移除两个硬编码的
    `40` 作为圆角的角度，`drawRoundRect()` 方法可以很容易地更改为 `drawRect()`。
- en: 'Let''s see the result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/bd7c0838-689e-4951-b557-940f215def1a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd7c0838-689e-4951-b557-940f215def1a.png)'
- en: For the full source code, check the `Example14-Primitives-Rect` folder in the
    GitHub repository.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整源代码，请检查 GitHub 仓库中的 `Example14-Primitives-Rect` 文件夹。
- en: 'Let''s continue with other primitives, for example, `drawPoints`. The `drawPoints(float[]
    points, Paint paint)` method will simply draw a list of points. It will use the
    stroke width and the stroke `Cap` of the `paint` object. For instance, a quick
    example that draws few random lines and also draws a point both at the beginning
    and at the end of each line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论其他原语，例如 `drawPoints`。`drawPoints(float[] points, Paint paint)` 方法将简单地绘制一系列点。它将使用
    `paint` 对象的笔触宽度和笔触 `Cap`。例如，一个快速示例，绘制几条随机线，并在每条线的开始和结束处都绘制一个点：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s see the result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/c54012c6-98f1-4eff-b43d-ce100ae7acf6.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c54012c6-98f1-4eff-b43d-ce100ae7acf6.png)'
- en: We're creating the points array here on the `onDraw()` method, but it's done
    only once.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的 `onDraw()` 方法中创建 points 数组，但这只做一次。
- en: Check the full source code of this example in the `Example15-Primitives-Points`
    folder, in the GitHub repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库的 `Example15-Primitives-Points` 文件夹中查看这个例子的完整源代码。
- en: 'Building on top of the previous example, we can easily introduce the `drawCircle`
    primitive. Let''s change the code a bit though; instead of generating only pairs
    of random values, let''s generate three random values. The first two will be the
    `X` and `Y` coordinate of the circle and the third the circle''s radius. In addition,
    let''s remove the lines for the sake of clarity:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例的基础上，我们可以轻松引入 `drawCircle` 原语。不过，让我们稍微改一下代码；不是只生成随机值对，而是生成三个随机值。前两个将是圆的
    `X` 和 `Y` 坐标，第三个是圆的半径。此外，为了清晰起见，我们删除了线条：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ve also initialized our `paint` object on our class constructor:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在类构造函数中初始化了 `paint` 对象：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s see the result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/cb2b47d2-cd97-4573-b4aa-3a21886b8c4e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb2b47d2-cd97-4573-b4aa-3a21886b8c4e.png)'
- en: Check the full source code of this example on the `Example16-Primitives-Circles`
    folder, in the GitHub repository.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库的 `Example16-Primitives-Circles` 文件夹中查看这个例子的完整源代码。
- en: To find out about all the primitives, modes, and methods to draw on a `Canvas`,
    check the Android documentation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关在`Canvas`上绘制所有基本图形、模式和方法的详细信息，请查看Android文档。
- en: Paths can be considered as containers of primitives, lines, curves, and other
    geometric shapes that, as we already seen, can be used as clipping regions, drawn,
    or used to draw text on it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将Path视为包含基本图形、线条、曲线以及其他几何形状的容器，正如我们已经看到的，它们可以用作裁剪区域、绘制或在其上绘制文本。
- en: 'To begin, let''s modify our previous example and convert all the circles to
    a `Path`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改之前的示例，并将所有圆转换为`Path`：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We don't need to store the points, so we declared it as a local variable. We
    created a `Path` object instead. Now that we have this `Path` with all the circles
    in it, we can draw it by calling the `drawPath(Path path, Paint paint)` method
    or use it as a clipping mask.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要存储点，因此将其声明为局部变量。我们创建了一个`Path`对象。现在我们有了这个包含所有圆的`Path`，可以通过调用`drawPath(Path
    path, Paint paint)`方法绘制它，或者用作裁剪遮罩。
- en: 'We added an image to our project and we''ll draw it as a background image,
    but we''ll apply a clipping mask defined by our `Path` to make things interesting:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向项目中添加了一张图片，并将其作为背景图像绘制，但我们将应用由我们的`Path`定义的裁剪遮罩以增加趣味：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s see the result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/3d2481dd-8a7f-49c3-b050-5f7b4929fa05.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d2481dd-8a7f-49c3-b050-5f7b4929fa05.png)'
- en: To see the full source code of this example, check the `Example17-Paths` folder
    on the GitHub repository.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例的完整源代码，请检查GitHub仓库中的`Example17-Paths`文件夹。
- en: 'Checking the Android documentation about Paths, we can see that there are a
    lot of methods to add primitives to a `Path`, for example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 查看有关Paths的Android文档，我们可以看到有很多方法可以向`Path`添加基本图形，例如：
- en: '`addCircle()`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCircle()`'
- en: '`addRect()`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addRect()`'
- en: '`addRoundRect()`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addRoundRect()`'
- en: '`addPath()`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addPath()`'
- en: However, we're not limited to these methods, we can also add lines or displace
    where our path will start our next element using the `lineTo` or `moveTo` methods,
    respectively. In the case we want to use relative coordinates, the `Path` class
    provides us with the methods `rLineTo` and `rMoveTo` that assumes that the given
    coordinates are relative from the last point of the `Path`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不仅限于这些方法，我们还可以使用`lineTo`或`moveTo`方法添加线条或位移我们path的下一个元素的起始位置。如果我们想使用相对坐标，`Path`类为我们提供了`rLineTo`和`rMoveTo`方法，这些方法假设给定的坐标相对于`Path`的最后一个点。
- en: For additional information about `Path` and its methods, check the Android documentation
    website. We can do so, using the methods `cubicTo` and `quadTo`. A Bezier curve
    consists of control points that control the shape of the smooth curve. Let's build
    a quick example by adding control points each time the user taps on the screen.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Path`及其方法的更多信息，请查看Android文档网站。我们可以使用`cubicTo`和`quadTo`方法来实现。贝塞尔曲线由控制点组成，这些控制点控制平滑曲线的形状。让我们构建一个快速示例，通过在用户每次点击屏幕时添加控制点。
- en: 'First, let''s define two `Paint` objects, one for the Bezier lines and another
    to draw the control points for reference:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义两个`Paint`对象，一个用于贝塞尔线，另一个用于绘制控制点以供参考：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Control points will be drawn as round red dots, while the Bezier lines will
    be drawn as thinner white lines. As we''re initializing our objects, let''s also
    define an empty `Path` and a float array to store the points:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 控制点将以红色的圆点绘制，而贝塞尔线将以较细的白色线条绘制。在我们初始化对象时，也定义一个空的`Path`和浮点数数组来存储点：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's override `onTouchEvent()` to add the point where the user tapped
    the screen and trigger a redraw of our custom view by calling the invalidate method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重写`onTouchEvent()`，以添加用户点击屏幕的位置，并通过调用invalidate方法触发我们自定义视图的重绘。
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On our `onDraw()` method, let''s first check if we have already three points.
    If that is the case, let''s add a cubic Bezier to our `Path`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`onDraw()`方法中，首先检查是否已经有三个点。如果是这样，让我们向`Path`添加一个三次贝塞尔曲线：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `currentIndex` maintains the last index of the point array that has been
    inserted into the `Path`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentIndex`保持已插入到`Path`的点数组最后一个索引。'
- en: 'Now, let''s draw the `Path` and the points:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制`Path`和点：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s see the result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '![](img/7f6bcce8-2242-4eba-887b-629a65ee7777.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f6bcce8-2242-4eba-887b-629a65ee7777.png)'
- en: See the full source code of this example on the `Example18-Paths` folder, in
    the GitHub repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库的`Example18-Paths`文件夹中查看此示例的完整源代码。
- en: Drawing text
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制文本
- en: 'Text can be considered a primitive from the point of view of `Canvas` operations,
    but we''ve put it here on its own section, as it''s quite important. Instead of
    starting with the simplest example, as we''ve just introduced Paths, we''ll continue
    our previous example and draw the text on top of the `Path`. To draw the text,
    we''ll reuse the `Paint` object for the Bezier curve, but we''ll add some text
    parameters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Canvas`操作的角度来看，文本可以被认为是一个基本元素，但我们将它单独放在这里，因为它非常重要。我们没有从最简单的例子开始，因为我们刚刚介绍了路径，我们将继续上一个例子，在`Path`顶部绘制文本。要绘制文本，我们将重用贝塞尔曲线的`Paint`对象，但我们将添加一些文本参数：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This sets the size of the text and also aligns it to the center of the `Path`,
    so every time we add new points, the text position will adapt to remain at the
    center. To draw the text, we simply call the `drawTextOnPath()` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了文本的大小，并将文本对齐到`Path`的中心，这样每次我们添加新点时，文本位置都会适应保持居中。要绘制文本，我们只需调用`drawTextOnPath()`方法：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This was a very quick addition to our code, but if we execute our application,
    we can see the results with the text over the `Path` lines:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们代码中一个非常快速的增加，但如果我们执行我们的应用程序，我们可以看到文本覆盖在`Path`线条上的结果：
- en: '![](img/0dad2444-d349-4e37-891e-1bcf98d01ac0.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dad2444-d349-4e37-891e-1bcf98d01ac0.png)'
- en: Take into account that we're drawing the same things as we drawn before, but
    we can freely use the `Path` just as the guide for the text. There is no need
    to draw it or to draw the control points.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在绘制之前绘制过的相同内容，但我们可以自由地使用`Path`作为文本的指导。无需绘制它或绘制控制点。
- en: Check the full source code of this example on the `Example19-Text folder`, in
    the GitHub repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库的`Example19-Text folder`中查看这个例子的完整源代码。
- en: We've started drawing text on Paths, as we had the example almost built. However,
    there are more simple methods for drawing text. For instance, we can just draw
    a text on a specific position of the screen by calling either `canvas.drawText(String
    text, float x, float y, Paint paint)` or `canvas.drawText(char[] text, float x,
    float y, Paint paint)`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始在路径上绘制文本，因为我们的例子几乎已经构建完成。然而，还有更简单的方法来绘制文本。例如，我们可以通过调用`canvas.drawText(String
    text, float x, float y, Paint paint)`或`canvas.drawText(char[] text, float x, float
    y, Paint paint)`在屏幕上的特定位置绘制文本。
- en: 'These methods will just do their job, but they will not check if the text fits
    in the available space and they will definitely not split and wrap the text. To
    do so, we''ll have to do it ourselves. The `Paint` class provides us with methods
    to measure text and calculate text boundaries. For example, we created a small
    helper method that returns the width and height of `String`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法只会完成它们的工作，但它们不会检查文本是否适合可用空间，而且绝对不会拆分和换行文本。要做到这一点，我们必须自己动手。`Paint`类为我们提供了测量文本和计算文本边界的方法。例如，我们创建了一个小助手方法，它返回`String`的宽度和高度：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ve used the text boundary to get the text height, but we''ve used the `measureText()`
    method to get the text width. There are some differences on how the size is computed
    in both methods. Although it''s not currently properly documented on the Android
    documentation site, there is an old discussion about this on Stack Overflow:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了文本边界来获取文本高度，但我们使用了`measureText()`方法来获取文本宽度。这两种方法在计算大小上有一些差异。尽管目前Android的官方文档网站上没有正确记录这一点，但在Stack
    Overflow上有一个关于这个问题的旧讨论：
- en: '[http://stackoverflow.com/questions/7549182/android-paint-measuretext-vs-gettextbounds](http://stackoverflow.com/questions/7549182/android-paint-measuretext-vs-gettextbounds).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/7549182/android-paint-measuretext-vs-gettextbounds](http://stackoverflow.com/questions/7549182/android-paint-measuretext-vs-gettextbounds)。'
- en: However, we shouldn't implement our own text splitting method. If we want to
    draw a large text and we know it might need splitting and wrapping, we can use
    the `StaticLayout` class. In the example here, we'll create a `StaticLayout` with
    the width of half the view width.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不应该实现自己的文本拆分方法。如果我们想要绘制大段文本，并且我们知道它可能需要拆分和换行，我们可以使用`StaticLayout`类。在这个例子中，我们将创建一个宽度为视图宽度一半的`StaticLayout`。
- en: 'We can implement it on our `onLayout()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`onLayout()`方法中实现它：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our `onDraw()` method, we draw it centered on the screen. As we know, the
    layout width was half the view width; we know we have to displace it by a quarter
    of the width.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`onDraw()`方法中，我们将它绘制在屏幕中心。我们知道，布局宽度是视图宽度的一半；我们知道我们需要将其位移到宽度的四分之一处。
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the result:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![](img/3ff97fdf-3797-4dc0-a960-57061d606d7d.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ff97fdf-3797-4dc0-a960-57061d606d7d.png)'
- en: Check the full source code of this example in the `Example20-Text` folder, in
    the GitHub repository.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库的`Example20-Text`文件夹中查看这个示例的完整源代码。
- en: Transformations and operations
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换和操作
- en: We already used some `canvas` transformations on our custom view before, but
    let's revisit the `Canvas` operations we can use. First of all, let's see how
    we can concatenate these transformations. Once we've used a transformation, any
    other transformation we use will be concatenated or applied on top of our previous
    operations. To avoid this behavior, we've to call the `save()` and `restore()`
    methods we also used before. To see how transformations build on top of each other,
    let's create a simple example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义视图上，我们已经使用了一些`canvas`变换，但让我们重新审视我们可以使用的`Canvas`操作。首先，让我们看看如何连接这些变换。一旦我们使用了变换，我们使用的任何其他变换都会被连接或应用在我们之前的操作之上。为了避免这种行为，我们必须调用我们之前也使用过的`save()`和`restore()`方法。为了了解变换是如何层层叠加的，让我们创建一个简单的示例。
- en: 'First, let''s create a `paint` object on our constructor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们构造函数中创建一个`paint`对象：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s calculate the rectangle size based on the size of the screen on
    the `onLayout()` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`onLayout()`方法中根据屏幕大小计算矩形尺寸：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also stored the starting time, which we will use it for a quick and simple
    animation afterwards. Now, we''re ready to implement the `onDraw()` method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还存储了开始时间，稍后我们将使用它进行快速简单的动画。现在，我们准备实现`onDraw()`方法：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've first calculated the `angle` based on the amount of time that passed since
    the beginning. Animations should always be based on time and not on the amount
    of frames drawn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先根据自开始以来经过的时间计算了`angle`。动画应该总是基于时间，而不是基于绘制的帧数。
- en: Then, we draw the background, store the `canvas` state by calling `canvas.save()`,
    and perform a translation to the center of the screen. We'll base all transformations
    and drawings from the center, instead of the top left corner.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们绘制背景，通过调用`canvas.save()`保存`canvas`状态，并进行平移到屏幕中心。我们将所有的变换和绘制都基于中心，而不是左上角。
- en: In this example, we'll draw 15 rectangles where each one will be increasingly
    rotated and scaled. As transformations are applied on top of each other, this
    is very easy to do in a simple `for()` loop. It is important to draw the rectangle
    from `-rectSize / 2` to `rectSize / 2` instead of `0` to `rectSize`; otherwise,
    it will be rotating from one angle.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将绘制15个矩形，每个矩形都会逐渐旋转和缩放。由于变换是层层叠加的，因此在一个简单的`for()`循环中很容易实现。重要的是要从`-rectSize
    / 2`绘制到`rectSize / 2`，而不是从`0`到`rectSize`；否则，它将从一个角度旋转。
- en: Change the code line where we draw the rectangle to `canvas.drawRect(0, 0, rectSize,
    rectSize, paint)` to see what happens.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们绘制矩形的代码行，改为`canvas.drawRect(0, 0, rectSize, rectSize, paint)`，看看会发生什么。
- en: 'There is, though, an alternative to this method: we can use pivot points on
    the transformations. Both `rotate()` and `scale()` methods support two additional
    `float` parameters that are the pivot point coordinates. If we look at the source
    code implementation of `scale(float sx, float sy, float px, float py)`, we can
    see it is simply applying a translation, calling the simple scale method, and
    applying the opposite translation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有一个替代方案：我们可以在变换中使用枢轴点。`rotate()`和`scale()`方法都支持两个额外的`float`参数，它们是枢轴点的坐标。如果我们查看`scale(float
    sx, float sy, float px, float py)`的源代码实现，我们可以看到它只是应用了一个平移，调用了简单的缩放方法，然后应用了相反的平移：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using this method, we could have implemented the `onDraw()` method this other
    way:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以以另一种方式实现`onDraw()`方法：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'See the following screenshot to see how the rectangles are concatenated:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图，了解矩形的连接方式：
- en: '![](img/8235837e-4edc-49f9-9f1e-842f8fe94de8.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8235837e-4edc-49f9-9f1e-842f8fe94de8.png)'
- en: In addition, the source code of this full example can be found in the `Example21-Transformations`
    folder on the GitHub repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个完整示例的源代码可以在GitHub仓库的`Example21-Transformations`文件夹中找到。
- en: 'We''ve seen some basic operations on matrices, such as `scale()`, `rotate(),`
    and `translate()`, but `canvas` provides us with some more additional methods:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了一些关于矩阵的基本操作，比如`scale()`、`rotate()`和`translate()`，但`canvas`为我们提供了更多附加方法：
- en: '`skew`: This applies a skew transformation.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skew`：这应用一个斜切变换。'
- en: '`setMatrix`: This lets us compute a transformation matrix and directly sets
    it to our `canvas`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMatrix`：这让我们计算一个变换矩阵，并直接将其设置到我们的`canvas`中。'
- en: '`concat`: This is similar to the previous case. We can concatenate any matrix
    to the current one.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat`：这类似于前面的情况。我们可以将任何矩阵与当前矩阵进行拼接。'
- en: Putting it all together
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将它们全部组合在一起
- en: So far, we've seen many different drawing primitives, clipping operations, and
    matrix transformations, but the most interesting part is when we combine it all
    together. In order to build great custom views, we've to use many different kinds
    of operations and transformations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多不同的绘图原语、剪辑操作和矩阵变换，但最有趣的部分是我们将它们全部组合在一起的时候。为了构建出色的自定义视图，我们必须使用许多不同类型的操作和变换。
- en: However, having so many operations available is a double-edged sword. We have
    to be careful when adding this complexity to our custom view, as we can compromise
    performance quite easily. We should check if we're applying, for example, too
    many or unnecessary clippings operations or if we aren’t optimizing enough or
    we aren’t maximizing reuse of clipping and transformation operations. In that
    case, we might even use the `quickReject()` method from the `canvas` object to
    quickly discard areas that will fall outside the clipping area.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拥有如此多的操作是一个双刃剑。在向自定义视图添加这种复杂性时，我们必须小心，因为很容易损害性能。我们应该检查是否应用了过多的或不必要的剪辑操作，或者是否没有足够优化，或者没有最大化剪辑和变换操作的重用。在这种情况下，我们甚至可以使用`canvas`对象的`quickReject()`方法快速丢弃将落在剪辑区域外的区域。
- en: Also, we need to keep track of all `save()` and `restore()` we're performing
    to our `canvas`. Performing additional `restore()` methods, not only means we
    have an issue with our code, but  is an actual error. If we have to change to
    different previously saved states, we can use the `restoreToCount()` method together
    with saving the state number in the call we do to save the state.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们需要跟踪我们对`canvas`执行的所有`save()`和`restore()`。执行额外的`restore()`方法，不仅意味着我们的代码存在问题，实际上它是一个错误。如果我们需要改变到不同的先前保存的状态，我们可以使用`restoreToCount()`方法，并结合保存状态编号的调用来保存状态。
- en: As we've mentioned before, and will mention again in the following chapters,
    avoid to allocate memory or create new instances of an object, inside the `onDraw()`
    method; especially remember this remark if at some point you think you have to
    create a new instance of a `paint` object inside the `onDraw()`. Reuse `paint`
    objects or initialize them, for instance, on the class constructor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，并在后续章节中会再次提到，避免在`onDraw()`方法中分配内存或创建对象的新实例；特别是如果你认为需要在`onDraw()`内部创建一个新的`paint`对象实例时，请记住这一点。重用`paint`对象或在类构造函数中初始化它们。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've seen how to draw more complex graphic primitives, transform
    them, and use clipping operations while drawing our custom view. Most of the time,
    these primitives by themselves don't give us too much value but, we've also saw
    many quick examples of how to put many of them together and create something useful.
    We didn't cover all the possible methods, operations, or transformations, as it
    will be a lot of information and will not be useful; it may seem like reading
    a language dictionary. To stay up to date with all the possible methods and drawing
    primitives, keep checking the developer's Android documentation and stay aware
    of the release notes of every new release of Android to check what's new.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何绘制更复杂的图形原语，变换它们，并在绘制自定义视图时使用剪辑操作。大多数情况下，这些原语本身并不能为我们提供太多价值，但我们还看到了许多快速示例，展示了如何将它们组合在一起创建有用的东西。我们没有涵盖所有可能的方法、操作或变换，因为这将包含大量信息并且可能不实用；它可能会像是阅读一本语言字典。要了解所有可能的方法和绘图原语，请持续查看开发者的Android文档，并关注每个新版本的Android的发行说明，以了解新增内容。
- en: In the next chapter, we'll see how to use OpenGL ES to add 3D rendering to our
    custom view.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何使用OpenGL ES为自定义视图添加3D渲染。
