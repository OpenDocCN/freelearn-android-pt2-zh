- en: Chapter 8. Writing a Match-3 Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling asynchronous multi-touch input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the audio playback mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shutting down the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the main loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multiplatform gaming engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the match-3 game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the game field logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing user interaction within a game loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we start putting together the recipes from the previous chapters.
    Most of the following recipes are aimed at improving and integrating the material
    scattered over the preceding chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The example project of this chapter is actually a simplified version of the
    MultiBricks game published by the books'' authors on Google Play: [http://play.google.com/store/apps/details?id=com.linderdaum.engine.multibricks](http://play.google.com/store/apps/details?id=com.linderdaum.engine.multibricks).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling asynchronous multi-touch input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we learned how to handle multi-touch events on Android.
    However, our simple example has one serious issue. Android touch events are sent
    asynchronously and can interfere with the game logic. As such, we need to create
    a queue to process events in a controllable way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out the Processing multi-touch events on Android recipe from [Chapter
    7](ch07.html "Chapter 7. Cross-platform UI and Input Systems"), *Cross-platform
    UI and Input System,* before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter we invoked the touch handler directly from an asynchronous
    JNI callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we have to store all the events in a queue rather then processing
    them immediately. The queue will hold the parameters to `GestureHandler_SendMotion()`
    in a struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The queue implementation relies on `std::vector`, holding touch events and
    `Mutex`, providing queue access synchronization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the work our new `SendMotion()` JNI callback has to do is pack the touch
    event parameters into the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now process the touch events whenever we like.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle the touch events in the queue, we extend the implementation of the
    `DrawFrame()` JNI callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the scope of the `Lock` variable inside the additional`{}`. We need it
    because the mutex variable must be unlocked to prevent deadlocks, before proceeding
    with the game logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the `jni/Wrappers.cpp` file from the example `1_Game` for the complete implementation,
    which can be retrieved from [www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our new approach is much more robust. However, the touch event timestamps generated
    inside `GestureHandler_SendMotion()`are slightly robust and do not correspond
    to the actual time of touches any more. This introduces a delay approximately
    equal to a single frame rendering time and can become an issue in multiplayer
    games. We leave the exercise of adding genuine timestamps to the reader. This
    can be done by extending the `sSendMotionData` struct with a timestamp field,
    which is assigned inside the JNI callback `SendMotion()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Processing multi-touch events on Android* recipe in [Chapter 7](ch07.html
    "Chapter 7. Cross-platform UI and Input Systems"), *Cross-platform UI and Input
    Systems*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the audio playback mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters we learned how to play audio using OpenAL on Android.
    Our basic audio subsystem implementation in [Chapter 5](ch05.html "Chapter 5. Cross-platform
    Audio Streaming"), *Cross-platform Audio Streaming,* lacked automatic management
    of audio sources; we had to control them manually on a separate thread. Now, we
    will put all of that code into a new audio subsystem usable in a real game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete source code for this recipe is integrated in the example `1_Game`
    and can be found in the files `sound/Audio.h` and `sound/Audio.cpp`. Other files
    in the `sound` folder provide decoding capabilities for different audio formats—check
    them out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need our `clAudioThread` class to take care of active audio sources. Let''s
    extend it with methods responsible for their registration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a container for active sources as well as mutex to control the
    access to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method `clAudioThread::Run()` gets more complicated. Besides the initialization
    of OpenAL, it has to update active audio sources so they can pull the audio data
    from their providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The inner loop updates active audio sources based on the elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following scope for the mutex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Audio sources are updated every 100 milliseconds. This value is purely empirical
    and is suitable for non-realtime audio playback as a tradeoff between the audio
    subsystem lag and power consumption of your Android device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Registration methods are needed to maintain the `FActiveSources` container.
    Their implementations can be found in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t add the same audio source multiple times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just find the source and erase it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The full implementation of this new `clAudioThread` class can be found in the
    `sound/Audio.cpp` and `sound/Audio.h` files in the example `1_Game`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To take advantage of the new `AudioThread` class, audio sources must register
    themselves. We extend the constructor and the destructor of the `clAudioSource`
    class to perform RAII registration ([http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now audio playback is very simple. Declare a global audio thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Start it from the main thread and wait until initialization completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can invoke other useful initialization routines between the `g_Audio.Start()`
    and `g_Audio.Wait()` calls, to take advantage of asynchronous initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and configure a new audio source and play it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All audio management is now done on another thread.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our audio thread is capable of playing different types of audio files such as
    `.ogg`, `.xm`, `.it,` and `.s3m` files. You can hide the creation of an appropriate
    wavedata provider by adding another method to `AudioSource`. Just switch the selection
    based on the file extension to create `ModPlugProvider` or `OggProvider` instances.
    We leave this as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Initializing OpenAL and playing the .wav files,* *Decoding Ogg Vorbis files*,
    *Decoding tracker music using ModPlug*, and *Streaming sounds* recipes in [Chapter
    5](ch05.html "Chapter 5. Cross-platform Audio Streaming"), *Cross-platform Audio
    Streaming*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shutting down the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smartphones' batteries are very limited making mobile devices very sensitive
    to any background activities they run. Our previous application samples stayed
    alive after the user switched to another activity. This means that instead of
    respecting the Android activity lifecycle ([http://developer.android.com/training/basics/activity-lifecycle](http://developer.android.com/training/basics/activity-lifecycle))
    and pausing our application, we continued to waste precious system resources in
    the background. It's time we learnt how to handle the `onPause()` Android callback
    in our native code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are not familiar with Android Activity lifecycle, refer to the developer
    manual: [http://developer.android.com/training/basics/activity-lifecycle/index.html](http://developer.android.com/training/basics/activity-lifecycle/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Android application does not have to implement all of the lifecycle methods.
    Our strategy for lifecycle management will be very simple; save game state and
    terminate an application once the `onPause()` method is called. We need to write
    some Java code to make it work. Add this code to your `Activity` class, in our
    case it is `Game1Activity` in the `Game1Activity.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ExitNative()` JNI method in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can implement the native `OnStop()`callback in our game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical implementation of the `OnStop()` callback will save the game state,
    so it can be restored when the game resumes later. Since our first game does not
    require any saving, we will provide only an empty implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You may want to implement game saving later as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the `OnStop()` method work on Windows, just call it after the exit
    from the main loop in `Wrapper_Windows.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The solution is now portable, and all of the logic can be debugged on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing the main loop*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the main loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters our code examples used the `OnTimer()` callback with
    a rough fixed timestep to update the state and the `OnDrawFrame()` callback to
    render graphics. This is not suitable for a real-time game where we should update
    the state based on the real time elapsed since the last frame. However, it is
    still desirable to use a small fixed timestep in the call to `OnTimer()`. We can
    solve this problem by interleaving calls to `OnTimer()` and `OnDrawFrame()` in
    a tricky fashion and put this logic into a game main loop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a very interesting article called **Fix Your Timestep!** available
    at [http://gafferongames.com/game-physics/fix-your-timestep](http://gafferongames.com/game-physics/fix-your-timestep),
    which explains in great detail different approaches to the implementation of a
    game main loop and why fixed timesteps are important.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic of the game main loop is platform-independent and can be put into
    a method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetSeconds()` returns monotonous time in seconds since the system start. However,
    only frame deltas matter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will update the game logic with a fixed timestep that corresponds to a game
    running at 60 frames per second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, we need a failsafe mechanism to prevent excessive slowdowns of the game
    due to slow rendering speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we accumulate the elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And invoke a sequence of the `OnTimer()` callbacks accordingly. All of `OnTimer()`
    callbacks receive the same fixed timestep value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the game has been updated, render the next frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnDrawFrame()` callback should be called after the update. If the device
    is fast enough, `OnDrawFrame()` will be invoked after every single `OnTimer()`
    call. Otherwise, some frames will be skipped to preserve the real-time speed of
    the game logic. And in the case when the device is too slow to run even the game
    logic, our safeguard code will spring into action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The whole thing will work in slow motion, but the game can still be playable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can try to scale the value that you pass to `OnTimer()`, for example, `OnTimer(
    k * TIME_QUANTUM )`. If `k` is less than `1.0`, the game logic will become slow-motion.
    It can be used to produce effects similar to bullet time ([http://en.wikipedia.org/wiki/Bullet_time](http://en.wikipedia.org/wiki/Bullet_time)).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the application is suspended but you want it to continue running in the
    background, it is wise to omit the rendering phase altogether or change the duration
    of the update quantum. You can do it by adding the `Paused` state to your game
    and check it in the main loop, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will help to save precious CPU cycles while still running the game logic
    simulation in the background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Implementing timing in physics* recipe in [Chapter 2](ch02.html "Chapter 2. Porting
    Common Libraries"), *Porting Common Libraries*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multiplatform gaming engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters and recipes, we handcrafted many ad hoc solutions to some
    multiplatform game development tasks. Now, we are going to combine all the relevant
    code into a nascent portable gaming engine and learn how to prepare makefiles
    for Windows and Android to build it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand what is going on in this recipe, you are advised to read through
    the chapters 1 to 7 from the beginning of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We split all our code into several logical subsystems and put them into the
    following folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`core`: This has low level facilities, such as the intrusive smartpointer and
    math library'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs`: This contains filesystem related classes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL`: This contains the official OpenGL headers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: This contains the include files of some third-party libraries'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphics`: This contains high-level graphics-related code, such as fonts,
    canvas, and images'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LGL`: This contains our OpenGL wrapper and functions-loading code together
    with the abstraction layer implemented in [Chapter 7](ch07.html "Chapter 7. Cross-platform
    UI and Input Systems"), *Cross-platform UI and Input System*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sound`: This contains audio-related classe and decoding libraries'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threading`: This contains multithreading-related classes, including mutexes,
    events, queues, and our multiplatform threads wrapper'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the code in each folder is split into classes. In our minimalistic gaming
    engine, we keep the number of classes to a reasonable minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `graphics` folder contains the implementations of the following structs
    and classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Struct `sBitmapParams` holds the parameters of the bitmaps, such as width, height,
    and pixel format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clBitmap` is an API-independent representation of a bitmap that holds
    actual pixel data together with `sBitmapParams`. It can be loaded into a clGLTexture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clCanvas` provides a mechanism for immediate rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clVertexAttribs` is an API-independent representation of 3D geometry.
    It can be loaded into a `clGLVertexArray`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clGeomServ` provides 3D geometry creation methods that return `clVertexAttribs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `iGestureResponder` is an interface to be implemented if you want to respond
    to touches or gestures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure `sMotionData` holds the current set of active touch points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clTextRenderer` provides FreeType-based text rendering facilities. It
    can render a text string with a specified font into a `clBitmap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure `sTouchPoint` represents a single touch point with an identifier,
    2D normalized float coordinates, flags, and a timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `LGL` folder holds the classes specific to OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: Structure `sUniform` represents a single uniform inside a shader program. It
    is just a name and a location index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clGLSLShaderProgram` represents a shader program written in GLSL and
    provides autoconversion capabilities between the desktop GLSL and mobile GLSL
    ES.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clGLTexture` provides access to OpenGL textures and can read `clBitmap`
    pixel data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clGLVertexArray` provides abstractions to OpenGL vertex array objects
    and vertex buffer objects. It uses data from `clVertexAttribs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Low-level classes, such as smarpointers, intrusive counters, and math-related
    code are put into the `core` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Class `clPtr` is an implementation of a reference-counted intrusive smartpointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `iObject` holds an intrusive reference counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `LRingBuffer` is an implementation of a wrap-around ring buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic math library consists of vector classes, including `LVector2`, `LVector3`,
    `LVector4`, `LVector2i`, and matrix classes, including `LMatrix3` and `LMatrix4`.
    The math library also contains minimal code for projections setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The filesystem-related code is located in the `fs` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Class `clArchiveReader` implements a `.zip` archive unpacking algorithm using
    the **libcompress** library. It is used to access resources in Android `.apk`
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clBlob` represents an array of bytes in memory that can be read or written
    to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `iRawFile` is a base class of all classes that represent a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clRawFile` represents a file on a physical filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clMemRawFile` represents a memory chunk as a file, suitable for accessing
    downloaded data (images, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clManagedMemRawFile` is similar to `MemRawFile`, but the memory is managed
    by a `Blob` object inside it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clFileMapper` is an abstraction of read-only memory-mapped files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clFileWriter` is an abstraction to write into files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clFileSystem` is a factory of streams and blobs. It provides facilities
    to manage virtual paths in our applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes `iMountPoint`, `clPhysicalMountPoint`, `clAliasMountPoint`, and `clArchiveMountPoint`
    are used to route the access to the OS native filesystem and Android `.apk` archives
    in a portable multiplatform way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sound` folder contains abstractions for our audio subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: Class `clAudioSource` represents an audio source in a virtual environment. It
    can be played, paused, or stopped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clAudioThread` updates the active sources and submits the data to the
    underlying OpenAL API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `iWaveDataProvider` abstracts the decoding of audio files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clStreamingWaveDataProvider` streams the data from audio files too large
    to be decoded into memory at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `clDecodingProvider` provides common rewinding logic for streaming audio
    providers. It is the base class for actual decoders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes `clOggProvider` and `clModPlugProvider` handle the decoding of the `.ogg`
    files with **libogg**/**libvorbis** and tracker music with **libmodplug**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `threading` folder contains portable implementations of different multithreading
    primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes `clMutex`, `LMutex`, and `iThread` implement basic low-level multithreading
    primitives in a portable way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes `clWorkerThread` and `iTask` are higher level abstractions based on
    `iThread`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes `iAsyncQueue` and `iAsyncCapsule` are used to implement asynchronous
    callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of out mini engine is located in the Engine folder within the
    examples for the last chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing the match-3 game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. Writing a Picture Puzzle Game"), *Writing
    a Picture Puzzle Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the match-3 game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to start the development of a finished **match-3** game. A match-3
    is a type of puzzle where a player needs to align tiles in order to make adjacent
    tiles disappear. Here, `3` stands for the number of same-color tiles that will
    disappear when put into adjacent positions. The following screenshot is of the
    final version of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the match-3 game](img/7785_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We use a set of 22 monomino, domino, tromino, tetromino, and pentomino shapes
    in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the match-3 game](img/7785_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since most of the impressions come from the results visualized on-screen, let
    us proceed with the essentials of how the game screen is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete ready-to-build source code is located in the `1_Game` folder of
    the supplementary materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'This game was released in 2011 by the book''s authors on Google Play in a somewhat
    extended form. You can find this game on the following websites, if you want to
    try it on your Android device immediately: [http://play.google.com/store/apps/details?id=com.linderdaum.engine.multibricks](http://play.google.com/store/apps/details?id=com.linderdaum.engine.multibricks)
    and [http://play.google.com/store/apps/details?id=com.linderdaum.engine.multibricks_free](http://play.google.com/store/apps/details?id=com.linderdaum.engine.multibricks_free).'
  prefs: []
  type: TYPE_NORMAL
- en: Authors don't mind if you use the graphical artwork from this game in your own
    projects. It is a learning tool and not a commodity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those interested in the general match-3 game mechanics can refer to the following
    Wikipedia article: [http://en.wikipedia.org/wiki/Match_3](http://en.wikipedia.org/wiki/Match_3).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entire game screen is re-rendered every frame in several steps in the `OnDrawFrame()`
    callback. Let''s walk over its source code to see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: The fullscreen background image is rendered clearing the graphics from the previous
    frame. The image is stored as a square 512 x 512 `.png` file and is rescaled to
    the full screen restoring its proportions, as shown in the following screenshot:![How
    to do it…](img/7785_08_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Power-of-two image was used to make the game compatible with old Android hardware.
    If you target OpenGL ES 3 as your minimal requirement, you can use textures of
    arbitrary sizes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is the C++ code to render the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, bind 3 textures and the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the pressed flags of control buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, render a full-screen rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `float b_Flags[]` array corresponds to the state of control buttons; the
    value of `1.0f` means the button is pressed and `0.0f` means it is released. These
    values are passed to the shader to highlight buttons accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cells of the game field are rendered on top of the background followed by the
    current shape above them:![How to do it…](img/7785_08_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Every cell of the field is just a tiny rectangle with a texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The current shape is rendered in one line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next figure is rendered near the control buttons, as shown in the following
    screenshot:![How to do it…](img/7785_08_8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code is more complicated, since we need to evaluate the bounding box of
    the shape to render it properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Render the current score text, as shown in the following screenshot:![How to
    do it…](img/7785_08_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the text changes, it is rendered into a bitmap, and the texture is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We just need to render a textured rectangle in every frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Render the game-over message if needed, as shown in the following screenshot:![How
    to do it…](img/7785_08_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is similar to text rendering, however, we can avoid caching here since
    this message box is shown infrequently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Canvas does everything required to render the text and update the texture. However,
    it is a bit slow for anything more frequent. Check out the full implementation
    in the `graphics/Canvas.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding code, we used some helper functions that might need some explanation.
    The `DrawQuad()` and `DrawTexQuad()` functions draw a single cell of the game
    field. They consist of some hardcoded values to position the cells relative to
    the background image. The following is the source code of one function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Magic constants of `800.0f` and `600.0f` appear here to convert from the coordinate
    system of the UI, which was designed for a `600×800` screen in portrait orientation,
    to the floating-point normalized coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Other magic constants are also part of the design and were chosen empirically.
    Try adjusting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DrawFigure()` method is used to draw a single shape anywhere in the game
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Skip invisible rows at the top of the game field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`DrawBorder()` function is just a shortcut to `Canvas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned that control buttons are highlighted in the fragment shader. Here
    is how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the states of the buttons as uniforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The function to check whether a rectangle contains a specified point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Store some hardcoded values corresponding to the rectangles where our control
    buttons are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the background texture and the highlighted parts. Check the files `back.png`,
    `back_high_bottom.png`, and `back_high_top.png` from the accompanying project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if buttons are pressed and choose the right texture accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Voilà! We have textured the background with all the buttons in one pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a multiplatform gaming engine*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to render the game screen. Some classes
    remained unimplemented. In this recipe, we will implement the `clBricksShape`
    class responsible for the storage and manipulation of each of the shapes that
    appear in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at how many different pentomino shapes can exist. Wikipedia provides
    a comprehensive overview: [http://en.wikipedia.org/wiki/Pentomino](http://en.wikipedia.org/wiki/Pentomino).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface of our `clBricksShape` class looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The size of shapes used in our game. We use `5x5` shapes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the colors of the cells this shape consists of. The colors are stored
    as indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The figure index defines the shape type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rotation index corresponds to the rotation angle of the figure: `0`, `1`,
    `2`, and `3` stand for `0`, `90`, `180`, and `270` degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The methods are very short and straightforward as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method `Rotate()` does not rotate the individual cells. It does nothing
    but adjust the rotation angle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Figure generation is also very simple. It is just a selection from the table
    of predefined figures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These methods are used to calculate the bounding box of the shape. Refer to
    the `game/Shape.h` file for their source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main trick behind the code in the preceding section is the table of predefined
    shapes. Its declaration is located in the `Pentomino.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. We store each and every shape in this 4D array. The content of
    the array is defined in the `Pentomino.cpp` file. The following code is the extract
    that defines all 4 rotations of a single shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The non-zero values in the array define which cells belong to the shape. The
    magnitude of the value defines the color of the cell.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing the match-3 game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the game field logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to store different shapes and render them. Let's implement some
    game logic to make these shapes interact with each other on a game field.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Writing the match-3 game* recipe to see how the game field is
    rendered.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface of `clBricksField` looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The size of our game field is `11×22`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The methods to check if the figure fits freely into a position are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method stamps the shape into the specified position of the game field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code is the main game logic. Methods to calculate and delete
    same-colored cell regions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are making a match-3 game, we pass the value of `3` to this method.
    However, the logic is general; you can play with your own values to tweak the
    gameplay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Cells of the game field are stored here. The values correspond to colors of
    the cells:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shape fitting uses simple mask checking and is trivial. We will give more attention
    to the neighbor cells calculation. It is based on the recursive flood-fill algorithm
    ([http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursively, calculate the number of neighbors to each cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Mark the cells if the number of neighbors is high enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the marked cells from the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the number of deleted regions. This is used to evaluate the current
    score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The recursive flood-fill is straightforward. The following code calculates
    the number of adjacent cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code marks the adjacent cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also another variant of game logic implemented in this project. Check
    out the method `deleteLines()`in the file `game/Field.h` to learn how to implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing user interaction within a game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipes we learned how to render the game environment and implement
    the game logic. One more important aspect of the development needs our attention:
    the user interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out the file `main.cpp` in the project `1_Game` for the full implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to implement some functions to move the currently falling shape:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enforce the game field constraints while moving a figure left or right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The source code of `MoveFigureRight()` is similar to `MoveFigureLeft()`. The
    code of `MoveFigureDown()` needs to update the score once the shape has hit the
    ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rotation code needs to check if the rotation is actually possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to call these methods in response to key presses or touches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ProcessClick()` function handles a single click. We store the position
    of the click in the `g_Pos` global variable for code simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Reset the states of the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t allow to press any buttons once the game is over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Run actions and update the buttons'' highlight states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used to implement autorepeat on a touchscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main loop of our game is implemented in the `OnTimer()` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check the values of the flags to implement a convenient auto-repeat
    on a touchscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for lines deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The auto-repeat values are picked to follow those typically used by developers
    in modern operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Our original MultiBricks game contains a Pause button. You can implement it
    as an exercise using the page-based user interface described in the [Chapter 9](ch09.html
    "Chapter 9. Writing a Picture Puzzle Game"), *Writing a Picture Puzzle Game*.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing the match-3 game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Page-based user interface* recipe in [Chapter 9](ch09.html "Chapter 9. Writing
    a Picture Puzzle Game")*, Writing a Picture Puzzle Game*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
