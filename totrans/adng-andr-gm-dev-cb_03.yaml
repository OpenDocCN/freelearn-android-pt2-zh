- en: Chapter 3. Designing Your Menu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 设计你的菜单
- en: 'In this chapter, we will begin to take a look at how to create a manageable
    menu system with AndEngine. The topics include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始了解如何使用AndEngine创建一个易于管理的菜单系统。主题包括：
- en: Adding buttons to the menu
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向菜单添加按钮
- en: Adding music to the menu
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为菜单添加音乐
- en: Applying a background
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用背景
- en: Using parallax backgrounds to create perspective
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视差背景创建透视效果
- en: Creating our level selection system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的关卡选择系统
- en: Hiding and retrieving layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏和检索图层
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Menu systems in games are essentially a map of the scenes or activities a game
    provides. In a game, a menu should look attractive and give a subtle hint of what
    to expect during gameplay. The menu should be organized and easy for a player
    to understand. In this chapter, we're going to take a look at various options
    we have which we can apply to our own games in order to create functional and
    appealing menus for any type of game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的菜单系统本质上是游戏提供的场景或活动的地图。在游戏中，菜单应该看起来吸引人，并微妙地提示在游戏过程中可以期待什么。菜单应该组织有序，便于玩家理解。在本章中，我们将看看我们可以应用到自己游戏中的各种选项，以创建适用于任何类型游戏的实用且吸引人的菜单。
- en: Adding buttons to the menu
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向菜单添加按钮
- en: In AndEngine, we can create touch-responsive buttons out of any `Entity` object
    or `Entity` object subtype. However, AndEngine includes a class called `ButtonSprite`
    whose texture representation depends on whether the `Entity` object is pressed
    or unpressed. In this recipe, we're going to take advantage of AndEngine's `ButtonSprite`
    class and override its `onAreaTouched()` method in order to add touch-responsive
    buttons to our menu and/or game's `Scene` object. Additionally, the code within
    this recipe regarding touch events can be applied to any other `Entity` object
    within our game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在AndEngine中，我们可以使用任何`Entity`对象或`Entity`对象子类型创建触摸响应的按钮。然而，AndEngine包含一个名为`ButtonSprite`的类，其纹理表示取决于`Entity`对象是被按下还是未被按下。在本教程中，我们将利用AndEngine的`ButtonSprite`类并覆盖其`onAreaTouched()`方法，以便向我们的菜单和/或游戏的`Scene`对象添加触摸响应按钮。此外，本教程关于触摸事件的代码可以应用于游戏中的任何其他`Entity`对象。
- en: Getting ready…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine. Please
    read through the entire recipe, *Working with different types of textures* in
    [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*, specifically the section regarding tiled texture regions. Next, visit
    the recipe, *Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要你对AndEngine中的`Sprite`对象有基本的了解。请通读[第一章](ch01.html "第一章. AndEngine游戏结构")中的*使用不同类型的纹理*教程，特别是关于图块纹理区域的部分。接下来，访问[第二章](ch02.html
    "第二章. 使用实体")中的*通过精灵使场景生动*教程，*使用实体*。
- en: 'Once the recipes regarding textures and sprites have been covered, create a
    new AndEngine project with an empty `BaseGameActivity` class. Finally, we will
    need to create a sprite sheet named `button_tiles.png` with two images and place
    it in the `assets/gfx/` folder of the project; one for the "unpressed" button
    representation and one for the "pressed" button representation. See the following
    image for an idea of what the image should look like. The following image is 300
    x 50 pixels, or 150 x 50 pixels per tile:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦涵盖了关于纹理和精灵的教程，请创建一个带有空的`BaseGameActivity`类的新的AndEngine项目。最后，我们需要创建一个名为`button_tiles.png`的精灵表，其中包含两个图像，并将其放置在项目中的`assets/gfx/`文件夹中；一个用于“未按下”按钮的表示，另一个用于“按下”按钮的表示。请参考以下图片以了解图像应有的样子。以下图片是300
    x 50像素，或者每个图块150 x 50像素：
- en: '![Getting ready…](img/978-1-849518-98-7_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪…](img/978-1-849518-98-7_03_01.jpg)'
- en: Refer to the class named `CreatingButtons` in the code bundle and import the
    code into your project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码捆绑包中名为`CreatingButtons`的类，并将代码导入到你的项目中。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The `ButtonSprite` class is convenient as it handles the tiled texture region
    versus button state changes for us. The following steps outline the tasks involved
    in setting up a `ButtonSprite` object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ButtonSprite`类非常方便，因为它为我们处理了图块纹理区域与按钮状态变化之间的关系。以下步骤概述了设置`ButtonSprite`对象所需执行的任务：'
- en: Declare a global `ITiledTextureRegion` object, naming it `mButtonTextureRegion`,
    then in the `onCreateResources()` method of the `BaseGameActivity` class, create
    a new `BuildableBitmapTextureAtlas` object suitable for your `button_tiles.png`
    image. Build and load the texture region and texture atlas objects so that we
    can use them later to create the `ButtonSprite` object.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个全局的`ITiledTextureRegion`对象，命名为`mButtonTextureRegion`，然后在`BaseGameActivity`类的`onCreateResources()`方法中，创建一个新的适用于您的`button_tiles.png`图像的`BuildableBitmapTextureAtlas`对象。构建并加载纹理区域和纹理图集对象，以便我们稍后可以使用它们来创建`ButtonSprite`对象。
- en: 'In order for the `ButtonSprite` object to work as intended, we should set up
    proper touch area binding on the `mScene` object. Copy the following code into
    the `onCreateScene()` method of the activity:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`ButtonSprite`对象按预期工作，我们应在`mScene`对象上设置适当的触摸区域绑定。将以下代码复制到活动的`onCreateScene()`方法中：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `ButtonSprite` object, supplying it the `mButtonTextureRegion` object
    and overriding its `onAreaTouched()` method:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ButtonSprite`对象，为其提供`mButtonTextureRegion`对象并重写其`onAreaTouched()`方法：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The final step is to register the touch area and attach the `buttonSprite`
    object to the `mScene` object:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是注册触摸区域并将`buttonSprite`对象附加到`mScene`对象：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是…
- en: This recipe makes use of a `ButtonSprite` object with an `ITiledTextureRegion`
    object to display two separate button states. One tile will act as the button's
    unpressed texture, the other will act as the button's pressed texture when a finger
    is touching the `Entity` object on the display.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱使用了`ButtonSprite`对象与`ITiledTextureRegion`对象来展示两个独立的按钮状态。其中一个图块将作为按钮未被按下时的纹理，另一个则作为当手指触摸显示上的`Entity`对象时按钮被按下的纹理。
- en: In the first step, we are creating our texture resources to be applied to the
    `ButtonSprite` object, which will be implemented in the coming steps. The `ButtonSprite`
    class will need an `ITiledTextureRegion` object with two indices, or two tiles
    as seen in the figure in the *Getting started...* section of this recipe. The
    first index of the `ITiledTextureRegion` object should contain the unpressed representation
    of the button, which will be applied to the `ButtonSprite` object by default.
    The second `ITiledTextureRegion` index should represent a pressed state of the
    `ButtonSprite` object. The `ButtonSprite` class will automatically alternate between
    these two `ITiledTextureRegion` indices depending on which state the `ButtonSprite`
    object is currently in; being either `ButtonSprite.State.NORMAL` for unpressed,
    setting the `ButtonSprite` object's current tile index to `0`, and `ButtonSprite.State.PRESSED`
    for, you guessed it, the pressed state which sets the `ButtonSprite` object's
    current tile index to `1`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建纹理资源以应用于`ButtonSprite`对象，这将在接下来的步骤中实现。`ButtonSprite`类需要一个具有两个索引的`ITiledTextureRegion`对象，或者在本文档的*入门...*
    部分所示的图中可以看到两个图块。`ITiledTextureRegion`对象的第一索引应包含按钮未被按下的表示，这将默认应用于`ButtonSprite`对象。第二个`ITiledTextureRegion`索引应表示`ButtonSprite`对象的按下状态。`ButtonSprite`类会根据`ButtonSprite`对象当前处于的状态自动在这两个`ITiledTextureRegion`索引之间切换；分别是`ButtonSprite.State.NORMAL`表示未被按下，将`ButtonSprite`对象的当前图块索引设置为`0`，以及`ButtonSprite.State.PRESSED`，是的，你猜对了，表示按下状态，将`ButtonSprite`对象的当前图块索引设置为`1`。
- en: In the second step, in order for the `ButtonSprite` object to work as intended,
    we need to enable touch area binding on the down action within the `mScene` object.
    We enable this within the `onCreateScene()` method of our activity's life cycle,
    just after the `mScene` object is created. What this does is, it allows our `ButtonSprite`
    object to register as unpressed when we drag our finger off of the `ButtonSprite`
    touch area. Disregarding this step will cause the `ButtonSprite` object to remain
    in a pressed state in the event that we press and drag our finger off the `Entity`
    object's touch area, which may very well be considered "buggy" if left for players
    to deal with. In the third step, we create the `ButtonSprite` object, centering
    it in within the scene. Ideally, we can create the `ButtonSprite` object and place
    it on the scene and it will work as it should. However, `ButtonSprite` is a button,
    after all, and therefore it should prompt an event to occur when pressed. We can
    do this by overriding the `onAreaTouched()` super method and creating events based
    on whether the `ButtonSprite` object's touch area is pressed down on, if a finger
    is dragged over it, or if a finger is released from the display while inside the
    touch area. In this recipe, we're simply displaying a `Toast` message in the event
    that the `ButtonSprite` object's `pSceneTouchEvent` registers the `isActionDown()`
    method. In a more realistic scenario during the development of a game, this button
    may just as well allow/disallow sound muting, start a new game, or any other action
    we choose for it. The other two methods used for touch event state-checking are
    `pSceneTouchEvent.isActionMove()` and `pSceneTouchEvent.isActionUp()`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，为了让`ButtonSprite`对象按预期工作，我们需要在`mScene`对象内对按下动作启用触摸区域绑定。我们在活动生命周期的`onCreateScene()`方法中启用此功能，在创建`mScene`对象之后立即进行。这样做可以允许我们的`ButtonSprite`对象在我们将手指拖离`ButtonSprite`触摸区域时注册为未按下状态。如果忽略这一步，那么当我们将手指按在`Entity`对象的触摸区域并拖离时，`ButtonSprite`对象将保持按下状态，这对于玩家来说可能会被认为是“有缺陷”的。在第三步中，我们创建`ButtonSprite`对象，并将其置于场景中心。理想情况下，我们可以创建`ButtonSprite`对象并将其放置在场景上，它应该就能正常工作。然而，`ButtonSprite`毕竟是一个按钮，因此当它被按下时应该触发一个事件。我们可以通过重写`onAreaTouched()`超方法并根据`ButtonSprite`对象的触摸区域是否被按下、手指是否在其上拖动或者手指是否从显示区域内释放来创建事件。在本教程中，我们仅在`ButtonSprite`对象的`pSceneTouchEvent`注册了`isActionDown()`方法时显示一个`Toast`消息。在游戏开发的真实场景中，这个按钮同样可以允许/禁止声音静音、开始新游戏，或者我们为其选择的任何其他动作。用于触摸事件状态检查的其他两个方法是`pSceneTouchEvent.isActionMove()`和`pSceneTouchEvent.isActionUp()`。
- en: Finally, once the `buttonSprite` object has been created we will need to register
    the touch area and attach the `Entity` object to the `mScene` object. By now,
    we should be well aware that in order to display an entity on the scene we must
    first attach it. Just as well, in order for the `buttonSprite` object's `onAreaTouched()`
    super method to execute, we must remember to call `mScene.registerTouchArea(buttonSprite)`.
    The same goes for any other `Entity` object for which we wish to provide touh
    events.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦创建了`buttonSprite`对象，我们将需要注册触摸区域并将`Entity`对象附加到`mScene`对象上。此时，我们应该清楚，为了在场景上显示一个实体，我们首先必须将其附加。同样，为了让`buttonSprite`对象的`onAreaTouched()`超方法能够执行，我们必须记得调用`mScene.registerTouchArea(buttonSprite)`。对于任何我们希望提供触摸事件的其它`Entity`对象也是如此。
- en: See also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine 游戏结构")中了解*使用不同类型的纹理*，*AndEngine 游戏结构*。
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")中了解*AndEngine 实体*，*使用实体*。
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")中了解如何通过精灵使场景生动，*使用实体*。
- en: Adding music to the menu
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向菜单中添加音乐
- en: In this topic, we're going to create a mute button which will control our menu's
    theme music. Pressing the mute button will cause the music to either play if currently
    paused, or pause if currently playing. This method for muting music and sounds
    can also be applied to in-game options and other areas of a game which allow sound
    and music playback. The difference between this recipe and the previous, is that
    we're going to be using a `TiledSprite` object which will allow us to set the
    `Sprite` object's tile index depending on whether the sound is playing or paused.
    Keep in mind that this recipe is useful for more than just enabling and disabling
    menu music. We can also follow the same approach for many other toggle-able options
    and states during gameplay.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将创建一个静音按钮，用于控制菜单主题音乐。按下静音按钮将导致音乐如果当前暂停则播放，如果当前播放则暂停。这种静音音乐和声音的方法也可以应用于游戏内的选项和其他允许声音和音乐播放的游戏区域。与之前的教程不同，我们将使用一个`TiledSprite`对象，它允许我们根据声音是否播放或暂停来设置`Sprite`对象的图块索引。请记住，这个教程不仅适用于启用和禁用菜单音乐。我们还可以在游戏过程中遵循同样的方法处理许多其他可切换的选项和状态。
- en: Getting ready…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine as
    well as using touch events to perform actions. Additionally, since we'll be incorporating
    the `Music` object into this recipe, we should understand how to load `Sound`
    and `Music` objects into our game's resources. Please read through the entire
    recipe, *Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*, specifically the section regarding
    tiled texture regions. Next, check into the recipe, Introducing sounds and music
    in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*. Finally, we will be working with sprites, so we should take a quick
    peak into the recipe, *Bringing a scene to life with sprites*, in [Chapter 2](ch02.html
    "Chapter 2. Working with Entities"), *Working with Entities*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程要求你对 AndEngine 中的`Sprite`对象以及使用触摸事件执行操作有基本了解。此外，由于我们将在本教程中整合`Music`对象，我们应当了解如何将`Sound`和`Music`对象加载到游戏资源中。请阅读整个教程，[第1章](ch01.html
    "第1章。AndEngine游戏结构")中的*处理不同类型的纹理*，特别是关于图块纹理区域的部分。接下来，查看[第1章](ch01.html "第1章。AndEngine游戏结构")中的*AndEngine游戏结构*中的引入声音和音乐教程。最后，我们将处理精灵，因此我们应当快速浏览[第2章](ch02.html
    "第2章。处理实体")中的*使用精灵为场景注入生命*教程。
- en: 'Once the topics regarding textures, sounds, and sprites have been covered,
    create a new AndEngine project with an empty `BaseGameActivity` class. We will
    need to create a sprite sheet named `sound_button_tiles.png` with two images and
    place it in the `assets/gfx/` folder of the project; one for the "non-muted" button
    representation and one for the "muted" button representation. See the following
    image for an idea of what the image should look like. The following image is 100
    x 50 pixels, or 50 x 50 piels per tile:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了纹理、声音和精灵的相关主题后，创建一个带有空的`BaseGameActivity`类的新的 AndEngine 项目。我们需要创建一个名为`sound_button_tiles.png`的精灵表，其中包含两个图像，并将其放置在项目的`assets/gfx/`文件夹中；一个用于“非静音”按钮表示，另一个用于“静音”按钮表示。以下是一个图像的示例，以了解图像应该是什么样子。以下图像是100
    x 50像素，或者每个图块50 x 50像素：
- en: '![Getting ready…](img/Image_03_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪…](img/Image_03_02.jpg)'
- en: We will also need to include a sound file that is in the MP3 format in the `assets/sfx/`
    folder of our project. The sound file can be any preferred music track of your
    choice for the purpose of executing this recipe.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在项目的`assets/sfx/`文件夹中包含一个 MP3 格式的声音文件。声音文件可以是为你执行此教程目的而选择的任何喜欢的音乐曲目。
- en: Refer to the class named `MenuMusic` in the code bundle and import the code
    into your project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`MenuMusic`的类，并将代码导入到你的项目中。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: This recipe introduces a combination of AndEngine features. We are combining
    music, textures, sprites, tiled texture regions, and touch events all into one
    convenient little package. The result—a toggle button that will control the playback
    of a `Music` object. Follow these steps to see how we create the toggle button.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程介绍了一系列 AndEngine 功能的组合。我们将音乐、纹理、精灵、图块纹理区域和触摸事件整合到一个便捷的小包中。结果是一个切换按钮，可以控制`Music`对象的播放。按照以下步骤，看看我们是如何创建这个切换按钮的。
- en: In the first step, we will be working with two global objects; `mMenuMusic`
    which is a `Music` object and `mButtonTextureRegion` which is an `ITiledTextureRegion`
    object. In the `onCreateResources()` method of the activity, we create these objects
    with their respective resources in the `assets/*` folder. Refer to the recipes
    mentioned in the *Getting started...* section for more information on creating
    these resources if needed.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，我们将使用两个全局对象；`mMenuMusic`是一个`Music`对象，`mButtonTextureRegion`是一个`ITiledTextureRegion`对象。在活动的`onCreateResources()`方法中，我们使用`assets/*`文件夹中的相应资源创建这些对象。如果需要，请参考*入门…*部分提到的教程，了解更多关于创建这些资源的信息。
- en: 'Next, we can skip directly to the `onPopulateScene()` method of the activity
    where we will create our `mMuteButton` object using the `TiledSprite` class. We
    will need to override the `onAreaTouched()` method of the `mMuteButton` object
    in order to either pause or play the music when the button is pressed:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以直接跳转到活动的`onPopulateScene()`方法，在这里我们将使用`TiledSprite`类创建`mMuteButton`对象。我们需要重写`mMuteButton`对象的`onAreaTouched()`方法，以便在按下按钮时暂停或播放音乐：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the button has been created, we need to initialize the `mMuteButton` and
    `mMenuMusic` objects'' initial states. This step involved setting the `mMuteButton`
    object''s tile index to that of the `UNMUTE` constant value which equals `1`,
    registering and attaching the `mMuteButton` object to the `mScene` object, setting
    `mMenuMusic` to loop, and then finally calling `play()` on the `mMenuMusic` object:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建按钮后，我们需要初始化`mMuteButton`和`mMenuMusic`对象的初始状态。这一步包括将`mMuteButton`对象的图块索引设置为`UNMUTE`常量值，该值等于`1`，注册并将`mMuteButton`对象附加到`mScene`对象，设置`mMenuMusic`为循环播放，并最终在`mMenuMusic`对象上调用`play()`方法：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final step to include when dealing with any `Music` object is to make sure
    we pause it upon app minimization, otherwise it will continue to play in the background.
    In this recipe, we are pausing the `mMenuMusic` object on minimization. However,
    in the event a user returns to the application, the music will play only if the
    `mMuteButton` object''s tile index was equal to the `UNMUTE` constant value when
    the app was minimized:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理任何`Music`对象时，最后一步是确保在应用最小化时暂停音乐，否则它将在后台继续播放。在本教程中，我们将最小化时暂停`mMenuMusic`对象。然而，如果用户返回应用程序，只有当应用最小化时`mMuteButton`对象的图块索引等于`UNMUTE`常量值，音乐才会播放：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This particular recipe is very useful in game development; not only for sound
    and music muting, but for all sorts of toggle buttons. While this recipe is dealing
    specifically with `Music` object playback, it contains all of the necessary code
    in order to start working with various other toggle buttons which might suit the
    more specific needs of our games.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的教程在游戏开发中非常有用；不仅适用于声音和音乐的静音，还适用于各种切换按钮。虽然本教程专门处理`Music`对象的播放，但它包含了开始使用各种其他切换按钮所需的所有必要代码，这些按钮可能更适合我们游戏的具体需求。
- en: In the first step, we must set up the necessary resources for use within the
    `mMenuMusic` object and the `mMuteButton` object. The `mMenuMusic` object will
    load a sound file named `menu_music.mp3`, which can be any MP3 file, preferably
    a music track. The `mMuteButton` object will load a sprite sheet called `sound_button_tiles.png`
    with two separate tiles. These objects are both taken care of within the `onCreateResourceS()`
    method of the `BaseGameActivity` object's life cycle. More information on the
    creation of these resources can be found within the recipes mentioned in the *Getting
    started...* section of this recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们必须为`mMenuMusic`对象和`mMuteButton`对象设置必要的资源。`mMenuMusic`对象将加载名为`menu_music.mp3`的音频文件，该文件可以是任何MP3文件，最好是音乐轨道。`mMuteButton`对象将加载名为`sound_button_tiles.png`的图块表，其中包含两个单独的图块。这些对象都在`BaseGameActivity`对象生命周期的`onCreateResourceS()`方法中处理。关于这些资源的创建，可以在本教程的*入门…*部分提到的教程中找到更多信息。
- en: In step two, we are setting up the `mMuteButton` object, which is of the `TiledSprite`
    type. The `TiledSprite` class allows us to use an `ITiledTextureRegion` object
    which gives us the ability to set the current tile index that the `mMuteButton`
    object will display on our scene. In the overridden `onAreaTouched()` method,
    we check to see whether or not the `mMuteButton` object has been pressed down
    on with the `if (pSceneTouchEvent.isActionDown())` statement. We then proceed
    to determine whether or not the `mMenuMusic` object is currently playing with
    the `isPlaying()` method of the `Music` object. If the music is playing, then
    pressing a finger down on the `mMuteButton` button will cause the `mMenuMusic`
    object to call `pause()` and revert the `mMuteButton` object's current tile index
    to that of the `MUTE` constant value, which is equal to `0`. If the music is not
    playing, then we do the exact opposite, calling `play()` on the `mMenuMusic` object
    and reverting the `mMuteButton` object's tile index back to `UNMUTE`, which is
    equal to `1`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we are setting up the `mMenuMusic` and `mMuteButton` objects'
    default state, which is equal to playing the music and setting the current tile
    index to `UNMUTE`. This will cause the music to play anytime the application initially
    starts up. Once we've set up the default button and music states, we continue
    on to register the `mMuteButton` object's touch area and attach the `Entity` object
    to the `Scene` object. This step can be taken further in order to save the state
    of the `mMuteButton` object to the device, allowing us to load the default state
    of music muting based on a user's past preference. For more information on saving/loading
    data and states, see the recipe, *Saving and loading game data* in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The final step is very important and should always be included when dealing
    with `Music` objects. The purpose of this step is explained in more detail in
    the recipe, *Introducing sounds and music* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*. However, there is a slight variation
    to the code in the `onResumeGame()` method for this recipe. In the event of application
    minimization, a user is likely expecting their game state to be waiting as it
    was left when they finally return it to focus. For this reason, rather than playing
    the `mMenuMusic` object when `onResumeGame()` is fired on app maximization, we
    determine whether or not the `mMuteButton` button's tile index was set to `UNMUTE`
    just prior to our game's window minimization. If so, then we can call the `play()`
    method on the `mMenuMusic` object, otherwise we can ignore it until a user decides
    to play the music by pressing the `mMuteButton` again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introducing sounds and music* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中，引入声音和音乐。
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")，*使用实体*中，了解AndEngine实体。
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")，*使用实体*中，介绍如何通过精灵使场景生动起来。
- en: Applying a background
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用背景
- en: AndEngine's `Scene` object allows us to apply a static background to it. The
    background can be used to display a solid color, an entity, a sprite, or a repeating
    sprite which are not affected by changes to the `Camera` object's position or
    zoom factor. In this recipe, we're going to take a look at how to apply the different
    types of backgrounds to our `Scene` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine的`Scene`对象允许我们为其应用静态背景。背景可以用来显示纯色、实体、精灵或重复精灵，这些都不会受到`Camera`对象位置或缩放因子变化的影响。在本食谱中，我们将看看如何将不同类型的背景应用到我们的`Scene`对象上。
- en: How to do it..
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The `Background` object is the most basic type of background for our `Scene`
    object in AndEngine. This object allows the scene to visually represent a solid
    color. We will start this recipe off by setting up the `Scene` object to display
    a `Background` object in order to become familiar with how applying backgrounds
    to a scene works. Later on in this recipe we''ll be introducing the majority of
    the remaining `Background` object''s subtypes in order to cover all options as
    far as applying backgrounds to our scene goes. Setting the `Scene` object up with
    a background involves just two steps as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在AndEngine中，`Background`对象是我们`Scene`对象最基本的背景类型。这个对象允许场景以纯色视觉展示。我们首先会设置`Scene`对象以显示`Background`对象，以便熟悉如何将背景应用到场景中。在本食谱的后面，我们将介绍大部分剩余的`Background`对象子类型，以涵盖所有关于将背景应用到场景的选项。为`Scene`对象设置背景只需以下两个步骤：
- en: 'Define the properties of and create the `Background` object:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并创建`Background`对象的属性：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set the `Background` object to the `Scene` object and enable the background
    feature:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Background`对象设置到`Scene`对象上，并启用背景功能：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Before deciding to use one of AndEngine's default backgrounds, we must figure
    out whether or not our background should take camera movement into consideration.
    We can think of these backgrounds as being "stuck" to the camera view. This means
    that any movements made to the camera will have absolutely no effect on the position
    of the background. The same rule applies for any other form of camera repositioning,
    including zooming. For this reason, we should not include any objects on our background
    which we need to scroll with camera movement. This is the difference between a
    `Background` object applied to the `Scene` object and an `Entity` object attached
    to the `Scene` object. Any "backgrounds" which should appear to move in response
    to the camera movement should be attached to the `Scene` object as an `Entity`
    object instead. This is most conveniently accomplished by applying an `Entity`
    object to the `Scene` object to act as a "background layer", which all sprites
    representing the background image would be attached to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用AndEngine的默认背景之前，我们必须确定背景是否需要考虑相机移动。我们可以将这些背景视为“粘附”在相机视图中。这意味着对相机所做的任何移动都不会影响背景的位置。对于任何其他形式的相机重新定位，包括缩放，也同样适用。因此，我们不应该在背景上包含任何需要随相机移动而滚动的对象。这是应用到`Scene`对象的`Background`对象与附加到`Scene`对象的`Entity`对象之间的区别。任何应该随相机移动而看似移动的“背景”，都应该作为`Entity`对象附加到`Scene`对象上，以作为“背景层”，所有表示背景图像的精灵都将附着在上面。
- en: Now that we've covered the difference between a `Background` object and an `Entity`
    object, we'll continue on to the steps for this recipe. As we can see in this
    recipe's steps, setting up a boring, old colored background is a straightforward
    task. However, it still happens to be useful to know. In the first step, we will
    define the properties of the `Background` object and create the `Background` object
    supplying said properties as the parameters. For the basic `Background` object,
    these parameters simply include the three color values and the alpha value of
    the `Background` object's color. However, as we will soon discuss, the different
    types of backgrounds will require different parameters depending on the type.
    The differences will be outlined for convenience when we get to that point.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`Background`对象与`Entity`对象之间的区别，接下来将继续介绍本食谱的步骤。从本食谱的步骤中我们可以看到，设置一个枯燥、老旧的有色背景是一项简单的任务。然而，了解它仍然是有用的。在第一步中，我们将定义`Background`对象的属性，并创建一个`Background`对象，将所述属性作为参数传入。对于基本的`Background`对象，这些参数仅包括三个颜色值以及`Background`对象颜色的alpha值。但是，正如我们稍后将讨论的，不同类型的背景将根据类型需要不同的参数。当我们讨论到这一点时，为了方便起见，将会概述这些差异。
- en: The second step for setting up a `Background` object on the `Scene` object will
    be the same two method calls no matter what type of background we are applying.
    We must set the scene's background with `setBackground(pBackground)` and make
    sure the scene's background is enabled by calling `setBackgroundEnabled(true)`.
    On the other hand, we can also disable the background by supplying the latter
    method with a `false` parameter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Scene`对象上设置`Background`对象的第二步将始终是相同的两个方法调用，无论我们应用的是哪种类型的背景。我们必须通过`setBackground(pBackground)`设置场景的背景，并通过调用`setBackgroundEnabled(true)`确保场景的背景已启用。另一方面，我们也可以通过向后者方法提供一个`false`参数来禁用背景。
- en: That's all it takes when setting up a background on our `Scene` object. However,
    in our own games it is rather unlikely that we'll be satisfied with a basic colored
    background. See the *There's more...* section of this recipe for a list and examples
    of the various `Background` object subtypes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在我们的`Scene`对象上设置背景的全部内容。然而，在我们自己的游戏中，我们很可能会对基本的有色背景感到不满意。请参阅本食谱的*还有更多...*部分，了解各种`Background`对象子类型的列表和示例。
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the following sections we will cover the different types of static backgrounds
    which we can use in our games. All of the `Background` object subtypes allow us
    to specify a background color for portions of the background which are not covered
    by a `Sprite` entity, `Rectangle` entity, or otherwise. These backgrounds all
    share the same "static" rule as mentioned in the *How it works...* section, that
    they will not move pending camera movement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们将介绍我们可以在游戏中使用的不同类型的静态背景。所有的`Background`对象子类型都允许我们为未被`Sprite`实体、`Rectangle`实体或其他方式覆盖的背景部分指定背景颜色。这些背景都遵循在*工作原理...*部分提到的相同"静态"规则，即它们在摄像头移动时不会移动。
- en: The EntityBackground class
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EntityBackground类
- en: 'The `EntityBackground` class allows us to apply a single `Entity` object, or
    an entire Entity object''s layer as our scene''s background. This can be useful
    for combining multiple `Entity` objects into a single `Background` object to be
    displayed on the scene. In the following code, we''re attaching two rectangles
    to an `Entity` object''s layer, then using the `Entity` object as a background:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityBackground`类允许我们应用单个`Entity`对象，或整个`Entity`对象的图层作为我们场景的背景。这可以用于将多个`Entity`对象组合到一个`Background`对象中，以便在场景上显示。在以下代码中，我们将两个矩形附加到`Entity`对象的图层上，然后使用`Entity`对象作为背景：'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `EntityBackground` object's parameters include `red`, `green`, and `blue`
    color values and finally the `Entity` object or layer to display as the background.
    Once the `EntityBackground` object has been created, we simply follow step two
    in this recipe's *How to do it...* section and our `EntityBackground` object will
    be ready to display whatever we choose to attach to the `backgroundEntity` object!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityBackground`对象的参数包括`red`、`green`和`blue`颜色值，最后是作为背景显示的`Entity`对象或图层。一旦创建了`EntityBackground`对象，我们只需按照本食谱中*如何操作...*部分的第二步进行操作，我们的`EntityBackground`对象将准备好显示我们选择附加到`backgroundEntity`对象上的任何内容！'
- en: The SpriteBackground class
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SpriteBackground类
- en: 'The `SpriteBackground` class allows us to attach a single `Sprite` object to
    our scene as a background image. Keep in mind, the sprite will not be stretched
    or distorted in any way to accommodate for the size of the display. In order to
    have a sprite stretch across the full width and height of the camera''s view,
    we must create the `Sprite` object while taking into consideration the camera''s
    width and height. With the following code, we can apply a single `Sprite` object
    as our background image on the scene. Assume the `mBackgroundTextureRegion` object''s
    dimensions are the same as the `WIDTH` and `HEIGHT` values in the following code,
    which represent the camera''s width and height values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpriteBackground`类允许我们将单个`Sprite`对象作为背景图像附加到场景中。请注意，为了适应显示的大小，这个精灵不会被拉伸或扭曲。为了使精灵在相机的视野中横跨整个宽度和高度，我们必须在考虑相机宽度和高度的情况下创建`Sprite`对象。使用以下代码，我们可以将单个`Sprite`对象作为场景的背景图像。假设`mBackgroundTextureRegion`对象的尺寸与以下代码中的`WIDTH`和`HEIGHT`值相同，这些值表示相机的宽度和高度值：'
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can create the `Sprite` object as we would any other. When creating the `SpriteBackground`
    object, we pass the usual color parameters along with the `Sprite` object we wish
    to display on the background.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像创建其他对象一样创建`Sprite`对象。在创建`SpriteBackground`对象时，我们传递常规颜色参数以及我们希望在背景上显示的`Sprite`对象。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good idea, when using `SpriteBackground` and `RepeatingSpriteBackground`,
    to apply `BitmapTextureFormat.RGB_565` to the texture atlas. Since the background
    will likely stretch across the full display, we usually do not require an alpha
    channel which can improve the performance of our game on low-end devices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`SpriteBackground`和`RepeatingSpriteBackground`时，将`BitmapTextureFormat.RGB_565`应用到纹理图集上是一个好主意。由于背景可能会横跨整个显示，我们通常不需要alpha通道，这可以提高在低端设备上游戏的性能。
- en: The RepeatingSpriteBackground class
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RepeatingSpriteBackground类
- en: 'The `RepeatingSpriteBackground` class is useful for creating textured maps
    for terrain or simply filling empty space on the scene with a texture. We can
    easily turn the following 128 x 128 pixel texture into a background which repeats
    the texture across the full length of the display:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeatingSpriteBackground`类非常适合创建地形纹理图或仅仅用纹理填充场景中的空白空间。我们可以轻松地将以下128 x 128像素的纹理转换成背景，使其在整个显示长度上重复纹理：'
- en: '![The RepeatingSpriteBackground class](img/978-1-849518-98-7_03_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![RepeatingSpriteBackground类](img/978-1-849518-98-7_03_03.jpg)'
- en: 'The resulting background after creating a `RepeatingSpriteBackground` object
    out of the preceding texture would look like the following image at 1280 x 752
    pixels in dimension:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面纹理创建`RepeatingSpriteBackground`对象后，得到的背景图像尺寸为1280 x 752像素，如下所示：
- en: '![The RepeatingSpriteBackground class](img/978-1-849518-98-7_03_03b.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![RepeatingSpriteBackground类](img/978-1-849518-98-7_03_03b.jpg)'
- en: 'Creating a `RepeatingSpriteBackground` object requires a little bit more work
    than the previous `Background` object subtypes. We will be loading our repeating
    image file into an `AssetBitmapTexture` object which will then be extracted into
    an `ITextureRegion` object for use by the background. Since we''re using the texture
    for the purpose of repeating it across `RepeatingSpriteBackground`, we must provide
    the `TextureOptions.REPEATING_BILINEAR` or `TextureOptions.REPEATING_NEAREST`
    texture options within the `AssetBitmapTexture` constructor. On top of that, when
    dealing with repeating textures, we must keep our image file bound to the power
    of two dimensions. Texture dimensions with a power of two are required by OpenGL''s
    wrap modes in order to properly repeat a texture. Failure to follow this rule
    will cause repeating sprites to appear as a black shape instead. Place the following
    code into the `onCreateResources()` method of your test activity. The `mRepeatingTextureRegion`
    object must be declared as a global `ITextureRegion` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`RepeatingSpriteBackground`对象需要比之前的`Background`对象子类型多做一点工作。我们将重复的图像文件加载到`AssetBitmapTexture`对象中，然后将其提取为`ITextureRegion`对象供背景使用。由于我们要将纹理用于在`RepeatingSpriteBackground`中重复，我们必须在`AssetBitmapTexture`构造函数中提供`TextureOptions.REPEATING_BILINEAR`或`TextureOptions.REPEATING_NEAREST`纹理选项。此外，在处理重复纹理时，我们的图像文件尺寸必须保持为2的幂次方。OpenGL的环绕模式要求纹理尺寸为2的幂次方，以正确地重复纹理。不遵循此规则将导致重复的精灵显示为黑色形状。将以下代码放入测试活动的`onCreateResources()`方法中。`mRepeatingTextureRegion`对象必须声明为全局`ITextureRegion`对象：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next step is to create the `RepeatingSpriteBackground` object. We will include
    this code in the `onCreateScene()` method of our activity''s life cycle:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`RepeatingSpriteBackground`对象。我们将此代码包含在我们的活动生命周期的`onCreateScene()`方法中：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first two parameters for the `RepeatingSpriteBackground` object define the
    maximum area that the repeating texture will cover, extending from the bottom-left
    corner of the display. In this case, we're covering the entire display. The third
    texture we pass is the `ITextureRegion` object to be used as the repeating texture.
    As previously mentioned, this texture region must be following the power-of-two
    dimension rule. The fourth parameter is the scale factor of the repeating texture.
    The default scale is `1`; increasing the scale will cause the repeating texture
    to enlarge which can make it easier to see the repeating pattern. Reducing the
    scale factor will shrink each repeated texture which can sometimes help to hide
    the pattern or obvious flaws in the repeating textures. Keep in mind, adjusting
    the scale of the repeating texture does not affect the overall size of the `RepeatingSpriteBackground`
    object as defined in the first two parameters, so feel free to adjust them until
    the texture looks right.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeatingSpriteBackground`对象的前两个参数定义了重复纹理将覆盖的最大区域，从显示的左下角开始。在本例中，我们覆盖了整个显示区域。我们传递的第三个纹理是作为重复纹理使用的`ITextureRegion`对象。如前所述，这个纹理区域必须遵循二的幂次维度规则。第四个参数是重复纹理的缩放因子。默认缩放为`1`；增加缩放会使重复纹理放大，这可能使重复模式更容易看到。减少缩放因子会缩小每个重复的纹理，有时可以帮助隐藏重复纹理中的明显瑕疵。请记住，调整重复纹理的缩放不会影响根据前两个参数定义的`RepeatingSpriteBackground`对象的整体大小，因此可以自由调整，直到纹理看起来正确为止。'
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见以下内容
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中，*使用不同类型的纹理*。
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")，*使用实体*中，*用精灵让场景生动起来*。
- en: Using parallax backgrounds to create perspective
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视差背景创建透视效果
- en: Applying a **parallax** background to a game can result in a visually-pleasing
    perspective effect. Even though we're working with a 2D engine, we can create
    a background which will gives off an illusion of depth through the use of parallax
    values which determine the movement speed of sprites based on the camera movement.
    This topic is going to introduce parallax backgrounds and how we can use them
    to add a sense of depth to an otherwise fully 2D world. The classes we will be
    using are the `ParallaxBackground` and the `AutoParallaxBackground` classes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将**视差**背景应用于游戏可以产生视觉上令人愉悦的透视效果。尽管我们使用的是2D引擎，但我们可以创建一个通过使用视差值来产生深度错觉的背景，这些视差值根据相机移动确定精灵的运动速度。本主题将介绍视差背景以及如何使用它们为完全2D的世界添加深度感。我们将使用的类是`ParallaxBackground`和`AutoParallaxBackground`。
- en: Getting ready…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine. Please
    read through the entire recipe, *Working with different types of textures* in
    [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*. Next, please visit the recipe, *Bringing a scene to life with sprites*
    in [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要具备AndEngine中`Sprite`对象的基本知识。请通读[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的整个食谱，*使用不同类型的纹理*。接下来，请访问[第2章](ch02.html
    "第2章. 使用实体")，*使用实体*中的食谱，*用精灵让场景生动起来*。
- en: 'Once the recipes regarding textures and sprites have been covered, create a
    new AndEngine project with an empty `BaseGameActivity` class. Finally, we will
    need to create an image named `hill.png` and place it in the `assets/gfx/` folder
    of the project. This image should be 800 x 150 pixels in dimension. The image
    can resemble the following figure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了纹理和精灵的相关方法之后，创建一个带有空的`BaseGameActivity`类的新的AndEngine项目。最后，我们需要在项目的`assets/gfx/`文件夹中创建一个名为`hill.png`的图像。这个图像的尺寸应为800
    x 150像素。图像可以类似于以下图形：
- en: '![Getting ready…](img/Image_03_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪…](img/Image_03_04.jpg)'
- en: Refer to the class named `UsingParallaxBackgrounds` in the code bundle and import
    the code into your project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`UsingParallaxBackgrounds`的类，并将代码导入到您的项目中。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The `ParallaxBackground` object is the most advanced `Background` object subtype
    in AndEngine. It requires the most setting up out of all of the `Background` object
    subtypes, but if broken down into small steps, it is really not that difficult.
    Perform the following steps for a walkthrough on how to set up a `ParallaxBackground`
    object to work in relation to the camera''s movement. For the sake of brevity,
    we''re going to omit the automatic camera movement code which can be found in
    the `onCreateEngineOptions()` method of the activity''s life cycle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallaxBackground`对象是AndEngine中最先进的`Background`对象子类型。它需要比所有`Background`对象子类型更多的设置，但如果分解成小步骤，实际上并不那么困难。执行以下步骤，了解如何设置一个与相机移动相关的`ParallaxBackground`对象。为了简洁起见，我们将省略可以在活动生命周期的`onCreateEngineOptions()`方法中找到的自动相机移动代码：'
- en: The first step is typical when creating an `ITextureRegion` object for `Sprite`
    objects and is to create our `BuildableBitmapTextureAtlas`. The texture atlas
    should be just big enough to contain the `hill.png` image, which is 800 pixels
    wide by 150 pixels high. Once the texture atlas has been created, continue on
    to create the `ITextureRegion` object, then build and load the texture atlas as
    usual. This should all take place within the `onCreateResources()` method of the
    activity's life cycle.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Sprite`对象的`ITextureRegion`对象的第一个步骤通常是创建我们的`BuildableBitmapTextureAtlas`。纹理图集应足够大以容纳`hill.png`图像，其宽度为800像素，高度为150像素。创建纹理图集后，继续创建`ITextureRegion`对象，然后像往常一样构建和加载纹理图集。这应该都在活动生命周期的`onCreateResources()`方法内完成。
- en: 'The remaining steps will take place within the `onCreateScene()` method of
    the activity''s life cycle. First, we need to create all of the `Sprite` objects
    which will appear on the background. In this recipe, we''re applying three `Sprite`
    objects which will be placed conveniently on the background in order to enhance
    the illusion of distance between the different sprites:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩余的步骤将在活动生命周期的`onCreateScene()`方法内进行。首先，我们需要创建所有将出现在背景上的`Sprite`对象。在此教程中，我们将应用三个`Sprite`对象，以便方便地放置在背景上，以增强不同精灵之间的距离错觉：
- en: '[PRE12]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will create the `ParallaxBackground` object. The three parameters
    for the constructor define the background color as usual. More importantly, we
    must override the `onUpdate()` method of the `ParallaxBackground` object in order
    to handle movement of the `Sprite` objects on the background pending any camera
    movement:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`ParallaxBackground`对象。构造函数的三个参数通常定义背景颜色。更重要的是，我们必须重写`ParallaxBackground`对象的`onUpdate()`方法，以处理在背景上等待任何相机移动时`Sprite`对象移动：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the `ParallaxBackground` object has been created, we must now attach `ParallaxEntity`
    objects to the `ParallaxBackground` object. The `ParallaxEntity` object requires
    that we define a parallax factor for the entity as well as a `Sprite` object for
    visual representation, which would be the hills in this case:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ParallaxBackground`对象后，我们现在必须将`ParallaxEntity`对象附加到`ParallaxBackground`对象上。`ParallaxEntity`对象要求我们为实体定义一个视差因子以及一个用于视觉表示的`Sprite`对象，在这种情况下将是山丘：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, as with all `Background` objects we must apply it to the `Scene` object
    and enable it:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像所有`Background`对象一样，我们必须将其应用到`Scene`对象并启用它：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we're setting up a `ParallaxBackground` object which will contain
    three separate `ParallaxEntity` objects. Each of these three `ParallaxEntity`
    objects will represent a hill within the background of our scene. Through the
    use of parallax factors and parallax values, the `ParallaxBackground` object allows
    each of the `ParallaxEntity` objects to offset their position at different speeds
    in the event that the `Camera` object changes its position. This allows the `ParallaxEntity`
    objects to give off the perspective effect. As we all know, objects which are
    closer to us will appear to move much faster than objects which are in the distance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此教程中，我们将设置一个`ParallaxBackground`对象，其中包含三个独立的`ParallaxEntity`对象。这三个`ParallaxEntity`对象将代表我们场景背景中的山丘。通过使用视差因子和视差值，`ParallaxBackground`对象允许每个`ParallaxEntity`对象在`Camera`对象改变其位置时以不同的速度偏移它们的位置。这使得`ParallaxEntity`对象能够产生透视效果。众所周知，离我们更近的物体会比远处的物体看起来移动得更快。
- en: The first step in the *How to do it...* section is a basic and necessary task
    for creating our `Sprite` objects. In this recipe, we're using a single texture
    region/image to represent all three sprites which will be attached to the background.
    However, feel free to modify this recipe in order to allow each of the three `Sprite`
    objects to use their own customized images. Practice will help to further understand
    how a `ParallaxBackground` object can be manipulated to create neat scenes within
    a game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在“*如何操作...*”部分的第一步是创建我们的`Sprite`对象的基本且必要的任务。在这个食谱中，我们使用一个单一的纹理区域/图像来表示所有三个将附加到背景的精灵。然而，请随意修改这个食谱，以便让三个`Sprite`对象中的每一个都能使用自己的定制图像。实践将有助于进一步理解如何操作`ParallaxBackground`对象，在游戏中创建整洁的场景。
- en: 'In the second step, we set up our three `Sprite` objects which will be attached
    to the background as `ParallaxEntity` objects. We''re placing them all in the
    center of the scene as far as the x coordinate goes. The `ParallaxBackground`
    class is only meant for applying perspective to the x coordinate movement, therefore
    the position of sprites on the background will move out of the initial x coordinate
    as the camera moves. With that being said, it is important to know that the `ParallaxBackground`
    object will continuously stitch together copies of each `ParallaxEntity` object
    attached to the background in order to compensate for background objects which
    may leave the camera''s view. See the following figure for a visual representation
    of how the `ParallaxBackground` object stitches background objects end-to-end:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们设置三个将作为`ParallaxEntity`对象附加到背景的`Sprite`对象。我们将它们都放置在场景中心的x坐标处。`ParallaxBackground`类仅用于将透视应用于x坐标移动，因此，随着摄像机的移动，背景上的精灵位置将离开初始x坐标。也就是说，重要的是要知道`ParallaxBackground`对象将不断地将附加到背景的每个`ParallaxEntity`对象的副本拼接在一起，以补偿可能离开摄像机视野的背景对象。以下是`ParallaxBackground`对象如何将背景对象端对端拼接的可视化表示：
- en: '![How it works…](img/Image_03_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/Image_03_05.jpg)'
- en: Due to the way `ParallaxEntity` object stitching works on the `ParallaxBackground`
    object, in order to create objects which may not appear so often on the background,
    we must include transparent padding within the image file itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ParallaxEntity`对象在`ParallaxBackground`对象上的拼接方式，为了创建可能不会在背景上经常出现的对象，我们必须在图像文件本身中包含透明填充。
- en: As for defining a sprite's y coordinate, it is best to spread the sprites out
    in order to be able to differentiate between the closest and the furthest hills
    on the background. In order to create the best perspective effect, the most distant
    objects should appear to be higher up on the scene as they will be hiding behind
    the closer objects as far as layering goes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 至于定义精灵的y坐标，最好是将精灵分散开，以便能够区分背景上最近和最远的山丘。为了创建最佳的透视效果，最远的物体在场景中应该显得更高，因为从层次上讲，它们将隐藏在更近的对象后面。
- en: In the third step, we create the `ParallaxBackground` object. The constructor,
    similar to all other `Background` object subtypes, defines the background color.
    The real magic takes place within the overridden `onUpdate()` method of the `ParallaxBackground`
    object. We have two variables; `cameraPreviousX` and `cameraCurrentX` which will
    be tested against initially to make sure there is a difference between the two
    in order to reduce any unnecessary execution of code. If the two values are not
    equal to each other, we accumulate the difference between the previous and current
    camera position into a `parallaxValueOffset` variable. By calling `setParallaxValue(parallaxValueOffset)`
    on the `ParallaxBackground` object, we are basically just telling the background
    that the camera has changed positions and it's time to update all of the `ParallaxEntity`
    object positions to compensate. Increasing the parallax value will cause `ParallaxEntity`
    objects to pan to the left, while decreasing it causes them to pan to the right.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们创建`ParallaxBackground`对象。构造函数与所有其他`Background`对象子类型一样，定义了背景颜色。真正的魔法发生在`ParallaxBackground`对象的覆盖`onUpdate()`方法中。我们有两个变量；`cameraPreviousX`和`cameraCurrentX`，它们将首先被测试以确保两者之间存在差异，以减少任何不必要的代码执行。如果这两个值不相等，我们将累积先前和当前摄像机位置之间的差异到一个`parallaxValueOffset`变量中。通过在`ParallaxBackground`对象上调用`setParallaxValue(parallaxValueOffset)`，我们基本上只是告诉背景摄像机已经改变了位置，现在是更新所有`ParallaxEntity`对象位置以进行补偿的时候了。增加视差值将导致`ParallaxEntity`对象向左平移，而减少它则导致它们向右平移。
- en: In the fourth step, we finally create the `ParallaxEntity` objects, supplying
    each of them with a parallax factor and a `Sprite` object. The parallax factor
    will define exactly how fast or how slow the `Sprite` object will move based on
    the camera's movement. In order to create a more realistic scenery, the objects
    furthest away should have a lesser value than closer objects. Additionally, the
    `attachParallaxEntity(pParallaxEntity)` method is similar to attaching `Entity`
    objects to a `Scene` object in the sense that the second object attached will
    appear in front of the first, the third will appear in front of the second, and
    so on. For this reason, we attach `ParallaxEntity` objects to `ParallaxBackground`
    from furthest first, then work our way up to the closest object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们最终创建`ParallaxEntity`对象，为每个对象提供一个视差因子和一个`Sprite`对象。视差因子将定义`Sprite`对象基于摄像头移动的速度是快还是慢。为了创建更逼真的风景，距离较远的对象应该具有比近处对象更小的值。此外，`attachParallaxEntity(pParallaxEntity)`方法类似于将`Entity`对象附加到`Scene`对象，因为第二个附加的对象将出现在第一个前面，第三个将出现在第二个前面，依此类推。因此，我们从最远的对象开始将`ParallaxEntity`对象附加到`ParallaxBackground`，然后逐步靠近最近的物体。
- en: Once all of the previous steps have been done, we can simply apply `ParallaxBackground`
    to the `Scene` object and enable it. From here on out, any and all camera movement
    will determine the position of the objects within the background scenery!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有前面的步骤后，我们可以简单地将`ParallaxBackground`应用到`Scene`对象并启用它。从现在开始，任何摄像头的移动都将决定背景景物中对象的位置！
- en: There's more…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: AndEngine also includes an `AutoParallaxBackground` class which is similar to
    the `ParallaxBackground` class in terms of setting up a visual effect. The difference
    between the two is that the `AutoParallaxBackground` class allows us to specify
    a constant rate in which the `ParallaxEntity` objects will move across the screen
    regardless of the camera's movement. This type of background is useful for games
    which should appear to be constantly moving such as a racing game or any type
    of fast-paced side-scroller. On the other hand, the `AutoParallaxBackground` class
    can also be used to create simple effects such as clouds scrolling consistently
    across the screen during gameplay, even in games which may appear to remain static
    in terms of `Camera` and `Scene` object position.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 还包括一个`AutoParallaxBackground`类，它和`ParallaxBackground`类在设置视觉效果方面类似。两者的区别在于，`AutoParallaxBackground`类允许我们指定一个恒定速率，在该速率下，无论摄像头是否移动，`ParallaxEntity`对象都会在屏幕上移动。这种类型的背景对于需要看起来不断移动的游戏很有用，比如赛车游戏或任何快节奏的横版滚动游戏。另一方面，`AutoParallaxBackground`类也可以用于在游戏过程中创建简单的效果，例如云层在屏幕上持续滚动，即使是在`Camera`和`Scene`对象位置看似静态的游戏中也是如此。
- en: 'We can create an `AutoParallaxBackground` object by making a simple adjustment
    to this recipe''s activity. Replace the current `ParallaxBackground` object creation
    with the following code snippet. Note that the `autoParallaxSpeed` variable defines
    how fast the `ParallaxEntity` objects will move on the background, since they''re
    no longer based on the camera''s movemen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对这一食谱活动的简单调整来创建一个`AutoParallaxBackground`对象。用以下代码片段替换当前的`ParallaxBackground`对象创建。注意，`autoParallaxSpeed`变量定义了`ParallaxEntity`对象在背景上的移动速度，因为它们不再基于摄像头的移动：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Additionally, remove all code associated with the `mCamera` object's `onUpdate()`
    method as it will no longer affect the position of the `ParallaxEntity` objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，移除所有与`mCamera`对象的`onUpdate()`方法相关的代码，因为它将不再影响`ParallaxEntity`对象的位置。
- en: 'The following figure displays the outcome of attaching three hill layers to
    the `ParallaxBackground` or `AutoParallaxBackground` objects at different heights,
    minus the movement, of course:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了将三个不同高度的丘陵层附加到`ParallaxBackground`或`AutoParallaxBackground`对象的结果，当然，这里没有考虑移动：
- en: '![There''s more…](img/Image_03_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/Image_03_06.jpg)'
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")《AndEngine游戏结构》中*处理不同类型的纹理*。
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")《使用实体》中*用精灵为场景赋予生命*。
- en: '*Applying a background* given in this chater.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节提供的*应用背景*。
- en: Creating our level selection system
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的关卡选择系统
- en: 'Chances are, if you''ve ever played a mobile game with multiple levels then
    you already have an idea of what we''ll be working with in this chapter. We''re
    going to be creating a class which provides our game with a grid containing level
    tiles that we can use in order to allow a user to select a level to play. This
    class can be very easily managed and is highly customizable, from button texture,
    column count, row count, and more, with ease. The end result will look something
    like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过带有多个关卡的移动游戏，那么你可能已经知道我们将在本章中处理什么。我们将创建一个类，为游戏提供一个包含关卡瓦片的网格，以便用户可以选择一个关卡进行游戏。这个类非常易于管理，并且高度可定制，从按钮纹理、列数、行数等，都可以轻松设置。最终结果将如下所示：
- en: '![Creating our level selection system](img/978-1-849518-98-7_03_04a.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的关卡选择系统](img/978-1-849518-98-7_03_04a.jpg)'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This implementation of the `LevelSelector` class extends AndEngine's `Entity`
    object. This makes applying transitional effects with entity modifiers and allowing
    scrolling based on touch events a rather trivial task.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelSelector`类的这个实现扩展了AndEngine的`Entity`对象。这使得应用实体修改器和基于触摸事件的滚动变得相当简单。'
- en: Getting ready…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: The `LevelSelector` class is highly based on the use of AndEngine's `Entity`,
    `Sprite`, and `Text` objects. In order to understand how `LevelSelector` works,
    please take the time to go over the recipes regarding these objects. These recipes
    include, *Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*, *Bringing a scene to life with sprites*
    in [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*,
    and *Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelSelector`类高度依赖于AndEngine的`Entity`、`Sprite`和`Text`对象的使用。为了理解`LevelSelector`是如何工作的，请花时间阅读关于这些对象的相关内容。这些内容包括[第2章](ch02.html
    "第2章. 使用实体")中的*理解AndEngine实体*，*使用实体*，*用精灵使场景生动*，以及*将文本应用到图层*。'
- en: The `LevelSelector` object requires an `ITextureRegion` object with a reference
    to an image file. Feel free to create an image which will represent a square button
    at 50 x 50 pixels in dimension, such as those seen in the figure in this recipe's
    introduction. While this `ITextureRegion` object is not needed internally within
    the `LevelSelector` class, it is needed in order to test out the `LevelSelector`
    class in an empty `BaseGameActivity` test project at the end of this recipe.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelSelector`对象需要一个带有图像文件引用的`ITextureRegion`对象。可以自由创建一个表示50x50像素尺寸的方形按钮的图像，如本食谱介绍中的图所示。虽然这个`ITextureRegion`对象在`LevelSelector`类内部并不需要，但在本食谱末尾在空的`BaseGameActivity`测试项目中测试`LevelSelector`类时需要它。'
- en: Refer to the class named `LevelSelector` in the code bundle for the working
    code for this recipe. Feel free to use this class and modify it as you see fit
    in order to fit the needs of your own games!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`LevelSelector`的类，以获取此食谱的工作代码。请随意使用这个类，并根据你的游戏需求进行修改！
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The `LevelSelector` class is actually quite simple to work with even though
    its size might be quite large. In this recipe, we're actually going to be introducing
    two classes; the first is the `LevelSelector` class which handles how the level
    tiles, or buttons, come to form a grid on the scene. The second is an inner class
    of `LevelSelector`, called `LevelTile`. The `LevelTile` class allows us to easily
    add or remove additional data that may be necessary for our own games. For the
    sake of keeping things simple, we're going to discuss each of the two classes
    in their own steps starting with the `LevelSelector` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其规模可能相当大，但`LevelSelector`类实际上非常易于使用。在这个食谱中，我们将介绍两个类；第一个是处理关卡瓦片（或按钮）如何在场景上形成网格的`LevelSelector`类。第二个是`LevelSelector`的内部类，称为`LevelTile`。`LevelTile`类允许我们轻松添加或删除可能对游戏有用的额外数据。为了保持简单，我们将分别讨论这两个类，从`LevelSelector`类开始。
- en: 'The following steps explain how the `LevelSelector` class works in order to
    arrange `LevelTile` objects on the scene in a grid format:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了`LevelSelector`类如何以网格格式在场景上排列`LevelTile`对象：
- en: 'Create the `LevelSelector` constructor, initializing all variables. This constructor
    is straightforward until we come to the point where we must specify the very first
    `LevelTile` object''s position via the `mInitialX` and `mInitialY` variables:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`LevelSelector`构造函数，初始化所有变量。这个构造函数很直接，直到我们必须通过`mInitialX`和`mInitialY`变量指定第一个`LevelTile`对象的位置：
- en: '[PRE17]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we must create the method which will be used to build the `LevelSelector`
    object''s tile grid. We are creating a method called `createTiles(pTextureRegion,
    pFont)` which makes creating the level tile grid completely automated by looping
    through a set number of `ROWS` and `COLUMNS` values, placing tiles in predetermined
    coordinates:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个方法，用于构建`LevelSelector`对象的瓦片网格。我们正在创建一个名为`createTiles(pTextureRegion,
    pFont)`的方法，通过循环一定的`ROWS`和`COLUMNS`值，将瓦片放置在预定的坐标中，从而完全自动化创建关卡瓦片网格：
- en: '[PRE18]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The third and final step for the `LevelSelector` class is to include two methods;
    one for displaying the `LevelSelector` class'' grid and another for hiding the
    `LevelSelector` class'' grid. For simplicity, we''ll call these methods `show()`
    and `hide()` with no parameters:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LevelSelector`类的第三步也是最后一步是包含两个方法；一个用于显示`LevelSelector`类的网格，另一个用于隐藏`LevelSelector`类的网格。为了简单起见，我们将这些方法称为`show()`和`hide()`，不带参数：'
- en: '[PRE19]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we move on to the `LevelTile` class'' steps. The `LevelTile` inner class
    is an extension of AndEngine''s `Sprite` object. The reason we implement our own
    `LevelTile` class is to allow each tile to store its own data, such as whether
    the level the tile represents is locked or not, `Font` and `Text` objects used
    to display the tile''s level number, the tile''s level number itself, and more.
    This class can easily be modified to store even more information such as a user''s
    high-score for a specific level, level color themes, or whatever else we''d like
    to include. The following steps walk us through the creation of the `LevelTile`
    inner class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续讨论`LevelTile`类的步骤。`LevelTile`内部类是AndEngine的`Sprite`对象的扩展。我们实现自己的`LevelTile`类的原因是让每个瓦片存储自己的数据，例如瓦片表示的关卡是否锁定，用于显示瓦片关卡编号的`Font`和`Text`对象，瓦片的关卡编号本身等等。这个类可以很容易地被修改以存储更多信息，例如特定关卡的用户的最高分，关卡颜色主题，或者我们想要包含的任何其他内容。以下步骤将引导我们创建`LevelTile`内部类：
- en: 'Create the `LevelTile` constructor:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`LevelTile`构造函数：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the necessary getters for the `LevelTile` class. For a basic `LevelTile`
    class such as this, all we''ll need access to is data regarding the locked state
    of the level number the tile represents as well as the level number the tile represents:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`LevelTile`类创建必要的getter方法。对于这样一个基本的`LevelTile`类，我们只需要访问有关瓦片表示的关卡编号的锁定状态以及瓦片表示的关卡编号的数据：
- en: '[PRE21]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to display the level number on each `LevelTile` object, we''ll create
    an `attachText()` method to handle applying a `Text` object to each `LevelTile`
    object after it is created:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在每个`LevelTile`对象上显示关卡编号，我们将创建一个`attachText()`方法，以在创建每个`LevelTile`对象后处理将`Text`对象应用到它们上面：
- en: '[PRE22]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Last but certainly not the least, we''ll override the `onAreaTouched()` method
    of the `LevelTile` class in order to provide a default action in the event a tile
    is pressed down on. The event executed should differ depending on the `mIsLocked`
    Boolean value:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将重写`LevelTile`类的`onAreaTouched()`方法，以便在瓦片被按下时提供一个默认操作。执行的的事件应根据`mIsLocked`布尔值的不同而有所不同：
- en: '[PRE23]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This implementation of a `LevelSelector` class allows us to create a grid of
    selectable level tiles by adding a minimal amount of code in our activity. Before
    we go over the implementation of the `LevelSelector` class into our activity,
    let's take a look at how this class works in order to give us an idea of how we
    might modify this class to better suit the specific needs of a range of different
    games. Just as the *How to do it...* section divides the steps into two segments
    based on each of the two classes used in this recipe, we will also explain how
    each class works in two segments. We will start with the `LevelSelector` class
    once again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`LevelSelector`类的实现允许我们通过在活动中添加少量的代码来创建可选择关卡瓦片的网格。在我们讨论将`LevelSelector`类实现到我们的活动中之前，让我们看看这个类是如何工作的，以便我们了解如何可能修改这个类以更好地满足一系列不同游戏的具体需求。正如*如何做…*部分根据这个食谱中使用的两个类将步骤分为两段一样，我们也将分两个部分解释每个类是如何工作的。我们将再次从`LevelSelector`类开始。
- en: Explaining the LevelSelector class
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释`LevelSelector`类
- en: 'First and foremost, the `LevelSelector` class includes a number of member variables,
    which we should get to know in order to take full advantage of this object. The
    following is a list of the variables used in this class along with a description
    for each:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`LevelSelector`类包含了许多成员变量，我们需要了解这些变量，才能充分利用这个对象。以下是在此类中使用变量的列表以及每个变量的描述：
- en: '`COLUMNS`: The number of `LevelTile` objects to be displayed on the horizontal
    axis of the `LevelSelector` class'' grid.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLUMNS`：`LevelSelector`类网格水平轴上显示的`LevelTile`对象数量。'
- en: '`ROWS`: The number of `LevelTile` objects to be displayed on the vertical axis
    of the `LevelSelector` class'' grid.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROWS`：`LevelSelector`类网格垂直轴上显示的`LevelTile`对象数量。'
- en: '`TILE_DIMENSION`: The width and height values of each individual `LevelTile`
    object.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TILE_DIMENSION`：每个单独的`LevelTile`对象的宽度和高度值。'
- en: '`TILE_PADDING`: The spacing, in pixels, between each `LevelTile` object on
    the `LevelSelector` class'' grid.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TILE_PADDING`：`LevelSelector`类网格上每个`LevelTile`对象之间的间距（以像素为单位）。'
- en: '`mChapter`: This value defines the `LevelSelector` class'' chapter value. This
    variable can allow us to create a number of `LevelSelector` objects which represent
    different chapters/worlds/zones within our game by specifying different chapter
    values for each `LevelSelector` object.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mChapter`：此值定义了`LevelSelector`类的章节值。这个变量可以让我们通过为每个`LevelSelector`对象指定不同的章节值，创建代表游戏内不同章节/世界/区域的一系列`LevelSelector`对象。'
- en: '`mMaxLevel`: This value defines the maximum unlocked level that a user has
    currently reached within our game. This variable would be tested against the level
    number of each `LevelTile` object that is touched. Users should not be allowed
    entry into levels which are greater than this variable.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mMaxLevel`：此值定义了用户在我们游戏中当前已达到的最高解锁等级。这个变量将会与每个被触碰的`LevelTile`对象的等级数字进行测试。不应该允许用户进入大于此变量的等级。'
- en: '`mCameraWidth`/`mCameraHeight`: These values are simply used to help properly
    align the `LevelSelector` and `LevelTile` objects in the center of the scene.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCameraWidth`/`mCameraHeight`：这些值仅用于帮助将`LevelSelector`和`LevelTile`对象正确对齐在场景中心。'
- en: '`mInitialX`: This variable is in place to hold a reference to the initial x
    coordinate of each of the `LevelSelector` class'' grid rows. Each time an entire
    row of the grid is laid out, the first `LevelTile` object of the next row reverts
    back to this x coordinate.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mInitialX`：此变量用于保存`LevelSelector`类网格每一行的初始x坐标的引用。每次网格的一整行布局完成后，下一行的第一个`LevelTile`对象将返回到这个x坐标。'
- en: '`mInitialY`: This variable is used only once to define the very first `LevelTile`
    object''s y coordinate. Since we''re building the `LevelSelector` class'' grid
    from left to right and from the top to bottom, we will never have to revert back
    to the initial y coordinate for subsequent tile placement.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mInitialY`：此变量仅用于定义第一个`LevelTile`对象的y坐标。由于我们是按照从左到右、从上到下的方式构建`LevelSelector`类的网格，因此在后续的瓷砖放置中，我们无需返回到初始的y坐标。'
- en: '`mHidden`: The `boolean` statement of this variable determines whether or not
    the `LevelTile` objects will respond to touch events. This variable is set `true`
    if the `LevelSelector` object is not visible on the scene, `false` otherwise.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mHidden`：此变量的布尔值确定`LevelTile`对象是否响应触摸事件。如果`LevelSelector`对象在场景中不可见，此变量设置为`true`，否则为`false`。'
- en: With all of the member variables out of the way, understanding how the `LevelSelector`
    class works will be a breeze! In the first step, we're creating the `LevelSelector`
    constructor to initialize all of the class variables. The constructor should be
    easy to follow up until the point where we define the `mInitialX` and `mInitialY`
    variables. All we are doing is calculating half of the overall width and height
    of the `LevelSelector` class' grid based on the number of columns, the number
    of rows, the tile dimension, and the tile padding. To calculate the overall width,
    we need to multiply the number of `COLUMNS` values by the width of each `LevelTile`
    object. Since we're including padding between each tile, we must also calculate
    how much space the padding will consume. However, padding will only occur in between
    tiles, meaning there will be no padding to calculate for the final column, so
    we can subtract a column from the padding calculation. We then divide this value
    by half in order to come up with half the width of the entire grid. Finally, subtracting
    half the width of the entire grid from the center position of the `Camera` object
    will give us the first `LevelTile` object's x coordinate! The same math applies
    to calculate the initial y coordinate, except the y axis deals with rows instead
    of columns, so we need to make that adjustment in the `mInitiaY` variable calculation
    in order to obtain the proper y coordinate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The second step for the `LevelSelector` class introduces the method of `LevelTile`
    object creation and placement. This is where the grid-making magic begins. Before
    we begin the iteration, we declare and define temporary coordinates which will
    be used to place each `LevelTile` object on the grid, incrementing their value
    accordingly after each tile is placed. The `TILE_DIMENSION * 0.5f` calculations
    are simply in place to accommodate for AndEngine's `Entity` object's anchor, or
    placement coordinate relying on the center of the `Entity` object. Additionally,
    we are initializing a temporary level number called `currentTileLevel` which is
    initialized to `1`, which signifies the level 1 tile. This variable is incremented
    by a value of 1 each time a level tile is placed on the grid. Once the initial
    level tile's values have been defined, we proceed to create the `for` loops which
    will loop through each position of the rows and columns which make up the grid.
    Starting with the first row, we will then loop N number of columns, incrementing
    the `tempX` variable by adding `TILE_DIMENSION` and `TILE_PADDING` after each
    tile is placed which will give us the next position. Once we reach the maximum
    number of columns, we decrease the `tempY` variable by adding `TILE_DIMENSION`
    and `TILE_PADDING` in order to drop us to the next row to populate. This process
    continues on until there are no rows left to populate.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The final step included in the `LevelSelector` class includes the code which
    calls `setVisible(pBoolean)` on the `LevelSelector` object, enabling visibility
    if the `show()` method is called and disabling visibility if the `hide()` method
    is called. The first time a `LevelSelector` object calls `show()`, it will be
    attached to the `Scene` object. Additionally, the `mHidden` variable will be adjusted
    according to the visibility of the `LevelSelector` object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the LevelTile class
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the `LevelSelector` class, we will begin by outlining the purpose of
    the different `LevelTile` class member variables. The following is a list of the
    variables used in this class along with a description for each:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`mIsLocked`: The `mIsLocked` Boolean variable is defined by a parameter in
    the `LevelTile` constructor. This variable defines whether or not this `LevelTile`
    object''s touch event should produce a positive event, such as proceeding to load
    a level, or a negative event, such as notification that the level is locked.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mLevelNumber`: This variable simply holds the value of the `LevelTile` object''s
    level number representation. This value is determined according to its position
    on the grid; for example, the first tile placed on a grid will represent level
    1, the second tile will represent level 2, and so on.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mFont` and `mTileText`: The `mFont` and `mTileText` objects are used to display
    a `Text` object on each `LevelTile`. If the `LevelTile` object is considered to
    be locked, a string displaying the word, **locked** will be displayed on the tile,
    otherwise the level number of the tile is displayed.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `LevelTile` class' first step, we're simply introducing the constructor.
    There's nothing out of the ordinary here. However, one thing to note is that the
    constructor does rely on the constant `TILE_DIMENSION` value to specify the tile's
    width/height dimensions without specifying a parameter. This is in place to keep
    a level of conformity between the `LevelSelector` and `LevelTile` classes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we had introduced two getter methods which can be used to
    obtain the more important values of the `LevelTile` class. Even though we aren't
    currently using these methods within either class, they can be important later
    on when the `LevelSelector`/`LevelTile` objects are implemented into a full-featured
    game which requires data such as level numbers to be passed around within the
    game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The third step introduces a method which is used to attach a `Text` object to
    `LevelTile` called `attachText()`. This method will place the `mTileText` object
    in the direct center of the `LevelTile` object with a string dependent on the
    `LevelTile` object's locked state. As stated in the `mFont` and `mTileText` variable
    explanation, the `mTileText` object's `String` variable will display either **locked**
    or the tile's level number.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step requires us to override the `onAreaTouched()` method of the
    `LevelTile` object. Before we even consider responding to a touch event on any
    tile, we first determine whether or not the `LevelSelector` object containing
    the `LevelTile` object is visible. If not, there is no point in proceeding with
    any touch events, but if the `LevelSelector` object is visible then we proceed
    to check whether the tile was pressed down on. If a `LevelTile` object is pressed
    down on, we then continue to check whether or not the tile is locked or unlocked.
    In the class'' current state, we are simply setting the color of the scene''s
    background in order to signify whether or not the pressed tile is locked or not.
    However, in a real-world application, the current locked event can be replaced
    with a basic notification stating that the selected tile is locked. In the event
    that a tile is not locked, then the touch event should take the user to the selected
    level based on the `LevelTile` object''s `mLevelNumber` variable. If the game
    contains multiple chapters/worlds/zones, then we could even go as far as the following
    pseudo-code implementation, depending on the game''s method of loading levels:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've included the `LevelSelector` class into any project we choose, we
    can easily implement a working-level selection grid into our `BaseGameActivity`.
    In order to properly create the `LevelSelector` object and display it on our scene,
    we'll need to make sure we've created an `ITextureRegion` object and `Font` object
    to be used when creating the `LevelTile` objects for the `LevelSelector` class.
    We're going to omit the resource creation code in order to keep the `LevelSelector`
    class' example brief. If need be, please visit the recipes, *Working with different
    types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*, and *Using AndEngine font resources* in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*, for more information
    on how to set up the necessary resources for this class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code displaying how to create the `LevelSelector` object can
    be copied into the `onCreateScene()` method of any activity prior to creating
    the necessary `ITextureRegion` and Font `objects`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A great feature of this `LevelSelector` class is the fact that it is an `Entity`
    object subtype. If we wish to apply fancy transition effects for it to move in
    and out of the camera's view as needed, we can simply call `levelSelector.registerEntityModifier(pEntityModifier)`.
    Since the `LevelTile` objects are attached to the `LevelSelector` object upon
    calling the `createTiles()` method, any change in the `LevelSelector` object's
    position will also affect all `LevelTile` objects, in sync. This also makes creating
    scrollable level selector implementation very easy to add if dealing with multiple
    chapters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding and retrieving layers
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different options we have for screen management in our games;
    a screen being a menu screen, loading screen, gameplay screen, and more. We can
    use multiple activities to act as each screen, we can use the more obvious `Scene`
    object to act as each screen in our game, or we can use `Entity` objects to act
    as each screen. While the majority of developers tend to follow the multiple activities
    or multiple `Scene` objects to act as different game screens, we're going to be
    taking a quick look into using `Entity` objects to act as the different screens
    in our games.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Using `Entity` objects to act as the various screens of our game has many benefits
    over the other two approaches mentioned. The entity approach allows us to apply
    many different screens, or layers to our game at the same time. Unlike with using
    multiple activities or `Scene` objects to act as different screens in our game,
    we can visually display a number of screens on the device using `Entity` objects.
    This is extremely useful as we can apply transitional effects when entering or
    leaving gameplay and easily load and unload resources as we see fit.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image displays this recipe''s code in action. What we''re seeing
    is two `Entity` object layers with a number of `Rectangle` children objects alternating
    between being transitioned in and transitioned out of the camera''s view. This
    represents how we can use `Entity` objects to handle transitional effects among
    a small or large group of children:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Hiding and retrieving layers](img/Image_03_07.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Getting ready…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires an understanding of `Entity` objects and how they can be
    used as layers to contain a set of children. Additionally, we're incorporating
    transitional effects to these layers through the use of entity modifiers. Before
    continuing on with this recipe, please make sure to read through the entire recipes,
    *Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*, *Overriding the onManagedUpdate() method*
    in [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*,
    and *Using modifiers and entity modifiers* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the class named `HidingAndRetrievingLayers` in the code bundle for
    the working code for this recipe and import it into an empty AndEngine `BaseGameActivity`
    class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps outline how we can use entity modifiers to handle transitional
    effects between different screens/layers within our game. This recipe includes
    a simple method which handles the transitioning of layers, however in a real-world
    application this task is generally performed with the use of a screen/layer manager
    class. The layers are swapped based on the time passed solely for the purpose
    of automated demonstration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and define the layers/screens as `Entity` objects and the transitional
    effects with `ParallelEntityModifier` objects. These objects should be global:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `mScene` object, overriding its `onManagedUpdate()` method in order
    to handle calling the `setLayer(pLayerIn, pLayerOut)` method introduced in the
    next step. Additionally, we will attach our `Entity` object layers once the `mScene`
    object has been created:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, we will create a `setLayer(pLayerIn, pLayerOut)` method which we can
    use to handle registering the entity modifiers to the appropriate `Entity` object,
    depending on if it should be entering or leaving the camera''s view:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe covers a simple, yet useful system relating to working with `Entity`
    layer transitioning. Larger games will likely involve more variables to take into
    account when handling layer swapping, but the concept is relevant across all project
    sizes as far as entity/screen indexing and creating the method of transitioning
    screens goes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In the first step we are creating our global objects. The three `Entity` objects
    will represent the different screens within our game. In this recipe, all three
    of the `Entity` objects contain four `Rectangle` children objects,which allow
    us to visualize the screen transitions, however we can interpret each of the three
    `Entity` objects as a different screen such as the menu screen, the loading screen,
    and the gameplay screen. We are also creating two global `ParallelEntityModifier`
    entity modifiers to handle the positional changes of the screens. The `mMoveInModifier`
    modifier will move the registered screen from outside the right-hand side of the
    camera's view into the center of the camera's view. The `mMoveOutModifier` modifier
    will move the registered screen from the center of the camera's view to outside
    the left-hand side of the camera's view. Both modifiers include a simple rotation
    and scaling effect to produce a "rolling" transitional effect.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we are creating our `mScene` object and attaching the globally-declared
    `Entity` objects to it. In this recipe, we are setting up the `mScene` object
    to handle screen swapping based on the time passed, however before discussing
    how the `onManagedUpdate()` method of the `mScene` object works to handle screen
    swapping, let''s take a look at how we''re obtaining our `Entity` object indices
    as they will be used to determine which screens will be transitioned:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see in this code snippet, we are attaching the screens in numerical
    order according to their name. Once an `Entity` object has been attached to the
    `Scene` object, we can then call the method, `getChildByIndex(pIndex)` on a parent
    in order to obtain an `Entity` object by its index. A child's index is determined
    by the order they are attached to another object. We use these indices within
    the `mScene` object's `onManagedUpdate()` method in order to determine which entity/screen
    to swap in and which to swap out of the camera's view every four seconds.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: During the initialization of the `mScene` object, we are instantiating two `int`
    variables which will be used to determine which screens to transition in and out
    of the camera's view. Initially, we are defining `layerInIndex` to a value of
    `0`, which is equal to the `mScreenOne` object's index and `layerOutIndex` to
    a value of `SCREEN_COUNT – 1`, which is equal to the `mScreenThree` object's index
    based on the order they were attached to the `Scene` object. After every four
    seconds within the `onManagedUpdate()` method of the `mScene` object, we are calling
    the `setLayer(pLayerIn, pLayerOut)` method to begin the screen transitioning,
    resetting the `timeCounter` variable to accumulate the next four seconds, and
    determining the next `Entity` objects to be transitioned in and out of the camera's
    view. While this example is not exactly relative to most games, it is meant to
    give us an understanding of how we can use child indices to make transition calls
    with a method such as `setLayer(pLayerIn,pLayerOut)`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the final step, we introduce the `setLayer(pLayerIn, pLayerOut)` method which
    handles the application of entity modifiers to the `Entity` objects passed in
    via parameters. This method has three goals; first it sets the layer being transitioned
    into the view to be visible if it's currently non-visible, it resets our `mMoveInModifier`
    and `mMoveOutModifier` objects, so that they can provide the `Entity` objects
    with full transitional effects, and lastly it calls `registerEntityModifier(pEntityModifier)`
    on both the `pLayerIn` and `pLayerOut` parameters, initiating the transitional
    effectson the `Entity` objects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is only relevant for game structures which use multiple `Entity`
    objects to act as different screens within our games. However, the choice between
    how to handle transitioning between screens is entirely up to the developer. Before
    making a decision, it is wise to know what the pros and cons are to the different
    options we have for handling multiple screens within a game. Please take a look
    at the following list which covers the good and the bad of the different approaches:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity/screen**:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: The Android OS will handle resource unloading for us with a simple call
    to the activity''s `finish()` method, making resource management very simple.'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Each screen transition will prompt a brief black screen to be displayed
    upon launching a new activity/screen.'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Multiple activities must each load their own resources. This means that
    preloading resources is not an option, which can increase the overall loading
    time, especially considering resources that may be used on all screens, such as
    font, or music playback resources.'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Due to Android''s memory management features, activities which are considered
    background processes may be killed at any time assuming the device is running
    low on memory. This can cause issues when we leave an activity which should remain
    in a paused state until a user returns. There is a possibility any activity transitioned
    from may not be returned to in the same state when needed.'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene/screen**:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: Possibility of preloading necessary resources which may be used across
    multiple screens. This can drastically help reduce loading times depending on
    the number of preloadable resources.'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: We are able to introduce a loading screen within our game, rather than
    displaying a blank screen while the resources load.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro/con: A screen and resource management system must be developed in order
    to handle the loading/unloading of resources and screens. Depending on the size
    and needs of the specific game, this can be a rather large task. However, this
    approach can allow for seamless transition times when moving between screens as
    we are able to load/unload resources at more convenient times, rather than as
    soon as a user decides to switch between screens.'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Typically only one `Scene` object can be applied to our Engine object
    at a time, meaning that screen transitions will be lacking in terms of animation/fluidity.
    The screen being set will simply replace the previous screen.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity/screen**:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: When dealing with `Entity` objects as screens, we are able to attach as
    many as we''d like to a `Scene` object. This gives us all of the pro''s of the
    scene/screen approach, as well as the added benefit of being able to add time-based
    transitional effects, such as "sliding" between the menu screen, to the loading
    screen, to the gameplay screen. This is the demonstration being made by this recipe''s
    code.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro/con: As with the scene/screen route, we are required to handle all screen
    and resource cleanup ourselves. The positive outweighs the negative, but when
    comparing with the activity/screen approach, the need for a screen/resource management
    system may be considered a con by some, depending on the size of the project.'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we wrap up this recipe, there''s one more important topic that was not
    discussed in this recipe. Take a look at the following figure which displays what
    this recipe''s displayed results on a device might resemble:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/Image_03_08.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: The preceding figure displays the typical transitional events when a user navigates
    around the different screens within a game. We covered how this navigation works
    in terms of bringing a new screen into the camera's view. Even more importantly,
    these transitional events should also handle the loading and unloading of resources.
    After all, there's no reason to have the **Menu screen** taking up the device's
    precious resources while it's not being displayed to the user. In an ideal situation
    if we are moving from the **Menu screen** to the **Game-play screen** as seen
    in the previous figure, during the **T1** phase the **Game-play** screen will
    begin to load its resources. Once the **T2** phase is reached, meaning the **Loading
    screen** is the game's current main screen, the **Menu screen** will be unloaded
    of all necessary resources and detached from the `Scene` object in order to remove
    the unnecessary overhead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This is just a brief overview of how transitioning between screens within a
    game is best handled in order to allow smooth transitions, and reduce the load-time
    involved between transitions. For a more in-depth information on the inner-workings
    of screen management, please see [Chapter 5](ch05.html "Chapter 5. Scene and Layer
    Management"), *Scene and layer management*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overriding the onManagedUpdate() method* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using modifiers and entity modifiers* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
