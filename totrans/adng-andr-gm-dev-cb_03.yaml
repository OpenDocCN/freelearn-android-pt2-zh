- en: Chapter 3. Designing Your Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will begin to take a look at how to create a manageable
    menu system with AndEngine. The topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to the menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding music to the menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parallax backgrounds to create perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our level selection system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding and retrieving layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Menu systems in games are essentially a map of the scenes or activities a game
    provides. In a game, a menu should look attractive and give a subtle hint of what
    to expect during gameplay. The menu should be organized and easy for a player
    to understand. In this chapter, we're going to take a look at various options
    we have which we can apply to our own games in order to create functional and
    appealing menus for any type of game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to the menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In AndEngine, we can create touch-responsive buttons out of any `Entity` object
    or `Entity` object subtype. However, AndEngine includes a class called `ButtonSprite`
    whose texture representation depends on whether the `Entity` object is pressed
    or unpressed. In this recipe, we're going to take advantage of AndEngine's `ButtonSprite`
    class and override its `onAreaTouched()` method in order to add touch-responsive
    buttons to our menu and/or game's `Scene` object. Additionally, the code within
    this recipe regarding touch events can be applied to any other `Entity` object
    within our game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine. Please
    read through the entire recipe, *Working with different types of textures* in
    [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*, specifically the section regarding tiled texture regions. Next, visit
    the recipe, *Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the recipes regarding textures and sprites have been covered, create a
    new AndEngine project with an empty `BaseGameActivity` class. Finally, we will
    need to create a sprite sheet named `button_tiles.png` with two images and place
    it in the `assets/gfx/` folder of the project; one for the "unpressed" button
    representation and one for the "pressed" button representation. See the following
    image for an idea of what the image should look like. The following image is 300
    x 50 pixels, or 150 x 50 pixels per tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/978-1-849518-98-7_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Refer to the class named `CreatingButtons` in the code bundle and import the
    code into your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ButtonSprite` class is convenient as it handles the tiled texture region
    versus button state changes for us. The following steps outline the tasks involved
    in setting up a `ButtonSprite` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a global `ITiledTextureRegion` object, naming it `mButtonTextureRegion`,
    then in the `onCreateResources()` method of the `BaseGameActivity` class, create
    a new `BuildableBitmapTextureAtlas` object suitable for your `button_tiles.png`
    image. Build and load the texture region and texture atlas objects so that we
    can use them later to create the `ButtonSprite` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order for the `ButtonSprite` object to work as intended, we should set up
    proper touch area binding on the `mScene` object. Copy the following code into
    the `onCreateScene()` method of the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `ButtonSprite` object, supplying it the `mButtonTextureRegion` object
    and overriding its `onAreaTouched()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to register the touch area and attach the `buttonSprite`
    object to the `mScene` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe makes use of a `ButtonSprite` object with an `ITiledTextureRegion`
    object to display two separate button states. One tile will act as the button's
    unpressed texture, the other will act as the button's pressed texture when a finger
    is touching the `Entity` object on the display.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we are creating our texture resources to be applied to the
    `ButtonSprite` object, which will be implemented in the coming steps. The `ButtonSprite`
    class will need an `ITiledTextureRegion` object with two indices, or two tiles
    as seen in the figure in the *Getting started...* section of this recipe. The
    first index of the `ITiledTextureRegion` object should contain the unpressed representation
    of the button, which will be applied to the `ButtonSprite` object by default.
    The second `ITiledTextureRegion` index should represent a pressed state of the
    `ButtonSprite` object. The `ButtonSprite` class will automatically alternate between
    these two `ITiledTextureRegion` indices depending on which state the `ButtonSprite`
    object is currently in; being either `ButtonSprite.State.NORMAL` for unpressed,
    setting the `ButtonSprite` object's current tile index to `0`, and `ButtonSprite.State.PRESSED`
    for, you guessed it, the pressed state which sets the `ButtonSprite` object's
    current tile index to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, in order for the `ButtonSprite` object to work as intended,
    we need to enable touch area binding on the down action within the `mScene` object.
    We enable this within the `onCreateScene()` method of our activity's life cycle,
    just after the `mScene` object is created. What this does is, it allows our `ButtonSprite`
    object to register as unpressed when we drag our finger off of the `ButtonSprite`
    touch area. Disregarding this step will cause the `ButtonSprite` object to remain
    in a pressed state in the event that we press and drag our finger off the `Entity`
    object's touch area, which may very well be considered "buggy" if left for players
    to deal with. In the third step, we create the `ButtonSprite` object, centering
    it in within the scene. Ideally, we can create the `ButtonSprite` object and place
    it on the scene and it will work as it should. However, `ButtonSprite` is a button,
    after all, and therefore it should prompt an event to occur when pressed. We can
    do this by overriding the `onAreaTouched()` super method and creating events based
    on whether the `ButtonSprite` object's touch area is pressed down on, if a finger
    is dragged over it, or if a finger is released from the display while inside the
    touch area. In this recipe, we're simply displaying a `Toast` message in the event
    that the `ButtonSprite` object's `pSceneTouchEvent` registers the `isActionDown()`
    method. In a more realistic scenario during the development of a game, this button
    may just as well allow/disallow sound muting, start a new game, or any other action
    we choose for it. The other two methods used for touch event state-checking are
    `pSceneTouchEvent.isActionMove()` and `pSceneTouchEvent.isActionUp()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once the `buttonSprite` object has been created we will need to register
    the touch area and attach the `Entity` object to the `mScene` object. By now,
    we should be well aware that in order to display an entity on the scene we must
    first attach it. Just as well, in order for the `buttonSprite` object's `onAreaTouched()`
    super method to execute, we must remember to call `mScene.registerTouchArea(buttonSprite)`.
    The same goes for any other `Entity` object for which we wish to provide touh
    events.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding music to the menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this topic, we're going to create a mute button which will control our menu's
    theme music. Pressing the mute button will cause the music to either play if currently
    paused, or pause if currently playing. This method for muting music and sounds
    can also be applied to in-game options and other areas of a game which allow sound
    and music playback. The difference between this recipe and the previous, is that
    we're going to be using a `TiledSprite` object which will allow us to set the
    `Sprite` object's tile index depending on whether the sound is playing or paused.
    Keep in mind that this recipe is useful for more than just enabling and disabling
    menu music. We can also follow the same approach for many other toggle-able options
    and states during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine as
    well as using touch events to perform actions. Additionally, since we'll be incorporating
    the `Music` object into this recipe, we should understand how to load `Sound`
    and `Music` objects into our game's resources. Please read through the entire
    recipe, *Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*, specifically the section regarding
    tiled texture regions. Next, check into the recipe, Introducing sounds and music
    in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*. Finally, we will be working with sprites, so we should take a quick
    peak into the recipe, *Bringing a scene to life with sprites*, in [Chapter 2](ch02.html
    "Chapter 2. Working with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the topics regarding textures, sounds, and sprites have been covered,
    create a new AndEngine project with an empty `BaseGameActivity` class. We will
    need to create a sprite sheet named `sound_button_tiles.png` with two images and
    place it in the `assets/gfx/` folder of the project; one for the "non-muted" button
    representation and one for the "muted" button representation. See the following
    image for an idea of what the image should look like. The following image is 100
    x 50 pixels, or 50 x 50 piels per tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/Image_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will also need to include a sound file that is in the MP3 format in the `assets/sfx/`
    folder of our project. The sound file can be any preferred music track of your
    choice for the purpose of executing this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the class named `MenuMusic` in the code bundle and import the code
    into your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe introduces a combination of AndEngine features. We are combining
    music, textures, sprites, tiled texture regions, and touch events all into one
    convenient little package. The result—a toggle button that will control the playback
    of a `Music` object. Follow these steps to see how we create the toggle button.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we will be working with two global objects; `mMenuMusic`
    which is a `Music` object and `mButtonTextureRegion` which is an `ITiledTextureRegion`
    object. In the `onCreateResources()` method of the activity, we create these objects
    with their respective resources in the `assets/*` folder. Refer to the recipes
    mentioned in the *Getting started...* section for more information on creating
    these resources if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we can skip directly to the `onPopulateScene()` method of the activity
    where we will create our `mMuteButton` object using the `TiledSprite` class. We
    will need to override the `onAreaTouched()` method of the `mMuteButton` object
    in order to either pause or play the music when the button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the button has been created, we need to initialize the `mMuteButton` and
    `mMenuMusic` objects'' initial states. This step involved setting the `mMuteButton`
    object''s tile index to that of the `UNMUTE` constant value which equals `1`,
    registering and attaching the `mMuteButton` object to the `mScene` object, setting
    `mMenuMusic` to loop, and then finally calling `play()` on the `mMenuMusic` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step to include when dealing with any `Music` object is to make sure
    we pause it upon app minimization, otherwise it will continue to play in the background.
    In this recipe, we are pausing the `mMenuMusic` object on minimization. However,
    in the event a user returns to the application, the music will play only if the
    `mMuteButton` object''s tile index was equal to the `UNMUTE` constant value when
    the app was minimized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This particular recipe is very useful in game development; not only for sound
    and music muting, but for all sorts of toggle buttons. While this recipe is dealing
    specifically with `Music` object playback, it contains all of the necessary code
    in order to start working with various other toggle buttons which might suit the
    more specific needs of our games.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we must set up the necessary resources for use within the
    `mMenuMusic` object and the `mMuteButton` object. The `mMenuMusic` object will
    load a sound file named `menu_music.mp3`, which can be any MP3 file, preferably
    a music track. The `mMuteButton` object will load a sprite sheet called `sound_button_tiles.png`
    with two separate tiles. These objects are both taken care of within the `onCreateResourceS()`
    method of the `BaseGameActivity` object's life cycle. More information on the
    creation of these resources can be found within the recipes mentioned in the *Getting
    started...* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we are setting up the `mMuteButton` object, which is of the `TiledSprite`
    type. The `TiledSprite` class allows us to use an `ITiledTextureRegion` object
    which gives us the ability to set the current tile index that the `mMuteButton`
    object will display on our scene. In the overridden `onAreaTouched()` method,
    we check to see whether or not the `mMuteButton` object has been pressed down
    on with the `if (pSceneTouchEvent.isActionDown())` statement. We then proceed
    to determine whether or not the `mMenuMusic` object is currently playing with
    the `isPlaying()` method of the `Music` object. If the music is playing, then
    pressing a finger down on the `mMuteButton` button will cause the `mMenuMusic`
    object to call `pause()` and revert the `mMuteButton` object's current tile index
    to that of the `MUTE` constant value, which is equal to `0`. If the music is not
    playing, then we do the exact opposite, calling `play()` on the `mMenuMusic` object
    and reverting the `mMuteButton` object's tile index back to `UNMUTE`, which is
    equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we are setting up the `mMenuMusic` and `mMuteButton` objects'
    default state, which is equal to playing the music and setting the current tile
    index to `UNMUTE`. This will cause the music to play anytime the application initially
    starts up. Once we've set up the default button and music states, we continue
    on to register the `mMuteButton` object's touch area and attach the `Entity` object
    to the `Scene` object. This step can be taken further in order to save the state
    of the `mMuteButton` object to the device, allowing us to load the default state
    of music muting based on a user's past preference. For more information on saving/loading
    data and states, see the recipe, *Saving and loading game data* in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is very important and should always be included when dealing
    with `Music` objects. The purpose of this step is explained in more detail in
    the recipe, *Introducing sounds and music* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*. However, there is a slight variation
    to the code in the `onResumeGame()` method for this recipe. In the event of application
    minimization, a user is likely expecting their game state to be waiting as it
    was left when they finally return it to focus. For this reason, rather than playing
    the `mMenuMusic` object when `onResumeGame()` is fired on app maximization, we
    determine whether or not the `mMuteButton` button's tile index was set to `UNMUTE`
    just prior to our game's window minimization. If so, then we can call the `play()`
    method on the `mMenuMusic` object, otherwise we can ignore it until a user decides
    to play the music by pressing the `mMuteButton` again.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introducing sounds and music* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AndEngine's `Scene` object allows us to apply a static background to it. The
    background can be used to display a solid color, an entity, a sprite, or a repeating
    sprite which are not affected by changes to the `Camera` object's position or
    zoom factor. In this recipe, we're going to take a look at how to apply the different
    types of backgrounds to our `Scene` object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it..
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Background` object is the most basic type of background for our `Scene`
    object in AndEngine. This object allows the scene to visually represent a solid
    color. We will start this recipe off by setting up the `Scene` object to display
    a `Background` object in order to become familiar with how applying backgrounds
    to a scene works. Later on in this recipe we''ll be introducing the majority of
    the remaining `Background` object''s subtypes in order to cover all options as
    far as applying backgrounds to our scene goes. Setting the `Scene` object up with
    a background involves just two steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the properties of and create the `Background` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `Background` object to the `Scene` object and enable the background
    feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before deciding to use one of AndEngine's default backgrounds, we must figure
    out whether or not our background should take camera movement into consideration.
    We can think of these backgrounds as being "stuck" to the camera view. This means
    that any movements made to the camera will have absolutely no effect on the position
    of the background. The same rule applies for any other form of camera repositioning,
    including zooming. For this reason, we should not include any objects on our background
    which we need to scroll with camera movement. This is the difference between a
    `Background` object applied to the `Scene` object and an `Entity` object attached
    to the `Scene` object. Any "backgrounds" which should appear to move in response
    to the camera movement should be attached to the `Scene` object as an `Entity`
    object instead. This is most conveniently accomplished by applying an `Entity`
    object to the `Scene` object to act as a "background layer", which all sprites
    representing the background image would be attached to.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the difference between a `Background` object and an `Entity`
    object, we'll continue on to the steps for this recipe. As we can see in this
    recipe's steps, setting up a boring, old colored background is a straightforward
    task. However, it still happens to be useful to know. In the first step, we will
    define the properties of the `Background` object and create the `Background` object
    supplying said properties as the parameters. For the basic `Background` object,
    these parameters simply include the three color values and the alpha value of
    the `Background` object's color. However, as we will soon discuss, the different
    types of backgrounds will require different parameters depending on the type.
    The differences will be outlined for convenience when we get to that point.
  prefs: []
  type: TYPE_NORMAL
- en: The second step for setting up a `Background` object on the `Scene` object will
    be the same two method calls no matter what type of background we are applying.
    We must set the scene's background with `setBackground(pBackground)` and make
    sure the scene's background is enabled by calling `setBackgroundEnabled(true)`.
    On the other hand, we can also disable the background by supplying the latter
    method with a `false` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: That's all it takes when setting up a background on our `Scene` object. However,
    in our own games it is rather unlikely that we'll be satisfied with a basic colored
    background. See the *There's more...* section of this recipe for a list and examples
    of the various `Background` object subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following sections we will cover the different types of static backgrounds
    which we can use in our games. All of the `Background` object subtypes allow us
    to specify a background color for portions of the background which are not covered
    by a `Sprite` entity, `Rectangle` entity, or otherwise. These backgrounds all
    share the same "static" rule as mentioned in the *How it works...* section, that
    they will not move pending camera movement.
  prefs: []
  type: TYPE_NORMAL
- en: The EntityBackground class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `EntityBackground` class allows us to apply a single `Entity` object, or
    an entire Entity object''s layer as our scene''s background. This can be useful
    for combining multiple `Entity` objects into a single `Background` object to be
    displayed on the scene. In the following code, we''re attaching two rectangles
    to an `Entity` object''s layer, then using the `Entity` object as a background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `EntityBackground` object's parameters include `red`, `green`, and `blue`
    color values and finally the `Entity` object or layer to display as the background.
    Once the `EntityBackground` object has been created, we simply follow step two
    in this recipe's *How to do it...* section and our `EntityBackground` object will
    be ready to display whatever we choose to attach to the `backgroundEntity` object!
  prefs: []
  type: TYPE_NORMAL
- en: The SpriteBackground class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SpriteBackground` class allows us to attach a single `Sprite` object to
    our scene as a background image. Keep in mind, the sprite will not be stretched
    or distorted in any way to accommodate for the size of the display. In order to
    have a sprite stretch across the full width and height of the camera''s view,
    we must create the `Sprite` object while taking into consideration the camera''s
    width and height. With the following code, we can apply a single `Sprite` object
    as our background image on the scene. Assume the `mBackgroundTextureRegion` object''s
    dimensions are the same as the `WIDTH` and `HEIGHT` values in the following code,
    which represent the camera''s width and height values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can create the `Sprite` object as we would any other. When creating the `SpriteBackground`
    object, we pass the usual color parameters along with the `Sprite` object we wish
    to display on the background.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good idea, when using `SpriteBackground` and `RepeatingSpriteBackground`,
    to apply `BitmapTextureFormat.RGB_565` to the texture atlas. Since the background
    will likely stretch across the full display, we usually do not require an alpha
    channel which can improve the performance of our game on low-end devices.
  prefs: []
  type: TYPE_NORMAL
- en: The RepeatingSpriteBackground class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `RepeatingSpriteBackground` class is useful for creating textured maps
    for terrain or simply filling empty space on the scene with a texture. We can
    easily turn the following 128 x 128 pixel texture into a background which repeats
    the texture across the full length of the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The RepeatingSpriteBackground class](img/978-1-849518-98-7_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting background after creating a `RepeatingSpriteBackground` object
    out of the preceding texture would look like the following image at 1280 x 752
    pixels in dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The RepeatingSpriteBackground class](img/978-1-849518-98-7_03_03b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating a `RepeatingSpriteBackground` object requires a little bit more work
    than the previous `Background` object subtypes. We will be loading our repeating
    image file into an `AssetBitmapTexture` object which will then be extracted into
    an `ITextureRegion` object for use by the background. Since we''re using the texture
    for the purpose of repeating it across `RepeatingSpriteBackground`, we must provide
    the `TextureOptions.REPEATING_BILINEAR` or `TextureOptions.REPEATING_NEAREST`
    texture options within the `AssetBitmapTexture` constructor. On top of that, when
    dealing with repeating textures, we must keep our image file bound to the power
    of two dimensions. Texture dimensions with a power of two are required by OpenGL''s
    wrap modes in order to properly repeat a texture. Failure to follow this rule
    will cause repeating sprites to appear as a black shape instead. Place the following
    code into the `onCreateResources()` method of your test activity. The `mRepeatingTextureRegion`
    object must be declared as a global `ITextureRegion` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next step is to create the `RepeatingSpriteBackground` object. We will include
    this code in the `onCreateScene()` method of our activity''s life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters for the `RepeatingSpriteBackground` object define the
    maximum area that the repeating texture will cover, extending from the bottom-left
    corner of the display. In this case, we're covering the entire display. The third
    texture we pass is the `ITextureRegion` object to be used as the repeating texture.
    As previously mentioned, this texture region must be following the power-of-two
    dimension rule. The fourth parameter is the scale factor of the repeating texture.
    The default scale is `1`; increasing the scale will cause the repeating texture
    to enlarge which can make it easier to see the repeating pattern. Reducing the
    scale factor will shrink each repeated texture which can sometimes help to hide
    the pattern or obvious flaws in the repeating textures. Keep in mind, adjusting
    the scale of the repeating texture does not affect the overall size of the `RepeatingSpriteBackground`
    object as defined in the first two parameters, so feel free to adjust them until
    the texture looks right.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parallax backgrounds to create perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying a **parallax** background to a game can result in a visually-pleasing
    perspective effect. Even though we're working with a 2D engine, we can create
    a background which will gives off an illusion of depth through the use of parallax
    values which determine the movement speed of sprites based on the camera movement.
    This topic is going to introduce parallax backgrounds and how we can use them
    to add a sense of depth to an otherwise fully 2D world. The classes we will be
    using are the `ParallaxBackground` and the `AutoParallaxBackground` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires basic knowledge of the `Sprite` object in AndEngine. Please
    read through the entire recipe, *Working with different types of textures* in
    [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game
    Structure*. Next, please visit the recipe, *Bringing a scene to life with sprites*
    in [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the recipes regarding textures and sprites have been covered, create a
    new AndEngine project with an empty `BaseGameActivity` class. Finally, we will
    need to create an image named `hill.png` and place it in the `assets/gfx/` folder
    of the project. This image should be 800 x 150 pixels in dimension. The image
    can resemble the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/Image_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Refer to the class named `UsingParallaxBackgrounds` in the code bundle and import
    the code into your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ParallaxBackground` object is the most advanced `Background` object subtype
    in AndEngine. It requires the most setting up out of all of the `Background` object
    subtypes, but if broken down into small steps, it is really not that difficult.
    Perform the following steps for a walkthrough on how to set up a `ParallaxBackground`
    object to work in relation to the camera''s movement. For the sake of brevity,
    we''re going to omit the automatic camera movement code which can be found in
    the `onCreateEngineOptions()` method of the activity''s life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is typical when creating an `ITextureRegion` object for `Sprite`
    objects and is to create our `BuildableBitmapTextureAtlas`. The texture atlas
    should be just big enough to contain the `hill.png` image, which is 800 pixels
    wide by 150 pixels high. Once the texture atlas has been created, continue on
    to create the `ITextureRegion` object, then build and load the texture atlas as
    usual. This should all take place within the `onCreateResources()` method of the
    activity's life cycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The remaining steps will take place within the `onCreateScene()` method of
    the activity''s life cycle. First, we need to create all of the `Sprite` objects
    which will appear on the background. In this recipe, we''re applying three `Sprite`
    objects which will be placed conveniently on the background in order to enhance
    the illusion of distance between the different sprites:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the `ParallaxBackground` object. The three parameters
    for the constructor define the background color as usual. More importantly, we
    must override the `onUpdate()` method of the `ParallaxBackground` object in order
    to handle movement of the `Sprite` objects on the background pending any camera
    movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the `ParallaxBackground` object has been created, we must now attach `ParallaxEntity`
    objects to the `ParallaxBackground` object. The `ParallaxEntity` object requires
    that we define a parallax factor for the entity as well as a `Sprite` object for
    visual representation, which would be the hills in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, as with all `Background` objects we must apply it to the `Scene` object
    and enable it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we're setting up a `ParallaxBackground` object which will contain
    three separate `ParallaxEntity` objects. Each of these three `ParallaxEntity`
    objects will represent a hill within the background of our scene. Through the
    use of parallax factors and parallax values, the `ParallaxBackground` object allows
    each of the `ParallaxEntity` objects to offset their position at different speeds
    in the event that the `Camera` object changes its position. This allows the `ParallaxEntity`
    objects to give off the perspective effect. As we all know, objects which are
    closer to us will appear to move much faster than objects which are in the distance.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in the *How to do it...* section is a basic and necessary task
    for creating our `Sprite` objects. In this recipe, we're using a single texture
    region/image to represent all three sprites which will be attached to the background.
    However, feel free to modify this recipe in order to allow each of the three `Sprite`
    objects to use their own customized images. Practice will help to further understand
    how a `ParallaxBackground` object can be manipulated to create neat scenes within
    a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second step, we set up our three `Sprite` objects which will be attached
    to the background as `ParallaxEntity` objects. We''re placing them all in the
    center of the scene as far as the x coordinate goes. The `ParallaxBackground`
    class is only meant for applying perspective to the x coordinate movement, therefore
    the position of sprites on the background will move out of the initial x coordinate
    as the camera moves. With that being said, it is important to know that the `ParallaxBackground`
    object will continuously stitch together copies of each `ParallaxEntity` object
    attached to the background in order to compensate for background objects which
    may leave the camera''s view. See the following figure for a visual representation
    of how the `ParallaxBackground` object stitches background objects end-to-end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/Image_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Due to the way `ParallaxEntity` object stitching works on the `ParallaxBackground`
    object, in order to create objects which may not appear so often on the background,
    we must include transparent padding within the image file itself.
  prefs: []
  type: TYPE_NORMAL
- en: As for defining a sprite's y coordinate, it is best to spread the sprites out
    in order to be able to differentiate between the closest and the furthest hills
    on the background. In order to create the best perspective effect, the most distant
    objects should appear to be higher up on the scene as they will be hiding behind
    the closer objects as far as layering goes.
  prefs: []
  type: TYPE_NORMAL
- en: In the third step, we create the `ParallaxBackground` object. The constructor,
    similar to all other `Background` object subtypes, defines the background color.
    The real magic takes place within the overridden `onUpdate()` method of the `ParallaxBackground`
    object. We have two variables; `cameraPreviousX` and `cameraCurrentX` which will
    be tested against initially to make sure there is a difference between the two
    in order to reduce any unnecessary execution of code. If the two values are not
    equal to each other, we accumulate the difference between the previous and current
    camera position into a `parallaxValueOffset` variable. By calling `setParallaxValue(parallaxValueOffset)`
    on the `ParallaxBackground` object, we are basically just telling the background
    that the camera has changed positions and it's time to update all of the `ParallaxEntity`
    object positions to compensate. Increasing the parallax value will cause `ParallaxEntity`
    objects to pan to the left, while decreasing it causes them to pan to the right.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth step, we finally create the `ParallaxEntity` objects, supplying
    each of them with a parallax factor and a `Sprite` object. The parallax factor
    will define exactly how fast or how slow the `Sprite` object will move based on
    the camera's movement. In order to create a more realistic scenery, the objects
    furthest away should have a lesser value than closer objects. Additionally, the
    `attachParallaxEntity(pParallaxEntity)` method is similar to attaching `Entity`
    objects to a `Scene` object in the sense that the second object attached will
    appear in front of the first, the third will appear in front of the second, and
    so on. For this reason, we attach `ParallaxEntity` objects to `ParallaxBackground`
    from furthest first, then work our way up to the closest object.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the previous steps have been done, we can simply apply `ParallaxBackground`
    to the `Scene` object and enable it. From here on out, any and all camera movement
    will determine the position of the objects within the background scenery!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AndEngine also includes an `AutoParallaxBackground` class which is similar to
    the `ParallaxBackground` class in terms of setting up a visual effect. The difference
    between the two is that the `AutoParallaxBackground` class allows us to specify
    a constant rate in which the `ParallaxEntity` objects will move across the screen
    regardless of the camera's movement. This type of background is useful for games
    which should appear to be constantly moving such as a racing game or any type
    of fast-paced side-scroller. On the other hand, the `AutoParallaxBackground` class
    can also be used to create simple effects such as clouds scrolling consistently
    across the screen during gameplay, even in games which may appear to remain static
    in terms of `Camera` and `Scene` object position.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an `AutoParallaxBackground` object by making a simple adjustment
    to this recipe''s activity. Replace the current `ParallaxBackground` object creation
    with the following code snippet. Note that the `autoParallaxSpeed` variable defines
    how fast the `ParallaxEntity` objects will move on the background, since they''re
    no longer based on the camera''s movemen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, remove all code associated with the `mCamera` object's `onUpdate()`
    method as it will no longer affect the position of the `ParallaxEntity` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure displays the outcome of attaching three hill layers to
    the `ParallaxBackground` or `AutoParallaxBackground` objects at different heights,
    minus the movement, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/Image_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying a background* given in this chater.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our level selection system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chances are, if you''ve ever played a mobile game with multiple levels then
    you already have an idea of what we''ll be working with in this chapter. We''re
    going to be creating a class which provides our game with a grid containing level
    tiles that we can use in order to allow a user to select a level to play. This
    class can be very easily managed and is highly customizable, from button texture,
    column count, row count, and more, with ease. The end result will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our level selection system](img/978-1-849518-98-7_03_04a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This implementation of the `LevelSelector` class extends AndEngine's `Entity`
    object. This makes applying transitional effects with entity modifiers and allowing
    scrolling based on touch events a rather trivial task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LevelSelector` class is highly based on the use of AndEngine's `Entity`,
    `Sprite`, and `Text` objects. In order to understand how `LevelSelector` works,
    please take the time to go over the recipes regarding these objects. These recipes
    include, *Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*, *Bringing a scene to life with sprites*
    in [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*,
    and *Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: The `LevelSelector` object requires an `ITextureRegion` object with a reference
    to an image file. Feel free to create an image which will represent a square button
    at 50 x 50 pixels in dimension, such as those seen in the figure in this recipe's
    introduction. While this `ITextureRegion` object is not needed internally within
    the `LevelSelector` class, it is needed in order to test out the `LevelSelector`
    class in an empty `BaseGameActivity` test project at the end of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the class named `LevelSelector` in the code bundle for the working
    code for this recipe. Feel free to use this class and modify it as you see fit
    in order to fit the needs of your own games!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LevelSelector` class is actually quite simple to work with even though
    its size might be quite large. In this recipe, we're actually going to be introducing
    two classes; the first is the `LevelSelector` class which handles how the level
    tiles, or buttons, come to form a grid on the scene. The second is an inner class
    of `LevelSelector`, called `LevelTile`. The `LevelTile` class allows us to easily
    add or remove additional data that may be necessary for our own games. For the
    sake of keeping things simple, we're going to discuss each of the two classes
    in their own steps starting with the `LevelSelector` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps explain how the `LevelSelector` class works in order to
    arrange `LevelTile` objects on the scene in a grid format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `LevelSelector` constructor, initializing all variables. This constructor
    is straightforward until we come to the point where we must specify the very first
    `LevelTile` object''s position via the `mInitialX` and `mInitialY` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must create the method which will be used to build the `LevelSelector`
    object''s tile grid. We are creating a method called `createTiles(pTextureRegion,
    pFont)` which makes creating the level tile grid completely automated by looping
    through a set number of `ROWS` and `COLUMNS` values, placing tiles in predetermined
    coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third and final step for the `LevelSelector` class is to include two methods;
    one for displaying the `LevelSelector` class'' grid and another for hiding the
    `LevelSelector` class'' grid. For simplicity, we''ll call these methods `show()`
    and `hide()` with no parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we move on to the `LevelTile` class'' steps. The `LevelTile` inner class
    is an extension of AndEngine''s `Sprite` object. The reason we implement our own
    `LevelTile` class is to allow each tile to store its own data, such as whether
    the level the tile represents is locked or not, `Font` and `Text` objects used
    to display the tile''s level number, the tile''s level number itself, and more.
    This class can easily be modified to store even more information such as a user''s
    high-score for a specific level, level color themes, or whatever else we''d like
    to include. The following steps walk us through the creation of the `LevelTile`
    inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `LevelTile` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the necessary getters for the `LevelTile` class. For a basic `LevelTile`
    class such as this, all we''ll need access to is data regarding the locked state
    of the level number the tile represents as well as the level number the tile represents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to display the level number on each `LevelTile` object, we''ll create
    an `attachText()` method to handle applying a `Text` object to each `LevelTile`
    object after it is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last but certainly not the least, we''ll override the `onAreaTouched()` method
    of the `LevelTile` class in order to provide a default action in the event a tile
    is pressed down on. The event executed should differ depending on the `mIsLocked`
    Boolean value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This implementation of a `LevelSelector` class allows us to create a grid of
    selectable level tiles by adding a minimal amount of code in our activity. Before
    we go over the implementation of the `LevelSelector` class into our activity,
    let's take a look at how this class works in order to give us an idea of how we
    might modify this class to better suit the specific needs of a range of different
    games. Just as the *How to do it...* section divides the steps into two segments
    based on each of the two classes used in this recipe, we will also explain how
    each class works in two segments. We will start with the `LevelSelector` class
    once again.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the LevelSelector class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First and foremost, the `LevelSelector` class includes a number of member variables,
    which we should get to know in order to take full advantage of this object. The
    following is a list of the variables used in this class along with a description
    for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COLUMNS`: The number of `LevelTile` objects to be displayed on the horizontal
    axis of the `LevelSelector` class'' grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROWS`: The number of `LevelTile` objects to be displayed on the vertical axis
    of the `LevelSelector` class'' grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TILE_DIMENSION`: The width and height values of each individual `LevelTile`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TILE_PADDING`: The spacing, in pixels, between each `LevelTile` object on
    the `LevelSelector` class'' grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mChapter`: This value defines the `LevelSelector` class'' chapter value. This
    variable can allow us to create a number of `LevelSelector` objects which represent
    different chapters/worlds/zones within our game by specifying different chapter
    values for each `LevelSelector` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mMaxLevel`: This value defines the maximum unlocked level that a user has
    currently reached within our game. This variable would be tested against the level
    number of each `LevelTile` object that is touched. Users should not be allowed
    entry into levels which are greater than this variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mCameraWidth`/`mCameraHeight`: These values are simply used to help properly
    align the `LevelSelector` and `LevelTile` objects in the center of the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mInitialX`: This variable is in place to hold a reference to the initial x
    coordinate of each of the `LevelSelector` class'' grid rows. Each time an entire
    row of the grid is laid out, the first `LevelTile` object of the next row reverts
    back to this x coordinate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mInitialY`: This variable is used only once to define the very first `LevelTile`
    object''s y coordinate. Since we''re building the `LevelSelector` class'' grid
    from left to right and from the top to bottom, we will never have to revert back
    to the initial y coordinate for subsequent tile placement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mHidden`: The `boolean` statement of this variable determines whether or not
    the `LevelTile` objects will respond to touch events. This variable is set `true`
    if the `LevelSelector` object is not visible on the scene, `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the member variables out of the way, understanding how the `LevelSelector`
    class works will be a breeze! In the first step, we're creating the `LevelSelector`
    constructor to initialize all of the class variables. The constructor should be
    easy to follow up until the point where we define the `mInitialX` and `mInitialY`
    variables. All we are doing is calculating half of the overall width and height
    of the `LevelSelector` class' grid based on the number of columns, the number
    of rows, the tile dimension, and the tile padding. To calculate the overall width,
    we need to multiply the number of `COLUMNS` values by the width of each `LevelTile`
    object. Since we're including padding between each tile, we must also calculate
    how much space the padding will consume. However, padding will only occur in between
    tiles, meaning there will be no padding to calculate for the final column, so
    we can subtract a column from the padding calculation. We then divide this value
    by half in order to come up with half the width of the entire grid. Finally, subtracting
    half the width of the entire grid from the center position of the `Camera` object
    will give us the first `LevelTile` object's x coordinate! The same math applies
    to calculate the initial y coordinate, except the y axis deals with rows instead
    of columns, so we need to make that adjustment in the `mInitiaY` variable calculation
    in order to obtain the proper y coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: The second step for the `LevelSelector` class introduces the method of `LevelTile`
    object creation and placement. This is where the grid-making magic begins. Before
    we begin the iteration, we declare and define temporary coordinates which will
    be used to place each `LevelTile` object on the grid, incrementing their value
    accordingly after each tile is placed. The `TILE_DIMENSION * 0.5f` calculations
    are simply in place to accommodate for AndEngine's `Entity` object's anchor, or
    placement coordinate relying on the center of the `Entity` object. Additionally,
    we are initializing a temporary level number called `currentTileLevel` which is
    initialized to `1`, which signifies the level 1 tile. This variable is incremented
    by a value of 1 each time a level tile is placed on the grid. Once the initial
    level tile's values have been defined, we proceed to create the `for` loops which
    will loop through each position of the rows and columns which make up the grid.
    Starting with the first row, we will then loop N number of columns, incrementing
    the `tempX` variable by adding `TILE_DIMENSION` and `TILE_PADDING` after each
    tile is placed which will give us the next position. Once we reach the maximum
    number of columns, we decrease the `tempY` variable by adding `TILE_DIMENSION`
    and `TILE_PADDING` in order to drop us to the next row to populate. This process
    continues on until there are no rows left to populate.
  prefs: []
  type: TYPE_NORMAL
- en: The final step included in the `LevelSelector` class includes the code which
    calls `setVisible(pBoolean)` on the `LevelSelector` object, enabling visibility
    if the `show()` method is called and disabling visibility if the `hide()` method
    is called. The first time a `LevelSelector` object calls `show()`, it will be
    attached to the `Scene` object. Additionally, the `mHidden` variable will be adjusted
    according to the visibility of the `LevelSelector` object.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the LevelTile class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the `LevelSelector` class, we will begin by outlining the purpose of
    the different `LevelTile` class member variables. The following is a list of the
    variables used in this class along with a description for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mIsLocked`: The `mIsLocked` Boolean variable is defined by a parameter in
    the `LevelTile` constructor. This variable defines whether or not this `LevelTile`
    object''s touch event should produce a positive event, such as proceeding to load
    a level, or a negative event, such as notification that the level is locked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mLevelNumber`: This variable simply holds the value of the `LevelTile` object''s
    level number representation. This value is determined according to its position
    on the grid; for example, the first tile placed on a grid will represent level
    1, the second tile will represent level 2, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mFont` and `mTileText`: The `mFont` and `mTileText` objects are used to display
    a `Text` object on each `LevelTile`. If the `LevelTile` object is considered to
    be locked, a string displaying the word, **locked** will be displayed on the tile,
    otherwise the level number of the tile is displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `LevelTile` class' first step, we're simply introducing the constructor.
    There's nothing out of the ordinary here. However, one thing to note is that the
    constructor does rely on the constant `TILE_DIMENSION` value to specify the tile's
    width/height dimensions without specifying a parameter. This is in place to keep
    a level of conformity between the `LevelSelector` and `LevelTile` classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we had introduced two getter methods which can be used to
    obtain the more important values of the `LevelTile` class. Even though we aren't
    currently using these methods within either class, they can be important later
    on when the `LevelSelector`/`LevelTile` objects are implemented into a full-featured
    game which requires data such as level numbers to be passed around within the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: The third step introduces a method which is used to attach a `Text` object to
    `LevelTile` called `attachText()`. This method will place the `mTileText` object
    in the direct center of the `LevelTile` object with a string dependent on the
    `LevelTile` object's locked state. As stated in the `mFont` and `mTileText` variable
    explanation, the `mTileText` object's `String` variable will display either **locked**
    or the tile's level number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step requires us to override the `onAreaTouched()` method of the
    `LevelTile` object. Before we even consider responding to a touch event on any
    tile, we first determine whether or not the `LevelSelector` object containing
    the `LevelTile` object is visible. If not, there is no point in proceeding with
    any touch events, but if the `LevelSelector` object is visible then we proceed
    to check whether the tile was pressed down on. If a `LevelTile` object is pressed
    down on, we then continue to check whether or not the tile is locked or unlocked.
    In the class'' current state, we are simply setting the color of the scene''s
    background in order to signify whether or not the pressed tile is locked or not.
    However, in a real-world application, the current locked event can be replaced
    with a basic notification stating that the selected tile is locked. In the event
    that a tile is not locked, then the touch event should take the user to the selected
    level based on the `LevelTile` object''s `mLevelNumber` variable. If the game
    contains multiple chapters/worlds/zones, then we could even go as far as the following
    pseudo-code implementation, depending on the game''s method of loading levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've included the `LevelSelector` class into any project we choose, we
    can easily implement a working-level selection grid into our `BaseGameActivity`.
    In order to properly create the `LevelSelector` object and display it on our scene,
    we'll need to make sure we've created an `ITextureRegion` object and `Font` object
    to be used when creating the `LevelTile` objects for the `LevelSelector` class.
    We're going to omit the resource creation code in order to keep the `LevelSelector`
    class' example brief. If need be, please visit the recipes, *Working with different
    types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*, and *Using AndEngine font resources* in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*, for more information
    on how to set up the necessary resources for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code displaying how to create the `LevelSelector` object can
    be copied into the `onCreateScene()` method of any activity prior to creating
    the necessary `ITextureRegion` and Font `objects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A great feature of this `LevelSelector` class is the fact that it is an `Entity`
    object subtype. If we wish to apply fancy transition effects for it to move in
    and out of the camera's view as needed, we can simply call `levelSelector.registerEntityModifier(pEntityModifier)`.
    Since the `LevelTile` objects are attached to the `LevelSelector` object upon
    calling the `createTiles()` method, any change in the `LevelSelector` object's
    position will also affect all `LevelTile` objects, in sync. This also makes creating
    scrollable level selector implementation very easy to add if dealing with multiple
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding and retrieving layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different options we have for screen management in our games;
    a screen being a menu screen, loading screen, gameplay screen, and more. We can
    use multiple activities to act as each screen, we can use the more obvious `Scene`
    object to act as each screen in our game, or we can use `Entity` objects to act
    as each screen. While the majority of developers tend to follow the multiple activities
    or multiple `Scene` objects to act as different game screens, we're going to be
    taking a quick look into using `Entity` objects to act as the different screens
    in our games.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Entity` objects to act as the various screens of our game has many benefits
    over the other two approaches mentioned. The entity approach allows us to apply
    many different screens, or layers to our game at the same time. Unlike with using
    multiple activities or `Scene` objects to act as different screens in our game,
    we can visually display a number of screens on the device using `Entity` objects.
    This is extremely useful as we can apply transitional effects when entering or
    leaving gameplay and easily load and unload resources as we see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image displays this recipe''s code in action. What we''re seeing
    is two `Entity` object layers with a number of `Rectangle` children objects alternating
    between being transitioned in and transitioned out of the camera''s view. This
    represents how we can use `Entity` objects to handle transitional effects among
    a small or large group of children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hiding and retrieving layers](img/Image_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires an understanding of `Entity` objects and how they can be
    used as layers to contain a set of children. Additionally, we're incorporating
    transitional effects to these layers through the use of entity modifiers. Before
    continuing on with this recipe, please make sure to read through the entire recipes,
    *Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*, *Overriding the onManagedUpdate() method*
    in [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*,
    and *Using modifiers and entity modifiers* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the class named `HidingAndRetrievingLayers` in the code bundle for
    the working code for this recipe and import it into an empty AndEngine `BaseGameActivity`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps outline how we can use entity modifiers to handle transitional
    effects between different screens/layers within our game. This recipe includes
    a simple method which handles the transitioning of layers, however in a real-world
    application this task is generally performed with the use of a screen/layer manager
    class. The layers are swapped based on the time passed solely for the purpose
    of automated demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and define the layers/screens as `Entity` objects and the transitional
    effects with `ParallelEntityModifier` objects. These objects should be global:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `mScene` object, overriding its `onManagedUpdate()` method in order
    to handle calling the `setLayer(pLayerIn, pLayerOut)` method introduced in the
    next step. Additionally, we will attach our `Entity` object layers once the `mScene`
    object has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will create a `setLayer(pLayerIn, pLayerOut)` method which we can
    use to handle registering the entity modifiers to the appropriate `Entity` object,
    depending on if it should be entering or leaving the camera''s view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe covers a simple, yet useful system relating to working with `Entity`
    layer transitioning. Larger games will likely involve more variables to take into
    account when handling layer swapping, but the concept is relevant across all project
    sizes as far as entity/screen indexing and creating the method of transitioning
    screens goes.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step we are creating our global objects. The three `Entity` objects
    will represent the different screens within our game. In this recipe, all three
    of the `Entity` objects contain four `Rectangle` children objects,which allow
    us to visualize the screen transitions, however we can interpret each of the three
    `Entity` objects as a different screen such as the menu screen, the loading screen,
    and the gameplay screen. We are also creating two global `ParallelEntityModifier`
    entity modifiers to handle the positional changes of the screens. The `mMoveInModifier`
    modifier will move the registered screen from outside the right-hand side of the
    camera's view into the center of the camera's view. The `mMoveOutModifier` modifier
    will move the registered screen from the center of the camera's view to outside
    the left-hand side of the camera's view. Both modifiers include a simple rotation
    and scaling effect to produce a "rolling" transitional effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we are creating our `mScene` object and attaching the globally-declared
    `Entity` objects to it. In this recipe, we are setting up the `mScene` object
    to handle screen swapping based on the time passed, however before discussing
    how the `onManagedUpdate()` method of the `mScene` object works to handle screen
    swapping, let''s take a look at how we''re obtaining our `Entity` object indices
    as they will be used to determine which screens will be transitioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in this code snippet, we are attaching the screens in numerical
    order according to their name. Once an `Entity` object has been attached to the
    `Scene` object, we can then call the method, `getChildByIndex(pIndex)` on a parent
    in order to obtain an `Entity` object by its index. A child's index is determined
    by the order they are attached to another object. We use these indices within
    the `mScene` object's `onManagedUpdate()` method in order to determine which entity/screen
    to swap in and which to swap out of the camera's view every four seconds.
  prefs: []
  type: TYPE_NORMAL
- en: During the initialization of the `mScene` object, we are instantiating two `int`
    variables which will be used to determine which screens to transition in and out
    of the camera's view. Initially, we are defining `layerInIndex` to a value of
    `0`, which is equal to the `mScreenOne` object's index and `layerOutIndex` to
    a value of `SCREEN_COUNT – 1`, which is equal to the `mScreenThree` object's index
    based on the order they were attached to the `Scene` object. After every four
    seconds within the `onManagedUpdate()` method of the `mScene` object, we are calling
    the `setLayer(pLayerIn, pLayerOut)` method to begin the screen transitioning,
    resetting the `timeCounter` variable to accumulate the next four seconds, and
    determining the next `Entity` objects to be transitioned in and out of the camera's
    view. While this example is not exactly relative to most games, it is meant to
    give us an understanding of how we can use child indices to make transition calls
    with a method such as `setLayer(pLayerIn,pLayerOut)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the final step, we introduce the `setLayer(pLayerIn, pLayerOut)` method which
    handles the application of entity modifiers to the `Entity` objects passed in
    via parameters. This method has three goals; first it sets the layer being transitioned
    into the view to be visible if it's currently non-visible, it resets our `mMoveInModifier`
    and `mMoveOutModifier` objects, so that they can provide the `Entity` objects
    with full transitional effects, and lastly it calls `registerEntityModifier(pEntityModifier)`
    on both the `pLayerIn` and `pLayerOut` parameters, initiating the transitional
    effectson the `Entity` objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is only relevant for game structures which use multiple `Entity`
    objects to act as different screens within our games. However, the choice between
    how to handle transitioning between screens is entirely up to the developer. Before
    making a decision, it is wise to know what the pros and cons are to the different
    options we have for handling multiple screens within a game. Please take a look
    at the following list which covers the good and the bad of the different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity/screen**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: The Android OS will handle resource unloading for us with a simple call
    to the activity''s `finish()` method, making resource management very simple.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Each screen transition will prompt a brief black screen to be displayed
    upon launching a new activity/screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Multiple activities must each load their own resources. This means that
    preloading resources is not an option, which can increase the overall loading
    time, especially considering resources that may be used on all screens, such as
    font, or music playback resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Due to Android''s memory management features, activities which are considered
    background processes may be killed at any time assuming the device is running
    low on memory. This can cause issues when we leave an activity which should remain
    in a paused state until a user returns. There is a possibility any activity transitioned
    from may not be returned to in the same state when needed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene/screen**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: Possibility of preloading necessary resources which may be used across
    multiple screens. This can drastically help reduce loading times depending on
    the number of preloadable resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: We are able to introduce a loading screen within our game, rather than
    displaying a blank screen while the resources load.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro/con: A screen and resource management system must be developed in order
    to handle the loading/unloading of resources and screens. Depending on the size
    and needs of the specific game, this can be a rather large task. However, this
    approach can allow for seamless transition times when moving between screens as
    we are able to load/unload resources at more convenient times, rather than as
    soon as a user decides to switch between screens.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: Typically only one `Scene` object can be applied to our Engine object
    at a time, meaning that screen transitions will be lacking in terms of animation/fluidity.
    The screen being set will simply replace the previous screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity/screen**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: When dealing with `Entity` objects as screens, we are able to attach as
    many as we''d like to a `Scene` object. This gives us all of the pro''s of the
    scene/screen approach, as well as the added benefit of being able to add time-based
    transitional effects, such as "sliding" between the menu screen, to the loading
    screen, to the gameplay screen. This is the demonstration being made by this recipe''s
    code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro/con: As with the scene/screen route, we are required to handle all screen
    and resource cleanup ourselves. The positive outweighs the negative, but when
    comparing with the activity/screen approach, the need for a screen/resource management
    system may be considered a con by some, depending on the size of the project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we wrap up this recipe, there''s one more important topic that was not
    discussed in this recipe. Take a look at the following figure which displays what
    this recipe''s displayed results on a device might resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/Image_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure displays the typical transitional events when a user navigates
    around the different screens within a game. We covered how this navigation works
    in terms of bringing a new screen into the camera's view. Even more importantly,
    these transitional events should also handle the loading and unloading of resources.
    After all, there's no reason to have the **Menu screen** taking up the device's
    precious resources while it's not being displayed to the user. In an ideal situation
    if we are moving from the **Menu screen** to the **Game-play screen** as seen
    in the previous figure, during the **T1** phase the **Game-play** screen will
    begin to load its resources. Once the **T2** phase is reached, meaning the **Loading
    screen** is the game's current main screen, the **Menu screen** will be unloaded
    of all necessary resources and detached from the `Scene` object in order to remove
    the unnecessary overhead.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a brief overview of how transitioning between screens within a
    game is best handled in order to allow smooth transitions, and reduce the load-time
    involved between transitions. For a more in-depth information on the inner-workings
    of screen management, please see [Chapter 5](ch05.html "Chapter 5. Scene and Layer
    Management"), *Scene and layer management*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overriding the onManagedUpdate() method* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using modifiers and entity modifiers* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
