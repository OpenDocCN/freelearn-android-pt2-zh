- en: Chapter 7. Other Android NDK API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming with the jnigraphics library in Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with the dynamic linker library in Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with the zlib compression library in Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming audio with the OpenSL ES audio library in Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with the OpenMAX AL multimedia library in Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we have covered Android NDK OpenGL ES API ([Chapter
    4](ch04.html "Chapter 4. Android NDK OpenGL ES API"), *Android NDK OpenGL ES API*),
    Native Application API ([Chapter 5](ch05.html "Chapter 5. Android Native Application
    API"), *Android Native Application API*), and Multithreading API ([Chapter 6](ch06.html
    "Chapter 6. Android NDK Multithreading"), *Android NDK Multithreading*). This
    is the last chapter on Android NDK API illustration, and we will cover a few more
    libraries, including the `jnigraphics` library, dynamic linker library, `zlib`
    compression library, OpenSL ES Audio library, and OpenMAX AL multimedia library.
  prefs: []
  type: TYPE_NORMAL
- en: We first introduce two small libraries, `jnigraphics` and dynamic linker, which
    only have a few API functions and are easy to use. We then describe `zlib` compression
    library, which can be used to compress and decompress data in `.zlib` and `.gzip`
    formats. The OpenSL ES audio library and OpenMAX AL multimedia library are two
    relatively new APIs available on newer versions of Android. The API functions
    in these two libraries are not frozen yet and still evolving. Because the source
    compatibility is not a goal of the library development on Android, as stated in
    the NDK OpenSL ES and OpenMAX AL documentation, future versions of these two libraries
    may require us to update our code.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that OpenSL ES and OpenMAX AL are fairly complex libraries with lots
    of API functions. We can only introduce the basic usage of these two libraries
    with simple examples. Interested readers should refer to the library documentation
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with the jnigraphics library in Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `jnigraphics` library provides a C-based interface for native code to access
    the pixel buffers of Java bitmap objects, which is available as a stable native
    API on Android 2.2 system images and higher. This recipe discusses how to use
    the `jnigraphics` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are expected to know how to create an Android NDK project. We can refer
    to the *Writing a Hello NDK program* recipe of [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK* for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create a simple Android application which
    demonstrates the usage of the `jnigraphics` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `JNIGraphics`. Set the package name as `cookbook.chapter7.JNIGraphics`.
    Refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*
    for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **JNIGraphics**, select **Android Tools** | **Add
    Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two Java files named `MainActivity.java` and `RenderView.java` in the `cookbook.chapter7.JNIGraphics`
    package. The `RenderView.java` loads the `JNIGraphics` native library, calls the
    native `naDemoJniGraphics` method to process a bitmap, and finally display the
    bitmap. The `MainActivity.java` files creates a bitmap, passes it to the `RenderView`
    class, and sets the `RenderView` class as its content view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `mylog.h` and `JNIGraphics.cpp` files under the `jni` folder. The `mylog.h`
    contains the Android native `logcat` utility functions, while the `JNIGraphics.cpp`
    file contains the native code to process the bitmap with the `jnigraphics` library
    functions. A part of the code in the `JNIGraphics.cpp` file is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the Android project. We can enable code to remove different components
    from the bitmap. The following screenshots show the original picture and the ones
    with red, green, and blue component removed respectively:![How to do it...](img/1505_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our sample project, we modified the bitmap passed to the native `naDemoJniGraphics`
    function by setting one of its RGB components to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `jnigraphics` library is only available for Android API level 8 (Android
    2.2, Froyo) and higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps should be followed to use the `jnigraphics` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `<android/bitmap.h>` header in the source code where we use the
    `jnigraphics` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link to the `jnigraphics` library by including the following line in the `Android.mk`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the source code, call `AndroidBitmap_getInfo` to retrieve the information
    about a bitmap object. The `AndroidBitmap_getInfo` function has the following
    prototype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function accepts a pointer to the `JNIEnv` structure, a reference to the
    bitmap object, and a pointer to the `AndroidBitmapInfo` structure. If the call
    is successful, the data structure pointed by `info` will be filled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `AndroidBitmapInfo` is defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`width` and `height` indicate the pixel width and height of the bitmap. `stride`
    refers to the number of bytes to skip between rows of the pixel buffer. The number
    must be no less than the width in bytes. In most cases, `stride` is the same as
    `width`. However, sometimes pixel buffer contains paddings so stride can be bigger
    than bitmap `width`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `format` is the color format, which can be `ANDROID_BITMAP_FORMAT_RGBA_8888`,
    `ANDROID_BITMAP_FORMAT_RGB_565`, `ANDROID_BITMAP_FORMAT_RGBA_4444`, `ANDROID_BITMAP_FORMAT_A_8`,
    or `ANDROID_BITMAP_FORMAT_NONE` as defined in the `bitmap.h` header file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, we used `ANDROID_BITMAP_FORMAT_RGBA_8888` as the bitmap format.
    Therefore, every pixel takes 4 bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lock the pixel address by calling the `AndroidBitmap_lockPixels` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the call succeeds, the `*addrPtr` pointer will point to the pixels of the
    bitmap. Once the pixel address is locked, the memory for the pixels will not move
    until the pixel address is unlocked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Manipulate the pixel buffer in the native code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unlock the pixel address by calling `AndroidBitmap_unlockPixels`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this function must be called if the `AndroidBitmap_lockPixels` function
    succeeds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `jnigraphics` functions return `ANDROID_BITMAP_RESUT_SUCCESS`, which has
    a value of `0`, upon success. They return a negative value upon failure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that we used the `jnigraphics` library to load textures in the *Mapping
    texture to 3D objects with OpenGL ES 1.x API* recipe in [Chapter 4](ch04.html
    "Chapter 4. Android NDK OpenGL ES API"), *Android NDK OpenGL ES API*. We can revisit
    the recipe for another example of how we use the `jnigraphics` library.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with the dynamic linker library in Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic loading is a technique to load a library into memory at runtime, and
    execute functions or access variables defined in the library. It allows the app
    to start without these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen dynamic loading in almost every recipe of this book. When we call
    the `System.loadLibrary` or `System.load` function to load the native libraries,
    we are using dynamic loading.
  prefs: []
  type: TYPE_NORMAL
- en: Android NDK has provided the dynamic linker library to support dynamic loading
    in NDK, since Android 1.5\. This recipe discusses the dynamic linker library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are expected to know how to create an Android NDK project. You can refer
    to the *Writing a Hello NDK program* recipe of [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK* for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps describe how to create an Android application using the
    dynamic linking library to load the math library and compute the square root of
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `DynamicLinker`. Set the package name as
    `cookbook.chapter7.dynamiclinker`. Refer to the *Loading native libraries and
    registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java Native
    Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `DynamicLinker` project, select **Android Tools** | **Add
    Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under the `cookbook.chapter7.dynamiclinker`
    package. This Java file simply loads the native `DynamicLinker` library and calls
    the native `naDLDemo` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `mylog.h` and `DynamicLinker.cpp` files under the `jni` folder. A part
    of the code in the `OpenSLESDemo.cpp` file is shown in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`naDLDemo` loads the `libm.so` library, obtains the address of the `sqrt` function
    and calls the function with input argument `2.0`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A screenshot of the `logcat` output is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_07_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to build with dynamic loading library `libdl.so`, we must add the
    following line to the `Android.mk` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following functions are defined in the `dlfcn.h` header file by the Android
    dynamic linking library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dlopen` function loads the library dynamically. The first argument indicates
    the library name, while the second argument refers to the loading mode, which
    describes how `dlopen` resolves the undefined symbols. When an object file (for
    example, shared library, executable file, and so on) is loaded, it may contain
    references to symbols whose addresses are not known until another object file
    is loaded (such symbols are referred to as undefined symbols). These references
    need to be resolved before they can be used to access the symbols. The following
    two modes determine when the resolving happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_NOW`: When the object file is loaded, the undefined symbols are resolved.
    This means the resolving occurs before the `dlopen` function returns. This may
    be a waste if resolving is performed but the references are never accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTLD_LAZY`: The resolving can be performed after the `dlopen` function returns,
    that is, the undefined symbols are resolved when the code is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two modes determine the visibility of the symbols in the loaded
    object. They can be ORed with the previously mentioned two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_LOCAL`: The symbols will not be available for another object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTLD_GLOBAL`: The symbols will be available for subsequently loaded objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dlopen` function returns a handle upon success. The handle should be used
    for the subsequent calls to `dlsym` and `dlclose`.
  prefs: []
  type: TYPE_NORMAL
- en: The `dlclose` function simply decrements the reference count of the loaded library
    handle. If the reference count is reduced to zero, the library will be unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The `dlerror` function returns a string to describe the most recent error occurred
    while calling `dlopen`, `dlsym`, or `dlclose` since the last call to `dlerror`.
    It returns `NULL` if no such error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The `dlsym` function returns the memory address of a given symbol of the loaded
    dynamic library referred by the input argument handle. The returned address can
    be used to access the symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dladdr` function takes an address and tries to return more information
    about the address and library through the `info` argument of the `DI_info` type.
    The `DI_info` data structure is defined as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`dli_fname` indicates the path of the shared object referred by the input argument
    `addr`. The `dli_fbase` is the address where the shared object is loaded. `dli_sname`
    indicates the name of the nearest symbol with address lower than `addr`, and `dli_saddr`
    is the address of symbol named by `dli_sname`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we demonstrated the usage of the first four functions. We load
    the math library by `dlopen`, obtain the address of the `sqrt` function by `dlsym`,
    check the error by `dlerror`, and close the library by `dlclose`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the dynamic loading library, refer to [http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html](http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html)
    and [http://linux.die.net/man/3/dlopen](http://linux.die.net/man/3/dlopen).
  prefs: []
  type: TYPE_NORMAL
- en: Programming with the zlib compression library in Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`zlib` is a widely-used, lossless data compression library, which is available
    for Android 1.5 system images or higher. This recipe discusses the basic usage
    of the `zlib` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are expected to know how to create an Android NDK project. We can refer
    to the *Writing a Hello NDK program* recipe of [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK* for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create a simple Android application which
    demonstrates the usage of `zlib` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `ZlibDemo`. Set the package name as `cookbook.chapter7.zlibdemo`.
    Refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*
    for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **ZlibDemo**, select **Android Tools** | **Add Native
    Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` in the `cookbook.chapter7.zlibdemo`
    package. The `MainActivity.java` file loads the `ZlibDemo` native library, and
    calls the native methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `mylog.h`, `ZlibDemo.cpp`, and `GzFileDemo.cpp` files under the `jni` folder.
    The `mylog.h` header file contains the Android native `logcat` utility functions,
    while `ZlibDemo.cpp` and `GzFileDemo.cpp` files contain code for compression and
    decompression. A part of the code in `ZlibDemo.cpp` and `GzFileDemo.cpp` is shown
    in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ZlibDemo.cpp` contains the native code to compress and decompress data in
    memory.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`compressUtil` compresses and decompress data in memory.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`naCompressAndDecompress` generates data for compression and calls the `compressUtil`
    function to compress and decompress the generated data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GzFileDemo.cpp` contains the native code to compress and decompress the data
    in file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`writeToFile` writes a string to a `gzip` file. Compression is applied at writing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`readFromFile` reads data from the `gzip` file. Decompression is applied at
    reading:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the `naCompressAndDecompress` function and disable the `naGzFileDemo`
    function, build and run the application. We can monitor the `logcat` output with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `logcat` output screenshot is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_07_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Enable the `naGzFileDemo` function and disable the `naCompressAndDecompress`
    function, build and run the application. The `logcat` output is shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_07_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `zlib` library provides compression and decompression functions for both
    in-memory data and files. We demonstrated both use cases. In the `ZlibDemo.cpp`
    file, we created two data buffers, one with repeated bytes, and the other with
    random bytes. We compress and decompress the data with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute the upper bound on the compressed size. This is done by the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function returns the maximum size of the compressed data after calling the
    `compress` or `compress2` function on `sourceLen` bytes of source data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Allocate the memory for storing the compressed data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compress the data. This is done by the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function accepts five input arguments. `source` and `sourceLen` refer to
    the source data buffer and source data length. `dest` and `destLen` indicate the
    data buffer for storing the compressed data and size of this buffer. The value
    of `destLen` must be at least the value returned by `compressBound` when the function
    is called. When the function is returned, `destLen` is set to the actual size
    of the compressed data. The last input argument `level` can be a value between
    0 and 9, where 1 gives best speed and 9 gives best compression. In our example,
    we set the value as 6 to compromise between speed and compression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use the compress function to compress the data, which does not have
    the level input argument. Instead, it assumes a default level, which is equivalent
    to 6.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Decompress the data. This is done by using the `uncompress` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The input arguments have the same meaning as the `compress2` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compare the decompressed data with the original data. This is just a simple
    check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, these functions use the `zlib` format for the compressed data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This library also supports reading and writing files in the `gzip` format. This
    is demonstrated in `GzFileDemo.cpp`. The usage of these functions is similar to
    the `stdio` functions for file reading and writing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The steps we followed to write compressed data to a `gzip` file and then read
    the uncompressed data from it are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a `gzip` file for writing. This is done by the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function accepts a filename and open mode, and returns a `gzFile` object
    on success. The mode is similar to the `fopen` function, but with an optional
    compression level. In our example, we called the `gzopen` with `w6` to specify
    the compression level as 6.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write data to a `gzip` file. This is done by the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function writes uncompressed data into the compressed file. The input argument
    `file` refers to the compressed file, `buf` refers to the uncompressed data buffer,
    and `len` indicates the number of bytes to write. The function returns the actual
    number of uncompressed data written.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Close the `gzip` file. This is done by the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calling this function will flush all pending output and close the compressed
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the file for reading. We passed `r6` to the `gzopen` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read data from the compressed file. This is done by the `gzread` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function reads `len` number of bytes from file into `buf`. It returns the
    actual number of bytes read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `zlib` library supports two compression formats, `zlib` and `gzip`. `zlib`
    is designed to be compact and fast, so it is best for use in memory and on communication
    channels. On the other hand, `gzip` is designed for single file compression on
    a filesystem, which has a larger header for maintaining the directory information,
    and uses a slower check method than `zlib`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to use the `zlib` library, we must include the `zlib.h` header file
    in our source code and add the following line to `Android.mk` to link to the `libz.so`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall in the *Managing assets at Android NDK* recipe in [Chapter 5](ch05.html
    "Chapter 5. Android Native Application API"), *Android Native Application AP*
    , we compiled the `libpng` library, which requires the `zlib` library.
  prefs: []
  type: TYPE_NORMAL
- en: We only covered a few functions provided by the `zlib` library. For more information,
    you can refer to the `zlib.h` and `zconf.h` header files in the `platforms/android-<version>/arch-arm/usr/include/`
    folder. Detailed documentation for the `zlib` library can be found at [http://www.zlib.net/manual.html](http://www.zlib.net/manual.html).
  prefs: []
  type: TYPE_NORMAL
- en: Programming audio with the OpenSL ES audio library in Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSL ES is an application level audio library in C. Android NDK native audio
    APIs are based on the OpenSL ES 1.0.1 standard with Android specific extensions.
    The API is available for Android 2.3 or higher and some features are only supported
    on Android 4.0 or higher. The API functions in this libraries are not frozen yet
    and are still evolving. Future versions of this library may require us to update
    our code. This recipe introduces OpenSL ES APIs in the context of Android.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start coding with OpenSL ES, it is essential to understand some basics
    of the library. OpenSL ES stands for **Open Sound Library** for embedded systems,
    which is a cross-platform, royalty-free, C language application level API for
    developers to access audio functionalities of embedded systems. The library specification
    defines features like audio playback and recording, audio effects and controls,
    2D and 3D audio, advanced MIDI, and so on. Based on the features supported, OpenSL
    ES defines three profiles, including phone, music, and game.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Android native audio API does not conform to any of the three profiles,
    because it does not implement all features from any of the profiles. In addition,
    Android implements some features specific to Android, such as the Android buffer
    queue. For a detailed description of what is supported on Android, we can refer
    to the OpenSL ES for Android documentation available with Android NDK under the
    `docs/opensles/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although OpenSL ES API is implemented in C, it adopts an object-oriented approach
    by building the library based on objects and interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object**: An object is an abstraction of a set of resources and their states.
    Every object has a type assigned at its creation, and the type determines the
    set of tasks the object can perform. It is similar to the class concept in C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: An interface is an abstraction of a set of features an object
    can provide. These features are exposed to us as a set of methods and the type
    of each interface determines the exact set of features exposed. In the code, the
    type of an interface is identified by the interface ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to note that an object does not have actual representation
    in code. We change the object''s states and access its features through interfaces.
    An object can have one or more interface instances. However, no two instances
    of a single object can be the same type. In addition, a given interface instance
    can only belong to one object. This relationship can be illustrated as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready...](img/1505_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the diagram, Object 1 and Object 2 have different types and therefore
    expose different interfaces. Object 1 has three interface instances, all with
    different types. While Object 2 has another two interface instances with different
    types. Note that Interface 2 of Object 1 and Interface 4 of Object 2 have the
    same type, which means both Object 1 and Object 2 support the features exposed
    through interfaces of Interface Type B.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create a simple Android application using
    the native audio library to record and play audio:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `OpenSLESDemo`. Set the package name as
    `cookbook.chapter7.opensles`. Refer to the *Loading native libraries and registering
    native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"),
    *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **OpenSLESDemo**, select **Android Tools** | **Add
    Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` in the `cookbook.chapter7.opensles`
    package. This Java file simply loads the native library `OpenSLESDemo` and calls
    the native methods to record and play audio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `mylog.h`, `common.h`, `play.c`, `record.c`, and `OpenSLESDemo.cpp` files
    in the `jni` folder. A part of the code in the `play.c`, `record.c`, and `OpenSLESDemo.cpp`
    files is shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`record.c` contains the code to create an audio recorder object and record
    the audio.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`createAudioRecorder` creates and realizes an audio player object and obtains
    the record and buffer queue interfaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`startRecording` enqueues the buffer to store the recording audio and set the
    audio object state as recording:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Every time the buffer queue is ready to accept a new data block, the `bqRecorderCallback`
    callback method is invoked. This happens when a buffer is filled with audio data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`play.c` contains the code to create an audio player object and play the audio.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`createBufferQueueAudioPlayer` creates and realizes an audio player object
    which plays audio from the buffer queue:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`startPlaying` fills the buffer with data from the `test.cpm` file and starts
    playing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`bqPlayerCallback` every time the buffer queue is ready to accept a new buffer,
    this callback method is invoked. This happens when a buffer has finished playing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OpenSLESDemo.cpp` contains the code to create the OpenSL ES engine object,
    free the objects, and register the native methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`naCreateEngine` creates the engine object and outputs the mix object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the following permissions to the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application GUI is shown in the following screenshot:![How to do it...](img/1505_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can start the audio recording by clicking on the **Record** button. The recording
    will last for 15 seconds. The `logcat` output will be as shown in the following
    screenshot:![How to do it...](img/1505_07_09.jpg)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the recording is finished. There will be a `/sdcard/test.pcm` file created
    at the Android device. We can click on the **Play** button to play the audio file.
    The `logcat` output will be as shown in the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_07_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sample project demonstrates how to use OpenSL ES Audio library. We will
    first explain some key concepts and then describe how we used the recording and
    playback API.
  prefs: []
  type: TYPE_NORMAL
- en: Object creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An object does not have an actual representation in code and the creation of
    an object is done through interface. Every method which creates an object returns
    a `SLObjectInf` interface, which can be used to perform the basic operations on
    the object and access other interfaces of the object. The steps for object creation
    is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an engine object. The engine object is the entry point of OpenSL ES API.
    Creating an engine object is done with the global function `slCreateEngine()`,
    which returns a `SLObjectItf` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Realize the engine object. An object cannot be used until it is realized. We
    will discuss this in detail in the following section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the `SLEngineItf` interface of the engine object through the `GetInterface()`
    method of the `SLObjectItf` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the object creation method provided by the `SLEngineItf` interface. A `SLObjectItf`
    interface of the newly created object is returned upon success.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Realize the newly created object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manipulate the created objects or access other interfaces through the `SLObjectItf`
    interface of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you are done with the object, call the `Destroy()` method of the `SLObjectItf`
    interface to free the object and its resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our sample project, we created and realized the engine object, and obtained
    the `SLEngineItf` interface at the `naCreateEngine` function of `OpenSLESDemo.cpp`.
    We then called the `CreateAudioRecorder()` method, exposed by the `SLEngineItf`
    interface, to create an audio recorder object at `createAudioRecorder` function
    of `record.c`. In the same function, we also realized the audio recorder object
    and accessed a few other interfaces of the object through the `SLObjectItf` interface
    returned at object creation. After we are finished with the recorder object, we
    called the `Destroy()` method to free the object and its resources, as shown in
    the `naShutdown` function of `OpenSLESDemo.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing to take note of on object creation is the interface request.
    An object creation method normally accepts three parameters related to interfaces,
    as shown in the `CreateAudioPlayer` method of the `SLEngineItf` interface as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last three input arguments are related to interfaces. The `numInterfaces`
    argument indicates the number of interfaces we request to access. `pInterfaceIds`
    is an array of the `numInterfaces` interface IDs, which indicates the interface
    types the object should support. `pInterfaceRequired` is an array of `SLboolean`,
    specifying whether the requested interface is optional or required. In our audio
    player example, we called the `CreateAudioPlayer` method to request three types
    of interfaces (`SLAndroidSimpleBufferQueueItf`, `SLEffectSendItf`, and `SLVolumeItf`
    indicated by `SL_IID_BUFFERQUEUE`, `SL_IID_EFFECTSEND`, and `SL_IID_VOLUME` respectively).
    Since all elements of the `req` array are `true`, all the interfaces are required.
    If the object cannot provide any of the interfaces, the object creation will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that an object can have implicit and explicit interfaces. The implicit
    interfaces are available for every object of the type. For example, the `SLObjectItf`
    interface is an implicit interface for all objects of all types. It is not necessary
    to request the implicit interfaces in the object creation method. However, if
    we want to access some explicit interfaces, we must request them in the method.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on interfaces refer to *Section 3.1.6*, *The Relationship
    Between Objects and Interfaces* in the *OpenSL ES 1.0.1 Specification* document.
  prefs: []
  type: TYPE_NORMAL
- en: Changing states of objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object creation method creates an object and puts it in an unrealized state.
    At this state, the resources of the object have not been allocated, therefore
    it is not usable.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to call the `Realize()` method of the `SLObjectItf` interface of
    the object to cause the object to transit to the realized state, where the resources
    are allocated and the interfaces can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are done with the object, we call the `Destroy()` method to free the
    object and its resources. This call internally transfers the object through the
    unrealized stage, where the resources are freed. Therefore, the resources are
    freed first before the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we illustrate the recording and playback APIs with our sample
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Use and build with OpenSL ES Audio library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to call the API functions, we must add the following lines to our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are using Android-specific features as well, we should include another
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Android.mk` file, we must add the following line to link to the native
    OpenSL ES Audio library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: OpenSL ES audio recording
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the MIME data format and the `SLAudioEncoderItf` interface are not
    available for the audio recorder on Android, we can only record audio in the PCM
    format. Our example demonstrates how to record audio in the PCM format and save
    the data into a file. This can be illustrated using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenSL ES audio recording](img/1505_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the `createAudioRecorder` function of `record.c`, we create and realize an
    audio recorder object. We set the audio input as data source, and an Android buffer
    queue as data sink. Note that we registered the `bqRecorderCallback` function
    as the callback function for buffer queue. Whenever the buffer queue is ready
    for a new buffer, the `bqRecorderCallback` function will be called to save the
    buffer data to the `test.cpm` file and enqueue the buffer again for recording
    new audio data. At the `startRecording` function, we start the recording.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The callback functions in OpenSL ES are executed from internal non-application
    threads. The threads are not managed by Dalvik VM and therefore they cannot access
    JNI. These threads are critical to the integrity of the OpenSL ES implementation,
    so the callback functions should not block or perform any heavy-processing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In case we need to perform heavy tasks when the callback function is triggered,
    we should post an event for another thread to process such tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This also applies to the OpenMAX AL library that we are going to cover in next
    recipe. More detailed information can be obtained from the NDK OpenSL ES documentation
    at the `docs/opensles/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSL ES audio playback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android OpenSL ES library provides lots of features for audio playback. We
    can play encoded audio files, including mp3, aac, and so on. Our example shows
    how to play the PCM audio. This can be illustrated as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenSL ES audio playback](img/1505_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We created and realized the engine object and the output mix object in the `naCreateEngine`
    function in `OpenSLESDemo.cpp`. The audio player object is created in the `createBufferQueueAudioPlayer`
    function of `play.c` with an Android buffer queue as data source and the output
    mix object as data sink. The `bqPlayerCallback` function is registered as the
    callback method through a `SLAndroidSimpleBufferQueueItf` interface. Whenever
    the player finishes playing a buffer, the buffer queue is ready for new data and
    the callback function `bqPlayerCallback` will be invoked. The method reads data
    from the `test.pcm` file into the buffer and enqueues it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `startPlaying` function, we read the initial data into the buffer and
    set the player state to `SL_PLAYSTATE_PLAYING`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenSL ES is a complex library with a more than 500 page long specification.
    The specification is a good reference when developing applications with OpenSL
    ES and it is available with the Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: The Android NDK also comes with a native-audio example, which demonstrates usage
    of a lot more OpenSL ES functions.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with the OpenMAX AL multimedia library in Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenMAX AL is an application-level multimedia library in C. Android NDK multimedia
    APIs are based on the OpenMAX AL 1.0.1 standard with Android-specific extensions.
    The API is available for Android 4.0 or higher. We should note that the API is
    evolving and the Android NDK team mentioned that the future version of OpenMAX
    AL API may require developers to change their code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start coding with the OpenMAX AL library, it is important to understand
    some basics about the library. We will briefly describe the library in the following
    text.
  prefs: []
  type: TYPE_NORMAL
- en: OpenMAX AL refers to the Application Layer interface of the **Open Media Acceleration**
    (**OpenMAX**) library. It is a royalty-free, cross-platform, C-language application
    level API for developers to create multimedia applications. Its main features
    include media recording, media playback, media controls (for example, brightness
    control), and effects. Compared to OpenSL ES library, OpenMAX AL provides features
    for both video and audio, but it lacks certain audio features like 3D audio and
    audio effects which OpenSL ES can provide. Some applications may need to use both
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: OpenMAX AL defines two profiles, namely media playback and media player/recorder.
    Android does not implement all features required by either profile, therefore
    the OpenMAX AL library in Android does not conform either profile. In addition,
    Android implements some features specific to Android.
  prefs: []
  type: TYPE_NORMAL
- en: The main features provided by Android OpenMAX AL implementation is the ability
    to process the MPEG-2 transport stream. We can demultiplex the stream, decode
    the video and audio, and render them as audio output or to the phone screen. This
    library allows us to have complete control over the media data before it is passed
    for presentation. For example, we can call OpenGL ES functions to apply graphics
    effect on video data before rendering it.
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed description of what is supported on Android, we can refer to
    the OpenMAX AL for Android documentation available with the Android NDK under
    the `docs/openmaxal/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The design of OpenMAX AL library is similar to OpenSL ES library. They both
    adopt an object-oriented approach and the fundamental concepts including objects
    and interfaces are the same. Readers should refer to the previous recipe for a
    detailed explanation on these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create a simple Android video playback
    application using the OpenMAX AL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `OpenMAXSLDemo`. Set the package name as
    `cookbook.chapter7.openmaxsldemo`. Refer to the *Loading native libraries and
    registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java Native
    Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **OpenMAXSLDemo**, select **Android Tools** | **Add
    Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` in the package `cookbook.chapter7.openmaxsldemo`.
    This Java file loads the native library `OpenMAXSLDemo`, sets the view, and calls
    the native methods to play the video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `mylog.h` and `OpenMAXSLDemo.c` files in the `jni` folder. A part of
    the code in `OpenMAXSLDemo.c` is showed in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`naCreateEngine` creates and realizes the engine object and the output mix
    object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`naCreateStreamingMediaPlayer` creates and realizes a media player object with
    the data source and data sink. It obtains the buffer queue interface and registers
    the `AndroidBufferQueueCallback` function as the callback function. The callback
    function will be invoked after a buffer is processed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AndroidBufferQueueCallback` is the callback function registered to refill
    the buffer with media data or handle commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the `NativeMedia.ts` video file available in the `samples/native-media/`
    directory for testing. The following command can be used to put the video file
    into the `/sdcard/` directory of the testing Android device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and start the Android application. We can see the GUI as shown in the
    following screenshot:![How to do it...](img/1505_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can press **Play** to start playing the video.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used the OpenMAX AL library to implement a simple video player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use and build with the OpenMAX AL multimedia library:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to call the API functions, we must add the following line to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are also using Android-specific features, we should include another header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Android.mk` file, we must add the following line to link to the OpenMAX
    AL multimedia library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: OpenMAX AL video playback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our sample project that is a simplified version of the native media project
    comes with the Android NDK. The following diagram illustrates how the application
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenMAX AL video playback](img/1505_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our code, we created and realized the engine and output mix objects at `naCreateEngine`
    function. At the `naCreateStreamingMediaPlayerfunction` function, we created and
    realized the media player object with the audio data sink set as output mix, video
    data sink set as native display, and data source set as the Android buffer queue.
  prefs: []
  type: TYPE_NORMAL
- en: When a buffer is consumed, the callback function `AndroidBufferQueueCallback`
    is invoked, where we refill the buffer with data from the `NativeMedia.ts` file
    and enqueue it to the buffer queue.
  prefs: []
  type: TYPE_NORMAL
- en: There's more....
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenMAX AL is a complex library. The specification is a good reference when
    developing applications with OpenMAX AL and it is available with the Android NDK.
    The Android NDK also comes with a native-media example, which is a good example
    of how to use the API.
  prefs: []
  type: TYPE_NORMAL
