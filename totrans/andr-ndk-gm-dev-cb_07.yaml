- en: Chapter 7. Cross-platform UI and Input Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing multi-touch events on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up multi-touch emulation on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multi-touch events on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an on-screen joypad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using FreeType for text rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localization of in-game strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mobile user interface is based (besides graphics rendering) on multi-touch
    input. This chapter shows you how to handle the touch events on the Android OS,
    and how to debug them on Windows. A dedicated recipe about the emulation of multi-touch
    capabilities on Windows using multiple mice is also included. The rest of the
    chapter is devoted to high-quality text rendering and supporting multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: Processing multi-touch events on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have not handled any user interaction except the **BACK** button
    on Android. In this recipe, we show how to process multi-touch events on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be familiar with the concepts of multi-touch input handling. In Java,
    Android multi-touch events are delivered inside the `MotionEvent` class, an instance
    of which is passed as a parameter to the `onTouchEvent()` method of your `Activity`
    class. The `MotionEvent` class contains all the information of the currently active
    and released touches. In order to pass this information to our native code, we
    convert a single event carrying multiple touches into a series of events holding
    data for a single touch. This keeps the JNI interoperation simple and enables
    easy porting of our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Android activity supports multi-touch event handling. All we have to do
    is override the `onTouchEvent()` method of the `Activity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare some internal constants to events related to individual touch
    points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The event handler uses the `MotionEvent` structure and extracts information
    about individual touches. The `SendMotion()` function is declared in the native
    code and contains the gesture decoding we call the via JNI from `onTouchEvent()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tell our native code we are going to send a series of events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the event code and the `ID` of the first touch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the coordinates of the primary touch point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process the touch start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process the end of the whole gesture when all the touches are released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process secondary touch points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end, we update the coordinates of each touch point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When everything is done, we inform our native gesture decoder about the end
    of the events sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The native `SendMotion()` function accepts the touch point `ID`, the coordinates
    in screen pixels, a motion flag, and a `boolean` parameter indicating whether
    the touch point is active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android OS sends the notifications about touch points to our application,
    and the `onTouchEvent()` function transforms the collection of touch events which
    resides within a `MotionEvent` object into a sequence of JNI `SendMotion()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling multi-touch events on Windows*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recognizing gestures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up multi-touch emulation on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing a touch-based interface is hard without the hardware, but even with
    the Android hardware available, we do not have the luxury of a step-by-step debugger.
    Fortunately, Windows supports touch screen hardware and can provide `WM_TOUCH`
    events for our application. This recipe shows a trick, utilizing multiple mice
    to emulate touch events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on a third-party Windows driver, the MultiTouchVista, a user
    input management layer that handles input from various devices. It can be downloaded
    from [http://multitouchvista.codeplex.com/](http://multitouchvista.codeplex.com/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install the system driver. We extract the `MultiTouchVista_-_second_release_-_refresh_2.zip`
    file, the latest release at the time of writing, and then open the command line
    with administrator rights. If the console is run without administrator privileges,
    the installation of the driver fails. The extracted folder contains the `Driver`
    subfolder, where you should choose either the `x64` or `x32` folder, depending
    on the type of your operating system. In that folder, we execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A dialog appears, asking whether you want to install this device software or
    not; you should click on the **Install** button. Once the installation is complete,
    you will see a message on the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we do, is activate the driver in **Device Manager**. We open
    the **Control Panel**, then the **Device Manager** window. There, we find the
    **Human Interface Devices** item in the list. We right-click on the **Universal
    Software HID device**, the one we have just installed the drivers for. We choose
    **Disable** from the context menu to disable the device. In the confirmation before
    disabling the device, we just respond with **Yes**. After that, we re-enable this
    device again by right-clicking on this node and choosing **Enable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, since we emulate the multi-touch with mice, we should somehow display the
    touch points on the screen, because otherwise it is impossible to know where the
    mice pointers are. In **Control Panel** | **Hardware and Sound**, we open the
    **Pen and Touch** window. The **Touch** tab contains the **Show the touch pointer
    when I'm interacting with items on the screen** checkbox, which should be enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all the mice are connected, we can start the driver. We open two command
    lines and in the first one, we run `Multitouch.Service.Console.exe` from the `MultiTouchVista`
    package. In the second console window, we run `Multitouch.Driver.Console.exe`
    without closing the **MultiTouch.Server.Console** window. Quit both of these applications
    to return to the normal non-multi-touch Windows environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check whether the driver and the service work as expected, we can try the
    standard Microsoft Paint application and use two or more mice simultaneously to
    draw something.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling multi-touch events on Windows*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multi-touch events on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have installed the `MultiTouchVista` driver, or if we happen to have
    a multi-touch-capable screen, we can initialize an event loop in the application
    and handle the `WM_TOUCH` messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first recipe contains all the relevant information about multi-touch handling.
    In this recipe, we only extend our code for Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book doesn’t discuss about multi-touch input emulation for Mac.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MinGW` toolchain does not include the latest Windows SDK headers, so a
    number of constants should be defined to use the `WM_TOUCH` messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `TOUCHINPUT` structure encapsulates a single touch using the `WinAPI` data
    types and should also be declared manually for `MinGW`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next four functions provide the touch interface handling for our application.
    We declare the function prototypes and static function pointers to load them from
    `user32.dll`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `MinGW` does not support the automatic export of `WM_TOUCH`-related routines,
    we have to load them manually from `user32.dll` using `GetProcAddress()`. This
    is done in the `LoadTouchFuncs()` function, which is defined in the file `Wrapper_Windows.cpp`
    from `1_MultitouchInput`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, we need to declare the `GetTouchPoint()` routine, which converts the
    `TOUCHPOINT` coordinates to screen pixels, for simplicity a hardcoded window size
    of 100 x 100 pixels is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to implement the multi-touch message handling on Windows.
    In our window function, we add a new message handler for the `WM_TOUCH` message,
    which contains data for several different touch points packed together. We unpack
    the parameters into an array, where each item represents a message for a single
    touch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each touch point, we update its status in the global array `g_TouchPoints`.
    This is the main difference from the Android code, since there we decode the `MotionEvent`
    structure in Java code and pass a list of points to the native code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we clean up the temporary array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We remove all the released points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we handle all the active touch points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The event handler uses a global list of touch points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sTouchPoint` structure point encapsulates the coordinates, the touch point
    `ID`, a motion flag, and the associated event time stamp for a single touch point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if this touch point is active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Viewport_UpdateTouchPoint()` function either adds the point to the list,
    or just updates the state depending on the motion flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Viewport_ClearReleasedPoints()` function removes all the points with the
    motion flag set to `MOTION_UP`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function, `Viewport_UpdateCurrentGesture()`, sends the point list
    to the gesture processor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `WM_CREATE` event handler, we register our window as the touch event
    responder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then we get a sequence of touch events in the `Viewport_ProcessMotion()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows 8 has introduced the `WM_POINTER` message, which ensures much cleaner
    code, similar to the Android and other touch-based environments. Interested readers
    may read the respective MSDN articles ([http://msdn.microsoft.com/en-us/library/hh454928(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/hh454928(v=vs.85).aspx))
    and write a similar handler in the window function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for the `WM_TOUCH` message handling is included in the `1_MultitouchInput`
    example. The next recipe shows how to decode a sequence of multi-touch events
    and recognize some basic gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implement a function which detects pinch-zoom-rotate and
    fling/swipe gestures. It can serve as a starting point for recognition of your
    own custom gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on the recipe *Processing multi-touch events on Android*
    from this chapter to handle multi-touch input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We split the task of motion decoding into individual layers. The low-level
    code handles the OS-generated touch events. Collected touch point data is processed
    using a set of routines in the mid-level code, which we present in this recipe.
    Finally, all the decoded gestures are reported to the user''s high-level code
    using the simple `iGestureResponder` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Event_UpdateGesture()` method is provided for direct access to the current
    state of contact points. The `sMotionData` structure is presented right after
    the `iGestureResponder` discussion. The `1_MultitouchInput` example overrides
    this method to render the touch points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Event_PointerChanged()`and `Event_PointerMoved()` methods are called to
    indicate the changes in individual touches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The information about decoded gestures is sent to the `iGestureResponder` instance.
    When the fling/swipe event finishes, the `Event_Fling()` method is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the timestamps in the `Up` and `Down` points, the responder may estimate
    the speed of the finger movement and decide if the gesture succeeds. The `Event_Drag()`
    method is called when the finger is dragged across the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The pinch-zoom event is handled using three methods. The `Event_PinchStart()`
    method is called when the gesture starts, `Event_PinchStop()` is called at the
    end of the gesture, and the `Event_Pinch()` method is called on each update of
    two touch points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s get to the mid-level routines to decode gestures. First, declare an
    instance of `iGestureResponder` which is used later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We introduce the `sMotionData` structure, which describes the current gesture
    state. Individual touch point features are accessed with the `Get*` functions.
    The `AddTouchPoint()` function ensures no points with duplicate IDs are added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A gesture is described by the current state of its touch points and a ring
    buffer of previous touch point states. To detect a gesture, we create an ad-hoc
    state machine. Two Boolean variables indicate if we really have the gesture and
    if the gesture is progressing. Validity flags are also stored for each kind of
    gesture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Single-finger gestures, like fling, drag, or tap, are described by the current
    and initial touch points. The pinch-zoom is a two-finger gesture whose state is
    determined by two initial points and two current points. Centers are calculated
    as the average of the initial and current point coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ignore accidental screen touches, we introduce a sensitivity threshold,
    which is the smallest percent of the screen space a finger must travel for the
    fling gesture to be detected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fling gesture is completely ignored if the finger''s final position moves
    from the initial position by less than the following value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `RingBuffer` data structure is implemented using a simple dynamic array.
    The full source code is in the `RingBuffer.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only special method is the accessor to previous states, relative to `FHead`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The current element and the total number of items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Division remainder with the wrapping around for negative values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last routine calculates the previous element index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To decode a gesture, we carefully handle each of the touch events. At the beginning
    we reset the touch point collection, and at the end of the touch we check for
    gesture completion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we are still moving, then modify the information about the current point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Depending on the motion flag, we inform the responder about individual touches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `UpdateGesture()` function does all the job of detection. It checks the
    current state of the gesture and calls the methods of the `g_Responder` object
    if any of the gestures are in progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The drag-and-pinch gestures are checked in the `IsDraggingValid()` and `IsPinchZoomValid()`
    methods, which are described a bit later. We respond to a single point drag, if
    the finger has travelled more than a specified distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `UpdateGesture()` function previously described uses the following helper
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The drag or fling motion should be performed with a single finger. To distinguish
    a drag from a fling, we use the `IsDraggingValid()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether the user is performing the pinch-zoom gesture, we call the
    `IsPinchZoomValid()` function. We get the touch points and calculate the distance
    between them. If we are already performing the pinch-zoom gesture, we update the
    current points. Otherwise, we store the initial points and calculate the center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `g_Responder` instance receives all the data about decoded gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an on-screen joypad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to make use of the multi-touch facilities and emulate a gaming console-like
    interface on an Android device touch screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn how to handle multi-touch input from recipes *Processing multi-touch events
    on Android* and *Processing multi-touch events on Windows* before proceeding with
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We implement a custom multi-touch event handler, which keeps track of all the
    touch points. The joystick is rendered as a full-screen bitmap shown on the left-hand
    side. When the user touches the screen, we use the touch coordinates to fetch
    the pixel color from the mask on the right-hand side of the figure. Then, we find
    the internal button corresponding to the color and change its `Pressed` state.
    The following figure shows the joypad visual representation and the color mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7785_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Single button of our virtual joystick is determined by its color in the mask
    and the index in the buttons table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A virtual analogue stick supports two directions and is determined by its radius,
    mask color, and position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ScreenJoystick` class contains descriptions for all of the buttons and
    axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The values for each axis and the `Pressed` flags for each button are stored
    in two arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The mask bitmap data pointer is also necessary for this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FPushed*` arrays tell us which buttons and axes are currently activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor and destructor are essentially empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `InitKeys()` method allocates the state arrays when the joystick construction
    is finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Restart()` method clears the state of pushed buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The internal state is changed by the private `SetAxisValue()` and `SetKeyState()`
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `IsPressed()` and `GetAxisValue()` methods can read the state of a key
    or an axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following internal methods look up for the button and axis with a given
    color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Two values for each axis are read as the displacement from the center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read axis value based on a center point and a touch point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main routine is the `HandleTouch()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the touch has just started, we reset the values for each button and axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the pointer is moving, we look up the respective button or axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each button we find, set the pressed state to true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each found axis, we read the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We declare a global variable, which holds the state of our joystick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `OnStart()` method, we add two axes and a single button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we initialize the joystick and reset its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Later in the code we can use the results of `g_Joystick.GetAxisValue` to find
    out the current axis value, and `g_Joystick.IsPressed` to see if the key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Using FreeType for text rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible that the interface avoids rendering the textual information.
    However, most applications have to display some text on the screen. It is time
    to consider the **FreeType** text rendering in all its detail with kerning and
    glyph caching. This is the longest recipe of this book, but we really wish not
    to miss the details and subtleties of the FreeType usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is time to make the real use of the recipe on the FreeType compilation from
    [Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"), *Porting Common
    Libraries*. We start with an empty application template described in [Chapter
    1](ch01.html "Chapter 1. Establishing a Build Environment"), *Establishing a Build
    Environment*. The following code supports multiple fonts, automatic kerning, and
    glyph caching.
  prefs: []
  type: TYPE_NORMAL
- en: '*In typography, kerning (less commonly mortising) is the process of adjusting
    the spacing between characters in a proportional font, usually to achieve a visually
    pleasing result.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Courtesy: [http://en.wikipedia.org/wiki/Kerning](http://en.wikipedia.org/wiki/Kerning)'
  prefs: []
  type: TYPE_NORMAL
- en: Glyph caching is a feature of the FreeType library, which reduces memory usage
    using glyph images and character maps. You can read about it at [http://www.freetype.org/freetype2/docs/reference/ft2-cache_subsystem.html](http://www.freetype.org/freetype2/docs/reference/ft2-cache_subsystem.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we develop the `TextRenderer` class, which holds all the states of the
    FreeType library. We wrap the text rendering in a class to support multiple instances
    of this class and ensure the thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required FreeType library initialization includes the library instance,
    glyph cache, character map cache, and image cache. We declare the internal FreeType
    objects first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then the list of loaded fonts is declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FMaskMode` switch is used to choose between opaque rendering and alpha-mask
    creation. It is mentioned later in the glyph rendering code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The initialization routine creates the FreeType library instance and initializes
    the glyph and image caches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As usual, we provide the shortest code possible. The complete code should check
    for non-zero return codes from the `FTC_*` functions. The `LoadFT()` function
    initializes the function pointers for the FreeType library. We use the `PTR` suffix
    for all of the FreeType functions in the code for this recipe to allow dynamic
    library loading on Windows. If you are only concerned about Android development,
    the `PTR` suffix can be omitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The deinitialization routine clears all the internal data and destroys the
    FreeType objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FreeString()` routine clears the internal FreeType glyphs cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FString` contains all the characters from the string being rendered. The initialization
    and deinitialization functions are called in the constructor and destructor, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To utilize the **TrueType** fonts and render the glyphs, we need to create
    a simple set of management routines to load the font files. The first one is the
    `LoadFontFile()` function, which loads the font file, stores its contents in the
    list, and returns the error code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We always use the 0-th face, which is the first one in the loaded file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check for success and store the font in the array of loaded font faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReadFileData()` function loads the content of `File`. You are encouraged
    to implement this function or to see the accompanying source, where it is done
    by means of our Virtual Filesystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The static function `FreeType_Face_Requester()` caches the access to the font
    face and allows us to reuse loaded fonts. It is defined in the FreeType library
    headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The FreeType library allows the `RequestData` parameter, where we pass an instance
    of `TextRenderer` by pointer. The `#ifdef` in the code of `FreeType_Face_Requester()`
    is necessary to run on 64-bit versions of Windows. The Android OS is 32-bit only,
    and the casting of `void*` to `int` is implicitly allowed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `GetSizedFace` function sets the font size for the loaded face:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the internal `sFTChar` structure which holds the information
    about a single character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The text we render is in the UTF-8 encoding, which must be converted to the
    UCS-2 multi-byte representation. The simplest UTF-8 decoder reads an input string
    and outputs its characters into the `FString` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The decoder uses the following function to read individual character codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code of `DecodeNextUTF8Char()` was taken from the Linderdaum Engine
    at [http://www.linderdaum.com](http://www.linderdaum.com).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `NextUTF8()` and `ContUTF8()` inline functions are declared next to the
    decoding buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A buffer with the current string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The current character index and the source buffer length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Raw pointer to the source buffer and the current byte:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the next byte or `UTF8_LINE_END` if there are no bytes left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the low six bits of the next continuation byte and return `UTF8_DECODE_ERROR`
    if it is not a continuation byte:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By now, we have the font loading functions and a UTF-8 decoder. Now it is time
    to deal with the actual rendering. The first thing we want to do is calculate
    the string size in screen pixels, which is performed in the `CalculateLineParameters`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use two variables to look for the minimum and maximum vertical positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another variable stores the horizontal size of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We iterate over the `FString` array and use the `sFTChar::FGlyph` field to
    retrieve the vertical character size. We also add the `FAdvance` field to `SizeX`,
    to account for the kerning and horizontal character size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the preceding code to render a UTF-8 string into a newly allocated bitmap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decode the UTF-8 input string and calculate individual character positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the horizontal and vertical string dimensions and allocate the output
    bitmap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render all the glyphs to the bitmap. Start on the other side of the bitmap,
    if the text is right-to-left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The routine `LoadStringWithFont()` does the job of horizontal position calculation
    for each character of the string `S`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the required font face:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decode the input UTF-8 string and calculate character sizes, checking each
    element in `FString`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load a glyph corresponding to the character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the horizontal offset of this glyph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the kerning for each character, except the first one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LoadStringWithFont()` function uses auxiliary routines `Kern()` and `SetAdvance()`
    to calculate the offset between two sequential characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the value from the 26.6 fixed-point format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, once we have the positions of each character, we render the individual
    glyphs to the bitmap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code in `RenderLineOnBitmap()` is fairly straightforward. The only subtle
    point is the bitwise shift operation, which converts the internal FreeType 26.6
    bit fixed-point format to a standard integer. First, we shift `StartX` left to
    get the FreeType's coordinate, and for each pixel, we shift `x` right to get the
    screen position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The 26.6 fixed-point format is used internally in FreeType to define fractional
    pixel coordinates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `DrawGlyph()` routine copies raw pixels from the glyph, or multiplies the
    source by the glyph''s pixel, depending on the rendering mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The auxiliary `MultColor()` function multiplies each component of the integer-encoded
    color by the `Mult` factor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The minimal code to render a UTF-8 string covers the creation of a `TextRenderer`
    instance, font loading, and actual text rendering using the loaded font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the Portuguese word *direção*, which means *direction*, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the `bmp` variable, which contains the rendered text, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7785_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the longest recipe ever, and still some important details have been
    left out. If the amount of text you render for each frame is large enough, it
    makes sense to pre-render some of the strings and avoid recreation of images.
  prefs: []
  type: TYPE_NORMAL
- en: Localization of in-game strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile applications are used on a variety of devices and, quite often, these
    devices are configured to use a language other than English. This recipe shows
    how to internationalize textual messages displayed in the application UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Review [Chapter 4](ch04.html "Chapter 4. Organizing a Virtual Filesystem"),
    *Organizing a Virtual Filesystem*, for the read-only file access using our implementation
    of the virtual filesystem abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For each language we want to support, we need to prepare a set of translated
    strings. We store these strings in a file. An example for the English-Russian
    language pair would be the `Localizer-ru.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `~` character is used as a delimiter between the original phrase and its
    translations. The original phrase can be used as a key, and it is stored with
    its translation in a global `std::map` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us suppose we have a locale name in a global variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We only need to implement the `LocalizeString()` function, which uses the `g_Translations`
    map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LoadLocale()` routine uses the global `g_LocaleName` variable and loads
    the required translation table skipping the lines without the `~` character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The directory where we store the localized string files is defined for the
    of simplicity, in another global variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LocalizeString()` function accepts a string in the base language and returns
    its translation. Whenever we want to render some text, we do not use string literals
    directly, as this will seriously reduce our ability to localize our game. Instead,
    we wrap these literals into the `LocalizeString()` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To render a text in an appropriate language we can use the OS functions to
    detect its current locale settings. On Android, we use the following Java code
    in our `Activity`. `SetLocale()` is called from the `Activity` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Detect the locale name and pass it to our native code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'In the native code, we just capture the locale name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, things are even simpler. We call the `GetLocaleInfo() WinAPI` function
    and extract the current language name in the ISO639 format ([http://en.wikipedia.org/wiki/ISO_639](http://en.wikipedia.org/wiki/ISO_639)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
