- en: Chapter 7. Cross-platform UI and Input Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 跨平台UI和输入系统
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Processing multi-touch events on Android
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安卓上处理多触摸事件
- en: Setting up multi-touch emulation on Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上设置多触摸模拟
- en: Handling multi-touch events on Windows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上处理多触摸事件
- en: Recognizing gestures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别手势
- en: Implementing an on-screen joypad
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现屏幕上的游戏手柄
- en: Using FreeType for text rendering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FreeType进行文本渲染
- en: Localization of in-game strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏内字符串的本地化
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: A mobile user interface is based (besides graphics rendering) on multi-touch
    input. This chapter shows you how to handle the touch events on the Android OS,
    and how to debug them on Windows. A dedicated recipe about the emulation of multi-touch
    capabilities on Windows using multiple mice is also included. The rest of the
    chapter is devoted to high-quality text rendering and supporting multiple languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 移动用户界面基于（除了图形渲染）多触摸输入。本章将向您展示如何在安卓操作系统上处理触摸事件，以及如何在Windows上调试它们。还包含了一个关于在Windows上使用多个鼠标模拟多触摸能力的专门教程。本章的其余部分致力于高质量文本渲染和支持多种语言。
- en: Processing multi-touch events on Android
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在安卓上处理多触摸事件
- en: Until now, we have not handled any user interaction except the **BACK** button
    on Android. In this recipe, we show how to process multi-touch events on Android.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们还没有处理除了安卓上的**返回**按钮之外的任何用户交互。在本教程中，我们将展示如何处理安卓上的多触摸事件。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should be familiar with the concepts of multi-touch input handling. In Java,
    Android multi-touch events are delivered inside the `MotionEvent` class, an instance
    of which is passed as a parameter to the `onTouchEvent()` method of your `Activity`
    class. The `MotionEvent` class contains all the information of the currently active
    and released touches. In order to pass this information to our native code, we
    convert a single event carrying multiple touches into a series of events holding
    data for a single touch. This keeps the JNI interoperation simple and enables
    easy porting of our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉多触摸输入处理的概念。在Java中，安卓多触摸事件是在`MotionEvent`类内部传递的，该类的实例作为参数传递给你的`Activity`类的`onTouchEvent()`方法。`MotionEvent`类包含了所有当前活动中和已释放的触摸信息。为了将此信息传递给我们的本地代码，我们将携带多个触摸的单个事件转换为一系列仅包含单个触摸数据的事件。这简化了JNI的交互操作，并使我们的代码易于移植。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Each Android activity supports multi-touch event handling. All we have to do
    is override the `onTouchEvent()` method of the `Activity` class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个安卓活动都支持多触摸事件处理。我们所要做的就是重写`Activity`类的`onTouchEvent()`方法：
- en: 'First, we declare some internal constants to events related to individual touch
    points:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明一些与单个触摸点相关的事件的内部常量：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The event handler uses the `MotionEvent` structure and extracts information
    about individual touches. The `SendMotion()` function is declared in the native
    code and contains the gesture decoding we call the via JNI from `onTouchEvent()`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件处理器使用`MotionEvent`结构，并提取有关单个触摸的信息。在本地代码中声明的`SendMotion()`函数包含了我们通过JNI从`onTouchEvent()`中调用的手势解码：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Tell our native code we are going to send a series of events:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉我们的本地代码我们将要发送一系列事件：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Determine the event code and the `ID` of the first touch:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定事件代码和第一个触摸点的`ID`：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Get the coordinates of the primary touch point:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取主触摸点的坐标：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Process the touch start:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理触摸开始：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Process the end of the whole gesture when all the touches are released:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有触摸点释放时，处理整个手势的结束：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Process secondary touch points:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理次要触摸点：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the end, we update the coordinates of each touch point:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们更新每个触摸点的坐标：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When everything is done, we inform our native gesture decoder about the end
    of the events sequence:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有操作完成后，我们通知本地手势解码器事件序列的结束：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The native `SendMotion()` function accepts the touch point `ID`, the coordinates
    in screen pixels, a motion flag, and a `boolean` parameter indicating whether
    the touch point is active:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地`SendMotion()`函数接受触摸点`ID`、屏幕像素坐标、运动标志和一个表示触摸点是否激活的布尔参数：
- en: '[PRE10]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Android OS sends the notifications about touch points to our application,
    and the `onTouchEvent()` function transforms the collection of touch events which
    resides within a `MotionEvent` object into a sequence of JNI `SendMotion()` calls.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓操作系统将触摸点的通知发送到我们的应用程序，`onTouchEvent()`函数将包含在`MotionEvent`对象中的触摸事件集合转换为一连串的JNI
    `SendMotion()`调用。
- en: See also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Handling multi-touch events on Windows*'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Windows上处理多触摸事件*'
- en: '*Recognizing gestures*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别手势*'
- en: Setting up multi-touch emulation on Windows
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上设置多点触控仿真
- en: Testing a touch-based interface is hard without the hardware, but even with
    the Android hardware available, we do not have the luxury of a step-by-step debugger.
    Fortunately, Windows supports touch screen hardware and can provide `WM_TOUCH`
    events for our application. This recipe shows a trick, utilizing multiple mice
    to emulate touch events.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有硬件的情况下测试基于触摸的界面是很困难的，但即使有可用的Android硬件，我们也没有逐步调试器的奢侈。幸运的是，Windows支持触摸屏硬件，可以为我们的应用程序提供`WM_TOUCH`事件。这个方法展示了一个技巧，利用多只鼠标来模拟触摸事件。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe relies on a third-party Windows driver, the MultiTouchVista, a user
    input management layer that handles input from various devices. It can be downloaded
    from [http://multitouchvista.codeplex.com/](http://multitouchvista.codeplex.com/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本方法依赖于第三方Windows驱动程序，即MultiTouchVista，它是一个用户输入管理层，处理来自各种设备的输入。可以从[http://multitouchvista.codeplex.com/](http://multitouchvista.codeplex.com/)下载。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we need to install the system driver. We extract the `MultiTouchVista_-_second_release_-_refresh_2.zip`
    file, the latest release at the time of writing, and then open the command line
    with administrator rights. If the console is run without administrator privileges,
    the installation of the driver fails. The extracted folder contains the `Driver`
    subfolder, where you should choose either the `x64` or `x32` folder, depending
    on the type of your operating system. In that folder, we execute the following
    command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装系统驱动。我们解压`MultiTouchVista_-_second_release_-_refresh_2.zip`文件，这是在撰写本文时最新的版本，然后用管理员权限打开命令行。如果未以管理员权限运行控制台，驱动程序安装将会失败。解压后的文件夹包含一个名为`Driver`的子文件夹，你应根据操作系统的类型选择`x64`或`x32`文件夹。在那个文件夹中，我们执行以下命令：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A dialog appears, asking whether you want to install this device software or
    not; you should click on the **Install** button. Once the installation is complete,
    you will see a message on the command line.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会弹出一个对话框，询问你是否想要安装这个设备软件，你应该点击**安装**按钮。安装完成后，你将在命令行上看到一条消息。
- en: The next thing we do, is activate the driver in **Device Manager**. We open
    the **Control Panel**, then the **Device Manager** window. There, we find the
    **Human Interface Devices** item in the list. We right-click on the **Universal
    Software HID device**, the one we have just installed the drivers for. We choose
    **Disable** from the context menu to disable the device. In the confirmation before
    disabling the device, we just respond with **Yes**. After that, we re-enable this
    device again by right-clicking on this node and choosing **Enable**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们要做的是在**设备管理器**中激活驱动。我们打开**控制面板**，然后打开**设备管理器**窗口。在那里，我们在列表中找到**人体学输入设备**项。我们右键点击刚刚安装了驱动程序的**通用软件HID设备**。从上下文菜单中选择**禁用**以禁用该设备。在禁用设备前的确认中，我们只需回答**是**。之后，我们再次通过右键点击这个节点并选择**启用**来重新启用这个设备。
- en: Now, since we emulate the multi-touch with mice, we should somehow display the
    touch points on the screen, because otherwise it is impossible to know where the
    mice pointers are. In **Control Panel** | **Hardware and Sound**, we open the
    **Pen and Touch** window. The **Touch** tab contains the **Show the touch pointer
    when I'm interacting with items on the screen** checkbox, which should be enabled.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于我们使用鼠标模拟多点触控，我们应该在屏幕上以某种方式显示触摸点，因为否则不可能知道鼠标指针的位置。在**控制面板** | **硬件和声音**中，我们打开**笔和触摸**窗口。**触摸**选项卡包含**当我与屏幕上的项目互动时显示触摸指针**复选框，应该启用它。
- en: When all the mice are connected, we can start the driver. We open two command
    lines and in the first one, we run `Multitouch.Service.Console.exe` from the `MultiTouchVista`
    package. In the second console window, we run `Multitouch.Driver.Console.exe`
    without closing the **MultiTouch.Server.Console** window. Quit both of these applications
    to return to the normal non-multi-touch Windows environment.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有鼠标都连接后，我们可以启动驱动程序。我们打开两个命令行窗口，在第一个窗口中运行来自`MultiTouchVista`软件包的`Multitouch.Service.Console.exe`。在第二个控制台窗口中，我们运行`Multitouch.Driver.Console.exe`，同时不要关闭**MultiTouch.Server.Console**窗口。退出这两个应用程序，以返回到正常的非多点触控Windows环境。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To check whether the driver and the service work as expected, we can try the
    standard Microsoft Paint application and use two or more mice simultaneously to
    draw something.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查驱动程序和服务是否如预期般工作，我们可以尝试使用标准微软画图应用程序，并使用两只或多只鼠标同时绘制一些内容。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Handling multi-touch events on Windows*'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Windows上处理多点触控事件*'
- en: Handling multi-touch events on Windows
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上处理多点触控事件
- en: Once we have installed the `MultiTouchVista` driver, or if we happen to have
    a multi-touch-capable screen, we can initialize an event loop in the application
    and handle the `WM_TOUCH` messages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`MultiTouchVista`驱动后，或者如果我们恰好有一个支持多点触控的屏幕，我们可以在应用程序中初始化一个事件循环并处理`WM_TOUCH`消息。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The first recipe contains all the relevant information about multi-touch handling.
    In this recipe, we only extend our code for Microsoft Windows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个食谱包含了关于多点触控处理的所有相关信息。在这个食谱中，我们仅扩展了针对Microsoft Windows的代码。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This book doesn’t discuss about multi-touch input emulation for Mac.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有讨论关于Mac的多点触控输入模拟。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `MinGW` toolchain does not include the latest Windows SDK headers, so a
    number of constants should be defined to use the `WM_TOUCH` messages:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MinGW`工具链不包括最新的Windows SDK头文件，因此需要定义许多常量以使用`WM_TOUCH`消息：'
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `TOUCHINPUT` structure encapsulates a single touch using the `WinAPI` data
    types and should also be declared manually for `MinGW`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TOUCHINPUT`结构使用`WinAPI`数据类型封装了一个单独的触摸，并且也应该为`MinGW`手动声明：'
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next four functions provide the touch interface handling for our application.
    We declare the function prototypes and static function pointers to load them from
    `user32.dll`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的四个函数为我们的应用程序提供了触摸界面处理。我们声明函数原型和静态函数指针，以便从`user32.dll`加载它们：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since `MinGW` does not support the automatic export of `WM_TOUCH`-related routines,
    we have to load them manually from `user32.dll` using `GetProcAddress()`. This
    is done in the `LoadTouchFuncs()` function, which is defined in the file `Wrapper_Windows.cpp`
    from `1_MultitouchInput`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`MinGW`不支持自动导出与`WM_TOUCH`相关的方法，我们必须使用`GetProcAddress()`手动从`user32.dll`加载它们。这一操作在`1_MultitouchInput`中的`Wrapper_Windows.cpp`文件中定义的`LoadTouchFuncs()`函数中完成：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Last, we need to declare the `GetTouchPoint()` routine, which converts the
    `TOUCHPOINT` coordinates to screen pixels, for simplicity a hardcoded window size
    of 100 x 100 pixels is used:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要声明`GetTouchPoint()`例程，它将`TOUCHPOINT`坐标转换为屏幕像素，为了简单起见，这里使用了硬编码的窗口大小100
    x 100像素：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we are ready to implement the multi-touch message handling on Windows.
    In our window function, we add a new message handler for the `WM_TOUCH` message,
    which contains data for several different touch points packed together. We unpack
    the parameters into an array, where each item represents a message for a single
    touch:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在Windows上实现多点触控消息处理。在我们的窗口函数中，我们为`WM_TOUCH`消息添加一个新的消息处理程序，其中包含了打包在一起的不同触摸点的数据。我们将参数解包到一个数组中，其中每个条目代表单个触摸点的消息：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For each touch point, we update its status in the global array `g_TouchPoints`.
    This is the main difference from the Android code, since there we decode the `MotionEvent`
    structure in Java code and pass a list of points to the native code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个触摸点，我们在全局数组`g_TouchPoints`中更新其状态。这是与Android代码的主要区别，因为在Java代码中我们会解码`MotionEvent`结构体，并将点列表传递给本地代码：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we clean up the temporary array:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们清理临时数组：
- en: '[PRE19]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We remove all the released points:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们移除所有释放的点：
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we handle all the active touch points:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理所有活动的触摸点：
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The event handler uses a global list of touch points:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件处理程序使用一个全局触摸点列表：
- en: '[PRE22]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `sTouchPoint` structure point encapsulates the coordinates, the touch point
    `ID`, a motion flag, and the associated event time stamp for a single touch point:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sTouchPoint`结构体封装了一个触摸点的坐标、触摸点`ID`、运动标志和关联的事件时间戳：'
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Check if this touch point is active:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这个触摸点是否处于激活状态：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Viewport_UpdateTouchPoint()` function either adds the point to the list,
    or just updates the state depending on the motion flag:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Viewport_UpdateTouchPoint()`函数会根据运动标志将点添加到列表中，或者只是更新状态：'
- en: '[PRE25]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Viewport_ClearReleasedPoints()` function removes all the points with the
    motion flag set to `MOTION_UP`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Viewport_ClearReleasedPoints()`函数移除所有运动标志设置为`MOTION_UP`的点：'
- en: '[PRE26]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last function, `Viewport_UpdateCurrentGesture()`, sends the point list
    to the gesture processor:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数，`Viewport_UpdateCurrentGesture()`，将点列表发送到手势处理器：
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the `WM_CREATE` event handler, we register our window as the touch event
    responder:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WM_CREATE`事件处理程序中，我们将我们的窗口注册为触摸事件响应者：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then we get a sequence of touch events in the `Viewport_ProcessMotion()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Viewport_ProcessMotion()`函数中获取一系列触摸事件。
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Windows 8 has introduced the `WM_POINTER` message, which ensures much cleaner
    code, similar to the Android and other touch-based environments. Interested readers
    may read the respective MSDN articles ([http://msdn.microsoft.com/en-us/library/hh454928(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/hh454928(v=vs.85).aspx))
    and write a similar handler in the window function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8引入了`WM_POINTER`消息，这确保了代码更加整洁，类似于Android和其他基于触摸的环境。感兴趣的读者可以阅读相应的MSDN文章（[http://msdn.microsoft.com/en-us/library/hh454928(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/hh454928(v=vs.85).aspx)），并在窗口函数中编写类似的处理程序。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The code for the `WM_TOUCH` message handling is included in the `1_MultitouchInput`
    example. The next recipe shows how to decode a sequence of multi-touch events
    and recognize some basic gestures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`1_MultitouchInput`示例中包含了`WM_TOUCH`消息处理代码。下一个食谱将展示如何解码一系列的多点触控事件并识别一些基本的手势。'
- en: Recognizing gestures
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别手势
- en: In this recipe, we implement a function which detects pinch-zoom-rotate and
    fling/swipe gestures. It can serve as a starting point for recognition of your
    own custom gestures.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们实现了一个检测捏合缩放旋转和fling/swipe手势的函数。它可以作为识别您自定义手势的起点。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe relies on the recipe *Processing multi-touch events on Android*
    from this chapter to handle multi-touch input.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱依赖于本章中的*在Android上处理多点触控事件*食谱来处理多点触控输入。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We split the task of motion decoding into individual layers. The low-level
    code handles the OS-generated touch events. Collected touch point data is processed
    using a set of routines in the mid-level code, which we present in this recipe.
    Finally, all the decoded gestures are reported to the user''s high-level code
    using the simple `iGestureResponder` interface:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将运动解码任务分解为各个层次。低级代码处理操作系统生成的触摸事件。收集到的触摸点数据由中级代码中的一组例程处理，我们将在本食谱中介绍这些内容。最后，所有解码的手势都通过简单的`iGestureResponder`接口报告给用户的高级代码：
- en: '[PRE29]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Event_UpdateGesture()` method is provided for direct access to the current
    state of contact points. The `sMotionData` structure is presented right after
    the `iGestureResponder` discussion. The `1_MultitouchInput` example overrides
    this method to render the touch points:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Event_UpdateGesture()`方法提供了直接访问接触点当前状态的功能。在讨论了`iGestureResponder`之后，紧接着介绍了`sMotionData`结构。`1_MultitouchInput`示例重写了这个方法来渲染触摸点：'
- en: '[PRE30]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Event_PointerChanged()`and `Event_PointerMoved()` methods are called to
    indicate the changes in individual touches:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Event_PointerChanged()`和`Event_PointerMoved()`方法被调用，以指示单个触摸的变化：'
- en: '[PRE31]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The information about decoded gestures is sent to the `iGestureResponder` instance.
    When the fling/swipe event finishes, the `Event_Fling()` method is called:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码的手势信息被发送到`iGestureResponder`实例。当fling/swipe事件结束时，会调用`Event_Fling()`方法：
- en: '[PRE32]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the timestamps in the `Up` and `Down` points, the responder may estimate
    the speed of the finger movement and decide if the gesture succeeds. The `Event_Drag()`
    method is called when the finger is dragged across the screen:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Up`和`Down`点的时间戳，响应者可以估计手指移动的速度并决定手势是否成功。当手指在屏幕上拖动时，会调用`Event_Drag()`方法：
- en: '[PRE33]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The pinch-zoom event is handled using three methods. The `Event_PinchStart()`
    method is called when the gesture starts, `Event_PinchStop()` is called at the
    end of the gesture, and the `Event_Pinch()` method is called on each update of
    two touch points:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捏合缩放事件通过三种方法处理。当手势开始时调用`Event_PinchStart()`方法，手势结束时调用`Event_PinchStop()`，每次更新两个触摸点时调用`Event_Pinch()`方法：
- en: '[PRE34]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s get to the mid-level routines to decode gestures. First, declare an
    instance of `iGestureResponder` which is used later:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到中级例程来解码手势。首先，声明一个`iGestureResponder`的实例，稍后使用：
- en: '[PRE35]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We introduce the `sMotionData` structure, which describes the current gesture
    state. Individual touch point features are accessed with the `Get*` functions.
    The `AddTouchPoint()` function ensures no points with duplicate IDs are added:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入了`sMotionData`结构，它描述了当前的手势状态。使用`Get*`函数访问单个触摸点的特征。`AddTouchPoint()`函数确保不会添加具有重复ID的点：
- en: '[PRE36]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A gesture is described by the current state of its touch points and a ring
    buffer of previous touch point states. To detect a gesture, we create an ad-hoc
    state machine. Two Boolean variables indicate if we really have the gesture and
    if the gesture is progressing. Validity flags are also stored for each kind of
    gesture:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手势由其触摸点的当前状态和先前触摸点状态的环形缓冲区描述。为了检测手势，我们创建了一个临时的状态机。两个布尔变量指示我们是否真的有手势以及手势是否正在进行中。对于每种类型的手势，也存储有效性标志：
- en: '[PRE37]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Single-finger gestures, like fling, drag, or tap, are described by the current
    and initial touch points. The pinch-zoom is a two-finger gesture whose state is
    determined by two initial points and two current points. Centers are calculated
    as the average of the initial and current point coordinates:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单指手势，如抛掷、拖拽或轻触，由当前点和初始点描述。捏合缩放是双指手势，其状态由两个初始点和两个当前点确定。中心点坐标是初始点和当前点坐标的平均值：
- en: '[PRE38]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To ignore accidental screen touches, we introduce a sensitivity threshold,
    which is the smallest percent of the screen space a finger must travel for the
    fling gesture to be detected:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了忽略意外的屏幕触摸，我们引入了一个灵敏度阈值，这是手指必须移动的最小屏幕空间百分比，以便检测到抛掷手势：
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The fling gesture is completely ignored if the finger''s final position moves
    from the initial position by less than the following value:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果手指最终位置相对于初始位置移动小于以下值，那么抛掷手势将被完全忽略：
- en: '[PRE40]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `RingBuffer` data structure is implemented using a simple dynamic array.
    The full source code is in the `RingBuffer.h` file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RingBuffer`数据结构是使用一个简单的动态数组实现的。完整的源代码在`RingBuffer.h`文件中：'
- en: '[PRE41]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The only special method is the accessor to previous states, relative to `FHead`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的特殊方法是相对于`FHead`的先前状态的访问器：
- en: '[PRE42]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The current element and the total number of items:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前元素和项目总数：
- en: '[PRE43]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Division remainder with the wrapping around for negative values:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负值时的带环绕的除法余数：
- en: '[PRE44]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last routine calculates the previous element index:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个例程计算前一个元素索引：
- en: '[PRE45]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To decode a gesture, we carefully handle each of the touch events. At the beginning
    we reset the touch point collection, and at the end of the touch we check for
    gesture completion:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解码手势，我们仔细处理每一个触摸事件。在开始时我们重置触摸点集合，在触摸结束时我们检查手势是否完成：
- en: '[PRE46]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we are still moving, then modify the information about the current point:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们仍在移动，那么修改当前点的信息：
- en: '[PRE47]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Depending on the motion flag, we inform the responder about individual touches:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据运动标志，我们通知响应者关于个别触摸的信息：
- en: '[PRE48]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `UpdateGesture()` function does all the job of detection. It checks the
    current state of the gesture and calls the methods of the `g_Responder` object
    if any of the gestures are in progress:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UpdateGesture()`函数负责所有的检测工作。它会检查当前的手势状态，并在有手势进行中的时候调用`g_Responder`对象的方法：'
- en: '[PRE49]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The drag-and-pinch gestures are checked in the `IsDraggingValid()` and `IsPinchZoomValid()`
    methods, which are described a bit later. We respond to a single point drag, if
    the finger has travelled more than a specified distance:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖拽和捏合手势通过`IsDraggingValid()`和`IsPinchZoomValid()`方法进行检查，这些方法稍后会进行描述。如果手指移动超过特定距离，我们会响应单点拖拽：
- en: '[PRE50]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `UpdateGesture()` function previously described uses the following helper
    function:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前描述的`UpdateGesture()`函数使用了以下辅助函数：
- en: '[PRE51]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The drag or fling motion should be performed with a single finger. To distinguish
    a drag from a fling, we use the `IsDraggingValid()` function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖拽或抛掷动作应该用一根手指完成。为了区分拖拽和抛掷，我们使用`IsDraggingValid()`函数：
- en: '[PRE52]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To check whether the user is performing the pinch-zoom gesture, we call the
    `IsPinchZoomValid()` function. We get the touch points and calculate the distance
    between them. If we are already performing the pinch-zoom gesture, we update the
    current points. Otherwise, we store the initial points and calculate the center:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查用户是否正在执行捏合缩放手势，我们调用`IsPinchZoomValid()`函数。我们获取触摸点并计算它们之间的距离。如果我们已经在执行捏合缩放手势，我们更新当前点。否则，我们存储初始点并计算中心：
- en: '[PRE53]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The `g_Responder` instance receives all the data about decoded gestures.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_Responder`实例接收所有关于解码手势的数据。'
- en: Implementing an on-screen joypad
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现屏幕上的游戏手柄
- en: It is time to make use of the multi-touch facilities and emulate a gaming console-like
    interface on an Android device touch screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候利用多点触控功能，在Android设备触摸屏上模拟类似游戏控制台界面了。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Learn how to handle multi-touch input from recipes *Processing multi-touch events
    on Android* and *Processing multi-touch events on Windows* before proceeding with
    this recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续这个食谱之前，先学习如何处理来自*在Android上处理多点触控事件*和*在Windows上处理多点触控事件*的食谱的多点触控输入。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We implement a custom multi-touch event handler, which keeps track of all the
    touch points. The joystick is rendered as a full-screen bitmap shown on the left-hand
    side. When the user touches the screen, we use the touch coordinates to fetch
    the pixel color from the mask on the right-hand side of the figure. Then, we find
    the internal button corresponding to the color and change its `Pressed` state.
    The following figure shows the joypad visual representation and the color mask:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个自定义的多点触控事件处理器，它跟踪所有的触控点。游戏手柄被渲染成左侧的全屏位图。当用户触摸屏幕时，我们使用触摸坐标从图右侧的遮罩中获取像素颜色。然后，我们找到与颜色对应的内部按钮并改变其`Pressed`状态。下图展示了游戏手柄的可视表示和颜色遮罩：
- en: '![How to do it...](img/7785_07_1.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/7785_07_1.jpg)'
- en: 'Single button of our virtual joystick is determined by its color in the mask
    and the index in the buttons table:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们虚拟游戏手柄的单个按钮由其在遮罩中的颜色和在按钮表中的索引确定：
- en: '[PRE54]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A virtual analogue stick supports two directions and is determined by its radius,
    mask color, and position:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟模拟杆支持两个方向，由其半径、遮罩颜色和位置确定：
- en: '[PRE55]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `ScreenJoystick` class contains descriptions for all of the buttons and
    axes:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ScreenJoystick`类包含了所有按钮和轴的描述：'
- en: '[PRE56]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The values for each axis and the `Pressed` flags for each button are stored
    in two arrays:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个轴的值和每个按钮的`Pressed`标志存储在两个数组中：
- en: '[PRE57]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The mask bitmap data pointer is also necessary for this class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类还需要遮罩位图数据指针：
- en: '[PRE58]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `FPushed*` arrays tell us which buttons and axes are currently activated:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FPushed*`数组告诉我们当前哪些按钮和轴被激活了：'
- en: '[PRE59]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The constructor and destructor are essentially empty:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数和析构函数本质上是空的：
- en: '[PRE60]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `InitKeys()` method allocates the state arrays when the joystick construction
    is finished:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InitKeys()`方法在游戏手柄构造完成后分配状态数组：'
- en: '[PRE61]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `Restart()` method clears the state of pushed buttons:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Restart()`方法清除被按下按钮的状态：'
- en: '[PRE62]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The internal state is changed by the private `SetAxisValue()` and `SetKeyState()`
    methods:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部状态由私有的`SetAxisValue()`和`SetKeyState()`方法改变：
- en: '[PRE63]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `IsPressed()` and `GetAxisValue()` methods can read the state of a key
    or an axis:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsPressed()`和`GetAxisValue()`方法可以读取一个键或轴的状态：'
- en: '[PRE64]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following internal methods look up for the button and axis with a given
    color:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的内部方法通过给定的颜色查找按钮和轴：
- en: '[PRE65]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Two values for each axis are read as the displacement from the center:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个轴的两个值作为从中心点的位移读取：
- en: '[PRE66]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Read axis value based on a center point and a touch point:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据中心点和触摸点读取轴值：
- en: '[PRE67]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The main routine is the `HandleTouch()` method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主例程是`HandleTouch()`方法：
- en: '[PRE68]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the touch has just started, we reset the values for each button and axis:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果触摸刚刚开始，我们重置每个按钮和轴的值：
- en: '[PRE69]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the pointer is moving, we look up the respective button or axis:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指针正在移动，我们查找相应的按钮或轴：
- en: '[PRE70]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For each button we find, set the pressed state to true:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们找到的每个按钮，将按下状态设置为真：
- en: '[PRE71]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For each found axis, we read the value:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于找到的每个轴，我们读取其值：
- en: '[PRE72]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We declare a global variable, which holds the state of our joystick:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个全局变量，它保存了游戏手柄的状态：
- en: '[PRE73]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the `OnStart()` method, we add two axes and a single button:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnStart()`方法中，我们添加两个轴和一个按钮：
- en: '[PRE74]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we initialize the joystick and reset its state:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化游戏手柄并重置其状态：
- en: '[PRE75]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Later in the code we can use the results of `g_Joystick.GetAxisValue` to find
    out the current axis value, and `g_Joystick.IsPressed` to see if the key is pressed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码稍后部分，我们可以使用`g_Joystick.GetAxisValue`的结果来获取当前的轴值，以及使用`g_Joystick.IsPressed`来查看按键是否被按下。
- en: Using FreeType for text rendering
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FreeType 进行文本渲染
- en: It is possible that the interface avoids rendering the textual information.
    However, most applications have to display some text on the screen. It is time
    to consider the **FreeType** text rendering in all its detail with kerning and
    glyph caching. This is the longest recipe of this book, but we really wish not
    to miss the details and subtleties of the FreeType usage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 界面可能避免渲染文本信息。然而，大多数应用程序必须在屏幕上显示一些文本。现在是详细考虑带字符间距和字形缓存的**FreeType**文本渲染的时候了。这是本书最长的食谱，但我们确实不希望错过
    FreeType 使用中的细节和微妙之处。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: It is time to make the real use of the recipe on the FreeType compilation from
    [Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"), *Porting Common
    Libraries*. We start with an empty application template described in [Chapter
    1](ch01.html "Chapter 1. Establishing a Build Environment"), *Establishing a Build
    Environment*. The following code supports multiple fonts, automatic kerning, and
    glyph caching.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将本书第二章[《移植通用库》](ch02.html "Chapter 2. Porting Common Libraries")中关于FreeType编译的实际应用提上日程了。我们从[第一章](ch01.html
    "Chapter 1. Establishing a Build Environment")*建立构建环境*中描述的空应用程序模板开始。以下代码支持多种字体、自动字距调整和字形缓存。
- en: '*In typography, kerning (less commonly mortising) is the process of adjusting
    the spacing between characters in a proportional font, usually to achieve a visually
    pleasing result.*'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在排版中，字距调整（较少见的是嵌槽）是调整比例字体中字符间间距的过程，通常是为了达到视觉上令人满意的效果。*'
- en: 'Courtesy: [http://en.wikipedia.org/wiki/Kerning](http://en.wikipedia.org/wiki/Kerning)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 致谢：[http://en.wikipedia.org/wiki/Kerning](http://en.wikipedia.org/wiki/Kerning)
- en: Glyph caching is a feature of the FreeType library, which reduces memory usage
    using glyph images and character maps. You can read about it at [http://www.freetype.org/freetype2/docs/reference/ft2-cache_subsystem.html](http://www.freetype.org/freetype2/docs/reference/ft2-cache_subsystem.html).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 字形缓存是FreeType库的一个特性，它通过使用字形图像和字符图来减少内存使用。你可以阅读关于它的内容在[http://www.freetype.org/freetype2/docs/reference/ft2-cache_subsystem.html](http://www.freetype.org/freetype2/docs/reference/ft2-cache_subsystem.html)。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Here we develop the `TextRenderer` class, which holds all the states of the
    FreeType library. We wrap the text rendering in a class to support multiple instances
    of this class and ensure the thread safety.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们开发了`TextRenderer`类，它保存了FreeType库的所有状态。我们将文本渲染封装在一个类中以支持此类多个实例，并确保线程安全。
- en: 'The required FreeType library initialization includes the library instance,
    glyph cache, character map cache, and image cache. We declare the internal FreeType
    objects first:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的FreeType库初始化包括库实例、字形缓存、字符图缓存和图像缓存。我们首先声明内部的FreeType对象：
- en: '[PRE76]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then the list of loaded fonts is declared:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后声明已加载字体的列表：
- en: '[PRE77]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `FMaskMode` switch is used to choose between opaque rendering and alpha-mask
    creation. It is mentioned later in the glyph rendering code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FMaskMode`开关用于选择不透明渲染和alpha遮罩创建。它稍后在字形渲染代码中提到：'
- en: '[PRE78]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The initialization routine creates the FreeType library instance and initializes
    the glyph and image caches:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化例程创建FreeType库实例并初始化字形和图像缓存：
- en: '[PRE79]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As usual, we provide the shortest code possible. The complete code should check
    for non-zero return codes from the `FTC_*` functions. The `LoadFT()` function
    initializes the function pointers for the FreeType library. We use the `PTR` suffix
    for all of the FreeType functions in the code for this recipe to allow dynamic
    library loading on Windows. If you are only concerned about Android development,
    the `PTR` suffix can be omitted.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与往常一样，我们提供了尽可能简短的代码。完整的代码应该检查`FTC_*`函数返回的非零代码。`LoadFT()`函数初始化FreeType库的函数指针。在本书的代码中，为了允许在Windows上动态加载库，我们为所有FreeType函数使用了`PTR`后缀。如果你只关心Android开发，可以省略`PTR`后缀。
- en: 'The deinitialization routine clears all the internal data and destroys the
    FreeType objects:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反初始化例程清除所有内部数据并销毁FreeType对象：
- en: '[PRE80]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `FreeString()` routine clears the internal FreeType glyphs cache:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FreeString()`例程清除内部FreeType字形缓存：'
- en: '[PRE81]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`FString` contains all the characters from the string being rendered. The initialization
    and deinitialization functions are called in the constructor and destructor, respectively:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FString`包含正在渲染的字符串的所有字符。初始化和反初始化函数分别在构造函数和析构函数中调用：'
- en: '[PRE82]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To utilize the **TrueType** fonts and render the glyphs, we need to create
    a simple set of management routines to load the font files. The first one is the
    `LoadFontFile()` function, which loads the font file, stores its contents in the
    list, and returns the error code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了利用**TrueType**字体并渲染字形，我们需要创建一组简单的管理例程来加载字体文件。第一个是`LoadFontFile()`函数，它加载字体文件，将其内容存储在列表中，并返回错误代码：
- en: '[PRE83]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We always use the 0-th face, which is the first one in the loaded file:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总是使用第0个面，这是加载文件中的第一个：
- en: '[PRE84]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Check for success and store the font in the array of loaded font faces:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否成功并将字体存储在已加载字体面的数组中：
- en: '[PRE85]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `ReadFileData()` function loads the content of `File`. You are encouraged
    to implement this function or to see the accompanying source, where it is done
    by means of our Virtual Filesystem.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ReadFileData()`函数加载`File`的内容。鼓励您实现此功能或查看随附的源代码，其中通过我们的虚拟文件系统完成此操作。'
- en: 'The static function `FreeType_Face_Requester()` caches the access to the font
    face and allows us to reuse loaded fonts. It is defined in the FreeType library
    headers:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态函数`FreeType_Face_Requester()`缓存对字体面的访问，并允许我们重用已加载的字体。它在FreeType库头文件中定义：
- en: '[PRE86]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The FreeType library allows the `RequestData` parameter, where we pass an instance
    of `TextRenderer` by pointer. The `#ifdef` in the code of `FreeType_Face_Requester()`
    is necessary to run on 64-bit versions of Windows. The Android OS is 32-bit only,
    and the casting of `void*` to `int` is implicitly allowed.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FreeType库允许`RequestData`参数，我们通过指针传递`TextRenderer`的实例。在`FreeType_Face_Requester()`代码中的`#ifdef`是必要的，以便在64位Windows版本上运行。Android
    OS是32位的，允许将`void*`隐式地转换为`int`。
- en: 'The `GetSizedFace` function sets the font size for the loaded face:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetSizedFace`函数为已加载的面设置字体大小：'
- en: '[PRE87]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, we define the internal `sFTChar` structure which holds the information
    about a single character:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义内部的`sFTChar`结构体，它保存有关单个字符的信息：
- en: '[PRE88]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The text we render is in the UTF-8 encoding, which must be converted to the
    UCS-2 multi-byte representation. The simplest UTF-8 decoder reads an input string
    and outputs its characters into the `FString` vector:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们渲染的文本采用UTF-8编码，必须将其转换为UCS-2多字节表示。最简单的UTF-8解码器读取输入字符串并将其字符输出到`FString`向量中：
- en: '[PRE89]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The decoder uses the following function to read individual character codes:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码器使用以下函数来读取单个字符编码：
- en: '[PRE90]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code of `DecodeNextUTF8Char()` was taken from the Linderdaum Engine
    at [http://www.linderdaum.com](http://www.linderdaum.com).
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DecodeNextUTF8Char()`的源代码取自Linderdaum Engine，位于[http://www.linderdaum.com](http://www.linderdaum.com)。'
- en: 'The `NextUTF8()` and `ContUTF8()` inline functions are declared next to the
    decoding buffers:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NextUTF8()`和`ContUTF8()`内联函数在解码缓冲区旁边声明：'
- en: '[PRE91]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'A buffer with the current string:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含当前字符串的缓冲区：
- en: '[PRE92]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The current character index and the source buffer length:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前字符索引和源缓冲区长度：
- en: '[PRE93]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Raw pointer to the source buffer and the current byte:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源缓冲区的原始指针和当前字节：
- en: '[PRE94]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Get the next byte or `UTF8_LINE_END` if there are no bytes left:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有剩余的字节，则获取下一个字节或`UTF8_LINE_END`：
- en: '[PRE95]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Get the low six bits of the next continuation byte and return `UTF8_DECODE_ERROR`
    if it is not a continuation byte:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取下一个延续字节的低六位，如果它不是延续字节，则返回`UTF8_DECODE_ERROR`：
- en: '[PRE96]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'By now, we have the font loading functions and a UTF-8 decoder. Now it is time
    to deal with the actual rendering. The first thing we want to do is calculate
    the string size in screen pixels, which is performed in the `CalculateLineParameters`
    function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了字体加载函数和一个UTF-8解码器。现在是处理实际渲染的时候了。我们首先想要做的是计算屏幕像素中的字符串大小，这由`CalculateLineParameters`函数执行：
- en: '[PRE97]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We use two variables to look for the minimum and maximum vertical positions:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用两个变量来查找最小和最大垂直位置：
- en: '[PRE98]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Another variable stores the horizontal size of the string:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个变量存储字符串的水平大小：
- en: '[PRE99]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We iterate over the `FString` array and use the `sFTChar::FGlyph` field to
    retrieve the vertical character size. We also add the `FAdvance` field to `SizeX`,
    to account for the kerning and horizontal character size:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`FString`数组，并使用`sFTChar::FGlyph`字段来获取字符的垂直大小。同时，我们将`FAdvance`字段加到`SizeX`上，以考虑字距调整和水平字符大小：
- en: '[PRE100]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We use the preceding code to render a UTF-8 string into a newly allocated bitmap:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用前面的代码将UTF-8字符串渲染到新分配的位图中：
- en: '[PRE101]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Decode the UTF-8 input string and calculate individual character positions:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码UTF-8输入字符串并计算每个字符的位置：
- en: '[PRE102]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Calculate the horizontal and vertical string dimensions and allocate the output
    bitmap:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算水平和垂直字符串尺寸并为输出位图分配空间：
- en: '[PRE103]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Render all the glyphs to the bitmap. Start on the other side of the bitmap,
    if the text is right-to-left:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有字形渲染到位图中。如果文本是从右到左的，则从位图的另一侧开始：
- en: '[PRE104]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The routine `LoadStringWithFont()` does the job of horizontal position calculation
    for each character of the string `S`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadStringWithFont()`例程负责计算字符串`S`中每个字符的水平位置：'
- en: '[PRE105]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Get the required font face:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所需的字体面：
- en: '[PRE106]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Decode the input UTF-8 string and calculate character sizes, checking each
    element in `FString`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码输入的UTF-8字符串并计算字符大小，检查`FString`中的每个元素：
- en: '[PRE107]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Load a glyph corresponding to the character:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载与字符对应的字形：
- en: '[PRE108]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Calculate the horizontal offset of this glyph:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算此字形的水平偏移量：
- en: '[PRE109]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Calculate the kerning for each character, except the first one:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算除第一个字符外的每个字符的间距：
- en: '[PRE110]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `LoadStringWithFont()` function uses auxiliary routines `Kern()` and `SetAdvance()`
    to calculate the offset between two sequential characters:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadStringWithFont()`函数使用辅助例程`Kern()`和`SetAdvance()`来计算两个连续字符之间的偏移量：'
- en: '[PRE111]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Convert the value from the 26.6 fixed-point format:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值从26.6固定小数格式转换：
- en: '[PRE112]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Finally, once we have the positions of each character, we render the individual
    glyphs to the bitmap:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们有了每个字符的位置，我们将各个字形渲染到位图上：
- en: '[PRE113]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The code in `RenderLineOnBitmap()` is fairly straightforward. The only subtle
    point is the bitwise shift operation, which converts the internal FreeType 26.6
    bit fixed-point format to a standard integer. First, we shift `StartX` left to
    get the FreeType's coordinate, and for each pixel, we shift `x` right to get the
    screen position.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RenderLineOnBitmap()`中的代码相当直接。唯一微妙之处在于位运算移位操作，它将内部的FreeType 26.6位固定小数格式转换为标准整数。首先，我们将`StartX`左移以获得FreeType的坐标，对于每个像素，我们将`x`右移以获得屏幕位置。'
- en: Note
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The 26.6 fixed-point format is used internally in FreeType to define fractional
    pixel coordinates.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FreeType在内部使用26.6固定小数格式来定义分数像素坐标。
- en: 'The `DrawGlyph()` routine copies raw pixels from the glyph, or multiplies the
    source by the glyph''s pixel, depending on the rendering mode:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DrawGlyph()`例程根据渲染模式，从字形复制原始像素，或者将源像素与字形的像素相乘：'
- en: '[PRE114]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The auxiliary `MultColor()` function multiplies each component of the integer-encoded
    color by the `Mult` factor:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助`MultColor()`函数将整数编码颜色的每个分量与`Mult`因子相乘：
- en: '[PRE115]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The minimal code to render a UTF-8 string covers the creation of a `TextRenderer`
    instance, font loading, and actual text rendering using the loaded font:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染UTF-8字符串所需的最小代码涵盖了创建`TextRenderer`实例、字体加载以及使用加载的字体进行实际文本渲染：
- en: '[PRE116]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Render the Portuguese word *direção*, which means *direction*, as an example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以葡萄牙语单词*direção*（意为*方向*）为例进行渲染：
- en: '[PRE117]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The result is the `bmp` variable, which contains the rendered text, as shown
    in the following screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`bmp`变量，其中包含渲染的文本，如下面的屏幕截图所示：
- en: '![How it works...](img/7785_07_2.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7785_07_2.jpg)'
- en: There's more…
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This is the longest recipe ever, and still some important details have been
    left out. If the amount of text you render for each frame is large enough, it
    makes sense to pre-render some of the strings and avoid recreation of images.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迄今为止最长的食谱，但仍然省略了一些重要细节。如果你每帧渲染的文本量足够大，预渲染一些字符串并避免重新创建图像是有意义的。
- en: Localization of in-game strings
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏内字符串的本地化
- en: Mobile applications are used on a variety of devices and, quite often, these
    devices are configured to use a language other than English. This recipe shows
    how to internationalize textual messages displayed in the application UI.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序在各种设备上使用，而且这些设备经常配置为使用非英语的语言。本食谱展示了如何在应用程序UI中显示文本消息时实现国际化。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Review [Chapter 4](ch04.html "Chapter 4. Organizing a Virtual Filesystem"),
    *Organizing a Virtual Filesystem*, for the read-only file access using our implementation
    of the virtual filesystem abstraction.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第4章](ch04.html "第4章. 组织虚拟文件系统")，*组织虚拟文件系统*，关于使用我们实现的虚拟文件系统抽象进行只读文件访问。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For each language we want to support, we need to prepare a set of translated
    strings. We store these strings in a file. An example for the English-Russian
    language pair would be the `Localizer-ru.txt` file:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们想要支持的每种语言，我们需要准备一组翻译后的字符串。我们将这些字符串存储在一个文件中。对于英文-俄文语言对，一个例子就是`Localizer-ru.txt`文件：
- en: '[PRE118]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `~` character is used as a delimiter between the original phrase and its
    translations. The original phrase can be used as a key, and it is stored with
    its translation in a global `std::map` container:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~`字符用作原始短语与其翻译之间的分隔符。原始短语可以用作键，并与它的翻译一起存储在一个全局的`std::map`容器中：'
- en: '[PRE119]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Let us suppose we have a locale name in a global variable:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个全局变量中的地区名称：
- en: '[PRE120]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We only need to implement the `LocalizeString()` function, which uses the `g_Translations`
    map:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要实现使用`g_Translations`映射的`LocalizeString()`函数：
- en: '[PRE121]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `LoadLocale()` routine uses the global `g_LocaleName` variable and loads
    the required translation table skipping the lines without the `~` character:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadLocale()`例程使用全局`g_LocaleName`变量，并加载所需的翻译表，跳过不含`~`字符的行：'
- en: '[PRE122]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The directory where we store the localized string files is defined for the
    of simplicity, in another global variable:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们定义了存储本地化字符串文件的目录，在另一个全局变量中：
- en: '[PRE123]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `LocalizeString()` function accepts a string in the base language and returns
    its translation. Whenever we want to render some text, we do not use string literals
    directly, as this will seriously reduce our ability to localize our game. Instead,
    we wrap these literals into the `LocalizeString()` calls:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalizeString()`函数接受基础语言的字符串并返回其翻译。每当我们想要渲染一些文本时，我们不会直接使用字符串字面量，因为这会严重降低我们本地化游戏的能力。相反，我们将这些字面量包装到`LocalizeString()`调用中：'
- en: '[PRE124]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There's more...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有很多...
- en: 'To render a text in an appropriate language we can use the OS functions to
    detect its current locale settings. On Android, we use the following Java code
    in our `Activity`. `SetLocale()` is called from the `Activity` constructor:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要以适当的语言渲染文本，我们可以使用操作系统函数来检测其当前地区设置。在Android上，我们在`Activity`中使用以下Java代码。`SetLocale()`是从`Activity`构造函数中调用的：
- en: '[PRE125]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Detect the locale name and pass it to our native code:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 检测地区名称并将其传递给我们的本地代码：
- en: '[PRE126]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In the native code, we just capture the locale name:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地代码中，我们只是捕获了地区名称：
- en: '[PRE127]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'On Windows, things are even simpler. We call the `GetLocaleInfo() WinAPI` function
    and extract the current language name in the ISO639 format ([http://en.wikipedia.org/wiki/ISO_639](http://en.wikipedia.org/wiki/ISO_639)):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，事情甚至更简单。我们调用`GetLocaleInfo() WinAPI`函数，并以ISO639格式提取当前语言名称（[http://en.wikipedia.org/wiki/ISO_639](http://en.wikipedia.org/wiki/ISO_639)）：
- en: '[PRE128]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
