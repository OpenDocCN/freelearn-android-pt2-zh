- en: Chapter 10. Getting More From AndEngine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover additional recipes that have a more specific application
    than those in previous chapters. These recipes include:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading all textures from a folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using textured meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a sprite-based shadow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a physics-based moving platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a physics-based rope bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading all textures from a folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a game that has a large amount of textures, loading each texture
    individually can become tedious. Creating a method to load and retrieve textures
    in such a game can be not only timesaving during development, but also reduce
    the overall loading times during runtime. In this recipe, we will create a way
    to load a large amount of textures using only a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, create a new activity class named `TextureFolderLoadingActivity` that
    extends the `BaseGameActivity` class. Next, create a folder named `FolderToLoad`
    in the `assets/gfx/` folder. Finally, place five images in the `assets/gfx/FolderToLoad/`
    folder with the names: `Coin1`, `Coin5`, `Coin10`, `Coin50`, and `Coin100`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to fill our `TextureFolderLoadingActivity` activity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following, simple code in our activity to make it functional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place this `ArrayList` variable and `ManagedStandardTexture` class inside
    of the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the next two methods to the activity class to allow us to load a
    texture by passing only the `TextureOptions` parameter and the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now insert the following method that allows us to load all of the textures
    within either one folder or multiple folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place the following methods into the activity to let us unload all `ManagedStandardTexture`
    classes or retrieve a texture by its short filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have all of our methods in the activity, place the following line
    of code in the `onCreateResources()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following code to the `onPopulateScene()` method to show how
    we can retrieve a loaded texture by name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we set up our `TextureFolderLoadingActivity` activity class by
    implementing the standard, overridden `BaseGameActivity` methods that most AndEngine
    games use. For more information on setting up an activity for use with AndEngine,
    see the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we create an `ArrayList` variable of `ManagedStandardTexture` objects,
    which is defined directly following the definition of the `ArrayList` variable.
    `ManagedStandardTextures` are simple containers that hold a pointer to an `ITextureRegion`
    region and a string variable that represents the `ITextureRegion` object's name.
    The `ManagedStandardTexture` class also includes a method to unload `ITextureRegion`
    and prepare the variables to be removed from memory upon the next garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third step includes two methods, `getTextureRegion()` and `loadAndManageTextureRegion()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getTextureRegion()` method calls the `loadAndManageTextureRegion()` method
    and returns the recently-loaded texture from the `ArrayList` variable named `loadedTextures`
    defined in step two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `loadAndManageTextureRegion()` method creates an `AssetBitmapTextureAtlasSource`
    source named `cSource`, which is only used to pass the texture's width and height
    in the following definition of the `BitmapTextureAtlas` object, `TextureToLoad`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TextureRegion` object, `TextureRegionToLoad`, is created by calling the
    `BitmapTextureAtlasTextureRegionFactory` object's `createFromAsset()` method.
    `TextureToLoad` is then loaded, and the `TextureRegionToLoad` object is added
    to the `loadedTextures` `ArrayList` variable by creating a new `ManagedStandardTexture`
    class. For more information on textures, see the *Different types of textures*
    recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine
    Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In step four, we create a method that parses the list of files in each folder
    passed in the `pFolderPaths` array and loads the image files as textures with
    the `TextureOptions` parameter being applied to each image. The `listFileNames`
    string array holds the list of files in each of the `pFolderPaths` folders, and
    the `curFilePath` and `curFileExtension` variables are used to store the filepaths
    and their relative extensions for use in determining which files are AndEngine-supported
    images. The first `for` loop simply runs the parsing and loading process for each
    folder path given. The `getAssets().list()` method throws an `IOException` exception
    and thus needs to be enclosed in a `try-catch` block. It is used to retrieve a
    list of all of the files within the passed `String` parameter. The second `for`
    loop sets `curFilePath` to the current `i` value's folder path concatenated with
    the current filename from the `listFileNames` array. Next, the `curFileExtension`
    string variable is set to the `curFilePath` variable's last index of ".", to return
    the extension, using the `substring()` method. Then, we check to make sure that
    the current file's extension is equal to one that is supported by AndEngine and
    call the `loadAndManageTextureRegion()` method if `true`. Finally, we catch the
    `IOException` exception by sending a message to the log and printing a `StackTrace`
    message from the `IOException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth step includes two methods, `unloadAllTextures()` and `getLoadedTextureRegion()`,
    that assist our managing of the textures loaded by our previous methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `unloadAllTextures()` method runs through all `ManagedStandardTextures`
    in the `loadedTextures` `ArrayList` object and unloads them using the `removeFromMemory()`
    method before removing them from `loadedTextures` and requesting a garbage collection
    from the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getLoadedTextureRegion()` method checks every `ManagedStandardTexture`
    in the `loadedTextures` variable against the `pName` string parameter and returns
    the current `ManagedStandardTexture` class' `ITextureRegion` region if the names
    are equal, or `null` if no match is made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step six calls the `loadAllTextureRegionsInFolders()` method from inside the
    `onCreateResources()` activity method by passing a `BILINEAR` `TextureOption`
    parameter and the asset folder path of our `FolderToLoad` folder. For more information
    on `TextureOptions`, see the *Applying options to our textures* recipe in [Chapter
    1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In our final step, we attach five sprites to our scene inside of the `onPopulateScene()`
    activity method. Each of the sprite constructors calls the `getLoadedTextureRegion()`
    method and passes the respective short name of the sprite's image file. The locations
    of each of the sprites place them in a horizontal line across the screen. The
    display of our sprites with textures loaded all at once should look similar to
    the following image. For more information on creating sprites, see the *Adding
    sprites to a layer* recipe in [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying options to our textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding sprites to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using textured meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Textured meshes**, which are simply triangulated polygons with a texture
    applied, are becoming more popular in mobile games because they allow for the
    creation and manipulation of non-rectangular shapes. Having the ability to work
    with textured meshes often creates an extra layer of game mechanics that were
    previously too costly to implement. In this recipe, we will learn how to create
    a textured mesh from a predetermined set of triangles.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new activity class named `TexturedMeshActivity` that extends
    `BaseGameActivity`. Next, place a seamless-tiling texture named `dirt.png` with
    the dimensions 512 x 128 in the `assets/gfx/` folder of our project. Finally,
    import the `TexturedMesh.java` class from the code bundle into our project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build our `TexturedMeshActivity` activity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following code in our activity to give us a standard AndEngine activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet to the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we prepare our `TexturedMeshActivity` class by inserting into it
    the standard, overridden `BaseGameActivity` methods that most AndEngine games
    use. For more information on setting up an activity for use with AndEngine, see
    the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In step two, we first define `texturedMeshT`, a `BitmapTextureAtlas` object,
    with the final parameter of the constructor being a `REPEATING_BILINEAR` `TextureOption`
    parameter to create a texture that will tile seamlessly within the triangles that
    make up our textured mesh. For more information on `TextureOptions`, see the *Applying
    options to our textures* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `texturedMeshTR` `ITextureRegion` object and loading our
    `texturedMeshT` object, we define an array of float variables that specify the
    relative and consecutive x and y positions of each of the vertices of each triangle
    that make up our textured mesh. See the following image for a better idea of how
    the vertices of a triangle are used in a textured mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we create the `meshBufferData` float array and set its size to the vertex
    size of the `TexturedMesh` class multiplied by the number of vertices in the `meshTriangleVertices`
    array—one vertex occupies two indices in the array, `X` and `Y`, so we must divide
    the length by `2`. Then, for each of the vertices in the `meshTriangleVertices`
    array, we apply the vertex''s position to the `meshBufferData` array. Finally,
    we create the `TexturedMesh` object, named `starTexturedMesh`. The parameters
    of the `TexturedMesh` constructor are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two parameters of the constructor are the x and y location of `400f`,
    `225f`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two parameters are the `meshBufferData` buffer data and the number
    of vertices, `12`, that we placed in the `meshBufferData` array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final three parameters of the `TexturedMesh` constructor are `DrawMode`
    of `Triangles`, `ITextureRegion` for the mesh, and our `VertexBufferObjectManager`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on creating `Meshes`, from which the `TexturedMesh` class
    is derived, see the *Applying primitives to a layer* recipe in [Chapter 2](ch02.html
    "Chapter 2. Working with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying options to our textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying primitives to a layer* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a sprite-based shadow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The addition of shadows to a game can increase the visual depth and give the
    game a more appealing appearance. Simply placing a sprite with a shadow texture
    below an object is a fast and efficient way to handle shadow creation. In this
    chapter, we will be learning how to do that while keeping the shadow properly
    aligned with its parent object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new activity class named `SpriteShadowActivity` that extends
    `BaseGameActivity` and implements `IOnSceneTouchListener`. Next, place a shadow
    image with a size of 256 x 128 and named `shadow.png` into the `assets/gfx/` folder.
    Finally, place a character image of size 128 x 256 and named `character.png` into
    the `assets/gfx/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build our `SpriteShadowActivity` activity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following standard AndEngine activity code in our activity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place these variables in our activity to give us specific control over
    the shadow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now place the following method in our activity to make the shadow''s alpha
    inversely proportional to the distance of the character from the shadow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the following code snippet into the `onSceneTouchEvent()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, fill the `onPopulateScene()` method with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we set up our `SpriteShadowActivity` activity class by implementing
    the standard, overridden `BaseGameActivity` methods that most AndEngine games
    use. For more information on setting up an activity for use with AndEngine, see
    the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how this recipe places our shadow sprite in relation
    to the character sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In step two, we define several constants that will control how the shadow sprite,
    `shadowSprite`, is aligned to the character sprite, `characterSprite`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two constants, `CHARACTER_START_X` and `CHARACTER_START_Y`, set the
    initial position of `characterSprite`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two constants, `SHADOW_OFFSET_X` and `SHADOW_OFFSET_Y`, control the
    distance on the x and y axis as to how far the shadow will be initially positioned
    in relation to the character sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SHADOW_OFFSET_X` constant is also used to update the shadow sprite's position
    when the character sprite is moved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next four constants control how, and to what level, the `shadowSprite`
    sprite''s alpha will be controlled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHADOW_MAX_ALPHA` and `SHADOW_MIN_ALPHA` set the absolute minimum and maximum
    alpha, which is changed according to the character''s distance on the y axis from
    the shadow. The further the distance, the lower the alpha of the `shadowSprite`
    sprite will be until the minimum level is reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SHADOW_MAX_ALPHA_HEIGHT` constant represents the maximum distance of the
    character from the shadow that the `shadowSprite` sprite's alpha will be affected
    before defaulting to `SHADOW_MIN_ALPHA`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SHADOW_MIN_ALPHA_HEIGHT` constant represents the minimum distance of the
    character from the shadow that the shadow's alpha should change. If `SHADOW_MIN_ALPHA_HEIGHT`
    is greater than `0`, the shadow's alpha will be at its maximum while the character's
    distance from the shadow is below `SHADOW_MIN_ALPHA_HEIGHT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining constants are calculated automatically from the previous set.
    `SHADOW_START_X` and `SHADOW_START_Y` represent the starting position of the `shadowSprite`
    sprite. They are calculated by adding the shadow's offset values to the character's
    starting position. The `CHARACTER_SHADOW_Y_DIFFERENCE` constant represents the
    initial starting distance between the character and the shadow on the y axis.
    The `SHADOW_ALPHA_HEIGHT_DIFFERENCE` constant represents the difference between
    the minimum and maximum heights and acts to modulate the shadow's alpha at runtime.
    The final constant, `SHADOW_ALPHA_DIFFERENCE`, represents the difference between
    the minimum and maximum alpha levels of the `shadowSprite` sprite. Similar to
    the `SHADOW_ALPHA_HEIGHT_DIFFERENCE` constant, it is used at runtime to determine
    the alpha level of the shadow.
  prefs: []
  type: TYPE_NORMAL
- en: The final two variables in step two, `shadowSprite` and `characterSprite`, represent
    the shadow and character in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the third step, we create a method that will update the shadow's alpha. We
    call the `shadowSprite.setAlpha()` method with the `MathUtils.bringToBounds()`
    method as the parameter. The `MathUtils.bringToBounds()` method takes a minimum
    and maximum value and ensures that the third value is within that range. We pass
    the `SHADOW_MIN_ALPHA` and `SHADOW_MAX_ALPHA` constants as the first two parameters
    of the `bringToBounds()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is the algorithm for determining the alpha of the shadow
    based on the distance of the `characterSprite` sprite from the `shadowSprite`
    sprite. The algorithm starts by subtracting the `CHARACTER_SHADOW_Y_DIFFERENCE`
    constant from the character's position on the y axis. This gives us the current
    ceiling of the y value that affects the shadow's alpha. Next, we subtract the
    shadow's starting position on the y axis to get the current, ideal distance of
    the character from the shadow. Next, we divide that distance by `SHADOW_ALPHA_HEIGHT_DIFFERENCE`
    to get the unit ratio of constrained-distance to alpha and multiply the ratio
    by the `SHADOW_ALPHA_DIFFERENCE` constant to get the unit ratio of constrained-distance
    to constrained-alpha. Currently, our ratio is inverted and will increase the alpha
    with distance, which opposes our goal of decreasing alpha as the character moves
    further, so we subtract it from the `SHADOW_MAX_ALPHA` constant to give us a proper
    ratio that decreases alpha as distance increases. Completing the algorithm, we
    then use the `bringToBounds()` method to ensure that the alpha value produced
    by the algorithm is constrained within the range of `SHADOW_MIN_ALPHA` to `SHADOW_MAX_ALPHA`.
  prefs: []
  type: TYPE_NORMAL
- en: Step four sets the position of the `characterSprite` sprite when the screen
    is first touched, or if the touch is moved, by checking the touch event's `isActionDown()`
    and `isActionMove()` properties. The `setPosition()` method, in this case, simply
    sets the x value to the touched x value and the x value to the touched y value
    or the character's starting y value, whichever is greater.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final step, we load the `TextureRegions`, `characterTextureRegion`,
    and `shadowTextureRegion` objects, for the character and shadow. For more information
    on `TextureRegions`, see the *Different types of textures* recipe in [Chapter
    1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
    Then, we create the `shadowSprite` and `characterSprite` sprites using their starting
    constants as the positions in the constructors. For `characterSprite`, we override
    the `setPosition()` method to also set the `shadowSprite` sprite''s position with
    the x offset applied and then call the `updateShadowAlpha()` method to set the
    proper alpha for the shadow after the character has moved. Finally, we attach
    the `shadowSprite` and `characterSprite` sprites to our scene and call the `updateShadowAlpha()`
    method to set the initial alpha of the shadow. The following image shows how the
    shadow''s alpha level is changed in relation to the distance from the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a physics-based moving platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most platform-style games have some sort of moving platform, which challenges
    the player to land with accurate timing. From a developer's standpoint, the platform
    is simply a physics-enabled body that moves from one location to another. In this
    recipe, we will see how to create a horizontally-moving platform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new activity class named `MovingPhysicsPlatformActivity` that extends
    `BaseGameActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build our `MovingPhysicsPlatformActivity` activity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following code snippet into our activity to make it functional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet to the `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the following code directly below the preceding code in the `onPopulateScene()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish the `onPopulateScene()` method and our activity by placing the following
    code after the preceding code to create a physics-enabled box that rests on the
    platform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first step, we prepare our `MovingPhysicsPlatformActivity` class by
    inserting into it the standard, overridden `BaseGameActivity` methods that most
    AndEngine games use. For more information on setting up an activity for use with
    AndEngine, see the *Understanding the life cycle* recipe in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*. The following
    image shows how our platform moves on a single axis, in this case to the right,
    while keeping the box on top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In step two, we first create a `FixedStepPhysicsWorld` object and register it
    as an update handler with our scene. Then, we create a `Rectangle` object, named
    `platformRect`, that will represent our moving platform and place it near the
    center of the screen. Next, we set the color of the `platformRect` rectangle to
    black using the `setColor()` method with a value of `0f` for the red, green, and
    blue float parameters. We then create a fixture definition for the platform. Notice
    that the friction is set to `1f` to prevent objects on it from sliding too much
    while it is moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the `Body` object, named `platformBody`, for the platform.
    Then, we register a `PhysicsConnector` class to connect the `platformRect` rectangle
    to the `platformBody` body. After attaching `platformRect` to our scene, we declare
    and set the variables that will control the moving platform:'
  prefs: []
  type: TYPE_NORMAL
- en: The `platformRelativeMinX` and `platformRelativeMaxX` variables represent how
    far to the left and right that the platform will move from its starting location
    in scene units.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `platformVelocity` variable represents the speed in meters per second for
    our physics platform body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two variables, `platformMinXWorldCoords` and `platformMaxXWorldCoords`,
    represent the absolute position of the `platformRelativeMinX` and `platformRelativeMaxX`
    variables and are calculated from the platform's initial x position scaled by
    the default `PIXEL_TO_METER_RATIO_DEFAULT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set the initial velocity of our `platformBody` body to the `platformVelocity`
    variable to make the body actively mobile as soon as the scene is first drawn.
    For more information on creating physics simulations, see the *Introduction to
    the Box2D physics extension* and the *Understanding different body types* recipes
    in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"), *Applications
    of Physics*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third step registers a new `IUpdateHandler` handler with our scene. In the
    `onUpdate()` method, we test if the platform's location is beyond the absolute
    bounds that we previously defined, `platformMinXWorldCoords` and `platformMaxXWorldCoords`.
    Depending on which absolute bound is reached, we set the location of the `platformBody`
    body to the reached bound and set its velocity to move away from the boundary.
    For more information on conditional update handlers, see the *Update handlers
    and conditionals* recipe in [Chapter 7](ch07.html "Chapter 7. Working with Update
    Handlers"), *Working with Update Handlers*.
  prefs: []
  type: TYPE_NORMAL
- en: In step four, we create and attach a box body to rest on the platform. For more
    information on creating a physics-enabled box, see the *Understanding different
    body types* recipe in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"),
    *Applications of Physics*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Update handlers and conditionals* in [Chapter 7](ch07.html "Chapter 7. Working
    with Update Handlers"), *Working with Update Handlers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a physics-based rope bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Box2D physics extension, creating complex physics-enabled elements
    is simple. One example of such a complex element is a rope bridge that reacts
    to collisions. In this recipe, we will see how to implement a method that creates
    a rope bridge tailored to specific parameters that control the bridge's size and
    physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new activity class named `PhysicsBridgeActivity` that extends `BaseGameActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build our `PhysicsBridgeActivity` activity class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following code in our activity to give us a standard AndEngine activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, place the following, incomplete method in our activity. This method will
    facilitate the creation of our bridge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the following code inside of the `for` loop of the `createBridge()`
    method above:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following code inside of our `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In step one, we set up our `PhysicsBridgeActivity` activity class by implementing
    the standard, overridden `BaseGameActivity` methods that most AndEngine games
    use. For more information on setting up an activity for use with AndEngine, see
    the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*. The following image shows what our
    physics-enabled bridge looks like with a physics-enabled square resting on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the second step, we implement the beginning of a method, named `createBridge()`,
    that will create our physics-enabled bridge. The first parameter, `pGroundBody`,
    is the ground `Body` object to which the bridge will be attached. The second parameter,
    `pLeftHingeAnchorPoint`, represents the x and y location of the upper-left side
    of the bridge. The third parameter, `pRightHingeAnchorPointX`, represents the
    x location of the right-hand side of the bridge. The next three parameters, `pNumSegments`,
    `pSegmentsWidth`, and `pSegmentsHeight`, represent how many segments the bridge
    will consist of and the width and height of each segment. The `pSegmentDensity`,
    `pSegmentElasticity`, and `pSegmentFriction` parameters will be directly passed
    to a fixture definition that will be applied to the segments of the bridge. For
    more information on fixture definitions, see the *Introduction to the Box2D physics
    extension* recipe in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"),
    *Applications of Physics*. The next two parameters, `pScene` and `pPhysicsWorld`,
    tell our method what the bridge segment rectangles and bridge segment bodies should
    be attached to. The final parameter is our `VertexBufferObjectManager` object
    and will be passed to the rectangles that represent each segment of our bridge.
  prefs: []
  type: TYPE_NORMAL
- en: The first two variables, `BridgeSegments` and `BridgeSegmentsBodies`, defined
    in the `createBridge()` method, are arrays that will hold the segment rectangles
    and segment bodies. They are defined to have a length passed by the `pNumSegments`
    parameter. The next variable, `BridgeSegmentFixtureDef`, is the fixture definition
    that each segment of the bridge will have. The `BridgeWidthConstant` variable
    represents the width of the bridge, calculated by finding the difference between
    the left and right anchors added to the width of a single segment of the bridge.
    The last variable, `BridgeSegmentSpacing`, represents how much space should be
    between each segment and is determined by dividing the width of the bridge by
    one more than the number of segments, and subtracting from that the half-width
    of the segments. We then create a `for` loop that will create and position the
    number of segments passed in the `pNumSegments` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the third step, we fill the previously created `for` loop. First, we create
    the current segment's rectangle, `BridgeSegments[i]`, that will act as the visual
    representation of the segment. We place it on the x axis using the `BridgeWidthConstant`
    variable divided by one more than the number of segments, and multiply that by
    the current segment number before adding the left hinge's x position, `pLeftHingeAnchorPoint[0]`
    and the amount of spacing between the segments, `BridgeSegmentSpacing`. For the
    y axis position of the current segment's rectangle, we place it at the left hinge's
    y position minus the segments' height divided by `2f` to make it flush with the
    hinge position.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the color of each segment to a light orange, `0.97f` red, `0.75f`
    green, and `0.54f` blue. After attaching the `Rectangle` object to the passed
    scene, we create the current segment's body by passing the segment's rectangle
    and a `BodyType` value of `Dynamic` to the standard `PhysicsFactory.CreateBoxBody()`
    method. We then set the linear damping to `1f` to smoothen the rhythmic movements
    caused by a collision. Next, we register a `PhysicsConnector` class to connect
    the current segment's rectangle to the current segment's body.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established a position and created corresponding rectangles
    and bodies for each segment, we create a `RevoluteJointDef` object, `revoluteJointDef`,
    to attach each segment to the bridge via a revolute joint. We test to see if the
    current segment is the first and, if so, attach the segment to the ground `Body`
    object instead of a previous segment. For the first bridge segment, the definition
    of the `Vector2 anchorPoint` places the `RevoluteJointDef` definition's anchor
    at an x location of the segment's x value, `BridgeSegmentsBodies[i].getWorldCenter().x`,
    minus the segment spacing, `BridgeSegmentSpacing`, divided by `2`, plus the segment
    width, `pSegmentsWidth`, divided by `2`, and scaled to the `PIXEL_TO_METER_RATIO_DEFAULT`
    default. The y location of the first segment's anchor point is simply the current
    segment's y value, `BridgeSegmentsBodies[i].getWorldCenter().y`. For the remaining
    segments, the anchor point's x location is computed by averaging the x position
    of the current segment with the x position of the previous segment.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `revoluteJointDef` is initialized using the `initialize()` method with
    the first body either set to the ground body, `pGroundBody`, if the current segment
    is the first, or the previous segment's body, `BridgeSegmentsBodies[i-1]`, if
    the current segment is not the first. The second body of `revoluteJointDef` is
    set to the current segment's body, and, after exiting the `if` statement, the
    joint is created with the `pPhysicsWorld` object's `createJoint()` method. We
    then test if the current segment will be the last created and, if so, create another
    revolute joint to attach the segment to the ground body to the right-hand side
    of the segment using a similar anchor point x location formula as for the first
    segment. For more information on physics simulations, see the *Introduction to
    the Box2D physics extension* and the *Understanding different body types* recipes
    in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"), *Applications
    of Physics*.
  prefs: []
  type: TYPE_NORMAL
- en: In the final step, we first create a `FixedStepPhysicsWorld` object inside of
    the `onPopulateScene()` method and register it as an update handler with our scene.
    Then, we create a ground body to which our bridge will be attached. Next, we create
    our bridge by calling the `createBridge()` method. We pass `groundBody` as the
    first parameter, a position of `0f,240f` to represent the mid-left side of the
    screen as the left anchor point, and an x position representing the right-hand
    side of the screen as the right anchor point. We then pass an integer of `16`
    as the number of segments to create and a segment width and height of `40f` and
    `10f`. Next, we pass a segment density of `4f`, a segment elasticity of `0.1f`,
    a segment friction of `0.5f`, our scene to which the segment rectangles will be
    attached, our physics world, and our `VertexBufferObjectManager` object. Now that
    our bridge is created, we create a simple box body to show that the bridge reacts
    to collisions properly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to the Box2D physics extension* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding different body types* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
