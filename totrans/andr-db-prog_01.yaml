- en: Chapter 1. Storing Data on Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：在 Android 上存储数据
- en: Today, we live in an increasingly data-centric and data-driven world. We live
    in a world where companies like Amazon track every item we view and every item
    we purchase so as to recommend similar products to us. We live in a world where
    companies like Google store every search query thrown at them so as to recommend
    better search queries in the future. We live in a world where social media sites
    like Facebook remember every event and every thought we share with our friends
    so as to better learn about each of their hundreds of millions of users. We live
    in an increasingly data-centric world, and so it's imperative that we develop
    applications with a data-centric perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们生活在一个日益以数据为中心和数据驱动的社会中。我们生活在一个像亚马逊这样的公司追踪我们查看的每一个商品和我们购买的每一个商品，以便向我们推荐类似商品的世界。我们生活在一个像谷歌这样的公司存储每一个向他们提出的搜索查询，以便未来推荐更好的搜索查询的世界。我们生活在一个像
    Facebook 这样的社交媒体网站记住我们与朋友分享的每一个事件和每一个想法，以便更好地了解他们数亿用户中的每一个的世界。我们生活在一个日益以数据为中心的世界中，因此，我们必须以数据为中心的视角开发应用程序，这是至关重要的。
- en: Now, why Android you might ask? Or more generally, why mobile applications?
    Take a look around you — the growth of mobile devices, such as smart phones and
    tablets, has been explosive over the last couple of years. Furthermore, mobile
    devices implicitly give us another layer of data that we previously didn't have
    with desktop applications. As you carry your smart phone or tablet around with
    you, it knows your location, it knows where you're checking in and what you're
    doing; in short, it knows much more about you than you're probably aware of.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么是 Android？或者更普遍地问，为什么是移动应用？看看你周围，近几年来，移动设备的增长，如智能手机和平板电脑，已经爆炸式增长。此外，移动设备隐含地为我们提供了之前在桌面应用中没有的另一层数据。当你随身携带智能手机或平板电脑时，它知道你的位置，知道你在哪里签到以及你在做什么；简而言之，它知道的你比你意识到的要多得多。
- en: Keeping these two points in mind, we begin our exploration of data and Android
    with a quick dive into the various methods the folks over at Google have built
    into the Android OS. This book assumes the reader has had *some* experience with
    the Android OS, as we'll dive right into the code. Now, not only is it important
    to know all the different data storage methods available to you, but equally important
    is to understand the strengths and weaknesses of each method, so that you can
    craft an efficient, well-designed, and scalable application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在记住这两个要点的同时，我们从数据和 Android 的角度开始探索，快速深入了解谷歌的工程师们为 Android 操作系统内置的各种方法。本书假设读者对
    Android 操作系统有一定的经验，因为我们将直接进入代码。现在，了解你可以使用的所有不同的数据存储方法很重要，但同样重要的是要了解每种方法的优点和缺点，这样你才能构建一个高效、设计良好且可扩展的应用程序。
- en: Using SharedPreferences
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SharedPreferences
- en: '`SharedPreferences` is the most simple, quick, and efficient way of storing
    local data in your Android application. It''s a framework that essentially allows
    you to store and associate various **key-value** pairs with your application (think
    of this as a map that comes with your application, which you can tap into at any
    time), and because each application is associated with its own `SharedPreferences`
    class, the data that gets stored and committed persists across all user sessions.
    However, because of its simple and efficient nature, `SharedPreferences` only
    allows you to save primitive data types (that is, booleans, floats, longs, ints,
    and strings), so keep this in mind when deciding what to store as a shared preference.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences`是在你的 Android 应用程序中存储本地数据最简单、快捷、高效的方式。它本质上是一个允许你存储和关联各种**键值**对与你的应用程序的框架（可以把它看作是随应用程序附带的地图，你可以随时利用它），因为每个应用程序都与其自己的`SharedPreferences`类关联，所以存储和提交的数据在所有用户会话中都是持久的。然而，由于其简单和高效的本质，`SharedPreferences`只允许你保存基本数据类型（即布尔值、浮点数、长整数、整数和字符串），因此在决定将什么作为共享偏好存储时要记住这一点。'
- en: 'Let''s look at an example of how you would access and use your application''s
    `SharedPreferences` class:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你如何访问和使用应用程序的`SharedPreferences`类的一个例子：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s walk through what''s going on in this little code snippet. First we
    start an `Activity` and in the `onCreate()` method, we make a request to retrieve
    a `SharedPreferences` class. The arguments for the `getSharedPreferences()` method
    are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这段小代码片段中发生的事情。首先，我们启动一个`Activity`，在`onCreate()`方法中，我们请求获取一个`SharedPreferences`类。`getSharedPreferences()`方法的参数是：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here the first argument simply specifies which shared preference mapping you
    want (each application can own several separate shared preference mappings, and
    so, just like you would specify the table name in a database, you must specify
    which mapping you want to retrieve). The second argument is a little more complex
    — in the example above, we pass in `MODE_PRIVATE` as the argument and this argument
    simply specifies the visibility of the shared preference instance you are retrieving
    (in this case the visibility is set to private, so that only your application
    can access the mappings contents). Other modes include:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个参数简单地指定你想要哪个共享偏好设置映射（每个应用程序可以拥有几个独立的共享偏好设置映射，因此，就像在数据库中指定表名一样，你必须指定要检索哪个映射）。第二个参数稍微复杂一些——在上面的例子中，我们传入`MODE_PRIVATE`作为参数，这个参数只是指定你正在检索的共享偏好设置实例的可见性（在这种情况下，可见性设置为私有，只有你的应用程序可以访问映射内容）。其他模式包括：
- en: '`MODE_WORLD_READABLE:` Makes the visibility of your map accessible by other
    applications, though contents can only be read'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_WORLD_READABLE:` 使你的地图对其他应用程序可见，尽管内容只能读取。'
- en: '`MODE_WORD_WRITEABLE:` Makes the visibility of your map accessible by other
    applications for both reading and writing'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_WORD_WRITEABLE:` 使你的地图对其他应用程序可见，并可用于读取和写入。'
- en: '`MODE_MULTI_PROCESS:` This mode, available since API Level 11, allows you to
    modify your map by multiple processes which may be writing to the same shared
    preference instance'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_MULTI_PROCESS:` 此模式自API Level 11起可用，允许你通过多个进程修改地图，这些进程可能会写入同一个共享偏好设置实例。'
- en: 'Now, once we have our shared preference object, we can immediately start retrieving
    contents by its various `get()` methods — for instance, the `getString()` and
    `getBoolean()` methods we saw earlier. These `get()` methods will typically take
    two parameters: the first being the *key*, and the second being the default value
    if the given key is not found. Taking the previous example, we have:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们有了共享偏好设置对象，就可以立即通过其各种`get()`方法检索内容——比如我们之前看到的`getString()`和`getBoolean()`方法。这些`get()`方法通常需要两个参数：第一个是*键*，第二个是如果找不到给定键时的默认值。以上一个例子为例，我们有：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And so, in the first case, we're trying to retrieve the string value associated
    with the key `strKey`, and defaulting to the string `error` if no such key is
    found. Likewise, in the second case, we're trying to retrieve a boolean value
    associated with the key `boolKey`, and defaulting to the boolean `false` if no
    such key is found.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一个案例中，我们尝试检索与键`strKey`关联的字符串值，如果找不到这样的键，则默认为字符串`error`。同样，在第二个案例中，我们尝试检索与键`boolKey`关联的布尔值，如果找不到这样的键，则默认为布尔值`false`。
- en: However, if you want to *edit* contents or *add new* content, then you'll have
    to retrieve the `Editor` object that each shared preference instance contains.
    This `Editor` object contains all of the `put()` methods which allow you to pass
    a key along with its associated value (just like you would for a standard `Map`
    object) — the only caveat is that after you add or update the content of your
    shared preference, you need to call the `Editor` object's `commit()` method to
    *save down those changes*. Furthermore, again, just like a standard `Map` object,
    the `Editor` class also contains `remove()` and `clear()` methods for you to freely
    manipulate the contents of your shared preference.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想*编辑*内容或*添加新*内容，那么你需要检索每个共享偏好设置实例中包含的`Editor`对象。这个`Editor`对象包含了所有允许你传递键及其关联值的`put()`方法（就像你对标准`Map`对象所做的那样）——唯一需要注意的是，在添加或更新共享偏好设置的内容后，你需要调用`Editor`对象的`commit()`方法来*保存这些更改*。此外，同样地，就像标准`Map`对象一样，`Editor`类也包含`remove()`和`clear()`方法，让你自由地操作共享偏好设置的内容。
- en: One last thing to note before we move on to typical use cases of `SharedPreferences`
    is that if you decide to set the visibility of your shared preference instance
    to `MODE_WORLD_WRITEABLE`, then you are potentially exposing yourself to various
    security breaches by malicious external applications. As a result, in practice,
    this mode is not recommended. However, the desire to share information locally
    between two applications is still one that many developers face, and so a method
    for doing so was developed that simply involves setting an `android:sharedUserId`
    in your application's manifest files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论`SharedPreferences`的典型用例之前，需要记住的最后一件事是，如果你决定将共享偏好实例的可见性设置为`MODE_WORLD_WRITEABLE`，那么你可能会因为恶意外部应用程序而面临各种安全漏洞。因此，实际上，不推荐使用这种模式。然而，许多开发人员仍然面临在两个应用程序之间本地共享信息的愿望，因此，开发了一种简单的方法，只需在应用程序的清单文件中设置一个`android:sharedUserId`即可实现。
- en: How this works is that each application, when signed and exported, is given
    an auto-generated application ID. However, if you explicitly set this ID in the
    application's manifest file, then, assuming two applications are signed with the
    same key, they will be able to freely access each other's data without having
    to expose their data to the rest of the applications on a user's phone. In other
    words, by setting the same ID for two applications, those two *and only those
    two* applications will be able to access each other's data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作原理是，每个签名并导出的应用程序都会获得一个自动生成的应用程序ID。但是，如果你在应用程序的清单文件中明确设置此ID，那么假设有两个应用程序使用相同的密钥签名，它们将能够自由访问彼此的数据，而无需将数据暴露给用户手机上的其他应用程序。换句话说，通过为两个应用程序设置相同的ID，只有这两个应用程序能够访问彼此的数据。
- en: Common use cases for SharedPreferences
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SharedPreferences的常见用例
- en: Now that we know how to instantiate and edit a shared preference object, it's
    important to think about some typical use cases for this type of data storage.
    And so, following are a couple of examples, illustrating what kinds of small,
    primitive key-value data pairs applications tend to like to save.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何实例化和编辑共享偏好对象，那么考虑这种数据存储类型的典型用例是很重要的。因此，以下是几个示例，说明应用程序倾向于保存哪些类型的小型、原始的键值对数据。
- en: Checking if it's the user's first time visit to your application
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查这是否是用户第一次访问你的应用程序
- en: 'For many applications, if this is the user''s first visit, then they will want
    to display some kind of instructions/tutorials activity or a splash screen activity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，如果这是用户的第一次访问，那么他们可能希望显示一些说明/教程活动或启动屏幕活动：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Checking when the application last updated itself
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查应用程序上次更新时间
- en: 'Many applications will have some kind of caching, or syncing, feature built-in,
    which will require regular updating. By saving the last update time, we can quickly
    check to see how much time has elapsed, and decide whether or not an update/sync
    needs to occur:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序内置了某种缓存或同步功能，这将需要定期更新。通过保存上次更新时间，我们可以快速检查已经过去了多少时间，并决定是否需要进行更新/同步：
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的账户下载你购买的所有Packt图书的示例代码文件，网址是[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)注册，我们会直接将文件通过电子邮件发送给你。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remembering what the user's login username was
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记住用户的登录用户名
- en: 'Many applications will allow the user to remember their username (as well as
    other login-oriented fields such as PINs, phone numbers, and so on) and a shared
    preference is a great way to store a simple primitive string ID:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序将允许用户记住他们的用户名（以及其他登录相关的字段，如PIN码、电话号码等），而共享偏好是存储简单原始字符串ID的好方法：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remembering an application's state
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记住应用程序的状态
- en: 'For many applications, the functionality of the application will change depending
    on the application''s state, typically set by the user. Consider a phone ringer
    application — if the user specifies that no functionality should occur if the
    phone is in silent mode, then this is probably an important state to remember:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序，应用程序的功能会根据应用程序的状态而改变，通常由用户设置。以电话铃声应用程序为例——如果用户指定在静音模式下不执行任何功能，那么这很可能是一个需要记住的重要状态：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Caching a user's location
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存用户的位置
- en: 'Any location-based application will often want to cache the user''s last location
    for a number of reasons (perhaps the user has turned off GPS, or has a weak signal,
    and so on). This can be easily done by converting the latitude and longitude of
    the user to floats and then storing those floats in a shared preference instance:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何基于位置的应用程序通常都会因为多种原因想要缓存用户的最后位置（可能用户关闭了GPS，或者信号弱等）。这可以通过将用户的纬度和经度转换为浮点数，然后存储在共享偏好设置实例中轻松完成：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the latest version of Android (API Level 11), there is also a new `getStringSet()`
    method which allows you to set and retrieve a set of string objects for a given
    associated key. Here''s how it looks in action:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的Android（API级别11）中，还有一个新的`getStringSet()`方法，它允许你为给定的关联键设置和检索一组字符串对象。以下是它的实际应用：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use cases for this are plenty — but for now let's move on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的用例很多——但现在让我们继续。
- en: Internal storage methods
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部存储方法
- en: Let's begin with internal storage mechanisms on Android. For those with experience
    in standard Java programming, this section will come pretty naturally. Internal
    storage on Android simply allows you to read and write to files that are associated
    with each application's internal memory. These files can only be accessed by the
    application and cannot be accessed by other applications or by the user. Furthermore,
    when the application is uninstalled, these files are automatically removed as
    well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Android的内部存储机制开始。对于那些有标准Java编程经验的用户，这一部分会非常自然。Android上的内部存储允许你读取和写入与每个应用程序内部存储关联的文件。这些文件只能由应用程序访问，其他应用程序或用户无法访问。此外，当应用程序被卸载时，这些文件也会自动删除。
- en: 'The following is a simple example of how to access an application''s internal
    storage:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了如何访问应用程序的内部存储：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we simply use the `Context` class''s `openFileOutput()` method, which
    takes as its first argument the name of the file to be created (or overridden)
    and as its second argument the visibility of that file (just like with `SharedPreferences`,
    you can control the visibility of your files). It then converts the string we
    want to write to byte form and passes it into the output stream''s `write()` method.
    One thing to mention though is an additional mode that can be specified with `openFileOutput()`
    and that is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们简单使用了`Context`类的`openFileOutput()`方法，它第一个参数是待创建（或覆盖）的文件名，第二个参数是文件的可见性（与`SharedPreferences`类似，你可以控制文件的可见性）。然后它将我们想要写入的字符串转换为字节形式，并传递给输出流的`write()`方法。不过有一点需要提及，可以使用`openFileOutput()`指定一个额外的模式，即：
- en: '`MODE_APPEND:` This mode allows you to open an existing file and append a string
    to its existing contents (any other mode and the existing contents will be deleted)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_APPEND:` 这个模式允许你打开一个已存在的文件，并将字符串追加到其现有内容之后（使用其他任何模式，现有内容将被删除）'
- en: 'Furthermore, if you are programming in Eclipse, then you can go to the **DDMS**
    screen and look at your application''s internal files (amongst other things):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你在Eclipse中编程，那么你可以进入**DDMS**屏幕，查看应用程序的内部文件（以及其他内容）。
- en: '![Internal storage methods](img/8123OS_01_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![内部存储方法](img/8123OS_01_01.jpg)'
- en: 'And so we see the text file that we just created. For those developing with
    the terminal, the path for this would be `/data/data/{your-app-path}/files/ my_file.txt`.
    Now, unfortunately, reading back files is much more verbose and the code for how
    you would do that looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到刚刚创建的文本文件。对于那些在终端进行开发的用户，这个文件的路径会是`/data/data/{your-app-path}/files/my_file.txt`。不幸的是，读取文件要复杂得多，相应的代码如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we start by opening a file input stream instead and pass it into a stream
    reader. This will allow us to call the `read()` method and read in the data as
    bytes which we can then append to a `StringBuilder`. Once the contents have been
    read back fully, we simply return the String from the `StringBuilder` and voila!
    At the end, just for the sake of completeness, the `Context` class provides you
    with a simple method for deleting files saved in the internal storage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这里开始通过打开一个文件输入流，并将其传递给一个流阅读器。这将允许我们调用 `read()` 方法，将数据以字节的形式读取进来，然后我们可以将这些字节追加到一个
    `StringBuilder` 中。一旦完全读取回内容，我们只需从 `StringBuilder` 返回字符串，瞧！在最后，为了完整性起见，`Context`
    类为你提供了一个简单的删除保存在内部存储中的文件的方法。
- en: External storage methods
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部存储方法
- en: External storage, on the other hand, involves storing data and files to the
    phone's external **Secure Digital (SD)** card. The concept behind internal and
    external storage is similar, and so let's begin by laying down the pros and cons
    of this kind of storage versus what we saw earlier — that is, `SharedPreferences`.
    In a shared preference, there is much less overhead and so reading/writing to
    a simple `Map` object is much more efficient than reading/writing to a disk. However,
    because you are limited to simple primitive values (for the most part; again the
    most recent version of Android allows you to save sets of strings), you are essentially
    trading flexibility for efficiency. With internal and external storage mechanisms,
    you can save not only much bigger chunks of data (that is, entire XML files) but
    also much more complicated forms of data (that is, media files, image files, and
    so on).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，外部存储涉及将数据和文件保存到手机的外部**安全数字（SD）卡**。内部和外部存储背后的概念是相似的，因此让我们首先列举这种存储方式与之前看到的
    `SharedPreferences` 相比的优缺点。在共享偏好设置中，开销要小得多，因此读写简单的 `Map` 对象比读写磁盘要高效得多。然而，由于你基本上只能使用简单的原始值（大部分情况下；再次强调，最新版本的
    Android 允许你保存字符串集合），你实际上是在用灵活性换取效率。使用内部和外部存储机制，不仅可以保存更大的数据块（即整个 XML 文件），还可以保存更复杂的数据形式（即媒体文件、图像文件等）。
- en: Now, how about internal versus external storage? Well the pros and cons of these
    two are much more subtle. First, let's consider the amount of **storage space**
    (*memory*). Though this varies depending on the phone a user owns, the amount
    of internal memory can often be quite low, and it is not uncommon for even relatively
    new phones to have as low as 512 MB of internal storage. External storage, on
    the other hand, depends solely on what SD card the user has in their phone. Typically,
    if an SD card is present, then the amount of external storage can be many times
    greater than the amount of internal storage (depending on the size of the SD card,
    this can be as high as 32 GB of storage).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，内部与外部存储如何选择呢？这两种选择的优缺点要微妙得多。首先，让我们考虑一下**存储空间**（*内存*）。尽管这取决于用户拥有的手机，但内部存储空间通常可能非常有限，即使是相对较新的手机，内部存储空间也可能低至
    512 MB。而外部存储则完全取决于用户手机中的 SD 卡。通常，如果存在 SD 卡，那么外部存储空间可以是内部存储空间的许多倍（这取决于 SD 卡的大小，这可以达到
    32 GB 的存储空间）。
- en: Now, let's consider the **access speed** for internal versus external storage.
    Unfortunately, in this case, nothing conclusive can be drawn as the read and write
    speeds are highly dependent on the type of internal flash memory the phone uses,
    as well as the classification of the SD card for external storage. And so the
    last thing to consider is the *accessibility* of each type of storage mechanism.
    Again, for internal storage, the data is only accessible by your application,
    and so it is extremely safe from potentially malicious external applications.
    The con is that if the application is uninstalled, then that internal memory is
    wiped as well. For external storage, the visibility is inherently world readable
    and writeable, and so any files saved are exposed both to external applications
    as well as to the user. There is no guarantee then that your files will remain
    safe and uncorrupted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一下内部与外部存储的**访问速度**。不幸的是，在这种情况下，不能得出任何明确的结论，因为读写速度高度依赖于手机使用的内部闪存类型，以及外部存储的
    SD 卡的分类。因此，最后要考虑的是每种存储机制的*可访问性*。再次强调，对于内部存储，数据只能由你的应用程序访问，因此它非常安全，不受潜在恶意的外部应用程序的影响。缺点是，如果应用程序被卸载，那么内部存储空间也会被清除。对于外部存储，其可见性本质上是全球可读和可写的，因此保存的任何文件都会暴露给外部应用程序以及用户。这样就不能保证你的文件会保持安全和未被篡改。
- en: 'Now that we''ve flushed out some of the differences, let''s get back to the
    code and see how you can actually access the external SD card with this following
    example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经弄清楚了一些差异，让我们回到代码，看看你如何通过以下示例实际访问外部SD卡：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to execute the previous code, don't forget to add into your manifest
    file the `WRITE_EXTERNAL_STORAGE` permission. Here, we start by making a call
    to the `Environment` class's `getExternalStorageState()` method, which allows
    us to detect whether an external SD card is actually mounted and writeable. Trying
    to read or write to a file without performing these preliminary checks will cause
    an error to be thrown.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行之前的代码，不要忘记在你的清单文件中添加`WRITE_EXTERNAL_STORAGE`权限。这里，我们从调用`Environment`类的`getExternalStorageState()`方法开始，这允许我们检测外部SD卡是否实际已挂载且可写。在没有执行这些初步检查的情况下尝试读取或写入文件，将导致抛出错误。
- en: Once we know that an SD card is mounted and, indeed, writeable, then for those
    with API Levels 7 and below, we call `getExternalStorageDirectory()` to retrieve
    the file path to the root of the SD card. At this point, we simply need to create
    our new file and instantiate a `FileWriter` and `BufferedWriter` and write our
    string to the file. One thing to note here is that the method for writing to disk
    when dealing with external storage differs from our previous method for writing
    to disk with internal storage.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道SD卡已挂载并且确实可写，那么对于API级别7及以下，我们调用`getExternalStorageDirectory()`来获取到SD卡根目录的文件路径。在这一点上，我们只需要创建我们的新文件并实例化一个`FileWriter`和`BufferedWriter`，然后将我们的字符串写入文件。这里需要注意的是，处理外部存储时写入磁盘的方法与我们之前写入内部存储的磁盘方法不同。
- en: This is actually an important point to note and understand, which is why I place
    so much emphasis on these write methods. In the internal storage example, we obtained
    a `FileOutputStream` object by calling the `Context` class's `openFileOutput()`
    method, which took as its second argument a mode. When passing in `MODE_PRIVATE`,
    what happens behind the scenes is that each time a file is created and written
    to with that `FileOutStream`, that file is encrypted and signed with your application's
    unique ID (as mentioned earlier), so that external applications cannot access
    the contents of those files. However, remember that when creating and writing
    to files in *external storage*, by default they are created with no security enforcements,
    so any application (or user) can both read and write to those files. This is why
    you can use standard Java methods (for example, `FileWriter)` for writing to external
    SD cards, but not when writing to internal storage. One last thing to note is
    that just as you can see the newly created file in the **DDMS** perspective in
    Eclipse, assuming you have an SD card setup, you can just as easily see the newly
    created text file in **DDMS:**
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个需要注意和理解的重要点，这就是为什么我如此强调这些写入方法。在内部存储示例中，我们通过调用`Context`类的`openFileOutput()`方法获取`FileOutputStream`对象，该方法以模式作为第二个参数。当传入`MODE_PRIVATE`时，幕后发生的事情是，每次使用该`FileOutStream`创建和写入文件时，该文件都会用你的应用程序的唯一ID（如前所述）进行加密和签名，这样外部应用程序就无法访问这些文件的内容。然而，请记住，在*外部存储*中创建和写入文件时，默认情况下它们是没有安全强制的，所以任何应用程序（或用户）都可以读取和写入这些文件。这就是为什么你可以使用标准的Java方法（例如，`FileWriter`）来写入外部SD卡，但在写入内部存储时则不行。还需要注意的最后一件事是，正如你可以在Eclipse的**DDMS**视图中看到新创建的文件，假设你有SD卡设置，你也可以很容易地在**DDMS**中看到新创建的文本文件：
- en: '![External storage methods](img/8123OS_01_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![外部存储方法](img/8123OS_01_02.jpg)'
- en: So while developing your application, by leveraging this **DDMS** perspective
    you can quickly push, pull, and monitor files that you are writing to disk.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开发你的应用程序时，利用这个**DDMS**视角，你可以快速地推、拉和监控你写入磁盘的文件。
- en: With that said, I'll quickly mention some of the changes in writing to external
    storage that were introduced after API Level 8\. These changes are actually very
    well documented at [http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String)](http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，我会快速提及一些在API级别8之后引入的外部存储写入的变化。这些变化实际上在[http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String)](http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String))有很好的文档记录。
- en: 'But from a high level, in API Level 8 and above, we simply have two new primary
    methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但从高层次来看，在API级别8及以上，我们有两个新的主要方法：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You'll notice that for each of these methods you can now pass in a `type` parameter.
    These `type` parameters allow you to specify what kind of file yours is, so that
    it gets organized into the right subfolders. In the first method, the external
    file directory root that is returned is specific to your application, so that
    when your application is uninstalled all of those associated files are deleted
    from the external SD card as well. In the second method, the file directory root
    that is returned is a public one, so that files stored on these paths will remain
    persistent even when your application is uninstalled. Deciding which to use simply
    depends on the kind of file you are trying to save — for instance, if it's a media
    file that gets played in your application, then the user probably has no use for
    it if he/she decides to uninstall your application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，对于这些方法中的每一个，你现在可以传递一个`type`参数。这些`type`参数允许你指定你的文件类型，以便它们被组织到正确的子文件夹中。在第一个方法中，返回的外部文件目录根是特定于你的应用程序的，这样当你的应用程序被卸载时，与这些文件相关联的所有文件也会从外部SD卡上删除。在第二个方法中，返回的文件目录根是公共的，因此即使你的应用程序被卸载，保存在这些路径上的文件也会保持持久。决定使用哪个方法仅仅取决于你试图保存的文件类型
    — 例如，如果它是在你的应用程序中播放的媒体文件，那么如果用户决定卸载你的应用程序，他/她可能不再需要这个文件。
- en: 'However, say your application allows the user to download wallpapers for their
    phone: in this case, you might consider saving any image files to a public directory,
    so that even if the user uninstalls your application, those files will still be
    accessible by the system. The different `type` parameters that you can specify
    are:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你的应用程序允许用户为他们的手机下载壁纸：在这种情况下，你可能会考虑将任何图像文件保存到公共目录中，这样即使用户卸载了你的应用程序，这些文件仍然可以被系统访问。你可以指定的不同`type`参数有：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And so we wrap up our somewhat lengthy discussion on internal and external storage
    mechanisms and dive right into the even heftier topic of SQLite databases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们结束了关于内部和外部存储机制的略显冗长的讨论，并直接进入更厚重的SQLite数据库主题。
- en: SQLite databases
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite数据库
- en: Last, but not least, by far the most sophisticated and, arguably, the most powerful
    method for local storage is with SQLite databases. Each application is equipped
    with its own SQLite database, which is accessible by any class in the application,
    but not by any outside applications. Before moving on to complex queries or snippets
    of code, let me just give a quick summary of what SQLite databases are.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，迄今为止最复杂且可以说最强大的本地存储方法是使用SQLite数据库。每个应用程序都配备了其自己的SQLite数据库，该数据库可以被应用程序中的任何类访问，但不能被外部应用程序访问。在深入到复杂的查询或代码片段之前，让我简要概述一下SQLite数据库是什么。
- en: '**SQL (Structured Query Language)** is a programming language designed especially
    for managing data in *relational* databases. **Relational databases** allow you
    to submit insert, delete, update, and get queries, while also allowing you to
    create and modify schemas (more simply thought of as tables). **SQLite** then
    is simply a scaled-down version of MySQL, PostgreSQL, and other popular database
    systems. It is entirely self-contained and server-less, while still being transactional
    and still using the standard SQL language for executing queries. Because of how
    it''s self-contained and executable, it is extremely efficient, flexible, and
    accessible by a wide variety of programming languages across a wide variety of
    platforms (including our very own Android platform).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL（结构化查询语言）** 是一种专门为管理*关系型*数据库中的数据而设计的编程语言。**关系型数据库**允许你提交插入、删除、更新和获取查询，同时还可以让你创建和修改模式（简单来说就是表格）。**SQLite**
    就是MySQL、PostgreSQL和其他流行数据库系统的简化版。它完全自包含且无需服务器，同时仍然支持事务处理，并使用标准的SQL语言来执行查询。由于其自包含和可执行的特点，它非常高效、灵活，并且可以被各种编程语言在各种平台上访问（包括我们自己的Android平台）。'
- en: 'For now, let''s simply take a look at how we would instantiate a new SQLite
    database schema and create a very simple table with this code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何实例化一个新的SQLite数据库模式，并使用以下代码片段创建一个非常简单的表：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, the first thing we''ll notice is that in order to create a customizable
    database schema, we must override the `SQLiteOpenHelper` class. By overriding
    it, we can then override the `onCreate()` method, which will allow us to dictate
    the structure of the table. In our case, you''ll notice that we''re simply creating
    a table with two columns, an ID column and a name column. The query is equivalent
    to running the following command in SQL:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先会注意到，为了创建一个可定制的数据库架构，我们必须重写`SQLiteOpenHelper`类。通过重写它，我们可以接着重写`onCreate()`方法，这将允许我们指定表的结构。在我们的例子中，你会注意到我们只是创建了一个包含两列的表，一个ID列和一个name列。该查询等价于在SQL中运行以下命令：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You'll also see that the ID column has been designated as a `PRIMARY KEY` and
    given the `AUTOINCREMENT` property — this is actually recommended for all tables
    created in Android and we'll adhere to this standard going forward. Lastly, you'll
    see that the name column was declared a string type with maximum character length
    of `255` (for longer strings, we can simply type the column as a `LONGTEXT` type).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到ID列被指定为`PRIMARY KEY`并赋予了`AUTOINCREMENT`属性——这实际上是针对在Android中创建的所有表推荐的，我们将遵循这一标准。最后，你会看到name列被声明为字符串类型，最大字符长度为`255`（对于更长的字符串，我们可以简单地将列类型设置为`LONGTEXT`）。
- en: After overriding the `onCreate()` method, we also override the `onUpgrade()`
    method. This allows us to quickly and simply change the structure of our table.
    All you need to do is increment the `DATABASE_VERSION` integer and the next time
    you instantiate the `SQLiteHelper`, it will automatically call its `onUpgrade()`
    method, at which point we will first drop the old version of the database and
    then create the new version.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`onCreate()`方法之后，我们还重写了`onUpgrade()`方法。这让我们可以快速简单地改变表的结构。你需要做的是增加`DATABASE_VERSION`整数值，下次实例化`SQLiteHelper`时，它将自动调用其`onUpgrade()`方法，此时我们首先会删除旧版本的数据库，然后创建新版本。
- en: 'Finally, let''s take a quick look at how we would insert and query for values
    in our very basic, bare-bones table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速地看看如何在我们非常基础且简陋的表中插入和查询值：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Pay close attention to this example, as it will set the path for the next couple
    of chapters. In this example, we first instantiate our `SQLiteHelper` and obtain
    a writeable `SQLiteDatabase` object. We then introduce the `ContentValues` class,
    which is a very convenient wrapper method that allows you to quickly insert, update,
    or remove rows in your table. Here you''ll notice that since our ID column was
    created with the `AUTOINCREMENT` field, we don''t need to manually assign or increment
    our IDs when inserting rows. Thus, we only need to pass to the `ContentValues`
    object the non-ID fields: in our case just the name column.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细关注这个例子，因为它将为我们接下来的几章内容定下基调。在这个例子中，我们首先实例化我们的`SQLiteHelper`并获取一个可写的`SQLiteDatabase`对象。然后我们引入了`ContentValues`类，这是一个非常方便的包装方法，可以让你快速地在表中插入、更新或删除行。在这里你会注意到，由于我们的ID列是使用`AUTOINCREMENT`字段创建的，我们在插入行时不需要手动分配或增加ID。因此，我们只需要将非ID字段传递给`ContentValues`对象：在我们的例子中，只需传递name列。
- en: Afterwards, we go back to our `SQLiteDatabase` object and call its `insert()`
    method. The first argument is simply the name of the database, and the third argument
    is the `ContentValue` we just created. The second argument is the only *tricky*
    one — basically, in the event that an empty `ContentValue` is passed in, because
    a SQLite database cannot insert an empty row, whatever column is passed in as
    the second argument, the SQLite database will automatically set the value of that
    column to `null`. By doing so, we can better avoid SQLite exceptions from being
    thrown.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们回到`SQLiteDatabase`对象，并调用其`insert()`方法。第一个参数仅仅是数据库名称，第三个参数是我们刚刚创建的`ContentValue`。第二个参数是唯一一个有点*棘手*的参数——基本上，如果传递了一个空的`ContentValue`，因为SQLite数据库不能插入空行，所以无论作为第二个参数传递的列是什么，SQLite数据库都会自动将那个列的值设置为`null`。通过这样做，我们可以更好地避免抛出SQLite异常。
- en: 'Additionally, we can insert rows into our database by just passing in a raw
    SQL query, as shown in the second method, to the `execSQL()` method. Lastly, now
    that we''ve inserted two rows into our table, let''s practice getting and reading
    these rows back. Here I show two methods as well — the first is by using the `SQLiteDatabase`
    helper method `query()`, and the second is by executing a raw SQL query. In both
    cases, a `Cursor` object is returned, which you can think of as an iterator over
    the rows of the sub-table that is returned by your query:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过向`execSQL()`方法传递原始SQL查询（如第二个方法所示）来向数据库中插入行。最后，既然我们已经向表中插入了两个行，让我们练习获取和读取这些行。这里我展示了两种方法——第一种是使用`SQLiteDatabase`帮助方法`query()`，第二种是执行原始SQL查询。在这两种情况下，都会返回一个`Cursor`对象，您可以将其视为对由您的查询返回的子表行的迭代器：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we have the desired `Cursor`, the rest is straightforward. Because the
    `Cursor` behaves like an iterator, in order to retrieve each row we need to throw
    it into a `while` loop, and in each loop, we move the cursor down one row. Then,
    within the `while` loop we get the column indices of the columns we want to pull
    data from: in our case, let''s just get both columns, though in practice often
    times you''ll only want data from specific columns at any given time. Finally,
    pass these column indices into the proper `get()` methods of `Cursor` — namely,
    if the type of the column is an integer, then call the `getInt()` method; if it
    is a string, then call the `getString()` method, and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了所需的`Cursor`，其余部分就非常直接了。因为`Cursor`的行为类似于迭代器，为了检索每一行，我们需要将其放入一个`while`循环中，并在每次循环中将游标向下移动一行。然后，在`while`循环中，我们获取我们想要从中提取数据的列的列索引：在我们的例子中，让我们获取两列，尽管实际上很多时候您只想在特定时间从特定列获取数据。最后，将这些列索引传递给`Cursor`的正确`get()`方法——具体来说，如果列的类型是整数，则调用`getInt()`方法；如果是字符串，则调用`getString()`方法，依此类推。
- en: But again, what we see here are simply the building blocks leading up to a wealth
    of tools and weapons that will soon be at our disposal. Soon we'll look at how
    we can write various wrapper methods to simplify our lives when developing large-scale
    applications, as well as dig further into the various methods and parameters the
    `SQLiteDatabase` class provides us with.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次强调，我们现在看到的仅仅是通往丰富工具和武器库的基石。很快，我们将会探讨如何编写各种包装方法，以便在开发大型应用程序时简化我们的生活，同时进一步深入挖掘`SQLiteDatabase`类提供给我们的各种方法和参数。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this first chapter, we accomplished a lot. We started off by looking at the
    simplest and most efficient data storage method of them all — the `SharedPreferences`
    class. We looked at the pros and cons of using a `SharedPreferences` object in
    your application, and though the class itself is limited to storing primitive
    data types, we saw that its use cases are plenty.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们完成了很多工作。我们从最简单、最高效的数据存储方法——`SharedPreferences`类开始讲起。我们探讨了在应用程序中使用`SharedPreferences`对象的优缺点，尽管这个类本身仅限于存储基本数据类型，但我们看到了它的使用场景非常丰富。
- en: Then, we moved up a little in complexity and examined both internal and external
    storage mechanisms. Though not as intuitive and efficient as a shared preference
    object, by leveraging internal and external storage, we are capable of storing
    both much more data and much more complex data (that is, images, media files,
    and so on). The pros and cons of using internal storage versus external storage
    are much more subtle and many times are highly phone and hardware dependent. But
    in any case, this goes to illustrate my earlier point that part of mastering data
    on Android is being able to analyze the pros and cons of every storage method
    and intelligently decide the most suitable method for your application's needs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提高了一点复杂性，并研究了内部和外部存储机制。虽然它们不如共享偏好对象直观和高效，但通过利用内部和外部存储，我们能够存储更多的数据以及更复杂的数据（即图片、媒体文件等）。使用内部存储与外部存储的优缺点更为微妙，很多时候它们高度依赖于手机和硬件。但无论如何，这都说明了我早先的观点：掌握Android上的数据部分，就是要能够分析每种存储方法的优缺点，并明智地选择最适合应用程序需求的方法。
- en: Finally, we dipped our toes into SQLite databases and looked at how you can
    override the `SQLiteOpenHelper` class to create your custom SQLite database and
    table. From there we saw an example of how to open and retrieve this SQLite database
    from an `Activity` class, and subsequently, how to both insert into and retrieve
    rows from our table. Because of the flexibility of the `SQLiteDatabase` class,
    we saw that there were multiple ways for both inserting and retrieving data, allowing
    those less familiar with SQL to utilize the wrapper methods, while allowing those
    SQL aficionados to flex their querying prowess by executing raw SQL commands.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们初步探索了SQLite数据库，并了解了如何重写`SQLiteOpenHelper`类以创建自定义的SQLite数据库和表。从那里，我们看到了一个示例，演示了如何从`Activity`类打开和检索SQLite数据库，以及如何向表中插入和检索行。由于`SQLiteDatabase`类的灵活性，我们了解到插入和检索数据有多种方法，这让那些不太熟悉SQL的人可以使用包装方法，同时也让那些SQL爱好者通过执行原始SQL命令来展示他们的查询能力。
- en: In the next chapter, we'll focus on SQLite databases, and attempt to build a
    much more complex, yet realistic, database schema.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注SQLite数据库，并尝试构建一个更为复杂但现实的数据库架构。
