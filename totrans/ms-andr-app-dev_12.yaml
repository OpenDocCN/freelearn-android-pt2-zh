- en: Chapter 12. Monetization, the Build Process, and Release
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十二章. 营收化、构建过程和发布
- en: This is the final chapter of the book; what we have left to do is monetize our
    app, generate different versions of it, and release and upload it to Play Store.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章；我们需要完成的是实现应用的盈利化，生成不同的版本，并将其发布和上传到Play商店。
- en: We will complete the build process by creating different build types and generating
    paid versions of the app without advertisements and a free version with advertisements.
    All of this will be in the same project but will be exported as two different
    apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建不同的构建类型来完成构建过程，并生成不带广告的付费版本和带广告的免费版本的应用。所有这些都在同一个项目中，但将作为两个不同的应用导出。
- en: Once the build process is finished, we will start implementing the advertisements
    and explain key points about advertisement monetization; this will make it possible
    to generate revenue using our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建过程完成，我们将开始实施广告，并解释关于广告盈利的关键点；这将使我们的应用能够产生收入。
- en: At the end, we will release the app and create an APK file of our APK signed
    with a release certificate, obfuscating the code so that it can be decompiled.
    We will upload it to Play Store and explain the key points to keep in mind during
    an app's publication.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将发布应用，并使用发布证书对我们的APK进行签名，混淆代码以防止被反编译。我们将上传到Play商店，并介绍在应用发布过程中需要注意的关键点。
- en: Build variants
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建变体
- en: Monetization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营收化
- en: Key points of advertisement monetization
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广告盈利的关键点
- en: Adding advertisements
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加广告
- en: Releasing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布
- en: Obfuscating and signing
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混淆和签名
- en: Exporting with Gradle
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle导出
- en: Uploading to Play Store
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传到Play商店
- en: Using build variants
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建变体
- en: 'To explain how monetization with advertisements works on Android, we will add
    advertisements to our application, but before this, we will set up a build process
    that allows us to export two versions: the paid version and the free version.
    This strategy is commonly used in Play Store (having a free version with advertisements
    and a paid version without advertisements) so that all users can use the app for
    free, but the users that don''t like advertisement and want to contribute with
    your app can always buy the paid version.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释在Android上通过广告实现盈利的机制，我们将在应用中添加广告，但在这一步之前，我们会设置一个构建过程，允许我们导出两个版本：付费版本和免费版本。这种策略在Play商店中很常见（提供一个带有广告的免费版本和一个不带广告的付费版本），这样所有用户都可以免费使用该应用，但不喜欢广告并希望支持应用的用户可以选择购买付费版本。
- en: 'There is a second way of implementing this strategy, which is creating just
    one version and having the option of buying an add-on to remove the advertisements
    inside the app with In-App billing products. The downside of this way is that
    your app won''t be listed in Play Store as a free app; it will be listed under
    "Offers in-App purchases", so there might be users who aren''t comfortable with
    this or children that are not allowed by their parents to have paid apps or apps
    including payments. The second problem is that In-App billing is not easy to implement;
    the process is very complex with many steps involving setting up the service,
    creating the products in Play Store, consuming these products from the app, and
    setting up a test environment, where we can test the purchases without incurring
    charges. To show the build variants, we can navigate to **View** | **Tool Windows**
    | **Build Variants** or click on **Build Variants** in the left-hand side bar
    of Android Studio:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一策略还有第二种方法，即只创建一个版本，并在应用内提供购买附加组件以移除广告的选项，通过应用内购买产品来实现。这种方式的缺点是，您的应用在Play商店中不会列为免费应用；它会被归类为“提供应用内购买”，因此可能有些用户对此感到不适应，或者家长不允许孩子使用付费应用或包含支付的应用。第二个问题是应用内购买不容易实现；这个过程非常复杂，涉及许多步骤，包括设置服务、在Play商店中创建产品、从应用中消费这些产品，以及设置一个测试环境，我们可以在不产生费用的前提下测试购买。
- en: '![Using build variants](img/B04887_12_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用构建变体](img/B04887_12_01.jpg)'
- en: Build variants are a combination of build types and product flavors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构建变体是构建类型和产品风味的组合。
- en: 'If we have the build types, `A` and `B`, and product flavors, `1` and `2`,
    the outcome will be the following build variants:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有构建类型 `A` 和 `B`，以及产品风味 `1` 和 `2`，那么结果将产生以下构建变体：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To understand this better, we can see what build types and build flavors are
    and how to create them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们可以了解构建类型和构建风味是什么，以及如何创建它们。
- en: Creating build types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建类型
- en: A build type allows us to configure the packaging of an app for debugging or
    release purposes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建类型允许我们为调试或发布目的配置应用程序的打包。
- en: 'Let''s start by taking a look at our `build.gradle` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们的`build.gradle`文件：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `build.gradle`, we can see that the build type release has two properties,
    which we will explain at the end of the chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`文件中，我们可以看到发布构建类型有两个属性，我们将在本章末尾解释它们。
- en: 'By default, we have two build types: **debug** and **release**. Even if we
    don''t see the debug build type, all the variants will be generated in release
    and debug mode.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们有两种构建类型：**调试（debug）**和**发布（release）**。即使我们没有看到调试构建类型，所有变体也将在发布和调试模式下生成。
- en: 'We can create more build types with different parameters; some of the parameters
    we can use are to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建更多具有不同参数的构建类型；我们可以使用的参数之一是：
- en: Sign the configuration
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名配置
- en: Debug the signing flag
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试签名标志
- en: Change the version name or package name suffix
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改版本名称或包名后缀
- en: This means that we can have different types signed with different certificates
    with the debug mode enabled or false and with a different package name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用不同类型的证书来启用或禁用调试模式，并且可以有不同的包名。
- en: The build type is not intended to create a different version of our app, such
    as demo or full, free or paid, and so on. For this, we have product flavors. Every
    build type is applied to every build flavor, creating a build variant as we saw
    before.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建类型并不是用来创建我们应用程序的不同版本，比如演示版或完整版，免费或付费等等。为此，我们有产品风味。每个构建类型都应用于每个构建风味，就像我们之前看到的，创建一个构建变体。
- en: Product flavors
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品风味
- en: 'We will create two product flavors and declare them in `build.gradle` using
    the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个产品风味，并在`build.gradle`中使用以下代码声明它们：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have a paid flavor, which is the app without advertisements, and a flavor
    called *free*, which is the free version with advertisements. For each product
    flavor, we can create a folder at the `../src/` level of our project. We don't
    need a folder for our paid version as it will be main by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个付费风味，这是没有广告的应用程序，还有一个名为*免费（free）*的风味，这是带有广告的免费版本。对于每个产品风味，我们可以在项目的`../src/`级别创建一个文件夹。我们的付费版本默认是主要的，所以不需要为其创建文件夹。
- en: '![Product flavors](img/B04887_12_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![产品风味](img/B04887_12_02.jpg)'
- en: This way, we can have different classes and resources for each build, even a
    different `AndroidManifest.xml` file. Our app will share the common code between
    the paid and the free versions in the `main` folder, with a specific code for
    ads in the `free` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以为每个构建版本使用不同的类和资源，甚至可以有不同的`AndroidManifest.xml`文件。我们的应用程序将在`main`文件夹中共享付费版本和免费版本的通用代码，在`free`文件夹中包含特定于广告的代码。
- en: 'To switch between the different versions, we can simply change the dropdown
    in the build variant window, as in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的版本之间切换，我们只需更改构建变体窗口中的下拉菜单，如下面的屏幕截图所示：
- en: '![Product flavors](img/B04887_12_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![产品风味](img/B04887_12_03.jpg)'
- en: Once a build variant is selected, we can either run the app or export it, and
    it will run or export the selected flavor accordingly. These can be configured
    to have a different package name and a different version name.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个构建变体后，我们可以运行应用程序或导出它，相应地运行或导出所选的风味。这些可以配置为具有不同的包名和不同的版本名称。
- en: Now, we will take a look at how to add a specific code to the free version that
    won't be included in the main paid version.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何向免费版本添加特定代码，这些代码不会包含在主付费版本中。
- en: Monetization in Android
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓应用的货币化
- en: We will describe the three common ways to earn money through an application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述通过应用程序赚钱的三种常见方式。
- en: Firstly, we can sell the application for a price in Play Store. There are some
    cases where charging for your app makes more sense than providing a free app with
    adverts or in-app products. If you create an app with big value for a small amount
    of users, you should definitely think about this option. For instance, if we were
    to release an app to professionally design houses for architects, we would know
    that our app will not be downloaded by millions of users; it's for a specific
    and targeted audience looking for quality software. We won't make enough profit
    with advertisements and our users will be keen to pay a good amount for software
    that makes their job easier. There is always a risk in asking for the money up
    front; even if the user has the option to obtain a refund for the app, he/she
    might not be attracted enough to try it. That is why we should consider the second
    model.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在Play Store中为应用程序定价销售。在某些情况下，为你的应用收费比提供带有广告或应用内产品的免费应用更有意义。如果你为少数用户创造了具有大价值的应用，你绝对应该考虑这个选项。例如，如果我们发布一个为建筑师专业设计房屋的应用，我们会知道我们的应用不会被数百万用户下载；它是针对寻求高质量软件的特定目标受众。我们无法通过广告获得足够的利润，而我们的用户将愿意为使他们的工作更轻松的软件支付一笔不错的费用。要求用户预先支付费用总是存在风险的；即使用户可以选择退还应用，他/她可能也不够吸引人去尝试。这就是为什么我们应该考虑第二种模式。
- en: The second option is known as a **freemium** model. We release a free app but
    include in-app purchases in it. Applied to the same example of an app to design
    houses, we could offer three designs for free so that when the user is comfortable
    with our product, we can ask him/her to purchase a one-time license or a subscription
    to continue using the app. It's very common in games, where you can purchase items
    for your character. It is in games where we can see how this model can also be
    combined with the third model to get the maximum revenue possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式被称为**免费增值**模式。我们发布一个免费的应用程序，但其中包括应用内购买。同样以设计房屋的应用为例，我们可以提供三种免费设计，以便当用户对我们的产品感到满意时，我们可以要求他/她购买一次性许可或订阅以继续使用该应用。这在游戏中非常常见，你可以为你的角色购买物品。正是在游戏中，我们可以看到这个模式也可以与第三种模式结合以获得尽可能最大的收益。
- en: The third model of monetization is the **advertisement model**; we place adverts
    in our apps, and when the user clicks on them, we get revenue. We can use different
    types of advertisements—from full screen advertisements to small banners at the
    bottom. We'll focus on this model. Implementing it is easier than you can imagine.
    But before implementing it, we need to explain what terms such as **CPC** (**Cost
    Per Click**), **CTR** (**Click Through Rate**), fill rate, and so on mean, which
    will help us choose a good advertisement platform and provider. This is also necessary
    to understand the metrics and be able to read the charts to know how the advertisements
    in your app are performing. Having advertisements in different places can change
    the revenue; however, we need to maximize the revenue without annoying the user.
    If we offer the user the option to remove advertisements for a small amount of
    money with an in-app product or with a paid version without advertisements, we
    can increase the number of advertisements. It's best for the user if they know
    that they have a choice. If they choose to live with the advertisements, it's
    their decision, and it won't annoy them as much as if we placed a lot of advertisements
    without the option to remove them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 盈利化的第三种模式是**广告模式**；我们在应用中放置广告，当用户点击它们时，我们获得收入。我们可以使用不同类型的广告——从全屏广告到底部的小横幅。我们将关注这个模式。实施它比你想象的要容易。但在实施之前，我们需要解释诸如**CPC**（**每次点击成本**）、**CTR**（**点击通过率**）、填充率等术语，这将帮助我们选择一个好的广告平台和提供商。这对于理解指标并能够阅读图表以了解应用中的广告表现也是必要的。在不同的地方放置广告可能会改变收入；然而，我们需要在不烦扰用户的情况下最大化收入。如果我们为用户提供以小额费用通过应用内产品或无广告的付费版本移除广告的选项，我们可以增加广告的数量。如果用户知道他们有选择，这对他们来说是最好的。如果他们选择与广告共存，这是他们的决定，它不会像我们在没有移除选项的情况下放置大量广告那样让他们感到烦恼。
- en: Key points in advertisement monetization
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广告盈利化的关键点
- en: We will explain the basics to understand how advertisement monetization works.
    There are a few concepts in the business with abbreviations that can be confusing
    at first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释理解广告盈利化如何运作的基础知识。在这个业务中有一些带有缩写的概念，初学者可能会感到困惑。
- en: 'Once we register with an advertisement platform, we will see a reports page
    with stats about our app. Here is an example of the dashboard from the advertisement
    network, `AdToApp`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在广告平台上注册，我们就会看到一个关于我们应用的统计数据报告页面。以下就是来自广告网络`AdToApp`的仪表板示例：
- en: '![Key points in advertisement monetization](img/B04887_12_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![广告盈利的关键点](img/B04887_12_04.jpg)'
- en: Here, we can see requests, fill rate, impressions, clicks, CTR, eCPM, and revenue.
    Let´s consider each of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到请求、填充率、展示量、点击量、CTR、eCPM和收入。让我们逐一考虑它们。
- en: Requests mean the number of times our app asked the advertisement network for
    an advert. For instance, if we decide to add a full screen advertisement at the
    start of our app, every time we start the app, there will be a request to the
    server to get back an advertisement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请求是指我们的应用向广告网络请求广告的次数。例如，如果我们决定在应用开始时添加一个全屏广告，那么每次启动应用时，都会向服务器发送一个请求以获取广告。
- en: We don't have the advertisement inside our app; what we have is a placeholder,
    a frame, and an `AdView`, which will be filled with content provided by the advertisement
    network. Sometimes, the advertising network doesn't have an ad for us at the moment
    of the request, which is why the next concept is important.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用中并没有实际的广告；我们拥有的是一个占位符、一个框架和一个`AdView`，它将由广告网络提供的内容填充。有时，在请求时刻广告网络可能没有广告给我们，这就是下一个概念重要的原因。
- en: Fill rate is a percentage derived by the amount of delivered ads divided by
    the amount of requested ads. For instance, if we start our app ten times and only
    get back adverts five times, we will have a fill rate of 50 percent. What we want
    in a good ad network is a fill rate of 100 percent. We want to show as many ads
    as possible and with a good CPC.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 填充率是通过已投放广告数量除以请求广告数量得出的百分比。例如，如果我们启动应用十次，只收到五次广告返回，那么我们的填充率就是50%。在一个好的广告网络中，我们希望填充率是100%。我们希望展示尽可能多的广告，并且有好的CPC。
- en: CPC, or cost per click, is how much we earn each time a user clicks on an advertisement
    in our app; the higher it is, the most revenue we get. The advertiser determines
    the CPC for an advertisement. Some advertisers may be willing to pay more per
    click than others.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CPC，即每次点击成本，是指用户在我们的应用中每次点击广告时我们能赚到的钱；这个数值越高，我们获得的收入越多。广告商决定广告的CPC。一些广告商可能愿意为每次点击支付更多的费用。
- en: Many clicks with low CPC is not necessarily better than a few clicks with high
    CPC. That's why the quality of the advertisements that we have is important.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 许多低CPC的点击并不一定比少数高CPC的点击更好。这就是为什么我们拥有的广告质量很重要。
- en: Impressions are how many times an advertisement is shown to the user. In the
    previous example, with ten advertisement requests and five failed, we would have
    five impressions. Impressions don't generate revenue if the user doesn't click
    on them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 展示量是指广告向用户展示的次数。在之前的例子中，如果有十次广告请求，其中五次失败，我们就会有五次展示量。如果用户没有点击，展示量不会产生收入。
- en: Clicks are the number of times a user clicks on an advertisement. This is what
    generates the revenue based on the CPC. So, five clicks with a 0.5$ CPC will generate
    5x0.5, which is 2.5$.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 点击量是指用户点击广告的次数。这是基于CPC产生收入的部分。因此，五次点击，每次点击0.5美元，将会产生5x0.5，即2.5美元。
- en: CTR, or click through rate, is the percentage given by the amount of clicks
    that your app receives divided by the amount of impressions. If we have 100 advertisements
    and one click, our CTR will be 1 percent. This amount is generally under 5 percent;
    users don't click on every advertisement they see, and you could have problems
    with an advertisement platform, such as **Admob**, cancelling your account and
    payments if they believe you are cheating by forcing the user to click on the
    advertisement. Let's say that we show a dialog at the start of our app and ask
    the user to click on an advertisement to continue using our app. This will basically
    give us 100 percent CTR; for every impression, there will be a click, and this
    is not allowed. We can't, under any circumstances, promote a click.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CTR，即点击通过率，是通过点击量除以展示量得出的百分比。如果我们有100次广告展示并获得一次点击，我们的CTR将是1%。这个数值通常在5%以下；用户不会点击他们看到的每一个广告，如果你通过强制用户点击广告来作弊，比如**Admob**这样的广告平台可能会取消你的账户和支付。假设我们在应用开始时显示一个对话框，要求用户点击广告以继续使用我们的应用。这将基本上给我们带来100%的CTR；每次展示都会有点击，这是不允许的。在任何情况下，我们都不可以推广点击。
- en: Advertisement providers want their advertisement to be seen by someone interested
    in it; they don't want to pay for the click of a person not interested in their
    advertisement, who will close it after a second. It could be that you have a high
    CTR because you have a good spot in your app and the advertisements are of interest
    to every user. If this happens, you will have to explain to your advertisement
    network, or some, such as **Admob**, will shut down your account. But we shouldn't
    be too unfair to them; they do this because they have found a lot of people trying
    to break the rules, and such a massive company can't focus on individuals, so
    they need to have objective filters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 广告提供商希望他们的广告能被对其感兴趣的人看到；他们不希望为那些对广告不感兴趣、一秒钟后就会关闭广告的人的点击付费。可能的情况是，你有一个高的点击率（CTR），因为你在应用中有一个好的广告位置，而且每个用户都对广告感兴趣。如果发生这种情况，你将不得不向你的广告网络解释，或者像**Admob**这样的广告网络可能会关闭你的账户。但我们也不应该对他们太不公平；他们这样做是因为他们发现很多人试图破坏规则，这样一个庞大的公司无法专注于个人，所以他们需要有客观的筛选机制。
- en: Other advertisement network companies are more flexible with this; they usually
    assign an agent to you, who you can contact frequently on Skype or e-mail, and
    in case of any problem, they usually let you know.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其他广告网络公司在这方面更加灵活；他们通常会为你分配一个代理人，你可以通过Skype或电子邮件频繁联系他，如果遇到任何问题，他们通常会通知你。
- en: eCPM stands for "effective cost per thousand impressions". It is calculated
    by dividing the total earnings by the total number of impressions in thousands.
    This is basically a quick way of knowing how good you are doing just by looking
    at a number—very useful to compare advertisement networks. It's a number usually
    between $0 and 3$.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: eCPM代表“每千次展示的有效成本”。它是通过将总收入除以总展示次数（以千为单位）来计算的。这基本上是通过一个数字快速了解你表现如何的方法——非常有助于比较广告网络。这个数字通常在$0到3$之间。
- en: We need to consider that this does not include the fill rate. It is the cost
    per thousand impressions and not per thousands requests. A three dollar eCPM with
    a 50 percent fill rate is the same as one and a half dollar eCPM with 100 percent
    fill rate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的是，这并不包括填充率。它是每千次展示的成本，而不是每千次请求的成本。一个50%填充率的三美元eCPM与100%填充率的一块半美元eCPM是相同的。
- en: What makes an advertisement network good is a high fill rate with a high eCPM.
    We need both to be high; adverts with expensive clicks and not enough fill rates
    won't produce any revenue because they simply won't be shown.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使一个广告网络变得优秀的是高填充率和高eCPM。我们需要这两个指标都高；如果点击费用昂贵但填充率不足，广告将不会产生任何收入，因为它们根本不会被展示。
- en: 'The guys from **AdToApp** created a good graphic explaining this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**AdToApp**的团队制作了一张很好的图来解释这一点：'
- en: '![Key points in advertisement monetization](img/B04887_12_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![广告盈利的关键点](img/B04887_12_05.jpg)'
- en: This graphic represents what we have been talking about; a premium advertisement
    network with a very high eCPM and a low fill rate is represented as a tall but
    empty building with the lights off.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了我们一直在讨论的内容；一个高eCPM但低填充率的优质广告网络被表现为一座高但空荡荡、灯光熄灭的大楼。
- en: We are finished with the theory, and we can start integrating an advertisement
    solution; in this case, we will choose AdToApp.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理论部分我们已经讲完了，现在可以开始集成广告解决方案了；在这种情况下，我们将选择AdToApp。
- en: Adding advertisements with AdToApp
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AdToApp添加广告
- en: There is no way to know which advertisement provider is better for you; the
    best you can do is to try different ones and have a look at the stats.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法知道哪个广告提供商更适合你；你能做的最好的事情就是尝试不同的广告提供商，并查看统计数据。
- en: From experience, we like to use AddToApp because apart from the good delivery
    results, it's really easy to integrate, and it can be included in your app even
    if you have another network. Therefore, it's really easy to measure its performance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，我们喜欢使用AddToApp，除了因为它良好的投放效果外，它的集成过程非常简单，即使你的应用中已经有其他网络广告，也可以轻松加入。因此，衡量其性能真的很容易。
- en: It's ideal to use in this book with `MasteringAndroidApp` as it allows us to
    use different types of advertisements, full screen advertisements, banners, videos,
    and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中使用它与`MasteringAndroidApp`非常合适，因为它允许我们使用不同类型的广告，包括全屏广告、横幅、视频等等。
- en: There are mediators for more than 20 different advertisement networks, so including
    their SDK, we will have access to plenty of advertisements with a high fill rate
    guaranteed. Regarding their eCPM, they analyze which network is giving better
    results for you; so, if they can deliver advertisements from multiple networks,
    they will deliver the ones with better results.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有超过20个不同广告网络的调解器，因此包含他们的SDK，我们将能够访问许多保证高填充率的广告。关于他们的eCPM，他们会分析哪个网络能为你带来更好的结果；因此，如果他们可以从多个网络投放广告，他们将投放效果更好的广告。
- en: '![Adding advertisements with AdToApp](img/B04887_12_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![通过AdToApp添加广告](img/B04887_12_06.jpg)'
- en: We can start creating an account at [https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow](https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始创建一个账户，地址是[https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow](https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow)。
- en: Once the account is created, we will create an app using the package name of
    our app.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，我们将使用我们应用的包名创建一个应用。
- en: '![Adding advertisements with AdToApp](img/B04887_12_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![通过AdToApp添加广告](img/B04887_12_07.jpg)'
- en: We will click on the SDK button to download their SDK and get configuration
    values for the integration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将点击SDK按钮以下载他们的SDK并获得集成配置值。
- en: '![Adding advertisements with AdToApp](img/B04887_12_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![通过AdToApp添加广告](img/B04887_12_08.jpg)'
- en: The integration is straightforward; the SDK will contain an `AdToAppSDK.jar`
    file, which we need to copy into `libs`. We need to add Google Play Services in
    `build.gradle` and the support library *v7*, but we already have this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 集成非常直接；SDK将包含一个`AdToAppSDK.jar`文件，我们需要将其复制到`libs`目录中。我们还需要在`build.gradle`中添加Google
    Play服务和支持库*v7*，但我们已经有了这些。
- en: 'We need to add the basic permissions to the manifest, which we already have
    as well, using the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在清单中添加基本权限，我们已经有这些了，使用以下代码：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need to add extra mandatory assets in the manifest, which can be copied
    from the same website; it contains the keys of our account. You can find them
    under the first section, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在清单中添加额外的必要资源，可以从同一网站复制，它包含我们账户的密钥。你可以在以下截图所示的第一部分找到它们：
- en: '![Adding advertisements with AdToApp](img/B04887_12_09.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![通过AdToApp添加广告](img/B04887_12_09.jpg)'
- en: 'Lastly, we can take a look at how to implement **Interstitials & Banners**
    or rewarded ads. Rewarded advertisements are the type of advertisements that pop
    up in a game and say, *Watch this video and get (gold, gems, and so on)*. The
    viewing of these advertisements is totally up to the users if they want the reward:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看看如何实现**插屏广告和横幅广告**或激励广告。激励广告是游戏中弹出的一种广告，提示*观看此视频并获得（金币、宝石等）*。是否观看这些广告完全取决于用户是否想要奖励：
- en: '![Adding advertisements with AdToApp](img/B04887_12_10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![通过AdToApp添加广告](img/B04887_12_10.jpg)'
- en: If we choose interstitials and banners, we need to initialize them depending
    on whether we want only video advertisements, only images (banners), or both images
    and videos in an interstitial.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择插屏广告和横幅广告，我们需要根据是否只需要视频广告、只需要图片（横幅）广告，或者插屏中同时需要图片和视频广告来初始化它们。
- en: In the website, depending on the type of advert you want, the necessary code
    will be shown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站上，根据你想要的广告类型，将显示必要的代码。
- en: The SDK is really flexible; we can go further and set callbacks to know when
    the banners were loaded and clicked on. This allows us to track the number of
    clicks in our advertisements and verify that they are the same as in the AdToApp
    console, making the process transparent.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SDK非常灵活；我们可以更进一步，设置回调以了解横幅广告何时加载和点击。这使我们能够跟踪广告中的点击次数，并验证它们与AdToApp控制台中的是否相同，从而使过程透明化。
- en: If we need extra help, we can activate logs in the SDK, which will inform us
    in case of any problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要额外的帮助，我们可以在SDK中激活日志，它将在出现任何问题时通知我们。
- en: Now, remember the good practices we mentioned at the start of the section about
    maximizing the number of advertisements without disturbing the user too much and
    implementing them in your app to start getting revenue!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住我们在本节开始时提到的最佳实践，即最大化广告数量而不过多打扰用户，并在你的应用中实施这些实践，开始获得收益！
- en: '![Adding advertisements with AdToApp](img/B04887_12_11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![通过AdToApp添加广告](img/B04887_12_11.jpg)'
- en: Releasing our app to Play Store
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用发布到Play商店
- en: Finally, our app is ready! This is the best moment while developing a new app;
    it is time to upload it to Play Store, get feedback from users, and hopefully
    get thousands of downloads.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的应用准备好了！这是开发新应用时最棒的瞬间；是时候将其上传到Play商店，获取用户的反馈，并希望获得成千上万的下载量。
- en: We need to export the app to an APK file; in order to be uploaded to Play Store,
    it has to be signed with a release certificate. This point is very important;
    once an application is signed with a certificate, if we upload it to Play Store
    and want to upload a new version in the future, it has to be signed with the same
    certificate.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将应用导出为APK文件；为了上传到Play商店，它必须使用发布证书进行签名。这一点非常重要；一旦应用程序用证书签名，如果我们将其上传到Play商店，并在将来想要上传新版本，它必须使用相同的证书进行签名。
- en: This certificate will be created by us during the release process. It needs
    an alias and a password, so ensure that you remember these details and save the
    certificate file in a safe place. Otherwise, say your app gets good ratings and
    a good number of downloads, and you want to update the version, but you don't
    have your certificate or have forgotten the password. In this case, you won't
    be able to update, you will have to upload a new app with a different package
    name, and it will start with zero downloads and zero ratings.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在发布过程中会创建这个证书。它需要一个别名和密码，请确保你记住这些细节并将证书文件保存在安全的地方。否则，假设你的应用得到了好的评分和大量的下载，当你想要更新版本时，如果没有证书或忘记了密码，那就无法更新。在这种情况下，你不得不以上传一个具有不同包名的全新应用，并且从零下载和零评分开始。
- en: Code obfuscation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码混淆
- en: Another important thing to take into consideration while releasing the app is
    code obfuscation. If we export the app without obfuscating the code, anyone can
    download the APK and decompile it, allowing them to see your code, which can be
    a security problem if you have Parse IDs, server access details, a GCM project
    number, and so on in it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布应用时，还需要考虑的另一个重要事项是代码混淆。如果我们导出应用而不混淆代码，任何人都可以下载APK并反编译它，使他们能够看到你的代码，如果其中有
    Parse IDs、服务器访问细节、GCM项目编号等，这可能会成为安全问题。
- en: We can obfuscate the code using **Proguard**. Proguard is a tool included in
    the Android build system. It obfuscates, shrinks, and optimizes the code, removing
    unused code and renaming classes, fields, and methods to prevent reverse engineering.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **Proguard** 来混淆代码。Proguard 是 Android 构建系统中包含的一个工具。它混淆、缩小和优化代码，移除未使用的代码，并重命名类、字段和方法，以防止逆向工程。
- en: Beware of this renaming of classes and methods; it can affect your crash and
    error reports as the stack trace will be obfuscated. However, this is not a problem
    as we can retrace them with a mapping file that we will save while releasing the
    app, which will allow us to convert the crash and report to readable and not obfuscated
    code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类和方法的重命名，这可能会影响你的崩溃和错误报告，因为堆栈追踪将会被混淆。然而，这不是问题，因为我们可以在发布应用时保存一个映射文件，用它可以重新追踪，这将允许我们将崩溃和报告转换成可读的、未被混淆的代码。
- en: 'To activate Proguard, we need to set the `minifyEnabled` property to `true`
    in `buildTypes`. You can execute the following code for this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活Proguard，我们需要在 `buildTypes` 中将 `minifyEnabled` 属性设置为 `true`。你可以执行以下代码来实现这一点：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our project, we have a `proguard-rules.pro` file, where we can add the rules
    to be considered while obfuscating. For instance, some third-party libraries cannot
    work properly if we obfuscate them, and there is no risk in leaving these libraries
    without obfuscation as they are not something that we created; we just added them
    to our project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，有一个 `proguard-rules.pro` 文件，我们可以在混淆时考虑添加规则。例如，如果我们混淆一些第三方库，它们可能无法正常工作，并且不混淆这些库是没有风险的，因为它们不是我们创建的；我们只是将它们添加到我们的项目中。
- en: '![Code obfuscation](img/B04887_12_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![代码混淆](img/B04887_12_12.jpg)'
- en: 'To prevent a third-party library from being obfuscated, we can add the rule
    `-keep along with the rule` and `-dontwarn` to ignore warnings. For instance,
    we added `calligraphy` to use custom fonts; this is how we can ignore it during
    the obfuscation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止第三方库被混淆，我们可以添加 `-keep` 规则以及 `-dontwarn` 规则来忽略警告。例如，我们添加了 `calligraphy` 以使用自定义字体；这样我们可以在混淆期间忽略它：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `keep` and the name of the package, we will keep all the classes inside
    this package.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `keep` 和包名，我们将保留该包内的所有类。
- en: 'We will add Proguard in the debug mode to create a crash intentionally and
    see how the stack trace looks obfuscated:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在调试模式下添加Proguard，故意创建一个崩溃，看看混淆后的堆栈追踪是什么样子：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can copy this `stracktrace` in a text file and go to `app/build/outputs/mapping/product_flavor_name/
    release_or_debug/mapping.txt` to get our `mapping.txt` file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个`stracktrace`复制到文本文件中，然后前往`app/build/outputs/mapping/product_flavor_name/
    release_or_debug/mapping.txt`获取我们的`mapping.txt`文件。
- en: 'Consider that we execute the retrace command in `<sdk_root>/tools/proguard`
    with the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在`<sdk_root>/tools/proguard`执行以下代码的retrace命令：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, we will have the crash in the correct line, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有正确的行号显示崩溃，如下所示：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember to save a copy of `mapping.txt` with every release of your app; this
    file is overwritten every time we release it, so it's very important to save the
    file at the moment of every release. Alternatively, if you have a repository and
    you tag the commits for every release, you can go back and generate the same release
    again, which will have the same mapping file in theory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在每次发布应用时保存`mapping.txt`的副本；每次发布时这个文件都会被覆盖，因此在每次发布时保存文件非常重要。或者，如果你有一个仓库，并且你为每次发布标记提交，你可以回退并再次生成相同的发布，理论上这将具有相同的映射文件。
- en: Now that we have our app protected against reverse engineering, we can continue
    with the release process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的应用已经针对逆向工程进行了保护，我们可以继续发布流程。
- en: Exporting the app
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出应用
- en: When we export an application, what we do is create an APK file in the release
    mode and sign it with a certificate. This certificate is proof that an app in
    Play Store is ours, and with it, we can upload the same app as we explained before.
    We will export the app and create a certificate this time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导出应用程序时，我们要做的是在发布模式下创建一个APK文件并用证书签名。这个证书是Play Store中应用属于我们的证明，有了它，我们可以像之前解释的那样上传同一个应用。这次我们将导出应用并创建一个证书。
- en: 'To export our application, we have two ways: one way is to use Gradle and the
    terminal inside Android Studio and the second way is to use the wizard in Android
    Studio. We will see both, but let''s create the certificate using the second way
    first.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出我们的应用程序，有两种方法：一种是在Android Studio中使用Gradle和终端，第二种是使用Android Studio中的向导。我们将介绍两种方法，但首先使用第二种方法创建证书。
- en: 'Navigate to **Build** | **Generate Signed Apk**; you will see a dialog similar
    to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**构建** | **生成签名的Apk**；你会看到一个与以下类似的对话框：
- en: '![Exporting the app](img/B04887_12_13.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![导出应用](img/B04887_12_13.jpg)'
- en: If we have exported this app before and created a certificate for it then, we
    just need to select a path and insert the alias and password, and this will export
    a new version of the app signed with the existing certificate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们之前导出过这个应用并创建了证书，那么只需选择路径，输入别名和密码，这将使用现有证书签署导出一个新版本的应用。
- en: For us, this is the first time that we are exporting `MasteringAndroidApp`,
    so we will click on **Create new…**. On the next screen, we need to select the
    path where will save the certificate, which is a `.keystore` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这是第一次导出`MasteringAndroidApp`，因此我们将点击**创建新的…**。在下一个屏幕上，我们需要选择保存证书的路径，这是一个`.keystore`文件。
- en: 'We also need a password for the `keystore` and a password for the alias inside
    the certificate. For a date with validity, 100 years will be okay; if your app
    lives more than you, it won''t be your problem! Finally, some personal information
    in at least one field is required here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为`keystore`和一个证书内的别名设置密码。对于有效日期，100年应该是可以的；如果你的应用比你活得更久，那就不是你的问题了！最后，在这里至少需要一个字段填写个人信息：
- en: '![Exporting the app](img/B04887_12_14.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![导出应用](img/B04887_12_14.jpg)'
- en: Finally, it will ask us which flavor we want to export, and it will create the
    `.apk`, pointing to us the path of the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它会询问我们想要导出哪个版本的应用，并且会创建`.apk`文件，同时指出文件的路径。
- en: This way is straightforward, but there is an automated way to export the app
    using the command line and Gradle; it's very useful if we want to build the app
    with Jenkins, for instance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很直接，但还有一种自动化的方法可以使用命令行和Gradle导出应用；例如，如果我们想用Jenkins构建应用，这会非常有用。
- en: 'To do this, we need to add a signing configuration in `build.gradle` so that
    when the app is generated automatically, it will know which `keystore` and which
    alias and passwords to use. The following code will help in doing this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要在`build.gradle`中添加一个签名配置，这样当自动生成应用时，它会知道要使用哪个`keystore`以及哪个别名和密码。以下代码将有助于实现这一点：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is no need to say that this can lead to a security problem; the password
    is written in `build.gradle` and the certificate file is included in our project.
    If we do this, we need to keep the project safe. If this is a concern, you can
    read the password and the alias at runtime with the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，这可能导致安全问题；密码写在`build.gradle`中，证书文件包含在我们的项目中。如果我们这样做，我们需要确保项目安全。如果这是一个关注点，你可以使用以下代码在运行时读取密码和别名：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run the command to generate the signed APK, it will ask us for the
    password alias and alias password. We can use the following line of code for this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行生成签名APK的命令时，系统会要求我们输入密码别名和别名密码。我们可以使用以下代码行来完成这个操作：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Exporting the app](img/B04887_12_15.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![导出应用](img/B04887_12_15.jpg)'
- en: 'With our app exported, we can proceed to the last step: uploading to Play Store.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应用导出后，我们可以继续最后一步：上传到Play商店。
- en: Uploading our app to Play Store
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的应用上传到Play商店
- en: To publish an app, we need a Google developer account. If you don't have one,
    you can obtain one from [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布应用，我们需要一个Google开发者账户。如果你没有，可以从[https://play.google.com/apps/publish/](https://play.google.com/apps/publish/)获取一个。
- en: Creating a publisher account
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建发布商账户
- en: The first step to creating a publisher account is to enter the basic information
    and read and accept the developer distribution agreement. The second step is the
    payment of a development license fee of 25 dollars for the creation of the account.
    This is all we have to pay to publish an app, and it's paid just a single time—one
    single payment for a lifetime's license. We can't complain, considering in iOS,
    the fee is 99 dollars yearly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建发布商账户的第一步是输入基本信息，并阅读并接受开发者分销协议。第二步是支付25美元的开发许可费用以创建账户。这是我们发布应用所需支付的全部费用，只需一次性支付——一次付费，终身许可。考虑到iOS上每年要支付99美元，我们不应该抱怨。
- en: 'The final and third step needs the developer''s name, which will appear under
    the name of our application. Take a look at the following example in Google Inc:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的第三步需要开发者的名字，该名字将显示在我们的应用程序名称下方。以下是Google Inc的示例：
- en: '![Creating a publisher account](img/B04887_12_16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建发布商账户](img/B04887_12_16.jpg)'
- en: We also need the e-mail, a mobile number, and our website, which is optional.
    According to Google, it is needed in case someone has to contact us in relation
    to the content published.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要电子邮件、手机号码以及可选的网站。根据谷歌的说法，这是为了在有人需要就发布的内容联系我们时使用。
- en: The Google Play Developer console
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Play Developer控制台
- en: 'When we open the publisher account, if we have no apps published, we will see
    four of the main features of the developer console, as shown in the following
    image:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开发布商账户时，如果我们还没有发布任何应用，我们将看到开发者控制台四个主要功能，如下面的图片所示：
- en: '![The Google Play Developer console](img/B04887_12_17.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Google Play Developer控制台](img/B04887_12_17.jpg)'
- en: The first option is to publish an Android app, and it is the option we will
    follow in the book. However, before this, we will describe quickly the other options
    to keep in mind.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是发布一个Android应用，这也是我们将在书中遵循的选项。然而，在此之前，我们将快速描述其他需要考虑的选项。
- en: The second option is about the Google Play game services. If you develop a game
    where you want the players to save and submit their score and have a scores ranking,
    you will need a server to store these scores and retrieve them, maybe even have
    a username and a login for the player. The game services do this for us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是关于Google Play游戏服务。如果你开发了一个游戏，希望玩家保存并提交他们的分数，并有一个分数排名，你将需要一个服务器来存储这些分数并检索它们，甚至可能需要玩家用户名和登录。游戏服务为我们完成这些工作。
- en: It provides an API that is shared across games, linked with the Google account
    of the user, where we can manage leaderboards and achievements. It even provides
    the API and infrastructure to implement multiplayer games, both real-time multiplayer
    and turn-based ones.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个API，跨游戏共享，并与用户的Google账户关联，我们可以管理排行榜和成就。它甚至提供了实现多人游戏（包括实时多人和回合制）的API和基础设施。
- en: The third option, the one at the bottom to the left, is about sharing the developer
    console. We might want to allow other developers to update an app. This will help,
    for instance, in the case of a company, where there will be people in charge of
    setting the name, description, images of the app, and marketing in general and
    other people in charge of the app upload and the developers. We can configure
    the access to the console and to a specific application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧底部的第三个选项是关于分享开发者控制台的。我们可能希望允许其他开发者更新应用。例如，在公司中，这将有助于那些负责设置应用名称、描述、图片和总体市场营销的人员，以及其他负责应用上传和开发的人员。我们可以配置对控制台和特定应用的访问权限。
- en: '![The Google Play Developer console](img/B04887_12_18.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Google Play开发者控制台](img/B04887_12_18.jpg)'
- en: The fourth and final option is the merchant account; we need this if want to
    sell paid apps or in-app products. This is an example of the merchant account
    from a paid app; we can see payments completed and cancelled. If a user purchases
    our app, he/she has two hours to claim a refund in case he/she didn't like it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个也是最后一个选项是商家账户；如果我们想要销售付费应用或应用内产品，就需要这个。这是来自付费应用的商家账户示例；我们可以看到完成的支付和取消的支付。如果用户购买了我们的应用，他/她在两小时内可以申请退款，如果他/她不喜欢它的话。
- en: '![The Google Play Developer console](img/B04887_12_19.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Google Play开发者控制台](img/B04887_12_19.jpg)'
- en: 'We saw an empty developer console with the four main options because we didn''t
    have an app published yet; if we had apps published, this is what we would see.
    The **Publish** button is at the top in this case:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们还没有发布应用，所以我们看到了一个包含四个主要选项的空白开发者控制台；如果我们有已发布的应用，我们会看到这样的界面。在这种情况下，**发布**按钮位于顶部：
- en: '![The Google Play Developer console](img/B04887_12_20.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Google Play开发者控制台](img/B04887_12_20.jpg)'
- en: On the initial screen, we can see the different apps, whether they are free
    or paid, the active installs, and the total installs. Active installs mean the
    people that have the app at the moment and that did not uninstall it after downloading.
    Total installs mean the count of all the times the app was installed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始屏幕上，我们可以看到不同的应用，无论它们是免费还是付费，活跃安装数和总安装数。活跃安装意味着目前拥有该应用并且下载后没有卸载的人数。总安装数意味着应用被安装的所有次数的总计。
- en: We can also see the ratings and number of crashes. We can take a look at more
    details, such as comments from the users and error crash reports, if we click
    on the app and go into the detail view.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看评分和崩溃次数。如果我们点击应用并进入详细视图，可以查看更多详细信息，比如用户的评论和错误崩溃报告。
- en: Publishing an app
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布应用
- en: Continuing with the upload process, when we click on **+ Add** new application,
    we are asked for a name and a default language. After this, we can choose how
    to start the process by uploading an APK or preparing the store listing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上传过程，当我们点击**+ 添加**新应用时，会被要求输入名称和默认语言。在此之后，我们可以选择通过上传APK或准备商店列表来开始流程。
- en: '![Publishing an app](img/B04887_12_21.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![发布应用](img/B04887_12_21.jpg)'
- en: 'These are two different processes: one is uploading the APK file, and the other
    is setting the title of the app, a description, an image, if it is paid or free,
    and so on—all the different options to be shown in Play Store.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括两个不同的过程：一个是上传APK文件，另一个是设置应用的标题、描述、图片、是否付费等——所有在Play商店中展示的不同选项。
- en: Let's start with the uploading of the APK file and the different testing groups.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从上传APK文件和不同的测试组开始。
- en: Uploading the APK file
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传APK文件
- en: Remember that when we upload an APK, the package name of our application has
    to be unique in the Play Store; we can only upload an APK with an existing package
    name if we want to update an app previously published by us and if the certificate
    that we used to sign the initial download is the same certificate we used to sign
    the new APK.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们上传APK时，我们应用的包名在Play商店中必须是唯一的；如果我们想要更新之前由我们发布的app，并且使用初始下载签名的证书与新的APK签名证书相同，那么我们可以上传具有现有包名的APK。
- en: 'The first things we notice when we click on **upload the APK** are the three
    different tabs with the names: **Production**, **Beta**, and **Alpha**.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**上传APK**时，首先注意到的三个不同标签页的名称分别为：**生产环境**、**测试版**和**Alpha版**。
- en: '![Uploading the APK file](img/B04887_12_22.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![上传APK文件](img/B04887_12_22.jpg)'
- en: We can release our app in two test groups and in production. Production means
    that it is published in Play Store; it is public and visible to everyone. For
    a while, this was the only option available in the developer console until they
    added the staged rollout.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在两个测试组以及生产环境中发布我们的应用程序。生产意味着它在Play商店中发布；它是公开的，对所有人可见。一段时间以来，这曾是开发者控制台中的唯一选项，直到他们增加了分阶段推出的功能。
- en: The staged rollout allows us to release the app to a limited group of users.
    To select the users, we have different options; we can invite these users by e-mail,
    share a link, or create a Google group or G+ community, inviting the users to
    the group and sharing the link of the app with them. Only these users will then
    see the app in the Play Store. This is useful to get feedback from some users
    before our app is released to the world and, of course, to prevent bugs and bad
    reviews of the app in production. We can also select the percentage of users our
    app is to be published to in production; for instance, if we have a million users,
    we can release to 10 percent first and double-check that everything is ok before
    doing a massive release.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 分阶段推出允许我们将应用程序发布给一组有限的用户。为了选择这些用户，我们有不同的选项；我们可以通过电子邮件邀请这些用户，分享链接，或者创建一个Google群组或G+社区，邀请用户加入该群组，并将应用程序的链接分享给他们。只有这些用户才会在Play商店中看到应用程序。这对于在应用程序向全世界发布之前从一些用户那里获得反馈非常有用，当然，也可以防止应用程序在生产环境中出现错误和差评。我们还可以选择在生产环境中发布我们应用程序的用户百分比；例如，如果我们有百万用户，我们可以首先向10%的用户发布，并在进行大规模发布之前再次确认一切是否正常。
- en: We can have different versions of our app in different stages; for instance,
    we can have version 1.0.0 published, 1.0.1 in beta testing, and 1.0.2 in alpha
    testing. We can roll out the APK from alpha to beta and from beta to production,
    but we can't roll back.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可以在不同的阶段有不同的版本；例如，我们可以发布版本1.0.0，1.0.1进行beta测试，1.0.2进行alpha测试。我们可以从alpha阶段滚动到beta阶段，从beta阶段滚动到生产阶段，但我们不能回滚。
- en: The concept that we will now explain is very important. Once we publish a version
    of our app, we can't go back to a previous published version. It could happen
    that we have a working version of our app in the Play Store, we develop a new
    version, it works fine in our device, and we think it is ready to be uploaded.
    It's Friday afternoon, and we don't bother testing because we think, "Oh, I'm
    sure it's fine. I just did a small change of two lines, that won't affect anything".
    We upload version 1.0.4\. After a couple of hours, we start receiving crash reports
    from Play Store. It's the moment of panic; the only thing we can do now is undo
    the publishing of the current app to prevent more damage and start working on
    a fix as soon as possible. However, if the fix is not easy, the most sensible
    thing would be to generate the last known working version again (1.0.3), increase
    the version number and code to 1.0.5, and upload it to Play Store.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要解释的概念非常重要。一旦我们发布了应用程序的一个版本，我们就无法回到之前的发布版本。可能会出现这样的情况：我们在Play商店中有一个应用程序的正常运行的版本，我们开发了一个新版本，在我们的设备上运行良好，我们认为它已经准备好上传了。现在是周五下午，我们不想进行测试，因为我们会想，“哦，我相信它没问题。我只是改了两行代码，不会影响任何东西”。我们上传了版本1.0.4。几小时后，我们开始收到来自Play商店的崩溃报告。这是恐慌的时刻；我们现在能做的唯一事情是撤销当前应用程序的发布，以防止更多损害，并尽快开始修复。然而，如果修复不容易，最明智的做法是再次生成最后一个已知正常工作的版本（1.0.3），将版本号和代码增加到1.0.5，并将其上传到Play商店。
- en: However, this could get worse; if we had a database and the structure changed
    from 1.0.3 to 1.0.4 and our code is not ready to accept a downgrade of the database
    from 1.0.4 to 1.0.3 renamed as 1.0.5, we will know that we will be working all
    weekend, only to be fired on Monday morning. To sum up our point, it is much better
    to prevent rather than heal; so, use the staged rollout, do all the testing necessary
    before releasing, and avoid releasing on Friday afternoon just in case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会变得更糟；如果我们有一个数据库，并且其结构从1.0.3更改为1.0.4，如果我们的代码还没有准备好接受从1.0.4降级到1.0.3（更名为1.0.5）的数据库，我们知道我们整个周末都要工作，只是为了在周一早上被解雇。总之，我们的观点是，预防胜于治疗；因此，使用分阶段推出，在发布之前进行所有必要的测试，并避免在周五下午发布，以防万一。
- en: Preparing the store listing
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备商店列表
- en: Preparing the store listing for a developer can be the most boring part, but
    it needs to be done in order to publish an app; there are some mandatory assets
    and fields that we can't skip.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，准备商店列表可能是最无聊的部分，但为了发布应用程序，这是必须要完成的；有一些我们不能跳过的必填资产和字段。
- en: 'First, we need a title for our app, a short description of up to 80 characters
    and a long description of up to 4000\. The title will be the first thing that
    we see while searching for our app; the short description can be seen, for instance,
    in tablets while browsing apps. This is the *elevator pitch* of our app, and we
    need to describe it here in the main function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的应用准备一个标题，一个最多80个字符的简短描述和一个最多4000个字符的长描述。标题将是我们搜索应用时首先看到的内容；简短描述可以在例如浏览应用时的平板电脑上看到。这是我们应用的*elevator
    pitch*，我们需要在这里描述其主要功能。
- en: '![Preparing the store listing](img/B04887_12_23.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_23.jpg)'
- en: The long description will be shown when we go to the detail view of this app.
    In terms of appearing in more searches and earning visibility, it is good to identify
    and add keywords related to our app in the description. The use of unrelated keywords
    to attract downloads is banned from Google, and if you do this, you will receive
    a warning in the developer console, and your app will need some changes before
    being approved and published again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 长描述将在我们查看此应用的详细视图时显示。为了在更多搜索中出现并获得可见性，在描述中识别并添加与应用相关的关键词是很好的做法。使用不相关关键词吸引下载是被Google禁止的，如果你这样做，你将在开发者控制台收到警告，并且你的应用在重新获得批准和发布之前需要做出一些更改。
- en: At this point, we have the option to internationalize our app's listing, repeating
    these three fields mentioned in as many languages as we want, and they will be
    displayed in different languages automatically, depending on the user's language.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以选择国际化我们应用的列表，重复这些字段，用我们想要的任何语言，它们将根据用户的语言自动显示在不同的语言中。
- en: The next step is to develop the graphics, and we need to take screenshots here.
    Screenshots can easily be taken in your device with a key combination; for instance,
    in a Samsung Galaxy 3, this is done by pressing the *volume down* and *menu* keys
    at the same time. They can also be taken from Android Studio by selecting the
    camera icon in the Android view.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开发图形，我们需要在这里进行截图。截图可以通过设备上的按键组合轻松完成；例如，在三星Galaxy 3上，这是通过同时按下*音量减*和*菜单*键完成的。也可以通过在Android
    Studio中选择Android视图中的相机图标来获取截图。
- en: '![Preparing the store listing](img/B04887_12_24.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_24.jpg)'
- en: 'Apart from screenshots, we need a 512 x 512 hi-res icon; this must be the same
    as or very similar to the icon that we are using for our app in the uploaded version,
    otherwise it will throw a warning. For this reason, it''s good to create the icon
    in 512 x 512 always and then scale it down to use in our app. The other way around
    will result in a scaled up image with bad quality. This is an example of where
    the icon is displayed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了截图，我们还需要一个512 x 512高分辨率的图标；这必须与上传版本中我们应用所使用的图标相同或非常相似，否则会收到警告。因此，最好始终以512
    x 512的尺寸创建图标，然后将其缩小以用于我们的应用。反其道而行将导致放大后图像质量变差。以下是图标显示的一个示例：
- en: '![Preparing the store listing](img/B04887_12_25.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_25.jpg)'
- en: The last image we need is the feature graphic. This is a 1024 x 500 graphic
    that shows the features of our app. This is the graphic that will be shown in
    our app featured on Google Play. It will be shown in the Play Store app; if we
    have a promo video, the feature graphic will still be shown while the video is
    not playing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要准备的最后一张图片是功能图。这是一张1024 x 500的图片，展示了我们应用的特点。这是在我们应用在Google Play上展示时会被用到的图片。它将在Play商店应用中展示；如果我们有促销视频，即使视频没有播放，功能图也会显示。
- en: '![Preparing the store listing](img/B04887_12_26.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_26.jpg)'
- en: We need to continue with categorization; depending on whether our app is a game
    or an application, we need to choose different categories. If you are not sure
    about which category to choose, take a look in Play Store for apps similar to
    yours.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要继续进行分类；根据我们的应用是否为游戏或应用程序，我们需要选择不同的类别。如果你不确定选择哪个类别，可以在Play商店查看类似你应用的app。
- en: After this, we need to select the content rating; starting in May 2015, every
    app needs to have the new rating system. According to Google, this new content
    rating provides an easy way to communicate familiar and locally relevant content
    ratings to your users and helps improve app engagement by targeting the right
    audience for your content as seen in [https://support.google.com/googleplay/android-developer/answer/188189](https://support.google.com/googleplay/android-developer/answer/188189).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们需要选择内容评级；从2015年5月开始，每个应用都需要有新的评级系统。根据谷歌的说法，这个新的内容评级为向用户传达熟悉且与本地相关的内容评级提供了一种简单方式，并通过针对你的内容定位合适的目标受众来帮助提高应用参与度，具体内容可参考[https://support.google.com/googleplay/android-developer/answer/188189](https://support.google.com/googleplay/android-developer/answer/188189)。
- en: Our contact details are automatically completed, so the last thing we need to
    do is accept the privacy policy, and then we can click on **Pricing & Distribution**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的联系方式会自动填写，所以我们还需要做的就是接受隐私政策，然后点击**定价与分发**。
- en: '![Preparing the store listing](img/B04887_12_27.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_27.jpg)'
- en: This is where we make our app free or paid; this step can't be reverted. If
    the app is a paid one, we can set a price, and Google will convert it to different
    currencies in different countries; although, we can set different prices for each
    country. We can opt into different developer groups; for instance, if we develop
    an app for kids, we can include it in **designed for families**. This will increase
    our chances to be highlighted in kids' sections and distributed for third-party
    networks related with kids' apps.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们决定应用是免费还是付费；这一步无法撤销。如果应用是付费的，我们可以设定一个价格，谷歌会将它转换成不同国家的不同货币；尽管如此，我们可以为每个国家设定不同的价格。我们可以选择加入不同的开发者群体；例如，如果我们开发了一个儿童应用，我们可以将其包含在**为家庭设计**中。这将增加我们在儿童专区被突出显示的机会，并分发到与儿童应用相关的第三方网络。
- en: In this section, we can select the countries were we want our app to be distributed
    as well. This can be used as well as a staged releasing strategy the first the
    time the app is published.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们还可以选择我们希望应用分发的国家。这也可以用作首次发布应用时的分阶段发布策略。
- en: '![Preparing the store listing](img/B04887_12_28.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_28.jpg)'
- en: Completing all of the above, we will be able to publish our app by clicking
    on **Publish** in the upper right corner.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以上所有步骤后，我们将能够通过点击右上角的**发布**来发布我们的应用。
- en: '![Preparing the store listing](img/B04887_12_29.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![准备商店列表](img/B04887_12_29.jpg)'
- en: If the button is disabled, you can click on **Why can't I publish?**, and it
    will list the requirements on the left-hand side. Once the app is published, it
    can take a couple of hours to appear in the Play Store. The easiest way to find
    out whether the app is published yet is to navigate to our app using the package
    name in the URL. In our case, the URL would be, [https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp](https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮不可用，你可以点击**为什么我不能发布？**，它将在左侧列出要求。应用发布后，可能需要几个小时才能在Play商店中显示。确定应用是否已发布的最简单方法是使用包名在URL中导航到我们的应用。在我们的例子中，URL将是
    [https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp](https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp)。
- en: This is it! We have completed the book from the beginners' to a more advanced
    level with enough knowledge to upload an app well-designed and built that is backward-compatible
    and monetized.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们从初学者到更高级别完成了这本书，拥有足够的知识来上传一个设计精良、构建完善、向下兼容并实现盈利的应用。
- en: We wish you success with your apps and we hope you make the next Angry Birds
    or the next WhatsApp!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们祝愿你的应用成功，并希望你能打造出下一个《愤怒的小鸟》或下一个WhatsApp！
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Thanks a lot for purchasing and finishing this book. For suggestions, improvements,
    or any feedback, don't hesitate to contact me at `<[Antonio@suitapps.com](mailto:Antonio@suitapps.com)>`
    or follow me on Twitter at `@AntPachon`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢购买并完成这本书。对于建议、改进或有任何反馈，请毫不犹豫地联系我 `<[Antonio@suitapps.com](mailto:Antonio@suitapps.com)>`
    或在Twitter上关注我 `@AntPachon`。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter of the book, we started learning how to create different
    builds of our applications, combining build types with product flavors to obtain
    build variants.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们开始学习如何创建应用的不同版本，通过结合构建类型与产品风味来获得构建变体。
- en: After that, we learned how to monetize our app, adding different types of adverts
    and explaining the key points of advertisement monetization.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了如何对我们的应用程序进行货币化，添加了不同类型的广告，并解释了广告货币化的关键要点。
- en: We also exported the app, obfuscated and signed with a release certificate,
    from Android Studio and from the command line using Gradle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从 Android Studio 和使用 Gradle 命令行导出了应用程序，进行了混淆并使用发布证书进行了签名。
- en: To finish, we uploaded and published our app in Play Store.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 Play 商店上传并发布了我们的应用程序。
