- en: Chapter 12. Monetization, the Build Process, and Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final chapter of the book; what we have left to do is monetize our
    app, generate different versions of it, and release and upload it to Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: We will complete the build process by creating different build types and generating
    paid versions of the app without advertisements and a free version with advertisements.
    All of this will be in the same project but will be exported as two different
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Once the build process is finished, we will start implementing the advertisements
    and explain key points about advertisement monetization; this will make it possible
    to generate revenue using our application.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we will release the app and create an APK file of our APK signed
    with a release certificate, obfuscating the code so that it can be decompiled.
    We will upload it to Play Store and explain the key points to keep in mind during
    an app's publication.
  prefs: []
  type: TYPE_NORMAL
- en: Build variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monetization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key points of advertisement monetization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding advertisements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obfuscating and signing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting with Gradle
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading to Play Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using build variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explain how monetization with advertisements works on Android, we will add
    advertisements to our application, but before this, we will set up a build process
    that allows us to export two versions: the paid version and the free version.
    This strategy is commonly used in Play Store (having a free version with advertisements
    and a paid version without advertisements) so that all users can use the app for
    free, but the users that don''t like advertisement and want to contribute with
    your app can always buy the paid version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second way of implementing this strategy, which is creating just
    one version and having the option of buying an add-on to remove the advertisements
    inside the app with In-App billing products. The downside of this way is that
    your app won''t be listed in Play Store as a free app; it will be listed under
    "Offers in-App purchases", so there might be users who aren''t comfortable with
    this or children that are not allowed by their parents to have paid apps or apps
    including payments. The second problem is that In-App billing is not easy to implement;
    the process is very complex with many steps involving setting up the service,
    creating the products in Play Store, consuming these products from the app, and
    setting up a test environment, where we can test the purchases without incurring
    charges. To show the build variants, we can navigate to **View** | **Tool Windows**
    | **Build Variants** or click on **Build Variants** in the left-hand side bar
    of Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using build variants](img/B04887_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Build variants are a combination of build types and product flavors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the build types, `A` and `B`, and product flavors, `1` and `2`,
    the outcome will be the following build variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To understand this better, we can see what build types and build flavors are
    and how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating build types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A build type allows us to configure the packaging of an app for debugging or
    release purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at our `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In `build.gradle`, we can see that the build type release has two properties,
    which we will explain at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, we have two build types: **debug** and **release**. Even if we
    don''t see the debug build type, all the variants will be generated in release
    and debug mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create more build types with different parameters; some of the parameters
    we can use are to:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign the configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug the signing flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the version name or package name suffix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we can have different types signed with different certificates
    with the debug mode enabled or false and with a different package name.
  prefs: []
  type: TYPE_NORMAL
- en: The build type is not intended to create a different version of our app, such
    as demo or full, free or paid, and so on. For this, we have product flavors. Every
    build type is applied to every build flavor, creating a build variant as we saw
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Product flavors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create two product flavors and declare them in `build.gradle` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have a paid flavor, which is the app without advertisements, and a flavor
    called *free*, which is the free version with advertisements. For each product
    flavor, we can create a folder at the `../src/` level of our project. We don't
    need a folder for our paid version as it will be main by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![Product flavors](img/B04887_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This way, we can have different classes and resources for each build, even a
    different `AndroidManifest.xml` file. Our app will share the common code between
    the paid and the free versions in the `main` folder, with a specific code for
    ads in the `free` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch between the different versions, we can simply change the dropdown
    in the build variant window, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Product flavors](img/B04887_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once a build variant is selected, we can either run the app or export it, and
    it will run or export the selected flavor accordingly. These can be configured
    to have a different package name and a different version name.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take a look at how to add a specific code to the free version that
    won't be included in the main paid version.
  prefs: []
  type: TYPE_NORMAL
- en: Monetization in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will describe the three common ways to earn money through an application.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we can sell the application for a price in Play Store. There are some
    cases where charging for your app makes more sense than providing a free app with
    adverts or in-app products. If you create an app with big value for a small amount
    of users, you should definitely think about this option. For instance, if we were
    to release an app to professionally design houses for architects, we would know
    that our app will not be downloaded by millions of users; it's for a specific
    and targeted audience looking for quality software. We won't make enough profit
    with advertisements and our users will be keen to pay a good amount for software
    that makes their job easier. There is always a risk in asking for the money up
    front; even if the user has the option to obtain a refund for the app, he/she
    might not be attracted enough to try it. That is why we should consider the second
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is known as a **freemium** model. We release a free app but
    include in-app purchases in it. Applied to the same example of an app to design
    houses, we could offer three designs for free so that when the user is comfortable
    with our product, we can ask him/her to purchase a one-time license or a subscription
    to continue using the app. It's very common in games, where you can purchase items
    for your character. It is in games where we can see how this model can also be
    combined with the third model to get the maximum revenue possible.
  prefs: []
  type: TYPE_NORMAL
- en: The third model of monetization is the **advertisement model**; we place adverts
    in our apps, and when the user clicks on them, we get revenue. We can use different
    types of advertisements—from full screen advertisements to small banners at the
    bottom. We'll focus on this model. Implementing it is easier than you can imagine.
    But before implementing it, we need to explain what terms such as **CPC** (**Cost
    Per Click**), **CTR** (**Click Through Rate**), fill rate, and so on mean, which
    will help us choose a good advertisement platform and provider. This is also necessary
    to understand the metrics and be able to read the charts to know how the advertisements
    in your app are performing. Having advertisements in different places can change
    the revenue; however, we need to maximize the revenue without annoying the user.
    If we offer the user the option to remove advertisements for a small amount of
    money with an in-app product or with a paid version without advertisements, we
    can increase the number of advertisements. It's best for the user if they know
    that they have a choice. If they choose to live with the advertisements, it's
    their decision, and it won't annoy them as much as if we placed a lot of advertisements
    without the option to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Key points in advertisement monetization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will explain the basics to understand how advertisement monetization works.
    There are a few concepts in the business with abbreviations that can be confusing
    at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we register with an advertisement platform, we will see a reports page
    with stats about our app. Here is an example of the dashboard from the advertisement
    network, `AdToApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key points in advertisement monetization](img/B04887_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see requests, fill rate, impressions, clicks, CTR, eCPM, and revenue.
    Let´s consider each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Requests mean the number of times our app asked the advertisement network for
    an advert. For instance, if we decide to add a full screen advertisement at the
    start of our app, every time we start the app, there will be a request to the
    server to get back an advertisement.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have the advertisement inside our app; what we have is a placeholder,
    a frame, and an `AdView`, which will be filled with content provided by the advertisement
    network. Sometimes, the advertising network doesn't have an ad for us at the moment
    of the request, which is why the next concept is important.
  prefs: []
  type: TYPE_NORMAL
- en: Fill rate is a percentage derived by the amount of delivered ads divided by
    the amount of requested ads. For instance, if we start our app ten times and only
    get back adverts five times, we will have a fill rate of 50 percent. What we want
    in a good ad network is a fill rate of 100 percent. We want to show as many ads
    as possible and with a good CPC.
  prefs: []
  type: TYPE_NORMAL
- en: CPC, or cost per click, is how much we earn each time a user clicks on an advertisement
    in our app; the higher it is, the most revenue we get. The advertiser determines
    the CPC for an advertisement. Some advertisers may be willing to pay more per
    click than others.
  prefs: []
  type: TYPE_NORMAL
- en: Many clicks with low CPC is not necessarily better than a few clicks with high
    CPC. That's why the quality of the advertisements that we have is important.
  prefs: []
  type: TYPE_NORMAL
- en: Impressions are how many times an advertisement is shown to the user. In the
    previous example, with ten advertisement requests and five failed, we would have
    five impressions. Impressions don't generate revenue if the user doesn't click
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Clicks are the number of times a user clicks on an advertisement. This is what
    generates the revenue based on the CPC. So, five clicks with a 0.5$ CPC will generate
    5x0.5, which is 2.5$.
  prefs: []
  type: TYPE_NORMAL
- en: CTR, or click through rate, is the percentage given by the amount of clicks
    that your app receives divided by the amount of impressions. If we have 100 advertisements
    and one click, our CTR will be 1 percent. This amount is generally under 5 percent;
    users don't click on every advertisement they see, and you could have problems
    with an advertisement platform, such as **Admob**, cancelling your account and
    payments if they believe you are cheating by forcing the user to click on the
    advertisement. Let's say that we show a dialog at the start of our app and ask
    the user to click on an advertisement to continue using our app. This will basically
    give us 100 percent CTR; for every impression, there will be a click, and this
    is not allowed. We can't, under any circumstances, promote a click.
  prefs: []
  type: TYPE_NORMAL
- en: Advertisement providers want their advertisement to be seen by someone interested
    in it; they don't want to pay for the click of a person not interested in their
    advertisement, who will close it after a second. It could be that you have a high
    CTR because you have a good spot in your app and the advertisements are of interest
    to every user. If this happens, you will have to explain to your advertisement
    network, or some, such as **Admob**, will shut down your account. But we shouldn't
    be too unfair to them; they do this because they have found a lot of people trying
    to break the rules, and such a massive company can't focus on individuals, so
    they need to have objective filters.
  prefs: []
  type: TYPE_NORMAL
- en: Other advertisement network companies are more flexible with this; they usually
    assign an agent to you, who you can contact frequently on Skype or e-mail, and
    in case of any problem, they usually let you know.
  prefs: []
  type: TYPE_NORMAL
- en: eCPM stands for "effective cost per thousand impressions". It is calculated
    by dividing the total earnings by the total number of impressions in thousands.
    This is basically a quick way of knowing how good you are doing just by looking
    at a number—very useful to compare advertisement networks. It's a number usually
    between $0 and 3$.
  prefs: []
  type: TYPE_NORMAL
- en: We need to consider that this does not include the fill rate. It is the cost
    per thousand impressions and not per thousands requests. A three dollar eCPM with
    a 50 percent fill rate is the same as one and a half dollar eCPM with 100 percent
    fill rate.
  prefs: []
  type: TYPE_NORMAL
- en: What makes an advertisement network good is a high fill rate with a high eCPM.
    We need both to be high; adverts with expensive clicks and not enough fill rates
    won't produce any revenue because they simply won't be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The guys from **AdToApp** created a good graphic explaining this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key points in advertisement monetization](img/B04887_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This graphic represents what we have been talking about; a premium advertisement
    network with a very high eCPM and a low fill rate is represented as a tall but
    empty building with the lights off.
  prefs: []
  type: TYPE_NORMAL
- en: We are finished with the theory, and we can start integrating an advertisement
    solution; in this case, we will choose AdToApp.
  prefs: []
  type: TYPE_NORMAL
- en: Adding advertisements with AdToApp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no way to know which advertisement provider is better for you; the
    best you can do is to try different ones and have a look at the stats.
  prefs: []
  type: TYPE_NORMAL
- en: From experience, we like to use AddToApp because apart from the good delivery
    results, it's really easy to integrate, and it can be included in your app even
    if you have another network. Therefore, it's really easy to measure its performance.
  prefs: []
  type: TYPE_NORMAL
- en: It's ideal to use in this book with `MasteringAndroidApp` as it allows us to
    use different types of advertisements, full screen advertisements, banners, videos,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are mediators for more than 20 different advertisement networks, so including
    their SDK, we will have access to plenty of advertisements with a high fill rate
    guaranteed. Regarding their eCPM, they analyze which network is giving better
    results for you; so, if they can deliver advertisements from multiple networks,
    they will deliver the ones with better results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding advertisements with AdToApp](img/B04887_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can start creating an account at [https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow](https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow).
  prefs: []
  type: TYPE_NORMAL
- en: Once the account is created, we will create an app using the package name of
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding advertisements with AdToApp](img/B04887_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will click on the SDK button to download their SDK and get configuration
    values for the integration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding advertisements with AdToApp](img/B04887_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integration is straightforward; the SDK will contain an `AdToAppSDK.jar`
    file, which we need to copy into `libs`. We need to add Google Play Services in
    `build.gradle` and the support library *v7*, but we already have this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the basic permissions to the manifest, which we already have
    as well, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add extra mandatory assets in the manifest, which can be copied
    from the same website; it contains the keys of our account. You can find them
    under the first section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding advertisements with AdToApp](img/B04887_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we can take a look at how to implement **Interstitials & Banners**
    or rewarded ads. Rewarded advertisements are the type of advertisements that pop
    up in a game and say, *Watch this video and get (gold, gems, and so on)*. The
    viewing of these advertisements is totally up to the users if they want the reward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding advertisements with AdToApp](img/B04887_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we choose interstitials and banners, we need to initialize them depending
    on whether we want only video advertisements, only images (banners), or both images
    and videos in an interstitial.
  prefs: []
  type: TYPE_NORMAL
- en: In the website, depending on the type of advert you want, the necessary code
    will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK is really flexible; we can go further and set callbacks to know when
    the banners were loaded and clicked on. This allows us to track the number of
    clicks in our advertisements and verify that they are the same as in the AdToApp
    console, making the process transparent.
  prefs: []
  type: TYPE_NORMAL
- en: If we need extra help, we can activate logs in the SDK, which will inform us
    in case of any problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now, remember the good practices we mentioned at the start of the section about
    maximizing the number of advertisements without disturbing the user too much and
    implementing them in your app to start getting revenue!
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding advertisements with AdToApp](img/B04887_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Releasing our app to Play Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, our app is ready! This is the best moment while developing a new app;
    it is time to upload it to Play Store, get feedback from users, and hopefully
    get thousands of downloads.
  prefs: []
  type: TYPE_NORMAL
- en: We need to export the app to an APK file; in order to be uploaded to Play Store,
    it has to be signed with a release certificate. This point is very important;
    once an application is signed with a certificate, if we upload it to Play Store
    and want to upload a new version in the future, it has to be signed with the same
    certificate.
  prefs: []
  type: TYPE_NORMAL
- en: This certificate will be created by us during the release process. It needs
    an alias and a password, so ensure that you remember these details and save the
    certificate file in a safe place. Otherwise, say your app gets good ratings and
    a good number of downloads, and you want to update the version, but you don't
    have your certificate or have forgotten the password. In this case, you won't
    be able to update, you will have to upload a new app with a different package
    name, and it will start with zero downloads and zero ratings.
  prefs: []
  type: TYPE_NORMAL
- en: Code obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important thing to take into consideration while releasing the app is
    code obfuscation. If we export the app without obfuscating the code, anyone can
    download the APK and decompile it, allowing them to see your code, which can be
    a security problem if you have Parse IDs, server access details, a GCM project
    number, and so on in it.
  prefs: []
  type: TYPE_NORMAL
- en: We can obfuscate the code using **Proguard**. Proguard is a tool included in
    the Android build system. It obfuscates, shrinks, and optimizes the code, removing
    unused code and renaming classes, fields, and methods to prevent reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of this renaming of classes and methods; it can affect your crash and
    error reports as the stack trace will be obfuscated. However, this is not a problem
    as we can retrace them with a mapping file that we will save while releasing the
    app, which will allow us to convert the crash and report to readable and not obfuscated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate Proguard, we need to set the `minifyEnabled` property to `true`
    in `buildTypes`. You can execute the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In our project, we have a `proguard-rules.pro` file, where we can add the rules
    to be considered while obfuscating. For instance, some third-party libraries cannot
    work properly if we obfuscate them, and there is no risk in leaving these libraries
    without obfuscation as they are not something that we created; we just added them
    to our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code obfuscation](img/B04887_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To prevent a third-party library from being obfuscated, we can add the rule
    `-keep along with the rule` and `-dontwarn` to ignore warnings. For instance,
    we added `calligraphy` to use custom fonts; this is how we can ignore it during
    the obfuscation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using `keep` and the name of the package, we will keep all the classes inside
    this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add Proguard in the debug mode to create a crash intentionally and
    see how the stack trace looks obfuscated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can copy this `stracktrace` in a text file and go to `app/build/outputs/mapping/product_flavor_name/
    release_or_debug/mapping.txt` to get our `mapping.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we execute the retrace command in `<sdk_root>/tools/proguard`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we will have the crash in the correct line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Remember to save a copy of `mapping.txt` with every release of your app; this
    file is overwritten every time we release it, so it's very important to save the
    file at the moment of every release. Alternatively, if you have a repository and
    you tag the commits for every release, you can go back and generate the same release
    again, which will have the same mapping file in theory.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our app protected against reverse engineering, we can continue
    with the release process.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we export an application, what we do is create an APK file in the release
    mode and sign it with a certificate. This certificate is proof that an app in
    Play Store is ours, and with it, we can upload the same app as we explained before.
    We will export the app and create a certificate this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export our application, we have two ways: one way is to use Gradle and the
    terminal inside Android Studio and the second way is to use the wizard in Android
    Studio. We will see both, but let''s create the certificate using the second way
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Build** | **Generate Signed Apk**; you will see a dialog similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exporting the app](img/B04887_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we have exported this app before and created a certificate for it then, we
    just need to select a path and insert the alias and password, and this will export
    a new version of the app signed with the existing certificate.
  prefs: []
  type: TYPE_NORMAL
- en: For us, this is the first time that we are exporting `MasteringAndroidApp`,
    so we will click on **Create new…**. On the next screen, we need to select the
    path where will save the certificate, which is a `.keystore` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a password for the `keystore` and a password for the alias inside
    the certificate. For a date with validity, 100 years will be okay; if your app
    lives more than you, it won''t be your problem! Finally, some personal information
    in at least one field is required here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exporting the app](img/B04887_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, it will ask us which flavor we want to export, and it will create the
    `.apk`, pointing to us the path of the file.
  prefs: []
  type: TYPE_NORMAL
- en: This way is straightforward, but there is an automated way to export the app
    using the command line and Gradle; it's very useful if we want to build the app
    with Jenkins, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to add a signing configuration in `build.gradle` so that
    when the app is generated automatically, it will know which `keystore` and which
    alias and passwords to use. The following code will help in doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need to say that this can lead to a security problem; the password
    is written in `build.gradle` and the certificate file is included in our project.
    If we do this, we need to keep the project safe. If this is a concern, you can
    read the password and the alias at runtime with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the command to generate the signed APK, it will ask us for the
    password alias and alias password. We can use the following line of code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Exporting the app](img/B04887_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With our app exported, we can proceed to the last step: uploading to Play Store.'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading our app to Play Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To publish an app, we need a Google developer account. If you don't have one,
    you can obtain one from [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a publisher account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step to creating a publisher account is to enter the basic information
    and read and accept the developer distribution agreement. The second step is the
    payment of a development license fee of 25 dollars for the creation of the account.
    This is all we have to pay to publish an app, and it's paid just a single time—one
    single payment for a lifetime's license. We can't complain, considering in iOS,
    the fee is 99 dollars yearly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final and third step needs the developer''s name, which will appear under
    the name of our application. Take a look at the following example in Google Inc:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a publisher account](img/B04887_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also need the e-mail, a mobile number, and our website, which is optional.
    According to Google, it is needed in case someone has to contact us in relation
    to the content published.
  prefs: []
  type: TYPE_NORMAL
- en: The Google Play Developer console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we open the publisher account, if we have no apps published, we will see
    four of the main features of the developer console, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Google Play Developer console](img/B04887_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first option is to publish an Android app, and it is the option we will
    follow in the book. However, before this, we will describe quickly the other options
    to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is about the Google Play game services. If you develop a game
    where you want the players to save and submit their score and have a scores ranking,
    you will need a server to store these scores and retrieve them, maybe even have
    a username and a login for the player. The game services do this for us.
  prefs: []
  type: TYPE_NORMAL
- en: It provides an API that is shared across games, linked with the Google account
    of the user, where we can manage leaderboards and achievements. It even provides
    the API and infrastructure to implement multiplayer games, both real-time multiplayer
    and turn-based ones.
  prefs: []
  type: TYPE_NORMAL
- en: The third option, the one at the bottom to the left, is about sharing the developer
    console. We might want to allow other developers to update an app. This will help,
    for instance, in the case of a company, where there will be people in charge of
    setting the name, description, images of the app, and marketing in general and
    other people in charge of the app upload and the developers. We can configure
    the access to the console and to a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Google Play Developer console](img/B04887_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The fourth and final option is the merchant account; we need this if want to
    sell paid apps or in-app products. This is an example of the merchant account
    from a paid app; we can see payments completed and cancelled. If a user purchases
    our app, he/she has two hours to claim a refund in case he/she didn't like it.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Google Play Developer console](img/B04887_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We saw an empty developer console with the four main options because we didn''t
    have an app published yet; if we had apps published, this is what we would see.
    The **Publish** button is at the top in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Google Play Developer console](img/B04887_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the initial screen, we can see the different apps, whether they are free
    or paid, the active installs, and the total installs. Active installs mean the
    people that have the app at the moment and that did not uninstall it after downloading.
    Total installs mean the count of all the times the app was installed.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the ratings and number of crashes. We can take a look at more
    details, such as comments from the users and error crash reports, if we click
    on the app and go into the detail view.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuing with the upload process, when we click on **+ Add** new application,
    we are asked for a name and a default language. After this, we can choose how
    to start the process by uploading an APK or preparing the store listing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing an app](img/B04887_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are two different processes: one is uploading the APK file, and the other
    is setting the title of the app, a description, an image, if it is paid or free,
    and so on—all the different options to be shown in Play Store.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the uploading of the APK file and the different testing groups.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the APK file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that when we upload an APK, the package name of our application has
    to be unique in the Play Store; we can only upload an APK with an existing package
    name if we want to update an app previously published by us and if the certificate
    that we used to sign the initial download is the same certificate we used to sign
    the new APK.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first things we notice when we click on **upload the APK** are the three
    different tabs with the names: **Production**, **Beta**, and **Alpha**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading the APK file](img/B04887_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can release our app in two test groups and in production. Production means
    that it is published in Play Store; it is public and visible to everyone. For
    a while, this was the only option available in the developer console until they
    added the staged rollout.
  prefs: []
  type: TYPE_NORMAL
- en: The staged rollout allows us to release the app to a limited group of users.
    To select the users, we have different options; we can invite these users by e-mail,
    share a link, or create a Google group or G+ community, inviting the users to
    the group and sharing the link of the app with them. Only these users will then
    see the app in the Play Store. This is useful to get feedback from some users
    before our app is released to the world and, of course, to prevent bugs and bad
    reviews of the app in production. We can also select the percentage of users our
    app is to be published to in production; for instance, if we have a million users,
    we can release to 10 percent first and double-check that everything is ok before
    doing a massive release.
  prefs: []
  type: TYPE_NORMAL
- en: We can have different versions of our app in different stages; for instance,
    we can have version 1.0.0 published, 1.0.1 in beta testing, and 1.0.2 in alpha
    testing. We can roll out the APK from alpha to beta and from beta to production,
    but we can't roll back.
  prefs: []
  type: TYPE_NORMAL
- en: The concept that we will now explain is very important. Once we publish a version
    of our app, we can't go back to a previous published version. It could happen
    that we have a working version of our app in the Play Store, we develop a new
    version, it works fine in our device, and we think it is ready to be uploaded.
    It's Friday afternoon, and we don't bother testing because we think, "Oh, I'm
    sure it's fine. I just did a small change of two lines, that won't affect anything".
    We upload version 1.0.4\. After a couple of hours, we start receiving crash reports
    from Play Store. It's the moment of panic; the only thing we can do now is undo
    the publishing of the current app to prevent more damage and start working on
    a fix as soon as possible. However, if the fix is not easy, the most sensible
    thing would be to generate the last known working version again (1.0.3), increase
    the version number and code to 1.0.5, and upload it to Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: However, this could get worse; if we had a database and the structure changed
    from 1.0.3 to 1.0.4 and our code is not ready to accept a downgrade of the database
    from 1.0.4 to 1.0.3 renamed as 1.0.5, we will know that we will be working all
    weekend, only to be fired on Monday morning. To sum up our point, it is much better
    to prevent rather than heal; so, use the staged rollout, do all the testing necessary
    before releasing, and avoid releasing on Friday afternoon just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the store listing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preparing the store listing for a developer can be the most boring part, but
    it needs to be done in order to publish an app; there are some mandatory assets
    and fields that we can't skip.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a title for our app, a short description of up to 80 characters
    and a long description of up to 4000\. The title will be the first thing that
    we see while searching for our app; the short description can be seen, for instance,
    in tablets while browsing apps. This is the *elevator pitch* of our app, and we
    need to describe it here in the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The long description will be shown when we go to the detail view of this app.
    In terms of appearing in more searches and earning visibility, it is good to identify
    and add keywords related to our app in the description. The use of unrelated keywords
    to attract downloads is banned from Google, and if you do this, you will receive
    a warning in the developer console, and your app will need some changes before
    being approved and published again.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have the option to internationalize our app's listing, repeating
    these three fields mentioned in as many languages as we want, and they will be
    displayed in different languages automatically, depending on the user's language.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to develop the graphics, and we need to take screenshots here.
    Screenshots can easily be taken in your device with a key combination; for instance,
    in a Samsung Galaxy 3, this is done by pressing the *volume down* and *menu* keys
    at the same time. They can also be taken from Android Studio by selecting the
    camera icon in the Android view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Apart from screenshots, we need a 512 x 512 hi-res icon; this must be the same
    as or very similar to the icon that we are using for our app in the uploaded version,
    otherwise it will throw a warning. For this reason, it''s good to create the icon
    in 512 x 512 always and then scale it down to use in our app. The other way around
    will result in a scaled up image with bad quality. This is an example of where
    the icon is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last image we need is the feature graphic. This is a 1024 x 500 graphic
    that shows the features of our app. This is the graphic that will be shown in
    our app featured on Google Play. It will be shown in the Play Store app; if we
    have a promo video, the feature graphic will still be shown while the video is
    not playing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We need to continue with categorization; depending on whether our app is a game
    or an application, we need to choose different categories. If you are not sure
    about which category to choose, take a look in Play Store for apps similar to
    yours.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we need to select the content rating; starting in May 2015, every
    app needs to have the new rating system. According to Google, this new content
    rating provides an easy way to communicate familiar and locally relevant content
    ratings to your users and helps improve app engagement by targeting the right
    audience for your content as seen in [https://support.google.com/googleplay/android-developer/answer/188189](https://support.google.com/googleplay/android-developer/answer/188189).
  prefs: []
  type: TYPE_NORMAL
- en: Our contact details are automatically completed, so the last thing we need to
    do is accept the privacy policy, and then we can click on **Pricing & Distribution**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is where we make our app free or paid; this step can't be reverted. If
    the app is a paid one, we can set a price, and Google will convert it to different
    currencies in different countries; although, we can set different prices for each
    country. We can opt into different developer groups; for instance, if we develop
    an app for kids, we can include it in **designed for families**. This will increase
    our chances to be highlighted in kids' sections and distributed for third-party
    networks related with kids' apps.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we can select the countries were we want our app to be distributed
    as well. This can be used as well as a staged releasing strategy the first the
    time the app is published.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Completing all of the above, we will be able to publish our app by clicking
    on **Publish** in the upper right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the store listing](img/B04887_12_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the button is disabled, you can click on **Why can't I publish?**, and it
    will list the requirements on the left-hand side. Once the app is published, it
    can take a couple of hours to appear in the Play Store. The easiest way to find
    out whether the app is published yet is to navigate to our app using the package
    name in the URL. In our case, the URL would be, [https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp](https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp).
  prefs: []
  type: TYPE_NORMAL
- en: This is it! We have completed the book from the beginners' to a more advanced
    level with enough knowledge to upload an app well-designed and built that is backward-compatible
    and monetized.
  prefs: []
  type: TYPE_NORMAL
- en: We wish you success with your apps and we hope you make the next Angry Birds
    or the next WhatsApp!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks a lot for purchasing and finishing this book. For suggestions, improvements,
    or any feedback, don't hesitate to contact me at `<[Antonio@suitapps.com](mailto:Antonio@suitapps.com)>`
    or follow me on Twitter at `@AntPachon`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of the book, we started learning how to create different
    builds of our applications, combining build types with product flavors to obtain
    build variants.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned how to monetize our app, adding different types of adverts
    and explaining the key points of advertisement monetization.
  prefs: []
  type: TYPE_NORMAL
- en: We also exported the app, obfuscated and signed with a release certificate,
    from Android Studio and from the command line using Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we uploaded and published our app in Play Store.
  prefs: []
  type: TYPE_NORMAL
