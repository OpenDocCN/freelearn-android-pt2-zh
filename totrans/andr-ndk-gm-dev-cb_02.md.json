["```kt\n    CFLAGS = -I src\n    ```", "```kt\n    <SourceFile>.o:\n      gcc $(CFLAGS) –c <SourceFile>.cpp –o <SourceFile>.o\n    ```", "```kt\n    ObjectFiles = <SourceFile1>.o <SourceFile2>.o ...\n    ```", "```kt\n    <LibraryName>:\n      ar –rvs <LibraryName>.a $(ObjectList)\n    ```", "```kt\n    >make <LibraryName>.a\n    ```", "```kt\n    ObjectFileList = File1.o \\\n       ... \\\n       FileN.o\n    ```", "```kt\n    # This line is a comment\n    ```", "```kt\n    APP_OPTIM := release\n    APP_PLATFORM := android-8\n    APP_STL := gnustl_static\n    APP_CPPFLAGS += -frtti \n    APP_CPPFLAGS += -fexceptions\n    APP_CPPFLAGS += -DANDROID\n    APP_ABI := armeabi-v7a x86\n    APP_MODULES := FreeImage\n    ```", "```kt\n    # Android API level\n    TARGET_PLATFORM := android-8\n    # local directory\n    LOCAL_PATH := $(call my-dir)\n    # the command to reset the compiler flags to the empty state\n    include $(CLEAR_VARS)\n    # use the complete ARM instruction set\n    LOCAL_ARM_MODE := arm\n    # define the library name and the name of the .a file\n    LOCAL_MODULE     := FreeImage\n    # add the include directories\n    LOCAL_C_INCLUDES += src \\\n    # add the list of source files\n    LOCAL_SRC_FILES += <ListOfSourceFiles>\n    ```", "```kt\n    COMMON_CFLAGS := -Werror -DANDROID -isystem $(SYSROOT)/usr/include/\n    ```", "```kt\n    ifeq ($(TARGET_ARCH),x86)\n      LOCAL_CFLAGS   := $(COMMON_CFLAGS)\n    else\n      LOCAL_CFLAGS   := -mfpu=vfp -mfloat-abi=softfp -fno-short-enums $(COMMON_CFLAGS)\n    endif\n    ```", "```kt\n    include $(BUILD_STATIC_LIBRARY)\n    ```", "```kt\n    --host=arm-linux CC=arm-eabi-gcc\n    ```", "```kt\n    CPPFLAGS=”-I D:/NDK/system/core/include”\n    ```", "```kt\n    >configure CC=arm-eabi-gcc --host=arm-linux --disable-tftp --disable-sspi --disable-ipv6 --disable-ldaps --disable-ldap --disable-telnet --disable-pop3 --disable-ftp --without-ssl --disable-imap --disable-smtp --disable-pop3 --disable-rtsp --disable-ares --without-ca-bundle --disable-warnings --disable-manual --without-nss --enable-shared --without-zlib --without-random --enable-threaded-resolver\n    ```", "```kt\nCURL* Curl = curl_easy_init();\ncurl_easy_setopt( Curl, CURLOPT_URL, “http://www.google.com” );\ncurl_easy_setopt( Curl, CURLOPT_FOLLOWLOCATION, 1 );\ncurl_easy_setopt( Curl, CURLOPT_FAILONERROR, true );\ncurl_easy_setopt( Curl, CURLOPT_WRITEFUNCTION, &MemoryCallback );\ncurl_easy_setopt( Curl, CURLOPT_WRITEDATA, 0 );\ncurl_easy_perform( Curl );\ncurl_easy_cleanup( Curl );\n```", "```kt\nsize_t MemoryCallback( void* P, size_t Size, size_t Num, void* )\n{\n  printf( (unsigned char*)P) );\n}\n```", "```kt\n#define CURL_CA_BUNDLE “/etc/ssl/certs/ca-certificates.crt”\n```", "```kt\nALCdevice* Device = alcOpenDevice( NULL );\nALCcontext* Context = alcCreateContext( Device, NULL );\nalcMakeContextCurrent( Context );\n…\nalcDestroyContext( Context );\nalcCloseDevice( Device );\n```", "```kt\n    GLOBAL_CFLAGS   := -O3 -DHAVE_CONFIG_H=1 -DFREEIMAGE_LIB-isystem $(SYSROOT)/usr/include/ \n    ```", "```kt\n    void* lfind( const void * key, const void * base, size_t num, size_t width, int (*fncomparison)(const void *, const void * ) )\n    {\n      char* Ptr = (char*)base;\n      for ( size_t i = 0; i != num; i++, Ptr+=width )\n      {\n        if ( fncomparison( key, Ptr ) == 0 ) return Ptr;\n      }\n      return NULL;\n    }\n    ```", "```kt\n    >ndk-build \n    ```", "```kt\nstruct sBitmap\n{\n  int Width;\n  int Height;\n  void* RGBPixels;\n};\n```", "```kt\nvoid FreeImage_LoadImageFromMemory( unsigned char* Data, unsigned \n  int Size, sBitmap* OutBitmap )\n{\n  FIMEMORY* Mem = FreeImage_OpenMemory( Data, Size );\n\n  FREE_IMAGE_FORMAT FIF=FreeImage_GetFileTypeFromMemory(Mem, 0);\n\n  FIBITMAP* Bitmap = FreeImage_LoadFromMemory( FIF, Mem, 0 );\n  FIBITMAP* ConvBitmap;\n\n  FreeImage_CloseMemory( Mem );\n\n  ConvBitmap = FreeImage_ConvertTo24Bits( Bitmap );\n\n  FreeImage_Unload( Bitmap );\n\n  Bitmap = ConvBitmap;\n\n  OutBitmap->Width  = FreeImage_GetWidth( Bitmap );\n  OutBitmap->Height = FreeImage_GetHeight( Bitmap );\n\n  OutBitmap->RGBPixels = malloc( OutBitmap->Width * OutBitmap->Height * 3 );\n\n\tFreeImage_ConvertToRawBits( OutBitmap->RGBPixels, Bitmap, OutBitmap->Width * 3, 24, 0, 1, 2, false );\n\n  FreeImage_Unload( Bitmap );\n}\n```", "```kt\nvoid FreeImage_Save( const char* fname, unsigned char* img, int W, int H, int BitsPP )\n{\n  // Create the FIBITMAP structure\n  // using the source image data\n  FIBITMAP* Bitmap = FI_ConvertFromRawBits(img,\n    W, H, W * BitsPP / 8,\n    BitsPP, 0, 1, 2, false);\n  // save PNG file using the default parameters\n\n  FI_Save( FIF_PNG, Bitmap, fname, PNG_DEFAULT );\n  FI_Unload( Bitmap );\n}\n```", "```kt\n    #include <stdio.h>\n    #include <string.h>\n    ```", "```kt\n    #include <ft2build.h>\n    #include FT_FREETYPE_H\n    ```", "```kt\n    #define CHAR_SIZE 16\n    #define SLOT_SIZE 32\n    ```", "```kt\n    #define WIDTH CHAR_SIZE*SLOT_SIZE\n    #define HEIGHT CHAR_SIZE*SLOT_SIZE\n    unsigned char image[HEIGHT][WIDTH][4];\n    ```", "```kt\n    void write_bmp(const char *fname, int w, int h, int bits_pp, unsigned char *img);\n    ```", "```kt\n    void draw_bitmap( FT_Bitmap* bitmap, FT_Int x, FT_Int y)\n    {\n      FT_Int i, j, p, q;\n      FT_Int x_max = x + bitmap->width, y_max = y + bitmap->rows;\n    ```", "```kt\n    for ( i = x, p = 0; i < x_max; i++, p++ )\n    for ( j = y, q = 0; j < y_max; j++, q++ )\n    {\n      if (i < 0 || j < 0 ||\n          i >= WIDTH || j >= HEIGHT ) continue;\n    ```", "```kt\n      unsigned char v = bitmap->buffer[q * bitmap->width + p];\n      for(int k = 0 ; k < 4 ; k++) image[j][i][k] = v;\n        }\n      }\n    ```", "```kt\n    int main()\n    {\n    ```", "```kt\n      memset( &image[0][0][0], 0, sizeof(image) );\n    ```", "```kt\n      FT_Library   library;\n      FT_Init_FreeType( &library );              \n    ```", "```kt\n      FT_Face      face;\n      FT_New_Face( library, “font.ttf”, 0, &face ); \n    ```", "```kt\n      FT_Set_Char_Size( face, CHAR_SIZE * 64, 0, 100, 0 );\n      FT_GlyphSlot slot = face->glyph;\n    ```", "```kt\n      for ( int n = 0; n < 256; n++ )\n      {\n    ```", "```kt\n        if( FT_Load_Char( face, n, FT_LOAD_RENDER ) )\n          { continue; }\n    ```", "```kt\n      FT_Vector pen;\n          pen.x = (n % 16) * SLOT_SIZE * 64;\n          pen.y = ( HEIGHT - (n / 16) * SLOT_SIZE) * 64;\n    ```", "```kt\n        draw_bitmap( &slot->bitmap,\n          (pen.x/64)+slot->bitmap_left,\n          EIGHT-(pen.y / 64) - slot->bitmap_top );\n      }\n    ```", "```kt\n      write_bmp( “font.bmp”, WIDTH, HEIGHT, 32,\n        (unsigned char*)image );\n    ```", "```kt\n      FT_Done_Face(face);\n      FT_Done_FreeType(library);\n\n      return 0;\n    }\n    ```", "```kt\n    unsigned char* font;\n    ```", "```kt\n    int w = 1000;\n    int h = 1000;\n    int fw, fh;\n    int char_w, char_h;\n    ```", "```kt\n    void render_char(unsigned char* buf, char ch,\n     int x, int y, int col)\n    {\n      int u = (ch % 16) * char_w;\n      int v = char_h / 2 + ((((int)ch) >> 4) - 1) * char_h;\n    ```", "```kt\n      for (int y1 = v ; y1 < v + char_h ; y1++ )\n        for (int x1 = u ; x1 <= u + char_w ; x1++ )\n        {\n          int m_col = get_pixel(font, fw, fh, x1, y1);\n    ```", "```kt\n         if(m_col != 0)\n           put_pixel(buf, w, h, x+x1-u, y+y1-v, col);\n        }\n    }\n    ```", "```kt\n    void render_text(unsigned char* buf, const char* str,\n     int x, int y, int col)\n    {\n      const char* c = str;\n      while (*c)\n      {\n        render_char(buf, *c, x, y, col);\n        c++;\n    ```", "```kt\n        x += char_w;\n      }\n    }\n    ```", "```kt\nfont = read_bmp( “font.bmp”, &fw, &fh );\nchar_w = fw / CHAR_SIZE;\nchar_h = fh / CHAR_SIZE;\n```", "```kt\nunsigned char* bmp = (unsigned char* )malloc( w * h * 3 );\nmemset( bmp, 0, w * h * 3 );\n```", "```kt\nrender_text( bmp, “Test string”, 10, 10, 0xFFFFFF );\n```", "```kt\nwrite_bmp( “test.bmp”, w, h, bmp );\nfree( bmp );\n```", "```kt\n    double GetSeconds()\n    {\n    ```", "```kt\n      const unsigned usec_per_sec = 1000000;\n    ```", "```kt\n      struct timeval Time;\n      gettimeofday( &Time, NULL );\n    ```", "```kt\n    int64_t T1 = Time.tv_usec + Time.tv_sec * usec_per_sec;\n    ```", "```kt\n      return (double)( T1 ) / (double)usec_per_sec;\n    }\n    ```", "```kt\n    g_OldTime = GetSeconds();\n    g_NewTime = g_OldTime;\n    ```", "```kt\n    g_ExecutionTime = 0;\n    ```", "```kt\n    void GenerateTicks()\n    {\n      g_NewTime = GetSeconds();\n    ```", "```kt\n      float DeltaSeconds = static_cast<float>(g_NewTime-g_OldTime);\n      g_OldTime = g_NewTime;\n    ```", "```kt\n      if (DeltaSeconds > 0) { OnTimer(DeltaSeconds); }\n    }\n    ```", "```kt\n    SetTimer( hWnd, 1, 10, NULL);\n    ```", "```kt\n    LRESULT CALLBACK MyFunc( HWND h, UINT msg, WPARAM w, LPARAM p )\n      ...\n      case WM_TIMER:\n    ```", "```kt\n        InvalidateRect(h, NULL, 1);\n    ```", "```kt\n        OnTimer(0.01);\n        break;\n    ```", "```kt\npositions_new = SomeFunction(positions_old, time_step);\n```", "```kt\nconst float TIME_STEP = 1.0f / 60.0f;\nfloat TimeCounter = 0;\n\nvoid OnTimer (float Delta)\n{\n  g_ExecutionTime += Delta;\n\n  while (g_ExecutionTime > TIME_STEP)\n  {\n```", "```kt\n    g_World->Step(Delta);\n    g_ExecutionTime -= TIME_STEP;\n  }\n}\n```", "```kt\nLine2D(int x1, int y1, int x2, int y2, int color);\n```", "```kt\n    [x, y]  [X_screen, Y_screen]\n    ```", "```kt\n    X_screen = x * XScale + XOfs\n    Y_screen = y * YScale + YOfs\n    ```", "```kt\n    int XToScreen(float x)\n    {\n      return Width / 2 + x * XScale + XOfs;\n    }\n    int YToScreen(float y)\n    {\n      return Height / 2 - y * YScale + YOfs;\n    }\n    float ScreenToX(int x)\n    {\n      return ((float)(x - Width / 2)  - XOfs) / XScale;\n    }\n    float ScreenToY(int y)\n    {\n      return -((float)(y - Height / 2) - YOfs) / YScale;\n    }\n    ```", "```kt\n    void LineW(float x1, float y1, float x2, float y2, int col)\n    {\n      Line( XToScreen(x1),YToScreen(y1),\n      XToScreen(x2),YToScreen(y2),col );\n    }\n    void Line2DLogical(const Vec2& p1, const Vec2& p2)\n    {\n      LineW(p1.x, p1.y, p2.x, p2.y);\n    }\n    ```", "```kt\nVec2 pt[4];\npt[0] = x + w * cos(Alpha) + h * sin(Alpha)\npt[1] = x - w * cos(Alpha) + h * sin(Alpha)\npt[2] = x - w * cos(Alpha) - h * sin(Alpha)\npt[3] = x + w * cos(Alpha) - h * sin(Alpha)\n```", "```kt\nfor(int i = 0 ; i < 4 ; i++)\n{\n  Line2DLogical(pt[i], pt[(i+1)%4]);\n}\n```", "```kt\n    World* g_World = NULL;\n    ```", "```kt\n    g_World = new World(Vec2(0,0), 10);\n    Setup(g_World);\n    ```", "```kt\n    void OnDrawFrame()\n    {\n      Clear(0xFFFFFF);\n      for (auto b = g_World->bodies.begin();\n      b !=g_World->bodies.end(); b++ )\n      {\n        DrawBody(*b);\n      }\n    ```", "```kt\n    for ( auto j = g_World->joints.begin() ;\n      j != g_World->joints.end() ; j++ )\n    {\n      DrawJoint(*j);\n    }\n    ```", "```kt\n        GenerateTicks();\n      }\n    ```", "```kt\n    #define dSINGLE\n    ```", "```kt\n    #define dDOUBLE\n    ```"]