- en: Sharing Our Custom View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been building our custom view, or many of them, in these last chapters.
    We've seen how to interact with them, how to draw 2D and 3D primitives, and we
    want somebody else to be able to use it. That is a great idea! It might be for
    ourselves, we might reuse it in a future project, or it might be a project by
    one of our colleagues. If we aim higher, it might be a project by the Android
    community.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that makes the Android community awesome is that there are
    lots of open source libraries. All these contributions by developers have helped
    many other developers get started in Android development, learn to get a deeper
    understanding of some concepts, or be able to build their applications in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, publishing your custom view or, for instance, an Android library, is
    one of the methods that contributes to this amazing community. Secondly, by doing
    so, it's a great way to advertise yourself, show the openness of your employer,
    and also attract talent to your company.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll see what we should take into consideration if we want
    to share our custom view and how to do it. We'll also put into practice some of
    the important recommendations we've given in the previous chapters. Even more
    importantly, we want other developers to use our custom view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing your custom view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all recommendations given can be applied not only to custom views but
    to any Android library we'd like to share or we want to make reusable for our
    colleagues or other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for sharing our custom view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should always aim for the highest quality possible, even though we're building
    a custom view or component only for ourselves or for a small application. However,
    there are some additional checks and best practices that we've to take into account
    if we want to share our custom view so others can use it. If that is our goal,
    and we'd like to get as many developers as possible using it in their applications
    or contributing to it, it'll be quite challenging to involve them if we ignore
    these basic recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations and recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something we should consider is that once we share our custom view, it might
    be used for many Android applications. If our custom view has errors and crashes,
    it'll crash the application using it. The application's users will not consider
    the custom view at fault but rather the application itself. The application developer,
    or developers, might try to open an issue or even submit a pull request to fix
    it, but if the custom view gives them too much trouble, they'll just replace it.
  prefs: []
  type: TYPE_NORMAL
- en: This applies to your own applications as well; you don't want to use an unstable
    component or custom view as you might end up either rewriting it or patching it
    up. As we've just mentioned, we should always aim for the highest quality. If
    our custom view is only used in one single application, the impact of finding
    a critical issue once it's at the production stage or the application is published
    to the store or stores only affects one application. However, if it's used by
    several applications, the impact and cost of maintenance increases. You can imagine
    the impact of detecting a highly critical issue of an open source component and
    having to make new releases of all the applications using it.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you should try to keep your code clean, well-organized, properly
    tested, and reasonably documented. It'll be easier for you, as well as your colleagues
    if you're sharing the custom view at your company, to maintain the custom view,
    and if it's open source, it will encourage contributions and won't actually scare
    external contributors. As with many other things, common sense applies. Don't
    over-document your custom view as basically nobody will read it; keep it as simple
    as possible and straight to the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the open issues of the `retrofit` library,
    an open source Android library widely used in many applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bb8375c-bb14-4472-85f1-04a41e1a0ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we can see there are many pull requests submitted by several developers,
    either fixing issues or adding functionality or features. In the following screenshot
    is an example of a pull request submitted to the `retrofit` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb39c47e-3b26-478e-87ff-987e1559c293.png)'
  prefs: []
  type: TYPE_IMG
- en: We've previously covered it already, but it's also important that the custom
    view behaves properly. Not only must it be crash-free but it also has to work
    properly on several devices and resolutions and have good performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can sum up the list of recommendations with the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Stable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work across devices and resolutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developed applying best code practices and standard style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly documented and easy to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've explained in [Chapter 2](20734a38-fcba-4c21-b85a-ec328252e678.xhtml),
    *Implementing Your First Custom View*, how to parameterize a custom view. We've
    created it because it might serve a very specific purpose, but in general the
    more configurable it is, the more likely it will be used somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we're building a progress bar. If our custom view always draws a horizontal
    red bar, it'll have its uses but not many as it's too specific. If we allow the
    developer of the application using this custom view to customize the color of
    the bar, we'd add several other use cases for it. If, in addition, we also allow
    developers to configure the background color or what kind of primitive we're drawing
    instead of a horizontal bar, we'll cover even more different scenarios with our
    custom view.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be careful as well; adding so many options will also increase the
    complexity of the code and the component itself. Configuring colors is straightforward
    and doesn't have that much impact, but being able to change the drawing primitive,
    for example, might be slightly trickier. Adding complexity might impact on performance,
    stability, and our ability to test and verify all scenarios are working fine when
    publishing it or making a new release.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing our custom view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we're happy with our custom view and the way it is, we're ready to share
    it. If we've also followed the best practices and recommendations, we might be
    additionally confident. Even if you haven't, the best way to learn is to get feedback
    from the community as soon as possible. Don't be afraid of making mistakes; you'll
    learn on the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways of publishing a custom view: we can open source it, for
    example, or we can just publish a compiled binary as a SDK or Android library.
    Most of the recommendations above are given for the open source approach or internal
    reuse, either for yourself or your colleagues, but many of them, not all, also
    apply if your goal is to publish a closed SDK or just the compiled binary as a
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: Open sourcing our custom view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open sourcing a custom view or, alternatively, an Android library, is pretty
    easy and straightforward. You need to make sure you perform some additional steps
    but the process itself is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: We've been using GitHub to share the source code of the examples of this book.
    This is not a coincidence. GitHub is one of the most widely used tools for sharing
    source code and open source libraries and projects. It's also the tool we will
    recommend and will use in this chapter to explain how to publish our custom view.
  prefs: []
  type: TYPE_NORMAL
- en: First things first; if we don't have a GitHub account, we've to register ourselves
    and create it. Creating an account is free as long as we want to host only public
    repositories or publicly accessible code. If we want to use it to store private
    code repositories, we've the paid option. For the scope of this book, we've more
    than enough with the free option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can register directly from the home page: [https://www.github.com](https://www.github.com)
    or from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/join](https://github.com/join)[.](https://github.com/join)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have made the account, we create a code repository to store the code.
    We can do so at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/new.](https://github.com/new) As shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9830572-a781-4551-8d37-b69f139b3e88.png)'
  prefs: []
  type: TYPE_IMG
- en: We must choose a repository name. It is highly recommended to add a description
    so its easier for everyone else to understand what our component or library is
    doing. We also have the option of adding a `.gitignore` file and adding a license.
  prefs: []
  type: TYPE_NORMAL
- en: The `.gitignore` is quite a useful file. All files mentioned here won't be uploaded
    to GitHub. For instance, there is no need to upload all the temporary files, builds,
    intermediate build files, or configuration files from Android Studio that hold
    information about the project specifically to our local computer. It won't be
    useful to anybody to know that we're storing the project in `\Users\raimon\development\AndroidCustomView`
    for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a license is very important to determine what rights we are granting
    to those using our source code. Some of the most common licenses for open source
    projects are Apache 2.0, MIT, and GPLv3 licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: MIT is the less restrictive and permissive license. It allows other parties
    to use the source in any way they want as long as they include the license and
    copyright notice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache 2.0 is also quite permissive. Like the MIT license, it allows other parties
    to use the source in any way they want as long as they include the license and
    copyright notice and state the changes done to the original files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPLv3 is slightly more restrictive as it forces anyone using your source code
    to distribute the source code of the application using it under the same license.
    This might be a restriction for some companies as they'd like to preserve the
    IP of their source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three licenses limit the liability of the original developer and do not
    provide any warranty. They all provide the software or source code as is.
  prefs: []
  type: TYPE_NORMAL
- en: Many Android libraries use either the MIT or Apache 2.0 license and it's our
    recommendation to use either for your custom view.
  prefs: []
  type: TYPE_NORMAL
- en: Once the repository is created and initialized, we can upload our code. We can
    use any Git client we prefer or simply use the command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we clone the repository we''ve just created-just as reference, not a
    real repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Checking connectivity. Done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we already have the directory created with our source code inside, Git will
    complain it can''t create the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'fatal: destination path `androidcustomview` already exists and is not an empty
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ve to use a different approach. First, we have to initialize
    the local repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, pull the content from the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add all the files we''d like to add to the GitHub repository. In
    this case, we''ll add everything and Git will automatically ignore those files
    matching the patterns on the `.gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can commit to the local repository now. Always use a meaningful commit message
    or description as it will be useful later on to know what was changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is done, we''re ready to push those commits to the remote repository,
    at [https://github.com/](https://github.com/) in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information about Git go to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Git](https://en.wikipedia.org/wiki/Git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a repository, GitHub also asks us if we wants to create a `README.md`
    file. This `README.md` file is what will be shown on the repository page as documentation.
    It''s formatted using markdown, which is why the extension is `.md`, and it''s
    important to keep it up-to-date with information about the project, how to use
    it, a quick example, and a mention of the license and authors. The most important
    part here is that anyone who wants to use your custom view can check quite quickly
    how to do so, if the license is appropriate, and how to contact you for support
    and help. This last part is optional as they can always open an issue on GitHub,
    but it''s nice to have. We can even edit and preview the changes directly from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/](https://github.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: It's not only important to keep the documentation up-to-date, it's also important
    to keep the library maintained and up-to-date. There are bugs that need addressing,
    new features to add, new versions of Android that break, deprecate, improve or
    add new method, and other developers opening issues or asking questions. When
    looking for a custom view or Android library, if there are no recent updates or,
    at least, not in the last few months, it looks abandoned and it greatly decreases
    the chances somebody else will use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a binary artifact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been talking about shared custom views and Android libraries as if they
    were the same. The most suitable way to share a custom view is as an Android library.
    The main difference between an Android application and an Android library is that
    the latter cannot be run by itself on a device or emulator and will only produce
    an `.aar` file. This `.aar` file can, later on, be added as a dependency in an
    Android application project or other libraries. We could also have sub-modules
    inside the same project and have dependencies between them. To see how this works,
    we'll convert a custom view project into an Android library and we'll add a test
    application project to quickly test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, once we have an Android application, we can convert it to a library
    by just performing two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the line mentioning the `applicationId` on the app module `build.gradle`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the plugin applied from `com.android.application` to `com.android.library`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Basically changing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we've also refactored the app module name to lib.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on how to convert an Android application to an Android library
    can be found at the developer Android documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.android.com/studio/projects/android-library.html](https://developer.android.com/studio/projects/android-library.html).'
  prefs: []
  type: TYPE_NORMAL
- en: If we're developing or extending this library, we'd recommend adding a new module
    inside the project as a test application. It would considerably speed up developing
    and testing of the custom view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a new module using the Android Studio File menu: File | New | New
    Module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98fafcf5-8182-4ee6-82b8-f3f24f3c6d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve added a test application module, we add a dependency to the library.
    In the `build.gradle` file of the new module, add a dependency to the local lib
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can add the custom view to this new test application layout and test
    it. In addition, we can also produce a library binary to distribute. It''ll only
    include the library or the lib module. We can do so by executing the `lib:assembleRelease`
    task on gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We'll get the `.aar` file in our project folder at `lib/build/outputs/aar/lib-release.aar`.
    Using the `lib:assembleDebug` task, we'll produce the debug library, or simply
    using `lib:assembleDebug` we'll get both debug and release versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can distribute the binary in any way you prefer, but one recommendation
    is to upload to an artifact platform. Many companies are using internal artifact
    or software repositories for their enterprise libraries and artifacts in general,
    but if you want to make it available to the wider public, you can upload it to
    `JCenter`, for example. If we check our topmost `build.gradle` file from any Android
    project, we will see there is a dependency on `JCenter` to look for libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily do so from Bintray: [https://bintray.com](https://bintray.com),
    for example. Once we''ve registered, we could create projects, import them from
    GitHub, create releases and versions, and even publish it to `JCenter` if our
    project is accepted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the Bintray gradle plugin, go to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/bintray/gradle-bintray-plugin#readme](https://github.com/bintray/gradle-bintray-plugin#readme).'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify our lives, there are some open source examples and code that will
    make this process way simpler. But first, let's create a repository on Bintray.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll name it `AndroidCustomView`, set it up as a Maven repository, and add
    a default Apache 2.0 license:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4395fe16-075f-408a-82c0-4399e53c9837.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have it, we can create versions or we can add them directly from our
    gradle build scripts. In order to do so, we must add some dependencies to our
    topmost `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can take advantage of some open source gradle build scripts already
    created. Instead of copying and pasting or adding more code to our build script,
    we can simply apply it directly from GitHub. Let''s add these two lines to the
    very end of our library `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After applying these two gradle build scripts, we end up having an additional
    task: `bintrayUpload`. We need to add the artifact configuration first, so let''s
    add it at the very beginning of the file, just after the apply library line on
    the library module `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the Bintray user and API key information to our `local.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `bintrayRepo` variable has to match the repository where we'd like to store
    our binaries or otherwise the build script will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've all the configuration in place, we can build a new version of
    the library by using `./gradlew` install and uploading it to Bintray by using
    `./gradlew bintrayUpload`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that versions are read-only when they've been uploaded, so we'll
    not be able to override them and we'll get an error when executing our gradle
    script unless we update the version number and upload a different version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve uploaded a version, we''ll have something close to the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cdbb2cd-2346-4235-b885-0407f7fcecb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also inspect the files of an uploaded version to see what has been uploaded.
    If we go to a version and to the Files menu, we''ll see the `.aar` Android library
    and all the other files the script has uploaded for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3eb44c2-92da-4150-b9ad-e965e72d1f53.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, it also packaged and uploaded the source code, the `Javadoc`
    and created a `.pom` file as it's hosted as a Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: After doing all these steps, we can upload it to `JCenter` directly from the
    artifact repository page by pressing Add to JCenter. Once approved, anyone wanting
    to use our library can simply define a dependency on `com.rrafols.packt.androidcustomview`
    and directly get it from `JCenter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about this process and the author of these gradle build
    scripts, go to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en](https://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en).'
  prefs: []
  type: TYPE_NORMAL
- en: Something we haven't mentioned but is also quite important is how to version
    our library. Whenever we're creating a new release, we create a version number.
    It is highly recommended to use semantic versioning,Â `MAJOR.MINOR.PATCH`, when
    versioning our custom view. This way we can easily indicate if changes in one
    version are introducing incompatibilities or not. For instance, using semantic
    versioning, if we change the major number, we're indicating we've introduced incompatibilities
    with previous versions, or by changing the minor number, we indicate we've added
    new functionality without introducing any incompatibility. This is important for
    third-parties or other developers using our library, so they know what to expect
    from one version to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Semantic Versioning, go to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://semver.org/](http://semver.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Check also the full source code of this example in the `Example32-Library` folder
    on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen the recommendations for sharing our custom view
    and how we can actually do it. There are many benefits from open sourcing our
    custom views or sharing them internally at our company, for example. We'll not
    only pay more attention to quality and to details, but we will also foster collaborations
    and enrich the Android developer community.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will see how we can put all the information we have
    been covering these last chapters and build some more complex custom views that
    we can use and include directly in our applications.
  prefs: []
  type: TYPE_NORMAL
