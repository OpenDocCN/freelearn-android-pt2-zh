- en: Chapter 6. Practicing Test-driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the **Test-driven Development** (**TDD**) discipline.
    We will start with TDD practices in the general sense, and later on move to the
    concepts and techniques more closely related to the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: This is a code-intensive chapter, so be prepared to type as you read, which
    would help you get the most out of the examples provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing and explaining Test-driven Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing its advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a real-life example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding project requirements by writing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolving through the project by applying TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting an application that fully complies with the requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Briefly, Test-driven Development is the strategy of writing tests in parallel
    with the development process. These test cases are written in advance of the code
    that is supposed to satisfy them.
  prefs: []
  type: TYPE_NORMAL
- en: A single test is written, and then the code needed to satisfy the compilation
    of this test is written, then the behavior that the test decrees should exist
    is written. We continue writing tests and implementation until the full set of
    desired behaviors is checked by the tests.
  prefs: []
  type: TYPE_NORMAL
- en: This contrasts with other approaches to the development process, where the tests
    are written at the end when all the coding has been done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the tests in advance of the code that satisfies them has the following
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests get written one way or another, while if the tests are left till the end
    it is highly probable that they will never be written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers take more responsibility for the quality of their work, when having
    to consider the tests as they code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design decisions are taken in smaller steps and afterwards the code satisfying
    the tests is improved by refactoring. Remember, this is while having the tests
    running, so that there are no regressions in expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-driven Development is often explained in a diagram like the following,
    to help us understand the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with TDD](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following sections expand on the individual actions associated with the
    TDD, red, green, refactor cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start our development process with writing a test case. This apparently is
    a simple process that will put some machinery to work inside our heads. After
    all, it is not possible to write some code, test it or not, if we don't have a
    clear understanding of the problem domain, and its details. Usually, this step
    will get you face to face with the aspects of the problem you don't understand,
    and you need to grasp these if you want to model and write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Running all tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the test is written the next step is to run it, along with all other tests
    we have written so far. Here, the importance of an IDE with built-in support of
    the testing environment is perhaps more evident than in other situations, cutting
    the development time by a good fraction. It is expected that, firstly, our newly
    written test fails as we still haven't written any code.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to complete our test, we write additional code and take design decisions.
    The additional code written is the minimum possible to get our test to compile.
    Consider here, that not compiling is failing.
  prefs: []
  type: TYPE_NORMAL
- en: When we get the test to compile and run, and if the test fails, then we try
    to write the minimum amount of code necessary to make the test succeed. This may
    sound awkward at this point, but the following code example in this chapter will
    help you understand the process.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, instead of running all tests again you can just run the newly added
    tests first, to save some time as sometimes running the tests on the emulator
    could be rather slow. Then run the whole test suite to verify that everything
    is still working properly. We don't want to add a new feature by breaking any
    features already existing in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the test succeeds, we refactor the code added to keep it tidy, clean, and
    the minimal needed for a maintainable and extensible application.
  prefs: []
  type: TYPE_NORMAL
- en: We run all the tests again, to verify that our refactoring has not broken anything,
    and if the tests are again satisfied and no more refactoring is needed, we finish
    our task.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests after refactoring is an incredible safety net that has been
    put in place by this methodology. If we made a mistake refactoring an algorithm,
    extracting variables, introducing parameters, changing signatures, or whatever
    the refactoring mechanism, this testing infrastructure will detect the problem.
    Furthermore, if some refactoring or optimization could not be valid for every
    possible case, we can verify it for every case used by the application expressing
    this as a test case.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Personally, the main advantage I've seen so far is that it quickly focuses you
    on your programming goal, and it is harder to get distracted or eager, and implement
    options in your software that will never be used (sometimes known as gold plating).
    This implementation of unneeded features is a waste of your precious development
    time and as you may already know, judiciously administering these resources may
    be the difference between successfully reaching the end of the project or not.
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage is that you always have a safety net for your changes. Every
    time you change a piece of code, you can be absolutely sure that other parts of
    the system are not affected, as long as there are tests verifying that the conditions
    haven't changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget, TDD cannot be indiscriminately applied to any project. I think
    that, as well as any other technique; you should use your judgment and expertise
    to recognize where it can be applied and where not. Always remember: *there are
    no silver bullets*.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to write a test about any subject, we should first understand the
    subject under test, this means breaking apart the requirement you are attempting
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that one of the advantages is that you focus upon a goal quickly,
    instead of revolving around the requirements as a big, unconquerable whole.
  prefs: []
  type: TYPE_NORMAL
- en: Translating requirements into tests and cross referencing them is perhaps the
    best way to understand the requirements, and to be sure that there is always an
    implementation and verification for all of them. Also, when the requirements change
    (something that is very frequent in software development projects), we can change
    the tests verifying these requirements, and then change the implementation to
    be sure that everything was correctly understood and mapped to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample project – the temperature converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have guessed it from some of the code snippets so far, that our TDD
    examples will revolve around an extremely simple Android sample project. It doesn't
    try to show all the fancy Android features, but focuses on testing and gradually
    building the application from the test, applying the concepts learned before.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that we have received a list of requirements to develop an Android
    temperature converter application. Though oversimplified, we will be following
    the steps you normally would, to develop such an application. However, in this
    case we will introduce the Test-driven Development techniques in the process.
  prefs: []
  type: TYPE_NORMAL
- en: List of requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually (let's be honest), the list of requirements are very vague, and there
    are a high number of details not fully covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s pretend that we receive this list:'
  prefs: []
  type: TYPE_NORMAL
- en: The application converts temperatures from Celsius to Fahrenheit and vice-versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface presents two fields to enter the temperatures; one for Celsius
    the other for Fahrenheit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a temperature is entered in one field, the other one is automatically updated
    with the conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some space in the user interface should be reserved for the on-screen keyboard,
    to ease the application operation when several conversions are entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry fields should start empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values entered are decimal values with two digits after the point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits are right aligned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last entered values should be retained even after the application is paused
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface concept design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we receive this conceptual user interface design from the
    user interface design team (I apologize right now to all designers for my lack
    of imagination and skill):'
  prefs: []
  type: TYPE_NORMAL
- en: '![User interface concept design](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first step is to create the project. Now, since we have done this for five
    chapters already I don''t think I need to give you a step-by-step guide. Just
    run through the Android Studio new project wizard, and select an Android mobile
    project with your package name, plus other boilerplate, and no Activity template.
    Android Studio will automatically create you an example `AndroidApplicationTestCase`.
    Bear in mind, if you get stuck, you can refer to the code accompaniment for this
    book. When created, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the project](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's quickly create a new Activity called `TemperatureConverterActivity`
    (we didn't use the template generator, because it adds loads of code that is not
    needed right now), don't forget to add the Activity to your `AndroidManifest`
    file. Fanatic TDD'ers might be shaking their fist right now, as really you should
    make this Activity only when needed in your tests, but I'm trying to guide you
    with some familiarity at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Java module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On top of this template project, we want to add another module of code. This
    will be a Java-only module and will act as a dependency or library, if you will,
    for our main Android module.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is two-fold. First, it allows you to separate code that is Java
    only, and does not have a dependency on Android, in a big project this can be
    your core domain; the business logic that runs your app, and it is important that
    you modularize this, so you can work on it without having to think about Android
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, having a Java-only module as we've said before, allows you to call
    on the vast history of Java as an established programming language when it comes
    to testing. Testing of the Java module is fast, simple, and easy. You can write
    JUnit tests for the JVM and have them running in milliseconds (which we will do!).
  prefs: []
  type: TYPE_NORMAL
- en: 'From Android Studio, navigate to **File** | **New Module,** this gives you
    the **Create new module** dialog. Under **More Modules**, select **Java Library,**
    and hit **Next**. Name your library `core`, and ensure the package name is the
    same as your Android application, and press on **Finish**. The last screen should
    have looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Java module](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, you need to add the one-way dependency from your Android `:app`
    module to the `:core` module. Within, `/app/build.gradle,` add the dependency
    on core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to reference files from our core module inside of our Android
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TemperatureConverterActivityTests class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proceed with creating the first test by selecting the main test package name,
    `com.blundell.tut.` This is under `src/androidTest/Java` in the AndroidStudio
    project view, or under `app/java/(androidTest)` in the AndroidStudio Android view.
    Then right-click here, and select **New** | **Java Class**, call it, `TemperatureConverterActivityTests`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the class is created, we need to go about turning it into a test class.
    We should select our superclass depending on what and how we are going to test.
    In [Chapter 2](part0020_split_000.html#page "Chapter 2. Understanding Testing
    with the Android SDK"), *Understanding Testing with the Android SDK*, we reviewed
    the available alternatives. Use it as a reference when you try to decide what
    superclass to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we are testing a single Activity and using the system
    infrastructure, therefore, we should use `ActivityInstrumentationTestCase2`. Also
    note that as `ActivityInstrumentationTestCase2` is a generic class, we need the
    template parameter as well. This is the Activity under test, which in our case,
    is `TemperatureConverterActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: We now notice that our class has some errors we need to fix before running.
    Otherwise the errors will prevent the test from running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem we need to fix has been described before in [Chapter 2](part0020_split_000.html#page
    "Chapter 2. Understanding Testing with the Android SDK"), *Understanding Testing
    with the Android SDK*, under the *The no-argument constructor* section. As this
    pattern dictates, we need to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far we have performed the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the no argument constructor `TemperatureConverterActivityTests()`.
    From this constructor, we invoke the constructor that takes a name as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in this given name constructor, we invoke the super constructor and
    set the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify that everything has been set up and is in place, you may run the
    tests by right clicking on the class, and selecting **Run** | **The Name of the
    Test Class**. There are no tests to run yet, but at least we can verify that the
    infrastructure supporting our tests is already in place. It should fail with a
    **No tests** found warning. Here is how to run the test class, in case you missed
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the TemperatureConverterActivityTests class](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start creating our test fixture by populating the `setup()` method with
    the elements we need in our tests. Almost unavoidable, in this case, is the use
    of the Activity under test, so let''s prepare for the situation and add it to
    the fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After introducing the previous code, create the `activity` field using AndroidStudio's
    refactoring tools to save you time. (*F2* for next error, *Alt* + *Enter* for
    quick fix, *Enter* again to create field, *Enter* again to confirm the fields
    type, done!)
  prefs: []
  type: TYPE_NORMAL
- en: The `ActivityInstrumentationTestCase2.getActivity()` method has a side effect.
    If the Activity under test is not running, it will be started. This may change
    the intention of a test if we use `getActivity()` as a simple accessor several
    times in a test, and for some reason the Activity finishes or crashes before test
    completion. We will be inadvertently restarting the Activity, that is why in our
    tests we discourage the use of `getActivity()` in favor of having it in the fixture,
    so that we are implicitly restarting the activity for every test.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back to our Test-driven Development track, we see from our concise list of requirements
    that there are two entries for Celsius and Fahrenheit temperatures, respectively.
    So let's add them to our test fixture.
  prefs: []
  type: TYPE_NORMAL
- en: They don't exist yet, and we haven't even started designing the user interface
    layout, but we know that there should be two entries like these for sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code you should add to the `setUp()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some important things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: We choose the names `converter_celsius_input` because, converter_ is the location
    of this field (in the `TemperatorConverter` Activity) `celsius_` is what the field
    represents, and finally input is how the fields behave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the fields for our fixture using `EditText`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the previously created Activity to find the Views by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `R` class for the main project even though these IDs do not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the existence of the user interface components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have added them to the `setUp()` method, as indicated in the previous
    section, we can write our first test and check the views existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are not able to run the tests yet because we must fix some compilation problems
    first. We should fix the missing IDs in the `R` class.
  prefs: []
  type: TYPE_NORMAL
- en: Having created our test fixture that references elements and IDs in the user
    interface that we don't have yet, it's mandated by the Test-driven Development
    paradigm that we add the needed code to satisfy our tests. The first thing we
    should do is get the test to compile, so if we have some tests testing unimplemented
    features, they will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the IDs defined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first stop would be to have the IDs for the user interface elements defined
    in the `R` class, so the errors generated by referencing undefined constants `R.id.converter_celsius_input`
    and `R.id.converter_fahrenheit_input` go away.
  prefs: []
  type: TYPE_NORMAL
- en: 'You, as an experienced Android developer, will know how to do it. I''ll give
    you a refresher anyway. Create an `activity_temperature_converter.xml` layout
    in the layout editor, and add the required user interface components to get something
    that resembles the design previously introduced in the *User Interface concept
    design* section, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so, we get our tests to compile (don''t forget to add the strings and
    dimensions), run the tests, do they pass? They shouldn''t! You need to hook up
    your new activity layout (I bet you beat me to it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests once more, and you should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: The `testHasInputFields` test succeeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is green now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the test is seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the IDs defined](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This clearly means that we are on track with applying TDD.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that we added some decorative and non-functional items
    to our user interface that we are not testing (say padding), mainly to keep our
    example as simple as possible. In a real-case scenario, you may want to add tests
    for these elements too.
  prefs: []
  type: TYPE_NORMAL
- en: Translating requirements to tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tests have a double feature. They verify the correctness of our code but, sometimes,
    and more prominently in TDD, they help us understand the design and digest what
    we are implementing. To be able to create the tests, we need to understand the
    problem we are dealing with, and if we don't, we should at least have a rough
    outline of the problem to allow us to start to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, the requirements behind the user interface are not clearly expressed,
    but you should be able to understand them from the wireframed UI design. If we
    pretend that this is the case, then we can grasp the design by writing our tests
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Empty fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From one of our requirements, we get: Entry fields should start empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To express this in a test, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply compare the initial contents of the fields against the empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: This test passes straight away, great! Although a tenant of TDD always starts
    with a red test, you might want to do a quick sanity check, and add some text
    to the XML for `EditText` and run the tests, and when it goes red and green again
    when you remove the added text, you know your test is validating the behavior
    you expect (and it wasn't green as a side effect of something you did not expect).
    We successfully converted one requirement to a test, and validated it by obtaining
    the test results.
  prefs: []
  type: TYPE_NORMAL
- en: View properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Identically, we can verify other properties of the Views composing our layout.
    Among other things, we can verify:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields (appear on the screen as expected)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start verifying that the fields are on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained before, we use an assert from here: `ViewAsserts`: `assertOnScreen`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static imports and how to make the most of them was explained in [Chapter 2](part0020_split_000.html#page
    "Chapter 2. Understanding Testing with the Android SDK"), *Understanding Testing
    with the Android SDK*. If you haven't done it before, now is the time.
  prefs: []
  type: TYPE_NORMAL
- en: The `assertOnScreen()` method needs an origin to start looking for the other
    Views. In this case, because we want to start from the top-most level, we use
    `getDecorView()`, which retrieves the top-level window view containing the standard
    window frame and decorations, with the client's content inside.
  prefs: []
  type: TYPE_NORMAL
- en: By running this test, we can ensure that the entry fields are on the screen,
    as the UI design dictates. In some way, we already knew that Views, with these
    specific IDs, existed. That is, we made the fixture compile by adding the Views
    to the main layout, but we were not sure they were appearing on the screen at
    all. So, nothing else is needed but the sole presence of this test, to ensure
    that the condition is not changed in the future. If we remove one of the fields
    for some reason, this test will tell us that it is missing, and not complying
    with the UI design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following with our list of requirements, we should test that the Views are
    aligned in the layout as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue using asserts from `ViewAssert`—in this case, `assertLeftAligned`
    and `assertRightAligned`. These methods verify the alignment of the specified
    Views. To get this test running we have to add the two lookups for the label TextView''s
    in the `setUp()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `LinearLayout` class we are using by default arranges the fields in the
    way we are expecting them. Again, while we don't need to add anything to the layout,
    to satisfy the test, this will act as a guard condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve verified that they are correctly aligned, we should verify that
    they are covering the whole screen width, as specified by the schematic drawing.
    In this example, it''s sufficient to verify `LayoutParams` having the correct
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We used a custom message to easily identify the problem, in case the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this test, we obtain the following message indicating that the test
    failed: **AssertionFailedError: celsiusInput layout width is not MATCH_PARENT
    expected:<-1> but was:<-2>**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to the layout definition. We must change `layout_width` to be
    `match_parent` for the Celsius and Fahrenheit fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Same for Fahrenheit—after the change is done, we repeat the cycle, and by running
    the test again, we can verify that it is now successful.
  prefs: []
  type: TYPE_NORMAL
- en: Our method is starting to appear. We create the test to verify a condition described
    in the requirements. If it's not met, we change the cause of the problem, and
    running the tests again, we verify that the latest change solves the problem,
    and what is perhaps more important is that the change doesn't break the existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s verify that the font sizes are defined as per our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the font size used by the field is enough in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The default font size is not `24px`, so we need to add this to our layout. It's
    a good practice to add the corresponding dimension to a resource file, and then
    use it where it's needed in the layout. So, let's add `label_text_size` to `res/values/dimens.xml,`
    with a value of `24sp`. Then reference it in the `Text` `size` property of the
    labels, `celsius_label` and `fahrenheit_label`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the test may pass or it may not, depending on the resolution of your device
    or emulator you are using. This is because we are asserting in the test, the pixel
    size, but we have declared in the `dimens.xml,` to use `sp` (scale independent
    pixels). Let''s harden this test. To resolve this we could either convert our
    `px` to `sp` in the test class, or use the `sp` value in the test. I have chosen
    to use `sp` in the test, although you could argue for either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s verify that margins are interpreted as described in the user
    interface design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a similar case as before (I've skipped the step of testing the raw pixel
    value). We need to add the margin to our layout. Let's add the margin dimension
    to the resource file, and then use it where it's needed in the layout. Set the
    `margin` dimension in `res/values/dimens.xml` to a value of `8dp`. Then, reference
    it in the `layout_margin_start` property of both fields, `celsius` and `fahrenheit`,
    and also in the `start` `margin` of the labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helper` method to get the integer pixel size from a resource `dimen,`
    just wraps the `float` method already discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'One more thing that is left is to verify the justification (alignment) of the
    entered values. We will validate the input shortly, to allow only the permitted
    values, but for now let''s just pay attention to the justification. The intention
    is to have values that are smaller than the whole field, justified to the right
    and vertically centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we verify the `gravity` values as usual. However, we are using a custom
    message to help us identify the values that could be wrong. As the `Gravity` class
    defines several constants whose values are better identified if expressed in hexadecimal,
    we are converting the values to this base in the message.
  prefs: []
  type: TYPE_NORMAL
- en: If this test is failing due to the default gravity used for the fields, then
    what is only left is to change it. Go to the layout definition and alter these
    `gravity` values, so that the test succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is precisely what we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now want to verify that the requirement specifying that enough screen space
    should be reserved to display the keyboard, is actually fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This verifies that the actual position of the last field in the screen, which
    is `fahrenheitInput`, is not lower than a suggested value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tests again verifying that everything is green again. Run up
    your application, and you should have a complete user interface backed by tests,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen layout](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user interface is in place. Now, we can start adding some basic functionality.
    This functionality will include the code to handle the actual temperature conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Temperature conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the list of requirements, we can obtain this statement: When one temperature
    is entered in one field, the other one is automatically updated with the conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following our plan, we must implement this as a test to verify that the correct
    functionality is there. Our test would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run through this step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, as we already know, to interact with the UI changing its values we
    should run the test on the UI thread, and thus because we use `EditText.setText`,
    the test is annotated with `@UiThreadTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, we are using a specialized class to replace `EditText` providing some
    convenience methods such as `clear()` and `setNumber()`. This will improve our
    application design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we invoke a converter, named `TemperatureConverter`, a utility class providing
    the different methods to convert between different temperature units, and using
    different types for the temperature values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, as we will be truncating the results to provide them in a suitable
    format presented in the user interface, we should compare against a delta to assert
    the value of the conversion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the test like this will force us to follow the planned path. Our first
    objective is to add the needed methods and code to get the test to compile, and
    then to satisfy the test's needs.
  prefs: []
  type: TYPE_NORMAL
- en: The EditNumber class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our main package, not in the tests one (which is not the one under `/androidTest/`),
    we should create the `EditNumber` class extending `EditText,` as we need to extend
    its functionality. Once the class is created, we need to change the type of the
    fields in our test class member types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, change any cast that is present in the tests. Your IDE will highlight
    these; press *F2* to find them in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are still two problems we need to fix before being able to compile the
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: We still don't have the `clear()` and `setNumber()`methods in `EditNumber`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have the `TemperatureConverter` utility class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From inside our test class, we can use the IDE to help us create the methods.
    Press *F2* again, and you should be taken to the error for **Cannot resolve method
    clear()**. Now press *Alt* + *Enter* to create the `clear()`method in type `EditNumber`.
    Same for `getNumber()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must create the `TemperatureConverter` class. This class will hold
    the mathematical conversions of Celsius and Fahrenheit, and no Android code. Therefore,
    we can create this package inside of our `/core/` module. As previously discussed,
    it will be under the same package structure, only this module does not know about
    Android and, therefore, we can write JVM tests that run much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to create it in the core module under the same package as your main
    code, and not in the test package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to create that class in the core module, and the current state
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber class](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Having done this, in our test, it creates the `fahrenheitToCelsius` method.
  prefs: []
  type: TYPE_NORMAL
- en: This fixes our last problem, and leads us to a test that we can now compile
    and run. Yes you will have red Lint errors, but these are not "compile" errors,
    and so the tests can still run. (AndroidStudio's cleverness is too damn high.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, or not, when we run the tests, they will fail with an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That is because we updated all of our Java files to include our newly created
    `EditNumber` class, but forgot to change the layout XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to update our UI definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That is, we replace the original `EditText` class by `com.blundell.tut.EditNumber,`
    which is a View extending the original `EditText` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we run the tests again, and we discover that all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute; we haven't implemented any conversion or any handling of
    values in the new `EditNumber` class, and all tests passed with no problem. Yes,
    they passed because we don't have enough restrictions in our system and the ones
    in place, simply cancel themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Before going further, let's analyze what just happened. Our test invoked the
    `fahrenheitInput.setText ("32.5")` method to set the temperature entered in the
    **Fahrenheit** field, but our `EditNumber` class doesn't do anything when text
    is entered, and the functionality is not implemented. So, the **Celsius** field
    remains empty.
  prefs: []
  type: TYPE_NORMAL
- en: The value for `expectedC`—the expected temperature in Celsius, is calculated
    invoking `TemperatureConverter.fahrenheitToCelsius(f)`, but this is an empty method.
    In this case because we knew the return type of the method we made it return to
    a constant `0`. So, `expectedC` becomes `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the actual value for the conversion is obtained from the UI. In this case
    invoking `getNumber()` from `EditNumber`. But this method was automatically generated,
    and to satisfy the restriction imposed by its signature, it must return a value,
    namely `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The delta value is again `0`, as calculated by `Math.abs(expectedC` `–` `actualC)`.
  prefs: []
  type: TYPE_NORMAL
- en: And finally our assertion `assertTrue(msg,` `delta` `<` `0.005)` is `true,`
    because `delta=0` satisfies the condition, and the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: So, is our methodology flawed, as it cannot detect a simple situation like this?
  prefs: []
  type: TYPE_NORMAL
- en: No, not at all, the problem here is that we don't have enough restrictions,
    and they are satisfied by the default values used by auto-generated methods. One
    alternative could be to throw exceptions at all of the auto-generated methods,
    something like `RuntimeException("not` `yet` `implemented")` to detect its use
    when not implemented. We will be adding enough restrictions in our system to easily
    trap this *double zero* condition.
  prefs: []
  type: TYPE_NORMAL
- en: The TemperatureConverter unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems, from our previous experience, that the default conversion implemented
    always returns `0`, so we need something more robust. Otherwise, our converter
    will only be returning a valid result, when the parameter takes the value of 32F
    (32F == 0C).
  prefs: []
  type: TYPE_NORMAL
- en: The `TemperatureConverter` class is a utility class not related with the Android
    infrastructure, so a standard unit test will be enough to test it.
  prefs: []
  type: TYPE_NORMAL
- en: As this is the first core test we are going to write, we need to do some setup.
    Firstly, from the project view; in your project structure create a `test` folder
    under `/core/src` by selecting **New** | **Directory** and using the name `test`.
    Inside this, create a `java` folder by selecting **New** | **Directory,** and
    using the name `java`. With Gradle being magic, it will now understand that this
    is a place you want to add tests, and the folder should turn green (green means
    that the folder is a part of the test classpath). Now add a new package, technically
    it is not new because we are going to use `com.blundell.tut` again, by selecting
    **New** | **Package** | and using the name `com/blundell/tut`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now. we create our tests in our new folder and package. We create our tests
    by selecting **New** | **Java Class**, and calling it `TemperatureConverterTests`.
    Your project should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TemperatureConverter unit tests](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make our first test, inside of `TemperatureConverterTests,` press *Ctrl*
    + *Enter* to bring up the **Generate** menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TemperatureConverter unit tests](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting the **Test Method** test, then **JUnit4** will generate us a template
    method of a test that we want, name it `testFahrenheitToCelsius()`. Remember this
    shortcut as it''s handy whenever creating a new test. Once you''ve generated this
    test, you''ll notice we have compile errors on the JUnit 4 imported lines of code.
    Oops! we forgot to add the JUnit library to the test classpath of our core module.
    Open up the build file in `/core/build.gradle,` and add the JUnit dependency.
    Your core `build.gradle` will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice, here we have jumped from JUnit3 to JUnit4 the main difference being
    we can now use annotations to tell our test runner, which of the methods in the
    class are tests. Therefore, technically we don't need to start the methods with
    `test` as in `testFooBar()` anymore, but we will for our own sanity when swopping
    between the two (Android JUnit4 support is coming soon!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Do a project sync by selecting **Project Sync,** and we are compiling and ready
    to code. Let''s start writing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a conversion table with values for different temperature conversion,
    we know from other sources, would be a good way to drive this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To run tests in the core module, we can right click on the file in the project
    view, and select **Run**. As the screenshot also shows, you can use the shortcut
    *Cmd* + *Shift* + *F10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TemperatureConverter unit tests](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When this test runs, we verify that it fails, giving us this trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See how fast those core tests ran! Aim for moving as much of your application
    logic into your core module as you can, so you can take advantage of this speed
    when doing Test-driven Development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this was something we were expecting as our conversion always returns
    `0`. Implementing our conversion, we discover that we need some `ABSOLUTE_ZERO_F`
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Absolute zero, is the theoretical temperature at which entropy would reach its
    minimum value. To be able to reach this absolute zero state, according to the
    laws of thermodynamics, the system should be isolated from the rest of the universe.
    Thus, it is an unreachable state. However, by international agreement, absolute
    zero is defined as 0K on the Kelvin scale, and as -273.15°C on the Celsius scale
    or to -459.67°F on the Fahrenheit scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating a custom exception, `InvalidTemperatureException`, to indicate
    a failure providing a valid temperature to the conversion method. This exception
    doesn''t know anything about Android, and so can also sit in our core module.
    Create it by extending `RuntimeException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Running the core tests again, we discover that `testFahrenheitToCelsius` succeeds.
    Therefore, we move back to our Android tests, and running these show us such that
    `testFahrenheitToCelsiusConversion` test fails. This tells us, that now the converter
    class correctly handles conversions, but there are still some problems with the
    UI handling this conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't despair about running two separate test classes. It is common for you
    to be selective about what tests to run; this is partly a learnt skill when doing
    TDD. However, if you so wish, you can write custom test runners that will run
    all of your tests. Also, using Gradle to run `build connectedAndroidTest` will
    run all your tests at once, which is advised whenever you consider you have completed
    a feature, or want to commit to your upstream version control.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the `testFahrenheitToCelsiusConversion` failure trace reveals
    that there's something still returning `0,` when it shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: This reminds us that we are still lacking a proper `EditNumber` implementation.
    Before proceeding to implement the mentioned methods, let's create the corresponding
    tests to verify what we are implementing is correct.
  prefs: []
  type: TYPE_NORMAL
- en: The EditNumber tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the previous chapter, we can now determine that the best base class for
    our custom View tests is `AndroidTestCase`, as we need a mock `Context` class
    to create the custom View, but we don't need system infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Create the tests for `EditNumber`, let's call it `EditNumberTests,` and extend
    `AndroidTestCase`. Reminder, this is under the app module in the `androidTest`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the constructors to reflect the pattern we identified before
    with the given name pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the fixture. In this case, this is a simple `EditNumber`
    class that we will be testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The mock context is obtained from the protected field `mContext` ([http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext](http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext)),
    available in the `AndroidTestCase` class.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `setUp` method, we set `editNumber` as a focusable View, meaning
    it will be able to gain focus, as it will be participating in a bunch of tests
    simulating UIs that may need to request its focus explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test that the required `clear()` functionality is implemented correctly
    in the `testClear()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test we verify that it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We need to implement `EditNumber.clear()` correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple case, so just by adding this implementation to `EditNumber,`
    we satisfy the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test and proceed. We are going to add a new method to `EditNumber.`
    Here, we already have `getNumber(), and` we are adding `setNumber()` so that we
    can use it later on. Now let''s complete the `testSetNumber()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Which fails unless we implement `EditNumber.setNumber()`, similar to this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We are using a constant, `DEFAULT_FORMAT`, to hold the desired format to convert
    the numbers. This can be later converted to a property that could also be specified
    in the XML layout definition of the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for the `testGetNumber()` and `getNumber()` pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `getNumber()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These tests succeed, so run your other tests to see where we are up to; I did
    this on the command line running the `gradlew build cAT` command. This runs all
    of the tests we have written so far; but `testFahrenheitToCelsiusConversion()`
    is failing. We have a lot of well tested code, take a step back, and reflect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are our Android test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber tests](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are our core Java test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber tests](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With `testFahrenheitToCelsiusConversion()` if you closely analyze the test case,
    can you can discover where the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Got it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test method is expecting the conversion to happen automatically when the
    focus changes, as was specified in our list of requirements: "when one temperature
    is entered in one field, the other one is automatically updated with the conversion".'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we don't have buttons or anything else to convert temperature values,
    so the conversion is to be done automatically, once the values are entered.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us back to our `TemperatureConverterActivity` class, and the way
    it handles the conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The TemperatureChangeWatcher class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of implementing the required behavior of constantly updating the other
    temperature value, is once the original has changed is through a `TextWatcher`.
    From the documentation, we can understand that a `TextWatcher` is an object of
    a type that is attached to an `Editable`; its methods will be called, when the
    text is changed ([http://developer.android.com/reference/android/text/TextWatcher.html](http://developer.android.com/reference/android/text/TextWatcher.html)).
  prefs: []
  type: TYPE_NORMAL
- en: It seems that is what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement this class as an inner class of `TemperatureConverterActivity`.
    The idea behind this is, because we act directly on the Views of the Activity,
    having it as an inner class shows this relationship, and keeps it obvious, should
    someone think of changing this Activity''s layout. If you implement the minimum
    `TextWatcher,` your Activity will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And now this is our code, after some additions to the recently created class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the same `TemperatureChangeWatcher` implementation for both
    fields, Celsius and Fahrenheit; therefore we keep a reference to the fields used
    as source and destination, as well as the operation needed to update their values.
    To specify this operation, we are introducing `enum,` which is pure Java and so
    can go into the core module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This operation is specified in the creation factory methods, and the destination
    and source `EditNumber` are selected accordingly. This way we can use the same
    watcher for different conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The method of the `TextWatcher` interface we are interested in, is `onTextChanged`.
    This will be called any time the text changes. At the beginning, we avoid potential
    loops, checking who has focus, and returning if the conditions are not met.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the destination field as an empty string, if the source is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we try to set the resulting value of invoking the corresponding conversion
    method to set the destination field. We flag the error as necessary, avoiding
    showing premature errors, when the conversion was invoked with a partially entered
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set the listener on the input fields in `TemperatureConverterActivity.onCreate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To be able to run the tests, we should compile them. To compile, we need to
    at least define the `celsiusToFahrenheit()` method, which is not yet defined.
  prefs: []
  type: TYPE_NORMAL
- en: More TemperatureConverter tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to implement `celsiusToFahrenheit,` and as usual we start from the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fairly equivalent to the other conversion method `fahrenheitToCelsius,`
    and we can use the infrastructure we devised while creating this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We use the conversion table to exercise the method through different conversions,
    and we verify that the error is less than a predefined delta.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the correspondent conversion implementation in the `TemperatureConverter`
    class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, all the tests are passing but we are still not testing all the common conditions.
    What I mean by this is that we have been checking the happy path so far. You should
    check whether errors and exceptions are correctly generated, besides all the normal
    cases we created so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create this test to check the correct generation of exceptions, when a temperature
    below absolute zero is used in a conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we decrement the absolute zero temperature, to obtain an even
    smaller value, and then we attempt the conversion. We wrote this test in our core
    module, and therefore used JUnit4, which allows us to use annotations to assert
    that we expect an exception to be thrown. If you wanted to do the same thing in
    JUnit3, you would have to use a try catch block, and fail the test if the code
    did not enter the catch block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In a similar manner, we test for the exception being thrown, when the attempted
    conversion involves a temperature in Celsius, that is lower than the absolute
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: The InputFilter tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another error requirement could be: We want to filter the input that is received
    by the conversion utility, so no garbage reaches this point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EditNumber` class already filters valid input, and generates exceptions
    otherwise. We can verify this condition by creating a new test in `TemperatureConverterActivityTests`.
    We choose this class because we are sending keys to the entry fields, just as
    a real user would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This test requests the focus onto the Celsius field using the pattern reviewed
    previously. This allows us to run parts of a test in the UI thread, and send key
    input to the view. The keys sent are an invalid sequence containing more than
    one period, which is not accepted for a well-formed decimal number. It is expected
    that when the filter is in place, this sequence will be filtered, and only the
    valid characters reach the field. Asserting that the value returned by `celsiusInput.getNumber(),`
    is what we expect after filtering.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this filter, we need to add `InputFilter` to `EditNumber`. Because
    this should be added to all of the constructors, we create an additional `init()`method,
    which we invoke from each. To achieve our goal we use an instance of `DigitsKeyListener,`
    accepting digits, signs, and decimal points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This `init` method is invoked from each constructor, so that if this view is
    used programmatically or from XML, we still have our filter.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests again, we can verify that all have passed, and now everything
    is green again.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing our final application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! We now have our final application that satisfies all the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot we are showing one of these requirements, which
    is the detection of an attempt to convert a temperature below the absolute zero
    temperature in Celsius (-1000.00C):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing our final application](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The UI respects the guidelines provided; the temperatures can be converted by
    entering them in the corresponding unit field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, this is the list of requirements that we have implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: The application converts temperatures from Celsius to Fahrenheit, and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface presents two fields to enter the temperatures, one for Celsius
    and the other for Fahrenheit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one temperature is entered in one field, the other one is automatically
    updated with the conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some space in the user interface should be reserved for the on-screen keyboard,
    to ease the application operation when several conversions are entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry fields should start empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values entered are decimal values with two digits after the point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits are right aligned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is more important is that we can now be certain that the application not
    only satisfies the requirements, but also has no evident problems or bugs. We
    took every step by analyzing the test results, and fixing the problems at their
    first appearance. This will ensure that any individual bug, once discovered, tested
    and fixed, will not resurface again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We presented Test-driven Development introducing its concepts, and applying
    them step-by-step in a potential real-life problem.
  prefs: []
  type: TYPE_NORMAL
- en: We started with a concise list of requirements, describing the temperature converter
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented every test followed by the code that satisfies it. In this manner,
    we implemented the application behavior as well as its presentation, conducting
    tests to verify that the UI we designed follows the specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Having the tests in place, lead us to analyze the different possibilities we
    have in running them. Evolving from the previous chapter, now our continuous integration
    machine can run the tests to guarantee any changes from the team will still result
    in a well-tested application.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces Behavior-driven Development, and continues our aim
    for bug-free well-tested code, this time with a focus upon behavior and agreement,
    on what a requirement means throughout the team.
  prefs: []
  type: TYPE_NORMAL
