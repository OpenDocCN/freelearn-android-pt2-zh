["```kt\n    @Override\n    public EngineOptions onCreateEngineOptions() {\n\n      // Define our mCamera object\n      mCamera = new Camera(0, 0, WIDTH, HEIGHT);\n\n      // Declare & Define our engine options to be applied to our Engine object\n      EngineOptions engineOptions = new EngineOptions(true,\n          ScreenOrientation.LANDSCAPE_FIXED, new FillResolutionPolicy(),\n          mCamera);\n\n      // It is necessary in a lot of applications to define the following\n      // wake lock options in order to disable the device's display\n      // from turning off during gameplay due to inactivity\n      engineOptions.setWakeLockOptions(WakeLockOptions.SCREEN_ON);\n\n      // Return the engineOptions object, passing it to the engine\n      return engineOptions;\n    }\n    ```", "```kt\n    @Override\n    public void onCreateResources(\n        OnCreateResourcesCallback pOnCreateResourcesCallback) {\n\n      /* We should notify the pOnCreateResourcesCallback that we've finished\n        * loading all of the necessary resources in our game AFTER they are loaded.\n        * onCreateResourcesFinished() should be the last method called.  */\n      pOnCreateResourcesCallback.onCreateResourcesFinished();\n    }\n    ```", "```kt\n    @Override\n    public void onCreateScene(OnCreateSceneCallback pOnCreateSceneCallback) {\n      // Create the Scene object\n      mScene = new Scene();\n\n      // Notify the callback that we're finished creating the scene, returning\n      // mScene to the mEngine object (handled automatically)\n      pOnCreateSceneCallback.onCreateSceneFinished(mScene);\n    }\n    ```", "```kt\n    @Override\n    public void onPopulateScene(Scene pScene,\n      OnPopulateSceneCallback pOnPopulateSceneCallback) {\n\n      // onPopulateSceneFinished(), similar to the resource and scene callback\n      // methods, should be called once we are finished populating the scene.\n      pOnPopulateSceneCallback.onPopulateSceneFinished();\n    }\n    ```", "```kt\n    <org.andengine.opengl.view.RenderSurfaceView\n    android:id=\"@+id/gameSurfaceView\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"/>\n    ```", "```kt\n    @Override\n    protected int getLayoutID() {\n      return R.layout.main;\n    }\n\n    @Override\n    protected int getRenderSurfaceViewID() {\n      return R.id.gameSurfaceView;\n    }\n    ```", "```kt\n@Override\npublic void onCreateResourcesAsync(IProgressListener pProgressListener)\n    throws Exception {\n\n  // Load texture number one\n  pProgressListener.onProgressChanged(10);\n\n  // Load texture number two\n  pProgressListener.onProgressChanged(20);\n\n  // Load texture number three\n  pProgressListener.onProgressChanged(30);\n\n  // We can continue to set progress to whichever value we'd like\n  // for each additional step through onCreateResourcesAsync...\n}\n```", "```kt\n/* The onCreateEngine method allows us to return a 'customized' Engine object\n* to the Activity which for the most part affects the way frame updates are \n* handled. Depending on the Engine object used, the overall feel of the \n* gameplay can alter drastically. \n*/\n@Override\npublic Engine onCreateEngine(EngineOptions pEngineOptions) {\n  return super.onCreateEngine(pEngineOptions);\n  /* The returned super method above simply calls:\n      return new Engine(pEngineOptions);\n  */\n}\n```", "```kt\n    @Override\n    public Engine onCreateEngine(EngineOptions pEngineOptions) {\n      // Create a fixed step engine updating at 60 steps per second\n        return new FixedStepEngine(pEngineOptions, 60);\n      }\n    ```", "```kt\n    @Override\n    public Engine onCreateEngine(EngineOptions pEngineOptions) {\n      // Create a limited FPS engine, which will run at a maximum of 60 FPS\n      return new LimitedFPSEngine(pEngineOptions, 60);\n    }\n    ```", "```kt\nEngineOptions engineOptions = new EngineOptions(true,\n    ScreenOrientation.LANDSCAPE_FIXED, new FillResolutionPolicy(),\n    mCamera); \n```", "```kt\n    public static class BaseObject {\n\n      /* The mX and mY variables have no real purpose in this recipe, however in\n       * a real factory class, member variables might be used to define position,\n       * color, scale, and more, of a sprite or other entity.   */\n      private int mX;\n      private int mY;\n\n      // BaseObject constructor, all subtypes should define an mX and mY value on creation\n      BaseObject(final int pX, final int pY){\n        this.mX = pX;\n        this.mY = pY;\n      }\n    }\n    ```", "```kt\n    public class ObjectFactory {\n\n      // Return a new LargeObject with the defined 'x' and 'y' member variables.\n      public static LargeObject createLargeObject(final int pX, final int pY){\n        return new LargeObject(pX, pY);\n      }\n      // Return a new SmallObject with the defined 'x' and 'y' member variables.\n      public static SmallObject createSmallObject(final int pX, final int pY){\n        return new SmallObject(pX, pY);\n      }\n    }\n    ```", "```kt\n    private static GameManager INSTANCE;\n\n    // The constructor does not do anything for this singleton\n    GameManager(){\n    }\n\n    public static GameManager getInstance(){\n      if(INSTANCE == null){\n        INSTANCE = new GameManager();\n      }\n      return INSTANCE;\n    }\n    ```", "```kt\n    // get the current score\n    public int getCurrentScore(){\n      return this.mCurrentScore;\n    }\n\n    // get the bird count\n    public int getBirdCount(){\n      return this.mBirdCount;\n    }\n\n    // increase the current score, most likely when an enemy is destroyed\n    public void incrementScore(int pIncrementBy){\n      mCurrentScore += pIncrementBy;\n    }\n\n    // Any time a bird is launched, we decrement our bird count\n    public void decrementBirdCount(){\n      mBirdCount -= 1;\n    }\n    ```", "```kt\n    // Resetting the game simply means we must revert back to initial values.\n    public void resetGame(){\n      this.mCurrentScore = GameManager.INITIAL_SCORE;\n      this.mBirdCount = GameManager.INITIAL_BIRD_COUNT;\n      this.mEnemyCount = GameManager.INITIAL_ENEMY_COUNT;\n    }\n    ```", "```kt\n    engineOptions.getAudioOptions().setNeedsMusic(true);\n    engineOptions.getAudioOptions().setNeedsSound(true);\n    ```", "```kt\n    /* Set the base path for our SoundFactory and MusicFactory to\n      * define where they will look for audio files.\n     */\n    SoundFactory.setAssetBasePath(\"sfx/\");\n    MusicFactory.setAssetBasePath(\"sfx/\");\n\n    // Load our \"sound.mp3\" file into a Sound object\n    try {\n      Sound mSound = SoundFactory.createSoundFromAsset(getSoundManager(), this, \"sound.mp3\");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    // Load our \"music.mp3\" file into a music object\n    try {\n      Music mMusic = MusicFactory.createMusicFromAsset(getMusicManager(), this, \"music.mp3\");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    ```", "```kt\n    // Play the mSound object\n    mSound.play();\n    ```", "```kt\n    /* Music objects which loop continuously should be played in\n    * onResumeGame() of the activity life cycle\n    */\n    @Override\n    public synchronized void onResumeGame() {\n      if(mMusic != null && !mMusic.isPlaying()){\n        mMusic.play();\n      }\n\n      super.onResumeGame();\n    }\n\n    /* Music objects which loop continuously should be paused in\n    * onPauseGame() of the activity life cycle\n    */\n    @Override\n    public synchronized void onPauseGame() {\n      if(mMusic != null && mMusic.isPlaying()){\n        mMusic.pause();\n      }\n\n      super.onPauseGame();\n    }\n    ```", "```kt\n    mMusic.setOnCompletionListener(new OnCompletionListener(){\n      /* In the event that a Music object reaches the end of its duration,\n      * the following method will be called\n      */\n      @Override\n      public void onCompletion(MediaPlayer mp) {\n      // Do something pending Music completion\n      }\n    });\n    ```", "```kt\n    BitmapTextureAtlasTextureRegionFactory.setAssetBasePath(\"gfx/\");\n    ```", "```kt\n    // Create the texture atlas at a size of 120x120 pixels\n    BitmapTextureAtlas mBitmapTextureAtlas = new BitmapTextureAtlas(mEngine.getTextureManager(), 120, 120);\n    ```", "```kt\n    /* Create rectangle one at position (10, 10) on the mBitmapTextureAtlas */\n    ITextureRegion mRectangleOneTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBitmapTextureAtlas, this, \"rectangle_one.png\", 10, 10);\n\n    /* Create rectangle two at position (50, 10) on the mBitmapTextureAtlas */\n    ITextureRegion mRectangleTwoTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBitmapTextureAtlas, this, \"rectangle_two.png\", 50, 10);\n\n    /* Create rectangle three at position (10, 60) on the mBitmapTextureAtlas */\n    ITextureRegion mRectangleThreeTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBitmapTextureAtlas, this, \"rectangle_three.png\", 10, 60);\n    ```", "```kt\n    mBitmapTextureAtlas.load();\n    ```", "```kt\n/* Create a buildable bitmap texture atlas - same parameters required\n* as with the original bitmap texture atlas */\nBuildableBitmapTextureAtlas mBuildableBitmapTextureAtlas = new BuildableBitmapTextureAtlas(mEngine.getTextureManager(), 120, 120);\n\n/* Create the three ITextureRegion objects. Notice that when using \n * the BuildableBitmapTextureAtlas, we do not need to include the final\n * two pTextureX and pTextureY parameters. These are handled automatically! */\nITextureRegion mRectangleOneTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBuildableBitmapTextureAtlas, this, \"rectangle_one.png\");\nITextureRegion mRectangleTwoTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBuildableBitmapTextureAtlas, this, \"rectangle_two.png\");\nITextureRegion mRectangleThreeTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBuildableBitmapTextureAtlas, this, \"rectangle_three.png\");\n\n// Buildable bitmap texture atlases require a try/catch statement\ntry {\n  /* Build the mBuildableBitmapTextureAtlas, supplying a BlackPawnTextureAtlasBuilder\n    * as its only parameter. Within the BlackPawnTextureAtlasBuilder's parameters, we\n    * provide 1 pixel in texture atlas source space and 1 pixel for texture atlas source\n    * padding. This will alleviate the chance of texture bleeding.\n    */\n  mBuildableBitmapTextureAtlas.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 1, 1));\n} catch (TextureAtlasBuilderException e) {\n  e.printStackTrace();\n}\n\n// Once the atlas has been built, we can now load\nmBuildableBitmapTextureAtlas.load();\n```", "```kt\nTiledTextureRegion mTiledTextureRegion = BitmapTextureAtlasTextureRegionFactory.createTiledFromAsset(mBitmapTextureAtlas, context,\"sprite_sheet.png\",11,1);\n```", "```kt\nBitmapTextureAtlas mBitmapTextureAtlas = new BitmapTextureAtlas(mEngine.getTextureManager(), 1024, 1024, BitmapTextureFormat.RGB_565, TextureOptions.BILINEAR);\n```", "```kt\n    /* Create our repeating texture. Repeating textures require width/height which are a power of two */\n    BuildableBitmapTextureAtlas texture = new BuildableBitmapTextureAtlas(engine.getTextureManager(), 32, 32, TextureOptions.REPEATING_BILINEAR);\n\n    // Create our texture region - nothing new here\n    mSquareTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(texture, context, \"square.png\");\n\n    try {\n      // Repeating textures should not have padding\n      texture.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 0, 0));\n      texture.load();\n\n    } catch (TextureAtlasBuilderException e) {\n      Debug.e(e);\n    }\n```", "```kt\n/* Increase the texture region's size, allowing repeating textures to stretch up to 800x480 */\nResourceManager.getInstance().mSquareTextureRegion.setTextureSize(800, 480);\n// Create a sprite which stretches across the full screen\nSprite sprite = new Sprite(0, 0, 800, 480, ResourceManager.getInstance().mSquareTextureRegion, mEngine.getVertexBufferObjectManager());\n```", "```kt\n    Font mFont = FontFactory.create(mEngine.getFontManager(), mEngine.getTextureManager(), 256, 256, Typeface.create(Typeface.DEFAULT, Typeface.NORMAL),  32f, true, org.andengine.util.adt.color.Color.WHITE_ABGR_PACKED_INT)\n\n    mFont.load();\n    ```", "```kt\n    Font mFont = FontFactory.createFromAsset(mEngine.getFontManager(), mEngine.getTextureManager(), 256, 256, this.getAssets(), \"Arial.ttf\", 32f, true, org.andengine.util.adt.color.Color.WHITE_ABGR_PACKED_INT); \n\n    mFont.load();\n    ```", "```kt\n    BitmapTextureAtlas mFontTexture = new BitmapTextureAtlas(mEngine.getTextureManager(), 256, 256, TextureOptions.BILINEAR);\n\n    Font mFont = FontFactory.createStroke(mEngine.getFontManager(), mFontTexture, Typeface.create(Typeface.DEFAULT, Typeface.BOLD), 32, true, org.andengine.util.adt.color.Color.WHITE_ABGR_PACKED_INT, 3, org.andengine.util.adt.color.Color.BLACK_ABGR_PACKED_INT);\n\n    mFont.load();\n    ```", "```kt\nmFont.prepareLetters(\"abcdefghijklmnopqrstuvwxyz\".toCharArray())\n```", "```kt\n    /* The variables listed should be kept public, allowing us easy access\n    to them when creating new Sprites, Text objects and to play sound files */\n    public ITextureRegion mGameBackgroundTextureRegion;\n    public ITextureRegion mMenuBackgroundTextureRegion;\n    public Sound  mSound;\n\n    public Font  mFont;\n    ```", "```kt\n    public synchronized void loadGameTextures(Engine pEngine, Context pContext){\n    // Set our game assets folder in \"assets/gfx/game/\"\n        BitmapTextureAtlasTextureRegionFactory.setAssetBasePath(\"gfx/game/\");\n\n    BuildableBitmapTextureAtlas mBitmapTextureAtlas = new BuildableBitmapTextureAtlas(pEngine.getTextureManager(), 800, 480);\n\n    mGameBackgroundTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBitmapTextureAtlas, pContext, \"game_background.png\");\n\n    try {\n      mBitmapTextureAtlas.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 1, 1));\n      mBitmapTextureAtlas.load();\n    } catch (TextureAtlasBuilderException e) {\n      Debug.e(e);\n    }\n    }\n    ```", "```kt\n    public synchronized void unloadGameTextures(){\n      // call unload to remove the corresponding texture atlas from memory\n      BuildableBitmapTextureAtlas mBitmapTextureAtlas = (BuildableBitmapTextureAtlas) mGameBackgroundTextureRegion.getTexture();\n      mBitmapTextureAtlas.unload();\n\n      // ... Continue to unload all textures related to the 'Game' scene\n\n      // Once all textures have been unloaded, attempt to invoke the Garbage Collector\n      System.gc();\n    }\n    ```", "```kt\n@Override\npublic void onCreateResources(\n    OnCreateResourcesCallback pOnCreateResourcesCallback) {\n\n  // Load the game texture resources\n  ResourceManager.getInstance().loadGameTextures(mEngine, this);\n\n  // Load the font resources\n  ResourceManager.getInstance().loadFonts(mEngine);\n\n  // Load the sound resources\n  ResourceManager.getInstance().loadSounds(mEngine, this);\n\n  pOnCreateResourcesCallback.onCreateResourcesFinished();\n}\n```", "```kt\n    // Include a 'filename' for our shared preferences\n    private static final String PREFS_NAME = \"GAME_USERDATA\";\n\n    /* These keys will tell the shared preferences editor which\n      data we're trying to access */\n\n    private static final String UNLOCKED_LEVEL_KEY = \"unlockedLevels\";\n    private static final String SOUND_KEY = \"soundKey\";\n\n    /* Create our shared preferences object & editor which will\n     be used to save and load data */\n    private SharedPreferences mSettings;\n    private SharedPreferences.Editor mEditor;\n\n    // keep track of our max unlocked level\n    private int mUnlockedLevels;\n\n    // keep track of whether or not sound is enabled\n    private boolean mSoundEnabled;\n    ```", "```kt\n    public synchronized void init(Context pContext) {\n      if (mSettings == null) {\n        /* Retrieve our shared preference file, or if it's not yet\n          * created (first application execution) then create it now\n          */\n        mSettings = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);\n        /* Define the editor, used to store data to our preference file\n         */\n        mEditor = mSettings.edit();\n\n        /* Retrieve our current unlocked levels. if the UNLOCKED_LEVEL_KEY\n          * does not currently exist in our shared preferences, we'll create\n          * the data to unlock level 1 by default\n          */\n        mUnlockedLevels = mSettings.getInt(UNLOCKED_LEVEL_KEY, 1);\n\n        /* Same idea as above, except we'll set the sound boolean to true\n          * if the setting does not currently exist\n          */\n        mSoundEnabled = mSettings.getBoolean(SOUND_KEY, true);\n      }\n    }\n    ```", "```kt\n    /* retrieve the max unlocked level value */\n    public synchronized int getMaxUnlockedLevel() {\n      return mUnlockedLevels;\n    }\n    ```", "```kt\n    public synchronized void unlockNextLevel() {\n      // Increase the max level by 1\n      mUnlockedLevels++;\n\n      /* Edit our shared preferences unlockedLevels key, setting its\n       * value our new mUnlockedLevels value\n        */\n      mEditor.putInt(UNLOCKED_LEVEL_KEY, mUnlockedLevels);\n\n      /* commit() must be called by the editor in order to save\n        * changes made to the shared preference data\n       */\n      mEditor.commit();\n    }\n    ```"]