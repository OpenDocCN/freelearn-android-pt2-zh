- en: Chapter 6. Activating Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 激活模式
- en: The chapters up to this point have served as an extended introduction, exploring
    the practicalities of Android development and the theory of design pattern application.
    We have covered many of the fundamental components of an Android app and seen
    how some of the most useful patterns are made, but we have not yet put the two
    together.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节作为扩展介绍，探讨了Android开发的实用性以及设计模式应用的理论。我们已经涵盖了Android应用许多基本组件，并了解了最有用的模式是如何构建的，但我们还没有将这两者结合起来。
- en: In this chapter, we will build one of the main sections of our app, an ingredient
    selection menu. This will involve a scrollable list of fillings that can be selected,
    expanded, and dismissed. On the way, we will also take a look at the collapsible
    toolbar and one or two other handy support library features, adding functionality
    to action buttons, a floating action button, and an alert dialog.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建应用的一个主要部分：成分选择菜单。这将涉及一个可滚动的填充物列表，可以选中、展开和关闭。在途中，我们还将看看可折叠工具栏以及其他一两个有用的支持库功能，为操作按钮、浮动操作按钮和警告对话框添加功能。
- en: At the heart of this code, we will apply a simple factory pattern to create
    each ingredient. This will demonstrate nicely how this pattern hides creational
    logic from client classes. In this chapter, we will create only a single example
    of a filling type, to see how it is done, but the same structures and processes
    will be used later as more complexity is added. This will lead us to explore recycler
    view formats and decoration, such as grid layouts and dividers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码的核心，我们将应用一个简单的工厂模式来创建每个成分。这将很好地展示这种模式如何将创建逻辑从客户类中隐藏起来。在本章中，我们将只创建一个填充类型的示例，以了解其实现方式，但相同的结构和过程稍后会在添加更多复杂性时使用。这将引导我们探索回收视图格式和装饰，如网格布局和分隔线。
- en: We will then move on to generate and customize an alert dialog from the clicking
    of a button. This will require an inbuilt builder pattern and lead us on to see
    how we can create a builder pattern of our own for inflating layouts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续生成并自定义一个警告对话框，通过点击按钮来实现。这将需要使用内置的构建器模式，并引导我们了解如何为膨胀布局创建自己的构建器模式。
- en: 'In this chapter, you will learn how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Create an app-bar layout
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用栏布局
- en: Apply a collapsing toolbar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用可折叠工具栏
- en: Control scrolling behavior
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制滚动行为
- en: Include nested scroll views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含嵌套滚动视图
- en: Apply a data factory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用数据工厂
- en: Create a list item view
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建列表项视图
- en: Convert a text view into a button
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本视图转换为按钮
- en: Apply grid layouts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用网格布局
- en: Add divider decoration
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加分隔线装饰
- en: Configure action icons
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置操作图标
- en: Create an alert dialog
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建警告对话框
- en: Customize dialogs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义对话框
- en: Add a second activity
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加第二个活动
- en: Apply swipe and dismiss behavior
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用滑动和关闭行为
- en: Create a layout builder pattern
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建布局构建器模式
- en: Create a layout at runtime
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建布局
- en: Users of our app will need some way of selecting ingredients. We could of course
    present them with one long list, but this would be cumbersome and unattractive.
    Clearly, we need to split our ingredients into categories. In the following examples,
    we will concentrate on just one of these groups as this will help simplify the
    underlying processes for later on, when we will consider more complex scenarios.
    We will begin by creating the necessary layouts, starting with the collapsing
    toolbar layout.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用用户需要某种方式来选择成分。我们当然可以向他们展示一个长长的列表，但这会既麻烦又不吸引人。显然，我们需要将成分分类。在以下示例中，我们将专注于这些组中的一个，这将有助于简化稍后考虑更复杂场景时的底层过程。我们将从创建必要的布局开始，首先从可折叠工具栏布局开始。
- en: Collapsing toolbars
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可折叠工具栏
- en: Toolbars that slide out of the way conveniently are a common feature of material
    design UIs, and provide an elegant and clever way to make good use of the limited
    space available on phones and even laptops.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏能够方便地滑出是材料设计UI的一个常见特性，并为手机甚至笔记本电脑上有限的空间提供了优雅和聪明的利用方式。
- en: '![Collapsing toolbars](img/B05685_06_01-1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![可折叠工具栏](img/B05685_06_01-1.jpg)'
- en: As you would imagine the **CollapsingToolbarLayout** is part of the design support
    library. It is intended as a child of the **AppBarLayout**, which is a linear
    layout, designed specifically for material design features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，**CollapsingToolbarLayout**是设计支持库的一部分。它是**AppBarLayout**的子视图，后者是一个线性布局，专门为材料设计特性而设计。
- en: Collapsing toolbars help manage space elegantly and also provide a good opportunity
    to display attractive graphics and help promote our product. They take little
    time to implement and are easily adapted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠工具栏优雅地管理空间，也提供了一个展示吸引人图形和推广我们产品的好机会。它们实现起来不需要太多时间，而且很容易适应。
- en: 'The best way to see how they work is to build one, and the following steps
    demonstrate how to do this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看它们如何工作的最佳方式是构建一个，以下步骤将展示如何进行：
- en: Start a new project and include the both the recycler view and the design support
    libraries.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目，并包含回收视图和设计支持库。
- en: 'Remove the action bar by changing the theme to:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更改主题来移除操作栏：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `activity_main.xml` file and apply the following root layout:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 文件，并应用以下根布局：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside this, add this `AppBarLayout`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此内部，添加这个 `AppBarLayout`：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Place this `CollapsingToolbarLayout` inside the app-bar:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此 `CollapsingToolbarLayout` 放在应用栏内：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The contents of the collapsing toolbar are the following two views:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 折叠工具栏的内容是以下两个视图：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, below the app-bar layout, add this recycler view:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 app-bar 布局下方，添加这个回收视图：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, add this floating action button:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加这个浮动操作按钮：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Collapsing toolbars](img/image_06_002.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![折叠工具栏](img/image_06_002.jpg)'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is possible, and often desirable, to set the status bar to translucent so
    that our app-bar image can be seen behind it. This is achieved by adding the following
    two items to the styles.xml files:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时我们希望将状态栏设置为半透明，以便我们的应用栏图片能够显示在状态栏后面。这通过在 styles.xml 文件中添加以下两项来实现：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have already encountered the coordinator layout in a previous chapter and
    seen how it facilitates many material design functions. The `AppBarLayout` does
    a similar thing and is generally used as a container for collapsing toolbars.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中我们已经遇到了协调布局，并看到了它如何实现许多材料设计功能。`AppBarLayout` 做类似的事情，通常用作折叠工具栏的容器。
- en: The **CollapsingToolbarLayout**, on the other hand, needs one or two things
    explaining. Firstly, the use of `android:layout_height="wrap_content"` will produce
    different effects, depending on the height of the image its ImageView contains.
    This is done so that when we design alternative layouts for different screen sizes
    and densities, we can simply scale this image accordingly. Here it is configured
    for a small (480 x 854dp) 240dpi device and is 192dp tall. We could of course
    have set layout height in dp and scaled this value in the various `dimens.xml`
    files. We would however, still have had to scale the image, so this method kills
    two birds with one stone.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**CollapsingToolbarLayout** 需要解释一两个要点。首先，使用 `android:layout_height="wrap_content"`
    将根据其 ImageView 包含的图片高度产生不同的效果。这样做的目的是，当我们为不同的屏幕尺寸和密度设计替代布局时，我们可以相应地缩放此图像。这里配置的是小（480
    x 854dp）240dpi 设备，高度为192dp。当然，我们也可以在 dp 中设置布局高度，并在不同的 `dimens.xml` 文件中缩放此值。然而，我们仍然需要缩放图像，所以这个方法是一石二鸟。
- en: The other interesting point about the collapsing toolbar layout is the way we
    can control how it scrolls, and as you would imagine, this is dealt with by the
    **layout_scrollFlags** attribute. Here we used `scroll`, `exitUntilCollapsed`,
    `enterAlwaysCollapsed`. This means that the toolbar never disappears from the
    top of the screen and that the toolbar does not expand until the list can be scrolled
    no further down.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于折叠工具栏布局的另一个有趣点是我们可以控制它的滚动方式，正如你所想象的，这是通过 **layout_scrollFlags** 属性处理的。这里我们使用了
    `scroll`、`exitUntilCollapsed`、`enterAlwaysCollapsed`。这意味着工具栏永远不会从屏幕顶部消失，且当列表无法再向下滚动时，工具栏不会展开。
- en: 'There are five scroll flags, and they are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种滚动标志，它们是：
- en: '`scroll` - Enables scrolling'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scroll` - 启用滚动'
- en: '`exitUntilCollapsed` - Prevents the toolbar from disappearing when scrolling
    up (omit to lose the toolbar until scrolling down)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exitUntilCollapsed` - 当向上滚动时防止工具栏消失（省略此项，直到向下滚动时工具栏才会消失）'
- en: '`enterAlways` - Toolbar expands whenever the list scrolls down'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enterAlways` - 列表向下滚动时工具栏展开'
- en: '`enterAlwaysCollapsed` - Toolbar only expands from top of the list'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enterAlwaysCollapsed` - 工具栏仅从列表顶部展开'
- en: '`snap` - Toolbar snaps into place rather than gliding'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snap` - 工具栏直接定位而不是滑动'
- en: 'The image view within the collapsing toolbar is almost identical to any other
    image view we might have seen, apart from maybe the `layout_collapseMode` attribute.
    This has two possible settings, `pin` and `parallax`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠工具栏内的图像视图几乎与我们可能见过的任何其他图像视图相同，除了可能有的 `layout_collapseMode` 属性。这个属性有两个可能的设置，`pin`
    和 `parallax`：
- en: '`pin` - The list and toolbar move together'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pin` - 列表和工具栏一起移动'
- en: '`parallax` - The list and toolbar move separately'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`视差` - 列表和工具栏分别移动'
- en: The best way to appreciate these effects is simply to try them out. We could
    also have applied either of these layout collapse modes on the toolbar beneath
    the image, but as we want our toolbar to remain on screen, we need not concern
    ourselves with its collapsing behavior.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 欣赏这些效果的最佳方式就是尝试一下。我们也可以将这些布局折叠模式之一应用于图片下方的工具栏，但由于我们希望工具栏保持屏幕显示，因此无需关心其折叠行为。
- en: 'The recycler view that will contain our data here is different in only one
    respect from the one we used earlier in the book. That is the inclusion of the
    line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将包含我们数据的回收视图与本书前面使用的唯一区别在于包含以下这行：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This attribute is all we have to add to any view or view group that sits below
    the app bar, to allow the two to coordinate their scrolling behavior.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是我们需要添加到任何位于应用栏下方的视图或视图组中的，以允许它们协调滚动行为。
- en: These simple classes save us a great deal of work when it comes to implementing
    material design and leave us to concentrate on providing functionality. Apart
    from the size of the image, very little refactoring is required to create a layout
    that works on a large number of possible devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的类在实现材料设计时为我们节省了大量工作，并让我们专注于提供功能。除了图片的大小，要创建一个在大数量可能设备上工作的布局，几乎不需要重构。
- en: 'Although we are using a recycler view here, it is quite possible to put any
    number of views and view groups below the app-bar. Providing that they possess
    the `app:layout_behavior="@string/appbar_scrolling_view_behavior"` attribute,
    they will move in concord with the bar. There is one layout that particularly
    suits this purpose and that is the **NestedScrollView**. By way of example, it
    looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这里我们使用了回收视图，但完全有可能在应用栏下方放置任意数量的视图和视图组。只要它们具有`app:layout_behavior="@string/appbar_scrolling_view_behavior"`属性，它们就会与栏一起移动。有一个特别适合此目的的布局，那就是**NestedScrollView**。举个例子，它看起来像这样：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next logical step is to create a layout for populating the recycler view,
    but first we need to prepare the data. In this chapter, we will develop an application
    component responsible for presenting the user with a list of ingredients of a
    particular category, in this case cheese. We will use the **factory pattern**
    to create these objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步逻辑上是创建一个布局来填充回收视图，但首先我们需要准备数据。在本章中，我们将开发一个应用程序组件，负责向用户展示特定类别（在本例中是奶酪）的配料列表。我们将使用**工厂模式**来创建这些对象。
- en: Applying a data factory pattern
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用数据工厂模式
- en: In this section, we will apply a factory pattern to create objects of type *cheese*.
    This will in turn implement a *filling* interface. Each object will consist of
    several properties such as price and calorific value. Some of these values will
    be presented in our list items and others will be available only through an expanded
    view or accessible only via code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用工厂模式来创建类型为*奶酪*的对象。这将进而实现一个*填充物*接口。每个对象将由几个属性组成，如价格和热量值。其中一些值将在我们的列表项中展示，其他值则只能通过扩展视图或在代码中访问。
- en: One of the few disadvantages of design patterns is the large number of classes
    that soon accumulate. For this reason, before beginning the following exercise,
    create a new package inside the `java` directory, called `fillings`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式为数不多的缺点之一是很快就会累积大量的类。因此，在开始以下练习之前，请在`java`目录中创建一个名为`fillings`的新包。
- en: 'Follow these steps to generate our cheese factory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤生成我们的奶酪工厂：
- en: 'Create a new interface called `Filling` in the `fillings` package and complete
    it like so:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`fillings`包中创建一个名为`Filling`的新接口，并按照以下方式完成它：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, create an abstract class that implements `Filling`, called `Cheese`,
    like this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个实现`Filling`的抽象类，名为`Cheese`，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a concrete class called `Cheddar`, like the one here:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Cheddar`的具体类，如下所示：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create several other `Cheese` classes, along the lines of the `Cheddar`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照与`Cheddar`类似的方式创建其他几个`Cheese`类。
- en: Having created the factory, we need a way to represent each cheese. For this,
    we will create an item layout.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了工厂之后，我们需要一种方法来表示每一种奶酪。为此，我们将创建一个条目布局。
- en: Positioning item layouts
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位条目布局
- en: To keep the interface clean, we will create a very simple item for our recycler
    view list. It will contain just an image, a string, and an action button for the
    user to add the ingredient to their sandwich.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持界面整洁，我们将为回收视图列表创建一个非常简单的条目。它将只包含一个图片、一个字符串和一个用户添加配料到三明治的操作按钮。
- en: 'The initial item layout will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 初始项目布局将如下所示：
- en: '![Positioning item layouts](img/image_06_003.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![定位项目布局](img/image_06_003.jpg)'
- en: 'This may appear to be a very simple layout, but there is more to it than meets
    the eye. Here is the code for the three views:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个非常简单的布局，但它比看上去要复杂得多。以下是三个视图的代码：
- en: 'The image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图片如下：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The title:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标题：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The action button:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 操作按钮：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is worth looking at the way that various resources are managed here. The
    following is the `dimens.xml` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的是这里管理各种资源的方式。以下是`dimens.xml`文件：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is immediately clear that several of these attributes carry the same values,
    and we could have achieved the same effect with only five. However, this can cause
    confusing code, especially when it comes to making changes later on, and despite
    this extravagant approach, there is still some hidden efficiency. The padding
    and margin settings for the action button will be the same for all such buttons
    across the app, as can be read clearly from their names and need only be declared
    once. Likewise, the text and image views in this layout are unique in this app
    and so are named accordingly. This also makes tweaking individual properties far
    clearer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这些属性中有几个携带相同的值，我们可能只需要五个就能达到同样的效果。然而，这可能会导致代码混淆，尤其是在后期进行修改时，尽管这种方法有些过分，但仍然存在一定的效率。操作按钮的填充和边距设置对于整个应用程序中的所有此类按钮都将相同，从它们的名称可以清晰地读取，并且只需要声明一次。同样，此布局中的文本和图像视图在此应用程序中是唯一的，因此也相应地命名。这也使得调整单个属性更加清晰。
- en: Finally, the use of `android:minWidth="64dp"` is a material stipulation intended
    to ensure all such buttons are wide enough for the average finger.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`android:minWidth="64dp"`是材料规定，旨在确保所有这样的按钮宽度都能适应平均手指大小。
- en: This completes the layout for this activity, and with our object factory in
    place as well, we can now populate our recycler view, as we did before, with a
    data adapter and a view holder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了此活动的布局，并且我们的对象工厂也准备就绪，现在我们可以像之前一样，使用数据适配器和视图持有者填充我们的回收视图。
- en: Using the factory with the RecyclerView
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂与RecyclerView
- en: As we saw briefly earlier in the book, RecyclerViews make use of an internal
    LayoutManager. This in turn communicates with the data set by use of an adapter.
    These adapters serve exactly the same function as the adapter design pattern we
    explored earlier in the book. The function may not appear so readily apparent,
    but it acts as a connection between a dataset and a recycler view's layout manager.
    The adapter crosses this bridge with its ViewHolder. The workings of the adapter
    are neatly separated from the client code, and all we need are a few lines to
    create a new adapter and layout manager.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书前面简要看到的那样，RecyclerView利用了一个内部的LayoutManager。这进而通过适配器与数据集通信。这些适配器与我们之前在书中探讨的适配器设计模式完全相同。这个功能可能不是那么明显，但它充当数据集和回收视图的布局管理器之间的桥梁。适配器通过其ViewHolder跨过这座桥。适配器的工作与客户端代码整洁地分离，我们只需要几行代码就可以创建一个新的适配器和布局管理器。
- en: 'With this in mind and our data ready, we can quickly put an adapter together
    by following these simple steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们的数据准备就绪，可以按照以下简单步骤快速组合一个适配器：
- en: 'Begin by creating this new class in your main package:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在主包中创建这个新类：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It requires the following field and constructor:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要以下字段和构造函数：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now add the `ViewHolder` as an inner class, like so:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像这样将`ViewHolder`添加为一个内部类：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are three inherited methods that must be overridden. The `onCreateViewHolder()`
    method:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有三个必须重写的方法。`onCreateViewHolder()`方法：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `onBindViewHolder()` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onBindViewHolder()`方法：'
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `getItemCount()` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getItemCount()`方法：'
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That is the adapter now complete, and all we need to concern ourselves with
    is connecting it up to our data and recycler view. This we do from the `onCreate()`
    method of the main activity. First, we need to create a list of all our cheeses.
    With our pattern in place, this is remarkably simple. The following method can
    go anywhere but here is placed in the main activity:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这样适配器就完成了，我们需要关心的就是将其连接到我们的数据和回收视图。这是在主活动的`onCreate()`方法中完成的。首先，我们需要创建一个包含所有奶酪的列表。有了我们的模式，这非常简单。以下方法可以放在任何地方，但这里放在主活动中：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you will need to import each of these classes from the Fillings package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你需要从Fillings包中导入这些类。
- en: 'We can now connect this to our recycler view, by way of the adapter by adding
    these lines to the `onCreate()` method in the main activity:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过适配器将这个连接到我们的回收视图，在主活动的`onCreate()`方法中添加以下几行：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first thing that stands out is just how little client code is required
    and how self-explanatory it is. Not only the code to set up the recycler view
    and adapter, but also the code to build the list. Without the pattern, we would
    have ended up with code like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先值得注意的是，所需的客户端代码非常少，而且非常易懂。不仅仅是设置回收视图和适配器的代码，还包括构建列表的代码。如果没有这种模式，我们最终可能会得到这样的代码：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The project can now be tested on a device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在可以在设备上进行测试了。
- en: '![Using the factory with the RecyclerView](img/image_06_004.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![在RecyclerView中使用工厂](img/image_06_004.jpg)'
- en: 'The linear layout manager that we used here is not the only one available to
    us. There are two other managers, one for grid layouts and one for staggered layouts.
    They can be applied like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的线性布局管理器不是唯一可用的。还有另外两个管理器，一个用于网格布局，另一个用于交错布局。可以这样应用：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This then only requires a little tweaking of the layout file and we can even
    provide alternative layouts and allow the user to select the one they prefer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这只需要稍微调整布局文件，我们甚至可以提供替代布局并允许用户选择他们喜欢的布局。
- en: From a visual point of view, we have everything pretty much in place. However,
    with such a sparse item design, it might be nice to add dividers between items.
    This is not as straightforward as one might think, but it is nevertheless a simple
    and elegant process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉角度来看，我们基本上已经准备就绪。然而，由于这样一个稀疏的项目设计，在项目之间添加分隔线可能会更好。这不像人们想象的那么简单，但这个过程简单而优雅。
- en: Adding dividers
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分隔线
- en: Prior to the RecyclerView, the ListView came with its own divider element. The
    recycler view, on the other hand, does not. This should not be thought of as a
    shortfall, however, as this latter approach allows for more flexibility.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在回收视图之前，ListView带有自己的分隔元素。而回收视图则没有。然而，这不应当被视为缺点，因为后者允许更大的灵活性。
- en: It may seem tempting to create a divider by adding a very narrow view at the
    bottom of the item layout, but this is considered very poor practice as when the
    item is moved or dismissed, the divider moves with it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个非常窄的视图在项目布局底部以创建分隔线可能看起来很诱人，但这被认为是非常不好的做法，因为当项目移动或被移除时，分隔线也会随之移动。
- en: The RecyclerView uses an inner class, **ItemDecoration** to provide dividers
    between items, as well as spaces and highlights. It also has a very useful subclass,
    the ItemTouchHelper, which we will encounter shortly when we see how to swipe
    and dismiss cards.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回收视图使用内部类**ItemDecoration**来提供项目之间的分隔线，以及间距和突出显示。它还有一个非常有用的子类，即ItemTouchHelper，当我们看到如何滑动和关闭卡片时会遇到它。
- en: 'First, follow these steps to add dividers to our recycler view:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤向我们的回收视图添加分隔线：
- en: 'Create a new ItemDecoration class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的ItemDecoration类：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Include this Drawable field:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含这个Drawable字段：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Followed by this constructor:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着是这个构造函数：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then override the `onDraw()` method:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后重写`onDraw()`方法：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All that is needed now, is to instantiate the divider in the `onCreate()` method
    of the activity, after the `LayoutManager` has been set:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，需要做的就是在`onCreate()`方法中实例化分隔线，在设置了`LayoutManager`之后：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code provides the system divider between our items. The item decoration
    also makes it possible to create **custom dividers** very simply.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码提供了我们项目之间的系统分隔线。项目装饰还可以非常简单地创建**自定义分隔线**。
- en: 'Just follow these two steps to see how it is done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下两个步骤看看是如何完成的：
- en: 'Create an XML file in the `drawable` directory called `item_divider.xml`, along
    these lines:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawable`目录中创建一个名为`item_divider.xml`的XML文件，内容如下：
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a second constructor to the `ItemDivider` class, like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ItemDivider`类中添加第二个构造函数，如下所示：
- en: '[PRE33]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then replace the divider initialization in the activity, with this one:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将活动中的分隔符初始化替换为此处：
- en: '[PRE34]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When run, these two techniques will produce results like those seen here:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当运行时，这两种技术将产生如下所示的结果：
- en: '![Adding dividers](img/image_06_005.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加分隔符](img/image_06_005.jpg)'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The preceding methods draw the divider before the view. If you have a fancy
    divider and wish parts of it to overlap the view, then you will need to override
    the `onDrawOver()` method instead, which will cause the divider to be drawn after
    the views.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的方法是在视图之前绘制分隔符。如果您有一个花哨的分隔符，并希望其部分与视图重叠，那么您需要重写`onDrawOver()`方法，这将导致在视图之后绘制分隔符。
- en: It is now time to start to add a little functionality to our project. We will
    start by considering what functions we want to provide our floating action button.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的项目添加一些功能了。我们将从考虑为我们的小悬浮操作按钮提供哪些功能开始。
- en: Configuring the floating action button
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置悬浮操作按钮
- en: So far, our layout provides only one action, the *add* action button on each
    list item. This will be used to include that filling in the user's eventual sandwich.
    It is always a good idea to ensure that the user is never more than one click
    away from spending their money, and so we will add a checkout function to the
    activity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的布局只提供了一个操作，即每个列表项上的*添加*操作按钮。这将用于包括用户最终的三明治填充。确保用户始终只需点击一次就能消费，因此我们将在活动中添加结账功能。
- en: 'The first thing we will need is an icon. Probably the best source for icons
    is the asset studio we used earlier in the book. This is such a great way to include
    icons in our projects, mainly because it automatically generates versions for
    all available screen densities. However, the number of icons is limited and there
    is no checkout basket. We have two choices here: we can find an icon online or
    we can design our own.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是一个图标。图标最佳的来源可能是我们在书中早些时候使用的资产工作室。这是在项目中包含图标的好方法，主要是因为它自动为所有可用的屏幕密度生成版本。然而，图标的数量有限，没有结账篮子。在这里我们有两个选择：我们可以在网上找一个图标，或者我们可以自己设计一个。
- en: 'There are a large number of material-compliant icons available online and Google
    have their own, which can be found at:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有大量的符合材料设计规范的图标，谷歌也有自己的图标，可以在以下位置找到：
- en: '[design.google.com/icons/](http://design.google.com/icons/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[design.google.com/icons/](http://design.google.com/icons/)'
- en: 'Many developers prefer to design their own graphics and there will always be
    times when we cannot find the icon we need. Google also provide a comprehensive
    guide to icon design at:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者喜欢设计自己的图形，而且总会有我们找不到所需图标的时候。谷歌还提供了图标设计的综合指南，可在以下位置找到：
- en: '[material.google.com/style/icons.html](http://material.google.com/style/icons.html)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[material.google.com/style/icons.html](http://material.google.com/style/icons.html)'
- en: 'Whichever option you choose, it can be added to the button via its `src` attribute,
    like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个选项，都可以通过按钮的`src`属性添加，如下所示：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Having created our icon, we now need to consider color. According to material
    design guidelines, action and system icons should be the same color as either
    the primary or secondary text. These are not, as one might imagine, two shades
    of gray, rather they are defined by levels of transparency. This is done because
    it works far better on colored backgrounds than gray shades do. So far, we have
    used default text color and have not included this in our `styles.xml` file. This
    is easy enough to do given the rules regarding material text color are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的图标后，现在需要考虑颜色。根据材料设计指南，操作和系统图标应与主文本或次文本颜色相同。它们不是如我们所想的两种灰色阴影，而是通过透明度级别定义的。这样做是因为在彩色背景上效果远比灰色阴影好。到目前为止，我们使用了默认的文本颜色，并没有在我们的`styles.xml`文件中包含这一点。根据材料文本颜色的规则，这样做是很容易的，规则如下：
- en: '![Configuring the floating action button](img/B05685_06_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![配置悬浮操作按钮](img/B05685_06_07.jpg)'
- en: 'To create primary and secondary text colors to our theme, add these lines to
    the `colors` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的主题添加主文本和次文本颜色，请在`colors`文件中添加以下这些行：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then add the appropriate lines to the `styles` file, depending on the background
    shade, for example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据背景阴影，在`styles`文件中添加适当的行，例如：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you have used an image asset or downloaded one of Google's material icons,
    then the system will automatically apply the primary text color to our FAB icon.
    Otherwise, you will need to color your icon directly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了图像资源或下载了谷歌的材料图标之一，系统将自动将主文本颜色应用到我们的FAB图标上。否则，您需要直接为您的图标着色。
- en: 'We can now activate the toolbar and the FAB by following these two steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过以下两个步骤激活工具栏和FAB：
- en: 'Add these lines to the main activity''s `onCreate()` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主活动的`onCreate()`方法中添加以下几行代码：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following click listener to the `onCreate()` method of its activity:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其活动的`onCreate()`方法中添加以下点击监听器：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The FAB icon and toolbar title will now be visible and animate correctly when
    the view is scrolled:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当视图滚动时，FAB图标和工具栏标题将可见并正确动画：
- en: '![Configuring the floating action button](img/image_06_007.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![配置悬浮操作按钮](img/image_06_007.jpg)'
- en: Clicking on the FAB should take the user to another activity, the checkout activity.
    However, they may have clicked the button in error, and therefore we should first
    present them with a dialog for them to confirm the selection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 点击悬浮操作按钮（FAB）应将用户带到另一个活动，即结账活动。然而，用户可能误点击了按钮，因此我们首先应该弹出一个对话框，让用户确认选择。
- en: The dialog builder
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框构建器
- en: As well as being essential to all but a few apps, Android dialogs offer a great
    way to see how the framework itself employs design patterns. In this case, it
    is the dialog builder, which strings together a series of setters to build our
    dialog.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了少数应用外，Android对话框对所有应用都是必不可少的，它也是了解框架本身如何应用设计模式的好方法。在这个例子中，它是对话框构建器，它通过一系列setter来构建我们的对话框。
- en: In the current situation, all we really need is a very simple dialog allowing
    the user to confirm their selection, but dialog construction is a very interesting
    topic and so we will take a closer look at how it is done and how inbuilt builder
    patterns are used to construct them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，我们真正需要的只是一个非常简单的对话框，允许用户确认他们的选择，但对话框构建是一个非常有趣的话题，因此我们将更详细地了解它是如何完成的，以及内置构建器模式是如何用于构建它们的。
- en: The dialog we are about to build will, if confirmed, take the user to another
    activity, so before we do that we should create that activity. This is easily
    done by selecting `New | Activity | Blank Activity` from the project explorer
    menu. Here we have called it `CheckoutActivity.java`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将构建的对话框，如果得到确认，将把用户带到另一个活动，因此在这样做之前，我们应该创建该活动。通过从项目资源管理器菜单中选择`新建 | 活动 | 空白活动`可以轻松完成。这里我们称它为`CheckoutActivity.java`。
- en: 'Once you have created this activity, follow these two steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此活动后，请按照以下两个步骤操作：
- en: 'The floating action button onClickListener will build and inflate our dialog.
    It is quite lengthy, so create a new method called `buildDialog()`: and add the
    following two lines to the bottom of the `onCreate()` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬浮操作按钮的点击监听器将构建并显示我们的对话框。它相当长，所以创建一个名为`buildDialog()`的新方法：并在`onCreate()`方法的底部添加以下两行：
- en: '[PRE40]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then define the method like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后像这样定义方法：
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![The dialog builder](img/image_06_008.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![对话框构建器](img/image_06_008.jpg)'
- en: 'For such a simple dialog, it is unnecessary to have a title and an icon and
    these are included by way of example only. There are many other attributes provided
    by the `AlertDialog.Builder` and a comprehensive guide can be found at:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的对话框，标题和图标是不必要的，这里包括它们只是为了示例。`AlertDialog.Builder`提供了许多其他属性，并且可以在以下位置找到全面的指南：
- en: developer.android.com/reference/android/app/AlertDialog.Builder.html
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: developer.android.com/reference/android/app/AlertDialog.Builder.html
- en: This provides a convenient way to put together almost any alert dialog we can
    think of, but it has some shortfalls. For example, the above dialog uses the default
    theme to color the button text. With our customized theme, it would be nice to
    see this applied to our dialogs as well. This is easily achieved by creating a
    custom dialog.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们几乎可以想到的任何警告对话框提供了一种便捷的构建方式，但它有一些不足之处。例如，上述对话框使用默认主题给按钮文字上色。在我们的自定义主题中，将这种颜色应用到我们的对话框会很不错。通过创建自定义对话框，可以轻松实现这一点。
- en: Custom dialogs
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义对话框
- en: As you would expect, a custom dialog is defined with an XML layout file in the
    same way we might design any other layout. Furthermore, we can inflate this layout
    during our builder chain, which means we can combine custom and default features
    in the same dialog.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，自定义对话框是用XML布局文件定义的，这与我们设计其他任何布局的方式相同。此外，我们可以在构建器链中填充此布局，这意味着我们可以在同一个对话框中组合自定义和默认功能。
- en: 'There are just two steps to customize our dialog:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义我们的对话框，只需以下两个步骤：
- en: 'Firstly, create a new layout resource file called `checkout_dialog.xml` and
    complete it like so:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`checkout_dialog.xml`的新布局资源文件，并完成如下：
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, edit the `buildDialog()` method to match the one seen here. The changes
    from the previous method have been highlighted:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`buildDialog()`方法编辑成与这里看到的一致。与之前方法的变化已被突出显示：
- en: '[PRE43]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we used the `AlertDialog.Builder` to set the view to our custom layout.
    This requires the layout resource and the parent, but in this case, we are building
    from within the listener, so it remains `null`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`AlertDialog.Builder`将视图设置为我们的自定义布局。这需要布局资源和父级，但在这个例子中，我们从监听器内部构建，所以它保持为`null`。
- en: 'When tested on a device, the output should resemble the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上测试时，输出应该类似于以下屏幕截图：
- en: '![Custom dialogs](img/image_06_009.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![自定义对话框](img/image_06_009.jpg)'
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is worth noting that when defining string resources for buttons, it is considered
    better practice to *not* capitalize the whole string, but only the first letter.
    For example, the following definitions created the text on the buttons in the
    previous example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在为按钮定义字符串资源时，最好*不要*将整个字符串大写，只大写首字母。例如，以下定义创建了上一个示例中按钮上的文本：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we customized the title and content of the dialog, but still
    used the provided OK and CANCEL buttons, and we can mix and match our own customizations
    with many of the dialog's setters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们自定义了对话框的标题和内容，但仍然使用了提供的确定和取消按钮，我们可以将我们自己的自定义与对话框的许多设置器混合匹配。
- en: Before we move on, we will provide one more form of functionality to the recycler
    view, swipe and dismiss behavior.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将为回收视图提供另一种功能，即滑动并取消的行为。
- en: Adding swipe and dismiss actions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加滑动并取消操作
- en: It is unlikely that we would need swipe and dismiss behavior in this particular
    app, as the lists are short and there is little to be gained by allowing users
    to edit them. However, so that we can see how this important and useful function
    is applied, we will implement it here even though we won't be including it in
    the final design.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的应用中，我们不太可能需要滑动并取消的行为，因为列表很短，允许用户编辑它们也没有太大的好处。然而，为了让我们了解这个重要且有用的功能是如何应用的，即使最终设计中不会包含它，我们也将在这里实现它。
- en: Swiping, as well as dragging and dropping, is largely managed by the **ItemTouchHelper**,
    which is a type of RecyclerView.ItemDecoration. The callbacks provided for this
    class allow us to detect item movement and direction and to intercept these actions
    and respond to them in code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动以及拖放操作主要由**ItemTouchHelper**管理，它是一种RecyclerView.ItemDecoration的类型。这个类提供的回调允许我们检测项目的移动和方向，并拦截这些操作，然后在代码中响应它们。
- en: 'As you can see here, there are just a few steps to implementing swipe and dismiss
    behavior:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，实现滑动并取消行为只需几个步骤：
- en: Firstly, our list is now going to change length, so remove the line `recyclerView.setHasFixedSize(true);`
    or set it to `false`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的列表现在将改变长度，因此删除这行代码`recyclerView.setHasFixedSize(true);`或者将其设置为`false`。
- en: 'It is always a good idea to keep our `onCreate()` methods as simple as possible,
    as there can often be a great deal going on there. We will create a separate method
    to initialize our item touch helper and call it from `onCreate()`. Here is the
    method:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持`onCreate()`方法尽可能简单总是一个好主意，因为那里通常有很多事情发生。我们将创建一个单独的方法来初始化我们的项目触摸助手，并在`onCreate()`中调用它。以下是该方法：
- en: '[PRE45]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now add the following line to the `onCreate()` method:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将以下行添加到`onCreate()`方法中：
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Despite performing half a dozen functions, the `onCreate()` method still remains
    short and clear:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管执行了半个函数的功能，`onCreate()`方法仍然保持简短和清晰：
- en: '[PRE47]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you test the app at this point, you will notice that although items disappear
    from the screen when swiped, the gap does not close up. This is because we have
    not yet informed the recycler view that it has been removed. Although this can
    be done from the `initItemTouchHelper()` method, it really belongs in the adapter
    class, as it utilizes its methods. Add the following method to the adapter to
    complete this task:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此时测试应用，您会注意到尽管项目在滑动时会从屏幕上消失，但间隙并没有关闭。这是因为我们还没有通知回收视图它已被移除。尽管这可以在`initItemTouchHelper()`方法中完成，但它实际上属于适配器类，因为它使用了它的方法。在适配器中添加以下方法以完成此任务：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The recycler view list will now reorder when an item is removed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当移除一个项目时，回收视图列表将会重新排序：
- en: '![Adding swipe and dismiss actions](img/image_06_010.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![添加滑动并取消操作](img/image_06_010.jpg)'
- en: 'In this example, the user can swipe an item either way to dismiss it, and this
    is fine for our purposes here, but there are many times when this distinction
    is very useful. Many mobile applications use swipe right to accept an item and
    swipe left to dismiss it. This is easily implemented by using the `onSwiped()`
    method''s direction parameter. For example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，用户可以左右滑动以关闭项目，这对我们这里的目的来说是可以的，但在很多情况下这种区分非常有用。许多移动应用程序使用向右滑动来接受一个项目，向左滑动来关闭它。这可以通过使用`onSwiped()`方法的方向参数轻松实现。例如：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Earlier in the chapter, we used a native pattern, the AlertDialog.Builder, to
    construct a layout. As is meant to be the case with creational patterns, the logic
    behind the processes was hidden from us, but the builder design pattern provides
    a very good mechanism for constructing layouts and view groups from individual
    view components, as we shall see next.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们使用了一个本地模式，即AlertDialog.Builder来构建布局。正如创建性模式的本意，背后的逻辑对我们是隐藏的，但构建器设计模式为从单个视图组件构建布局和视图组提供了一个非常好的机制，我们将在下面看到这一点。
- en: Constructing layout builders
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造布局构建器
- en: So far in this book, all the layouts we have constructed have been static XML
    definitions. As you would expect, however, it is perfectly possible to construct
    and inflate UIs dynamically from our source code. Furthermore, Android layouts
    lend themselves very nicely to the builder pattern, as we saw with our alert dialog,
    as they are comprised of an ordered collection of smaller objects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们构建的所有布局都是静态的XML定义。然而，正如你所期望的，完全可以从我们的源代码中动态构建和填充UI。此外，Android布局非常适合构建器模式，正如我们在警告对话框中所看到的，因为它们由一系列有序的小对象组成。
- en: The following example will follow the builder design pattern to inflate a linear
    layout from a series of predefined *layout views*. As before, we will build up
    from interfaces to abstractions and concrete classes. We will create two kinds
    of layout item, a title or *headline* view and a *content* view. We then make
    several concrete examples of these that can then be constructed by the builder.
    As there are some features that all views have in common (text and background
    colors in this case), we will avoid having to duplicate methods by having another
    interface, with its own concrete extensions to handle this shading.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将遵循构建器设计模式，从一系列预定义的*布局视图*中填充一个线性布局。像之前一样，我们将从接口构建到抽象和具体类。我们将创建两种布局项，标题或*头条*视图和*内容*视图。然后我们制作这些的具体示例，可以通过构建器来构建。因为所有视图都有一些共同的特征（在这种情况下是文本和背景颜色），我们将通过另一个接口来避免重复方法，这个接口有自己的具体扩展来处理这种着色。
- en: 'To best see how this works, start a new Android project and follow these steps
    to construct the model:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解这是如何工作的，请启动一个新的Android项目，并按照以下步骤构建模型：
- en: Create an inner package called `builder`. Add all the following classes to this
    package.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`builder`的内部包。将以下所有类添加到这个包中。
- en: 'Create the following interface for our view classes:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的视图类创建以下接口：
- en: '[PRE50]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now create the interface for the text and background colors, like so:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建文本和背景颜色的接口，如下所示：
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will create the concrete examples of `Shading`. They look like this:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建`Shading`的具体示例。它们看起来像这样：
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can create abstract implementations of the two types of view we want.
    These should match the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们想要的两种视图类型的抽象实现。这些应该符合以下要求：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we need to create concrete classes of both these types. First the headers:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建这两种类型的具体类。首先是标题：
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then Content:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是内容：
- en: '[PRE55]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This completes our model. We have two individual views and color settings for
    each type of view. We can now create a helper class to put these views together
    in whichever order we wish. Here we will have just two, one for a simple output
    and one for a more detailed layout.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的模型就完成了。我们有两个单独的视图以及每种视图的颜色设置。现在我们可以创建一个助手类，按照我们希望的顺序组合这些视图。这里我们只需要两个，一个用于简单的输出，另一个用于更详细的布局。
- en: 'This is how the builder looks:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器的样子如下：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The class diagram for this pattern is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的类图如下：
- en: '![Constructing layout builders](img/B05685_06_13.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Constructing layout builders](img/B05685_06_13.jpg)'
- en: As is the intention with the builder pattern and other patterns in general,
    all the work we have just gone to serves to hide the model logic from the client
    code, in our case the current activity and the `onCreate()` method in particular.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如构建器模式和其他一般模式所期望的，我们所做的一切工作都是为了将模型逻辑从客户端代码中隐藏起来，在我们的例子中，特别是当前活动和`onCreate()`方法。
- en: We could of course inflate these views in the default root view group as provided
    by the main XML activity, but it is often useful to generate these dynamically
    too, especially if we want to generate nested layouts.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在主XML活动提供的默认根视图组中扩展这些视图，但动态生成这些视图通常也很有用，特别是如果我们想要生成嵌套布局。
- en: 'The following activity demonstrates how we can now use the builder to inflate
    layouts dynamically:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个活动演示了我们现在如何使用构建器动态扩展布局：
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You will also need the following method, which is used to convert from `px`
    to `dp`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要以下方法，该方法用于从`px`转换为`dp`：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Which when run on a device will produce one of the following two UIs:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上运行时，将产生以下两种UI之一：
- en: '![Constructing layout builders](img/image_06_012.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![构建布局构建器](img/image_06_012.jpg)'
- en: As expected, the client code is simple, short, and easy to follow.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，客户端代码简单、简短且易于理解。
- en: It is not necessary to use either programmatic or static layouts, and the two
    can be mixed. Views can be designed in XML and then inflate them the way we did
    here in Java. We can even keep the same pattern we used here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不必使用程序化布局或静态布局，两者可以混合使用。视图可以在XML中设计，然后像我们在这里用Java所做的那样进行扩展。我们可以甚至保持这里使用的相同模式。
- en: There is a lot more that could be covered here, such as how to include other
    types of views, such as images using adapter or bridge patterns, but we will cover
    combining patterns later in the book. For now, we have seen how a layout builder
    works in principle and how it separates its logic from the client code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有很多内容可以介绍，比如如何使用适配器或桥接模式包含其他类型的视图，例如图片，但我们将在书中稍后介绍组合模式。现在，我们已经了解了布局构建器的工作原理以及它是如何将其逻辑与客户端代码分离的。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has covered quite a lot. We began by creating a collapsing toolbar
    and a functional recycler view. We saw how to add basic functionality to much
    of our layout, and how a factory pattern can be applied to a specific case. This
    led us to explore how builders, internal and created, can be used to construct
    detailed layouts.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容相当丰富。我们从创建一个折叠工具栏和一个功能性的回收视图开始。我们了解了如何为布局的大部分添加基本功能，以及如何将工厂模式应用于特定案例。这引导我们探索构建器（内部和创建的）如何用于构建详细布局。
- en: In the next chapter, we will look further into responding to user activity and,
    now we have some working widgets and views, how to connect them to some useful
    logic.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨如何响应用户活动，现在我们有了某些工作的控件和视图，我们将了解如何将它们连接到有用的逻辑。
