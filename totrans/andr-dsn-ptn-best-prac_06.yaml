- en: Chapter 6. Activating Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapters up to this point have served as an extended introduction, exploring
    the practicalities of Android development and the theory of design pattern application.
    We have covered many of the fundamental components of an Android app and seen
    how some of the most useful patterns are made, but we have not yet put the two
    together.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build one of the main sections of our app, an ingredient
    selection menu. This will involve a scrollable list of fillings that can be selected,
    expanded, and dismissed. On the way, we will also take a look at the collapsible
    toolbar and one or two other handy support library features, adding functionality
    to action buttons, a floating action button, and an alert dialog.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of this code, we will apply a simple factory pattern to create
    each ingredient. This will demonstrate nicely how this pattern hides creational
    logic from client classes. In this chapter, we will create only a single example
    of a filling type, to see how it is done, but the same structures and processes
    will be used later as more complexity is added. This will lead us to explore recycler
    view formats and decoration, such as grid layouts and dividers.
  prefs: []
  type: TYPE_NORMAL
- en: We will then move on to generate and customize an alert dialog from the clicking
    of a button. This will require an inbuilt builder pattern and lead us on to see
    how we can create a builder pattern of our own for inflating layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an app-bar layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a collapsing toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control scrolling behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include nested scroll views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a data factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a list item view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert a text view into a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply grid layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add divider decoration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure action icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an alert dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a second activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply swipe and dismiss behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a layout builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a layout at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of our app will need some way of selecting ingredients. We could of course
    present them with one long list, but this would be cumbersome and unattractive.
    Clearly, we need to split our ingredients into categories. In the following examples,
    we will concentrate on just one of these groups as this will help simplify the
    underlying processes for later on, when we will consider more complex scenarios.
    We will begin by creating the necessary layouts, starting with the collapsing
    toolbar layout.
  prefs: []
  type: TYPE_NORMAL
- en: Collapsing toolbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toolbars that slide out of the way conveniently are a common feature of material
    design UIs, and provide an elegant and clever way to make good use of the limited
    space available on phones and even laptops.
  prefs: []
  type: TYPE_NORMAL
- en: '![Collapsing toolbars](img/B05685_06_01-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you would imagine the **CollapsingToolbarLayout** is part of the design support
    library. It is intended as a child of the **AppBarLayout**, which is a linear
    layout, designed specifically for material design features.
  prefs: []
  type: TYPE_NORMAL
- en: Collapsing toolbars help manage space elegantly and also provide a good opportunity
    to display attractive graphics and help promote our product. They take little
    time to implement and are easily adapted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to see how they work is to build one, and the following steps
    demonstrate how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project and include the both the recycler view and the design support
    libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the action bar by changing the theme to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `activity_main.xml` file and apply the following root layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this, add this `AppBarLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place this `CollapsingToolbarLayout` inside the app-bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The contents of the collapsing toolbar are the following two views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, below the app-bar layout, add this recycler view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add this floating action button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Collapsing toolbars](img/image_06_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible, and often desirable, to set the status bar to translucent so
    that our app-bar image can be seen behind it. This is achieved by adding the following
    two items to the styles.xml files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have already encountered the coordinator layout in a previous chapter and
    seen how it facilitates many material design functions. The `AppBarLayout` does
    a similar thing and is generally used as a container for collapsing toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: The **CollapsingToolbarLayout**, on the other hand, needs one or two things
    explaining. Firstly, the use of `android:layout_height="wrap_content"` will produce
    different effects, depending on the height of the image its ImageView contains.
    This is done so that when we design alternative layouts for different screen sizes
    and densities, we can simply scale this image accordingly. Here it is configured
    for a small (480 x 854dp) 240dpi device and is 192dp tall. We could of course
    have set layout height in dp and scaled this value in the various `dimens.xml`
    files. We would however, still have had to scale the image, so this method kills
    two birds with one stone.
  prefs: []
  type: TYPE_NORMAL
- en: The other interesting point about the collapsing toolbar layout is the way we
    can control how it scrolls, and as you would imagine, this is dealt with by the
    **layout_scrollFlags** attribute. Here we used `scroll`, `exitUntilCollapsed`,
    `enterAlwaysCollapsed`. This means that the toolbar never disappears from the
    top of the screen and that the toolbar does not expand until the list can be scrolled
    no further down.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five scroll flags, and they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scroll` - Enables scrolling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exitUntilCollapsed` - Prevents the toolbar from disappearing when scrolling
    up (omit to lose the toolbar until scrolling down)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enterAlways` - Toolbar expands whenever the list scrolls down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enterAlwaysCollapsed` - Toolbar only expands from top of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snap` - Toolbar snaps into place rather than gliding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The image view within the collapsing toolbar is almost identical to any other
    image view we might have seen, apart from maybe the `layout_collapseMode` attribute.
    This has two possible settings, `pin` and `parallax`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pin` - The list and toolbar move together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parallax` - The list and toolbar move separately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to appreciate these effects is simply to try them out. We could
    also have applied either of these layout collapse modes on the toolbar beneath
    the image, but as we want our toolbar to remain on screen, we need not concern
    ourselves with its collapsing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recycler view that will contain our data here is different in only one
    respect from the one we used earlier in the book. That is the inclusion of the
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This attribute is all we have to add to any view or view group that sits below
    the app bar, to allow the two to coordinate their scrolling behavior.
  prefs: []
  type: TYPE_NORMAL
- en: These simple classes save us a great deal of work when it comes to implementing
    material design and leave us to concentrate on providing functionality. Apart
    from the size of the image, very little refactoring is required to create a layout
    that works on a large number of possible devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we are using a recycler view here, it is quite possible to put any
    number of views and view groups below the app-bar. Providing that they possess
    the `app:layout_behavior="@string/appbar_scrolling_view_behavior"` attribute,
    they will move in concord with the bar. There is one layout that particularly
    suits this purpose and that is the **NestedScrollView**. By way of example, it
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next logical step is to create a layout for populating the recycler view,
    but first we need to prepare the data. In this chapter, we will develop an application
    component responsible for presenting the user with a list of ingredients of a
    particular category, in this case cheese. We will use the **factory pattern**
    to create these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a data factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply a factory pattern to create objects of type *cheese*.
    This will in turn implement a *filling* interface. Each object will consist of
    several properties such as price and calorific value. Some of these values will
    be presented in our list items and others will be available only through an expanded
    view or accessible only via code.
  prefs: []
  type: TYPE_NORMAL
- en: One of the few disadvantages of design patterns is the large number of classes
    that soon accumulate. For this reason, before beginning the following exercise,
    create a new package inside the `java` directory, called `fillings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to generate our cheese factory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new interface called `Filling` in the `fillings` package and complete
    it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an abstract class that implements `Filling`, called `Cheese`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a concrete class called `Cheddar`, like the one here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create several other `Cheese` classes, along the lines of the `Cheddar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having created the factory, we need a way to represent each cheese. For this,
    we will create an item layout.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning item layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep the interface clean, we will create a very simple item for our recycler
    view list. It will contain just an image, a string, and an action button for the
    user to add the ingredient to their sandwich.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial item layout will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Positioning item layouts](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This may appear to be a very simple layout, but there is more to it than meets
    the eye. Here is the code for the three views:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The action button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth looking at the way that various resources are managed here. The
    following is the `dimens.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is immediately clear that several of these attributes carry the same values,
    and we could have achieved the same effect with only five. However, this can cause
    confusing code, especially when it comes to making changes later on, and despite
    this extravagant approach, there is still some hidden efficiency. The padding
    and margin settings for the action button will be the same for all such buttons
    across the app, as can be read clearly from their names and need only be declared
    once. Likewise, the text and image views in this layout are unique in this app
    and so are named accordingly. This also makes tweaking individual properties far
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the use of `android:minWidth="64dp"` is a material stipulation intended
    to ensure all such buttons are wide enough for the average finger.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the layout for this activity, and with our object factory in
    place as well, we can now populate our recycler view, as we did before, with a
    data adapter and a view holder.
  prefs: []
  type: TYPE_NORMAL
- en: Using the factory with the RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw briefly earlier in the book, RecyclerViews make use of an internal
    LayoutManager. This in turn communicates with the data set by use of an adapter.
    These adapters serve exactly the same function as the adapter design pattern we
    explored earlier in the book. The function may not appear so readily apparent,
    but it acts as a connection between a dataset and a recycler view's layout manager.
    The adapter crosses this bridge with its ViewHolder. The workings of the adapter
    are neatly separated from the client code, and all we need are a few lines to
    create a new adapter and layout manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind and our data ready, we can quickly put an adapter together
    by following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating this new class in your main package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It requires the following field and constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the `ViewHolder` as an inner class, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are three inherited methods that must be overridden. The `onCreateViewHolder()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `onBindViewHolder()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `getItemCount()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is the adapter now complete, and all we need to concern ourselves with
    is connecting it up to our data and recycler view. This we do from the `onCreate()`
    method of the main activity. First, we need to create a list of all our cheeses.
    With our pattern in place, this is remarkably simple. The following method can
    go anywhere but here is placed in the main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you will need to import each of these classes from the Fillings package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now connect this to our recycler view, by way of the adapter by adding
    these lines to the `onCreate()` method in the main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that stands out is just how little client code is required
    and how self-explanatory it is. Not only the code to set up the recycler view
    and adapter, but also the code to build the list. Without the pattern, we would
    have ended up with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The project can now be tested on a device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the factory with the RecyclerView](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The linear layout manager that we used here is not the only one available to
    us. There are two other managers, one for grid layouts and one for staggered layouts.
    They can be applied like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This then only requires a little tweaking of the layout file and we can even
    provide alternative layouts and allow the user to select the one they prefer.
  prefs: []
  type: TYPE_NORMAL
- en: From a visual point of view, we have everything pretty much in place. However,
    with such a sparse item design, it might be nice to add dividers between items.
    This is not as straightforward as one might think, but it is nevertheless a simple
    and elegant process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dividers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to the RecyclerView, the ListView came with its own divider element. The
    recycler view, on the other hand, does not. This should not be thought of as a
    shortfall, however, as this latter approach allows for more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem tempting to create a divider by adding a very narrow view at the
    bottom of the item layout, but this is considered very poor practice as when the
    item is moved or dismissed, the divider moves with it.
  prefs: []
  type: TYPE_NORMAL
- en: The RecyclerView uses an inner class, **ItemDecoration** to provide dividers
    between items, as well as spaces and highlights. It also has a very useful subclass,
    the ItemTouchHelper, which we will encounter shortly when we see how to swipe
    and dismiss cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, follow these steps to add dividers to our recycler view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new ItemDecoration class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include this Drawable field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Followed by this constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then override the `onDraw()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that is needed now, is to instantiate the divider in the `onCreate()` method
    of the activity, after the `LayoutManager` has been set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code provides the system divider between our items. The item decoration
    also makes it possible to create **custom dividers** very simply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just follow these two steps to see how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an XML file in the `drawable` directory called `item_divider.xml`, along
    these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a second constructor to the `ItemDivider` class, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then replace the divider initialization in the activity, with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When run, these two techniques will produce results like those seen here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Adding dividers](img/image_06_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding methods draw the divider before the view. If you have a fancy
    divider and wish parts of it to overlap the view, then you will need to override
    the `onDrawOver()` method instead, which will cause the divider to be drawn after
    the views.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is now time to start to add a little functionality to our project. We will
    start by considering what functions we want to provide our floating action button.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the floating action button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our layout provides only one action, the *add* action button on each
    list item. This will be used to include that filling in the user's eventual sandwich.
    It is always a good idea to ensure that the user is never more than one click
    away from spending their money, and so we will add a checkout function to the
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will need is an icon. Probably the best source for icons
    is the asset studio we used earlier in the book. This is such a great way to include
    icons in our projects, mainly because it automatically generates versions for
    all available screen densities. However, the number of icons is limited and there
    is no checkout basket. We have two choices here: we can find an icon online or
    we can design our own.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a large number of material-compliant icons available online and Google
    have their own, which can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[design.google.com/icons/](http://design.google.com/icons/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many developers prefer to design their own graphics and there will always be
    times when we cannot find the icon we need. Google also provide a comprehensive
    guide to icon design at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[material.google.com/style/icons.html](http://material.google.com/style/icons.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whichever option you choose, it can be added to the button via its `src` attribute,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Having created our icon, we now need to consider color. According to material
    design guidelines, action and system icons should be the same color as either
    the primary or secondary text. These are not, as one might imagine, two shades
    of gray, rather they are defined by levels of transparency. This is done because
    it works far better on colored backgrounds than gray shades do. So far, we have
    used default text color and have not included this in our `styles.xml` file. This
    is easy enough to do given the rules regarding material text color are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the floating action button](img/B05685_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create primary and secondary text colors to our theme, add these lines to
    the `colors` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the appropriate lines to the `styles` file, depending on the background
    shade, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you have used an image asset or downloaded one of Google's material icons,
    then the system will automatically apply the primary text color to our FAB icon.
    Otherwise, you will need to color your icon directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now activate the toolbar and the FAB by following these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these lines to the main activity''s `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following click listener to the `onCreate()` method of its activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The FAB icon and toolbar title will now be visible and animate correctly when
    the view is scrolled:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Configuring the floating action button](img/image_06_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Clicking on the FAB should take the user to another activity, the checkout activity.
    However, they may have clicked the button in error, and therefore we should first
    present them with a dialog for them to confirm the selection.
  prefs: []
  type: TYPE_NORMAL
- en: The dialog builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as being essential to all but a few apps, Android dialogs offer a great
    way to see how the framework itself employs design patterns. In this case, it
    is the dialog builder, which strings together a series of setters to build our
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: In the current situation, all we really need is a very simple dialog allowing
    the user to confirm their selection, but dialog construction is a very interesting
    topic and so we will take a closer look at how it is done and how inbuilt builder
    patterns are used to construct them.
  prefs: []
  type: TYPE_NORMAL
- en: The dialog we are about to build will, if confirmed, take the user to another
    activity, so before we do that we should create that activity. This is easily
    done by selecting `New | Activity | Blank Activity` from the project explorer
    menu. Here we have called it `CheckoutActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created this activity, follow these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The floating action button onClickListener will build and inflate our dialog.
    It is quite lengthy, so create a new method called `buildDialog()`: and add the
    following two lines to the bottom of the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define the method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![The dialog builder](img/image_06_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'For such a simple dialog, it is unnecessary to have a title and an icon and
    these are included by way of example only. There are many other attributes provided
    by the `AlertDialog.Builder` and a comprehensive guide can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: developer.android.com/reference/android/app/AlertDialog.Builder.html
  prefs: []
  type: TYPE_NORMAL
- en: This provides a convenient way to put together almost any alert dialog we can
    think of, but it has some shortfalls. For example, the above dialog uses the default
    theme to color the button text. With our customized theme, it would be nice to
    see this applied to our dialogs as well. This is easily achieved by creating a
    custom dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Custom dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you would expect, a custom dialog is defined with an XML layout file in the
    same way we might design any other layout. Furthermore, we can inflate this layout
    during our builder chain, which means we can combine custom and default features
    in the same dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just two steps to customize our dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, create a new layout resource file called `checkout_dialog.xml` and
    complete it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, edit the `buildDialog()` method to match the one seen here. The changes
    from the previous method have been highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used the `AlertDialog.Builder` to set the view to our custom layout.
    This requires the layout resource and the parent, but in this case, we are building
    from within the listener, so it remains `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When tested on a device, the output should resemble the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom dialogs](img/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is worth noting that when defining string resources for buttons, it is considered
    better practice to *not* capitalize the whole string, but only the first letter.
    For example, the following definitions created the text on the buttons in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we customized the title and content of the dialog, but still
    used the provided OK and CANCEL buttons, and we can mix and match our own customizations
    with many of the dialog's setters.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, we will provide one more form of functionality to the recycler
    view, swipe and dismiss behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding swipe and dismiss actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is unlikely that we would need swipe and dismiss behavior in this particular
    app, as the lists are short and there is little to be gained by allowing users
    to edit them. However, so that we can see how this important and useful function
    is applied, we will implement it here even though we won't be including it in
    the final design.
  prefs: []
  type: TYPE_NORMAL
- en: Swiping, as well as dragging and dropping, is largely managed by the **ItemTouchHelper**,
    which is a type of RecyclerView.ItemDecoration. The callbacks provided for this
    class allow us to detect item movement and direction and to intercept these actions
    and respond to them in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see here, there are just a few steps to implementing swipe and dismiss
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, our list is now going to change length, so remove the line `recyclerView.setHasFixedSize(true);`
    or set it to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is always a good idea to keep our `onCreate()` methods as simple as possible,
    as there can often be a great deal going on there. We will create a separate method
    to initialize our item touch helper and call it from `onCreate()`. Here is the
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following line to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Despite performing half a dozen functions, the `onCreate()` method still remains
    short and clear:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you test the app at this point, you will notice that although items disappear
    from the screen when swiped, the gap does not close up. This is because we have
    not yet informed the recycler view that it has been removed. Although this can
    be done from the `initItemTouchHelper()` method, it really belongs in the adapter
    class, as it utilizes its methods. Add the following method to the adapter to
    complete this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The recycler view list will now reorder when an item is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding swipe and dismiss actions](img/image_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, the user can swipe an item either way to dismiss it, and this
    is fine for our purposes here, but there are many times when this distinction
    is very useful. Many mobile applications use swipe right to accept an item and
    swipe left to dismiss it. This is easily implemented by using the `onSwiped()`
    method''s direction parameter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Earlier in the chapter, we used a native pattern, the AlertDialog.Builder, to
    construct a layout. As is meant to be the case with creational patterns, the logic
    behind the processes was hidden from us, but the builder design pattern provides
    a very good mechanism for constructing layouts and view groups from individual
    view components, as we shall see next.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing layout builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, all the layouts we have constructed have been static XML
    definitions. As you would expect, however, it is perfectly possible to construct
    and inflate UIs dynamically from our source code. Furthermore, Android layouts
    lend themselves very nicely to the builder pattern, as we saw with our alert dialog,
    as they are comprised of an ordered collection of smaller objects.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will follow the builder design pattern to inflate a linear
    layout from a series of predefined *layout views*. As before, we will build up
    from interfaces to abstractions and concrete classes. We will create two kinds
    of layout item, a title or *headline* view and a *content* view. We then make
    several concrete examples of these that can then be constructed by the builder.
    As there are some features that all views have in common (text and background
    colors in this case), we will avoid having to duplicate methods by having another
    interface, with its own concrete extensions to handle this shading.
  prefs: []
  type: TYPE_NORMAL
- en: 'To best see how this works, start a new Android project and follow these steps
    to construct the model:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an inner package called `builder`. Add all the following classes to this
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following interface for our view classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the interface for the text and background colors, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create the concrete examples of `Shading`. They look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create abstract implementations of the two types of view we want.
    These should match the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create concrete classes of both these types. First the headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then Content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This completes our model. We have two individual views and color settings for
    each type of view. We can now create a helper class to put these views together
    in whichever order we wish. Here we will have just two, one for a simple output
    and one for a more detailed layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the builder looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The class diagram for this pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing layout builders](img/B05685_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As is the intention with the builder pattern and other patterns in general,
    all the work we have just gone to serves to hide the model logic from the client
    code, in our case the current activity and the `onCreate()` method in particular.
  prefs: []
  type: TYPE_NORMAL
- en: We could of course inflate these views in the default root view group as provided
    by the main XML activity, but it is often useful to generate these dynamically
    too, especially if we want to generate nested layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following activity demonstrates how we can now use the builder to inflate
    layouts dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need the following method, which is used to convert from `px`
    to `dp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Which when run on a device will produce one of the following two UIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing layout builders](img/image_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the client code is simple, short, and easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to use either programmatic or static layouts, and the two
    can be mixed. Views can be designed in XML and then inflate them the way we did
    here in Java. We can even keep the same pattern we used here.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more that could be covered here, such as how to include other
    types of views, such as images using adapter or bridge patterns, but we will cover
    combining patterns later in the book. For now, we have seen how a layout builder
    works in principle and how it separates its logic from the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered quite a lot. We began by creating a collapsing toolbar
    and a functional recycler view. We saw how to add basic functionality to much
    of our layout, and how a factory pattern can be applied to a specific case. This
    led us to explore how builders, internal and created, can be used to construct
    detailed layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look further into responding to user activity and,
    now we have some working widgets and views, how to connect them to some useful
    logic.
  prefs: []
  type: TYPE_NORMAL
