- en: Chapter 4. Android NDK OpenGL ES API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 2D Graphics and applying transforms with OpenGL ES 1.x API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing 3D graphics and lighting up the scene with the OpenGL ES 1.x API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping texture to 3D objects with the OpenGL ES 1.x API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing 3D graphics with the OpenGL ES 2.0 API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying graphics with EGL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Open Graphics Library** (**OpenGL**) is a cross-platform industry standard
    API for producing 2D and 3D graphics. It specifies a language-independent software
    interface for graphics hardware or software graphics engines. **OpenGL ES** is
    a flavor of OpenGL for embedded devices. It consists of a subset of OpenGL specifications
    and some additional extensions that are specific to OpenGL ES .'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES does not require dedicated graphics hardware to work. Different devices
    can come with graphics hardware with different processing capabilities. The workload
    of the OpenGL ES calls is divided between the CPU and graphics hardware. It is
    possible to support OpenGL ES entirely from the CPU. However, graphics hardware
    can improve performance at different levels, based on its processing capabilities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into Android NDK OpenGL ES, a little introduction of the **Graphics
    Rendering Pipeline** (**GRP**) in the OpenGL context is necessary. GRP refers
    to a series of processing stages, which the graphics hardware takes to produce
    graphics. It accepts objects description in terms of vertices of primitives (
    **primitives** refer to simple geometric shapes such as point, line, and triangle)
    and output color values for the pixels on the display. It can be roughly divided
    into the following four main stages:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex processing**: It accepts the graphics model description, processes
    and transforms the individual vertices to project then onto the screen, and combines
    their information for further processing of **primitives**.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rasterization**: It converts primitives into fragments. A **fragment** contains
    the data that is necessary to generate a pixel''s data in the frame buffer. Note
    that only the pixels affected by one or more primitives will have a fragment.
    A fragment contains information, such as raster position, depth, interpolated
    color, and texture coordinates.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fragment processing**: It processes each fragment. A series of operations
    are applied to each fragment, including alpha test, texture mapping, and so on.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Output merging**: It combines all fragments to produce the color values (including
    alpha) for the 2D display.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the modern computer graphics hardware, vertex processing and fragment processing
    are programmable. We can write programs to perform custom transform and processing
    of vertices and fragments. In contrast, rasterization and output merging are configurable,
    but not programmable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Each of the preceding stages can consist of one or more steps. OpenGL ES 1.x
    and OpenGL ES 2.0 provide different GRPs. Specifically, OpenGL ES 1.x provides
    a fixed function pipeline, where we input primitive and texture data, set up lighting,
    and OpenGL ES will handle the rest. In contrast, OpenGL ES 2.0 provides a programmable
    pipeline, which allows us to write vertex and fragment shaders in **OpenGL ES
    Shading Language** (**GLSL**) to handle the specifics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram indicaties the fixed function pipeline of OpenGL ES 1.x:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/1505_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'The following is another diagram that illustrates the programmable pipeline
    of OpenGL ES 2.0:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/1505_04_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the fixed pipeline in OpenGL ES 1.x has been
    replaced by the programmable shaders in OpenGL ES 2.0.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'With this introduction of computer graphics, we''re now ready to start our
    journey to Android NDK OpenGL ES programming. Android NDK provides both OpenGL
    ES 1.x (version 1.0 and version 1.1) and OpenGL ES 2.0 libraries, which differ
    significantly. The following table summarizes the factors to consider when considering
    the OpenGL ES version to use in our Android applications:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '|   | OpenGL 1.x | OpenGL 2.0 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| **Performance** | Fast 2D and 3D graphics. | Depending upon the Android device,
    but in general it provides faster 2D and 3D graphics. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| **Device compatibility** | Almost all Android devices. | Majority of Android
    devices, and increasing. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| **Coding convenience** | Fixed pipeline with convenient functions. Easy to
    use for simple 3D applications. | No built-in basic functions and more effort
    may be required for simple 3-D applications. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| **Graphics control** | Fixed pipeline. Difficult or impossible to create
    some effects (for example, cartoon shading). | Programmable pipeline. More direct
    control of the graphics processing pipeline to create certain effects. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenGL ES 1.0 is supported on all Android devices because Android comes with
    a 1.0-capable software graphics engine, which can be used on devices without corresponding
    graphics hardware. OpenGL ES 1.1 and OpenGL ES 2.0 are supported only on devices
    with corresponding **Graphics Processing Unit** (**GPU**).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover both the OpenGL 1.x and OpenGL ES 2.0 APIs in Android
    NDK. We first demonstrated how to draw 2D and 3D graphics using the OpenGL 1.x
    API. Transforms, lighting, and texture mapping are also covered. We then introduce
    the OpenGL 2.0 API in NDK. Lastly, we describe how to display graphics with EGL.
    This chapter introduces a few basics of computer graphics and principles of OpenGL.
    Readers who are already familiar with OpenGL ES can skip those parts and focus
    on how to invoke the OpenGL ES API from Android NDK.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We will provide a sample Android application for every recipe covered in this
    chapter. Due to space constraints, we cannot show all the source code in the book.
    Readers are strongly recommended to download the code and refer to to it when
    going through this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 2D Graphics and applying transforms with the OpenGL ES 1.x API
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers 2D drawing in OpenGL ES 1.x by example. In order to draw
    2D objects, we'll also describe the OpenGL rendering display through `GLSurfaceView`,
    adding colors to them, and transformation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the introduction of this chapter, which is essential
    to understand some of the content in this recipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create our sample Android NDK project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `TwoDG1`. Set the package name as `cookbook.chapter4.gl1x`.
    Please refer to the *Loading native libraries and registering native methods*
    recipe in [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native
    Interface*, if you want more detailed instructions.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `TwoDG1` project in Eclipse, select **Android Tools** | **Add
    Native Support**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following three Java files under the `cookbook.chapter4.gl1x` package:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyActivity.java`: It creates the activity of this project:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`MySurfaceView.java`: It extends `GLSurfaceView`, which provides a dedicated
    surface for displaying OpenGL rendering:'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`MyRenderer.java`: It implements `Renderer` and calls the native methods:'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `TwoDG1.cpp`, `Triangle.cpp`, `Square.cpp`, `Triangle.h`, and `Square.h`
    files under the `jni` folder. Please refer to the downloaded project for the complete
    content. Here, we only list some important parts of the code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TwoDG1.cpp`: It consists of the code to set up the OpenGL ES 1.x environment
    and perform the transforms:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Triangle.cpp`: It draws a 2D triangle:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Square.cpp`: It draws a 2D square:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the `Android.mk` file under the `jni` folder with following content :'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Build the Android NDK application and run it on an Android device. The following
    is a screenshot of the display:![How to do it...](img/1505_04_03.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe demonstrates basic 2D drawing with OpenGL ES.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES rendering display through GLSurfaceView
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GLSurfaceView` and `GLSurfaceView.Renderer` are the two foundational classes
    provided by Android SDK to display OpenGL ES graphics.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`GLSurfaceView` accepts a user defined `Renderer` object that does the actual
    rendering. It is often extended to handle touch events, which is illustrated in
    the next recipe. It supports both on-demand and continuous rendering. In our sample
    code, we simply set the `Renderer` object and configure the rendering mode to
    on-demand.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`GLSurfaceView.Renderer` is the interface for renderer. Three methods need
    to be implemented with it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`onSurfaceCreated`: It''s called once when setting up the OpenGL ES environment.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSurfaceChanged`: It''s called if the geometry of the view changes; most
    common examples are device screen orientation changes.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDrawFrame`: It''s called at each redraw of the view.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our sample project, `MyRenderer.java` is a simple wrapper, while the actual
    work is done in native C++ code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Drawing objects at OpenGL ES
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two methods are commonly used to draw objects in OpenGL ES, including `glDrawArrays`
    and `glDrawElements`. We demonstrate the usage of these two methods in `Triangle.cpp`
    and `Square.cpp` respectively. Note that both the methods require `GL_VERTEX_ARRAY`
    to be enabled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the mode of drawing, which indicates the primitive to
    use. In our sample code, we used `GL_TRIANGLES`, which means we're actually drawing
    two triangles to form the square. Other valid values in Android NDK OpenGL ES
    include `GL_POINTS`, `GL_LINES`, `GL_LINE_LOOP`, `GL_LINE_STRIP`, `GL_TRIANGLE_STRIP`,
    and `GL_TRIANGLE_FAN`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Colors at OpenGL ES
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also demonstrate two methods to add colors to the objects. In `Triangle.cpp`,
    we set the current color by the `glColor4f` API call. In `Square.cpp`, we enable
    `GL_COLOR_ARRAY`, and define an array of color by using `glColorPointer`. The
    array of colors will be used by the `glDrawElements` (it's also OK to use `glDrawArrays`)
    API call.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES transformation
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following diagram illustrates different transformation stages in OpenGL
    ES 1.0:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenGL ES transformation](img/1505_04_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'As illustrated in the diagram, vertex data are transformed before rasterization.
    The transforms are analogous to taking a photograph with a camera:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**ModelView transform**: Arrange the scene and place the camera'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection transform**: Choose a camera lens and adjust zoom factor'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Viewpoint transform**: Determine how large the final photograph is'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ModelView transform** actually refers to two different transforms, namely
    Model Transform and View Transform. **Model Transform** refers to the process
    of converting all objects from its object space (also known as local space or
    model space) to a world space, which is shared among all objects. This transform
    is done through a series of scaling (`glScalef`), rotation (`glRotatef`) and translation
    (`glTranslatef`).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`glScalef`: It stretches, shrinks, or reflects an object. The x-, y- and z-axis
    values are multiplied by the corresponding x, y, and z scaling factor. In our
    sample code, we called `glScalef(0.2f, 0.2f, 0.2f)` to scale down both the triangle
    and the square, so that they can fit into the screen.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glRotatef`: It rotates an object in a counter clockwise manner in the direction
    from the origin through specified point (x, y, z). The rotation angle is measured
    in degrees. In our sample code, we called `glRotatef(45.0, 0.0, 0.0, 1.0)` to
    rotate the square about the z-axis by 45 degrees.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glTranslatef`: It moves an object by the given values along each axis. In
    our sample code, we called `glTranslatef(0.3f, 0.0f, 0.0f)` to move the triangle
    to the right and `glTranslatef(-0.3f, 0.0f, 0.0f)` to move the square to the left,
    so that they won''t overlap.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model transform arranges the objects in a scene, while View transform changes
    the position of the viewing camera. To produce a specific image, we can either
    move the objects or change our camera position. Therefore, OpenGL ES internally
    performs the two transforms using a single matrix – the + `GL_MODELVIEW` matrix.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenGL ES defines that the camera is default at the origin (0, 0, 0) of eye
    coordinates space and aims into the negative z-axis. It is possible to change
    the position by `GLU.gluLookAt` at the Android SDK. However, the corresponding
    API is not available at Android NDK.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Projection transform** determines what can be seen (analogous to choosing
    camera lens and zoom factor) and how vertex data are projected onto the screen.
    OpenGL ES supports two modes of projection, namely perspective projection (`glFrustum`)
    and orthographic projection (`glOrtho`). **Perspective projection** makes objects
    that are farther away smaller, which matches with a normal camera. On the other
    hand, **Orthographic projection** is analogous to the telescope, which maps objects
    directly without affecting their size. OpenGL ES manipulates the transform through
    the `GL_PROJECTION` matrix. After a project transform, objects which are outside
    of the clipping volume are clipped out and not drawn in the final scene. In our
    sample project, we called `glOrthof(-ratio, ratio, -1, 1, 0, 10)` to specify the
    viewing volume, where `ratio` refers to the width to height ratio of the screen.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: After projection transform, perspective division is done by dividing the clip
    coordinates by the transformed `w` value of the input vertex. The values the for
    x-, y-, and z-axes will be normalized to the range between `-1.0` to `1.0`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stage of the OpenGL ES transform pipeline is the viewport transform,
    which maps the normalized device coordinates to window coordinates (in pixels,
    with the origin at the upper-left corner). Note that a viewpoint also includes
    a z component, which is needed for situations, such as ordering of two overlapping
    OpenGL scenes, and can be set with the `glDepthRange` API call. Applications usually
    need to set viewport when the display size changes through the `glViewport` API
    call. In our example, we set the viewport as the entire screen by calling `glViewport(0,
    0, width, height)`. This setting, together with the `glOrthof` call, will keep
    the objects in proportion after projection transform, as shown in the following
    diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenGL ES transformation](img/1505_04_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the diagram, the clipping volume is set to (-width/height, width/height,
    -1, 1, 0, 1). At perspective division, the vertex is divided by `w`. At viewpoint
    transform, both the x and y coordinates ranges are scaled up by `w*height/2`.
    Therefore, the objects will be in proportion as shown in the *How to do it...*
    section of this recipe. The left-had side of the following screenshot shows the
    output, if we set clipping volume by calling `glOrthof(-1, 1, -1, 1, 0, 1)`, and
    the right one indicates what the graphics look like if viewport is set by calling
    `glViewport(0, 0, width/2, height/5)`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenGL ES transformation](img/1505_04_06_new.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Drawing 3D graphics and lighting up the scene with the OpenGL ES 1.x API
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers how to draw 3D objects, handle touch events, and lighten
    up the objects in OpenGL ES.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the introduction and the *Drawing 2D Graphics
    and Apply Transforms with OpenGL ES 1.x API* recipies below before going through
    this one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to develop our sample Android project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `CubeG1`. Set the package name as `cookbook.chapter4.gl1x`.
    Please refer to the *Loading native libraries and registering native methods*
    recipe in [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native
    Interface*, if you want more detailed instructions.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project CubeG1, select **Android Tools** | **Add Native Support**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three Java files, namely `MyActivity.java`, `MySurfaceView`, and `MyRenderer.java`,
    under the `cookbook.chapter4.gl1x` package. `MyActivity.java` is the same as used
    in the previous recipe.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MySurfaceView.java` extends `GLSurfaceView` with the code to handle touch
    events:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`MyRenderer.java` implements a render to invoke the native methods to render
    the graphics:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `CubeG1.cpp`, `Cube.cpp`, and `Cube.h` files under the `jni` folder.
    Please refer to downloaded project for the complete content. Let''s list out the
    code for the `naInitGL1x`, `naSurfaceChanged`, and `naDrawGraphics` native methods
    in `CubeG1.cpp`, and draw and lighting methods in `Cube.cpp`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CubeG1.cpp` sets up the OpenGL ES environment and lighting:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Cube.cpp` draws a 3D cube and lightens it up:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Build the Android NDK application and run it on an Android device. The app will
    display a cube, which we can touch to rotate:![How to do it...](img/1505_04_08_new.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe discusses how to use the OpenGL ES 1.x API to draw 3D graphics.
    Note that we will need to load the OpenGL ES library `GLESv1_CM` in the `Andorid.mk`
    file, and include the header file `GLES/gl.h` in the native source code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing 3D objects in OpenGL ES**: Drawing 3D objects is similar to drawing
    2D objects. In the `Cube::draw` method, we first set up the vertex buffer and
    then called `glDrawElements` to draw the six faces of the cube. We used `GL_TRIANGLES`
    as a primitive. Since each face contains two triangles, there are 12 triangles
    and 36 vertices.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Touch event handling**: In `MySurfaceView.java`, we override the `onTouchEvent`
    method to detect the figure movement on screen and change the rotation angle attributes
    of `MyRenderer`. We call the `requestRender` method to request the renderer to
    redraw the graphics.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighting and material in OpenGL ES**: There are classes of lighting models,
    namely local illumination and global illumination. **Local illumination** only
    considers direct lighting, and therefore lighting calculation can be performed
    on individual objects. In contrast to this, **global illumination** takes indirect
    lighting reflected from other objects and the environment, and therefore is more
    computation-expensive. Local illumination is used in OpenGL ES 1.x, while the
    global illumination can be programmed using the **OpenGL Shading Language** (**GLSL**)
    in OpenGL ES 2.0\. Here, we discuss lighting in OpenGL ES 1.x only.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three parties are involved in OpenGL ES when lighting is considered, including
    camera position, light sources, and the material of the objects. Camera position
    is always at a default position `(0, 0, 0)` and aims into the negative z-axis,
    as discussed in the previous recipe. Light sources can provide separate ambient,
    diffuse, and specular lights. Materials can reflect different amounts of ambient,
    diffuse, and specular lights. In addition, materials may also emit light. Each
    of the light consists of RGB components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Ambient light**: It approximates the constant amount of light present everywhere
    in the scene.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diffuse light**: It approximates the light from distant directional light
    source (for example, sunlight). When the reflected light strikes a surface, it
    is scattered equally in all directions.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specular light**: It approximates the lights reflected by a smooth surface.
    Its intensity depends on the angle between the viewer and the direction of the
    ray reflected from the surface.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emission light**: Some materials can emit lights.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that RGB values in light sources indicate the intensity of the color component,
    while they refer to the reflected proportions of those colors in the material.
    To understand how both the light sources and material can affect the viewer perception
    of the object, think of a white light that strikes on a surface, which only reflects
    blue component of the light, then the surface will appear as blue for the viewer.
    If the light is pure red, the surface will be black for the viewer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps can be performed to set up simple lighting in OpenGL ES:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Set the lighting model parameters. This is done through `glLightModelfv`. Android
    NDK OpenGL ES supports two parameters, including `GL_LIGHT_MODEL_AMBIENT` and
    `GL_LIGHT_MODEL_TWO_SIDE`. The first one allows us to specify the global ambient
    light, and the second one allows us to specify whether we want to calculate lighting
    at the back of the surface.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable, configure, and place one or more light sources. This is done through
    the `glLightfv` method. We can configure ambient, diffuse, and specular light
    separately. The light source position is also configured through `glLightfv` with
    `GL_POSITION`. In `CubeG1.cpp`, we used the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The fourth value of the position indicates whether the light source is positional
    or directional. When the value is set to `0`, the light is directional, which
    simulates a light source that is far away (sunlight). The light rays are parallel
    when hitting the surface, and the (x, y, z) values of the position refer to the
    direction of the light. If the fourth value is set to `1`, the light is positional,
    which is similar to a light bulb. The (x, y, z) values refer to the position of
    the light source and the light rays hit the surface from different angles. Note
    that the light source emits light at equal intensities to all directions. The
    two kinds of lighting sources are illustrated in the following image:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How it works...](img/1505_04_22.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Besides positional and directional light sources, there''s also spotlight:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We shall enable lighting and the light sources also by calling
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: and
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Define the normal vectors for each vertex of all objects. The orientation of
    the object relative to the light sources is determined by these normals. In our
    code, we rely on OpenGL ES's default normals.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the material. This is done by the `glMaterialf` or `glMaterialfv` method.
    In our sample code, we specify the red component of the diffuse light to be `0.8`,
    while keeping the green and blue components 0\. Therefore, the final cube appears
    to be red.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mapping texture to 3D objects with the OpenGL ES 1.x API
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Texture mapping** is a technique that overlays an image onto an object''s
    surface to create a more realistic scene. This recipe covers how to add texture
    in OpenGL ES 1.x.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the *Drawing 3D graphics and lighting up the
    scene with OpenGL ES 1.x API* recipe before going through this one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create an Android project that demonstrates mapping texture
    to 3D objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `DiceG1`. Set the package name as `cookbook.chapter4.gl1x`.
    Please refer to the *Loading native libraries and registering native methods*
    recipe in [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native
    Interface*, if you want more detailed instructions.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `CubeG1`, select **Android Tools** | **Add Native
    Support**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three Java files, namely `MyActivity.java`, `MySurfaceView.java`, and `MyRenderer.java`
    under the `cookbook.chapter4.diceg1` package. `MyActivity.java` and `MySurfaceView.java`
    are similar to the previous recipe.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyRenderer.java` is listed as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the `DiceG1.cpp`, `Cube.cpp`, `Cube.h`, and `mylog.h` files under the `jni`
    folder. Please refer to the downloaded project for the complete content. Here,
    we list out the code the `fornaLoadTexture` and `naInitGL1x` native methods in
    `DiceG1.cpp`, and the `draw` method in `Cube.cpp`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Build the Android NDK application and run it on an Android device. The app will
    display a cube textured as a dice:![How to do it...](img/1505_04_10_new.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe adds a texture to the 3D cube to make it look like a dice.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Texture coordinates**: A texture is typically a 2D image. Texture coordinates
    `(s, t)` are usually normalized to `[0.0, 1.0]` as shown in the following diagram.
    Texture image is mapped to `[0, 1]` in both the `s` and `t` axes:![How it works...](img/1505_04_12.jpg)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loading textures**: The first step of mapping texture in OpenGL ES is to
    load them. In our example, we used Android SDK to read image files from drawable
    resources and pass the bitmaps to native code. The native method `naLoadTexture`
    locks the bitmap image and performs the following OpenGL operations.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create the glGenTexture texture**: This generates texture IDs.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bind texture: glBindTexture. This tells OpenGL which texture id we''re working
    with.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set the texture filtering**: `glTexParameter` with `GL_TEXTURE_MIN_FILTER`
    or `GL_TEXTURE_MAG_FILTER` (this is discussed later).'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set the texture wrapping**: `glTexParameter` with `GL_TEXTURE_WRAP_S` or
    `GL_TEXTURE_WRAP_T` (this is discussed later).'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load the images data to OpenGL**: (`glTexImage2D`) we need to specify image
    data, width, height, color format, and so on.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture wrapping**: texture is mapped to `[0, 1]` in both the s and t axes.
    However, we can specify the texture coordinates beyond the range. Wrapping will
    be applied once that happens. Typical settings for texture wrapping are as follows:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_CLAMP`: Clamp the texture coordinates to `[0.0, 1.0]`.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_REPEAT`: Repeat the texture. This creates a repeating pattern.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture filtering**: It is common that the texture image has a different
    resolution than the object. If the texture is smaller, magnification is performed;
    if the texture is larger, minification is performed. The following two methods
    are used generally:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_NEAREST`: Use the texture element that is nearest to the center of the
    pixel being textured.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_LINEAR`: Apply interpolation to calculate the color values based on the
    four texture elements closest to the pixel being textured.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set the texture environment**: Before we map textures to objects, we can
    call `glTexEnvf` to control how texture values are interpreted when a fragment
    is textured. We can configure `GL_TEXTURE_ENV_COLOR` and `GL_TEXTURE_ENV_MODE`.
    In our sample project, we used the `GL_REPLACE` for `GL_TEXTURE_ENV_MODE`, which
    simply replaces the cube fragments with texture values.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping the texture**: We draw each face of the 3D cube and map the texture
    by `glDrawElement`. `GL_TEXTURE_COORD_ARRAY` must be enabled by calling `glEnableClientState`.
    Before drawing each interface, we bind to the corresponding texture by calling
    `glBindTexture`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our native code, we used the Android native bitmap API to receive texture
    bitmap object from Java code. More details of this API will be covered in [Chapter
    7](ch07.html "Chapter 7. Other Android NDK API"), *Other Android NDK API*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 3D graphics with the OpenGL ES 2.0 API
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipes describe OpenGL ES 1.x on the Android NDK. This recipe
    covers how to use OpenGL ES 2.0 in Android NDK.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Readers are recommended to read the introduction of this chapter before going
    through this recipe. A lot of graphic basics are covered in the following recipes;
    it is suggested that we go through them first:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '*Drawing 2D graphics and applying transforms with OpenGL ES 1.x API*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing 3D graphics and lighting up the scene with OpenGL ES 1.x API*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create an Android project that renders a 3D cube with OpenGL
    ES 2.0 API in Android NDK:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `CubeG2`. Set the package name as `cookbook.chapter4.cubeg2`.
    Please refer to the *Loading native libraries and registering native methods*
    recipe of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native
    Interface*, if you want more detailed instructions.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `CubeG2`, select **Android Tools** | **Add Native
    Support**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add three Java files, namely `MyActivity.java`, `MyRenderer.java`, and `MySurfaceView.java`.
    We only list a part of `MyRenderer.java` here, since the other two files—`MyActivity.java`
    and `MySurfaceView.java`—are similar to the files in the previous recipe:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `Cube.cpp`, `matrix.cpp`, `CubeG2.cpp`, `Cube.h`, `matrix.h`, and `mylog.h`
    files under the `jni` folder. The content of the files are summarized as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cube.cpp and Cube.h**: They define a `Cube` object and method to draw a 3D
    cube.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**matrix.cpp and matrix.h**: These matrix operations, including creating translation,
    scale and rotation matrices, and matrix multiplication.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CubeG2.cpp**: They create and load shaders. They also create, link, and use
    programs and apply transformations to the 3D cube.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mylog.h**: They define macros for Android NDK logging.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we list a part of `Cube.cpp` and `CubeG2.cpp`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Cube.cpp`:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`CubeG2.cpp`: It includes the `loadShader`, `createProgram`, `naInitGL20`,
    and `naDrawGraphics` methods, which are explained as follows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`loadShader`: This method creates a shader, attaches a source, and compiles
    the shader:'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`createProgram`: This method creates a program object, attaches shaders, and
    links the program:'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`naInitGL20`: This method sets up the OpenGL ES 2.0 environment, gets the shader
    source string, and gets the shader attribute and uniform positions:'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`naDrawGraphics`: This method applies model transforms (rotate, scale, and
    translate) and the projection transform:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a folder named `raw` under the `res` folder, and add the following two
    files to it:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vshader`: This is the vertex shader source:'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`fshader`: This is the fragment shader source:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the `Android.mk` file under the `jni` folder as follows. Note that we must
    link to OpenGL ES 2.0 by `LOCAL_LDLIBS := -lGLESv2`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following line before `<application>...</application>` in the `AndroidManifest.xml`
    file, which indicates that the Android application uses the OpenGL ES 2.0 feature:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Build the Android NDK application and run it on an Android device. The app will
    display a cube and we can touch to rotate the cube:![How to do it...](img/1505_04_13_new.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample project renders a 3D cube using OpenGL ES 2.0\. OpenGL ES 2.0 provides
    a programmable pipeline, where a vertex shader and fragment shader can be supplied
    to control how the vertex and fragment are processed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex shader**: It''s executed for every vertex. Transforms, lighting, texture
    mapping, and so on are usually performed using it.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment shader**: It''s executed for every fragment produced by the rasterizer.
    A typical processing is to adding colors to every fragment.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders are programmed using OpenGL Shading Language, which is discussed next.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL Shading Language (GLSL)
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we briefly introduce GLSL.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Data types**: They are of four main types, including `bool`, `int`, `float`,
    and `sampler`. There are also vector types for the first three types—`bvec2`,
    `bvec3`, `bvec4` refer to 2D, 3D, and 4D boolean vectors. `ivec2`, `ivec3`, and
    `ivec4` represent integer vectors. `vec2`, `vec3`, and `vec4` refer to floating
    point vectors. **Samplers** are used for texture sampling and have to be uniform.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes, uniforms, and varyings**: A shader includes three types of inputs
    and outputs, including uniforms, attributes, and varyings. All three types have
    to be global:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform**: It is of read-only type and doesn''t need to be changed during
    rendering. For example, light position.'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: It is of read-only type and is only available as an input to
    the vertex shader. It changes for every vertex. For example, vertex position.'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Varying**: It is used to pass data from the vertex shader to the fragment
    shader. It is readable and writable in the vertex shader, but only readable in
    the fragment shader.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in types**: GLSL has various built-in attributes, uniforms, and varyings
    for shaders. We highlight a few of them as follows:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl_Vertex`: It is an attribute—a 4D vector representing the vertex position.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl_Color`: It is an attribute—a 4D vector representing the vertex color.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl_ModelViewMatrix`: It is an uniform—the 4x4 model view matrix.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl_ModelViewProjectionMatrix`: It is a uniform. The 4x4 model view projection
    matrix.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl_Position`: It is only available as vertex shader output. It''s a 4D vector
    representing the final processed vertex position.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl_FragColor`: It is only available as fragment shader output. It''s a 4D
    vector representing the final color to be written to the frame buffer.'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use shader:'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our sample project, the vertex shader program simply multiplies every cube
    vertex with the model-view-projection matrix, and the fragment shader sets green
    color to every fragment. The following steps should be followed to use the shader
    source code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**Create Shaders**: The following OpenGL ES 2.0 methods are called:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`glCreateShader`: It creates a `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER` shader.
    A non-zero value is returned by it, by which the shader can be referenced.'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glShaderSource`: It puts the source code in a shader object. The source code
    stored previously will be completely replaced.'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glCompileShader`: It compiles the source code of the shader object.'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create a program and attach the shaders**: The following methods are called:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`glCreateProgram`: It creates an empty program object to which shaders can
    be attached. Program objects essentially provide a mechanism to link everything
    needed to be executed together.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glAttachShader`: It attaches a shader to a program object.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glLinkProgram`: It links a program object. If any `GL_VERTEX_SHADER` objects
    are attached to the program object, they will be used to create an executable
    running on the vertex processor. If any `GL_FRAGMENT_SHADER` shaders are attached,
    they will be used to create an executable running on the fragment processor.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the program**: We use the following calls to pass data to shaders and
    perform OpenGL operations:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`glUseProgram`: A program object as part of current rendering state is installed'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glGetAttribLocation`: It returns an attribute variable''s location'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glVertexAttribPointer`: It specifies the location and data format of the array
    of generic vertex attributes to use at rendering'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glEnableVertexAttribArray`: It enables a vertex attribute array'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glGetUniformLocation`: It returns a uniform variable''s location'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glUniform`: It specifies the value of a uniform variable'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glDrawArrays`: It renders primitives from the array data.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample project performs model-view transform and projection transform through
    **matrix operations**. The details of these transforms are tedious and not within
    the scope of this book, therefore we won't cover them here. However, detailed
    comments are provided along with the code. Interested readers could also easily
    find online resources about these operations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Displaying graphics with EGL
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the `GLSurfaceView` display mechanism we described in the previous recipe,
    it is also possible to display OpenGL graphics using EGL.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the *Drawing 3D Graphics and Lighting up the
    Scene with OpenGL ES 1.x API* recipe before going through this one.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create an Android project that demonstrates
    the usage of EGL:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `EGLDemo`. Set the package name as `cookbook.chapter4.egl`.
    Please refer to the *Loading native libraries and registering native methods*
    recipe in [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native
    Interface*, if you want more detailed instructions.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `EGLDemo`, select **Android Tools** | **Add Native
    Support**.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two Java files, namely `EGLDemoActivity.java` and `MySurfaceView.java`.
    `EGLDemoActivity.java` sets `ContentView` as an instance of `MySurfaceView`, and
    starts and stops rendering at the Android activity callback functions:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`MySurfaceView.java` performs role similar to `GLSurfaceView`. It interacts
    with the the native renderer to manage the display surface and handle touch events:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code should be added to the `jni` folder:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cube.cpp and Cube.h**: Use the OpenGL 1.x API to draw a 3D cube.'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OldRenderMethods.cpp and OldRenderMethods.h**: Initialize OpenGL 1.x, perform
    transforms, draw graphics, and so on. This is similar to the corresponding methods
    in *the Drawing 3D Graphics in OpenGL 1.x* recipe.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Renderer.cpp and Renderer.h**: Simulate `android.opengl.GLSurfaceView.Renderer`.
    It sets up the EGL context, manages the display, and so on.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderAFrame`: It sets the event type, and then signals the rendering thread
    to handle the event:'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`renderThreadRun`: It runs in a separate thread to handle various events, including
    surface change, draw a frame, and so on:'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`initDisplay`: It sets up the EGL context:'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`EGLDemo.cpp`: It registers the native methods and wraps the native code. The
    following two methods are used:'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`naSurfaceChanged`: It gets the native window associated with a Java `Surface`
    object and initializes EGL and OpenGL:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`naRequestRenderer`: It renders a frame, which is called by the `touch` event
    handler in `MySurfaceView`:'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Build the Android NDK application and run it on an Android device. The app will
    display a cube, which we can touch to rotate it:![How to do it...](img/1505_04_15_new.jpg)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EGL is an interface between OpenGL ES and the underlying native window system.
    According to Khronos EGL web page ([http://www.khronos.org/egl](http://www.khronos.org/egl)),
    graphics context management, surface binding, and rendering synchronization for
    rendering with other Khronos 2D and 3D APIs, including OpenGL ES are handled by
    it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**EGL** is a cross-platform API widely used in embedded systems, including
    Android and iPhone (the EGL implementation from Apple is called **EAGL**). Many
    desktop platforms also support EGL. Different implementations may not be 100 percent
    compatible, but the porting effort will usually not be substantial for the EGL
    code.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps describe how to set up and manipulate EGL and its integration
    with OpenGL:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Get and initialize the display connection**: EGL needs to know where the
    content should be displayed, therefore we will need to get a display connection
    and initialize it. This is done using the following two methods:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eglGetDisplay`: It obtains the EGL display connection for the native display.
    If the input argument is `EGL_DEFAULT_DISPLAY`, a default display connection is
    returned.'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eglInitialize`: It initializes an EGL display connection obtained by `eglGetDisplay`.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure EGL**: This is done through `eglChooseConfig`.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eglChooseConfig` returns a list of EGL frame buffer configurations that match
    the requirements specified by the `attrib_list` argument. The attribute is an
    array with pairs of attributes and corresponding desired values, and it is terminated
    by `EGL_NONE`. In our code, we simply specify `EGL_SURFACE_TYPE` as `EGL_WINDOW_BIT`,
    and color components sizes as 8 bit.'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create a render surface where the display content will be placed**: This
    is done through `eglCreateWindowSurface`.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eglCreateWindowSurface`, given the EGL display connection, the EGL frame buffer
    configuration and native window returns a new EGL window surface.'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our code, we start from `SurfaceView` and pass its associated `android.view.Surface`
    value to the native code. In the native code, we obtain its native window, and
    finally create the EGL window surface for OpenGL drawing.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create the EGL rendering context and make it the current**: This is done
    by `eglCreateContext` and `eglMakeCurrent`.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eglCreateContext`: It creates a new EGL rendering context, which is used to
    render into the EGL draw surface.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eglMakeCurrent`: It attaches an EGL context to the EGL draw and read surfaces.
    In our code, the created window surface is used as both the read and draw surface.'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenGL drawing**: This is covered in previous recipes.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Swap the EGL surface internal buffers to display the content**: This is done
    by the `eglSwapBuffers` call.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eglSwapBuffers` posts the EGL surface color buffer to a native window. This
    effectively displays the drawing content on the screen.'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: EGL internally maintains two buffers. The content of the front buffer is displayed,
    while the drawing can be done on the back buffer. At the time we decided to display
    the new drawing, we swap the two buffers.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At time we want to stop rendering. Release the EGL context, destroy the EGL
    surface, and terminate the EGL display connection:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eglMakeCurrent` with `EGL_NO_SURFACE` and `EGL_NO_CONTEXT` releases the current
    context'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eglDestroySurface` destroys an EGL surface'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eglTerminate` terminates the EGL display connection'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eglTerminate` 终止了 EGL 显示连接'
- en: Window management
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口管理
- en: 'Our code uses the Android native window management API calls to obtain a native
    window and configure it. The following methods are called:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码使用 Android 原生窗口管理 API 调用来获取原生窗口并配置它。调用了以下方法：
- en: '`ANativeWindow_fromSurface`: It returns a native window associated with the
    Java surface object. The returned reference should be passed to `ANativeWindow_release`
    to ensure there''s no leaking.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANativeWindow_fromSurface`：它返回与 Java 表面对象关联的原生窗口。返回的引用应该传递给 `ANativeWindow_release`，以确保没有内存泄漏。'
- en: '`ANativeWindow_setBuffersGeometry`: It sets the size and format of window buffers.
    In our code, we specified width and height as `0`, in which case the window''s
    base value will be used.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANativeWindow_setBuffersGeometry`：它设置窗口缓冲区的大小和格式。在我们的代码中，我们将宽度和高度指定为 `0`，在这种情况下，将使用窗口的基本值。'
- en: Note that we'll need to link to the Android library in the `Android.mk` file
    (`LOCAL_LDLIBS := -landroid`), because it is a part of the Android native application
    API, which we will cover more in the next chapter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在 `Android.mk` 文件中链接到 Android 库（`LOCAL_LDLIBS := -landroid`），因为它是 Android
    原生应用程序 API 的一部分，我们将在下一章中详细介绍。
- en: There's more...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The renderer runs an event loop in a separate thread. We used the **POSIX thread**
    (`pthreads`) calls to create a native thread, synchronize it with the main thread,
    and so on. We'll cover `pthread` in detail in [Chapter 6](ch06.html "Chapter 6. Android
    NDK Multithreading"), *Android NDK Multithreading*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器在一个单独的线程中运行事件循环。我们使用了**POSIX 线程**（`pthreads`）调用创建原生线程，将其与主线程同步等。我们将在[第6章](ch06.html
    "第6章. Android NDK 多线程")，*Android NDK Multithreading*中详细讲解 `pthread`。
