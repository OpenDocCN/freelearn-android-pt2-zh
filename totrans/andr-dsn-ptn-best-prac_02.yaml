- en: Chapter 2. Creational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a look at the **factory pattern** and its associated
    **abstract factory pattern**. However, we looked at these patterns in quite a
    general way and not at how these objects, once created, can be represented and
    manipulated on an Android device. In other words, the patterns we built could
    have been applied in many other software environments, and to see how to make
    them more Android-specific we need to take a look at Android UIs and how they
    are composed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will concentrate on how to represent our products as Android
    UI components. We will use the **card view** to display these, and each card will
    contain a title, an image, some descriptive text, and the ingredient''s calorific
    value, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creational Patterns](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will lead us to take an initial look at **material design,** a powerful
    and increasingly popular **visual design language** for creating clean and intuitive
    UIs. Conceived originally for the smaller screens of mobile devices, material
    design is now widely considered such a valuable UI paradigm that its use has spread
    from Android devices to websites and even other mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Material design** is more than just fashionable, it provides a very effective
    series of guidelines for following best UI construction practices. Material design
    provides visual patterns that are analogous to the programmatic patterns we have
    already discussed. These patterns provide well-defined structures that are clean
    and simple to operate. Material design covers concepts such as proportion, scaling,
    typography, and spacing, all of which are very easily managed within the IDE and
    neatly prescribed by material design guidelines.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have seen how to represent our ingredients as workable UI components,
    we will take a look at another commonly used creational pattern, the **builder
    pattern**. This will demonstrate a pattern that allows us to build a single *sandwich*
    object from our individual *ingredient* objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit material styles and themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply palettes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize text settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage screen densities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the card view support library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand z-depth and shading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying material design to a card view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it can be changed at any time, one of the first things we should consider
    when building an Android app is the color scheme. This is the way that the framework
    allows us to customize the color and appearance of many familiar screen components,
    such as the title and status bar background colors and text and highlight shades.
  prefs: []
  type: TYPE_NORMAL
- en: Applying themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we want our apps to stand out from the crowd, but we also want
    to incorporate all the features that Android users are familiar with. One way
    to do this is by applying a particular color scheme throughout an app. This is
    most easily done by customizing or creating Android themes
  prefs: []
  type: TYPE_NORMAL
- en: Since API level 21 (Android 5.0), the **material theme** has been default on
    Android devices. It is, however, more than just a new look. The material theme
    also provides as default the touch feedback and transition animations that we
    associate with material design. As with all Android themes, the material themes
    are based on Android styles.
  prefs: []
  type: TYPE_NORMAL
- en: An **Android style** is a set of graphical properties defining the appearance
    of a particular screen component. Styles allow us to define everything from font
    size and background color to padding and elevation, and much more. An Android
    theme is simply a style applied across a whole activity or application. Styles
    are defined as XML files, and stored in the resources (`res`) directory of Android
    Studio projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Android Studio comes with a graphical **theme editor** that generates
    the XML for us. Nevertheless, it is always good to understand what is going on
    under the hood, and this is best seen by opening the abstract factory project
    from the last chapter or by starting a new one. From the project explorer, open
    the `res/values/styles.xml` file. It will contain the following style definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, only three colors are defined, although we could have had more, such
    as primary and secondary text colors, window background color, and others. The
    colors themselves are defined in the `colors.xml` file, which is also found in
    the `values` directory and will contain the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is quite possible to apply more than one theme and incorporate as many styles
    as we might like, but generally speaking, a single theme applied across an entire
    application that customizes one of the default material themes is the easiest
    and cleanest answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to customize the default theme is with the theme editor, which
    can be opened from the `Tools | Android` menu. The editor provides a powerful
    WYSIWYG preview pane that allows us to instantly view any changes we make as we
    make them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying themes](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although we are free to choose any colors we like for our theme, the material
    design guidelines are quite clear about how colors should be used together. This
    is best explained by taking a look at **material palettes**.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing color and text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first things we need to consider when applying a theme are colors and text.
    Material design guidelines recommend selecting these colors from a predefined
    series of palettes.
  prefs: []
  type: TYPE_NORMAL
- en: Using palettes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two most significant colors we can edit in a material theme are the primary
    colors. They are applied directly to the status and app bars and give an app a
    distinctive look without affecting the uniform feel of the platform as a whole.
    Both these colors should be selected from the same color palette. There are many
    such palettes available, and the entire collection can be found at www.google.com/design/spec/style/color.html#color-color-palette.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever palette you decide to use as your primary colors, Google recommend
    that you use shades with values of **500** and **700**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using palettes](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This does not have to be enforced too strictly, but it usually a good idea to
    stick close to these values and to always select two shades of the same color.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The theme editor can be very helpful here; not only do its solid color blocks
    offer tooltips telling us the shade value, but once we have picked a primary color,
    it will suggest a suitable darker version.
  prefs: []
  type: TYPE_NORMAL
- en: Our choice of primary shades needs to be considered when selecting the accent
    color. This will be applied to switches and highlights and needs to contrast nicely
    with the primary color. There are no simple rules governing which colors contrast
    with each other other than pick a color that looks good and has a light shade
    value of **100**, or close by.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to change the color of the navigation bar at the foot of the
    screen with `navigationBarColor`, but this is not recommended as the navigation
    bar should not really be thought of as part of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the other theme settings can be left as they are for most purposes.
    However, if you wish to change text colors there are one or two things to note.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Material text does not generate lighter shades by using lighter hues, but rather
    by using the alpha channel to create varying levels of **transparency**. The reason
    for this is that this looks more pleasing when used on different colored backgrounds
    or images. The rules for text transparency are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing text](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a lot that can be done with styles and themes, but for now it is enough
    to create a simple color scheme and know that it will be applied consistently
    across an application. Our next task will be to see how we can expand the sandwich
    ingredient objects we considered earlier into a user-friendly interface. No doubt
    one of the best ways to entice a user is with an appetizing photograph.
  prefs: []
  type: TYPE_NORMAL
- en: Adding image resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most interesting challenges that Android offers is the vast number
    of screen densities and sizes that we have to cater for. This is particularly
    true when it comes displaying bitmap images, where there are two competing issues
    that need to be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: Low resolution images display very poorly when stretched to fit on large or
    high resolution screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High quality images use up far more memory than is needed when displayed on
    smaller, low density screens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen sizes aside, the problem of differing screen densities is mostly solved
    with the use of **density-independent pixels** (**dp**).
  prefs: []
  type: TYPE_NORMAL
- en: Managing screen densities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dps are an abstract unit of measurement based on a screen displaying 160 dpi.
    This means that a widget with a width of 320 dp will always be 2'' wide regardless
    of screen density. When it comes to the actual physical dimensions of a screen,
    this can be managed with a variety of layout types, libraries, and properties
    such as weight and gravity, but for now we will look at how to provide images
    that suit the widest possible range of screen densities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android system divides screen densities with the following qualifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: Low density (`ldpi`) - **120 dpi**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Medium density (`mdpi`) - **160 dpi**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High density (`hdpi`) - **240 dpi**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra-high density (`xhdpi`) - **320 dpi**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra-extra-high density (`xxhdpi`) - **480 dpi**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra-extra-extra-high density (`xxxhdpi`) - **640 dpi**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During an app's installation, each device will only download images that match
    its own specifications. This saves memory on older devices and still provides
    the richest possible visual experience on devices that are capable.
  prefs: []
  type: TYPE_NORMAL
- en: From a developer's point of view, it might seem that we have to generate six
    versions of every image we want to include in any given project. Thankfully, this
    is not usually the case. The difference between a 640 dpi image and, say, a 320
    dpi image is hardly noticeable on most handheld devices, and considering that
    most users of our sandwich builder app will simply want to scroll through a menu
    of ingredients, rather than scrutinize the quality of our imagery, we can safely
    provide images for medium, high, and extra-high density devices only.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good rule of thumb when considering image quality for high-end devices is
    to compare our image sizes with those produced by the device's native camera.
    It is unlikely that providing larger images will improve user experience enough
    to justify the extra memory required.
  prefs: []
  type: TYPE_NORMAL
- en: In our example here, we will want to provide images that fit onto a card view
    that will occupy most of the screen width in portrait mode. For now, find an image
    that is roughly 2,000 pixels in width. In the following example, it is called
    `sandwich.png` and is 1,920 by 1,080 pixels in size. Your image does not have
    to match these dimensions, but later we will see how well-selected image proportions
    are considered a significant part of good UI practice.
  prefs: []
  type: TYPE_NORMAL
- en: An image that has a width of 1,920 pixels would be six inches wide when displayed
    on an extra-high density device displaying 320 dpi. We will assume, for now at
    least, that our app will be accessed from mobile devices, rather than computers
    or televisions, so even on a high density, 10'' tablet, six inches will be more
    than enough for our purposes. Next, we will see how to prepare for other screen
    densities too.
  prefs: []
  type: TYPE_NORMAL
- en: Using designated resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Providing alternative bitmaps to suit a variety of screen densities is easily
    achieved by assigning **designated resource directories** to contain images configured
    for specific screen densities. From Android Studio, we can create such directories
    from the project explorer with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a `New | Directory` from the `res` folder and call it `drawable-mdpi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create two more sibling directories called `drawable-hdpi` and `drawable-xhdpi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open these new folders directly by selecting **Show in Explorer** in the `drawable`
    context menu from the project explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `sandwich.png` image to the `drawable-xhdpi` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make two copies of this image and re-scale them so that one is 3:4 the original
    scale and the other 1:2 scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place these copies in the `drawable-hdpi` and `drawable-mdpi` directories respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These variations will now appear in the project explorer, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using designated resources](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now rest assured that only the most suitable and memory efficient image
    resource will be downloaded according to a device''s native screen density. To
    see how this looks, add the following image view to the project''s `activity_main.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be viewed with the preview screens on any emulator or real device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using designated resources](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The nice thing about this approach is that once we have the variations of our
    image designated correctly, we can simply refer to it as `@drawable/sandwich`
    and forget about the actual device it is being viewed on or which directory it
    is stored in.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us free to explore how we might include our images as part of a
    broader interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a card view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The card view is one of the most recognizable material design components. It
    is designed to show several pieces of content that all apply to a single subject.
    This content is usually a combination of graphics, text, action buttons, and icons,
    and cards are a great way to present a selection of choices in a uniform way.
    This makes it a good choice for displaying our sandwich ingredients and related
    information such as price or calorific value. We will use the factory pattern
    from the previous chapter to do this, but before we see what code needs changing,
    let's take a look at how we implement the card view in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding card view properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your minimum target SDK is 21 or greater, then the **CardView** widget will
    be included as standard. Otherwise, you will need to include the cardview support
    library. This is easily added in the `build.gradle` file by including the following
    highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As the name of the support library suggests, we can only support card views
    as far back as API level 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not necessary to edit the `build.gradle` file manually, although it is
    useful to know how, as it can be done more simply via the `File | Project Structure...`
    menu and selecting the items shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding card view properties](img/image_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some developers version their support libraries with a `+` symbol, like so:
    `com.android.support:cardview-v7:23.` **+**. This is an attempt to anticipate
    future libraries. This generally works very well, but it does not guarantee that
    these apps might not crash at a later date. It is a little more time-consuming,
    but far smarter, to use the compiled SDK version during development and then update
    the app regularly once it is published.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to rebuild the project before we can add the card view to our
    layout. First, we will need to set some of the card''s properties. Open the `res/values/dimens.xml`
    file and add the following three new dimension resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the card as a widget in the main XML activity file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The use of shadowing does more than just give a three-dimensional appearance
    to an interface; it demonstrates the layout hierarchy graphically, making it obvious
    to the user which functions are available.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have spent any time examining the card view properties, you will have
    noticed the `translationZ` property. This appears to have the same effect as `elevation`.
    However, `elevation` will set the card's absolute elevation, whereas `translationZ`
    is a relative setting and its value will be added or subtracted from the current
    elevation.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a card view set up, we can fill it out to represent our sandwich
    ingredients according to material design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Applying CardView metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design guidelines are very clear about such issues as typeface, padding, and
    scale. Once we start using the CoordinatorLayout, a lot of these settings will
    be set automatically, but for now, it is a good idea to see how these metrics
    are applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different patterns for cards, and a full description of them
    can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.google.com/design/spec/components/cards.html](http://open the Java activity
    file extend it so that it implements)'
  prefs: []
  type: TYPE_NORMAL
- en: The one we will create here will contain an image, three text items, and an
    action button. Cards can be considered as container objects, and as such, normally
    contain their own root layout. This can be placed directly inside the card view
    itself, but it makes for more readable and more flexible code if we create the
    card content as a separate XML layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need at least one image for this next exercise. According to material
    design, photographic images should be clear, bright, simple, and present a single,
    unambiguous subject. For example, if we wanted to add coffee to our menu, the
    image on the left would be the most suitable of the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying CardView metrics](img/image_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Card images need to have a width to height ratio of 16:9 or 1:1\. Here, we will
    use 16:9, and ideally we should produce scaled versions to suit various screen
    densities, but as this is only a demonstration, we can be lazy and just place
    the originals directly into the `drawable` folder. This approach is far from best
    practice, but is fine for preliminary testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have sourced and saved your images, the next step is to create a layout
    for our card:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the project explorer, navigate to `New | XML | Layout XML File` and call
    it `card_content.xml`. Its root view group should be a linear layout with a vertical
    orientation, and it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using either the graphical or text editor, create a layout structure to match
    the **Component Tree** seen here:![Applying CardView metrics](img/image_02_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now include this layout inside the card view from the main activity layout
    file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is editable, the recommended elevation for a card view is 2 dp,
    unless it has been selected and/or is being moved, in which case it has an elevation
    of 8 dp.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As you will no doubt know, the use of strings that are hard-coded into XML
    resources are strongly discouraged. If nothing else, this makes the process of
    translating our apps into other languages almost impossible. However, during the
    early stages of layout design, it helps to provide some placeholder values to
    give an idea of how a layout might look. Later, we will control card content using
    Java, and select this content based on user input; but for now, we will select
    some typical values so that we can see the effect our settings have easily and
    quickly. To see how this is of use, add the following properties, or equivalent,
    to the `strings.xml` file in the `values` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we will use these placeholders to evaluate any changes we make as
    we make them. The layouts we just created should, when viewed as a preview, look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying CardView metrics](img/image_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Converting this into a materially designed component requires nothing more than
    some formatting and a little knowledge of material guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The metrics for this layout are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The image must have a ratio of 16:9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title text should be 24 sp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The descriptive text is 16 sp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The margins around the bottom right and left of the text is 16 dp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The margin above the title text is 24 dp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action text as 24 sp and takes its color from the accent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties are very easily set from either the properties panel or by
    editing the XML directly. There are one or two things not mentioned here, so it
    is worth taking a look at each element separately.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is essential to point out that these values should never be described
    literally in the code as they are in the following snippet; for example, `android:paddingStart="24dp"`
    should be coded as something like `android:paddingStart="@dimen/text_paddingStart"`
    with `text_paddingStart` being defined in the `dimens.xml` files. Here, the values
    have been hard-coded only to simplify the explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for image view at the top should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is very straightforward, but do note the use of `contentDescription`; this
    is used when a visually impaired user has set accessibility options so that images
    can be appreciated by having their descriptions read out by the device's voice
    synthesizer.
  prefs: []
  type: TYPE_NORMAL
- en: Beneath this are the following three text views.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These too are very simple to follow. All that really needs pointing out is the
    use of `Start` and `End` as opposed to `Left` and `Right` to define padding and
    gravity, as this helps apply our layout correct itself when translated into languages
    where text runs from right to left. We also included the `textAppearance` property,
    which may appear redundant as we also set text size directly. Attributes such
    as `textAppearanceMedium` are useful as not only do they automatically apply text
    coloring according to our customized theme, they will also adjust their size according
    to individual users' global text size settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves only the action button at the bottom, and as this uses a text view
    rather than a button, this may require a little explanation. The XML looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are two reasons why we chose a text view here where it would seem to make
    sense to use a button widget. Firstly, Android recommends the use of a **flat
    button** where only the text is visible on card views; and secondly, the touchable
    area that triggers an action needs to be larger than the text itself. This is
    easily performed by setting the padding properties as we have previously. To make
    a text view behave like a button, we only need to add the line `android:clickable="true"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our finished card should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying CardView metrics](img/image_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a lot more to the design of card views, but this should serve as a
    good introduction to some of the principles we need to follow, and for now, we
    can see how these new ways of presenting our objects reflect on our factory pattern
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the beauties of design patterns is the ease by which they can adapted
    to suit any changes we wish to make. We could, if we chose, leave our factory
    code as it is and use the single string output to direct the client code to the
    appropriate dataset. It is more in keeping with the nature of patterns, though,
    to adapt them to match our slightly more complex ingredient objects.
  prefs: []
  type: TYPE_NORMAL
- en: The thought that went into our code structure in the last chapter now pays off,
    as although we need to edit our interfaces and concrete examples, we can leave
    the factory classes themselves just as they are, and this demonstrates one of
    the advantages of patterns rather nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the four criteria we used to build our card, our updated interfaces could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual objects could look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we move forward, we will need more properties for our objects, such as price
    and whether they are vegetarian or contain nuts, and as our objects become more
    complex we will have to apply more sophisticated ways to manage our data, but
    in principle there is nothing wrong with the approach we are using here. It may
    be bulky, but it is certainly easy to read and maintain. Factory patterns are
    clearly very useful, but they only create single objects. To model a sandwich
    more realistically, we need to be able to put *ingredient* objects together and
    treat the entire collection as a single *sandwich* object. This is where the builder
    pattern comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The builder design pattern is one of the most useful creational patterns as
    it builds larger objects from smaller ones. This is precisely what we want to
    do to construct a sandwich object from a list of ingredients. The builder pattern
    has a further advantage in that optional features are easy to include later. As
    before, we will begin by creating an interface; we will call it `Ingredient` and
    use it to represent both `bread` and `filling`. This time, we will need to represent
    calories as an integer, as we will need to calculate the total amount in a finished
    sandwich.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open an Android Studio project, or start a new one, and follow the proceeding
    steps to create a basic sandwich builder pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new interface called `Ingredient.java`, and complete it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create an abstract class for `Bread` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And create an identical one called `Filling`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create concrete classes of `Bread`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the same for `Filling`. Two classes of each type should be enough for demonstration
    purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create our `Sandwich` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create the `SandwichBuilder` class like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This completes our builder design pattern, for now at least. When viewed as
    a diagram, it looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Applying a builder pattern](img/image_02_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here, we have provided the builder with two functions: to return a ready-made
    sandwich and a user-customized one. We have no working interface as yet, but we
    can simulate user choice via our client code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also delegated output responsibilities to the `Sandwich` class itself,
    and this is often a good idea as it helps keep our client code clean and obvious,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce an output along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: One of the biggest advantages of the builder is how easy it is to add, remove,
    and modify the concrete classes, and even changes in the interface or abstractions
    require no modification of the client source code. This makes the builder pattern
    one of the most powerful, and it can be used in numerous situations. This is not
    to say that it is always preferable to the factory pattern. For simple objects,
    the factory is often the best choice, and of course, patterns exist on different
    scales and it is not uncommon to find factories nested within builders and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of material about how we present our products,
    and this is a vital element to any successful app. We saw how to manage color
    and text schemes and then went on to the more serious issue of managing the wide
    number of screen densities our apps may find themselves running on.
  prefs: []
  type: TYPE_NORMAL
- en: One of material design's most frequently used components, the card view, was
    covered next, and the importance of support libraries was emphasized, and in particular
    the design library. We will need to look further into this library, as it is vital
    for creating the kind of layouts and interaction our apps deserve. The next chapter
    will concentrate on more of these visual elements, focusing on the more commonly
    found material components such as app-bars and sliding drawers.
  prefs: []
  type: TYPE_NORMAL
