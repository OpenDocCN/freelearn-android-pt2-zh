- en: Chapter 2. Creational Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 创建型模式
- en: In the previous chapter, we took a look at the **factory pattern** and its associated
    **abstract factory pattern**. However, we looked at these patterns in quite a
    general way and not at how these objects, once created, can be represented and
    manipulated on an Android device. In other words, the patterns we built could
    have been applied in many other software environments, and to see how to make
    them more Android-specific we need to take a look at Android UIs and how they
    are composed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了**工厂模式**及其相关的**抽象工厂模式**。然而，我们以相当普遍的方式查看了这些模式，并没有查看一旦创建后，这些对象如何在Android设备上被表示和操作。换句话说，我们构建的模式可以应用于许多其他软件环境，为了使它们更具Android特色，我们需要查看Android
    UI及其组成方式。
- en: 'In this chapter, we will concentrate on how to represent our products as Android
    UI components. We will use the **card view** to display these, and each card will
    contain a title, an image, some descriptive text, and the ingredient''s calorific
    value, as can be seen in the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将集中讨论如何将我们的产品表现为Android UI组件。我们将使用**卡片视图**来展示这些内容，每个卡片将包含一个标题、一幅图像、一些描述性文本以及成分的热量值，如下面的截图所示：
- en: '![Creational Patterns](img/image_02_001.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![创建型模式](img/image_02_001.jpg)'
- en: This will lead us to take an initial look at **material design,** a powerful
    and increasingly popular **visual design language** for creating clean and intuitive
    UIs. Conceived originally for the smaller screens of mobile devices, material
    design is now widely considered such a valuable UI paradigm that its use has spread
    from Android devices to websites and even other mobile platforms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导我们初步了解**材料设计**，这是一种强大的、越来越受欢迎的**视觉设计语言**，用于创建清晰直观的UI。最初为移动设备的小屏幕而设计，材料设计现在被认为是一个非常有价值的UI范例，其应用已经从Android设备扩展到网站，甚至其他移动平台。
- en: '**Material design** is more than just fashionable, it provides a very effective
    series of guidelines for following best UI construction practices. Material design
    provides visual patterns that are analogous to the programmatic patterns we have
    already discussed. These patterns provide well-defined structures that are clean
    and simple to operate. Material design covers concepts such as proportion, scaling,
    typography, and spacing, all of which are very easily managed within the IDE and
    neatly prescribed by material design guidelines.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**材料设计**不仅仅是一种时尚，它提供了一系列遵循最佳UI构建实践的非常有效的指南。材料设计提供了与我们已经讨论过的编程模式相似的视觉模式。这些模式提供了清晰、简单的操作结构。材料设计涵盖了比例、缩放、排版和间距等概念，所有这些都可以在IDE中轻松管理，并由材料设计指南整齐地规定。'
- en: Once we have seen how to represent our ingredients as workable UI components,
    we will take a look at another commonly used creational pattern, the **builder
    pattern**. This will demonstrate a pattern that allows us to build a single *sandwich*
    object from our individual *ingredient* objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们了解了如何将我们的成分表现为可操作的UI组件后，我们将查看另一种常用的创建型模式，即**构建器模式**。这将展示一种允许我们从单个*配料*对象构建一个*三明治*对象的模式。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何进行以下操作：
- en: Edit material styles and themes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑材料样式和主题
- en: Apply palettes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用调色板
- en: Customize text settings
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义文本设置
- en: Manage screen densities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理屏幕密度
- en: Include the card view support library
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含卡片视图支持库
- en: Understand z-depth and shading
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Z轴深度和阴影
- en: Applying material design to a card view
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将材料设计应用于卡片视图
- en: Create a builder pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建构建器模式
- en: Although it can be changed at any time, one of the first things we should consider
    when building an Android app is the color scheme. This is the way that the framework
    allows us to customize the color and appearance of many familiar screen components,
    such as the title and status bar background colors and text and highlight shades.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以在任何时候进行更改，但在构建Android应用时，我们首先应该考虑的就是配色方案。这是框架允许我们自定义许多熟悉屏幕组件的颜色和外观的方式，例如标题和状态栏背景颜色以及文本和突出显示的阴影。
- en: Applying themes
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用主题
- en: As developers, we want our apps to stand out from the crowd, but we also want
    to incorporate all the features that Android users are familiar with. One way
    to do this is by applying a particular color scheme throughout an app. This is
    most easily done by customizing or creating Android themes
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们希望我们的应用程序能够从众多应用中脱颖而出，但同时我们也希望融入Android用户熟悉的全部功能。实现这一点的方法之一是在整个应用程序中应用特定的颜色方案。这最简单的方法是定制或创建Android主题。
- en: Since API level 21 (Android 5.0), the **material theme** has been default on
    Android devices. It is, however, more than just a new look. The material theme
    also provides as default the touch feedback and transition animations that we
    associate with material design. As with all Android themes, the material themes
    are based on Android styles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自从API级别21（Android 5.0）起，**材质主题**已成为Android设备的默认主题。然而，它不仅仅是一个新的外观。材质主题还默认提供了我们与材质设计相关的触摸反馈和过渡动画。与所有Android主题一样，材质主题也是基于Android样式的。
- en: An **Android style** is a set of graphical properties defining the appearance
    of a particular screen component. Styles allow us to define everything from font
    size and background color to padding and elevation, and much more. An Android
    theme is simply a style applied across a whole activity or application. Styles
    are defined as XML files, and stored in the resources (`res`) directory of Android
    Studio projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android样式**是一组定义特定屏幕组件外观的图形属性。样式允许我们从字体大小、背景颜色、内边距和高度等方面进行定义，还有更多。Android主题实际上就是应用于整个活动或应用程序的样式。样式被定义为XML文件，并存储在Android
    Studio项目的资源（`res`）目录中。'
- en: 'Fortunately, Android Studio comes with a graphical **theme editor** that generates
    the XML for us. Nevertheless, it is always good to understand what is going on
    under the hood, and this is best seen by opening the abstract factory project
    from the last chapter or by starting a new one. From the project explorer, open
    the `res/values/styles.xml` file. It will contain the following style definition:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android Studio带有一个图形化的**主题编辑器**，它为我们生成XML。不过，了解幕后发生的情况总是好的，这最好通过打开上一章的抽象工厂项目或开始一个新项目来查看。从项目浏览器中，打开`res/values/styles.xml`文件。它将包含以下样式定义：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, only three colors are defined, although we could have had more, such
    as primary and secondary text colors, window background color, and others. The
    colors themselves are defined in the `colors.xml` file, which is also found in
    the `values` directory and will contain the following definitions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，虽然只定义了三种颜色，但我们也可以定义更多，例如主要和次要文本颜色、窗口背景颜色等。颜色本身在`colors.xml`文件中定义，该文件也位于`values`目录中，并将包含以下定义：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is quite possible to apply more than one theme and incorporate as many styles
    as we might like, but generally speaking, a single theme applied across an entire
    application that customizes one of the default material themes is the easiest
    and cleanest answer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以应用多个主题，并融入我们喜欢的多种样式，但通常来说，在整个应用程序中应用单一主题，并定制其中一个默认的材质主题是最简单、最整洁的方法。
- en: 'The simplest way to customize the default theme is with the theme editor, which
    can be opened from the `Tools | Android` menu. The editor provides a powerful
    WYSIWYG preview pane that allows us to instantly view any changes we make as we
    make them, like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 定制默认主题的最简单方式是使用主题编辑器，可以从`工具 | Android`菜单中打开。编辑器提供了一个强大的所见即所得预览窗格，使我们能够在我们进行更改时即时查看任何更改，如下所示：
- en: '![Applying themes](img/image_02_002.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![应用主题](img/image_02_002.jpg)'
- en: Although we are free to choose any colors we like for our theme, the material
    design guidelines are quite clear about how colors should be used together. This
    is best explained by taking a look at **material palettes**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以为我们的主题自由选择任何喜欢的颜色，但材质设计指南对于如何一起使用颜色非常明确。这最好通过查看**材质调色板**来解释。
- en: Customizing color and text
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制颜色和文本
- en: The first things we need to consider when applying a theme are colors and text.
    Material design guidelines recommend selecting these colors from a predefined
    series of palettes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用主题时我们首先需要考虑的是颜色和文本。材质设计指南建议从预定义的一系列调色板中选择这些颜色。
- en: Using palettes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调色板
- en: The two most significant colors we can edit in a material theme are the primary
    colors. They are applied directly to the status and app bars and give an app a
    distinctive look without affecting the uniform feel of the platform as a whole.
    Both these colors should be selected from the same color palette. There are many
    such palettes available, and the entire collection can be found at www.google.com/design/spec/style/color.html#color-color-palette.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在材料主题中，我们可以编辑的最重要的两种颜色是主色。它们直接应用于状态栏和应用程序栏，使应用具有独特的观感，而不会影响整个平台的统一感。这两种颜色都应该从同一个色板中选择。有许多这样的色板可供选择，整个系列可以在www.google.com/design/spec/style/color.html#color-color-palette找到。
- en: 'Whichever palette you decide to use as your primary colors, Google recommend
    that you use shades with values of **500** and **700**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定使用哪个色板作为你的主色，谷歌建议你使用值为**500**和**700**的阴影。
- en: '![Using palettes](img/image_02_003.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![使用色板](img/image_02_003.jpg)'
- en: This does not have to be enforced too strictly, but it usually a good idea to
    stick close to these values and to always select two shades of the same color.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要严格执行，但通常最好遵循这些值，并且总是选择同一颜色的两种阴影。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The theme editor can be very helpful here; not only do its solid color blocks
    offer tooltips telling us the shade value, but once we have picked a primary color,
    it will suggest a suitable darker version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，主题编辑器会非常有帮助；它的实色块不仅提供了提示工具，告诉我们阴影值，而且一旦我们选定了主色，它还会推荐一个合适的深色版本。
- en: Our choice of primary shades needs to be considered when selecting the accent
    color. This will be applied to switches and highlights and needs to contrast nicely
    with the primary color. There are no simple rules governing which colors contrast
    with each other other than pick a color that looks good and has a light shade
    value of **100**, or close by.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 选择强调色时，需要考虑我们选择的主要色调。这将应用于开关和高亮显示，并且需要与主色形成良好对比。除了选择看起来不错且具有浅色值**100**的颜色之外，没有简单的规则来决定哪些颜色之间形成对比。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is possible to change the color of the navigation bar at the foot of the
    screen with `navigationBarColor`, but this is not recommended as the navigation
    bar should not really be thought of as part of your app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`navigationBarColor`改变屏幕底部的导航栏颜色，但不建议这样做，因为导航栏不应被视为应用的一部分。
- en: Most of the other theme settings can be left as they are for most purposes.
    However, if you wish to change text colors there are one or two things to note.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数目的，其他主题设置可以保持原样。但是，如果你希望更改文本颜色，有一两件事需要注意。
- en: Customizing text
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义文本
- en: 'Material text does not generate lighter shades by using lighter hues, but rather
    by using the alpha channel to create varying levels of **transparency**. The reason
    for this is that this looks more pleasing when used on different colored backgrounds
    or images. The rules for text transparency are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 材料文本不是通过使用更浅的色调来生成浅色阴影，而是通过使用alpha通道来创建不同级别的**透明度**。这样做的原因是，当它被用在不同的背景色或图像上时，看起来更加悦目。文本透明度的规则如下：
- en: '![Customizing text](img/image_02_004.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![自定义文本](img/image_02_004.jpg)'
- en: There is a lot that can be done with styles and themes, but for now it is enough
    to create a simple color scheme and know that it will be applied consistently
    across an application. Our next task will be to see how we can expand the sandwich
    ingredient objects we considered earlier into a user-friendly interface. No doubt
    one of the best ways to entice a user is with an appetizing photograph.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于样式和主题，我们可以做很多事情，但现在只需创建一个简单的配色方案，并知道它将在整个应用程序中一致应用就足够了。我们下一个任务将是探讨如何将我们之前考虑的“三明治成分”对象扩展成一个用户友好的界面。毫无疑问，吸引用户的一个最佳方式就是使用诱人的照片。
- en: Adding image resources
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图像资源
- en: 'One of the most interesting challenges that Android offers is the vast number
    of screen densities and sizes that we have to cater for. This is particularly
    true when it comes displaying bitmap images, where there are two competing issues
    that need to be resolved:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供的最具挑战性的问题之一是我们要适应的众多屏幕密度和尺寸。在显示位图图像时，这一点尤为正确，这里有两个需要解决的竞争性问题：
- en: Low resolution images display very poorly when stretched to fit on large or
    high resolution screens
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低分辨率图像在拉伸以适应大屏幕或高分辨率屏幕时显示效果非常差。
- en: High quality images use up far more memory than is needed when displayed on
    smaller, low density screens.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高质量图像在较小、低密度的屏幕上显示时，所使用的内存远大于所需。
- en: Screen sizes aside, the problem of differing screen densities is mostly solved
    with the use of **density-independent pixels** (**dp**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕尺寸先放一边，通过使用**密度独立像素**（**dp**）基本上解决了不同屏幕密度的问题。
- en: Managing screen densities
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理屏幕密度
- en: Dps are an abstract unit of measurement based on a screen displaying 160 dpi.
    This means that a widget with a width of 320 dp will always be 2'' wide regardless
    of screen density. When it comes to the actual physical dimensions of a screen,
    this can be managed with a variety of layout types, libraries, and properties
    such as weight and gravity, but for now we will look at how to provide images
    that suit the widest possible range of screen densities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: dp是一个基于160 dpi屏幕显示的抽象测量单位。这意味着无论屏幕密度如何，宽度为320 dp的组件始终为2英寸宽。当涉及到屏幕的实际物理尺寸时，这可以通过各种布局类型、库和属性（如权重和重力）来管理，但现在我们将了解如何提供适合尽可能广泛的屏幕密度的图像。
- en: 'The Android system divides screen densities with the following qualifiers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统用以下限定符划分屏幕密度：
- en: Low density (`ldpi`) - **120 dpi**
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低密度（`ldpi`）- **120 dpi**
- en: Medium density (`mdpi`) - **160 dpi**
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中等密度（`mdpi`）- **160 dpi**
- en: High density (`hdpi`) - **240 dpi**
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高密度（`hdpi`）- **240 dpi**
- en: Extra-high density (`xhdpi`) - **320 dpi**
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超高密度（`xhdpi`）- **320 dpi**
- en: Extra-extra-high density (`xxhdpi`) - **480 dpi**
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超超超高密度（`xxhdpi`）- **480 dpi**
- en: Extra-extra-extra-high density (`xxxhdpi`) - **640 dpi**
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超超超高密度（`xxxhdpi`）- **640 dpi**
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: During an app's installation, each device will only download images that match
    its own specifications. This saves memory on older devices and still provides
    the richest possible visual experience on devices that are capable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用安装期间，每个设备只会下载与其规格相匹配的图像。这节省了旧设备的内存，同时为有能力的设备提供了尽可能丰富的视觉体验。
- en: From a developer's point of view, it might seem that we have to generate six
    versions of every image we want to include in any given project. Thankfully, this
    is not usually the case. The difference between a 640 dpi image and, say, a 320
    dpi image is hardly noticeable on most handheld devices, and considering that
    most users of our sandwich builder app will simply want to scroll through a menu
    of ingredients, rather than scrutinize the quality of our imagery, we can safely
    provide images for medium, high, and extra-high density devices only.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，我们可能需要为每个项目生成六种不同版本的图像。幸运的是，通常情况下并非如此。在大多数手持设备上，640 dpi图像与320 dpi图像之间的差别几乎无法察觉。考虑到我们三明治制作应用的大多数用户只想浏览食材菜单，而不是仔细检查图像质量，我们可以只安全地提供中等、高和超高密度设备的图像。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A good rule of thumb when considering image quality for high-end devices is
    to compare our image sizes with those produced by the device's native camera.
    It is unlikely that providing larger images will improve user experience enough
    to justify the extra memory required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑高端设备图像质量时，一个很好的经验法则是将我们的图像尺寸与设备原生相机产生的尺寸进行比较。提供更大的图像不太可能足以改善用户体验，从而证明需要额外的内存是合理的。
- en: In our example here, we will want to provide images that fit onto a card view
    that will occupy most of the screen width in portrait mode. For now, find an image
    that is roughly 2,000 pixels in width. In the following example, it is called
    `sandwich.png` and is 1,920 by 1,080 pixels in size. Your image does not have
    to match these dimensions, but later we will see how well-selected image proportions
    are considered a significant part of good UI practice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们希望提供适合卡片视图的图像，该视图在纵向模式下将占据屏幕宽度的绝大部分。现在，找一个大约2,000像素宽的图像。在下面的例子中，它被称为`sandwich.png`，尺寸为1,920×1,080像素。你的图像不必与这些尺寸匹配，但稍后我们会看到，选择合适的图像比例是良好UI实践的重要组成部分。
- en: An image that has a width of 1,920 pixels would be six inches wide when displayed
    on an extra-high density device displaying 320 dpi. We will assume, for now at
    least, that our app will be accessed from mobile devices, rather than computers
    or televisions, so even on a high density, 10'' tablet, six inches will be more
    than enough for our purposes. Next, we will see how to prepare for other screen
    densities too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在超高密度设备上显示320 dpi时，宽度为1,920像素的图像将显示为六英寸宽。现在至少假设我们的应用将来自移动设备，而不是计算机或电视，所以在高密度10英寸的平板电脑上，六英寸对我们来说已经足够了。接下来，我们还将了解如何为其他屏幕密度做准备。
- en: Using designated resources
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指定资源
- en: 'Providing alternative bitmaps to suit a variety of screen densities is easily
    achieved by assigning **designated resource directories** to contain images configured
    for specific screen densities. From Android Studio, we can create such directories
    from the project explorer with these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分配特定资源目录来满足不同屏幕密度的需求是很容易实现的。在Android Studio中，我们可以通过以下步骤从项目资源管理器中创建这些目录：
- en: First, create a `New | Directory` from the `res` folder and call it `drawable-mdpi`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![使用指定资源](img/image_02_006.jpg)'
- en: Next, create two more sibling directories called `drawable-hdpi` and `drawable-xhdpi`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建两个同级的目录，分别命名为`drawable-hdpi`和`drawable-xhdpi`。
- en: Open these new folders directly by selecting **Show in Explorer** in the `drawable`
    context menu from the project explorer.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从项目资源管理器中选择`drawable`上下文菜单中的**在资源管理器中显示**直接打开这些新文件夹。
- en: Add the `sandwich.png` image to the `drawable-xhdpi` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sandwich.png`图片添加到`drawable-xhdpi`文件夹中。
- en: Make two copies of this image and re-scale them so that one is 3:4 the original
    scale and the other 1:2 scale.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作这张图片的两个副本，并按3:4和1:2的比例缩放它们。
- en: Place these copies in the `drawable-hdpi` and `drawable-mdpi` directories respectively.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些副本分别放置在`drawable-hdpi`和`drawable-mdpi`目录中。
- en: 'These variations will now appear in the project explorer, as seen here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化现在可以在项目资源管理器中看到，如下所示：
- en: '![Using designated resources](img/image_02_005.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用指定资源](img/image_02_005.jpg)'
- en: 'We can now rest assured that only the most suitable and memory efficient image
    resource will be downloaded according to a device''s native screen density. To
    see how this looks, add the following image view to the project''s `activity_main.xml`
    file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们可以确保只有最适合设备原生屏幕密度的图像资源会被下载。
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output can be viewed with the preview screens on any emulator or real device:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`res`文件夹中创建一个`新 | 目录`，并将其命名为`drawable-mdpi`。
- en: '![Using designated resources](img/image_02_006.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: 要查看效果，请在项目的`activity_main.xml`文件中添加以下图像视图：
- en: The nice thing about this approach is that once we have the variations of our
    image designated correctly, we can simply refer to it as `@drawable/sandwich`
    and forget about the actual device it is being viewed on or which directory it
    is stored in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，一旦我们正确指定了图片资源，就可以简单地通过引用`@drawable/sandwich`来忽略它实际存储的目录。
- en: This leaves us free to explore how we might include our images as part of a
    broader interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片视图是Material Design中最容易识别的组件之一，它设计用来以统一的方式展示多个相关的片段内容。这种内容通常包括图形、文本、操作按钮和图标等。卡片是展示像三明治配料和相关价格或热量信息这类选择的好方法。
- en: Creating a card view
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个卡片视图（**CardView**）。
- en: The card view is one of the most recognizable material design components. It
    is designed to show several pieces of content that all apply to a single subject.
    This content is usually a combination of graphics, text, action buttons, and icons,
    and cards are a great way to present a selection of choices in a uniform way.
    This makes it a good choice for displaying our sandwich ingredients and related
    information such as price or calorific value. We will use the factory pattern
    from the previous chapter to do this, but before we see what code needs changing,
    let's take a look at how we implement the card view in the first place.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以在任何模拟器或真实设备上的预览屏幕上查看：
- en: Understanding card view properties
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解卡片视图属性。
- en: 'If your minimum target SDK is 21 or greater, then the **CardView** widget will
    be included as standard. Otherwise, you will need to include the cardview support
    library. This is easily added in the `build.gradle` file by including the following
    highlighted line:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的最低目标 SDK 是21或更高，那么卡片视图小部件将作为标准包含。否则，您需要包含卡片视图支持库。这可以在`build.gradle`文件中通过添加以下高亮行轻松完成：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the name of the support library suggests, we can only support card views
    as far back as API level 7.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如支持库的名字所暗示，我们只能支持回溯到API级别7的卡片视图。
- en: 'It is not necessary to edit the `build.gradle` file manually, although it is
    useful to know how, as it can be done more simply via the `File | Project Structure...`
    menu and selecting the items shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不必手动编辑`build.gradle`文件，尽管了解如何操作是有用的，可以通过`文件 | 项目结构...`菜单选择以下所示的项目来完成：
- en: '![Understanding card view properties](img/image_02_007.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![理解卡片视图属性](img/image_02_007.jpg)'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Some developers version their support libraries with a `+` symbol, like so:
    `com.android.support:cardview-v7:23.` **+**. This is an attempt to anticipate
    future libraries. This generally works very well, but it does not guarantee that
    these apps might not crash at a later date. It is a little more time-consuming,
    but far smarter, to use the compiled SDK version during development and then update
    the app regularly once it is published.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者使用`+`符号来版本化他们的支持库，如：`com.android.support:cardview-v7:23.+`。这是为了预测未来的库。这通常运作得很好，但这并不能保证这些应用在未来不会崩溃。在开发过程中使用编译的SDK版本，然后在应用发布后定期更新，虽然更耗时，但更明智。
- en: 'You will need to rebuild the project before we can add the card view to our
    layout. First, we will need to set some of the card''s properties. Open the `res/values/dimens.xml`
    file and add the following three new dimension resources:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将卡片视图添加到我们的布局之前，你需要重新构建项目。首先，我们需要设置一些卡片的属性。打开`res/values/dimens.xml`文件，并添加以下三个新的尺寸资源：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can add the card as a widget in the main XML activity file, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在主XML活动文件中将卡片作为小部件添加，如下所示：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The use of shadowing does more than just give a three-dimensional appearance
    to an interface; it demonstrates the layout hierarchy graphically, making it obvious
    to the user which functions are available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影的使用不仅仅是为了给界面提供三维外观；它还通过图形化地展示布局层次结构，让用户清楚地知道哪些功能可用。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have spent any time examining the card view properties, you will have
    noticed the `translationZ` property. This appears to have the same effect as `elevation`.
    However, `elevation` will set the card's absolute elevation, whereas `translationZ`
    is a relative setting and its value will be added or subtracted from the current
    elevation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间检查过卡片视图属性，你会注意到`translationZ`属性。这看起来与`elevation`有相同的效果。然而，`elevation`将设置卡片的绝对高度，而`translationZ`是一个相对设置，它的值将会加到或从当前高度中减去。
- en: Now we have a card view set up, we can fill it out to represent our sandwich
    ingredients according to material design guidelines.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了卡片视图，可以根据材料设计指南填充它，以表示我们的三明治成分。
- en: Applying CardView metrics
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用CardView的度量标准
- en: Design guidelines are very clear about such issues as typeface, padding, and
    scale. Once we start using the CoordinatorLayout, a lot of these settings will
    be set automatically, but for now, it is a good idea to see how these metrics
    are applied.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设计指南对字体、内边距和缩放等问题非常明确。一旦我们开始使用CoordinatorLayout，这些设置中的许多将会自动设置，但现在，了解这些度量标准是如何应用的还是一个好主意。
- en: 'There are many different patterns for cards, and a full description of them
    can be found here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于卡片有许多不同的模式，它们的完整描述可以在这里找到：
- en: '[www.google.com/design/spec/components/cards.html](http://open the Java activity
    file extend it so that it implements)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[卡片设计规范](http://www.google.com/design/spec/components/cards.html)'
- en: The one we will create here will contain an image, three text items, and an
    action button. Cards can be considered as container objects, and as such, normally
    contain their own root layout. This can be placed directly inside the card view
    itself, but it makes for more readable and more flexible code if we create the
    card content as a separate XML layout.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里创建的卡片将包含一个图片、三个文本项和一个动作按钮。卡片可以被看作是容器对象，通常它们包含自己的根布局。这可以直接放置在卡片视图内，但如果我们把卡片内容作为独立的XML布局创建，代码将更具可读性和灵活性。
- en: 'We will need at least one image for this next exercise. According to material
    design, photographic images should be clear, bright, simple, and present a single,
    unambiguous subject. For example, if we wanted to add coffee to our menu, the
    image on the left would be the most suitable of the two:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习中，我们将至少需要一张图片。根据材料设计，照片应该是清晰、明亮、简单，并呈现单一、明确的主题。例如，如果我们想将咖啡添加到菜单中，左边的图片将是最合适的：
- en: '![Applying CardView metrics](img/image_02_008.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![应用CardView的度量标准](img/image_02_008.jpg)'
- en: Card images need to have a width to height ratio of 16:9 or 1:1\. Here, we will
    use 16:9, and ideally we should produce scaled versions to suit various screen
    densities, but as this is only a demonstration, we can be lazy and just place
    the originals directly into the `drawable` folder. This approach is far from best
    practice, but is fine for preliminary testing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片图片的宽高比应为16:9或1:1。这里，我们将使用16:9，理想情况下我们应该生成缩放版本以适应各种屏幕密度，但既然这只是一个演示，我们可以偷懒直接将原始图片放入`drawable`文件夹。这种方法远非最佳实践，但对于初步测试是没问题的。
- en: 'Once you have sourced and saved your images, the next step is to create a layout
    for our card:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到并保存你的图片后，下一步是创建一个卡片的布局：
- en: 'From the project explorer, navigate to `New | XML | Layout XML File` and call
    it `card_content.xml`. Its root view group should be a linear layout with a vertical
    orientation, and it should look like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目浏览器中，导航到`新建 | XML | 布局XML文件`，并将其命名为`card_content.xml`。它的根视图组应该是一个垂直方向的线性布局，应该看起来像这样：
- en: '[PRE6]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using either the graphical or text editor, create a layout structure to match
    the **Component Tree** seen here:![Applying CardView metrics](img/image_02_009.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图形或文本编辑器，创建一个与这里看到的**组件树**相匹配的布局结构：![应用CardView度量](img/image_02_009.jpg)
- en: 'Now include this layout inside the card view from the main activity layout
    file, like this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此布局包含在主活动布局文件中的卡片视图中，如下所示：
- en: '[PRE7]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although it is editable, the recommended elevation for a card view is 2 dp,
    unless it has been selected and/or is being moved, in which case it has an elevation
    of 8 dp.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管可以编辑，但建议卡片视图的默认高度为2 dp，除非它已被选中和/或正在移动，在这种情况下，它的高度为8 dp。
- en: 'As you will no doubt know, the use of strings that are hard-coded into XML
    resources are strongly discouraged. If nothing else, this makes the process of
    translating our apps into other languages almost impossible. However, during the
    early stages of layout design, it helps to provide some placeholder values to
    give an idea of how a layout might look. Later, we will control card content using
    Java, and select this content based on user input; but for now, we will select
    some typical values so that we can see the effect our settings have easily and
    quickly. To see how this is of use, add the following properties, or equivalent,
    to the `strings.xml` file in the `values` directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你无疑知道，在XML资源中硬编码字符串的使用是强烈不推荐的。至少，这使得将我们的应用程序翻译成其他语言的过程几乎不可能。然而，在布局设计的早期阶段，提供一些占位符值以了解布局可能的外观是有帮助的。稍后，我们将使用Java控制卡片内容，并根据用户输入选择此内容；但现在，我们将选择一些典型值，以便我们可以轻松快速地看到我们的设置产生的影响。为了了解这是如何有用的，请在`values`目录下的`strings.xml`文件中添加以下属性或等价物：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For now, we will use these placeholders to evaluate any changes we make as
    we make them. The layouts we just created should, when viewed as a preview, look
    something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这些占位符来评估我们进行的任何更改。我们刚刚创建的布局，在预览中查看时，应该看起来像这样：
- en: '![Applying CardView metrics](img/image_02_010.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![应用CardView度量](img/image_02_010.jpg)'
- en: Converting this into a materially designed component requires nothing more than
    some formatting and a little knowledge of material guidelines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转化为材质设计组件只需要进行一些格式化处理，并了解一些材质设计指南的知识。
- en: 'The metrics for this layout are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局的度量如下：
- en: The image must have a ratio of 16:9
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片的长宽比必须是16:9。
- en: The title text should be 24 sp
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题文本应为24 sp。
- en: The descriptive text is 16 sp
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述性文本为16 sp。
- en: The margins around the bottom right and left of the text is 16 dp
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本底部右侧和左侧的边距为16 dp。
- en: The margin above the title text is 24 dp
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题文本上方的边距为24 dp。
- en: The action text as 24 sp and takes its color from the accent
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作文本的大小为24 sp，并从强调色中获取其颜色。
- en: These properties are very easily set from either the properties panel or by
    editing the XML directly. There are one or two things not mentioned here, so it
    is worth taking a look at each element separately.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可以通过属性面板或直接编辑XML非常容易地设置。这里有一两件事情没有提到，所以值得单独查看每个元素。
- en: First, it is essential to point out that these values should never be described
    literally in the code as they are in the following snippet; for example, `android:paddingStart="24dp"`
    should be coded as something like `android:paddingStart="@dimen/text_paddingStart"`
    with `text_paddingStart` being defined in the `dimens.xml` files. Here, the values
    have been hard-coded only to simplify the explanation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须指出的是，这些值绝不应像以下代码段中那样直接在代码中描述；例如，`android:paddingStart="24dp"` 应该像这样编码 `android:paddingStart="@dimen/text_paddingStart"`，其中
    `text_paddingStart` 在 `dimens.xml` 文件中定义。这里，值是硬编码的，只是为了简化解释。
- en: 'The code for image view at the top should look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部图像视图的代码应该如下所示：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is very straightforward, but do note the use of `contentDescription`; this
    is used when a visually impaired user has set accessibility options so that images
    can be appreciated by having their descriptions read out by the device's voice
    synthesizer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，但请注意 `contentDescription` 的使用；当视力受损的用户设置了辅助功能选项时，这会被用来让设备通过语音合成器朗读图像的描述，以便用户欣赏。
- en: Beneath this are the following three text views.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是以下三个文本视图。
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These too are very simple to follow. All that really needs pointing out is the
    use of `Start` and `End` as opposed to `Left` and `Right` to define padding and
    gravity, as this helps apply our layout correct itself when translated into languages
    where text runs from right to left. We also included the `textAppearance` property,
    which may appear redundant as we also set text size directly. Attributes such
    as `textAppearanceMedium` are useful as not only do they automatically apply text
    coloring according to our customized theme, they will also adjust their size according
    to individual users' global text size settings.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也非常容易理解。真正需要指出的是，我们使用 `Start` 和 `End` 而不是 `Left` 和 `Right` 来定义内边距和重力，这有助于在将布局翻译成从右到左运行文本的语言时，让布局自我纠正。我们还包含了
    `textAppearance` 属性，尽管我们直接设置了文本大小，这看起来可能有些多余。像 `textAppearanceMedium` 这样的属性很有用，因为它们不仅可以根据我们自定义的主题自动应用文本颜色，还可以根据个别用户的全局文本大小设置调整其大小。
- en: 'This leaves only the action button at the bottom, and as this uses a text view
    rather than a button, this may require a little explanation. The XML looks like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这只剩下底部的动作按钮，由于这里使用的是文本视图而不是按钮，这可能需要一些解释。XML 看起来像这样：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are two reasons why we chose a text view here where it would seem to make
    sense to use a button widget. Firstly, Android recommends the use of a **flat
    button** where only the text is visible on card views; and secondly, the touchable
    area that triggers an action needs to be larger than the text itself. This is
    easily performed by setting the padding properties as we have previously. To make
    a text view behave like a button, we only need to add the line `android:clickable="true"`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择文本视图而不是按钮控件有两个原因。首先，Android推荐在卡片视图中使用只有文本可见的**扁平按钮**；其次，触发动作的可触摸区域需要比文本本身大。这可以通过设置内边距属性轻松实现，正如我们之前所做的那样。要让文本视图像按钮一样工作，我们只需添加一行
    `android:clickable="true"`。
- en: 'Our finished card should now look something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的卡片现在应该看起来像这样：
- en: '![Applying CardView metrics](img/image_02_011.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![应用 CardView 度量](img/image_02_011.jpg)'
- en: There is a lot more to the design of card views, but this should serve as a
    good introduction to some of the principles we need to follow, and for now, we
    can see how these new ways of presenting our objects reflect on our factory pattern
    code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于卡片视图的设计还有很多内容，但这应该足以作为我们需要遵循的一些原则的介绍，现在我们可以看到这些呈现对象的新方式如何反映在我们的工厂模式代码上。
- en: Updating the factory pattern
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新工厂模式
- en: One of the beauties of design patterns is the ease by which they can adapted
    to suit any changes we wish to make. We could, if we chose, leave our factory
    code as it is and use the single string output to direct the client code to the
    appropriate dataset. It is more in keeping with the nature of patterns, though,
    to adapt them to match our slightly more complex ingredient objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的美之一在于它们可以轻松地适应我们希望做出的任何变化。如果我们选择，可以保留工厂代码不变，并使用单一字符串输出将客户端代码指向适当的数据集。然而，根据模式的本质，我们应该将它们适应到与我们稍微复杂的成分对象相匹配。
- en: The thought that went into our code structure in the last chapter now pays off,
    as although we need to edit our interfaces and concrete examples, we can leave
    the factory classes themselves just as they are, and this demonstrates one of
    the advantages of patterns rather nicely.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上一章代码结构中的思考现在得到了回报，因为尽管我们需要编辑我们的接口和具体示例，但我们可以将工厂类本身保持原样，这很好地展示了模式的一个优点。
- en: 'Using the four criteria we used to build our card, our updated interfaces could
    look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们构建卡片时使用的四个标准，我们更新后的接口可能看起来像这样：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Individual objects could look like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单个对象可能看起来像这样：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we move forward, we will need more properties for our objects, such as price
    and whether they are vegetarian or contain nuts, and as our objects become more
    complex we will have to apply more sophisticated ways to manage our data, but
    in principle there is nothing wrong with the approach we are using here. It may
    be bulky, but it is certainly easy to read and maintain. Factory patterns are
    clearly very useful, but they only create single objects. To model a sandwich
    more realistically, we need to be able to put *ingredient* objects together and
    treat the entire collection as a single *sandwich* object. This is where the builder
    pattern comes in.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向前发展，我们的对象将需要更多的属性，比如价格以及它们是否是素食或含有坚果等。随着对象的变得更加复杂，我们将不得不应用更复杂的方式来管理我们的数据，但原则上这里使用的方法并没有错。它可能有些笨重，但肯定易于阅读和维护。工厂模式显然非常有用，但它们只创建单一对象。为了更真实地模拟三明治，我们需要能够将*配料*对象组合在一起，并将整个集合视为一个单独的*三明治*对象。这正是构建模式发挥作用的地方。
- en: Applying a builder pattern
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用构建模式
- en: The builder design pattern is one of the most useful creational patterns as
    it builds larger objects from smaller ones. This is precisely what we want to
    do to construct a sandwich object from a list of ingredients. The builder pattern
    has a further advantage in that optional features are easy to include later. As
    before, we will begin by creating an interface; we will call it `Ingredient` and
    use it to represent both `bread` and `filling`. This time, we will need to represent
    calories as an integer, as we will need to calculate the total amount in a finished
    sandwich.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器设计模式是最有用的创建模式之一，因为它从更小的对象构建更大的对象。这正是我们想要从配料列表构造三明治对象所做的。构建器模式的另一个优点是，可选特性稍后很容易加入。像之前一样，我们将从创建一个接口开始；我们将它称为`Ingredient`，用它来表示`面包`和`填充物`。这次，我们需要用整数来表示卡路里，因为我们需要计算成品三明治中的总含量。
- en: 'Open an Android Studio project, or start a new one, and follow the proceeding
    steps to create a basic sandwich builder pattern:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个Android Studio项目，或者开始一个新项目，并按照以下步骤创建一个基本的三明治构建模式：
- en: 'Create a new interface called `Ingredient.java`, and complete it like so:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Ingredient.java`的新接口，并完成如下：
- en: '[PRE14]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now create an abstract class for `Bread` like this:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在像这样为`Bread`创建一个抽象类：
- en: '[PRE15]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And create an identical one called `Filling`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并创建一个名为`Filling`的相同接口。
- en: 'Next, create concrete classes of `Bread`, like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，像这样创建`Bread`的具体类：
- en: '[PRE16]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do the same for `Filling`. Two classes of each type should be enough for demonstration
    purposes:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Filling`也做同样的处理。为了演示目的，每种类型两个类应该就足够了：
- en: '[PRE17]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can create our `Sandwich` class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`Sandwich`类：
- en: '[PRE18]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, create the `SandwichBuilder` class like so:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像这样创建`SandwichBuilder`类：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This completes our builder design pattern, for now at least. When viewed as
    a diagram, it looks like this:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了我们的构建器设计模式，至少目前是这样。当它作为一个图表被查看时，看起来像这样：
- en: '![Applying a builder pattern](img/image_02_012.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![应用构建模式](img/image_02_012.jpg)'
- en: 'Here, we have provided the builder with two functions: to return a ready-made
    sandwich and a user-customized one. We have no working interface as yet, but we
    can simulate user choice via our client code.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为构建器提供了两个功能：返回一个现成的三明治和一个用户定制的三明治。我们目前还没有可用的接口，但我们可以通过客户端代码模拟用户选择。
- en: 'We have also delegated output responsibilities to the `Sandwich` class itself,
    and this is often a good idea as it helps keep our client code clean and obvious,
    as you can see here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将输出职责委托给了`Sandwich`类本身，这样做通常是个好主意，因为它有助于保持客户端代码的清晰和明显，正如您在这里看到的：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should produce an output along these lines:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似这样的输出：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: One of the biggest advantages of the builder is how easy it is to add, remove,
    and modify the concrete classes, and even changes in the interface or abstractions
    require no modification of the client source code. This makes the builder pattern
    one of the most powerful, and it can be used in numerous situations. This is not
    to say that it is always preferable to the factory pattern. For simple objects,
    the factory is often the best choice, and of course, patterns exist on different
    scales and it is not uncommon to find factories nested within builders and vice
    versa.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构造者最大的优势之一是添加、删除和修改具体类非常容易，甚至接口或抽象的变更也无需修改客户端源代码。这使得构造者模式成为最强大的模式之一，并且可以应用于众多场景。但这并不是说构造者模式总是比工厂模式更优。对于简单对象，工厂通常是最佳选择。当然，模式存在于不同规模上，构造者中嵌套工厂或者工厂中嵌套构造者都是常见的情况。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered a lot of material about how we present our products,
    and this is a vital element to any successful app. We saw how to manage color
    and text schemes and then went on to the more serious issue of managing the wide
    number of screen densities our apps may find themselves running on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了大量关于如何展示产品的内容，这是任何成功应用的关键要素。我们学习了如何管理颜色和文本方案，并进一步探讨了更严肃的问题：如何管理应用可能运行在各种屏幕密度上的情况。
- en: One of material design's most frequently used components, the card view, was
    covered next, and the importance of support libraries was emphasized, and in particular
    the design library. We will need to look further into this library, as it is vital
    for creating the kind of layouts and interaction our apps deserve. The next chapter
    will concentrate on more of these visual elements, focusing on the more commonly
    found material components such as app-bars and sliding drawers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了材料设计中使用最频繁的组件之一：卡片视图，并强调了支持库的重要性，尤其是设计库。我们需要进一步了解这个库，因为它对于创建我们应用所需的布局和交互至关重要。下一章将专注于更多这些视觉元素，聚焦于更常见的材料组件，如应用栏和滑动抽屉。
