- en: Chapter 5. XamSnap for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin writing the iOS version of XamSnap, open the solution we created in
    the previous chapter. We will be working mostly in the `XamSnap.iOS` project in
    this chapter. The project template will have automatically created a controller
    named `ViewController`; go ahead and delete it. We will create our own controllers
    as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of an iOS application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using UINavigationController
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a login screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Segues and UITableView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a friends list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a list of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of an iOS app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start developing our app, let's review the main settings of the application.
    Apple uses a file named `Info.plist` to store important information about any
    iOS app. These settings are used by the OS itself and when an iOS application
    is installed on a device by the Apple App Store. Begin development of any new
    iOS application by filling out the information in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin Studio provides a neat menu to modify values in the `Info.plist` file,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the basics of an iOS app](img/image00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most important settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Name**: This is the title below an app''s icon in iOS. Note that
    this is not the same as the official name of your app in the iOS App Store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle Identifier**: This is your app''s bundle identifier or bundle ID.
    It is a unique name to identify your application. The convention is to use a reverse
    domain naming style beginning with your company name, such as `com.jonathanpeppers.xamsnap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: This is the version number for your application that is visible
    to the users on the app store, such as `1.0.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: This is the version number reserved for the developer (for CI builds,
    etc.), such as `1.0.0.1234`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: In this, you can select **iPhone/iPod**, **iPad**, or **Universal**
    (all devices) for your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment Target**: This is the minimum iOS version your application runs
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main Interface**: This is the main storyboard file for your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device Orientations**: These are the different positions your application
    will be able to rotate to and support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status Bar Style**: These are the options to hide the top status bar in your
    application and run full screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other settings for app icons, splash screens, and so on. You can also
    toggle between the **Advanced** or **Source** tabs to configure additional settings
    for which Xamarin does not provide a user-friendly menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the following settings for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Name**: `XamSnap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle Identifier**: `com.yourcompanyname.xamsnap`; make sure you name future
    apps so that they begin with `com.yourcompanyname`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: **iPhone/iPod**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment Target**: **8.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported Device Orientations**: Only select **Portrait**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.iOS Build Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find some additional settings for Xamarin iOS applications if you right-click
    on your project and select **Options**, as shown in the following screenshot.
    It is a good idea to know what is available for iOS-specific projects in Xamarin
    Studio. A lot is going on here, but the defaults will get you by in most situations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.iOS Build Options](img/image00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss some of the most important options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iOS Build**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SDK version**: This is the version of the iOS SDK to compile your application
    with. It is generally best to use **Default**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linker behavior**: Xamarin has implemented a feature called **linking**.
    The linker will strip any code that will never be called within your assemblies.
    This keeps your application small, and allows them to ship a stripped-down version
    of the core Mono runtime with your app. Except for debug builds, it is best to
    use the **Link SDK assemblies only** option. We will cover linking in a future
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported Architectures**: These are the types of processors. `i386` is the
    simulator and `ARMv7 + ARM64` is the option for compiling for modern iOS devices.
    You should generally be able to use the defaults here, unless upgrading an older
    Xamarin.iOS application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HttpClient implementation**: newer versions of Xamarin.iOS allow you to choose
    a native HTTP stack for `System.Net.Http.HttpClient`. Mono''s implementation is
    the default, but is not as performant as the native stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSL/TLS implementation**: Xamarin.iOS also has the option to use native APIs
    for SSL. If you choose Mono instead, your application will only support TLS 1.0,
    so it is better to use the native option here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use LLVM optimizing compiler**: Checking this compiles code that is smaller
    and runs faster, but takes longer to compile. **LLVM** stands for **Low Level
    Virtual Machine**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strip native debugging symbols**: When this option is on, Xamarin removes
    extra information from your app that would enable debugging from Xamarin Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional mtouch arguments**: This field is for passing extra command-line
    arguments to the Xamarin compiler for iOS. You can check the complete list of
    these arguments at [https://developer.xamarin.com/api](https://developer.xamarin.com/api).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize PNG files for iOS**: Apple uses a custom PNG format to speed up
    the loading of PNGs within your app. You can turn this off to speed up builds,
    or if you plan on optimizing the images yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS Bundle Signing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signing Identity**: This is the certificate to identify the app''s creator
    for deploying the application to devices. We''ll cover more on this in later chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provisioning profile**: This is a specific profile that deploys the app to
    a device. This works in tandem with **Signing Identity**, but also declares the
    distribution method and the devices that can install the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom Entitlements**: This file contains additional settings to be applied
    with the provisioning profile and contains other specific declarations for the
    app, such as iCloud or push notifications. The project template for iOS apps includes
    a default `Entitlements.plist` file for new projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this application, you can leave all these options at their defaults. When
    making a real iOS application on your own, you should consider changing many of
    these as per your application's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using UINavigationController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In iOS applications, the key class for managing navigation between different
    controllers is the `UINavigationController` class. It is a parent controller that
    contains several child controllers in a stack. Users can move forward by putting
    new controllers on top of the stack, or using a built-in back button to pop a
    controller off the stack and navigate to the previous screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The developer can manipulate the navigation controller''s stack with the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetViewControllers`: This sets an array of child controllers. It has a value
    to optionally animate the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewControllers`: This is a property for getting or setting the array of child
    controllers without an option for animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PushViewController`: This places a new child controller at the top of the
    stack and has an option to display an animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopViewController`: This pops off the child controller at the top of the stack
    and has an option to animate the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopToViewController`: This pops to the specified child controller, removing
    all controllers above it. It provides an option to animate the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopToRootViewController`: This removes all child controllers except the bottom-most
    controller. It includes an option to display an animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopViewController`: This is a property that returns the child controller that
    is currently on top of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that using the option for animations will cause a crash
    if you try to modify the stack during the animation. To fix this situation, either
    use the `SetViewControllers` method and set the entire list of child controllers,
    or refrain from using the animations during a combination of transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a navigation controller in our application by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file to open it in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the controller that was created by the project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Navigation Controller** element from the **Toolbox** on the right onto
    the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that a default **View Controller** element was created, as well as a
    **Navigation Controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a **segue** that connects the two controllers. We'll cover this
    concept in more detail later in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just a note for Visual Studio users, Xamarin has done a great job making their
    Visual Studio Extension work identically to Xamarin Studio. All of the examples
    in this chapter should work just as described in either Xamarin Studio on OS X
    or Visual Studio on Windows. The exception, of course, is a remotely connected
    mac for deploying to the simulator or an iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application at this point, you will have a basic iOS app with
    a status bar at the top, a navigation controller containing a navigation bar with
    a default title, and a child controller that is completely white, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using UINavigationController](img/image00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the login screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the first screen of our application will be a login screen, let's begin
    by setting up the appropriate views in the storyboard file. We will implement
    the login screen by using Xamarin Studio to write the C# code, and its iOS designer
    to create iOS layouts in our storyboard file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the project in Xamarin Studio and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller, click on the **Properties** pane and select the
    **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `LoginController` into the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the `LoginController` class is generated for you. You may create
    a `Controllers` folder and move the file into it if you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the controller''s settings will look like
    in Xamarin Studio after the changes have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the login screen](img/image00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s modify the layout of the controller by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file a second time to return to the iOS
    designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the navigation bar and edit the **Title** field to read `Login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two text fields onto the controller. Position and size them appropriately
    for the username and password entries. You may also want to remove the default
    text to make the fields blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second field, check the **Secure Text Entry** checkbox. This will set
    the control to hide the characters for the password field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may also want to fill out the **Placeholder** field for `Username` and `Password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a button onto the controller. Set the button's **Title** to `Login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an activity indicator onto the controller. Check the **Animating** and
    **Hidden** checkboxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create the outlets for each of the controls by filling out the **Name**
    field. Name the outlets `username`, `password`, `login`, and `indicator`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file and take a look at `LoginController.designer.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that Xamarin Studio has generated properties for each of the
    outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the login screen](img/image00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and compile the application to make sure everything is okay. At this
    point, we also need to add a reference to the `XamSnap.Core` project created in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s set up our iOS application to register all its view models and
    the other services that will be used throughout the application. We will use the
    `ServiceContainer` class we created in [Chapter 4](part0039.xhtml#aid-1565U1 "Chapter 4. XamSnap
    - A Cross-Platform App"), *XamSnap - A Cross-Platform App*, to set up dependencies
    throughout our application. Open `AppDelegate.cs` and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Down the road, we will replace the fake services with real ones. Now let''s
    add the login functionality to `LoginController.cs`. First add `LoginViewModel`
    to a member variable at the top of the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will pull a shared instance of `LoginViewModel` into a local variable in
    the controller. This is the pattern we will use throughout the book in order to
    pass a shared view model from one class to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, override `ViewDidLoad` to hook up the view model''s functionality with
    the views set up in outlets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll add the code to navigate to a new screen later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s hook up the `IsBusyChanged` event to actually perform an action,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you might ask why we subscribe to the event in this manner. The problem
    is that the `LoginViewModel` class will last through your application's lifetime,
    while the `LoginController` class will not. If we subscribed to the event in `ViewDidLoad`,
    but didn't unsubscribe later, then our application would have a memory leak. We
    also avoided using a lambda expression for the event, since it would otherwise
    be impossible to unsubscribe to the event.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't have the same problem with the `TouchUpInside` event on the
    button, since it will live in memory as long as the controller does. This is a
    common problem with events in C#, which is why it is a good idea to use the preceding
    pattern on iOS.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application now, you should be able to enter a username and password,
    as shown in the following screenshot. On pressing **Login**, you should see the
    indicator appear and all the controls disabled. Your application will correctly
    be calling the shared code, and should function correctly when we add a real web
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the login screen](img/image00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using segues for navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A segue is a transition from one controller to another. In the same way, a storyboard
    file is a collection of controllers and their views attached together by segues.
    This, in turn, allows you to see the layouts of each controller and the general
    flow of your application at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just a few categories of segue, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: This is used within a navigation controller. It pushes a new controller
    to the top of the navigation controller''s stack. Push uses the standard animation
    technique for navigation controllers and is generally the most commonly used segue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationship**: This is used to set a child controller for another controller.
    For example, the root controller of a navigation controller, container views,
    or split view controllers in an iPad application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modal**: On using this, a controller presented modally will appear on top
    of the parent controller. It will cover the entire screen until dismissed. There
    are several types of different transition animations available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: This is a custom segue that includes an option for a custom class,
    which subclasses `UIStoryboardSegue`. This gives you fine-grained control over
    the animation and how the next controller is presented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Segues also keep to the following pattern while executing:'
  prefs: []
  type: TYPE_NORMAL
- en: The destination controller and its views are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The segue object, a subclass of `UIStoryboardSegue`, is created. This is normally
    only important for custom segues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PrepareForSegue` method is called on the source controller. This is a good
    place to run any custom code before a segue begins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The segue's `Perform` method is called and the transition animation is started.
    This is where the bulk of the code resides for a custom segue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Xamarin.iOS designer you have the choice of either firing a segue automatically
    from a button or table view row, or just giving the segue an identifier. In the
    second case, you can start the segue yourself by calling the `PerformSegue` method
    on the source controller by using its identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s set up a new segue by setting up some aspects of our `Main.storyboard`
    file through performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Table View Controller** to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller, and navigate to the **Properties** pane and the
    **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `ConversationsController` into the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down under the **View Controller** section and enter a **Title** of `Conversations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a segue from `LoginController` to `ConversationsController` by clicking
    while holding **Ctrl** and dragging the blue line from one controller to the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Show** segue from the pop up that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the segue by clicking on it and give it an **Identifier** of `OnLogin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your storyboard will look something similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using segues for navigation](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `LoginController.cs` and modify the line of code that we marked as `TODO`
    earlier in this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now if you build and run the application, you will navigate to the new controller
    after a successful login. The segue will be performed, and you will see the built-in
    animation provided by the navigation controller.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up UITableView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's set up the table view on the second controller. We are using a powerful
    class on iOS called `UITableView`. It is used in many situations and is very similar
    to the concept of a list view on other platforms. The `UITableView` class is controlled
    by another class called `UITableViewSource`. It has methods that you need to override
    to set up how many rows should exist and how those rows should be displayed on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `UITableViewSource` is a combination of `UITableViewDelegate` and
    `UITableViewDataSource`. I prefer to use `UITableViewSource` for simplicity, since
    using both of the other two classes would often be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump in and start coding, let''s review the most commonly used methods
    on `UITableViewSource`, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RowsInSection`: This method allows you to define the number of rows in a section.
    All table views have a number of sections and rows. By default, there is only
    one section; however, it is a requirement to return the number of rows in a section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberOfSections`: This is the number of sections in the table view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetCell`: This method must return a cell for each row. It is up to the developer
    to set up what a cell should look like; you can set up the table view to recycle
    cells. Recycling cells will yield better performance while scrolling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TitleForHeader`: This method, if overridden, is the simplest way to return
    a string for the title. Each section in a table view can have a standard header
    view by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RowSelected`: This method will be called when the user selects a row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are additional methods that you can override, but these will get you going
    in most situations. You can also set up custom headers and footers if you need
    to develop a custom-styled table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s open the `ConversationsController.cs` file and create a nested class
    inside `ConversationsController`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented the two required methods for setting up a table view: `RowsInSection`
    and `GetCell`. We returned the number of conversations found on the view model
    and set up our cell for each row. We also used `UITableViewCellAccessory.DisclosureIndicator`
    to add an indicator for the users to see that they can click on the row.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice our implementation of recycling cells. Calling `DequeueReusableCell`
    with a cell identifier will return a `null` cell the first time around. If `null`,
    you should create a new cell using the same cell identifier. Subsequent calls
    to `DequeueReusableCell` will return an existing cell, enabling you to reuse it.
    You can also define `TableView` cells in the storyboard file, which is useful
    for custom cells. Our cell here is very simple, so it is easier to define it from
    the code. Recycling cells is important on mobile platforms to preserve memory
    and provide the user with a very fluid scrolling table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the `TableView` source on `TableView`. Add some changes
    to our `ConversationsController` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, when the view appears, we will load our list of conversations. Upon completion
    of that task, we'll reload the table view so that it displays our list of conversations.
    If you run the application, you'll see a few conversations appear in the table
    view after logging in, as shown in the following screenshot. Down the road, everything
    will operate in the same manner when we load the conversations from a real web
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up UITableView](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a friends list screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next screen we need for our XamSnap app is our friends list. When creating
    a new conversation, the app will load a list of friends to start a conversation
    with. We'll follow a very similar pattern to load our list of conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we''ll create `UIBarButtonItem`, which navigates to a new controller
    named `FriendsController`, by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Table View Controller** to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller, click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `FriendsController` into the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **View Controller** section and enter `Friends` in the **Title**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Navigation Item** from the **Toolbox** onto the `ConversationsController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Bar Button Item** element and place it on the top-right of the
    new navigation bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** pane of the bar button, set its **Identifier** to **Add**.
    This will use the built-in plus button, which is commonly used throughout iOS
    applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a segue from the **Bar Button Item** to the `FriendsController` by holding
    **Ctrl** and dragging the blue line from the bar button to the next controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Show** segue from the pop up that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your changes to the storyboard should look something similar to what is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a friends list screen](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You should see a new `FriendsController` class, which Xamarin Studio has generated
    for you. If you compile and run the application, you'll see the new bar button
    item we've created. Clicking on it will navigate you to the new controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement `UITableViewSource` to display our friends list. Start
    with a new nested class inside `FriendsController`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, we implemented table cell recycling and merely set the text
    on the label for each friend. We used `cell.AccessoryView` to indicate to the
    user that each cell is clickable and starts a new conversation. We disabled user
    interaction on the button just to allow the row to be selected when the user clicks
    on the button. Otherwise, we'd have to implement a click event for the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to modify `FriendsController` in the same way as we did for
    conversations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will function exactly the same as the conversations list: the controller
    will load the friends list asynchronously and refresh the table view. If you compile
    and run the application, you''ll be able to navigate to the screen and view the
    sample friends list we created in [Chapter 4](part0039.xhtml#aid-1565U1 "Chapter 4. XamSnap
    - A Cross-Platform App"), *XamSnap - A Cross-Platform App*, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a friends list screen](img/image00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a list of messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's implement the screen to view a conversation or list of messages. We
    will try to model the screen on the built-in text message application in iOS.
    To do so, we will also cover the basics of how to create custom table view cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll need a new `MessagesController` class; perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Table View Controller** to the storyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your view controller, click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `MessagesController` into the **Class** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **View Controller** section and enter `Messages` in the **Title**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a segue from `ConversationsController` to `MessagesController` by holding
    ***Ctrl*** and dragging the blue line from one controller to the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Show** segue from the pop up that appears. Enter the **Identifier**
    `OnConversation` in the **Properties** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create two **Table View Cells** in the table view in `MessagesController`.
    You may reuse the existing blank one created by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Style** field to **Basic** for each cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Identifier** to `MyCell` and `TheirCell`, respectively, for each cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Xamarin Studio will generate `MessagesController.cs`. Just as before, you can
    move the controller to a `Controllers` folder. Now open `MessagesController.cs`
    and implement `UITableViewSource` inside a nested class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We added some logic to check if a message is from a current user to decide on
    the appropriate table cell identifier. Since we used the **Basic** style for both
    cells, we can use the `TextLabel` property on the cell to set the text for a `UILabel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make the required changes to our `MessagesController`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only new thing here is where we set the `Title` property to the username
    of the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our custom cells, we will need to make more changes in Xcode by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a **Label** by clicking on the default text, **Title**, on either cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use some creativity to style both labels. I chose to make the text in `MyCell`
    blue and `TheirCell` green. I set **Alignment** on the label to right aligned
    in `TheirCell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the storyboard file and return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to update the `ConversationsController` to navigate to this new
    screen. Let''s modify the `TableSource` class inside `ConversationsController.cs`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, you will have to modify one small line in the `ViewDidLoad`
    of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application now, you will be able to view the messages list
    as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a list of messages](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Composing messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final piece of our application, we need to implement some custom functionality
    that Apple doesn't provide with their APIs. We need to add a text field with a
    button that appears to be attached to the bottom of the table view. Most of this
    will require writing some simple C# code and wiring up events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding some new member variables to our `MessagesController`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place the text field and bar buttons inside the toolbar, as in the
    following code in `ViewDidLoad`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Much of this work is a basic UI setup. It is not something we can do inside
    Xcode because it is a very specific use case. We create a text field, bar button
    item, and toolbar from C#, and add them as a footer to our `UITableView`. This
    will display the toolbar at the bottom of the table view, below any rows we defined
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will need to modify `ViewWillAppear`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We need to subscribe to `IsBusyChanged` in order to show and hide the spinner.
    We also call `BecomeFirstResponder`, so the keyboard will appear and give focus
    to our text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s add an override for `ViewWillDisapper` to clean up the event, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s set up our method for `IsBusyChanged`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`OnIsBusyChanged` is used to disable some of our views while it is loading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we need to implement a function for sending a new message,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code is also fairly straightforward. After sending the message, we merely
    need to clear out the text field and tell the table view to reload the newly added
    row, as shown in the following screenshot. Using the `async` keyword makes this
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing messages](img/image00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the basic settings that Apple and Xamarin provide
    for developing iOS applications. This includes the `Info.plist` file and project
    options in Xamarin Studio. We covered `UINavigationController`, the basic building
    block for navigation in iOS applications, and implemented a login screen complete
    with username and password fields. Next, we covered iOS segues and the `UITableView`
    class. We implemented the friends list screen using `UITableView`, and the messages
    list screen, also using `UITableView`. Lastly, we added a custom UI functionality:
    a custom toolbar floating at the bottom of the messages list.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon completing this chapter, you will have a partially functional iOS version
    of XamSnap. You will have a deeper understanding of the iOS platform and tools,
    and fairly good knowledge to apply to building your own iOS applications. Take
    it upon yourself to implement the remaining screens that we did not cover in this
    chapter. If you get lost, feel free to review the full sample application included
    with this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement these UIs on Android.
  prefs: []
  type: TYPE_NORMAL
