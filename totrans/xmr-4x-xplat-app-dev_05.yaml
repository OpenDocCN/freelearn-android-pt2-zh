- en: Chapter 5. XamSnap for iOS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. iOS的XamSnap
- en: To begin writing the iOS version of XamSnap, open the solution we created in
    the previous chapter. We will be working mostly in the `XamSnap.iOS` project in
    this chapter. The project template will have automatically created a controller
    named `ViewController`; go ahead and delete it. We will create our own controllers
    as we go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写XamSnap的iOS版本，请打开我们在上一章创建的解决方案。在本章中，我们主要在`XamSnap.iOS`项目中工作。项目模板将自动创建一个名为`ViewController`的控制器；请继续并删除它。我们将在进行中创建我们自己的控制器。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The basics of an iOS application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS应用的基础知识
- en: Using UINavigationController
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UINavigationController
- en: Implementing a login screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现登录界面
- en: Segues and UITableView
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Segues和UITableView
- en: Adding a friends list
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加好友列表
- en: Adding a list of messages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加消息列表
- en: Composing messages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写消息
- en: Understanding the basics of an iOS app
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解iOS应用的基础知识
- en: Before we start developing our app, let's review the main settings of the application.
    Apple uses a file named `Info.plist` to store important information about any
    iOS app. These settings are used by the OS itself and when an iOS application
    is installed on a device by the Apple App Store. Begin development of any new
    iOS application by filling out the information in this file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发我们的应用程序之前，让我们回顾一下应用程序的主要设置。苹果使用一个名为`Info.plist`的文件来存储有关任何iOS应用的重要信息。这些设置由操作系统本身使用，以及当iOS应用程序通过苹果应用商店在设备上安装时。开始开发任何新的iOS应用程序，通过填写此文件中的信息。
- en: 'Xamarin Studio provides a neat menu to modify values in the `Info.plist` file,
    as shown in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio提供了一个整洁的菜单，用于修改`Info.plist`文件中的值，如下截图所示：
- en: '![Understanding the basics of an iOS app](img/image00217.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![了解iOS应用的基础知识](img/image00217.jpeg)'
- en: 'The most important settings are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的设置如下：
- en: '**Application Name**: This is the title below an app''s icon in iOS. Note that
    this is not the same as the official name of your app in the iOS App Store.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用名称**：这是iOS中应用图标下方的标题。请注意，这与你在iOS应用商店中的应用程序官方名称不同。'
- en: '**Bundle Identifier**: This is your app''s bundle identifier or bundle ID.
    It is a unique name to identify your application. The convention is to use a reverse
    domain naming style beginning with your company name, such as `com.jonathanpeppers.xamsnap`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包标识符**：这是你的应用程序的包标识符或包ID。这是一个独特的名称，用于识别你的应用程序。约定是使用以你的公司名称开头的反向域名命名风格，如`com.jonathanpeppers.xamsnap`。'
- en: '**Version**: This is the version number for your application that is visible
    to the users on the app store, such as `1.0.0`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：这是你的应用程序的版本号，用户在应用商店中可见，如`1.0.0`。'
- en: '**Build**: This is the version number reserved for the developer (for CI builds,
    etc.), such as `1.0.0.1234`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：这是为开发者保留的版本号（例如CI构建等），如`1.0.0.1234`。'
- en: '**Devices**: In this, you can select **iPhone/iPod**, **iPad**, or **Universal**
    (all devices) for your application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：在这里，你可以为你的应用程序选择**iPhone/iPod**、**iPad**或**通用**（所有设备）。'
- en: '**Deployment Target**: This is the minimum iOS version your application runs
    on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署目标**：这是你的应用程序运行的最低iOS版本。'
- en: '**Main Interface**: This is the main storyboard file for your app.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主界面**：这是你的应用的主故事板文件。'
- en: '**Device Orientations**: These are the different positions your application
    will be able to rotate to and support.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备方向**：这是你的应用程序能够旋转并支持的不同位置。'
- en: '**Status Bar Style**: These are the options to hide the top status bar in your
    application and run full screen.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态栏样式**：这些选项可以隐藏应用程序中的顶部状态栏，并全屏运行。'
- en: There are other settings for app icons, splash screens, and so on. You can also
    toggle between the **Advanced** or **Source** tabs to configure additional settings
    for which Xamarin does not provide a user-friendly menu.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他关于应用图标、启动屏幕等的设置。你也可以在**高级**或**源**标签之间切换，以配置Xamarin没有提供友好菜单的其他设置。
- en: 'Configure the following settings for our application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置以下设置：
- en: '**Application Name**: `XamSnap`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用名称**：`XamSnap`'
- en: '**Bundle Identifier**: `com.yourcompanyname.xamsnap`; make sure you name future
    apps so that they begin with `com.yourcompanyname`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包标识符**：`com.yourcompanyname.xamsnap`；确保你为未来应用命名时，它们以`com.yourcompanyname`开头。'
- en: '**Devices**: **iPhone/iPod**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：**iPhone/iPod**'
- en: '**Deployment Target**: **8.0**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署目标**：**8.0**'
- en: '**Supported Device Orientations**: Only select **Portrait**.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的设备方向**：只选择**纵向**。'
- en: Xamarin.iOS Build Options
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.iOS构建选项
- en: You can find some additional settings for Xamarin iOS applications if you right-click
    on your project and select **Options**, as shown in the following screenshot.
    It is a good idea to know what is available for iOS-specific projects in Xamarin
    Studio. A lot is going on here, but the defaults will get you by in most situations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你右键点击你的项目并选择**选项**，你可以找到一些针对 Xamarin iOS 应用程序的附加设置，如下面的截图所示。了解在 Xamarin Studio
    中为 iOS 特定项目提供了什么是一个好主意。这里有很多内容，但在大多数情况下，默认设置就足够了。
- en: '![Xamarin.iOS Build Options](img/image00218.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.iOS 构建选项](img/image00218.jpeg)'
- en: 'Let''s discuss some of the most important options, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些最重要的选项，如下：
- en: '**iOS Build**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**iOS 构建**'
- en: '**SDK version**: This is the version of the iOS SDK to compile your application
    with. It is generally best to use **Default**.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDK 版本**：这是用于编译应用程序的 iOS SDK 版本。通常最好使用**默认**版本。'
- en: '**Linker behavior**: Xamarin has implemented a feature called **linking**.
    The linker will strip any code that will never be called within your assemblies.
    This keeps your application small, and allows them to ship a stripped-down version
    of the core Mono runtime with your app. Except for debug builds, it is best to
    use the **Link SDK assemblies only** option. We will cover linking in a future
    chapter.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接器行为**：Xamarin 实现了一个名为**链接**的功能。链接器将移除任何在你的程序集中永远不会调用的代码。这使你的应用程序保持小巧，并允许它们与你的应用程序一起发布核心
    Mono 运行的简化版本。除了调试版本外，最好使用**仅链接 SDK 程序集**的选项。我们将在未来的章节中介绍链接。'
- en: '**Supported Architectures**: These are the types of processors. `i386` is the
    simulator and `ARMv7 + ARM64` is the option for compiling for modern iOS devices.
    You should generally be able to use the defaults here, unless upgrading an older
    Xamarin.iOS application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的架构**：这些是处理器的类型。`i386`是模拟器，`ARMv7 + ARM64`是针对现代 iOS 设备编译的选项。你通常应该能够在这里使用默认设置，除非升级较旧的
    Xamarin.iOS 应用程序。'
- en: '**HttpClient implementation**: newer versions of Xamarin.iOS allow you to choose
    a native HTTP stack for `System.Net.Http.HttpClient`. Mono''s implementation is
    the default, but is not as performant as the native stack.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HttpClient 实现**：新版本的 Xamarin.iOS 允许你为`System.Net.Http.HttpClient`选择本地 HTTP
    栈。Mono 的实现是默认的，但性能不如本地栈。'
- en: '**SSL/TLS implementation**: Xamarin.iOS also has the option to use native APIs
    for SSL. If you choose Mono instead, your application will only support TLS 1.0,
    so it is better to use the native option here.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSL/TLS 实现**：Xamarin.iOS 也有使用本地 API 进行 SSL 的选项。如果你选择使用 Mono，你的应用程序将只支持 TLS
    1.0，因此最好在这里使用本地选项。'
- en: '**Use LLVM optimizing compiler**: Checking this compiles code that is smaller
    and runs faster, but takes longer to compile. **LLVM** stands for **Low Level
    Virtual Machine**.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 LLVM 优化编译器**：勾选此项将编译出体积更小、运行速度更快的代码，但编译时间会更长。**LLVM**代表**低级虚拟机**。'
- en: '**Strip native debugging symbols**: When this option is on, Xamarin removes
    extra information from your app that would enable debugging from Xamarin Studio.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去除本地调试符号**：当这个选项开启时，Xamarin 会从你的应用程序中移除额外的信息，这些信息可以从 Xamarin Studio 中进行调试。'
- en: '**Additional mtouch arguments**: This field is for passing extra command-line
    arguments to the Xamarin compiler for iOS. You can check the complete list of
    these arguments at [https://developer.xamarin.com/api](https://developer.xamarin.com/api).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的 mtouch 参数**：此字段用于传递给 iOS 的 Xamarin 编译器额外的命令行参数。你可以查看这些参数的完整列表在[https://developer.xamarin.com/api](https://developer.xamarin.com/api)。'
- en: '**Optimize PNG files for iOS**: Apple uses a custom PNG format to speed up
    the loading of PNGs within your app. You can turn this off to speed up builds,
    or if you plan on optimizing the images yourself.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对 iOS 优化 PNG 文件**：苹果使用自定义的 PNG 格式来加速应用程序内 PNG 的加载。你可以关闭此选项来加快构建速度，或者如果你打算自己优化图像。'
- en: '**iOS Bundle Signing**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**iOS 打包签名**'
- en: '**Signing Identity**: This is the certificate to identify the app''s creator
    for deploying the application to devices. We''ll cover more on this in later chapters.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名标识**：这是用于识别应用程序创建者并将应用程序部署到设备的证书。我们将在后面的章节中详细介绍这一点。'
- en: '**Provisioning profile**: This is a specific profile that deploys the app to
    a device. This works in tandem with **Signing Identity**, but also declares the
    distribution method and the devices that can install the app.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：这是一个特定的配置文件，用于将应用程序部署到设备上。它与**签名标识**协同工作，同时声明分发方法和可以安装应用程序的设备。'
- en: '**Custom Entitlements**: This file contains additional settings to be applied
    with the provisioning profile and contains other specific declarations for the
    app, such as iCloud or push notifications. The project template for iOS apps includes
    a default `Entitlements.plist` file for new projects.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义权利**：这个文件包含了与应用程序权利证明文件一起应用的附加设置，并包含了对应用程序的其他特定声明，比如iCloud或推送通知。iOS应用程序的项目模板为新项目包含了一个默认的`Entitlements.plist`文件。'
- en: For this application, you can leave all these options at their defaults. When
    making a real iOS application on your own, you should consider changing many of
    these as per your application's needs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，你可以保留所有这些选项为默认值。在独自开发实际的iOS应用程序时，你应该根据应用程序的需求考虑更改这些设置。
- en: Using UINavigationController
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`UINavigationController`。
- en: In iOS applications, the key class for managing navigation between different
    controllers is the `UINavigationController` class. It is a parent controller that
    contains several child controllers in a stack. Users can move forward by putting
    new controllers on top of the stack, or using a built-in back button to pop a
    controller off the stack and navigate to the previous screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS应用程序中，管理不同控制器间导航的关键类是`UINavigationController`。它是一个父控制器，包含了一个栈中的多个子控制器。用户可以通过在栈顶放置新的控制器来前进，或者使用内置的后退按钮移除控制器并导航回上一个屏幕。
- en: 'The developer can manipulate the navigation controller''s stack with the following
    methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用以下方法操作导航控制器的栈：
- en: '`SetViewControllers`: This sets an array of child controllers. It has a value
    to optionally animate the transition.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetViewControllers`：这个方法设置一个子控制器数组。它有一个可选值用来动画过渡。'
- en: '`ViewControllers`: This is a property for getting or setting the array of child
    controllers without an option for animation.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewControllers`：这是一个属性，用于获取或设置子控制器数组，但不提供动画选项。'
- en: '`PushViewController`: This places a new child controller at the top of the
    stack and has an option to display an animation.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PushViewController`：这个方法将一个新的子控制器放置在栈顶，并可以选择显示动画。'
- en: '`PopViewController`: This pops off the child controller at the top of the stack
    and has an option to animate the transition.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopViewController`：这个方法会移除栈顶的子控制器，并可以选择是否动画过渡。'
- en: '`PopToViewController`: This pops to the specified child controller, removing
    all controllers above it. It provides an option to animate the transition.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopToViewController`：这个方法移除到指定的子控制器，移除其上的所有控制器。它提供了一个动画过渡的选项。'
- en: '`PopToRootViewController`: This removes all child controllers except the bottom-most
    controller. It includes an option to display an animation.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopToRootViewController`：这个方法移除除了最底部的控制器之外的所有子控制器。它包括一个显示动画的选项。'
- en: '`TopViewController`: This is a property that returns the child controller that
    is currently on top of the stack.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopViewController`：这是一个属性，返回当前位于栈顶的子控制器。'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important to note that using the option for animations will cause a crash
    if you try to modify the stack during the animation. To fix this situation, either
    use the `SetViewControllers` method and set the entire list of child controllers,
    or refrain from using the animations during a combination of transitions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果在动画过程中尝试修改栈，使用动画选项将会导致崩溃。要解决这个问题，可以选择使用`SetViewControllers`方法并设置整个子控制器列表，或者在组合过渡期间避免使用动画。
- en: 'Let''s set up a navigation controller in our application by performing the
    following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下步骤，在应用程序中设置导航控制器：
- en: Double-click on the `Main.storyboard` file to open it in Xamarin Studio.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Main.storyboard`文件，在Xamarin Studio中打开它。
- en: Remove the controller that was created by the project template.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除由项目模板创建的控制器。
- en: Drag a **Navigation Controller** element from the **Toolbox** on the right onto
    the storyboard.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右侧的**工具箱**中拖动一个**导航控制器**元素到故事板中。
- en: Notice that a default **View Controller** element was created, as well as a
    **Navigation Controller**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，已经创建了一个默认的**视图控制器**元素以及一个**导航控制器**。
- en: You will see a **segue** that connects the two controllers. We'll cover this
    concept in more detail later in the chapter.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个连接两个控制器的**segue**。我们将在本章后面更详细地介绍这个概念。
- en: Save the storyboard file.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just a note for Visual Studio users, Xamarin has done a great job making their
    Visual Studio Extension work identically to Xamarin Studio. All of the examples
    in this chapter should work just as described in either Xamarin Studio on OS X
    or Visual Studio on Windows. The exception, of course, is a remotely connected
    mac for deploying to the simulator or an iOS device.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Visual Studio用户的一个小提示，Xamarin已经很好地使他们的Visual Studio扩展与Xamarin Studio完全相同。本章中的所有示例都应如描述的那样在Xamarin
    Studio on OS X或Windows上的Visual Studio中工作。当然，远程连接的mac部署到模拟器或iOS设备是一个例外。
- en: 'If you run the application at this point, you will have a basic iOS app with
    a status bar at the top, a navigation controller containing a navigation bar with
    a default title, and a child controller that is completely white, as shown in
    the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行应用程序，你将得到一个基本的iOS应用，它有一个顶部的状态栏，一个包含默认标题的导航栏的导航控制器，以及一个完全白色的子控制器，如下面的截图所示：
- en: '![Using UINavigationController](img/image00219.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用UINavigationController](img/image00219.jpeg)'
- en: Implementing the login screen
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录界面
- en: Since the first screen of our application will be a login screen, let's begin
    by setting up the appropriate views in the storyboard file. We will implement
    the login screen by using Xamarin Studio to write the C# code, and its iOS designer
    to create iOS layouts in our storyboard file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们应用程序的第一个屏幕将是登录屏幕，因此让我们从在故事板文件中设置适当的视图开始。我们将使用Xamarin Studio编写C#代码实现登录屏幕，并使用其iOS设计师在故事板文件中创建iOS布局。
- en: 'Return to the project in Xamarin Studio and perform the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Xamarin Studio中的项目，并执行以下步骤：
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Main.storyboard`文件，在iOS设计师中打开它。
- en: Select your view controller, click on the **Properties** pane and select the
    **Widget** tab.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，点击**属性**窗格并选择**小部件**标签页。
- en: Enter `LoginController` into the **Class** field.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`LoginController`。
- en: Notice that the `LoginController` class is generated for you. You may create
    a `Controllers` folder and move the file into it if you wish.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到为你生成了`LoginController`类。如果你愿意，可以创建一个`Controllers`文件夹并将文件移到其中。
- en: 'The following screenshot shows what the controller''s settings will look like
    in Xamarin Studio after the changes have been made:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Xamarin Studio中进行更改后控制器设置的样子：
- en: '![Implementing the login screen](img/image00220.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![实现登录界面](img/image00220.jpeg)'
- en: 'Now let''s modify the layout of the controller by performing the following
    steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过执行以下步骤来修改控制器的布局：
- en: Double-click on the `Main.storyboard` file a second time to return to the iOS
    designer.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次双击`Main.storyboard`文件返回到iOS设计师。
- en: Tap on the navigation bar and edit the **Title** field to read `Login`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击导航栏并编辑**标题**字段，将其改为`Login`。
- en: Drag two text fields onto the controller. Position and size them appropriately
    for the username and password entries. You may also want to remove the default
    text to make the fields blank.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个文本字段拖到控制器上。适当地为用户名和密码输入定位和调整它们的大小。你可能还想删除默认文本以使字段为空。
- en: For the second field, check the **Secure Text Entry** checkbox. This will set
    the control to hide the characters for the password field.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个字段，勾选**安全文本输入**复选框。这将设置控件隐藏密码字段的字符。
- en: You may also want to fill out the **Placeholder** field for `Username` and `Password`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还想为`Username`和`Password`填写**占位符**字段。
- en: Drag a button onto the controller. Set the button's **Title** to `Login`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个按钮拖到控制器上。将按钮的**标题**设置为`Login`。
- en: Drag an activity indicator onto the controller. Check the **Animating** and
    **Hidden** checkboxes.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个活动指示器拖到控制器上。勾选**动画**和**隐藏**复选框。
- en: Next, create the outlets for each of the controls by filling out the **Name**
    field. Name the outlets `username`, `password`, `login`, and `indicator`, respectively.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过填写**名称**字段为每个控件创建出口。分别为这些出口命名为`username`、`password`、`login`和`indicator`。
- en: Save the storyboard file and take a look at `LoginController.designer.cs`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件，查看`LoginController.designer.cs`。
- en: 'You will notice that Xamarin Studio has generated properties for each of the
    outlets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到Xamarin Studio已经为每个出口生成了属性：
- en: '![Implementing the login screen](img/image00221.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![实现登录界面](img/image00221.jpeg)'
- en: Go ahead and compile the application to make sure everything is okay. At this
    point, we also need to add a reference to the `XamSnap.Core` project created in
    the previous chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 去编译应用程序，确保一切正常。在这一点上，我们还需要添加对前一章创建的`XamSnap.Core`项目的引用。
- en: 'Next, let''s set up our iOS application to register all its view models and
    the other services that will be used throughout the application. We will use the
    `ServiceContainer` class we created in [Chapter 4](part0039.xhtml#aid-1565U1 "Chapter 4. XamSnap
    - A Cross-Platform App"), *XamSnap - A Cross-Platform App*, to set up dependencies
    throughout our application. Open `AppDelegate.cs` and add the following method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们设置iOS应用程序以注册其所有视图模型以及其他将在整个应用程序中使用的服务。我们将使用在[第4章](part0039.xhtml#aid-1565U1
    "第4章。XamSnap - 一个跨平台应用程序")，*XamSnap - 一个跨平台应用程序*中创建的`ServiceContainer`类来设置我们应用程序中的依赖关系。打开`AppDelegate.cs`并添加以下方法：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Down the road, we will replace the fake services with real ones. Now let''s
    add the login functionality to `LoginController.cs`. First add `LoginViewModel`
    to a member variable at the top of the class, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续操作中，我们将用真实的服务替换假服务。现在让我们在`LoginController.cs`中添加登录功能。首先在类顶部将`LoginViewModel`添加到成员变量中，如下所示：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will pull a shared instance of `LoginViewModel` into a local variable in
    the controller. This is the pattern we will use throughout the book in order to
    pass a shared view model from one class to another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`LoginViewModel`的共享实例拉入控制器中的局部变量。这是我们将在整本书中使用的模式，以便将共享视图模型从一个类传递到另一个类。
- en: 'Next, override `ViewDidLoad` to hook up the view model''s functionality with
    the views set up in outlets, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重写`ViewDidLoad`以将视图模型的功能与在outlets中设置好的视图连接起来，如下所示：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll add the code to navigate to a new screen later in the chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面添加代码以导航到一个新屏幕。
- en: 'Next, let''s hook up the `IsBusyChanged` event to actually perform an action,
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`IsBusyChanged`事件实际连接起来以执行一个操作，如下所示：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you might ask why we subscribe to the event in this manner. The problem
    is that the `LoginViewModel` class will last through your application's lifetime,
    while the `LoginController` class will not. If we subscribed to the event in `ViewDidLoad`,
    but didn't unsubscribe later, then our application would have a memory leak. We
    also avoided using a lambda expression for the event, since it would otherwise
    be impossible to unsubscribe to the event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问为什么我们要以这种方式订阅事件。问题是`LoginViewModel`类将贯穿应用程序的整个生命周期，而`LoginController`类则不会。如果我们只在`ViewDidLoad`中订阅事件，但稍后没有取消订阅，那么我们的应用程序将会有内存泄漏。我们还避免了使用lambda表达式作为事件，因为否则将无法取消订阅该事件。
- en: Note that we don't have the same problem with the `TouchUpInside` event on the
    button, since it will live in memory as long as the controller does. This is a
    common problem with events in C#, which is why it is a good idea to use the preceding
    pattern on iOS.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不会遇到按钮上的`TouchUpInside`事件相同的问题，因为它将和控制器一样长时间存在于内存中。这是C#中事件的一个常见问题，这就是为什么在iOS上使用前面的模式是一个好主意。
- en: If you run the application now, you should be able to enter a username and password,
    as shown in the following screenshot. On pressing **Login**, you should see the
    indicator appear and all the controls disabled. Your application will correctly
    be calling the shared code, and should function correctly when we add a real web
    service.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该能够输入用户名和密码，如下面的截图所示。按下**登录**后，你应该看到指示器出现，所有控件被禁用。你的应用程序将正确调用共享代码，并且在我们添加一个真实的网络服务时应该能正确运行。
- en: '![Implementing the login screen](img/image00222.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![实现登录界面](img/image00222.jpeg)'
- en: Using segues for navigation
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用segue进行导航
- en: A segue is a transition from one controller to another. In the same way, a storyboard
    file is a collection of controllers and their views attached together by segues.
    This, in turn, allows you to see the layouts of each controller and the general
    flow of your application at the same time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Segue是从一个控制器到另一个控制器的过渡。同样，一个故事板文件是连接在一起的控制器和它们的视图的集合，通过segue进行连接。这反过来又允许你同时查看每个控制器的布局和应用程序的一般流程。
- en: 'There are just a few categories of segue, which are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的segue，如下所示：
- en: '**Push**: This is used within a navigation controller. It pushes a new controller
    to the top of the navigation controller''s stack. Push uses the standard animation
    technique for navigation controllers and is generally the most commonly used segue.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**：在导航控制器内使用。它将一个新的控制器推送到导航控制器堆栈的顶部。推送使用导航控制器的标准动画技术，通常是最常用的过渡方式。'
- en: '**Relationship**: This is used to set a child controller for another controller.
    For example, the root controller of a navigation controller, container views,
    or split view controllers in an iPad application.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系**：用于为另一个控制器设置子控制器。例如，导航控制器的根控制器，容器视图，或者在iPad应用程序中的分割视图控制器。'
- en: '**Modal**: On using this, a controller presented modally will appear on top
    of the parent controller. It will cover the entire screen until dismissed. There
    are several types of different transition animations available.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模态**：使用此方式时，以模态方式呈现的控制器将出现在父控制器的顶部。它将覆盖整个屏幕，直到被关闭。有几种不同类型的过渡动画可供选择。'
- en: '**Custom**: This is a custom segue that includes an option for a custom class,
    which subclasses `UIStoryboardSegue`. This gives you fine-grained control over
    the animation and how the next controller is presented.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：这是一种自定义的过渡，包括一个选项，用于自定义类，该类是`UIStoryboardSegue`的子类。这使你可以细致地控制动画以及下一个控制器的呈现方式。'
- en: 'Segues also keep to the following pattern while executing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡在执行时也遵循以下模式：
- en: The destination controller and its views are created.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地控制器及其视图被创建。
- en: The segue object, a subclass of `UIStoryboardSegue`, is created. This is normally
    only important for custom segues.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`UIStoryboardSegue`的子类的过渡对象。这对于自定义过渡通常很重要。
- en: The `PrepareForSegue` method is called on the source controller. This is a good
    place to run any custom code before a segue begins.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源控制器上调用`PrepareForSegue`方法。在过渡开始之前，这是一个运行任何自定义代码的好地方。
- en: The segue's `Perform` method is called and the transition animation is started.
    This is where the bulk of the code resides for a custom segue.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡的`Perform`方法被调用，过渡动画开始。这是自定义过渡的大部分代码所在的地方。
- en: In the Xamarin.iOS designer you have the choice of either firing a segue automatically
    from a button or table view row, or just giving the segue an identifier. In the
    second case, you can start the segue yourself by calling the `PerformSegue` method
    on the source controller by using its identifier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS设计师中，你有从按钮或表格行自动触发过渡的选择，或者只是给过渡一个标识符。在第二种情况下，你可以通过使用其标识符在源控制器上调用`PerformSegue`方法来自己启动过渡。
- en: 'Now let''s set up a new segue by setting up some aspects of our `Main.storyboard`
    file through performing the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过执行以下步骤设置一些`Main.storyboard`文件的方面，来设置一个新的过渡：
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Main.storyboard`文件，在iOS设计师中打开它。
- en: Add a new **Table View Controller** to the storyboard.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向故事板中添加一个新的**表格视图控制器**。
- en: Select your view controller, and navigate to the **Properties** pane and the
    **Widget** tab.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，并导航到**属性**窗格和**小部件**标签。
- en: Enter `ConversationsController` into the **Class** field.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`ConversationsController`。
- en: Scroll down under the **View Controller** section and enter a **Title** of `Conversations`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**视图控制器**部分向下滚动，并输入一个**标题**为`Conversations`。
- en: Create a segue from `LoginController` to `ConversationsController` by clicking
    while holding **Ctrl** and dragging the blue line from one controller to the other.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住**Ctrl**点击并从`LoginController`拖动蓝线到`ConversationsController`，创建一个过渡。
- en: Select the **Show** segue from the pop up that appears.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的弹出菜单中选择**显示**过渡。
- en: Select the segue by clicking on it and give it an **Identifier** of `OnLogin`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击选择此过渡，并为其分配一个标识符`OnLogin`。
- en: Save the storyboard file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'Your storyboard will look something similar to what is shown in the following
    screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你的故事板将与下面截图所示的内容类似：
- en: '![Using segues for navigation](img/image00223.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用过渡进行导航](img/image00223.jpeg)'
- en: 'Open `LoginController.cs` and modify the line of code that we marked as `TODO`
    earlier in this chapter, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LoginController.cs`文件，并按照本章早些时候标记为`TODO`的代码行进行修改，如下所示：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now if you build and run the application, you will navigate to the new controller
    after a successful login. The segue will be performed, and you will see the built-in
    animation provided by the navigation controller.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你构建并运行应用程序，成功登录后你将导航到新的控制器。过渡将被执行，你将看到导航控制器提供的内置动画。
- en: Setting up UITableView
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 UITableView
- en: Next, let's set up the table view on the second controller. We are using a powerful
    class on iOS called `UITableView`. It is used in many situations and is very similar
    to the concept of a list view on other platforms. The `UITableView` class is controlled
    by another class called `UITableViewSource`. It has methods that you need to override
    to set up how many rows should exist and how those rows should be displayed on
    the screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在第二个控制器上设置表格视图。我们在 iOS 上使用了一个强大的类，叫做 `UITableView`。它被用在许多场景中，并且与其他平台上列表视图的概念非常相似。`UITableView`
    类由另一个叫做 `UITableViewSource` 的类控制。它有你需要重写的方法，以设置应该存在多少行以及这些行应该如何在屏幕上显示。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that `UITableViewSource` is a combination of `UITableViewDelegate` and
    `UITableViewDataSource`. I prefer to use `UITableViewSource` for simplicity, since
    using both of the other two classes would often be required.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `UITableViewSource` 是 `UITableViewDelegate` 和 `UITableViewDataSource` 的组合。出于简单考虑，我更喜欢使用
    `UITableViewSource`，因为通常需要使用另外两个类。
- en: 'Before we jump in and start coding, let''s review the most commonly used methods
    on `UITableViewSource`, which are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们回顾一下在 `UITableViewSource` 上最常用的方法，如下：
- en: '`RowsInSection`: This method allows you to define the number of rows in a section.
    All table views have a number of sections and rows. By default, there is only
    one section; however, it is a requirement to return the number of rows in a section.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowsInSection`：这个方法允许你定义一个部分中的行数。所有表格视图都有多个部分和行。默认情况下，只有一个部分；然而，需要返回一个部分中的行数。'
- en: '`NumberOfSections`: This is the number of sections in the table view.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberOfSections`：这是表格视图中的部分数。'
- en: '`GetCell`: This method must return a cell for each row. It is up to the developer
    to set up what a cell should look like; you can set up the table view to recycle
    cells. Recycling cells will yield better performance while scrolling.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCell`：这个方法必须为每一行返回一个单元格。开发者需要决定单元格的外观；你可以设置表格视图来回收单元格。回收单元格可以在滚动时提供更好的性能。'
- en: '`TitleForHeader`: This method, if overridden, is the simplest way to return
    a string for the title. Each section in a table view can have a standard header
    view by default.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TitleForHeader`：如果重写这个方法，它是最简单的返回标题字符串的方式。表格视图中的每个部分默认都可以有一个标准的头部视图。'
- en: '`RowSelected`: This method will be called when the user selects a row.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowSelected`：当用户选择一行时，将调用此方法。'
- en: There are additional methods that you can override, but these will get you going
    in most situations. You can also set up custom headers and footers if you need
    to develop a custom-styled table view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可以重写的方法，但大多数情况下这些方法就足够了。如果需要开发具有自定义样式的表格视图，你还可以设置自定义的头部和底部。
- en: 'Now let''s open the `ConversationsController.cs` file and create a nested class
    inside `ConversationsController`, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开 `ConversationsController.cs` 文件，并在 `ConversationsController` 内部创建一个嵌套类，如下：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We implemented the two required methods for setting up a table view: `RowsInSection`
    and `GetCell`. We returned the number of conversations found on the view model
    and set up our cell for each row. We also used `UITableViewCellAccessory.DisclosureIndicator`
    to add an indicator for the users to see that they can click on the row.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了设置表格视图所需的两个方法：`RowsInSection` 和 `GetCell`。我们返回了视图模型中找到的对话数量，并为每一行设置了我们的单元格。我们还使用了
    `UITableViewCellAccessory.DisclosureIndicator`，以便用户可以看到他们可以点击行。
- en: Notice our implementation of recycling cells. Calling `DequeueReusableCell`
    with a cell identifier will return a `null` cell the first time around. If `null`,
    you should create a new cell using the same cell identifier. Subsequent calls
    to `DequeueReusableCell` will return an existing cell, enabling you to reuse it.
    You can also define `TableView` cells in the storyboard file, which is useful
    for custom cells. Our cell here is very simple, so it is easier to define it from
    the code. Recycling cells is important on mobile platforms to preserve memory
    and provide the user with a very fluid scrolling table.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们实现的单元格回收。使用单元格标识符调用 `DequeueReusableCell` 会在第一次返回一个 `null` 单元格。如果为 `null`，你应该使用相同的单元格标识符创建一个新的单元格。后续调用
    `DequeueReusableCell` 将返回一个现有的单元格，使你能够复用它。你也可以在故事板文件中定义 `TableView` 单元格，这对于自定义单元格很有用。我们的单元格这里非常简单，所以从代码中定义它更容易。在移动平台上回收单元格对于节省内存和为用户提供流畅的滚动表格非常重要。
- en: 'Next, we need to set up the `TableView` source on `TableView`. Add some changes
    to our `ConversationsController` class, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `TableView` 上设置 `TableView` 的数据源。对我们的 `ConversationsController` 类进行以下一些更改：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, when the view appears, we will load our list of conversations. Upon completion
    of that task, we'll reload the table view so that it displays our list of conversations.
    If you run the application, you'll see a few conversations appear in the table
    view after logging in, as shown in the following screenshot. Down the road, everything
    will operate in the same manner when we load the conversations from a real web
    service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当视图出现时，我们将加载我们的对话列表。在完成该任务后，我们将重新加载表格视图，使其显示我们的对话列表。如果你运行应用程序，你会在登录后看到表格视图中出现一些对话，如下面的截图所示。以后当我们从真正的网络服务加载对话时，一切都会以同样的方式运行。
- en: '![Setting up UITableView](img/image00224.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![设置UITableView](img/image00224.jpeg)'
- en: Adding a friends list screen
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加好友列表屏幕
- en: The next screen we need for our XamSnap app is our friends list. When creating
    a new conversation, the app will load a list of friends to start a conversation
    with. We'll follow a very similar pattern to load our list of conversations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们XamSnap应用程序下一个需要的屏幕是我们的好友列表。当创建新对话时，应用程序将加载好友列表以开始对话。我们将遵循一个非常相似的模式来加载我们的对话列表。
- en: 'To begin, we''ll create `UIBarButtonItem`, which navigates to a new controller
    named `FriendsController`, by performing the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过以下步骤创建一个`UIBarButtonItem`，它导航到一个名为`FriendsController`的新控制器：
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Main.storyboard`文件，在iOS设计师中打开它。
- en: Add a new **Table View Controller** to the storyboard.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向故事板中添加一个新的**表格视图控制器**。
- en: Select your view controller, click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，点击**属性**窗格，确保你选择了**控件**标签页。
- en: Enter `FriendsController` into the **Class** field.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`FriendsController`。
- en: Scroll down to the **View Controller** section and enter `Friends` in the **Title**
    field.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**视图控制器**部分，在**标题**字段中输入`Friends`。
- en: Drag a **Navigation Item** from the **Toolbox** onto the `ConversationsController`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**工具箱**中拖动一个**导航项**到`ConversationsController`上。
- en: Create a new **Bar Button Item** element and place it on the top-right of the
    new navigation bar.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**工具栏按钮**元素，并将其放置在新导航栏的右上角。
- en: In the **Properties** pane of the bar button, set its **Identifier** to **Add**.
    This will use the built-in plus button, which is commonly used throughout iOS
    applications.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏按钮的**属性**窗格中，将其**标识符**设置为**添加**。这将使用内置的加号按钮，这在iOS应用程序中是常用的。
- en: Create a segue from the **Bar Button Item** to the `FriendsController` by holding
    **Ctrl** and dragging the blue line from the bar button to the next controller.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住**Ctrl**键，并将蓝色线条从工具栏按钮拖动到下一个控制器，创建一个从**工具栏按钮**到`FriendsController`的segue。
- en: Select the **Show** segue from the pop up that appears.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的菜单中选择**显示**segue。
- en: Save the storyboard file.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'Your changes to the storyboard should look something similar to what is shown
    in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你对故事板的更改应该与以下截图所示类似：
- en: '![Adding a friends list screen](img/image00225.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![添加好友列表屏幕](img/image00225.jpeg)'
- en: You should see a new `FriendsController` class, which Xamarin Studio has generated
    for you. If you compile and run the application, you'll see the new bar button
    item we've created. Clicking on it will navigate you to the new controller.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个名为`FriendsController`的新类，这是Xamarin Studio为你生成的。如果你编译并运行应用程序，你会看到我们创建的新工具栏按钮。点击它将导航到新的控制器。
- en: 'Now let''s implement `UITableViewSource` to display our friends list. Start
    with a new nested class inside `FriendsController`, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`UITableViewSource`来展示我们的好友列表。首先在`FriendsController`内部创建一个新的嵌套类，如下所示：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just as before, we implemented table cell recycling and merely set the text
    on the label for each friend. We used `cell.AccessoryView` to indicate to the
    user that each cell is clickable and starts a new conversation. We disabled user
    interaction on the button just to allow the row to be selected when the user clicks
    on the button. Otherwise, we'd have to implement a click event for the button.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所做，我们实现了表格单元格的回收利用，并为每个好友的标签设置了文本。我们使用`cell.AccessoryView`来提示用户每个单元格都是可点击的，并开始新的对话。我们在按钮上禁用了用户交互，以便当用户点击按钮时，可以选中行。否则，我们就必须为按钮实现一个点击事件。
- en: 'Next, we''ll need to modify `FriendsController` in the same way as we did for
    conversations, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照对话的方式修改`FriendsController`，如下所示：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will function exactly the same as the conversations list: the controller
    will load the friends list asynchronously and refresh the table view. If you compile
    and run the application, you''ll be able to navigate to the screen and view the
    sample friends list we created in [Chapter 4](part0039.xhtml#aid-1565U1 "Chapter 4. XamSnap
    - A Cross-Platform App"), *XamSnap - A Cross-Platform App*, as shown in the following
    screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将和对话列表完全一样：控制器将异步加载朋友列表并刷新表格视图。如果你编译并运行应用程序，你将能够导航到屏幕并查看我们在[第4章](part0039.xhtml#aid-1565U1
    "第4章. XamSnap - 跨平台应用程序")，*XamSnap - 跨平台应用程序*中创建的示例朋友列表，如下截图所示：
- en: '![Adding a friends list screen](img/image00226.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![添加朋友列表屏幕](img/image00226.jpeg)'
- en: Adding a list of messages
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加消息列表
- en: Now let's implement the screen to view a conversation or list of messages. We
    will try to model the screen on the built-in text message application in iOS.
    To do so, we will also cover the basics of how to create custom table view cells.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现查看对话或消息列表的屏幕。我们将尝试模仿iOS内置的短信应用程序的屏幕。为此，我们还将介绍如何创建自定义表格视图单元格的基础知识。
- en: 'To start, we''ll need a new `MessagesController` class; perform the following
    steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的`MessagesController`类；执行以下步骤：
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Main.storyboard`文件，在iOS设计师中打开它。
- en: Add a new **Table View Controller** to the storyboard.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向故事板中添加一个新的**表格视图控制器**。
- en: Select your view controller, click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，点击**属性**窗格，确保你选择了**小部件**标签。
- en: Enter `MessagesController` into the **Class** field.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`MessagesController`。
- en: Scroll down to the **View Controller** section and enter `Messages` in the **Title**
    field.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**视图控制器**部分，在**标题**字段中输入`Messages`。
- en: Create a segue from `ConversationsController` to `MessagesController` by holding
    ***Ctrl*** and dragging the blue line from one controller to the other.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住***Ctrl***并将蓝色线条从`ConversationsController`拖到`MessagesController`，创建一个segue。
- en: Select the **Show** segue from the pop up that appears. Enter the **Identifier**
    `OnConversation` in the **Properties** pane.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的菜单中选择**显示**segue。在**属性**窗格中输入**标识符** `OnConversation`。
- en: Now create two **Table View Cells** in the table view in `MessagesController`.
    You may reuse the existing blank one created by default.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`MessagesController`中的表格视图中创建两个**表格视图单元格**。你可以重复使用默认创建的现有空白单元格。
- en: Change the **Style** field to **Basic** for each cell.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个单元格的**样式**字段更改为**Basic**。
- en: Set the **Identifier** to `MyCell` and `TheirCell`, respectively, for each cell.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别为每个单元格将**标识符**设置为`MyCell`和`TheirCell`。
- en: Save the storyboard file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'Xamarin Studio will generate `MessagesController.cs`. Just as before, you can
    move the controller to a `Controllers` folder. Now open `MessagesController.cs`
    and implement `UITableViewSource` inside a nested class, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio将生成`MessagesController.cs`。和之前一样，你可以将控制器移动到`Controllers`文件夹中。现在打开`MessagesController.cs`，并在嵌套类中实现`UITableViewSource`，如下所示：
- en: '[PRE9]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We added some logic to check if a message is from a current user to decide on
    the appropriate table cell identifier. Since we used the **Basic** style for both
    cells, we can use the `TextLabel` property on the cell to set the text for a `UILabel`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些逻辑，以检查消息是否来自当前用户，以决定适当的表格单元格标识符。由于我们为两个单元格都使用了**Basic**样式，我们可以使用单元格上的`TextLabel`属性来设置`UILabel`的文本。
- en: 'Now let''s make the required changes to our `MessagesController`, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`MessagesController`进行必要的更改，如下所示：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only new thing here is where we set the `Title` property to the username
    of the conversation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一新事物是我们将`Title`属性设置为对话的用户名。
- en: 'To complete our custom cells, we will need to make more changes in Xcode by
    performing the following steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的自定义单元格，我们还需要在Xcode中进行以下步骤进行更多更改：
- en: Double-click on the `Main.storyboard` file to open it in the iOS designer.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Main.storyboard`文件，在iOS设计师中打开它。
- en: Select a **Label** by clicking on the default text, **Title**, on either cell.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击默认文本**Title**，选择一个**标签**。
- en: Use some creativity to style both labels. I chose to make the text in `MyCell`
    blue and `TheirCell` green. I set **Alignment** on the label to right aligned
    in `TheirCell`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创造性地为两个标签设置样式。我选择使`MyCell`中的文本为蓝色，`TheirCell`为绿色。我将`TheirCell`中的标签**对齐**设置为右对齐。
- en: Save the storyboard file and return.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件并返回。
- en: 'Next, we need to update the `ConversationsController` to navigate to this new
    screen. Let''s modify the `TableSource` class inside `ConversationsController.cs`,
    as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`ConversationsController`以导航到这个新屏幕。让我们修改`ConversationsController.cs`中的`TableSource`类，如下所示：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And, of course, you will have to modify one small line in the `ViewDidLoad`
    of the controller:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要在控制器中的`ViewDidLoad`修改一行小代码：
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run the application now, you will be able to view the messages list
    as displayed in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将能够看到如下截图所示的消息列表：
- en: '![Adding a list of messages](img/image00227.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![添加消息列表](img/image00227.jpeg)'
- en: Composing messages
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写消息
- en: For the final piece of our application, we need to implement some custom functionality
    that Apple doesn't provide with their APIs. We need to add a text field with a
    button that appears to be attached to the bottom of the table view. Most of this
    will require writing some simple C# code and wiring up events.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们应用程序的最后一块，我们需要实现一些苹果公司API不提供的自定义功能。我们需要添加一个带有按钮的文本字段，使其看起来附着在表格视图的底部。其中大部分工作需要编写一些简单的C#代码并连接事件。
- en: 'Let''s begin by adding some new member variables to our `MessagesController`
    class, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`MessagesController`类中添加一些新的成员变量，如下所示：
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will place the text field and bar buttons inside the toolbar, as in the
    following code in `ViewDidLoad`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在工具栏中放置文本字段和工具栏按钮，如下面的`ViewDidLoad`中的代码所示：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much of this work is a basic UI setup. It is not something we can do inside
    Xcode because it is a very specific use case. We create a text field, bar button
    item, and toolbar from C#, and add them as a footer to our `UITableView`. This
    will display the toolbar at the bottom of the table view, below any rows we defined
    earlier.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作大部分是基本的UI设置。这不是我们在Xcode中能做的事情，因为这是一个非常特定的用例。我们从C#创建文本字段、工具栏按钮项，并将它们作为`UITableView`的页脚添加。这将使工具栏显示在我们之前定义的任何行下面的表格视图底部。
- en: 'Now we will need to modify `ViewWillAppear`, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要按照以下方式修改`ViewWillAppear`：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We need to subscribe to `IsBusyChanged` in order to show and hide the spinner.
    We also call `BecomeFirstResponder`, so the keyboard will appear and give focus
    to our text field.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要订阅`IsBusyChanged`以显示和隐藏加载指示器。同时我们调用`BecomeFirstResponder`，这样键盘就会出现并将焦点给予我们的文本字段。
- en: 'So let''s add an override for `ViewWillDisapper` to clean up the event, as
    follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`ViewWillDisapper`添加一个重写方法，以清理事件，如下所示：
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s set up our method for `IsBusyChanged`, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们为`IsBusyChanged`设置方法，如下所示：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`OnIsBusyChanged` is used to disable some of our views while it is loading.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnIsBusyChanged`用于在加载时禁用我们的一些视图。'
- en: 'Last but not least, we need to implement a function for sending a new message,
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们需要实现一个发送新消息的函数，如下所示：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code is also fairly straightforward. After sending the message, we merely
    need to clear out the text field and tell the table view to reload the newly added
    row, as shown in the following screenshot. Using the `async` keyword makes this
    easy.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码同样直接明了。发送消息后，我们只需清空文本字段并告诉表格视图重新加载新添加的行，如下面的截图所示。使用`async`关键字使这变得简单。
- en: '![Composing messages](img/image00228.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![编写消息](img/image00228.jpeg)'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'In this chapter, we covered the basic settings that Apple and Xamarin provide
    for developing iOS applications. This includes the `Info.plist` file and project
    options in Xamarin Studio. We covered `UINavigationController`, the basic building
    block for navigation in iOS applications, and implemented a login screen complete
    with username and password fields. Next, we covered iOS segues and the `UITableView`
    class. We implemented the friends list screen using `UITableView`, and the messages
    list screen, also using `UITableView`. Lastly, we added a custom UI functionality:
    a custom toolbar floating at the bottom of the messages list.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了苹果和Xamarin为开发iOS应用程序提供的基本设置。这包括`Info.plist`文件和Xamarin Studio中的项目选项。我们涵盖了`UINavigationController`，这是iOS应用程序导航的基本构建块，并实现了一个带有用户名和密码字段的登录屏幕。接下来，我们介绍了iOS的segue和`UITableView`类。我们使用`UITableView`实现了好友列表屏幕，以及消息列表屏幕。最后，我们添加了一个自定义UI功能：在消息列表底部的自定义工具栏。
- en: Upon completing this chapter, you will have a partially functional iOS version
    of XamSnap. You will have a deeper understanding of the iOS platform and tools,
    and fairly good knowledge to apply to building your own iOS applications. Take
    it upon yourself to implement the remaining screens that we did not cover in this
    chapter. If you get lost, feel free to review the full sample application included
    with this book.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章节后，你将拥有一个部分功能性的XamSnap的iOS版本。你将对iOS平台和工具有一个更深入的理解，并且拥有足够的知识去开发你自己的iOS应用程序。请自行实现本章未涵盖的其余屏幕。如果你感到困惑，可以随时回顾本书附带的完整示例应用程序。
- en: In the next chapter, we will implement these UIs on Android.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现在Android上的这些用户界面。
