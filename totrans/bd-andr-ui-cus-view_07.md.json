["```kt\npackage com.packt.rrafols.draw; \n\nimport android.content.Context; \nimport android.graphics.Bitmap; \nimport android.graphics.BitmapFactory; \nimport android.graphics.Canvas; \nimport android.graphics.Paint; \nimport android.graphics.Path; \nimport android.graphics.Rect; \nimport android.graphics.Region; \nimport android.util.AttributeSet; \nimport android.view.GestureDetector; \nimport android.view.MotionEvent; \nimport android.view.View; \nimport android.widget.Scroller; \n\npublic class PerformanceExample extends View { \n    private static final String TAG =PerformanceExample.class.\n                                     getName(); \n\n    private static final int BLACK_COLOR = 0xff000000; \n    private static final int WHITE_COLOR = 0xffffffff; \n    private float angle; \n\n    public PerformanceExample(Context context, AttributeSet attributeSet)\n    { \n        super(context, attributeSet); \n\n        angle = 0.f; \n    } \n\n    /** \n     * This is precisely an example of what MUST be avoided. \n     * It is just to exemplify chapter 7\\. \n     * \n     * DO NOT USE. \n     * \n     * @param canvas \n     */ \n    @Override \n    protected void onDraw(Canvas canvas) { \n        Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), \n                        Bitmap.Config.ARGB_8888); \n           Rect rect = new Rect(0, 0, getWidth(), getHeight()); \n           Paint paint = new Paint(); \n           paint.setColor(BLACK_COLOR); \n           paint.setStyle(Paint.Style.FILL); \n           canvas.drawRect(rect, paint); \n           canvas.save(); \n\n           canvas.rotate(angle, getWidth() / 2, getHeight() / 2); \n           canvas.translate((getWidth() - getWidth()/4) / 2, \n                 (getHeight() - getHeight()/4) / 2); \n\n           rect = new Rect(0, 0, getWidth() / 4, getHeight() / 4); \n           paint = new Paint(); \n           paint.setColor(WHITE_COLOR); \n           paint.setStyle(Paint.Style.FILL); \n           canvas.drawBitmap(bitmap, 0, 0, paint); \n           canvas.drawRect(rect, paint); \n           canvas.restore(); \n           invalidate(); \n           bitmap.recycle(); \n           angle += 0.1f; \n       } \n    } \n```", "```kt\nI art : Starting a blocking GC Explicit\nI art : Explicit concurrent mark sweep GC freed 198893(13MB) AllocSpace objects, 30(656KB) LOS objects, 26% free, 43MB/59MB, paused 2.835ms total 313.353ms\nI art : Background partial concurrent mark sweep GC freed 26718(2MB) AllocSpace objects, 1(20KB) LOS objects, 27% free, 43MB/59MB, paused 3.434ms total 291.430ms\n```", "```kt\nprivate static void yuv2rgb(int width, int height, byte[] yuvData,\n    int[] rgbData) { \n    int uvOffset = width * height; \n    for (int i = 0; i < height; i++) { \n         int u = 0; \n         int v = 0; \n         for (int j = 0; j < width; j++) { \n           int y = yuvData[i * width + j]; \n           if (y < 0) y += 256; \n\n           if (j % 2 == 0) { \n               u = yuvData[uvOffset++]; \n               v = yuvData[uvOffset++]; \n            } \n\n            if (u < 0) u += 256; \n            if (v < 0) v += 256; \n\n            int nY = y - 16; \n            int nU = u - 128; \n            int nV = v - 128; \n\n            if (nY< 0) nY = 0; \n\n            int nR = (int) (1.164 * nY + 2.018 * nU); \n            int nG = (int) (1.164 * nY - 0.813 * nV - 0.391 * nU); \n            int nB = (int) (1.164 * nY + 1.596 * nV); \n\n            nR = min(255, max(0, nR)); \n            nG = min(255, max(0, nG)); \n            nB = min(255, max(0, nB)); \n\n            nR&= 0xff; \n            nG&= 0xff; \n            nB&= 0xff; \n\n            int color = 0xff000000 | (nR<< 16) | (nG<< 8) | nB; \n            rgbData[i * width + j] = color; \n        } \n    } \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    yuv2rgb(imageWidth, imageHeight, yuvData, rgbData); \n    bitmap.setPixels(rgbData, 0, imageWidth, 0, 0, imageWidth,\n    imageHeight); \n\n    canvas.drawBitmap(bitmap, 0.f, 0.f, null); \n\n    frames++; \n    invalidate(); \n} \n```", "```kt\nif (timeStart == -1) { \n    timeStart = SystemClock.elapsedRealtime(); \n} else { \n    long tdiff = SystemClock.elapsedRealtime() - timeStart; \n    if (tdiff != 0) { \n        float fps = ((float) frames * 1000.f) / tdiff; \n        Log.d(TAG, \"FPS: \" + fps); \n    } \n} \n```", "```kt\nprivate static void yuv2rgb(int width, int height, byte[] yuvData,\n    int[] rgbData) { \n    int uvOffset = width * height; \n    int offset = 0; \n    for (int i = 0; i < height; i++) { \n        int u = 0; \n        int v = 0; \n        for (int j = 0; j < width; j++) { \n            int y = yuvData[offset]; \n            ... \n            rgbData[offset] = color; \n\n            offset++; \n        } \n    } \n} \n```", "```kt\nint nR = (int) (1.164 * nY + 2.018 * nU); \nint nG = (int) (1.164 * nY - 0.813 * nV - 0.391 * nU); \nint nB = (int) (1.164 * nY + 1.596 * nV); \n```", "```kt\nint nR = (int) (1192 * nY + 2066 * nU); \nint nG = (int) (1192 * nY - 833 * nV - 400 * nU); \nint nB = (int) (1192 * nY + 1634 * nV); \n```", "```kt\nnR = min(255, max(0, nR)); \nnG = min(255, max(0, nG)); \nnB = min(255, max(0, nB)); \n```", "```kt\nnR = min(255 << 10, max(0, nR)); \nnG = min(255 << 10, max(0, nG)); \nnB = min(255 << 10, max(0, nB)); \n```", "```kt\nnR>>= 10; \nnG>>= 10; \nnB>>= 10; \n```", "```kt\nint nR = (int) (1192 * nY + 2066 * nU); \nint nG = (int) (1192 * nY - 833 * nV - 400 * nU); \nint nB = (int) (1192 * nY + 1634 * nV); \n```", "```kt\nint luminance = 1192 * nY; \nint nR = (int)(luminance + 2066 * nU); \nint nG = (int)(luminance - 833 * nV - 400 * nU); \nint nB = (int)(luminance + 1634 * nV); \n```", "```kt\nfor(int j = 0; j < width; j += 2) {\n   int y0 = yuvData[offset]; \n   if (y0 < 0) y0 += 256; \n\n   int y1 = yuvData[offset + 1]; \n   if (y1 < 0) y1 += 256; \n\n   u = yuvData[uvOffset++]; \n   v = yuvData[uvOffset++]; \n   if (u < 0) u += 256; \n   if (v < 0) v += 256; \n\n   int nY0 = y0 - 16; \n   int nY1 = y1 - 16; \n   int nU = u - 128; \n   int nV = v - 128; \n\n   if (nY0 < 0) nY0 = 0; \n   if (nY1 < 0) nY1 = 0; \n\n   int chromaR = 2066 * nU; \n   int chromaG = -833 * nV - 400 * nU; \n   int chromaB = 1634 * nV; \n\n   int luminance = 1192 * nY0; \n   int nR = (int) (luminance + chromaR); \n   int nG = (int) (luminance + chromaG); \n   int nB = (int) (luminance + chromaB); \n\n   nR = min(255 << 10, max(0, nR)); \n   nG = min(255 << 10, max(0, nG)); \n   nB = min(255 << 10, max(0, nB)); \n\n   nR>>= 10; \n   nG>>= 10; \n   nB>>= 10; \n\n   nR&= 0xff; \n   nG&= 0xff; \n   nB&= 0xff; \n\n   rgbData[offset] = 0xff000000 | (nR<< 16) | (nG<< 8) | nB; \n\n   luminance = 1192 * nY1; \n   nR = (int) (luminance + chromaR); \n   nG = (int) (luminance + chromaG); \n   nB = (int) (luminance + chromaB); \n\n   nR = min(255 << 10, max(0, nR)); \n   nG = min(255 << 10, max(0, nG)); \n   nB = min(255 << 10, max(0, nB)); \n\n   nR>>= 10; \n   nG>>= 10; \n   nB>>= 10; \n\n   nR&= 0xff; \n   nG&= 0xff; \n   nB&= 0xff; \n\n   rgbData[offset + 1] = 0xff000000 | (nR<< 16) | (nG<< 8) | nB; \n\n   offset += 2; \n} \n```", "```kt\nfor (int i = 0; i < height; i++) { \n    for (int j = 0; j < width; j += 2) { \n      int y0 = yuvData[offset    ] & 0xff; \n      int y1 = yuvData[offset + 1] & 0xff; \n\n      int u = yuvData[uvOffset++] & 0xff; \n      int v = yuvData[uvOffset++] & 0xff; \n\n        ... \n   } \n} \n```", "```kt\nfor (int i = 0; i < height; i++) { \n  for (int j = 0; j < width; j += 2) { \n        ... \n    int chromaR = 517 * nU; \n    int chromaG = -208 * nV - 100 * nU; \n    int chromaB = 409 * nV; \n\n    int lum = 298 * nY0; \n\n    nR = min(65280, max(0, nR)); \n    nG = min(65280, max(0, nG)); \n    nB = min(65280, max(0, nB)); \n\n    nR<<= 8; \n    nB>>= 8; \n\n    nR&= 0x00ff0000; \n    nG&= 0x0000ff00; \n    nB&= 0x000000ff; \n\n    rgbData[offset] = 0xff000000 | nR | nG | nB; \n\n        ... \n\n    offset += 2; \n   } \n} \n```", "```kt\nprivate static int[] luminance; \nprivate static int[] chromaR; \nprivate static int[] chromaGU; \nprivate static int[] chromaGV; \nprivate static int[] chromaB; \n\nprivate static int[] clipValuesR; \nprivate static int[] clipValuesG; \nprivate static int[] clipValuesB; \n\nprivate static void precalcTables() {\n    luminance = new int[256];\n    for (int i = 0; i <luminance.length; i++) {\n        luminance[i] = ((298 * (i - 16)) >> 8) + 300;\n    }\n    chromaR = new int[256]; \n    chromaGU = new int[256]; \n    chromaGV = new int[256]; \n    chromaB = new int[256]; \n    for (int i = 0; i < 256; i++) {\n       chromaR[i] = (517 * (i - 128)) >> 8;\n       chromaGU[i] = (-100 * (i - 128)) >> 8;\n       chromaGV[i] = (-208 * (i - 128)) >> 8;\n       chromaB[i] = (409 * (i - 128)) >> 8;\n    }\n\n    clipValuesR = new int[1024]; \n    clipValuesG = new int[1024]; \n    clipValuesB = new int[1024]; \n    for (int i = 0; i < 1024; i++) { \n       clipValuesR[i] = 0xFF000000 | (min(max(i - 300, 0), 255) << 16); \n       clipValuesG[i] = min(max(i - 300, 0), 255) << 8; \n       clipValuesB[i] = min(max(i - 300, 0), 255); \n    } \n} \n```", "```kt\nprivate static void yuv2rgb(int width, int height, byte[] yuvData,\n    int[] rgbData) { \n    int uvOffset = width * height; \n    int offset = 0; \n\n    for (int i = 0; i < height; i++) { \n        for (int j = 0; j < width; j += 2) { \n        int y0 = yuvData[offset ] & 0xff; \n        int y1 = yuvData[offset + 1] & 0xff; \n\n        int u = yuvData[uvOffset++] & 0xff; \n        int v = yuvData[uvOffset++] & 0xff; \n\n        int chR = chromaR[u]; \n        int chG = chromaGV[v] + chromaGU[u]; \n        int chB = chromaB[v]; \n\n        int lum = luminance[y0]; \n        int nR = clipValuesR[lum + chR]; \n        int nG = clipValuesG[lum + chG]; \n        int nB = clipValuesB[lum + chB]; \n\n        rgbData[offset] = nR | nG | nB; \n\n        lum = luminance[y1]; \n        nR = clipValuesR[lum + chR]; \n        nG = clipValuesG[lum + chG]; \n        nB = clipValuesB[lum + chB]; \n\n        rgbData[offset + 1] = nR | nG | nB; \n\n        offset += 2; \n       } \n    } \n} \n```"]