- en: Chapter 5. Discovering Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 探索持续集成
- en: '**Continuous** **integration** is one agile technique for software engineering
    that aims to improve software quality and reduce the time taken to integrate changes
    by continuously applying integration and testing frequently, as opposed to the
    more traditional approach of integrating and testing at the end of the development
    cycle.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**是软件工程中的一种敏捷技术，旨在通过持续的应用集成和频繁的测试，而不是在开发周期结束时采用更传统的集成和测试方法，来提高软件质量并减少集成更改所需的时间。'
- en: Continuous integration has received a broad adoption, and a proliferation of
    commercial tools and open source projects is a clear demonstration of its success.
    That is not very difficult to understand, as anybody who during their professional
    career has participated in a software development project using a traditional
    approach is very likely to have experienced the so-called *integration hell*,
    where the time it takes to integrate the changes exceeds the time it took to make
    the changes. Does this remind you of anything?On the contrary, continuous integration
    is the practice of integrating changes frequently and in small steps. These steps
    are negligible and, if an error is noticed, it is so small that it can be fixed
    immediately. The most common practice is to trigger the build process after every
    commit to the source code repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成已经得到了广泛的应用，商业工具和开源项目的激增是其成功的明显证明。这不难理解，因为任何在职业生涯中参与过使用传统方法的软件开发项目的人都可能经历过所谓的*集成地狱*，即集成更改所需的时间超过了做出更改的时间。这让你想起了什么？相反，持续集成是频繁且小步骤集成更改的做法。这些步骤是微不足道的，如果注意到错误，它如此之小以至于可以立即修复。最常见的做法是在每次提交到源代码仓库后触发构建过程。
- en: 'This practice also implies other requirements, beside the source code being
    maintained by a version control system (VCS):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实践还意味着除了源代码需要由版本控制系统（VCS）维护之外的其他要求：
- en: Builds should be automated by running a single command. This feature has been
    supported for a very long time by tools such as `make` and `ant`, and more recently
    by `maven` and `gradle`.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应当通过运行单个命令来自动化。这个特性已经被如`make`和`ant`这样的工具支持了很长时间，并且最近也被`maven`和`gradle`支持。
- en: Builds should be self-testing to confirm that the newly built software meets
    the expectations of the developers.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应当自我测试，以确认新构建的软件符合开发者的预期。
- en: Build artifacts and results of the tests should be easy to find and view.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工件和测试结果应当易于查找和查看。
- en: When we write tests for our Android projects, we would like to take advantage
    of continuous integration. To achieve this, we want to create a model that coexists
    with the traditional IDE environment and Android build tools, so we can run and
    install our app no matter the environment such as CI box, IDE or manually.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为 Android 项目编写测试时，我们希望利用持续集成。为了实现这一点，我们想要创建一个与传统 IDE 环境和 Android 构建工具共存模型，这样无论在
    CI 环境箱、IDE 还是在手动环境下，我们都能运行和安装我们的应用。
- en: 'In this chapter, we are going to discuss:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Automating the build process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化构建过程
- en: Introducing version control systems to the process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入版本控制系统到流程中
- en: Continuous integration with Jenkins
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 进行持续集成
- en: Automating tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: After this chapter, you will be able to apply continuous integration to your
    own project no matter its size, whether it is a medium or large software project
    employing dozens of developers or it is just you programming solo.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将能够将持续集成应用到你的项目中，无论项目规模大小，无论是雇佣数十名开发人员的中大型软件项目，还是你一个人编程。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original article on continuous integration was written by Martin Fowler
    back in 2000 ([http://www.martinfowler.com/articles/continuousIntegration.html](http://www.martinfowler.com/articles/continuousIntegration.html)),
    and describes the experience of putting together continuous integration on a large
    software project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于持续集成的原始文章是由 Martin Fowler 在 2000 年撰写的（[http://www.martinfowler.com/articles/continuousIntegration.html](http://www.martinfowler.com/articles/continuousIntegration.html)），描述了在一个大型软件项目上实施持续集成的经验。
- en: Building Android applications manually using Gradle
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gradle 手动构建 Android 应用程序
- en: If we aim to incorporate **continuous** **integration** into our development
    process, the first step will be to build Android applications manually, as we
    can combine an integration machine with the manual building technique to automate
    the procedure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是将在开发过程中整合**持续**的**集成**，那么第一步将是手动构建Android应用程序，因为我们可以将集成机器与手动构建技术相结合来自动化这一过程。
- en: In doing this, we intend to keep our project compatible with the IDE and command-line
    building process, and this is what we are going to do. Automated building is a
    great advantage and speeds up the development process by building and eventually
    showing the errors that may exist in your project immediately. When editing resources
    or other files that generate intermediate classes, a CI is an invaluable tool;
    otherwise, some simple errors would be discovered too late in the building process.
    Following the mantra of fail often, fail fast is a recommended practice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们打算保持项目与IDE和命令行构建过程兼容，这就是我们将要做的。自动化构建是一个很大的优势，它通过立即构建并最终显示项目中可能存在的错误，从而加快开发过程。在编辑生成中间类的资源或其他文件时，CI是一个无价的工具；否则，在构建过程中一些简单的错误可能会发现得太晚。遵循“经常失败，快速失败”的格言是推荐的做法。
- en: Fortunately, Android supports manual building with the existing tools and not
    much effort is needed to merge manual IDE builds and automatic CI builds in the
    same project. In such cases, building manually inside your IDE with Gradle is
    supported. However, other options such as Ant exist too that are no longer supported
    by default, and Maven or Make that are not supported out of the box.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android支持使用现有工具进行手动构建，并且在同一项目中合并手动IDE构建和自动CI构建并不需要太多努力。在这种情况下，支持在IDE中使用Gradle手动构建。然而，像Ant这样不再默认支持的选项，以及Maven或Make等不支持开箱即用的选项也存在。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Gradle is build automation evolved. Gradle combines the power and flexibility
    of Ant with the dependency management and conventions of Maven into a more effective
    way to build.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle是构建自动化的演进。Gradle将Ant的强大和灵活性以及Maven的依赖管理和约定融合成更有效的构建方式。
- en: More information can be found at its home page, [http://gradle.org/](http://gradle.org/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在其主页上找到，[http://gradle.org/](http://gradle.org/)。
- en: At the time of writing, projects based on Android Gradle require at least Gradle
    2.2 or newer versions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，基于Android Gradle的项目至少需要Gradle 2.2或更新版本。
- en: It is worth noting here that the entire Android open source project is not built
    by Gradle but built by an incredibly complex structure of make files, and this
    method is used even to build the applications that are included by the platform
    such as Calculator, Contacts, Settings, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，整个Android开源项目并非由Gradle构建，而是由极其复杂的make文件结构构建，这种方法甚至用于构建平台中包含的应用程序，如计算器、联系人、设置等。
- en: 'When creating a new project with Android Studio, the template project will
    already be being built with Gradle. This means you can already build the project
    manually from the command line. Executing `./gradlew tasks` from the base of your
    project will give you a full list of tasks that can be run. The most commonly
    used tasks are as shown in the following table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android Studio创建新项目时，模板项目已经使用Gradle进行构建。这意味着你从命令行手动构建项目。在项目根目录执行 `./gradlew
    tasks` 将提供可以运行的所有任务列表。最常用的任务如下表所示：
- en: '| Target | Description |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | 描述 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `build` | Assembles and tests this project |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `build` | 组装并测试此项目 |'
- en: '| `clean` | Deletes the build directory |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `clean` | 删除构建目录 |'
- en: '| `tasks` | Displays the tasks runnable from root project x (some of the displayed
    tasks may belong to subprojects) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `tasks` | 显示可以从根项目x运行的任务（其中一些显示的任务可能属于子项目） |'
- en: '| `installDebug` | Installs the Debug build |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `installDebug` | 安装调试版本 |'
- en: '| `installDebugTest` | Installs the Test build for the Debug build |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `installDebugTest` | 为调试版本安装测试版本 |'
- en: '| `connectedAndroidTest` | Installs and runs the tests for Build debug on connected
    devices |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `connectedAndroidTest` | 在连接的设备上为构建调试安装并运行测试 |'
- en: '| `uninstallDebug` | Uninstalls the Debug build |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `uninstallDebug` | 卸载调试版本 |'
- en: The commands prefixed with `./gradlew` use an installation of Gradle that is
    actually shipped inside your project source code. This is known as the *gradle
    wrapper*. Therefore, you do not need Gradle installed on your local machine! However,
    if you do have Gradle installed locally, all commands using the wrapper can be
    replaced with `./gradle`. If there are several devices or emulators connected
    to the build machine, these commands will run/install on them all. This is great
    for our CI setup, meaning we can run our tests on all the provided devices so
    that we can handle a number of configurations and Android versions. If you do
    want to install on just one for some other reason, this is possible through the
    Device Providers API but is out of the scope of this book. I encourage you to
    read more at [http://tools.android.com](http://tools.android.com) and also check
    out the wide range of Gradle plugins available to help you with this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀为 `./gradlew` 的命令使用的是实际上包含在项目源代码中的 Gradle 安装。这称为 *gradle 包装器*。因此，你不需要在本地机器上安装
    Gradle！但是，如果你在本地安装了 Gradle，所有使用包装器的命令都可以替换为 `./gradle`。如果有多台设备或模拟器连接到构建机器，这些命令将在它们上面全部运行/安装。这对于我们的
    CI 设置来说非常棒，意味着我们可以在所有提供的设备上运行我们的测试，以便处理多种配置和 Android 版本。如果你出于其他原因只想在其中一个上安装，通过设备提供商
    API 是可以实现的，但这超出了本书的范围。我鼓励你在 [http://tools.android.com](http://tools.android.com)
    阅读更多内容，并查看广泛可用的 Gradle 插件，以帮助你完成这些工作。
- en: 'Now we can run this command to install our application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行这个命令来安装我们的应用程序：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the start and end of the output generated:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的输出开始和结束的部分：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running the preceding command mentioned, the following steps are executed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述提到的命令后，将执行以下步骤：
- en: Compilation of the sources, including resource, AIDL, and Java files
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译源代码，包括资源、AIDL 和 Java 文件
- en: Conversion of the compiled files into the native Android format
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编译的文件转换为原生的 Android 格式
- en: Package creation and signing
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和签名
- en: Installation onto the given device or emulator
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装到给定的设备或模拟器上
- en: 'Once we have the APK installed, and because we are now doing everything from
    the command line, we can even start an Activity such as `EspressoActivity`. Using
    the `am` `start` command and an Intent using the `MAIN` action and the Activity
    we are interested to launch as the component, we can create a command line as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了 APK，并且现在所有操作都从命令行进行，我们甚至可以启动如 `EspressoActivity` 的活动。使用 `am` `start`
    命令和一个使用 `MAIN` 动作和我们感兴趣启动的活动作为组件的 Intent，我们可以创建如下命令行：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Activity is started as you can verify in the emulator. Now the next thing
    to do would be to install the test project for our application, and then use the
    command line to run these tests (as discussed in previous chapters). Finally,
    when they are completed, we should uninstall the application. If you read the
    command list carefully, you may have noticed that luckily this has been done for
    us with the `connectedAndroidTest` Gradle task.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 活动已经启动，你可以在模拟器中验证。现在要做的下一件事是安装我们应用程序的测试项目，然后使用命令行运行这些测试（如前几章所述）。最后，当它们完成后，我们应该卸载应用程序。如果你仔细阅读了命令列表，可能会注意到幸运的是，`connectedAndroidTest`
    Gradle 任务已经为我们完成了这些操作。
- en: 'After running the command, we will obtain the tests results. If they pass,
    the output is simply as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们将获得测试结果。如果通过，输出如下所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However if they fail, the output is more detailed and a link to the file where
    you can see the full stack trace and the reasons why each test failed is presented:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果它们失败了，输出将更加详细，并提供一个链接到文件，你可以查看完整的堆栈跟踪以及每个测试失败的原因：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have done everything from the command line by just invoking some simple commands,
    which is what we were looking for in order to feed this into a continuous integration
    process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用一些简单的命令从命令行完成了一切操作，这正是我们想要做的，以便将这个过程引入持续集成流程。
- en: Git – the fast version control system
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git – 快速版本控制系统
- en: '**Git** is a free and open source, distributed version control system designed
    to handle everything from small to very large projects with speed and efficiency.
    It is very simple to set up so I strongly recommend its use even for personal
    projects. There is no project simple enough that could not benefit from the application
    of this tool. You can find information and downloads at http://git-scm.com/.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git** 是一个免费且开源的分布式版本控制系统，旨在以速度和效率处理从小型到非常大型的各种项目。它非常容易设置，因此我强烈建议即使是个人项目也使用它。没有任何一个项目简单到无法从这个工具的应用中受益。你可以在
    http://git-scm.com/ 找到信息和下载。'
- en: A version control system or **VCS** (also known as source code management or
    **SCM**) is an unavoidable element for development projects where more than one
    developer is involved and the best practice even if coding solo. Furthermore,
    even though it is possible to apply continuous integration with no VCS in place
    (as a VCS is not a requisite of CI), it is not a reasonable or recommended practice
    to avoid it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统或**版本控制系统（VCS）**（也称为源代码管理或**SCM**）是涉及多个开发人员开发项目的不可避免元素，即使单人编码也是最佳实践。此外，尽管在没有VCS的情况下也可以应用持续集成（因为VCS不是CI的必要条件），但避免这样做并不是一个合理或推荐的做法。
- en: Other and probably more traditional (see legacy), options exist in the VCS arena
    such as Subversion or CVS, which you are free to use if you feel more comfortable.
    Otherwise, Git is used extensively by the Android project to host Google's own
    code and examples so it is worth investing some time to at least understand the
    basics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本控制系统领域还有其他一些可能更传统的选择（见遗留系统），如Subversion或CVS，如果你觉得更舒适，可以自由使用。否则，Git被广泛应用于Android项目，托管谷歌自己的代码和示例，因此至少花时间了解基础知识是值得的。
- en: Having said that and remembering that this is a very broad subject to justify
    a book in itself (and certainly there are some good books about it), we are discussing
    here the most basic topics and supplying examples to get you started if you haven't
    embraced this practice yet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，考虑到这是一个非常广泛的主题，足以证明其自身需要一本书（确实有一些好书关于这个主题），我们在这里讨论的是最基本的话题，并提供示例，以帮助那些还没有开始实践的人入门。
- en: Creating a local Git repository
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建本地 Git 仓库
- en: 'These are the simplest possible commands to create a local repository and populate
    it with the initial source code for our projects. In this case we are again using
    the `AndroidApplicationTestingGuide` project created and used in previous chapters.
    We copy the code we used in the previous section, where we built manually:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最简单的命令，用于创建本地仓库并用我们项目的初始源代码填充它。在这个例子中，我们再次使用之前章节创建和使用的 `AndroidApplicationTestingGuide`
    项目。我们复制了之前手动构建时使用的代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create the new project directory, initialize the Git repository, copy the
    initial content, clean and delete our previous autogenerated files, remove the
    `local.properties` file, add everything to the repository, and commit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建新的项目目录，初始化 Git 仓库，复制初始内容，清理并删除我们之前自动生成的文件，移除 `local.properties` 文件，将所有内容添加到仓库，并提交。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `local.properties` file must never be checked in a version control system
    as it contains information specific to your local configuration. You might also
    want to look at creating a `.gitignore` file. This file allows you to define what
    files are not checked in (such as auto-generated files). An example of the `.gitignore`
    file can be found at [https://github.com/github/gitignore](https://github.com/github/gitignore).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`local.properties` 文件绝不能被检入版本控制系统，因为它包含特定于你本地配置的信息。你可能还想看看创建一个 `.gitignore`
    文件。这个文件允许你定义哪些文件不被检入（例如自动生成的文件）。`.gitignore` 文件的示例可以在 [https://github.com/github/gitignore](https://github.com/github/gitignore)
    找到。'
- en: At this point, we have our project repository containing the initial source
    code for our application and all of its tests. We haven't altered the structure
    so the project is still compatible with our IDE and Gradle for when we continue
    developing, locally building, and continuously integrating.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的项目仓库包含了我们应用程序的初始源代码以及所有的测试。我们没有改变结构，所以项目仍然与我们IDE和Gradle兼容，以便我们继续本地开发、构建和持续集成。
- en: The next step is to have our project built and tested automatically every time
    we commit a change to the source code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让我们的项目在我们每次提交源代码更改后自动构建和测试。
- en: Continuous integration with Jenkins
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 进行持续集成
- en: '**Jenkins** is an open source, extensible continuous integration server that
    has the ability to build and test software projects or monitor the execution of
    external jobs. Jenkins is easy to install and configure, and is thus widely used.
    That makes it ideal as an example to learn continuous integration.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jenkins** 是一款开源、可扩展的持续集成服务器，具有构建和测试软件项目或监控外部作业执行的能力。Jenkins 安装和配置简单，因此被广泛使用。这使得它成为学习持续集成的理想示例。'
- en: Installing and configuring Jenkins
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Jenkins
- en: We mentioned easy installation as one of the advantages of Jenkins and installation
    could not be any easier. Download the native package for the operating system
    of your choice from [http://jenkins-ci.org/](http://jenkins-ci.org/). There are
    native packages for all major server and desktop operating systems. In the following
    examples, we will be using version 1.592\. We will run the `.war` file after downloading
    it, since it does not require administrative privileges to do so.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到 Jenkins 的优点之一是易于安装，而且安装过程确实简单。从 [http://jenkins-ci.org/](http://jenkins-ci.org/)
    下载你选择操作系统的原生包。所有主要的服务器和桌面操作系统都有原生包。在以下示例中，我们将使用版本 1.592。下载 `.war` 文件后，我们将运行它，因为这不需要管理员权限。
- en: 'Once finished, copy the war into a selected directory, `~/jenkins`, and then
    run the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将 war 文件复制到选择的目录 `~/jenkins`，然后运行以下命令：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This expands and starts Jenkins.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将展开并启动 Jenkins。
- en: The default configuration uses port `8080` as the HTTP listener port, so pointing
    your browser of choice to `http://localhost:8080` should present you with the
    Jenkins home page. You can verify and change Jenkins' operating parameter if required,
    by accessing the **Manage** **Jenkins** screen. We should add to this configuration
    the plugins needed for Git integration, building with Gradle, checking test results,
    and support for Android emulator during builds. These plugins are named **Git
    plugin**, **Gradle plugin**, **JUnit plugin**, and **Android Emulator plugin**,
    respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置使用 `8080` 端口作为 HTTP 监听端口，因此将你的浏览器指向 `http://localhost:8080` 应该会显示 Jenkins
    主页。如果需要，你可以通过访问 **管理 Jenkins** 屏幕来验证和更改 Jenkins 的操作参数。我们应该在此配置中添加所需的插件，以实现 Git
    集成、使用 Gradle 构建、检查测试结果以及在构建过程中支持 Android 模拟器。这些插件分别是 **Git 插件**、**Gradle 插件**、**JUnit
    插件** 和 **Android Emulator 插件**。
- en: 'This following screenshot displays the information you can obtain about the
    plugins following the link available on the Jenkins plugin administration page:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图展示了你可以通过 Jenkins 插件管理页面上的链接获取的插件信息：
- en: '![Installing and configuring Jenkins](img/00016.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![安装和配置 Jenkins](img/00016.jpeg)'
- en: After installing and restarting Jenkins, these plugins will be available for
    use. Our next step is to create the jobs necessary to build the projects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并重新启动 Jenkins 后，这些插件就可以使用了。我们的下一步是创建构建项目所需的任务。
- en: Creating the jobs
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建任务
- en: Let's start by creating the AndroidApplicationTestingGuide job using **New Item**
    on the Jenkins home page. Name it after the project. Different kinds of jobs can
    be created; in this case, we select **Freestyle project**, allowing you to connect
    any SCM with any build system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Jenkins 主页上的 **新建项目** 开始创建 AndroidApplicationTestingGuide 任务。以项目命名。可以创建不同类型的任务；在这种情况下，我们选择
    **自由风格项目**，允许你将任何 SCM 连接到任何构建系统。
- en: 'After clicking on the **OK** button, you will be presented with the specific
    job options, which are described in the following table. This is at the top of
    the job properties'' page as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **确定** 按钮后，你将看到具体的任务选项，如下表所述。这是任务属性页面顶部的如下内容：
- en: '![Creating the jobs](img/00017.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![创建任务](img/00017.jpeg)'
- en: 'All of the options in the **New** **Item** screen have a help text associated,
    so here we are only explaining the ones we enter:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**新建项目**屏幕中的所有选项都有关联的帮助文本，因此这里我们只解释需要输入的部分：'
- en: '| Option | Description |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Project name | The name given to the project. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 项目名称 | 给项目赋予的名称。 |'
- en: '| Description | Optional description. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 可选描述。 |'
- en: '| Discard Old Builds | This helps you save on disk consumption by managing
    how long to keep records of the builds (such as console output, build artifacts,
    and so on). |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 丢弃旧构建 | 这可以帮助你通过管理构建记录（如控制台输出、构建工件等）的保留时间来节省磁盘消耗。 |'
- en: '| This build is parameterized | This allows you to configure parameters that
    are passed to the build process to create parameterized builds, for instance,
    using `$ANDROID_HOME` instead of hardcoding a path. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 此构建是参数化的 | 这允许你配置传递给构建过程的参数，以创建参数化构建，例如，使用 `$ANDROID_HOME` 而不是硬编码路径。 |'
- en: '| Source Code ManagementAlso known as VCS, where is the source code for the
    project? In this case, we use Git and a repository where the URL is the absolute
    path of the repository we created earlier. For example, `/git-repo/AndroidApplicationTestingGuide`.
    |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 源代码管理 也称为 VCS，项目的源代码在哪里？在这种情况下，我们使用 Git 和一个仓库，该仓库的 URL 是我们之前创建的仓库的绝对路径。例如，`/git-repo/AndroidApplicationTestingGuide`。
    |'
- en: '| Build Triggers | How this project is automatically built. In this case, we
    want every change in the source code to trigger the automatic build, so we select
    **Poll SCM**.The other option is to use **Build periodically**. This feature is
    primarily to use Jenkins as a `cron` replacement, and it is not ideal to continuously
    build software projects. When people first start continuous integration, they
    are often so used to the idea of regularly scheduled builds such as nightly/weekly
    that they use this feature. However, the point of continuous integration is to
    start a build as soon as a change is made, to provide a quick feedback to the
    change.This option can be used for longer running builds like test suites that
    perhaps test performance when the build runs for 1 hour for example (configure
    it to run at midnight). It also can be used to release new versions, nightly,
    or weekly. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 构建触发器 | 如何自动构建这个项目。在这种情况下，我们希望源代码的每次更改都触发自动构建，所以我们选择**轮询SCM**。另一个选项是使用**定时构建**。这个特性主要用于将Jenkins作为`cron`的替代，对于持续构建软件项目来说并不理想。当人们第一次开始持续集成时，他们常常习惯于定期的构建，如每晚/每周，因此使用这个特性。然而，持续集成的要点是在做出更改后立即开始构建，以便为更改提供快速的反馈。这个选项可以用于长时间运行的构建，比如测试套件，可能在构建运行1小时时测试性能（将其配置为在午夜运行）。它还可以用于每晚或每周发布新版本。
    |'
- en: '| Schedule | This field follows the syntax of `Cron` (with minor differences).
    Specifically, each line consists of five fields separated by TAB or whitespace:`MINUTE
    HOUR DOM MONTH DOW`.For example, if we want to poll continuously at 30 minutes
    past the hour, specify:`30 * * * *`Check the documentation for a complete explanation
    of all the options. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 计划 | 这个字段遵循`Cron`的语法（有一些小的差异）。具体来说，每行由五个由制表符或空格分隔的字段组成：`分钟 小时 天 月 星期几`。例如，如果我们想在每个小时的30分钟进行持续轮询，指定为：`30
    * * * *`。查看文档以获取所有选项的完整解释。 |'
- en: '| Build environment | This option lets you specify different options for the
    build environment and for the Android emulator that may run during the build.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 构建环境 | 这个选项允许你为构建环境和可能在进行构建时运行的Android模拟器指定不同的选项。 |'
- en: '| Build | This option describes the build steps. We select **Invoke Gradle
    script** as we reproduce the steps we did before to manually build and test the
    project.We will select **Use Gradle Wrapper** so that our project doesn''t rely
    on the CI boxes built in the Gradle version.Then, in the **Tasks** box, we want
    to write `clean connectedAndroidTest`. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 构建 | 这个选项描述了构建步骤。我们选择**调用Gradle脚本**，因为我们重现了之前手动构建和测试项目的步骤。我们将选择**使用Gradle包装器**，这样我们的项目就不依赖于内置在Gradle版本的CI机器。然后，在**任务**框中，我们希望输入
    `clean connectedAndroidTest`。 |'
- en: '| Post build actions | These are a series of actions we can do after the build
    is done. We are interested in saving the APKs so we enable **Archive the artifacts**
    and then define the path for them as **Files to archive**; in this precise case,
    it is `**/*-debug.apk`. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 构建后操作 | 这些是在构建完成后我们可以执行的一系列操作。我们希望保存APK文件，因此我们启用**归档工件**，然后定义它们的路径为**要归档的文件**；在这个具体的情况下，它是
    `**/*-debug.apk`。 |'
- en: '| Save | Saves the changes we just made and completes the build job creation.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 保存 | 保存我们刚刚做的更改并完成构建任务创建。 |'
- en: 'Now that our CI build is set up, there are following two options:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的持续集成（CI）构建已经设置好了，有以下两个选项：
- en: You can force a build using **Build** **Now**
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用**立即构建**来强制构建。
- en: Or introduce some changes to the source code, push with Git, and wait for them
    to be detected by our polling strategy
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者对源代码进行一些更改，使用Git提交，并等待它们被我们的轮询策略检测到。
- en: Either way, we will get our project built and our artifacts ready to be used
    for other purposes, such as dependency projects or QA. Unfortunately, if you did
    run the CI build, it would fail spectacularly as there are no devices attached.
    Your choices are, attach a real device or use the Android Emulator plugin that
    we just installed. Let's use the plugin. From Jenkins, go to the job we just created
    and click on **Configure**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都能构建我们的项目，并准备好工件以供其他用途，例如依赖项目或质量保证（QA）。不幸的是，如果你运行了CI构建，它会因为未连接设备而彻底失败。你可以选择连接一个真实设备，或者使用我们刚刚安装的Android模拟器插件。我们使用插件。在Jenkins中，转到我们刚刚创建的任务并点击**配置**。
- en: '| Option | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Build environment | Our intention is to install and run the tests on an emulator.
    So for our build environment, we use the facilities provided by the **Android
    Emulator Plugin**. This comes in handy if you wish to automatically start an Android
    emulator of your choice before the build steps execute, with the emulator being
    stopped after the building is complete.You can choose to start a predefined, existing
    Android emulator instance (AVD).Alternatively, the plugin can automatically create
    a new emulator on the build slave with properties you specify here.In any case,
    the `logcat` output will automatically be captured and archived.Select **Run emulator
    with properties**.Then, select **4.4** for the **Android OS version**, **320**
    DPI for the **Screen density** and **WQVGA** for **Screen resolution**.Feel free
    to experiment and select the options that better suit your needs. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 构建环境 | 我们的目标是在模拟器上安装并运行测试。因此，对于我们的构建环境，我们使用 **Android Emulator 插件** 提供的设施。如果你希望在构建步骤执行之前自动启动你选择的
    Android 模拟器，并在构建完成后停止模拟器，这将非常方便。你可以选择启动预定义的、现有的 Android 模拟器实例（AVD）。或者，插件可以自动在构建从机上创建一个新的模拟器，并在此处指定属性。在任何情况下，`logcat`
    输出都将自动捕获并归档。选择 **使用属性运行模拟器**。然后，选择 **4.4** 作为 **Android OS 版本**，**320** DPI 作为
    **屏幕密度**，以及 **WQVGA** 作为 **屏幕分辨率**。请随意实验并选择更适合你需求的选项。 |'
- en: '| Common emulator options | We would like to **Reset emulator state at start-up**
    to wipe user data and disable **Show emulator window**, so the emulator window
    is not displayed. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 常见模拟器选项 | 我们希望**在启动时重置模拟器状态**以清除用户数据并禁用**显示模拟器窗口**，这样就不会显示模拟器窗口。 |'
- en: After configuring and building this project, we have the APK installed on the
    target emulator and the tests are running.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 配置并构建此项目后，我们将在目标模拟器上安装 APK 并运行测试。
- en: Obtaining Android test results
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 Android 测试结果
- en: Once the tests are run, the results are saved as XML files inside the project's
    build folder at `/AndroidApplicationTestingGuides/app/build/outputs/androidTest-results/connected/`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行后，结果将保存为 XML 文件，位于项目构建文件夹内的 `/AndroidApplicationTestingGuides/app/build/outputs/androidTest-results/connected/`。
- en: They are no good to us there. It would be nice if we could read the results
    of our tests in Jenkins and have them displayed in a nice HTML format; another
    Jenkins plugin to the rescue. JUnit Plugin enables a post build action that asks
    you where your JUnit reports are stored and will then retrieve them for easy viewing
    in the project screen of Jenkins as test results. In this scenario, we use the
    Post-build Actions also in the job configuration's page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在那里对我们没有好处。如果我们能在 Jenkins 中读取我们的测试结果，并以漂亮的 HTML 格式显示它们，那就太好了；另一个 Jenkins 插件来拯救。JUnit
    插件启用了一个构建后操作，询问你的 JUnit 报告存储在哪里，并将它们检索出来，以便在 Jenkins 的项目屏幕上轻松查看测试结果。在这种情况下，我们在作业配置页面也使用了构建后操作。
    |
- en: '| Having done all of the steps previously described, only forcing a build is
    left to see the results. Option | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 完成之前描述的所有步骤后，只剩下强制构建以查看结果。选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Publish JUnit test result report | When this option is configured, the JUnit
    plugin on Jenkins can provide useful information about test results, such as historical
    test result trends, a web UI to view test reports, tracking failures, and so on.It
    requires a regex to look up the JUnit result files. I would recommend `**/TEST*.xml`.
    This regex should match all JUnit test results, including those of the Android
    connected tests; praise in research here goes to Adam Brown. If you change the
    regex, be sure not to include any non-report files into this pattern.Once a few
    builds have run with test results, you should start seeing some trend charts displaying
    the evolution of tests. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 发布 JUnit 测试结果报告 | 当配置了此选项时，Jenkins 上的 JUnit 插件可以提供有关测试结果的实用信息，如历史测试结果趋势、用于查看测试报告的
    Web UI、跟踪失败等。它需要一个正则表达式来查找 JUnit 结果文件。我建议使用 `**/TEST*.xml`。这个正则表达式应该匹配所有的 JUnit
    测试结果，包括 Android 连接测试的结果；这里的研究赞誉归功于 Adam Brown。如果你更改了正则表达式，确保不要将任何非报告文件包含在此模式中。运行几个带有测试结果的构建后，你应该会开始看到一些趋势图表，显示测试的发展演变。
    |'
- en: 'Click on **Build** **Now** and after a few moments, you will see your test
    results and statistics displayed in a similar way as the following screenshot
    depicts:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **立即构建**，几分钟后，你将看到你的测试结果和统计数据以类似以下截图的方式显示：
- en: '![Obtaining Android test results](img/00018.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![获取 Android 测试结果](img/00018.jpeg)'
- en: From here, we can easily understand our project status. Clicking on **Latest
    Test Result** shows you how many tests failed and why. You can search through
    the failed tests and can also find the extensive **Error message** and **Stack
    trace** options.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以轻松了解项目状态。点击**最新测试结果**，你可以看到有多少测试失败以及原因。你可以搜索失败的测试，还可以找到详尽的**错误信息**和**堆栈跟踪**选项。
- en: 'It is also really helpful to understand the evolution of a project through
    the evaluation of different trends and Jenkins is able to provide such information.
    Every project presents the current trends using weather-like icons from sunny,
    when the health of the project increases by 80 percent, and to thunderstorm when
    the health lies below 20 percent. In addition, for every project, the evolution
    of the trend of the tests success versus failure ratio is displayed in a chart.
    A failing test chart is reproduced here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过评估不同的趋势来了解项目的演变也确实很有帮助，而Jenkins能够提供这类信息。每个项目都使用类似天气的图标展示当前趋势，从阳光明媚（项目健康度提高80%）到雷暴（健康度低于20%）。此外，对于每个项目，测试成功与失败比例的趋势演变也会在图表中显示。下面是失败的测试图表：
- en: '![Obtaining Android test results](img/00019.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![获取Android测试结果](img/00019.jpeg)'
- en: In this case, we can see how at build 9, four tests where broken, three where
    fixed in build 10, and the final one in build 11.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到在构建9时，有四个测试失败了，其中三个在构建10中修复，最后一个在构建11中修复。
- en: 'To see how a project status changes by forcing a failure, let''s add a failing
    test such as the following. Don''t forget to push your commit to trigger the CI
    build as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到项目状态如何通过强制失败而改变，让我们添加一个如下所示的失败测试。别忘了推送你的提交，以触发CI构建，如下所示：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Yet another very interesting feature that is worth mentioning is the ability
    of Jenkins to keep and display the timeline and build the time trend, as shown
    in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣且值得一提的功能是Jenkins能够保存和显示时间轴和构建时间趋势，如下面的截图所示：
- en: '![Obtaining Android test results](img/00020.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![获取Android测试结果](img/00020.jpeg)'
- en: This page presents the build history with links to every particular build that
    you can follow to see the details. Now we have less to be worried about and every
    time somebody in the development team commits changes to the repository, we know
    that these changes will be immediately integrated and the whole project will be
    built and tested. If we further configure Jenkins, we can even receive the status
    by e-mail. To achieve this, enable **E-mail Notification** in the job configuration
    page and enter the desired **Recipients**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面展示了带有链接的构建历史，你可以通过这些链接查看每个特定构建的详细信息。现在我们不必担心太多，每当开发团队的成员将变更提交到仓库时，我们知道这些变更将立即集成，整个项目将被构建和测试。如果我们进一步配置Jenkins，我们甚至可以通过电子邮件接收状态。为此，请在作业配置页面启用**电子邮件通知**，并输入所需的**收件人**。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced continuous integration in practice providing valuable
    information to start applying it soon to your projects no matter what their size,
    whether you are developing solo or a part of a big company team.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过实际应用介绍了持续集成的概念，提供了有价值的信息，以便你尽快将其应用到项目中，无论项目规模大小，无论你是独立开发还是大型公司团队的一员。
- en: The techniques presented focus on the particularities of Android projects maintaining
    and supporting widely used development tools such as Android Studio and the Android
    Gradle plugin.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所介绍的技术关注于Android项目的特性，维护并支持广泛使用的开发工具，如Android Studio和Android Gradle插件。
- en: We introduced real-world examples with real-world tools available from the vast
    open source arsenal. We employed Gradle to automate the building process, Git
    to create a simple version control system repository to store our source code
    and manage the changes, and finally, installed and configured Jenkins as the continuous
    integration of choice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了现实世界中的示例和工具，这些工具来自丰富的开源武器库。我们使用Gradle自动化构建过程，使用Git创建一个简单的版本控制系统仓库来存储我们的源代码和管理变更，最后安装并配置了Jenkins作为我们选择的持续集成工具。
- en: Within Jenkins, we detailed the creation of jobs to automate the creation of
    our Android application and its tests, and we emphasized the relationship between
    the continuous integration box and its devices/emulators.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中，我们详细介绍了创建作业的过程，以自动化创建我们的Android应用程序及其测试，并强调了持续集成框与其设备/模拟器之间的关系。
- en: Finally, we became aware of the Android-connected tests results and implemented
    a strategy to obtain an attractive interface to monitor the running of tests,
    their results, and the existing trends.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们意识到了与安卓相关的测试结果，并实施了一项策略，以获得一个吸引人的界面来监视测试的运行、它们的结果和现有的趋势。
- en: The next chapter takes us through the road of Test-driven Development; you'll
    finally start to understand why I keep talking about the temperature in all the
    examples so far with a real-world project. Thus, having a continuous integration
    setup is perfect to empower us to write great code and have faith in our CI built
    APKs being ready to release.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带领我们走上测试驱动开发的道路；你最终将开始理解为什么我在迄今为止的所有示例中都在谈论温度，这对于一个真实的项目来说非常重要。因此，建立持续集成设置非常完美，可以帮助我们编写优秀的代码，并相信我们的持续集成构建的APK已经准备好发布。
