- en: Chapter 11. Debugging and Testing on Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to debug in Android, an essential practice
    to save time in finding and fixing problems while developing our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to create automated tests that can test the click of a button
    or the outcome of a single method. This is a set of tests that you can run in
    Android Studio to ensure that every time you develop a new feature, you don't
    break any of the existent ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to use **Robolectric** for unit tests and Espresso for
    integration tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will discuss how to test the UI with millions
    of random clicks using Monkey, how to record sequences of clicks through the app,
    and how to configure tests based on these recordings with MonkeyTalk.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Logs and the debug mode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests with Robolectric
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests with Espresso
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: UI Testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random clicks with MonkeyRunner
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording clicks with MonkeyTalk
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logs and the debug mode
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We couldn't finish the book without mentioning logs and how to debug to solve
    problems while developing. Developing in Android can be more than just copying
    and pasting from Stack Overflow if you know how to solve your own problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The debug mode and logs are mechanisms used to help the developer identify where
    the problems are. With time, every developer improves and uses these techniques
    less frequently, but at the beginning, it's quite common to have an app full of
    logs. We don't want users to be able to see the log when the app is released,
    and we don't want to remove logs manually and then add them again when we release
    a new version. We will take a look at how to avoid this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Working with logs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The log class is used to print out messages and errors, which we can read in
    real time using `LogCat`. This is an example of how to log a message:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Log` class has five methods, and they are used to have a different level
    of priority on the logs. This allows us to filter by priority in `LogCat`. There
    are situations when we display different logs, for instance, to see the number
    of job offers we download in every request. If we have a crash in our app, logs
    of the type error are our priority at this moment, and we want to hide other logs
    with less priority to find the error as soon as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The five priorities are (from low to high) verbose, debug, information, warning,
    and error. (`Log.v` , `Log.d`, `Log.i`, `Log.w`, and `Log.e`)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We can filter by process with the bar at the top of the logging window. We can
    filter by priority and by keyword, and we can create custom filters by tag, process
    ID, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with logs](img/B04887_11_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: If the logs don't appear or they are old and not refreshing, try to open the
    dropdown to the right, select **No** **filters**, and then select **Show only
    selected application** again. This forces the console to refresh.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with logs](img/B04887_11_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'To finish with logs, we will create a wrapper and use a third-party library
    with the idea to be able to disable all the logs in the project by just changing
    the value of a Boolean. To do this, we simply create a class with the same methods
    of the `Log` class that depend on this Boolean value:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成日志，我们将创建一个包装器，并使用第三方库，以便只需更改布尔值就能在项目中禁用所有日志。为此，我们只需创建一个具有与`Log`类相同方法的类，这些方法依赖于这个布尔值：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to use this wrapper every time we want to write a log—`MyLogger.d()`
    instead of `Log.d()`. This way, if we change the value of the Boolean `LOG` in
    the `MyLogger` class, it will stop all the logs in our project at the same time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次想要编写日志时都需要使用这个包装器——使用`MyLogger.d()`而不是`Log.d()`。这样，如果我们更改`MyLogger`类中的布尔值`LOG`，它将同时停止我们项目中的所有日志。
- en: 'It is recommended to use the value from the `BuildConfing.DEBUG` variable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用`BuildConfing.DEBUG`变量的值：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will be true if our app is in the debug mode, and it will be false when
    we release the app. So, we don't need to remember to turn the logs off in release
    mode, and there is no risk of a log appearing to the final user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用处于调试模式，这将成立，发布应用时将变为假。因此，我们不需要记住在发布模式下关闭日志，也没有日志对最终用户显示的风险。
- en: Using Timber, the log wrapper
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Timber，日志包装器
- en: 'Timber is a log wrapper created by Jake Wharton that takes the log to an advanced
    level, allowing us to have different log behaviors using the log tree concept.
    Take a look at the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Timber是由Jake Wharton创建的日志包装器，它将日志提升到了一个高级水平，允许我们使用日志树概念来拥有不同的日志行为。看看以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One of the advantages of using timber is that we don''t need to write a tag
    in our logs more than once in the same activity:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Timber的优点之一是，我们不需要在同一个活动中多次编写日志标签：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our trees can have different behaviors; for instance, I might want to disable
    logs in the release mode, but I still want to handle errors; so, I will plant
    an error tree that will report the error to Parse:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的树可以有不同的行为；例如，我可能想在发布模式下禁用日志，但我仍然想处理错误；所以，我会种植一个错误树，将错误报告给Parse：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Debugging our app
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试我们的应用
- en: Logs can be used to find problems while developing, but if we master the debug
    mode, we will find this practice much quicker.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可用于开发过程中查找问题，但如果我们掌握了调试模式，会发现这个做法要快得多。
- en: 'While we are in the debug mode, we can set breakpoints in the code. With these
    breakpoints, we specify a line of code where we want the execution to stop to
    show us the values of the variables at that moment. To set a breakpoint, simply
    double-click on the left-hand side bar:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处于调试模式时，可以在代码中设置断点。通过这些断点，我们指定一个代码行，我们希望执行在此处停止，以显示那一刻的变量值。要设置断点，只需在左侧边栏上双击：
- en: '![Debugging our app](img/B04887_11_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![调试我们的应用](img/B04887_11_03.jpg)'
- en: 'We set a debug point in the response of the method that gets the job offer.
    We can launch the debug mode from the top bar:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在获取工作机会的方法的响应中设置了一个调试点。我们可以从顶部栏启动调试模式：
- en: '![Debugging our app](img/B04887_11_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![调试我们的应用](img/B04887_11_04.jpg)'
- en: 'If we run the app in **Debug** mode, Android studio will pause the execution
    when it reaches this point:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在**调试**模式下运行应用，当达到这一点时，Android Studio将暂停执行：
- en: '![Debugging our app](img/B04887_11_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![调试我们的应用](img/B04887_11_05.jpg)'
- en: Android Studio will automatically prompt the **Debugger** window, where we will
    be able to see the variables at the point of execution. We can see in the preceding
    screenshot the job offer list and navigate to see what every offer has inside.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio会自动提示**调试器**窗口，我们可以在执行点查看变量。从前面的截图中，我们可以看到工作机会列表，并导航查看每个机会内部的内容。
- en: The important features here are the green **Play** button to the left, which
    continues the execution of our app until the next breakpoint, and the red square,
    which exits the debug mode and continues with the execution of the app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要特性是左侧的绿色**播放**按钮，它将继续执行我们的应用到下一个断点，以及红色方块，它退出调试模式并继续执行应用。
- en: 'We also have different controls available to move to the next line, into a
    method, or outside the method. For instance, consider that we have a breakpoint
    in the first line of the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有不同的控件可用于转到下一行，进入一个方法，或离开方法。例如，假设我们在以下命令的第一行有一个断点：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, **Step Over**, which is the blue arrow pointing downward, will
    move our execution to the next line. If we click on **Step Into**, the blue arrow
    pointing to the bottom-right corner, we will get into the `getInstace()` method.
    With a combination of these controls, we can control the flow in realtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: With the debug mode explained, we can now move on to automated tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Testing on Android
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new functionality is not complete without being tested first. We, as developers,
    have fallen many times into the trap of submitting code changes without writing
    a passing test first, only to find that the expected behavior was broken on future
    iterations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We learned the hard way that writing tests boosts our productivity, increases
    code quality, and helps us release more often. For this reason, Android provided
    several tools to help us test our apps from the early stages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In the following two sections, we will talk about my favorite setup, Robolectric
    for unit testing and Espresso for integration testing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests with Robolectric
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until Robolectric, writing unit tests meant that we had to run them on a real
    device or an emulator. This process could take several minutes as Android build
    tools have to package the testing code, push it to the connected device, and then
    run it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Robolectric alleviates this problem by enabling us to run our unit tests in
    the JVM of our workstation without the need for an Android device or emulator.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'To include Robolectric using Gradle, we can add the following dependency to
    our `build.gradle` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use `testCompile` to specify that we want this dependency to be included
    in our test project. For the test project, the default source directory is `src/test`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Robolectric configuration
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing, Robolectric version 3.0 supports the following Android
    SDKs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Jelly Bean, SDK version 16
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jelly Bean MR1, SDK version 17
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jelly Bean MR2, SDK version 18
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KitKat, SDK version 19
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lollipop, SDK version 21
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the tests will run against `targetSdkVersion` defined in the `AndroidManifest`
    file. If you want to run the tests against a different SDK version or if your
    current `targetSdkVersion` is not supported by Robolectric, you can override it
    manually using a properties file located at `src/test/resources/robolectric.properties`
    with the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our first unit test
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll begin by setting up a very simple and common scenario: a welcoming activity
    with a **Login** button that navigates the user to a login activity. The layout
    for the welcome activity is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On the `WelcomeActivity` class, we''ll simply set the login button to start
    the login activity:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to test this, we can ensure that we start `LoginActivity` by sending
    the correct `Intent`. Because Robolectric is a unit-testing framework, `LoginActivity`
    will not actually be started, but we'll be able to check whether the framework
    captured the correct intent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create the test file, `WelcomeActivityTest.java`, in the correct
    package within the `src/test/java/` path. Robolectric depends on JUnit 4, so we
    will start by specifying Robolectric''s Gradle test runner and some extra configuration
    that the framework will use to find the `AndroidManifest` resources and assets.
    Run the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can write our first test. We''ll begin by creating and bringing the
    welcome activity to the foreground:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have an instance of `WelcomeActivity`, it''s easy to click on the
    login button:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we have to verify that the framework captured the intent that would
    have started `LoginActivity`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `shadowOf` static method returns a `ShadowActivity` object that stores
    most of the interactions with the current activity under test. We need to use
    the `@Test` annotation, which tells JUnit that the method can be run as a test
    case. Putting everything together, we have the following test class (`WelcomeActivityTest.java`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running unit tests
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before being able to run the unit tests, we need to select the correct **Test
    Artifact** in Android Studio. To do so, we will open the **Build Variants** toolbar
    and select the **Unit Tests** artifact, as displayed in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests](img/B04887_11_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Now, from the **Project** window, we can run the tests by right-clicking on
    the test classes and selecting the **Run** option. Ensure that there are no spaces
    in the project path; otherwise, Robolectric will throw an exception prior to execution
    of the unit tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests](img/B04887_11_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'We can also run unit tests from the command line. To do so, call the `test`
    task command with the `--continue` option:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This option is ideal if we have a continuous integration system configured,
    such as Jenkins, Travis, or wercker.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of the Robolectric section. Next, we'll discuss integration
    testing with **Espresso**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests with Espresso
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the very nature of Android and the vast amount of devices out there,
    we can never be certain of how the app might behave when we release it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We naturally tend to manually test our app on as many different devices as possible,
    which is a tedious process that we have to repeat on every release that we do.
    In this section, we'll briefly discuss Espresso and how we can write tests that
    will run on a real device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Espresso configuration
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before writing our first integration test, we need to install and configure
    our test environment. Perform the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: From Android SDK Manager, we need to select and install **Android Support Repository**
    from the **Extras** folder, as shown in the following screenshot:![Espresso configuration](img/B04887_11_08.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the folder for our integration tests code; this should be located at
    `app/src/androidTest`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll also need to specify a few dependencies in the project''s `build.gradle`.
    Use the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Recently, Android added support for JUnit 4 style test cases. To use this,
    we''ll add `AndroidJUnitRunner` as the default test instrumentation runner in
    the `build.gradle` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Writing an integration test
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this example, we''ll continue from where we left off with Robolectric;
    we''ll write a test for `LoginActivity`. For this activity, we''ll set a simple
    layout with two `EditTexts` and a sign-in button. Run the following code (`activity_login.xml`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `LoginActivity`, when the user clicks on the sign-in button, we''ll send
    the credentials to the splash activity using the following code (`LoginActivity.java`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this test, we'll type the user credentials in the two input fields and verify
    that we bundle them correctly in the intent.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create the `LoginActivityTest.java` test file in the correct
    package within the `src/test/androidTest/` path. We''ll use JUnit 4, so we will
    start by specifying the `AndroidJUnit4` test runner. Use the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another distinction to Robolectric is that in Espresso, we need to specify
    a rule that will prepare the activity under test. For this, use the following
    command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can start writing the test. First, we''ll need to type the login details
    in the two input fields:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will send the intent by clicking on the sign-in button:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we have to verify that the captured intent contains the login credentials:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Putting everything together, we will have the following test class (`LoginActivityTest.java`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running integration tests
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to what we did with Robolectric, to run integration tests, we need
    to switch to the correct **Test Artifact** in Android Studio. To do so, we will
    open the **Build Variants** toolbar and select the **Android Instrumentation Tests**
    artifact:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Running integration tests](img/B04887_11_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Now, from the **Project** window, we can run the tests by right-clicking on
    the test classes and selecting the **Run** option.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also run integration tests from the command line. To do so, we will
    call the `connectedCheck` (or `cC`) task:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a command line is the preferred way if we have a continuous integration
    system with a connected device or emulator. Once we write enough integration tests,
    we can easily deploy and run them on hundreds of real devices using services such
    as **Testdroid**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Running integration tests](img/B04887_11_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Testing from a UI perspective
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing that we will do now is similar to the kind of tests that a person
    using the app could do. In fact, in companies that have **QA** (**Quality Assurance**),
    people use these tools as a complement to manual testing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: UI tests can be automated as well, but they differ from unit and integration
    tests; these are actions performed on the screen, from clicking on a button to
    completing a registration process with recorded events.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We will start with stress testing using **The Monkey**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Launching The Monkey
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Monkey is a program that can be launched from the command line with ADB.
    It generates random events in our device or emulator, and using a seed, we can
    reproduce the same random events. To clarify, let's consider an example with numbers.
    Imagine that I execute Monkey and it produces random numbers from 1 to 10; if
    I launched it again, I would get different numbers. When I execute The Monkey
    with a seed (this seed is a number), I get a set of different numbers from 1 to
    10, and if I launch it again with the same seed, I will get the same numbers.
    This is useful because if we use a seed to generate random events and have a crash,
    we can fix this crash and run the same seed again to ensure that we fixed the
    problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: The Monkey是一个可以从命令行通过ADB启动的程序。它在我们的设备或模拟器中生成随机事件，并使用一个种子，我们可以重现相同的随机事件。为了说明，让我们考虑一个带数字的例子。假设我执行了Monkey，它产生了1到10的随机数字；如果我再次启动它，我会得到不同的数字。当我使用一个种子（这个种子是一个数字）执行The
    Monkey时，我得到了一组不同的1到10的数字，如果我用相同的种子再次启动它，我会得到相同的数字。这很有用，因为如果我们使用一个种子来生成随机事件并遇到崩溃，我们可以修复这个崩溃，并再次运行相同的种子，以确保我们解决了问题。
- en: These random events can vary from clicks and scroll gestures to system level
    events (such as volume up, volume down, screenshot, and so on) We can limit the
    number of the events and the type as well as the packages in which we run it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些随机事件可以是从点击和滚动手势到系统级别事件（如音量增大、音量减小、截图等）的变化。我们可以限制事件的数量和类型，以及运行它的程序包。
- en: 'The basic syntax in the terminal is the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 终端中的基本语法是以下命令：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you have never used ADB, you can find in it the `platform-tools` folder
    inside the Android SDK directory wherever it is installed in your system:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过ADB，你可以在Android SDK目录中的`platform-tools`文件夹里找到它，无论它安装在你的系统中的哪个位置：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we open a terminal and navigate to this directory, we can write the following
    line of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开终端并导航到这个目录时，我们可以编写以下代码行：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you try to use `adb` and the output is `command not found`, you can restart
    `adb` with `adb kill-server`, `adb start-server`, and `use ./adb` (*dot slash
    adb*) if you use Linux or Mac.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用`adb`而输出是`command not found`时，你可以使用`adb kill-server`、`adb start-server`和如果是Linux或Mac系统，使用`./adb`（点斜杠adb）来重启`adb`。
- en: 'We can increase the number of events to `5000` or produce infinite events,
    but it is always recommended to set a limit of numbers; otherwise, you will have
    to restart the device to stop The Monkey. When you execute the command, you will
    be able to see the random events produced, and it will indicate the seed used
    in case you want to repeat the same chain of events:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将事件数量增加到`5000`，或者产生无限事件，但通常建议设置一个数字限制；否则，你可能需要重启设备来停止The Monkey。当你执行命令时，你将能够看到产生的随机事件，并且它会指示所使用的种子，以便如果你想重复相同的事件链，可以知道种子：
- en: '![Launching The Monkey](img/B04887_11_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![启动The Monkey](img/B04887_11_11.jpg)'
- en: Depending on the app, we might need to adjust the time between events with the
    throttle milliseconds property in order to simulate a real user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的不同，我们可能需要调整事件之间的时间，使用节流毫秒属性来模拟真实用户。
- en: With the next testing tool, we will do a different kind of UI testing with the
    purpose of following a flow. An example of this would be if we have a registration
    process composed of three screens with different forms and want to record a test
    where a user fills up the form and continues through the three screens logically.
    In this case, The Monkey will not really help; with a very big number of events,
    it will eventually complete all the input fields with random characters and click
    on the buttons to move to the next screen, but this is not exactly what we want.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一个测试工具，我们将进行一种不同类型的UI测试，目的是跟随一个流程。例如，如果我们有一个由三个屏幕组成的注册流程，每个屏幕都有不同的表单，我们想要记录一个测试，用户填写表单并通过这三个屏幕逻辑地继续。在这种情况下，The
    Monkey实际上并不太有帮助；在大量的事件中，它最终会用随机字符填写所有输入字段，并点击按钮进入下一个屏幕，但这并不是我们真正想要的。
- en: Recording UI tests with MonkeyTalk
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MonkeyTalk记录UI测试
- en: The purpose of recording a sequence of tests such as the registration process
    is to have this test saved in order to be able to run it again when we make changes
    to our code. We might have to modify the network requests of the registration
    process without changing the UI, so these tests are perfect. We can just run them
    after finishing the modifications, and we don't have to manually complete the
    registration or fill the forms ourselves. We are not being lazy here; if we have
    hundreds of tests, this will be a lot of effort for one person. Also, with automated
    tests, we can ensure that the sequence of events is always the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**MonkeyTalk** is a free and open source tool, which comes in two versions;
    we''ll be using the community version for our example.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A list comparing the community and professional versions can be seen on their
    website at [https://www.cloudmonkeymobile.com/monkeytalk](https://www.cloudmonkeymobile.com/monkeytalk).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'MonkeyTalk can be used on real devices and emulators. It works by recording
    a list of events while we are in *Record mode*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording UI tests with MonkeyTalk](img/B04887_11_12.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Once we enter this record mode by clicking on **Record** in the tool, every
    event will be recorded in an order, with the action performed and the argument
    used. In the preceding screenshot, we can see how tapping on `TextView` and writing
    some input on it are recoded as two events.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create this in a script file, and MonkeyTalk will reproduce it; so,
    we have the option to create our own sequence of events without recording. For
    the preceding events, we will write a script such as the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we click on the **Play now** button, we will see all these steps executed
    on any device. We could record the scripts on an Android phone and play them on
    an iOS device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from recording and playing scripts, we can have verification commands.
    For instance, if we had a button that cleared all the input fields, we can add
    a verification command during the script using `currentValue`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will report the result of the verification during execution, so we will
    be able to check whether all our verifications are passed correctly. For example,
    clicking on the button to clear the forms would need a click listener that clears
    every input text. If, for some reason, we make modifications and the IDs of the
    elements change, a MonkeyTalk test will report the problem with a command failed
    verification.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be nice to have a tool that runs these UI tests for us, along with
    unit and integration tests, every time we make changes in our app? This solution
    exists, and it's called **Continuous Integration**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not our intention to explain how to build a continuous integration system
    because it's out of the scope of this book and it is not usually the job of an
    Android developer to set up the environment. However, you should be aware of what
    it is and how it works as it's directly related with Android.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: A good suite of automated tests is always better combined with CI or a continuous
    integration solution. This solution will allow us to build and test our application
    every time there is a code change.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一套良好的自动化测试套件与 CI 或持续集成解决方案结合使用总是更好的。这个解决方案将允许我们在每次代码更改时构建和测试我们的应用程序。
- en: This is the way most companies with big projects work. If they have a team of
    developers, the code is usually shared in a repository, and they build a CI system
    connected to the repository. Every time a developer makes and commits a change
    to the repository, the collection of tests is executed, and if the result is successful,
    a new Android executable file (**APK**) is built.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大多数拥有大型项目的公司的工作方式。如果他们有一个开发团队，代码通常会在一个仓库中共享，并且他们会构建一个与仓库相连的持续集成（CI）系统。每当开发者在仓库中进行更改并提交时，都会执行测试集合，如果结果成功，就会构建一个新的
    Android 可执行文件（**APK**）。
- en: This is done to minimize the risk of problems. In a big application, which takes
    years to be developed with different people working on it, it would be impossible
    for a new developer to start making changes without breaking or changing any of
    the existing features. This is because either not all the people in the project
    know what all the code is for, or the code is just so complex that modifying a
    component alters others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了尽量减少问题的风险。在一个需要多年开发，不同人员参与的大型应用程序中，新开发人员在不破坏或更改现有功能的情况下开始进行更改是不可能的。这是因为项目中的所有人并不都了解所有代码的用途，或者代码过于复杂，修改一个组件可能会影响其他组件。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in implementing this solution, we can point you to **Jenkins**,
    originally called Hudson at [https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣实施这个解决方案，我们可以为你推荐**Jenkins**，其最初名为 Hudson，详情请访问[https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins)。
- en: '![Continuous integration](img/B04887_11_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/B04887_11_13.jpg)'
- en: Apart from testing and building our app, Jenkins will generate a test cover
    report, which will allow us to know the percentage of our code that is covered
    by unit and integration tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试和构建我们的应用程序外，Jenkins 还将生成一个测试覆盖率报告，这将使我们能够了解单元测试和集成测试覆盖了我们代码的百分比。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started learning how to use logs in our app in an advanced
    way, and we took a quick overview of the debugging process. We explained what
    tests are and how to create unit and integration tests with Robolectric and Espresso,
    respectively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习如何在我们的应用程序中以高级方式使用日志，并快速概述了调试过程。我们解释了什么是测试，以及如何分别使用 Robolectric 和
    Espresso 创建单元测试和集成测试。
- en: We also created UI tests, starting with stress tests with the The Monkey, then
    generating random events, and later started testing with MonkeyTalk, recording
    event flows that can be played again verifying the output. To finish, we spoke
    about continuous integration to discover how companies put together the tests
    and the building system for an Android app.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了 UI 测试，从使用 The Monkey 进行压力测试开始，然后生成随机事件，后来开始使用 MonkeyTalk 进行测试，记录可以再次播放以验证输出的事件流程。最后，我们讨论了持续集成，了解公司如何为
    Android 应用程序将测试和构建系统集成在一起。
- en: In the next chapter, which is the last chapter of this book, we will take a
    look at how to monetize our app, how to build the app using different build flavors,
    and obfuscating the code, leaving it ready to be uploaded to App Store.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是本书的最后一章中，我们将了解如何使我们的应用程序盈利，如何使用不同的构建风味构建应用程序，以及混淆代码，使其准备好上传到应用商店。
