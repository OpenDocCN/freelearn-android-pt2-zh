- en: Chapter 11. Debugging and Testing on Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 安卓上的调试与测试
- en: In this chapter, you will learn how to debug in Android, an essential practice
    to save time in finding and fixing problems while developing our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Android中进行调试，这是一个在开发应用程序时查找和解决问题的基本实践，可以节省时间。
- en: We will learn how to create automated tests that can test the click of a button
    or the outcome of a single method. This is a set of tests that you can run in
    Android Studio to ensure that every time you develop a new feature, you don't
    break any of the existent ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建自动化测试，可以测试按钮的点击或单个方法的结果。这是一组你可以在Android Studio中运行的测试，以确保每次开发新功能时，不会破坏现有的功能。
- en: You will also learn how to use **Robolectric** for unit tests and Espresso for
    integration tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用**Robolectric**进行单元测试和Espresso进行集成测试。
- en: At the end of the chapter, we will discuss how to test the UI with millions
    of random clicks using Monkey, how to record sequences of clicks through the app,
    and how to configure tests based on these recordings with MonkeyTalk.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将讨论如何使用Monkey进行数百万次随机点击测试UI，如何通过应用录制点击序列，以及如何使用MonkeyTalk配置基于这些记录的测试。
- en: Logs and the debug mode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和调试模式
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Unit tests with Robolectric
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Robolectric进行单元测试
- en: Integration tests with Espresso
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Espresso进行集成测试
- en: UI Testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI测试
- en: Random clicks with MonkeyRunner
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MonkeyRunner进行随机点击
- en: Recording clicks with MonkeyTalk
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MonkeyTalk记录点击
- en: Continuous Integration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Logs and the debug mode
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和调试模式
- en: We couldn't finish the book without mentioning logs and how to debug to solve
    problems while developing. Developing in Android can be more than just copying
    and pasting from Stack Overflow if you know how to solve your own problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不提及日志以及如何通过调试解决问题，我们无法完成这本书。如果你知道如何解决自己的问题，那么在Android上开发不仅仅是复制粘贴Stack Overflow的内容。
- en: The debug mode and logs are mechanisms used to help the developer identify where
    the problems are. With time, every developer improves and uses these techniques
    less frequently, but at the beginning, it's quite common to have an app full of
    logs. We don't want users to be able to see the log when the app is released,
    and we don't want to remove logs manually and then add them again when we release
    a new version. We will take a look at how to avoid this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 调试模式和日志是帮助开发者定位问题的机制。随着时间的推移，每个开发者都会进步并减少使用这些技术的频率，但一开始，应用中充满了日志是很常见的。我们不希望用户在应用发布后能够看到日志，也不希望手动移除日志并在发布新版本时再次添加。我们将看看如何避免这种情况。
- en: Working with logs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理日志
- en: 'The log class is used to print out messages and errors, which we can read in
    real time using `LogCat`. This is an example of how to log a message:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Log类用于打印实时可在`LogCat`中读取的消息和错误。以下是记录消息的示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Log` class has five methods, and they are used to have a different level
    of priority on the logs. This allows us to filter by priority in `LogCat`. There
    are situations when we display different logs, for instance, to see the number
    of job offers we download in every request. If we have a crash in our app, logs
    of the type error are our priority at this moment, and we want to hide other logs
    with less priority to find the error as soon as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log`类有五种方法，它们用于在日志上设置不同的优先级。这允许我们在`LogCat`中按优先级进行过滤。在某些情况下，我们会显示不同的日志，例如，查看每次请求下载的工作机会数量。如果我们的应用崩溃了，此时错误类型的日志是我们的优先事项，我们希望隐藏其他优先级较低的日志，以便尽快找到错误。'
- en: The five priorities are (from low to high) verbose, debug, information, warning,
    and error. (`Log.v` , `Log.d`, `Log.i`, `Log.w`, and `Log.e`)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 五个优先级分别是（从低到高）：详细、调试、信息、警告和错误。(`Log.v` , `Log.d`, `Log.i`, `Log.w`, 和 `Log.e`)
- en: We can filter by process with the bar at the top of the logging window. We can
    filter by priority and by keyword, and we can create custom filters by tag, process
    ID, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过日志窗口顶部的栏按进程进行过滤。我们可以按优先级和关键词进行过滤，并且可以创建自定义过滤器，按标签、进程ID等进行过滤。
- en: '![Working with logs](img/B04887_11_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![处理日志](img/B04887_11_01.jpg)'
- en: If the logs don't appear or they are old and not refreshing, try to open the
    dropdown to the right, select **No** **filters**, and then select **Show only
    selected application** again. This forces the console to refresh.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志不显示或者它们是旧的且不刷新，尝试打开右边的下拉菜单，选择**无** **过滤**，然后再次选择**仅显示选定应用程序**。这会强制控制台刷新。
- en: '![Working with logs](img/B04887_11_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![处理日志](img/B04887_11_02.jpg)'
- en: 'To finish with logs, we will create a wrapper and use a third-party library
    with the idea to be able to disable all the logs in the project by just changing
    the value of a Boolean. To do this, we simply create a class with the same methods
    of the `Log` class that depend on this Boolean value:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成日志，我们将创建一个包装器，并使用第三方库，以便只需更改布尔值就能在项目中禁用所有日志。为此，我们只需创建一个具有与`Log`类相同方法的类，这些方法依赖于这个布尔值：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to use this wrapper every time we want to write a log—`MyLogger.d()`
    instead of `Log.d()`. This way, if we change the value of the Boolean `LOG` in
    the `MyLogger` class, it will stop all the logs in our project at the same time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次想要编写日志时都需要使用这个包装器——使用`MyLogger.d()`而不是`Log.d()`。这样，如果我们更改`MyLogger`类中的布尔值`LOG`，它将同时停止我们项目中的所有日志。
- en: 'It is recommended to use the value from the `BuildConfing.DEBUG` variable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用`BuildConfing.DEBUG`变量的值：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will be true if our app is in the debug mode, and it will be false when
    we release the app. So, we don't need to remember to turn the logs off in release
    mode, and there is no risk of a log appearing to the final user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用处于调试模式，这将成立，发布应用时将变为假。因此，我们不需要记住在发布模式下关闭日志，也没有日志对最终用户显示的风险。
- en: Using Timber, the log wrapper
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Timber，日志包装器
- en: 'Timber is a log wrapper created by Jake Wharton that takes the log to an advanced
    level, allowing us to have different log behaviors using the log tree concept.
    Take a look at the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Timber是由Jake Wharton创建的日志包装器，它将日志提升到了一个高级水平，允许我们使用日志树概念来拥有不同的日志行为。看看以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One of the advantages of using timber is that we don''t need to write a tag
    in our logs more than once in the same activity:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Timber的优点之一是，我们不需要在同一个活动中多次编写日志标签：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our trees can have different behaviors; for instance, I might want to disable
    logs in the release mode, but I still want to handle errors; so, I will plant
    an error tree that will report the error to Parse:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的树可以有不同的行为；例如，我可能想在发布模式下禁用日志，但我仍然想处理错误；所以，我会种植一个错误树，将错误报告给Parse：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Debugging our app
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试我们的应用
- en: Logs can be used to find problems while developing, but if we master the debug
    mode, we will find this practice much quicker.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可用于开发过程中查找问题，但如果我们掌握了调试模式，会发现这个做法要快得多。
- en: 'While we are in the debug mode, we can set breakpoints in the code. With these
    breakpoints, we specify a line of code where we want the execution to stop to
    show us the values of the variables at that moment. To set a breakpoint, simply
    double-click on the left-hand side bar:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处于调试模式时，可以在代码中设置断点。通过这些断点，我们指定一个代码行，我们希望执行在此处停止，以显示那一刻的变量值。要设置断点，只需在左侧边栏上双击：
- en: '![Debugging our app](img/B04887_11_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![调试我们的应用](img/B04887_11_03.jpg)'
- en: 'We set a debug point in the response of the method that gets the job offer.
    We can launch the debug mode from the top bar:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在获取工作机会的方法的响应中设置了一个调试点。我们可以从顶部栏启动调试模式：
- en: '![Debugging our app](img/B04887_11_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![调试我们的应用](img/B04887_11_04.jpg)'
- en: 'If we run the app in **Debug** mode, Android studio will pause the execution
    when it reaches this point:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在**调试**模式下运行应用，当达到这一点时，Android Studio将暂停执行：
- en: '![Debugging our app](img/B04887_11_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![调试我们的应用](img/B04887_11_05.jpg)'
- en: Android Studio will automatically prompt the **Debugger** window, where we will
    be able to see the variables at the point of execution. We can see in the preceding
    screenshot the job offer list and navigate to see what every offer has inside.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio会自动提示**调试器**窗口，我们可以在执行点查看变量。从前面的截图中，我们可以看到工作机会列表，并导航查看每个机会内部的内容。
- en: The important features here are the green **Play** button to the left, which
    continues the execution of our app until the next breakpoint, and the red square,
    which exits the debug mode and continues with the execution of the app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要特性是左侧的绿色**播放**按钮，它将继续执行我们的应用到下一个断点，以及红色方块，它退出调试模式并继续执行应用。
- en: 'We also have different controls available to move to the next line, into a
    method, or outside the method. For instance, consider that we have a breakpoint
    in the first line of the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有不同的控件可用于转到下一行，进入一个方法，或离开方法。例如，假设我们在以下命令的第一行有一个断点：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, **Step Over**, which is the blue arrow pointing downward, will
    move our execution to the next line. If we click on **Step Into**, the blue arrow
    pointing to the bottom-right corner, we will get into the `getInstace()` method.
    With a combination of these controls, we can control the flow in realtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**单步跳过**（指向下方的蓝色箭头）将把我们的执行移到下一行。如果我们点击**单步进入**（指向右下角的蓝色箭头），我们将进入`getInstace()`方法。结合这些控件，我们可以实时控制流程。
- en: With the debug mode explained, we can now move on to automated tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 解释了调试模式之后，我们现在可以继续讨论自动化测试。
- en: Testing on Android
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上测试
- en: A new functionality is not complete without being tested first. We, as developers,
    have fallen many times into the trap of submitting code changes without writing
    a passing test first, only to find that the expected behavior was broken on future
    iterations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新功能在完成之前都需要先进行测试。我们作为开发者，曾多次掉入在未先编写通过测试的情况下提交代码更改的陷阱，结果发现在未来的迭代中预期行为被破坏了。
- en: We learned the hard way that writing tests boosts our productivity, increases
    code quality, and helps us release more often. For this reason, Android provided
    several tools to help us test our apps from the early stages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过艰难的方式了解到，编写测试可以提高我们的生产力，提高代码质量，并帮助我们更频繁地发布。因此，Android提供了几种工具，以帮助我们从早期阶段开始测试应用程序。
- en: In the following two sections, we will talk about my favorite setup, Robolectric
    for unit testing and Espresso for integration testing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们将讨论我最喜欢的设置：用Robolectric进行单元测试，用Espresso进行集成测试。
- en: Unit tests with Robolectric
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Robolectric的单元测试
- en: Until Robolectric, writing unit tests meant that we had to run them on a real
    device or an emulator. This process could take several minutes as Android build
    tools have to package the testing code, push it to the connected device, and then
    run it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Robolectric出现，编写单元测试意味着我们必须在真实设备或模拟器上运行它们。这个过程可能需要几分钟，因为Android构建工具必须打包测试代码，将其推送到连接的设备，然后运行它。
- en: Robolectric alleviates this problem by enabling us to run our unit tests in
    the JVM of our workstation without the need for an Android device or emulator.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Robolectric通过使我们能够在工作站的JVM中运行单元测试，而无需Android设备或模拟器，从而缓解了这个问题。
- en: 'To include Robolectric using Gradle, we can add the following dependency to
    our `build.gradle` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用Gradle包含Robolectric，我们可以在`build.gradle`文件中添加以下依赖： '
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use `testCompile` to specify that we want this dependency to be included
    in our test project. For the test project, the default source directory is `src/test`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`testCompile`来指定我们希望此依赖包含在测试项目中。对于测试项目，默认源目录是`src/test`。
- en: Robolectric configuration
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Robolectric配置
- en: 'At the time of writing, Robolectric version 3.0 supports the following Android
    SDKs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Robolectric 3.0版本支持以下Android SDK：
- en: Jelly Bean, SDK version 16
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jelly Bean，SDK版本16
- en: Jelly Bean MR1, SDK version 17
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jelly Bean MR1，SDK版本17
- en: Jelly Bean MR2, SDK version 18
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jelly Bean MR2，SDK版本18
- en: KitKat, SDK version 19
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KitKat，SDK版本19
- en: Lollipop, SDK version 21
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lollipop，SDK版本21
- en: 'By default, the tests will run against `targetSdkVersion` defined in the `AndroidManifest`
    file. If you want to run the tests against a different SDK version or if your
    current `targetSdkVersion` is not supported by Robolectric, you can override it
    manually using a properties file located at `src/test/resources/robolectric.properties`
    with the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，测试将针对`AndroidManifest`文件中定义的`targetSdkVersion`运行。如果你想针对不同的SDK版本运行测试，或者你当前的`targetSdkVersion`不被Robolectric支持，你可以手动覆盖它，通过位于`src/test/resources/robolectric.properties`的属性文件，内容如下：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our first unit test
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的第一单元测试
- en: 'We''ll begin by setting up a very simple and common scenario: a welcoming activity
    with a **Login** button that navigates the user to a login activity. The layout
    for the welcome activity is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置一个非常简单且常见的场景开始：一个带有**登录**按钮的欢迎活动，该按钮使用户导航到登录活动。欢迎活动的布局如下：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On the `WelcomeActivity` class, we''ll simply set the login button to start
    the login activity:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WelcomeActivity`类中，我们只需将登录按钮设置为启动登录活动：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to test this, we can ensure that we start `LoginActivity` by sending
    the correct `Intent`. Because Robolectric is a unit-testing framework, `LoginActivity`
    will not actually be started, but we'll be able to check whether the framework
    captured the correct intent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以确保通过发送正确的`Intent`来启动`LoginActivity`。因为Robolectric是一个单元测试框架，`LoginActivity`实际上不会启动，但我们能够检查框架是否捕获了正确的意图。
- en: 'First, we will create the test file, `WelcomeActivityTest.java`, in the correct
    package within the `src/test/java/` path. Robolectric depends on JUnit 4, so we
    will start by specifying Robolectric''s Gradle test runner and some extra configuration
    that the framework will use to find the `AndroidManifest` resources and assets.
    Run the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`src/test/java/`路径中正确的包内创建测试文件`WelcomeActivityTest.java`。Robolectric
    依赖于 JUnit 4，因此我们将从指定 Robolectric 的 Gradle 测试运行器和一些额外的配置开始，框架将使用这些配置来查找`AndroidManifest`资源和资产。运行以下命令：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can write our first test. We''ll begin by creating and bringing the
    welcome activity to the foreground:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写我们的第一个测试。我们将从创建并使欢迎活动进入前台开始：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have an instance of `WelcomeActivity`, it''s easy to click on the
    login button:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了`WelcomeActivity`的实例，点击登录按钮就变得简单了：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we have to verify that the framework captured the intent that would
    have started `LoginActivity`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须验证框架捕获了将启动`LoginActivity`的意图：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `shadowOf` static method returns a `ShadowActivity` object that stores
    most of the interactions with the current activity under test. We need to use
    the `@Test` annotation, which tells JUnit that the method can be run as a test
    case. Putting everything together, we have the following test class (`WelcomeActivityTest.java`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`shadowOf`静态方法返回一个`ShadowActivity`对象，该对象存储了与当前测试活动的大部分交互。我们需要使用`@Test`注解，这告诉
    JUnit 该方法可以作为测试用例运行。将所有内容放在一起，我们得到以下测试类（`WelcomeActivityTest.java`）：'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running unit tests
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: 'Before being able to run the unit tests, we need to select the correct **Test
    Artifact** in Android Studio. To do so, we will open the **Build Variants** toolbar
    and select the **Unit Tests** artifact, as displayed in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够运行单元测试之前，我们需要在 Android Studio 中选择正确的**测试工件**。为此，我们将打开**构建变体**工具栏，并选择**单元测试**工件，如下面的截图所示：
- en: '![Running unit tests](img/B04887_11_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![运行单元测试](img/B04887_11_06.jpg)'
- en: Now, from the **Project** window, we can run the tests by right-clicking on
    the test classes and selecting the **Run** option. Ensure that there are no spaces
    in the project path; otherwise, Robolectric will throw an exception prior to execution
    of the unit tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从**项目**窗口中，我们可以通过右键点击测试类并选择**运行**选项来运行测试。确保项目路径中没有空格；否则，Robolectric 在执行单元测试之前会抛出异常。
- en: '![Running unit tests](img/B04887_11_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![运行单元测试](img/B04887_11_07.jpg)'
- en: 'We can also run unit tests from the command line. To do so, call the `test`
    task command with the `--continue` option:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从命令行运行单元测试。为此，使用带有`--continue`选项的`test`任务命令调用：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This option is ideal if we have a continuous integration system configured,
    such as Jenkins, Travis, or wercker.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经配置了持续集成系统，例如 Jenkins、Travis 或 wercker，这个选项是理想的。
- en: This is the end of the Robolectric section. Next, we'll discuss integration
    testing with **Espresso**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Robolectric 部分的结尾。接下来，我们将讨论使用**Espresso**进行集成测试。
- en: Integration tests with Espresso
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Espresso 进行集成测试
- en: Due to the very nature of Android and the vast amount of devices out there,
    we can never be certain of how the app might behave when we release it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 本身的特点以及市场上的大量设备，我们无法确定发布应用时它可能会如何表现。
- en: We naturally tend to manually test our app on as many different devices as possible,
    which is a tedious process that we have to repeat on every release that we do.
    In this section, we'll briefly discuss Espresso and how we can write tests that
    will run on a real device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自然会尽可能在许多不同的设备上手动测试我们的应用，这是一个繁琐的过程，每次发布时都必须重复。在本节中，我们将简要讨论 Espresso 以及如何编写将在真实设备上运行的测试。
- en: Espresso configuration
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Espresso 配置
- en: 'Before writing our first integration test, we need to install and configure
    our test environment. Perform the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的第一个集成测试之前，我们需要安装并配置测试环境。执行以下步骤：
- en: From Android SDK Manager, we need to select and install **Android Support Repository**
    from the **Extras** folder, as shown in the following screenshot:![Espresso configuration](img/B04887_11_08.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Android SDK 管理器中，我们需要在**Extras**文件夹中选择并安装**Android 支持仓库**，如下面的截图所示：![Espresso
    配置](img/B04887_11_08.jpg)
- en: Create the folder for our integration tests code; this should be located at
    `app/src/androidTest`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于集成测试代码的文件夹；这应该位于`app/src/androidTest`。
- en: 'We''ll also need to specify a few dependencies in the project''s `build.gradle`.
    Use the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在项目的`build.gradle`中指定一些依赖项。使用以下代码：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Recently, Android added support for JUnit 4 style test cases. To use this,
    we''ll add `AndroidJUnitRunner` as the default test instrumentation runner in
    the `build.gradle` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Android添加了对JUnit 4风格测试案例的支持。要使用它，我们将在`build.gradle`文件中将`AndroidJUnitRunner`添加为默认的测试仪器运行器：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Writing an integration test
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: 'For this example, we''ll continue from where we left off with Robolectric;
    we''ll write a test for `LoginActivity`. For this activity, we''ll set a simple
    layout with two `EditTexts` and a sign-in button. Run the following code (`activity_login.xml`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将从Robolectric停下的地方继续；我们将为`LoginActivity`编写一个测试。对于这个活动，我们将设置一个简单的布局，包含两个`EditTexts`和一个登录按钮。运行以下代码（`activity_login.xml`）：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `LoginActivity`, when the user clicks on the sign-in button, we''ll send
    the credentials to the splash activity using the following code (`LoginActivity.java`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoginActivity`中，当用户点击登录按钮时，我们将使用以下代码（`LoginActivity.java`）将凭据发送到闪屏活动：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this test, we'll type the user credentials in the two input fields and verify
    that we bundle them correctly in the intent.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将在两个输入字段中输入用户凭据，并验证我们是否在意图中正确捆绑它们。
- en: 'First, we will create the `LoginActivityTest.java` test file in the correct
    package within the `src/test/androidTest/` path. We''ll use JUnit 4, so we will
    start by specifying the `AndroidJUnit4` test runner. Use the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`src/test/androidTest/`路径中正确的包内创建`LoginActivityTest.java`测试文件。我们将使用JUnit
    4，因此首先会指定`AndroidJUnit4`测试运行器。使用以下命令：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another distinction to Robolectric is that in Espresso, we need to specify
    a rule that will prepare the activity under test. For this, use the following
    command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与Robolectric的另一区别是，在Espresso中，我们需要指定一个规则来准备被测试的活动。为此，使用以下命令：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can start writing the test. First, we''ll need to type the login details
    in the two input fields:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写测试。首先，我们需要在两个输入字段中输入登录详情：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will send the intent by clicking on the sign-in button:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过点击登录按钮发送意图：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we have to verify that the captured intent contains the login credentials:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须验证捕获的意图是否包含登录凭据：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Putting everything together, we will have the following test class (`LoginActivityTest.java`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 把所有内容放在一起，我们将拥有以下测试类（`LoginActivityTest.java`）：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running integration tests
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行集成测试
- en: 'Similar to what we did with Robolectric, to run integration tests, we need
    to switch to the correct **Test Artifact** in Android Studio. To do so, we will
    open the **Build Variants** toolbar and select the **Android Instrumentation Tests**
    artifact:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用Robolectric所做的类似，要运行集成测试，我们需要在Android Studio中切换到正确的**测试工件（Test Artifact）**。为此，我们将打开**构建变种（Build
    Variants）**工具栏并选择**Android Instrumentation Tests**工件：
- en: '![Running integration tests](img/B04887_11_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![运行集成测试](img/B04887_11_09.jpg)'
- en: Now, from the **Project** window, we can run the tests by right-clicking on
    the test classes and selecting the **Run** option.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从**项目**窗口中，我们可以通过右键点击测试类并选择**运行**选项来运行测试。
- en: 'We can also run integration tests from the command line. To do so, we will
    call the `connectedCheck` (or `cC`) task:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从命令行运行集成测试。为此，我们将调用`connectedCheck`（或`cC`）任务：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a command line is the preferred way if we have a continuous integration
    system with a connected device or emulator. Once we write enough integration tests,
    we can easily deploy and run them on hundreds of real devices using services such
    as **Testdroid**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有连接设备或模拟器的持续集成系统，使用命令行是首选方式。当我们编写足够的集成测试后，可以轻松地在数百台真实设备上部署和运行它们，使用如**Testdroid**之类的服务。
- en: '![Running integration tests](img/B04887_11_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![运行集成测试](img/B04887_11_10.jpg)'
- en: Testing from a UI perspective
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从UI角度进行测试
- en: The testing that we will do now is similar to the kind of tests that a person
    using the app could do. In fact, in companies that have **QA** (**Quality Assurance**),
    people use these tools as a complement to manual testing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进行的测试与使用应用程序的人可能会进行的测试类似。实际上，在拥有**质量保证（QA）**的的公司中，人们将这些工具作为手动测试的补充。
- en: UI tests can be automated as well, but they differ from unit and integration
    tests; these are actions performed on the screen, from clicking on a button to
    completing a registration process with recorded events.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试也可以自动化，但它们与单元测试和集成测试不同；这些是在屏幕上执行的操作，从点击按钮到使用记录的事件完成注册过程。
- en: We will start with stress testing using **The Monkey**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用**The Monkey**进行压力测试开始。
- en: Launching The Monkey
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动The Monkey
- en: The Monkey is a program that can be launched from the command line with ADB.
    It generates random events in our device or emulator, and using a seed, we can
    reproduce the same random events. To clarify, let's consider an example with numbers.
    Imagine that I execute Monkey and it produces random numbers from 1 to 10; if
    I launched it again, I would get different numbers. When I execute The Monkey
    with a seed (this seed is a number), I get a set of different numbers from 1 to
    10, and if I launch it again with the same seed, I will get the same numbers.
    This is useful because if we use a seed to generate random events and have a crash,
    we can fix this crash and run the same seed again to ensure that we fixed the
    problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: The Monkey是一个可以从命令行通过ADB启动的程序。它在我们的设备或模拟器中生成随机事件，并使用一个种子，我们可以重现相同的随机事件。为了说明，让我们考虑一个带数字的例子。假设我执行了Monkey，它产生了1到10的随机数字；如果我再次启动它，我会得到不同的数字。当我使用一个种子（这个种子是一个数字）执行The
    Monkey时，我得到了一组不同的1到10的数字，如果我用相同的种子再次启动它，我会得到相同的数字。这很有用，因为如果我们使用一个种子来生成随机事件并遇到崩溃，我们可以修复这个崩溃，并再次运行相同的种子，以确保我们解决了问题。
- en: These random events can vary from clicks and scroll gestures to system level
    events (such as volume up, volume down, screenshot, and so on) We can limit the
    number of the events and the type as well as the packages in which we run it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些随机事件可以是从点击和滚动手势到系统级别事件（如音量增大、音量减小、截图等）的变化。我们可以限制事件的数量和类型，以及运行它的程序包。
- en: 'The basic syntax in the terminal is the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 终端中的基本语法是以下命令：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you have never used ADB, you can find in it the `platform-tools` folder
    inside the Android SDK directory wherever it is installed in your system:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过ADB，你可以在Android SDK目录中的`platform-tools`文件夹里找到它，无论它安装在你的系统中的哪个位置：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we open a terminal and navigate to this directory, we can write the following
    line of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开终端并导航到这个目录时，我们可以编写以下代码行：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you try to use `adb` and the output is `command not found`, you can restart
    `adb` with `adb kill-server`, `adb start-server`, and `use ./adb` (*dot slash
    adb*) if you use Linux or Mac.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用`adb`而输出是`command not found`时，你可以使用`adb kill-server`、`adb start-server`和如果是Linux或Mac系统，使用`./adb`（点斜杠adb）来重启`adb`。
- en: 'We can increase the number of events to `5000` or produce infinite events,
    but it is always recommended to set a limit of numbers; otherwise, you will have
    to restart the device to stop The Monkey. When you execute the command, you will
    be able to see the random events produced, and it will indicate the seed used
    in case you want to repeat the same chain of events:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将事件数量增加到`5000`，或者产生无限事件，但通常建议设置一个数字限制；否则，你可能需要重启设备来停止The Monkey。当你执行命令时，你将能够看到产生的随机事件，并且它会指示所使用的种子，以便如果你想重复相同的事件链，可以知道种子：
- en: '![Launching The Monkey](img/B04887_11_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![启动The Monkey](img/B04887_11_11.jpg)'
- en: Depending on the app, we might need to adjust the time between events with the
    throttle milliseconds property in order to simulate a real user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的不同，我们可能需要调整事件之间的时间，使用节流毫秒属性来模拟真实用户。
- en: With the next testing tool, we will do a different kind of UI testing with the
    purpose of following a flow. An example of this would be if we have a registration
    process composed of three screens with different forms and want to record a test
    where a user fills up the form and continues through the three screens logically.
    In this case, The Monkey will not really help; with a very big number of events,
    it will eventually complete all the input fields with random characters and click
    on the buttons to move to the next screen, but this is not exactly what we want.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一个测试工具，我们将进行一种不同类型的UI测试，目的是跟随一个流程。例如，如果我们有一个由三个屏幕组成的注册流程，每个屏幕都有不同的表单，我们想要记录一个测试，用户填写表单并通过这三个屏幕逻辑地继续。在这种情况下，The
    Monkey实际上并不太有帮助；在大量的事件中，它最终会用随机字符填写所有输入字段，并点击按钮进入下一个屏幕，但这并不是我们真正想要的。
- en: Recording UI tests with MonkeyTalk
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MonkeyTalk记录UI测试
- en: The purpose of recording a sequence of tests such as the registration process
    is to have this test saved in order to be able to run it again when we make changes
    to our code. We might have to modify the network requests of the registration
    process without changing the UI, so these tests are perfect. We can just run them
    after finishing the modifications, and we don't have to manually complete the
    registration or fill the forms ourselves. We are not being lazy here; if we have
    hundreds of tests, this will be a lot of effort for one person. Also, with automated
    tests, we can ensure that the sequence of events is always the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记录一系列测试（如注册过程）的目的是为了保存这些测试，以便在我们对代码进行更改时能够再次运行它。我们可能需要修改注册过程的网络请求，而不改变UI，所以这些测试非常完美。我们可以在完成修改后直接运行它们，而无需手动完成注册或填写表单。这里我们并不是在偷懒；如果我们有数百个测试，这对于一个人来说将是大量的工作。此外，通过自动化测试，我们可以确保事件序列始终如一。
- en: '**MonkeyTalk** is a free and open source tool, which comes in two versions;
    we''ll be using the community version for our example.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**MonkeyTalk**是一个免费且开源的工具，有两个版本；在我们的示例中，我们将使用社区版。'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A list comparing the community and professional versions can be seen on their
    website at [https://www.cloudmonkeymobile.com/monkeytalk](https://www.cloudmonkeymobile.com/monkeytalk).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有关社区版和专业版的比较列表，可以在他们的网站[https://www.cloudmonkeymobile.com/monkeytalk](https://www.cloudmonkeymobile.com/monkeytalk)上查看。
- en: 'MonkeyTalk can be used on real devices and emulators. It works by recording
    a list of events while we are in *Record mode*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: MonkeyTalk可以在真实设备和模拟器上使用。它通过在*录制模式*下记录一系列事件来工作：
- en: '![Recording UI tests with MonkeyTalk](img/B04887_11_12.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonkeyTalk录制UI测试](img/B04887_11_12.jpg)'
- en: Once we enter this record mode by clicking on **Record** in the tool, every
    event will be recorded in an order, with the action performed and the argument
    used. In the preceding screenshot, we can see how tapping on `TextView` and writing
    some input on it are recoded as two events.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过点击工具中的**录制**进入这个录制模式，所有的事件将以执行的动作用到的参数的顺序被记录下来。在上面的截图中，我们可以看到点击`TextView`并在上面输入一些内容是如何被记录为两个事件的。
- en: 'We could create this in a script file, and MonkeyTalk will reproduce it; so,
    we have the option to create our own sequence of events without recording. For
    the preceding events, we will write a script such as the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个脚本文件中创建这个，MonkeyTalk将会重现它；因此，我们有了在不录制的情况下创建自己的事件序列的选项。对于前面的事件，我们将编写如下脚本：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we click on the **Play now** button, we will see all these steps executed
    on any device. We could record the scripts on an Android phone and play them on
    an iOS device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击**立即播放**按钮，我们将在任何设备上看到所有这些步骤的执行。我们可以在Android手机上录制脚本，然后在iOS设备上播放它们。
- en: 'Apart from recording and playing scripts, we can have verification commands.
    For instance, if we had a button that cleared all the input fields, we can add
    a verification command during the script using `currentValue`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了录制和播放脚本，我们还可以有验证命令。例如，如果我们有一个清除所有输入字段的按钮，我们可以在脚本执行过程中使用`currentValue`添加一个验证命令：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will report the result of the verification during execution, so we will
    be able to check whether all our verifications are passed correctly. For example,
    clicking on the button to clear the forms would need a click listener that clears
    every input text. If, for some reason, we make modifications and the IDs of the
    elements change, a MonkeyTalk test will report the problem with a command failed
    verification.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将报告执行过程中验证的结果，这样我们就能检查我们的所有验证是否正确通过。例如，点击清除表单的按钮就需要一个点击监听器来清除每个输入文本。如果由于某种原因我们进行了修改，元素的ID发生了变化，MonkeyTalk测试会通过一个失败的命令验证来报告这个问题。
- en: Wouldn't it be nice to have a tool that runs these UI tests for us, along with
    unit and integration tests, every time we make changes in our app? This solution
    exists, and it's called **Continuous Integration**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次我们在应用中做出更改时，有一个工具能为我们运行这些UI测试，以及单元测试和集成测试，那岂不是很棒？这个解决方案是存在的，它被称为**持续集成**。
- en: Continuous integration
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: It is not our intention to explain how to build a continuous integration system
    because it's out of the scope of this book and it is not usually the job of an
    Android developer to set up the environment. However, you should be aware of what
    it is and how it works as it's directly related with Android.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的不是解释如何构建一个持续集成系统，因为这超出了本书的范围，而且通常不是Android开发者的职责来设置这个环境。但是，你应该了解它是什么以及它是如何工作的，因为它与Android直接相关。
- en: A good suite of automated tests is always better combined with CI or a continuous
    integration solution. This solution will allow us to build and test our application
    every time there is a code change.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一套良好的自动化测试套件与 CI 或持续集成解决方案结合使用总是更好的。这个解决方案将允许我们在每次代码更改时构建和测试我们的应用程序。
- en: This is the way most companies with big projects work. If they have a team of
    developers, the code is usually shared in a repository, and they build a CI system
    connected to the repository. Every time a developer makes and commits a change
    to the repository, the collection of tests is executed, and if the result is successful,
    a new Android executable file (**APK**) is built.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大多数拥有大型项目的公司的工作方式。如果他们有一个开发团队，代码通常会在一个仓库中共享，并且他们会构建一个与仓库相连的持续集成（CI）系统。每当开发者在仓库中进行更改并提交时，都会执行测试集合，如果结果成功，就会构建一个新的
    Android 可执行文件（**APK**）。
- en: This is done to minimize the risk of problems. In a big application, which takes
    years to be developed with different people working on it, it would be impossible
    for a new developer to start making changes without breaking or changing any of
    the existing features. This is because either not all the people in the project
    know what all the code is for, or the code is just so complex that modifying a
    component alters others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了尽量减少问题的风险。在一个需要多年开发，不同人员参与的大型应用程序中，新开发人员在不破坏或更改现有功能的情况下开始进行更改是不可能的。这是因为项目中的所有人并不都了解所有代码的用途，或者代码过于复杂，修改一个组件可能会影响其他组件。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in implementing this solution, we can point you to **Jenkins**,
    originally called Hudson at [https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣实施这个解决方案，我们可以为你推荐**Jenkins**，其最初名为 Hudson，详情请访问[https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins)。
- en: '![Continuous integration](img/B04887_11_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/B04887_11_13.jpg)'
- en: Apart from testing and building our app, Jenkins will generate a test cover
    report, which will allow us to know the percentage of our code that is covered
    by unit and integration tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试和构建我们的应用程序外，Jenkins 还将生成一个测试覆盖率报告，这将使我们能够了解单元测试和集成测试覆盖了我们代码的百分比。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started learning how to use logs in our app in an advanced
    way, and we took a quick overview of the debugging process. We explained what
    tests are and how to create unit and integration tests with Robolectric and Espresso,
    respectively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习如何在我们的应用程序中以高级方式使用日志，并快速概述了调试过程。我们解释了什么是测试，以及如何分别使用 Robolectric 和
    Espresso 创建单元测试和集成测试。
- en: We also created UI tests, starting with stress tests with the The Monkey, then
    generating random events, and later started testing with MonkeyTalk, recording
    event flows that can be played again verifying the output. To finish, we spoke
    about continuous integration to discover how companies put together the tests
    and the building system for an Android app.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了 UI 测试，从使用 The Monkey 进行压力测试开始，然后生成随机事件，后来开始使用 MonkeyTalk 进行测试，记录可以再次播放以验证输出的事件流程。最后，我们讨论了持续集成，了解公司如何为
    Android 应用程序将测试和构建系统集成在一起。
- en: In the next chapter, which is the last chapter of this book, we will take a
    look at how to monetize our app, how to build the app using different build flavors,
    and obfuscating the code, leaving it ready to be uploaded to App Store.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是本书的最后一章中，我们将了解如何使我们的应用程序盈利，如何使用不同的构建风味构建应用程序，以及混淆代码，使其准备好上传到应用商店。
