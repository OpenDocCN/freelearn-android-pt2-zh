["```kt\n    mScene.setTouchAreaBindingOnActionDownEnabled(true);\n    ```", "```kt\n    /* Create the buttonSprite object in the center of the Scene */\n    ButtonSprite buttonSprite = new ButtonSprite(WIDTH * 0.5f,\n        HEIGHT * 0.5f, mButtonTextureRegion,\n        mEngine.getVertexBufferObjectManager()) {\n      /* Override the onAreaTouched() event method */\n      @Override\n      public boolean onAreaTouched(TouchEvent pSceneTouchEvent,\n          float pTouchAreaLocalX, float pTouchAreaLocalY) {\n        /* If buttonSprite is touched with the finger */\n        if(pSceneTouchEvent.isActionDown()){\n          /* When the button is pressed, we can create an event \n           * In this case, we're simply displaying a quick toast */\n          CreatingButtons.this.runOnUiThread(new Runnable(){\n            @Override\n            public void run() {\n              Toast.makeText(getApplicationContext(), \"Button Pressed!\", Toast.LENGTH_SHORT).show();\n            }\n          });\n        }\n        /* In order to allow the ButtonSprite to swap tiled texture region \n         * index on our buttonSprite object, we must return the super method */\n        return super.onAreaTouched(pSceneTouchEvent, pTouchAreaLocalX, pTouchAreaLocalY);\n      }\n    };\n    ```", "```kt\n    /* Register the buttonSprite as a 'touchable' Entity */\n    mScene.registerTouchArea(buttonSprite);\n    /* Attach the buttonSprite to the Scene */\n    mScene.attachChild(buttonSprite);\n    ```", "```kt\n    /* Create the music mute/unmute button */\n    TiledSprite mMuteButton = new TiledSprite(buttonX, buttonY,\n        mButtonTextureRegion, mEngine.getVertexBufferObjectManager()) {\n\n      /* Override the onAreaTouched() method allowing us to define custom\n      * actions */\n      @Override\n      public boolean onAreaTouched(TouchEvent pSceneTouchEvent,\n          float pTouchAreaLocalX, float pTouchAreaLocalY) {\n        /* In the event the mute button is pressed down on... */\n        if (pSceneTouchEvent.isActionDown()) {\n          if (mMenuMusic.isPlaying()) {\n            /*  If music is playing, pause it and set tile index to  MUTE  */\n            this.setCurrentTileIndex(MUTE);\n            mMenuMusic.pause();\n          } else {\n            /* If music is paused, play it and set tile index to UNMUTE */\n            this.setCurrentTileIndex(UNMUTE);\n            mMenuMusic.play();\n          }\n          return true;\n        }\n        return super.onAreaTouched(pSceneTouchEvent, pTouchAreaLocalX,\n            pTouchAreaLocalY);\n      }\n    };\n    ```", "```kt\n    /* Set the current tile index to unmuted on application startup */\n    mMuteButton.setCurrentTileIndex(UNMUTE);\n\n    /* Register and attach the mMuteButton to the Scene */\n    mScene.registerTouchArea(mMuteButton);\n    mScene.attachChild(mMuteButton);\n\n    /* Set the mMenuMusic object to loop once it reaches the track's end */\n    mMenuMusic.setLooping(true);\n    /* Play the mMenuMusic object */\n    mMenuMusic.play();\n    ```", "```kt\n    @Override\n    public synchronized void onResumeGame() {\n      super.onResumeGame();\n\n      /* If the music and button have been created */\n      if (mMenuMusic != null && mMuteButton != null) {\n        /* If the mMuteButton is set to unmuted on resume... */\n        if(mMuteButton.getCurrentTileIndex() == UNMUTE){\n          /* Play the menu music */\n          mMenuMusic.play();\n        }\n      }\n    }\n\n    @Override\n    public synchronized void onPauseGame() {\n      super.onPauseGame();\n\n      /* Always pause the music on pause */\n      if(mMenuMusic != null && mMenuMusic.isPlaying()){\n        mMenuMusic.pause();\n      }\n    }\n    ```", "```kt\n    /* Define background color values */\n    final float red = 0;\n    final float green = 1;\n    final float blue = 1;\n    final float alpha = 1;\n\n    /* Create a new background with the specified color values */\n    Background background = new Background(red, green, blue, alpha);\n    ```", "```kt\n    /* Set the mScene object's background */\n    mScene.setBackground(background);\n\n    /* Set the background to be enabled */\n    mScene.setBackgroundEnabled(true);\n    ```", "```kt\n    /* Create a rectangle in the bottom left corner of the Scene */\n    Rectangle rectangleLeft = new Rectangle(100, 100, 200, 200,\n        mEngine.getVertexBufferObjectManager());\n\n    /* Create a rectangle in the top right corner of the Scene */\n    Rectangle rectangleRight = new Rectangle(WIDTH - 100, HEIGHT - 100, 200, 200,\n        mEngine.getVertexBufferObjectManager());\n    /* Create the entity to be used as a background */\n    Entity backgroundEntity = new Entity();\n\n    /* Attach the rectangles to the entity which will be applied as a background */\n    backgroundEntity.attachChild(rectangleLeft);\n    backgroundEntity.attachChild(rectangleRight);\n\n    /* Define the background color properties */\n    final float red = 0;\n    final float green = 0;\n    final float blue = 0;\n\n    /* Create the EntityBackground, specifying its background color & entity to represent the background image */\n    EntityBackground background = new EntityBackground(red, green, blue, backgroundEntity);\n\n    /* Set & enable the background */\n    mScene.setBackground(background);\n    mScene.setBackgroundEnabled(true);\n```", "```kt\n/* Create the Sprite object */\nSprite sprite = new Sprite(WIDTH * 0.5f, HEIGHT * 0.5f, mBackgroundTextureRegion,\n    mEngine.getVertexBufferObjectManager());\n\n/* Define the background color values */\nfinal float red = 0;\nfinal float green = 0;\nfinal float blue = 0;\n\n/* Create the SpriteBackground object, specifying \n * the color values & Sprite object to display*/\nSpriteBackground background = new SpriteBackground(red, green, blue, sprite);\n\n/* Set & Enable the background */\nmScene.setBackground(background);\nmScene.setBackgroundEnabled(true);\n```", "```kt\nAssetBitmapTexture mBitmapTexture = null;\n\ntry {\n  /* Create the AssetBitmapTexture with the REPEATING_* texture option */\n  mBitmapTexture = new AssetBitmapTexture(mEngine.getTextureManager(), this.getAssets(), \"gfx/grass.png\", BitmapTextureFormat.RGB_565,TextureOptions.REPEATING_BILINEAR);\n} catch (IOException e) {\n  e.printStackTrace();\n}\n/* Load the bitmap texture */\nmBitmapTexture.load();\n\n/* Extract the bitmap texture into an ITextureRegion */\nmRepeatingTextureRegion = TextureRegionFactory.extractFromTexture(mBitmapTexture);\n```", "```kt\n\n/* Define the RepeatingSpriteBackground sizing parameters */\nfinal float cameraWidth = WIDTH;\nfinal float cameraHeight = HEIGHT;\nfinal float repeatingScale = 1f;\n\n/* Create the RepeatingSpriteBackground */\nRepeatingSpriteBackground background = new RepeatingSpriteBackground(cameraWidth, cameraHeight, mRepeatingTextureRegion, repeatingScale,\n    mEngine.getVertexBufferObjectManager());\n\n/* Set & Enable the background */\nmScene.setBackground(background);\nmScene.setBackgroundEnabled(true);\n```", "```kt\n    final float textureHeight = mHillTextureRegion.getHeight();\n\n    /* Create the hill which will appear to be the furthest\n    * into the distance. This Sprite will be placed higher than the \n     * rest in order to retain visibility of it */\n    Sprite hillFurthest = new Sprite(WIDTH * 0.5f, textureHeight * 0.5f + 50, mHillTextureRegion,\n        mEngine.getVertexBufferObjectManager());\n\n    /* Create the hill which will appear between the furthest and closest\n     * hills. This Sprite will be placed higher than the closest hill, but\n    * lower than the furthest hill in order to retain visibility */\n    Sprite hillMid = new Sprite(WIDTH * 0.5f, textureHeight * 0.5f + 25, mHillTextureRegion,\n        mEngine.getVertexBufferObjectManager());\n\n    /* Create the closest hill which will not be obstructed by any other hill \n    * Sprites. This Sprite will be placed at the bottom of the Scene since\n    * nothing will be covering its view */\n    Sprite hillClosest = new Sprite(WIDTH * 0.5f, textureHeight * 0.5f, mHillTextureRegion,\n        mEngine.getVertexBufferObjectManager());\n    ```", "```kt\n    /* Create the ParallaxBackground, setting the color values to represent \n    * a blue sky */\n    ParallaxBackground background = new ParallaxBackground(0.3f, 0.3f, 0.9f) {\n\n      /* We'll use these values to calculate the parallax value of the background */\n      float cameraPreviousX = 0;\n      float parallaxValueOffset = 0;\n\n      /* onUpdates to the background, we need to calculate new \n       * parallax values in order to apply movement to the background\n      * objects (the hills in this case) */\n      @Override\n      public void onUpdate(float pSecondsElapsed) {\n        /* Obtain the camera's current center X value */\n        final float cameraCurrentX = mCamera.getCenterX();\n\n        /* If the camera's position has changed since last \n         * update... */\n        if (cameraPreviousX != cameraCurrentX) {\n\n          /* Calculate the new parallax value offset by \n           * subtracting the previous update's camera x coordinate\n           * from the current update's camera x coordinate */\n          parallaxValueOffset +=  cameraCurrentX - cameraPreviousX;\n\n          /* Apply the parallax value offset to the background, which \n           * will in-turn offset the positions of entities attached\n           * to the background */\n          this.setParallaxValue(parallaxValueOffset);\n\n          /* Update the previous camera X since we're finished with this \n           * update */\n          cameraPreviousX = cameraCurrentX;\n        }\n        super.onUpdate(pSecondsElapsed);\n      }\n    };\n    ```", "```kt\n    background.attachParallaxEntity(new ParallaxEntity(5, hillFurthest));\n    background.attachParallaxEntity(new ParallaxEntity(10, hillMid));\n    background.attachParallaxEntity(new ParallaxEntity(15, hillClosest));\n    ```", "```kt\n    /* Set & Enabled the background */\n    mScene.setBackground(background);\n    mScene.setBackgroundEnabled(true);\n    ```", "```kt\n/* Define the speed that the parallax entities will move at.\n * \n* Set to a negative value for movement in the opposite direction */\nfinal float autoParallaxSpeed = 3;\n\n/* Create an AutoParallaxBackground */\nAutoParallaxBackground background = new AutoParallaxBackground(0.3f, 0.3f, 0.9f, autoParallaxSpeed);\n```", "```kt\n    final float halfLevelSelectorWidth = ((TILE_DIMENSION * COLUMNS) + TILE_PADDING\n        * (COLUMNS - 1)) * 0.5f;\n    this.mInitialX = (this.mCameraWidth * 0.5f) - halfLevelSelectorWidth;\n\n    /* Same math as above applies to the Y coordinate */\n    final float halfLevelSelectorHeight = ((TILE_DIMENSION * ROWS) + TILE_PADDING\n        * (ROWS - 1)) * 0.5f;\n    this.mInitialY = (this.mCameraHeight * 0.5f) + halfLevelSelectorHeight;\n    ```", "```kt\n    public void createTiles(final ITextureRegion pTextureRegion,\n        final Font pFont) {\n\n      /* Temp coordinates for placing level tiles */\n      float tempX = this.mInitialX + TILE_DIMENSION * 0.5f;\n      float tempY = this.mInitialY - TILE_DIMENSION * 0.5f;\n\n      /* Current level of the tile to be placed */\n      int currentTileLevel = 1;\n\n      /* Loop through the Rows, adjusting tempY coordinate after each\n       * iteration */\n      for (int i = 0; i < ROWS; i++) {\n\n        /* Loop through the column positions, placing a LevelTile in each\n         * column */\n        for (int o = 0; o < COLUMNS; o++) {\n\n          final boolean locked;\n\n          /* Determine whether the current tile is locked or not */\n          if (currentTileLevel <= mMaxLevel) {\n            locked = false;\n          } else {\n            locked = true;\n          }\n\n          /* Create a level tile */\n          LevelTile levelTile = new LevelTile(tempX, tempY, locked,\n              currentTileLevel, pTextureRegion, pFont);\n\n          /* Attach the level tile's text based on the locked and\n          * currentTileLevel variables pass to its constructor */\n          levelTile.attachText();\n\n          /* Register & Attach the levelTile object to the LevelSelector */\n          mScene.registerTouchArea(levelTile);\n          this.attachChild(levelTile);\n\n          /* Increment the tempX coordinate to the next column */\n          tempX = tempX + TILE_DIMENSION + TILE_PADDING;\n\n          /* Increment the level tile count */\n          currentTileLevel++;\n        }\n\n        /* Reposition the tempX coordinate back to the first row (far left) */\n        tempX = mInitialX + TILE_DIMENSION * 0.5f;\n\n        /* Reposition the tempY coordinate for the next row to apply tiles */\n        tempY = tempY - TILE_DIMENSION - TILE_PADDING;\n      }\n    }\n    ```", "```kt\n    /* Display the LevelSelector on the Scene. */\n    public void show() {\n\n      /* Register as non-hidden, allowing touch events */\n      mHidden = false;\n\n      /* Attach the LevelSelector the the Scene if it currently has no parent */\n      if (!this.hasParent()) {\n        mScene.attachChild(this);\n      }\n\n      /* Set the LevelSelector to visible */\n      this.setVisible(true);\n    }\n\n    /* Hide the LevelSelector on the Scene. */\n    public void hide() {\n\n      /* Register as hidden, disallowing touch events */\n      mHidden = true;\n\n      /* Remove the LevelSelector from view */\n      this.setVisible(false);\n    }\n    ```", "```kt\n    public LevelTile(float pX, float pY, boolean pIsLocked,\n        int pLevelNumber, ITextureRegion pTextureRegion, Font pFont) {\n      super(pX, pY, LevelSelector.this.TILE_DIMENSION,\n        LevelSelector.this.TILE_DIMENSION, pTextureRegion,\n        LevelSelector.this.mEngine.getVertexBufferObjectManager());\n\n      /* Initialize the necessary variables for the LevelTile */\n      this.mFont = pFont;\n      this.mIsLocked = pIsLocked;\n      this.mLevelNumber = pLevelNumber;\n    }\n    ```", "```kt\n    /* Method used to obtain whether or not this level tile represents a\n     * level which is currently locked */\n    public boolean isLocked() {\n      return this.mIsLocked;\n    }\n\n    /* Method used to obtain this specific level tiles level number */\n    public int getLevelNumber() {\n      return this.mLevelNumber;\n    }\n    ```", "```kt\n    public void attachText() {\n      String tileTextString = null;\n\n      /* If the tile's text is currently null... */\n      if (this.mTileText == null) {\n        /* Determine the tile's string based on whether it's locked or\n        * not */\n        if (this.mIsLocked) {\n          tileTextString = \"Locked\";\n        } else {\n          tileTextString = String.valueOf(this.mLevelNumber);\n        }\n        /* Setup the text position to be placed in the center of the tile */\n        final float textPositionX = LevelSelector.this.TILE_DIMENSION * 0.5f;\n        final float textPositionY = textPositionX;\n\n        /* Create the tile's text in the center of the tile */\n        this.mTileText = new Text( textPositionX,\n            textPositionY, this.mFont,\n            tileTextString, tileTextString.length(),\n            LevelSelector.this.mEngine.getVertexBufferObjectManager());\n\n        /* Attach the Text to the LevelTile */\n        this.attachChild(mTileText);\n      }\n    }\n    ```", "```kt\n    @Override\n    public boolean onAreaTouched(TouchEvent pSceneTouchEvent,\n        float pTouchAreaLocalX, float pTouchAreaLocalY) {\n      /* If the LevelSelector is not hidden, proceed to execute the touch\n       * event */\n      if (!LevelSelector.this.mHidden) {\n        /* If a level tile is initially pressed down on */\n        if (pSceneTouchEvent.isActionDown()) {\n          /* If this level tile is locked... */\n          if (this.mIsLocked) {\n            /* Tile Locked event... */\n        LevelSelector.this.mScene.getBackground().setColor(\n            org.andengine.util.adt.color.Color.RED);\n          } else {\n            /* Tile unlocked event... This event would likely prompt\n             * level loading but without getting too complicated we\n             * will simply set the Scene's background color to green */\n        LevelSelector.this.mScene.getBackground().setColor(\n                org.andengine.util.adt.color.Color.GREEN);\n\n            /**\n             * Example level loading:\n             *     LevelSelector.this.hide();\n             * SceneManager.loadLevel(this.mLevelNumber);\n             */\n          }\n          return true;\n        }\n      }\n      return super.onAreaTouched(pSceneTouchEvent, pTouchAreaLocalX,\n          pTouchAreaLocalY);\n    }\n    ```", "```kt\nLevelSelector.this.hide();\nSceneManager.loadLevel(this.mLevelNumber, LevelSelector.this.mChapter);\n```", "```kt\n/* Define the level selector properties */\nfinal int maxUnlockedLevel = 7;\nfinal int levelSelectorChapter = 1;\nfinal int cameraWidth = WIDTH;\nfinal int cameraHeight = HEIGHT\n\n/* Create a new level selector */\nLevelSelector levelSelector = new LevelSelector(maxUnlockedLevel, levelSelectorChapter, cameraWidth, cameraHeight, mScene, mEngine);\n\n/* Generate the level tiles for the levelSelector object */\nlevelSelector.createTiles(mTextureRegion, mFont);\n\n/* Display the levelSelector object on the scene */\nlevelSelector.show();\n```", "```kt\n    /* These three Entity objects will represent different screens */\n    private final Entity mScreenOne = new Entity();\n    private final Entity mScreenTwo = new Entity();\n    private final Entity mScreenThree = new Entity();\n\n    /* This entity modifier is defined as the 'transition-in' modifier\n     * which will move an Entity/screen into the camera-view */\n    private final ParallelEntityModifier mMoveInModifier = new ParallelEntityModifier(\n      new MoveXModifier(3, WIDTH, 0),\n      new RotationModifier(3, 0, 360),\n      new ScaleModifier(3, 0, 1));\n\n    /* This entity modifier is defined as the 'transition-out' modifier\n     * which will move an Entity/screen out of the camera-view */\n    private final ParallelEntityModifier mMoveOutModifier = new ParallelEntityModifier(\n      new MoveXModifier(3, 0, -WIDTH),\n      new RotationModifier(3, 360, 0),\n      new ScaleModifier(3, 1, 0));\n    ```", "```kt\n    mScene = new Scene() {\n      /* Variable which will accumulate time passed to\n       * determine when to switch screens */\n      float timeCounter = 0;\n\n      /* Define the first screen indices to be transitioned in and out */\n      int layerInIndex = 0;\n      int layerOutIndex = SCREEN_COUNT - 1;\n\n      /* Execute the code below on every update to the mScene object */\n      @Override\n      protected void onManagedUpdate(float pSecondsElapsed) {\n\n        /* If accumulated time is equal to or greater than 4 seconds */\n        if (timeCounter >= 4) {\n\n         /* Set screens to be transitioned in and out */\n          setLayer(mScene.getChildByIndex(layerInIndex),\n              mScene.getChildByIndex(layerOutIndex));\n\n          /* Reset the time counter */\n          timeCounter = 0;\n\n          /* Setup the next screens to be swapped in and out */\n          if (layerInIndex >= SCREEN_COUNT - 1) {\n            layerInIndex = 0;\n           layerOutIndex = SCREEN_COUNT - 1;\n          } else {\n            layerInIndex++;\n            layerOutIndex = layerInIndex - 1;\n          }\n\n        }\n        /* Accumulate seconds passed since last update */\n        timeCounter += pSecondsElapsed;\n        super.onManagedUpdate(pSecondsElapsed);\n      }\n    };\n\n    /* Attach the layers to the scene.\n     * Their layer index (according to mScene) is relevant to the\n     * order in which they are attached */\n    mScene.attachChild(mScreenOne); // layer index == 0\n    mScene.attachChild(mScreenTwo); // layer index == 1\n    mScene.attachChild(mScreenThree); // layer index == 2\n    ```", "```kt\n    /* This method is used to swap screens in and out of the camera-view */\n    private void setLayer(IEntity pLayerIn, IEntity pLayerOut) {\n\n      /* If the layer being transitioned into the camera-view is invisible,\n       * set it to visibile */\n      if (!pLayerIn.isVisible()) {\n       pLayerIn.setVisible(true);\n      }\n\n      /* Global modifiers must be reset after each use */\n      mMoveInModifier.reset();\n      mMoveOutModifier.reset();\n\n      /* Register the transitional effects to the screens */\n      pLayerIn.registerEntityModifier(mMoveInModifier);\n      pLayerOut.registerEntityModifier(mMoveOutModifier);\n    }\n    ```", "```kt\nmScene.attachChild(mScreenOne); // layer index == 0\nmScene.attachChild(mScreenTwo); // layer index == 1\nmScene.attachChild(mScreenThree); // layer index == 2\n```"]