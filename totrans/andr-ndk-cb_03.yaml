- en: Chapter 3. Build and Debug NDK Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 构建和调试NDK应用程序
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Building an Android NDK application at the command line
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行构建 Android NDK 应用程序
- en: Building an Android NDK application in Eclipse
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Eclipse 中构建 Android NDK 应用程序
- en: Building an Android NDK application for different ABIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的 ABI 构建 Android NDK 应用程序
- en: Building an Android NDK applications for different CPU features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的 CPU 特性构建 Android NDK 应用程序
- en: Debugging an Android NDK application with logging messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志消息调试 Android NDK 应用程序
- en: Debugging an Android NDK application with CheckJNI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CheckJNI 调试 Android NDK 应用程序
- en: Debugging an Android NDK application with NDK GDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NDK GDB 调试 Android NDK 应用程序
- en: Debugging an Android NDK application with CGDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CGDB 调试 Android NDK 应用程序
- en: Debugging an Android NDK application in Eclipse
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Eclipse 中调试 Android NDK 应用程序
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: We covered the environment set up in [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK*, and JNI programming in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*. To build Android NDK applications,
    we'll also need to use the **build** and **debug** tools for Android NDK.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章. Hello NDK") *Hello NDK*中介绍了环境设置，以及[第2章](ch02.html "第2章.
    Java Native Interface") *Java Native Interface*中的JNI编程。为了构建Android NDK应用程序，我们还需要使用Android
    NDK的**构建**和**调试**工具。
- en: Android NDK comes with the `ndk-build` script to facilitate the easy build of
    any Android NDK application. This script hides the complications of invoking cross
    compilers, cross linkers, and so on, from developers. We'll start by introducing
    the usage of the `ndk-build` command.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 附带了 `ndk-build` 脚本，以方便构建任何Android NDK应用程序。这个脚本隐藏了调用交叉编译器、交叉链接器等的复杂性，让开发者无需处理。我们将从介绍
    `ndk-build` 命令的用法开始。
- en: A recent release of the **Android Development Tools** (**ADT**) plugin has enabled
    the building of Android NDK applications from Eclipse. We'll demonstrate how to
    use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android Development Tools** (**ADT**) 插件的最近一次发布支持从 Eclipse 构建Android NDK应用程序。我们将演示如何使用它。'
- en: We'll explore building NDK applications for different **Application Binary Interfaces**
    (**ABIs**) and making use of optional CPU features. This is essential to achieve
    best performance on different Android devices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨为不同的**应用程序二进制接口** (**ABIs**) 构建NDK应用程序，并利用可选的CPU特性。这对于在不同Android设备上实现最佳性能至关重要。
- en: Besides build, we will also introduce various debugging tools and techniques
    for Android NDK applications. Starting with the simple but powerful logging technique,
    we'll show how to debug NDK applications from both the command line and the Eclipse
    IDE. The `CheckJNI` mode will also be introduced, which can help us capture JNI
    bugs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建，我们还将介绍各种用于Android NDK应用程序的调试工具和技术。从简单但强大的日志技术开始，我们将展示如何从命令行和Eclipse IDE中调试NDK应用程序。还将介绍
    `CheckJNI` 模式，它可以帮助我们捕获JNI错误。
- en: Building an Android NDK application at the command line
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命令行构建 Android NDK 应用程序
- en: Though Eclipse is the recommended IDE for Android development, sometimes we
    want to build an Android application in the command line so that the process can
    be automated easily and become part of a continuous integration process. This
    recipe focuses on how to build an Android DNK application at the command line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Eclipse是推荐用于Android开发的IDE，但有时我们希望在命令行中构建Android应用程序，以便可以轻松地自动化该过程并成为持续集成过程的一部分。本食谱重点介绍如何在命令行中构建Android
    NDK应用程序。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Apache Ant is a tool mainly used for building Java applications. It accepts
    an XML file to describe the build, deploy and test processes, manage the processes,
    and to automatically keep a track of the dependencies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Ant 主要是一个用于构建Java应用程序的工具。它接受一个XML文件来描述构建、部署和测试过程，管理这些过程，并自动跟踪依赖关系。
- en: 'We are going to use Apache Ant to build and deploy our sample project. If you
    don''t have it installed yet, you can follow these commands to install it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Apache Ant 来构建和部署我们的示例项目。如果你还没有安装它，可以按照以下命令进行安装：
- en: 'If you''re on Ubuntu Linux, use the following command:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Ubuntu Linux，请使用以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you''re using a Mac, use the following command:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Mac，请使用以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you're using Windows, you can download the `winant` installer from [http://code.google.com/p/winant/downloads/list](http://code.google.com/p/winant/downloads/list),
    and install it.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，可以从[http://code.google.com/p/winant/downloads/list](http://code.google.com/p/winant/downloads/list)下载
    `winant` 安装程序，并进行安装。
- en: Readers are supposed to have the NDK development environment set up and read
    the *Writing a Hello NDK program* recipe in [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK*, before going through this one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 读者在阅读本节之前，应该已经设置好了NDK开发环境，并阅读了[第1章](ch01.html "第1章. Hello NDK")中的*编写Hello NDK程序*部分，*Hello
    NDK*。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps create and build a sample `HelloNDK` application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤创建并构建一个示例`HelloNDK`应用：
- en: 'Create the project. Start a command-line console and enter the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目。启动命令行控制台并输入以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `android` tool can be found under the `tools/` directory of the Android
    SDK folder. If you have followed [Chapter 1](ch01.html "Chapter 1. Hello NDK"),
    *Hello NDK*, to set up the SDK and NDK development with `PATH` configured properly,
    you can execute the `android` command directly from the command line. Otherwise,
    you will need to enter the relative or full path to the `android` program. This
    also applies to other SDK and NDK tools used in the book.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`android`工具可以在Android SDK文件夹的`tools/`目录下找到。如果你按照[第1章](ch01.html "第1章. Hello
    NDK")设置了SDK和NDK开发环境，并正确配置了`PATH`，那么可以直接从命令行执行`android`命令。否则，你需要输入到`android`程序的相关路径或完整路径。这也适用于本书中使用的其他SDK和NDK工具。'
- en: 'The following is a screenshot of the command output:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是命令输出的截图：
- en: '![How to do it…](img/1505_03_01.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_01.jpg)'
- en: 'Go to the `HelloNDK` project folder and create a folder named `jni` by using
    the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`HelloNDK`项目文件夹，并使用以下命令创建一个名为`jni`的文件夹：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file named `hello.c` under the `jni` folder, and add the following
    content to it:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建一个名为`hello.c`的文件，并添加以下内容：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a file named `Android.mk` under the `jni` folder with the following
    content:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建一个名为`Android.mk`的文件，内容如下：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Build the native library using the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建本地库：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Modify the `HelloNDKActivity.java` file to the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`HelloNDKActivity.java`文件为以下内容：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the project. We have added a native library, so we need to update the
    project with the following command. Note that this command is only needed once
    unless we change the project settings, while the previous `ndk-build` command
    needs to be executed every time we update the native code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新项目。我们添加了一个本地库，因此需要使用以下命令更新项目。注意，除非我们更改项目设置，否则此命令只需执行一次，而之前的`ndk-build`命令每次更新本地代码都需要执行：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is a screenshot of the command output:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是命令输出的截图：
- en: '![How to do it…](img/1505_03_02.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_02.jpg)'
- en: 'Go to the project `root` folder, and build our project in the debug mode using
    the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到项目根文件夹，并使用以下命令以调试模式构建我们的项目：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following screenshot, we show the last few lines of the output, which
    indicates a successful build is:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下截图中，我们展示了输出的最后几行，这表示构建成功的是：
- en: '![How to do it…](img/1505_03_03.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_03.jpg)'
- en: The output `apk` will be produced at `bin/HelloNDK-debug.apk`.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出的`apk`文件将生成在`bin/HelloNDK-debug.apk`。
- en: 'Create an emulator using the following command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个模拟器：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is a screenshot of the command output:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是命令输出的截图：
- en: '![How to do it…](img/1505_03_04.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_04.jpg)'
- en: 'Start the emulator, using the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动模拟器：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, we can start the **Android Virtual Device Manager** window by
    using the command "`android avd`", and then choosing an emulator to launch, as
    follows:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可以使用"`android avd`"命令打开**Android虚拟设备管理器**窗口，然后选择一个模拟器启动，如下所示：
- en: '![How to do it…](img/1505_03_05.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_05.jpg)'
- en: 'Install the app on the emulator. We first check the device serial number by
    using the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上安装应用。我们首先通过以下命令检查设备序列号：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is a screenshot of the command output:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是命令输出的截图：
- en: '![How to do it…](img/1505_03_06.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_06.jpg)'
- en: 'We then install the `debug.apk` file to the emulator by using the following
    command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令将`debug.apk`文件安装到模拟器上：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![How to do it…](img/1505_03_07.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_07.jpg)'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If only a single device is connected to the computer, there is no need to specify
    the device serial number. In the preceding commands , we can remove "-`s emulator-5554`".
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果只有一个设备连接到电脑，那么无需指定设备序列号。在上述命令中，我们可以移除"-`s emulator-5554`"。
- en: 'Start the `HelloNDK` app on the emulator using the command in the following
    format:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下格式的命令在模拟器上启动`HelloNDK`应用：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our example, we use the following ommand:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在我们的示例中，我们使用以下命令： '
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How to do it…](img/1505_03_08.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_08.jpg)'
- en: Run the app on a device.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上运行应用。
- en: Suppose the device serial number is `HT21HTD09025`, then we can use the following
    command to install the app on an Android device.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设设备序列号为 `HT21HTD09025`，那么我们可以使用以下命令在 Android 设备上安装应用。
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In our example, we use the following command to start the app:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用以下命令来启动应用：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create a release package.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个发布包。
- en: 'Once we confirm that our application can run successfully, we may want to create
    a release package for uploading to the Android market. You can perform the following
    steps to achieve this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认应用程序可以成功运行，我们可能想要创建一个发布包以便上传到 Android 市场。你可以执行以下步骤来实现这一点：
- en: 'Create a keystore. An Android app must be signed using a key from a keystore.
    A **keystore** is a collection of private keys. We can use the following command
    to create a keystore with a private key:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个密钥库。Android 应用必须使用密钥库中的密钥进行签名。一个 **密钥库** 是私钥的集合。我们可以使用以下命令创建带有私钥的密钥库：
- en: '[PRE18]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is a screenshot of the command output:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是命令输出的截图：
- en: '![How to do it…](img/1505_03_09.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_09.jpg)'
- en: As shown, a keystore with password as `testkwpw` is created, and a RSA key pair
    with password as `testkpw` is added to the keystore.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如所示，创建了一个带有密码为 `testkwpw` 的密钥库，并在其中添加了一个带有密码为 `testkpw` 的 RSA 密钥对。
- en: Type the command "`ant release`" to build an `apk` for the app. The output can
    be found in the b`i`n folder as `HelloNDK-release-unsigned.apk`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令 "`ant release`" 为应用构建一个 `apk`。输出可以在 b`i`n 文件夹中找到，文件名为 `HelloNDK-release-unsigned.apk`。
- en: 'Sign the `apk` by using the following command:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令对 `apk` 进行签名：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For our sample application, the command and output are as follows:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的示例应用程序，命令和输出如下：
- en: '![How to do it…](img/1505_03_10.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_10.jpg)'
- en: 'Zip-align the `apk` file. The `zipalign` tool aligns the data inside an `apk`
    file for performance optimization. The following command can be used to align
    a signed `apk`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `apk` 文件进行 zip 对齐。`zipalign` 工具对 `apk` 文件内的数据进行对齐，以优化性能。以下命令可用于对齐已签名的 `apk`：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For our sample application, the command and output are as follows:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的示例应用程序，命令和输出如下：
- en: '![How to do it…](img/1505_03_11.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_11.jpg)'
- en: How it works…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: This recipe discusses how to build an Android NDK application from the command
    line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程介绍如何从命令行构建 Android NDK 应用程序。
- en: 'Android NDK provides a build system with the following goals:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 提供了一个具有以下目标的构建系统：
- en: '**Simplicity**: It handles most of the heavy lifting stuff for developers,
    and we only need to write brief build files (`Android.mk` and `Application.mk`)
    to describe the sources need to be compiled.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：它为开发者处理了大部分繁重的工作，我们只需要编写简短的构建文件（`Android.mk` 和 `Application.mk`）来描述需要编译的源代码。'
- en: '**Compatibility**: More build tools, platforms, and so on, may be added to
    NDK in future releases, but no changes are required for the build files.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：未来的版本可能会向 NDK 添加更多构建工具、平台等，但构建文件不需要更改。'
- en: Android NDK comes with a set of cross toolchains, including cross-compilers,
    cross-linkers, cross-assemblers, and so on. These tools can be found under `toolchains`
    folder of the NDK `root` directory. They can be used to generate binaries on different
    Android platforms (ARM, x86, or MIPS) on Linux, Mac OS, or Windows. Although it
    is possible to use the toolchains directly to build native code for Android, it
    is not recommended unless we're porting a project with its own build scripts.
    In this case, we may only need to change the original compiler to the NDK cross
    compiler to build it for Android.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 提供了一套交叉工具链，包括交叉编译器、交叉链接器、交叉汇编器等。这些工具可以在 NDK `root` 目录下的 `toolchains`
    文件夹中找到。它们可用于在 Linux、Mac OS 或 Windows 上为不同的 Android 平台（ARM、x86 或 MIPS）生成二进制文件。尽管可以直接使用工具链来为
    Android 构建本地代码，但除非我们正在移植带有自己的构建脚本的项目，否则不推荐这样做。在这种情况下，我们可能只需要将原始编译器更改为 NDK 交叉编译器，以构建适用于
    Android 的版本。
- en: 'In most cases, we''ll describe the sources in `Android.mk` and specify the
    ABIs on `Application.mk`. Android NDK''s `ndk-build` script will internally invoke
    the cross toolchain to build the native code for us. The following is a list of
    commonly used `ndk-build` options:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将在 `Android.mk` 中描述源代码，并在 `Application.mk` 上指定 ABIs。Android NDK 的
    `ndk-build` 脚本将在内部调用交叉工具链为我们构建本地代码。以下是一些常用的 `ndk-build` 选项列表：
- en: '`ndk-build`: It is used to build binaries.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build`：它用于构建二进制文件。'
- en: '`ndk-build clean`: It cleans the generated binaries.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build clean`：它清理生成的二进制文件。'
- en: '`ndk-build V=1`: This builds binaries and displays the build commands. It is
    handy when we want to find out how things are built or checked for build bugs.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build V=1`：构建二进制文件并显示构建命令。当我们想要了解构建过程或检查构建错误时，这很方便。'
- en: '`ndk-build -B`: This command forces a rebuild.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build -B`：此命令强制重新构建。'
- en: '`ndk-build NDK_DEBUG=1`: It generates debuggable build.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build NDK_DEBUG=1`：生成可调试的构建。'
- en: '`ndk-build NDK_DEBUG=0`: It generates a release build.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build NDK_DEBUG=0`：生成发布版本。'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: This recipe uses a lot of command-line tools in the Android SDK. This allows
    us to present complete instructions of how to create, build, and deploy an Android
    NDK project. However, we won't provide the details about these tools in this book
    since this book is dedicated to Android NDK. You may read more about those tools
    at [http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程使用了许多Android SDK的命令行工具。这允许我们提供如何创建、构建和部署Android NDK项目的完整说明。然而，由于本书专注于Android
    NDK，因此不会详细介绍这些工具。你可以访问[http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html)了解更多关于这些工具的信息。
- en: Taking screenshots from the command line
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从命令行截取屏幕截图
- en: Taking a screenshot from command line can be handy to record the display results
    for an automated test. However, Android does not provide a command-line tool to
    take a screenshot currently.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行截取屏幕截图对于记录自动化测试的显示结果很有帮助。然而，目前Android没有提供用于截屏的命令行工具。
- en: A Java program found at `\development\tools\screenshot\src\com\android\screenshot\`
    of the Android source code can be used to take screenshot. The code uses a similar
    method as the Eclipse DDMS plugin to take a screenshot, but from the command line.
    We incorporated the preceding code into an Eclipse Java project named `screenshot`,
    which can be downloaded from the website.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用位于Android源代码`\development\tools\screenshot\src\com\android\screenshot\`的Java程序来截取屏幕截图。该代码使用了与Eclipse
    DDMS插件类似的方法从命令行截取屏幕截图。我们将前面的代码整合到一个名为`screenshot`的Eclipse Java项目中，可以从网站下载。
- en: 'One can import the project and export an executable JAR file to use the tool.
    Suppose the exported JAR file is named `screenshot.jar`, then the following sample
    command uses it to take a screenshot from an emulator:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以导入项目并导出一个可执行的JAR文件来使用该工具。假设导出的JAR文件名为`screenshot.jar`，那么以下示例命令使用它从模拟器中截取屏幕：
- en: '![Taking screenshots from the command line](img/1505_03_12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![从命令行截取屏幕截图](img/1505_03_12.jpg)'
- en: Building an Android NDK application in Eclipse
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Eclipse中构建Android NDK应用程序
- en: The previous recipe discusses how to build an Android NDK application in the
    command line. This recipe demonstrates how to do it in the Eclipse IDE.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上一教程讨论了如何在命令行中构建Android NDK应用程序。本教程演示如何在Eclipse IDE中完成此操作。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Add NDK Preferences. Start Eclipse, then click on **Window** | **Preferences**.
    In the **Preferences** window, select **NDK** under **Android**. Click on **Browse**
    and select the NDK `root` folder. Click on **OK**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 添加NDK首选项。启动Eclipse，然后点击**窗口** | **首选项**。在**首选项**窗口中，选择**Android**下的**NDK**。点击**浏览**并选择NDK的`根`文件夹。点击**确定**。
- en: '![Getting ready](img/1505_03_13.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1505_03_13.jpg)'
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps create an NDK project using Eclipse:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤使用Eclipse创建一个NDK项目：
- en: Create an Android application named `HelloNDKEclipse`. Set the package name
    as `cookbook.chapter3`. Create an activity named `HelloNDKEclipseActivity`. Please
    refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*,
    if you want more detailed instructions.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HelloNDKEclipse`的Android应用程序。将包名设置为`cookbook.chapter3`。创建一个名为`HelloNDKEclipseActivity`的活动。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章. Java本地接口")，*Java Native Interface*中的*加载本地库和注册本地方法*教程。
- en: Right-click on the project `HelloNDKEclipse`, select **Android Tools** | **Add
    Native Support**. A window similar to the following screenshot will appear. Click
    on **Finish** to dismiss it:![How to do it…](img/1505_03_14.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目`HelloNDKEclipse`，选择**Android Tools** | **添加本地支持**。会出现一个类似以下截图的窗口。点击**完成**以关闭它：![如何操作…](img/1505_03_14.jpg)
- en: This will add a `jni` folder with two files (`HelloNDKEclipse.cpp` and `Android.mk`)
    inside, and switch Eclipse to C/C++ perspective.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在内部添加一个包含两个文件（`HelloNDKEclipse.cpp`和`Android.mk`）的`jni`文件夹，并将Eclipse切换到C/C++透视图。
- en: 'Add the following content to `HelloNDKEclipse.cpp`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`HelloNDKEclipse.cpp`中添加以下内容：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Change the content of HelloNDKEclipseActivity.java to below.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 HelloNDKEclipseActivity.java 的内容更改为以下内容。
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Right-click on `HelloNDKEclipse` project, and select **Build Project**. This
    will build the native library for us.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `HelloNDKEclipse` 项目，选择 **构建项目**。这将为我们构建本地库。
- en: Right-click on the project, go to **Run As**, and select **Android Application**.
    The phone screen will display something similar to the following screenshot:![How
    to do it…](img/1505_03_15.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目，选择 **运行方式**，然后选择 **Android 应用程序**。手机屏幕将显示类似于以下截图的内容：![如何操作…](img/1505_03_15.jpg)
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe discusses building the Android NDK application at Eclipse.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱讨论在 Eclipse 中构建 Android NDK 应用程序。
- en: We have been using C in all previous recipes. Starting from this recipe, we'll
    be writing our code in C++.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的食谱中我们一直在使用 C。从本食谱开始，我们将用 C++ 编写代码。
- en: 'By default, Android provides minimal C++ support. There''s no **Run-time Type
    Information** (**RTTI**) and C++ exceptions support, and even the C++ standard
    library support, is partial. The following is a list of the C++ headers supported
    by Android NDK by default:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Android 提供了最小的 C++ 支持。没有 **运行时类型信息** (**RTTI**) 和 C++ 异常支持，甚至 C++ 标准库支持也是部分的。以下是
    Android NDK 默认支持的 C++ 头文件列表：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is possible to add more C++ support by using different C++ libraries. NDK
    comes with the `gabi++`, `stlport`, and `gnustl` C++ libraries, besides the system
    default one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不同的 C++ 库，有可能增加对 C++ 的支持。NDK 除了系统默认库之外，还提供了 `gabi++`、`stlport` 和 `gnustl`
    C++ 库。
- en: In our sample code, we used an external "C" to wrap the C++ method. This is
    to avoid C++ mangling of the JNI function names. C++ name mangling could change
    the function names to include type information about parameters, whether the function
    is virtual or not, and so on. While this enables C++ to link overloaded functions,
    it breaks the JNI function discovery mechanism.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们使用了外部 "C" 来包装 C++ 方法。这样做是为了避免 JNI 函数名被 C++ 糟蹋。C++ 名称糟蹋可能会改变函数名以包含关于参数的类型信息，函数是否为虚函数等。虽然这使得
    C++ 能够链接重载函数，但它破坏了 JNI 函数发现机制。
- en: We can also use the explicit function registration method covered in the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, to get rid of the
    wrapping.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 [第2章](ch02.html "第2章。Java 本地接口") *Java Native Interface* 中 *加载本地库和注册本地方法*
    食谱中涵盖的显式函数注册方法来摆脱包装。
- en: Building an Android NDK application for different ABIs
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同的 ABI 构建一个 Android NDK 应用程序
- en: Native code is compiled into binaries. Therefore, one set of binaries can only
    run on a specific architecture. Android NDK comes with techniques and tools to
    allow developers to compile the same source code for multiple architectures easily.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本地代码被编译成二进制文件。因此，一组二进制文件只能在一个特定的架构上运行。Android NDK 提供了技术和工具，使开发者能够轻松地为多个架构编译相同的源代码。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: An **Application Binary Interface** (**ABI**) defines how the Android application's
    machine code is supposed to interact with the system at runtime, including the
    CPU instruction set, endianness, alignment of memory, and so on. An ABI basically
    defines a type of architecture.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **应用程序二进制接口** (**ABI**) 定义了 Android 应用程序的机器代码如何在运行时与系统交互，包括 CPU 指令集、字节序、内存对齐等。ABI
    基本上定义了一种架构类型。
- en: 'The following table briefly summarizes the four ABIs supported by Android:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下表简要总结了 Android 支持的四个 ABI：
- en: '| ABI name | Support | Not support | Optional |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ABI名称 | 支持 | 不支持 | 可选 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `armeabi` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `armeabi` |'
- en: ARMv5TE instruction set
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv5TE 指令集
- en: Thumb (also known as Thumb-1) instructions
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thumb（也称为 Thumb-1）指令
- en: '| Hardware-assisted floating point computation |   |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 硬件辅助浮点计算 |   |'
- en: '| `armeabi-v7a` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `armeabi-v7a` |'
- en: Whatever is supported in `armeabi`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`armeabi` 支持的所有内容'
- en: VFP hardware FPU instructions
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFP 硬件 FPU 指令
- en: Thumb-2 instruction set
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thumb-2 指令集
- en: VFPv3-D16 is used.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFPv3-D16 被使用。
- en: '|   |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: Advanced SIMD (also known as NEON)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 SIMD（也称为 NEON）
- en: VFPv3-D32
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFPv3-D32
- en: ThumbEE
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ThumbEE
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `x86` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `x86` |'
- en: Instruction set commonly known as "x86" or "IA-32".
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常称为 "x86" 或 "IA-32" 的指令集。
- en: MMX, SSE, SSE2, and SSE3 instruction set extensions
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MMX、SSE、SSE2 和 SSE3 指令集扩展
- en: '|   |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: MOVBE instruction
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MOVBE 指令
- en: SSSE3 "supplemental SSE3" extension
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSSE3 "补充 SSE3" 扩展
- en: Any variant of "SSE4"
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 "SSE4" 的变体
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `mips` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `mips` |'
- en: MIPS32r1 instruction set
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIPS32r1 指令集
- en: Hard-Float
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬浮点
- en: O32
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O32
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: DSP application specific extension
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSP 应用特定扩展
- en: MIPS16
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIPS16
- en: micromips
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: micromips
- en: '|   |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: 'armeabi and armeabi-v7a are the two most commonly used ABIs for Android devices.
    ABI armeabi-v7a is compatible with armeabi, which means applications compiled
    for armeabi can run on armeabi-v7a too. But the reverse is not true, since armeabi-v7a
    includes additional features. In the following section, we briefly introduce some
    technical terms referred to frequently in armeabi and armeabi-v7a:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: armeabi和armeabi-v7a是Android设备最常用的两种ABI。ABI armeabi-v7a与armeabi兼容，这意味着为armeabi编译的应用程序也可以在armeabi-v7a上运行。但反之则不成立，因为armeabi-v7a包含额外的功能。在以下部分中，我们将简要介绍在armeabi和armeabi-v7a中经常提到的一些技术术语。
- en: '**Thumb**: This instruction set consists of 16-bit instructions, which is a
    subset of the 32-bit instruction set of the standard ARM. Some instructions in
    the 32-bit instruction set are not available for Thumb, but can be simulated with
    several Thumb instructions. The narrower 16-bit instruction set can offer memory
    advantages.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thumb**：这个指令集由16位指令组成，是标准ARM 32位指令集的一个子集。某些32位指令集中的指令在Thumb中不可用，但可以用几个Thumb指令来模拟。更窄的16位指令集可以提供内存优势。'
- en: Thumb-2 extends Thumb-1 by adding some 32-bit instructions, which results in
    a variable-length instruction set. Thumb-2 aims to attain code density like to
    Thumb-1 and performance similar to standard ARM instruction set on a 32-bit memory.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Thumb-2通过添加一些32位指令扩展了Thumb-1，从而形成了一种可变长度指令集。Thumb-2旨在像Thumb-1一样实现代码密度，并在32位内存上实现与标准ARM指令集相似的性能。
- en: Android NDK generates the thumb code by default, unless `LOCAL_ARM_MODE` is
    defined in the `Android.mk` file.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android NDK默认生成thumb代码，除非在 `Android.mk` 文件中定义了 `LOCAL_ARM_MODE`。
- en: '**Vector Floating Point (VFP)**: It is an extension to the ARM processor, which
    provides low cost floating point computation.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量浮点（VFP）**：它是ARM处理器的扩展，提供了低成本的浮点计算功能。'
- en: '**VFPv3-D16 and VFPv3-D32**: VFPv3-D16 refers to 16 dedicated 64-bit floating
    point registers. Similarly, VFPv3-D32 means there are 32 64-bit floating point
    registers. These registers speed up floating point computation.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VFPv3-D16和VFPv3-D32**：VFPv3-D16指的是16个专用的64位浮点寄存器。同样，VFPv3-D32意味着有32个64位浮点寄存器。这些寄存器加速了浮点计算。'
- en: '**NEON**: NEON is the nickname for the ARM **Advanced Single Instruction Multiple
    Data** (**SIMD**) instruction set extension. It requires VFPv3-D32, which means
    32 hardware FPU 64-bit registers will be used. It provides a set of scalar/vector
    instructions and registers, which are comparable to MMX/SSE/SDNow! in the x86
    world. It is not supported by all Android devices, but many new devices have NEON
    support. NEON can accelerate media and signal processing applications significantly
    by executing up to 16 operations simultaneously.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NEON**：NEON是ARM **高级单指令多数据（SIMD）** 指令集扩展的昵称。它需要VFPv3-D32支持，这意味着将使用32个硬件浮点单元64位寄存器。它提供了一系列标量/向量指令和寄存器，这些在x86世界中与MMX/SSE/SDNow!相当。并非所有Android设备都支持NEON，但许多新设备已经具备NEON支持。NEON可以通过同时执行多达16个操作，显著加速媒体和信号处理应用程序。'
- en: One can refer to ARM documentation website at [http://infocenter.arm.com/help/index.jsp](http://infocenter.arm.com/help/index.jsp)
    for more detailed information. We don't discuss x86 and mips ABI here, because
    few Android devices run on these architecture.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更详细信息，可以参考ARM文档网站 [http://infocenter.arm.com/help/index.jsp](http://infocenter.arm.com/help/index.jsp)。这里我们不讨论x86和mips
    ABI，因为很少有Android设备运行在这些架构上。
- en: Read the *Building Android NDK Application at Eclipse* recipe before going through
    this one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这一步之前，请阅读 *在Eclipse中构建Android NDK应用程序* 的菜谱。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行操作...
- en: 'The following steps build an Android project for different ABIs:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤为不同的ABI构建Android项目：
- en: Create an Android application named `HelloNDKMultipleABI`. Set the package name
    as `cookbook.chapter3`. Create an activity named `HelloNDKMultipleABIActivity`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HelloNDKMultipleABI` 的Android应用程序。将包名设置为 `cookbook.chapter3`。创建一个名为
    `HelloNDKMultipleABIActivity` 的活动。
- en: Right-click on the `HelloNDKMultipleABI` project, select **Android Tools** |
    **Add Native Support**. A window appears, click on **Finish** to dismiss it. This
    will add a `jni` folder with two files (`HelloNDKMultipleABI.cpp` and `Android.mk`)
    inside, and switch Eclipse to the C/C++ perspective.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `HelloNDKMultipleABI` 项目，选择 **Android Tools** | **Add Native Support**。出现一个窗口，点击
    **Finish** 关闭它。这将添加一个包含两个文件（`HelloNDKMultipleABI.cpp` 和 `Android.mk`）的 `jni` 文件夹，并将Eclipse切换到C/C++视角。
- en: 'Add the following content to the `HelloNDKMultipleABI.cpp` file:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HelloNDKMultipleABI.cpp` 文件中添加以下内容：
- en: '[PRE24]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Change the `HelloNDKMultipleABIActivity.java` file to the following content:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `HelloNDKMultipleABIActivity.java` 文件更改为以下内容：
- en: '[PRE25]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new file named `Application.mk` under the project''s `jni` folder with
    the following content:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`jni`文件夹下添加一个名为`Application.mk`的新文件，内容如下：
- en: '[PRE26]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Right-click on the `HelloNDKMultipleABIActivity` project, and select **Build
    Project**. This will build the native library for us.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`HelloNDKMultipleABIActivity`项目，选择**构建项目**。这将为我们构建原生库。
- en: Create two emulators, with ABI set to `armeabi` and `armeabi-v7a` respectively.
    The following screenshot depicts how an emulator is created with the `armeabi`
    ABI:![How to do it...](img/1505_03_16.jpg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个模拟器，分别将ABI设置为`armeabi`和`armeabi-v7a`。以下截图展示了如何创建一个ABI为`armeabi`的模拟器：![如何操作...](img/1505_03_16.jpg)
- en: Run the sample Android application on the two emulators. The same result is
    shown on both of them:![How to do it...](img/1505_03_17.jpg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个模拟器上运行示例Android应用程序。在它们上面显示的结果相同：![如何操作...](img/1505_03_17.jpg)
- en: 'Change the content of `Application.mk` to the following code snippet and run
    the sample application on the two emulators. The application will still work on
    both the emulators:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Application.mk`的内容更改为以下代码片段，并在两个模拟器上运行示例应用程序。应用程序仍然可以在两个模拟器上运行：
- en: '[PRE27]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Change the content of `Application.mk` as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Application.mk`的内容更改如下：
- en: '[PRE28]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the sample application on the two emulators. The application works on the
    `armeabi-v7a` emulator, but crashes on `armeabi` emulator, as shown in the following
    screenshot:![How to do it...](img/1505_03_18.jpg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个模拟器上运行示例应用程序。应用程序在`armeabi-v7a`模拟器上运行，但在`armeabi`模拟器上会崩溃，如下面的截图所示：![如何操作...](img/1505_03_18.jpg)
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: An Android device can define one or two ABIs. For typical x86-, MIPS-, ARMv5-,
    and ARMv6-based devices, there's only a primary ABI. Based on the platform, it
    can be x86, mips, or armeabi. For a typical ARMv7-based device, the primary ABI
    is usually armeabi-v7a, and it also has a secondary ABI as armeabi. This enables
    binaries compiled for either armeabi or armeabi-v7a to run on ARMv7 devices. In
    our example, we demonstrated that the app can work on both armeabi and armeabi-v7a
    emulators when built against only armeabi.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Android设备可以定义一个或两个ABI。对于基于x86、MIPS、ARMv5和ARMv6的典型设备，只有一个首要ABI。根据平台，它可以是x86、mips或armeabi。对于基于典型ARMv7的设备，首要ABI通常是armeabi-v7a，它还有一个次要ABI为armeabi。这使得编译为armeabi或armeabi-v7a的二进制文件可以在ARMv7设备上运行。在我们的示例中，我们证明了当只针对armeabi构建时，应用程序可以在armeabi和armeabi-v7a模拟器上运行。
- en: At installation, the Android package manager searches for native libraries built
    for the primary ABI and copies them to the application's data directory. If not
    found, it then searches the native libraries built for the secondary ABI. This
    ensures that only the proper native libraries are installed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装时，Android包管理器会搜索为首要ABI构建的原生库，并将其复制到应用程序的数据目录中。如果没有找到，它会搜索为次要ABI构建的原生库。这确保只有正确的原生库被安装。
- en: In our example, when we compile the binary against armeabi-v7a only, the native
    library won't get installed on the armeabi emulator, subsequently the native library
    cannot be loaded, and a crash will be shown.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，当我们只针对armeabi-v7a编译二进制文件时，原生库将不会安装在armeabi模拟器上，因此无法加载原生库，并且会显示崩溃。
- en: Building Android NDK applications for different CPU features
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同的CPU特性构建Android NDK应用程序
- en: Many projects use native code to improve performance. One advantage of developing
    in NDK over SDK is that we can build different packages for different CPUs, which
    is the topic of this recipe.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目使用原生代码以提高性能。与SDK开发相比，在NDK中开发的一个优点是我们可以为不同的CPU构建不同的包，这正是本食谱的主题。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please read the *Building Android NDK application for different ABIs* recipe
    before going through this one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本食谱之前，请阅读《为不同ABI构建Android NDK应用程序》的食谱。
- en: How to do it…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The following steps build Android NDK applications for different CPU features.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤为不同的CPU特性构建Android NDK应用程序。
- en: At Eclipse, click on **File** | **New** | **Other**. Select **Android Project**
    from **Existing Code** under **Android** as shown in the following screenshot.
    Then click on **Next**:![How to do it…](img/1505_03_19.jpg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中，点击**文件** | **新建** | **其他**。在**Android**下选择**现有代码**中的**Android项目**，如下面的截图所示。然后点击**下一步**：![如何操作…](img/1505_03_19.jpg)
- en: Browse to the `samples/hello-neon` folder of the Android NDK folder. Then click
    on **Finish**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到Android NDK文件夹中的`samples/hello-neon`文件夹。然后点击**完成**。
- en: Start a terminal, then go to the `samples/hello-neon/jni` folder. Type the command
    "`ndk-build`" to build the binaries.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动终端，然后进入`samples/hello-neon/jni`文件夹。输入命令"`ndk-build`"以构建二进制文件。
- en: 'Run the Android project on different devices and emulators. Based on your device/emulator
    ABI and availability of the NEON feature, you should be able to see the results
    as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的设备和模拟器上运行安卓项目。根据你的设备/模拟器ABI和NEON特性的可用性，你应该能够看到如下结果：
- en: For Android device with armeabi ABI, the result is as follows:![How to do it…](img/1505_03_20.jpg)
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有armeabi ABI的安卓设备，结果如下：![如何操作…](img/1505_03_20.jpg)
- en: 'For Android device with armeabi-v7a ABI and NEON, the result is as follows:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有armeabi-v7a ABI和NEON的安卓设备，结果如下：
- en: '![How to do it…](img/1505_03_21.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_21.jpg)'
- en: How it works…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Android devices are roughly divided by ABIs. However, different devices with
    the same ABI can have different CPU extensions and features. These extensions
    and features are optional and therefore we don't know whether a user's device
    has them until runtime. Detecting and making use of these features can sometimes
    improve app performance significantly on certain devices.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备大致可以通过ABIs来划分。然而，具有相同ABI的不同设备可能有不同的CPU扩展和特性。这些扩展和特性是可选的，因此我们在运行时之前无法知道用户的设备是否具备这些特性。在某些设备上，检测并利用这些特性有时可以显著提高应用性能。
- en: 'Android NDK contains a library named `cpufeatures`, which can be used to detect
    the CPU family and optional features at runtime. As illustrated in the sample
    code, the following steps indicate how to use this library:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓NDK包含一个名为`cpufeatures`的库，可以在运行时用来检测CPU家族和可选特性。正如示例代码所示，以下步骤指示如何使用这个库：
- en: 'Add it in the static library list in `Android.mk` as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Android.mk`的静态库列表中添加，如下所示：
- en: '[PRE29]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the end of the `Android.mk` file, import the `cpufeatures` module:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Android.mk`文件的末尾，导入`cpufeatures`模块：
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the code, include the header file `<cpu-features.h>`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中，包含头文件`<cpu-features.h>`。
- en: 'Call detection functions; Currently `cpufeatures` provides only three functions:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用检测函数；目前`cpufeatures`只提供三个函数：
- en: 'Get the CPU family. The function prototype is as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取CPU家族。函数原型如下：
- en: '[PRE31]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It returns an enum. The supported CPU families are listed in the section to
    follow.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它返回一个枚举。支持的CPU系列在下面的章节中列出。
- en: '[PRE32]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Get the optional CPU features. Each CPU feature is represented by a bit flag
    and the bit is set to `1` if the feature is available. The function prototype
    is as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取可选的CPU特性。每个CPU特性由一个位标志表示，如果特性可用，该位设置为`1`。函数原型如下：
- en: '[PRE33]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For the ARM CPU family, the supported CPU feature detections are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ARM CPU家族，支持的CPU特性检测如下：
- en: '`ANDROID_CPU_ARM_FEATURE_ARMv7`: It means that the ARMv7-a instruction is supported.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_CPU_ARM_FEATURE_ARMv7`：这意味着支持ARMv7-a指令。'
- en: '`ANDROID_CPU_ARM_FEATURE_VFPv3`: It means that the VFPv3 hardware FPU instruction
    set extension is supported. Note that this refers to VFPv3-D16, which provides
    16 hardware FP registers.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_CPU_ARM_FEATURE_VFPv3`：这意味着支持VFPv3硬件FPU指令集扩展。请注意，这里指的是VFPv3-D16，它提供16个硬件浮点寄存器。'
- en: '`ANDROID_CPU_ARM_FEATURE_NEON`: It means that he ARM Advanced SIMD (also known
    as NEON) vector instruction set extension is supported. Note that such CPUs also
    support VFPv3-D32, which provides 32 hardware FP registers.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_CPU_ARM_FEATURE_NEON`：这意味着支持ARM高级SIMD（也称为NEON）向量指令集扩展。请注意，这样的CPU也支持VFPv3-D32，它提供32个硬件浮点寄存器。'
- en: 'For the x86 CPU family, the supported CPU feature detections are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x86 CPU家族，支持的CPU特性检测如下：
- en: '`ANDROID_CPU_X86_FEATURE_SSSE3`: It means that the `SSSE3` instruction extension
    set is supported.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_CPU_X86_FEATURE_SSSE3`：这意味着支持`SSSE3`指令扩展集。'
- en: '`ANDROID_CPU_X86_FEATURE_POPCNT`: It means that the `POPCNT` instruction is
    supported.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_CPU_X86_FEATURE_POPCNT`：这意味着支持`POPCNT`指令。'
- en: '`ANDROID_CPU_X86_FEATURE_MOVBE`: It means that the `MOVBE` instruction is supported.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_CPU_X86_FEATURE_MOVBE`：这意味着支持`MOVBE`指令。'
- en: 'We can do a "`&`" operation to detect if a feature is available or not, as
    follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行"`&`"操作来检测一个特性是否可用，如下所示：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Get the number of CPU cores on the device:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 获取设备上的CPU核心数：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since NDK r8c, more CPU feature detections are available. Please refer to `sources/android/cpufeatures/cpu-features.c`
    for more details.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 自从NDK r8c以来，更多的CPU特性检测可用。更多详情请参考`sources/android/cpufeatures/cpu-features.c`。
- en: There's more…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are a few more noteworthy points about CPU features on Android.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安卓上的CPU特性还有几个值得注意的点。
- en: More about CPU feature detection
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于CPU特性检测的更多信息
- en: 'The `cpufeatures` library can only detect a limited set of CPU features. It
    is possible to implement our own CPU detection mechanisms. By looking at the NDK
    source code at `/sources/android/cpufeatures/`, one can find that the `cpufeatures`
    library essentially looks at the `/proc/cpuinfo` file. We can read this file and
    parse the content in our application. The following is a screenshot of the file
    content:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpufeatures`库只能检测有限的CPU特性集。我们可以实现自己的CPU检测机制。通过查看NDK源代码在`/sources/android/cpufeatures/`，可以发现`cpufeatures`库本质上查看的是`/proc/cpuinfo`文件。我们可以读取这个文件，并在我们的应用程序中解析内容。以下是文件内容的截图：'
- en: '![More about CPU feature detection](img/1505_03_22.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![关于CPU特性检测的更多信息](img/1505_03_22.jpg)'
- en: Please refer to the Android project `cpuinfo`, available in the book's website
    for how to do this programmatically.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本书网站上的Android项目`cpuinfo`，了解如何通过编程方式实现这一点。
- en: Different approaches of building for different cpu features
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为不同的CPU特性构建的不同方法
- en: 'There are a few approaches to building native code for different CPU features:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同的CPU特性构建本地代码有几种方法：
- en: '**Single library, different binaries at build time**: This is demonstrated
    in the sample project. The `helloneon-intrinsics.c` file is only compiled for
    armeabi-v7a ABI.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一库，构建时不同的二进制文件**：这也在示例项目中演示。`helloneon-intrinsics.c`文件仅针对armeabi-v7a ABI编译。'
- en: '**Single library, different execution paths at runtime**: This is also shown
    in the sample project. The code detects whether the NEON feature is available
    or not at runtime and executes different code blocks.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一库，运行时不同的执行路径**：这也在示例项目中展示。代码在运行时检测NEON特性是否可用，并执行不同的代码块。'
- en: '**Different libraries, load appropriate library at runtime**: Sometimes, we
    may want to compile the source code into different libraries and differentiate
    them by names. For example, we may have `libmylib-neon.so` and `libmylib-vfpv3.so`
    . We detect the CPU feature at runtime and load the appropriate library.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同库，运行时加载适当的库**：有时，我们可能希望将源代码编译成不同的库，并通过名称区分它们。例如，我们可能有`libmylib-neon.so`和`libmylib-vfpv3.so`。我们在运行时检测CPU特性并加载适当的库。'
- en: '**Different packages, load appropriate library at runtime**: If the library
    is big, it is desirable to deploy different binaries for different CPUs as separate
    packages. This is done by many video players available on Google Play (for example,
    MX Player).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同包，运行时加载适当的库**：如果库很大，最好为不同的CPU部署不同的二进制文件作为单独的包。这是Google Play上许多视频播放器（例如MX
    Player）的做法。'
- en: Debugging an Android NDK application with logging messages
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志消息调试Android NDK应用程序
- en: Android logging system provides a method for collecting logs from various applications
    into a series of circular buffers. The `logcat` command is used to view the logs.
    Log message is the simplest method of debugging a program, yet one of the most
    powerful ones. This recipe focuses on message logging in NDK.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Android日志系统提供了一种从各种应用程序收集日志到一系列循环缓冲区的方法。使用`logcat`命令查看日志。日志消息是调试程序最简单的方法之一，也是最强大的方法之一。本食谱重点关注NDK中的消息日志记录。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'The following steps create our sample Android project:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤创建我们的示例Android项目：
- en: Create an Android application named `NDKLoggingDemo`. Set the package name as
    `cookbook.chapter3`. Create an activity named `NDKLoggingDemoActivity`. Please
    refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*,
    if you want more detailed instructions.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NDKLoggingDemo`的Android应用程序。将包名设置为`cookbook.chapter3`。创建一个名为`NDKLoggingDemoActivity`的活动。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章. Java Native Interface")，*Java Native Interface*中的*加载本地库和注册本地方法*食谱。
- en: Right-click on the project `NDKLoggingDemo`, select **Android Tools** | **Add
    Native Support**. A window appears, click on **Finish** to dismiss it.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目`NDKLoggingDemo`，选择**Android Tools** | **Add Native Support**。出现一个窗口，点击**Finish**关闭它。
- en: 'Add a new file named `mylog.h` under the `jni` folder, and add the following
    content to it:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加一个名为`mylog.h`的新文件，并向其中添加以下内容：
- en: '[PRE36]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following content to `NDKLoggingDemo.cpp`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`NDKLoggingDemo.cpp`添加以下内容：
- en: '[PRE37]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the content of `NDKLoggingDemoActivity.java` to the following:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`NDKLoggingDemoActivity.java`的内容为以下：
- en: '[PRE38]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Change the `Android.mk` file to include the Android log library as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Android.mk`文件，如下包含Android日志库：
- en: '[PRE39]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Right-click on the `NDKLoggingDemo` project, and select **Build Project**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`NDKLoggingDemo`项目，并选择**Build Project**。
- en: 'Start the monitor logcat output by entering the following command. Then, start
    the sample Android app on an Android device:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令开始监控`logcat`输出。然后，在Android设备上启动示例Android应用：
- en: '[PRE40]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is a screenshot of the logcat output:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是`logcat`输出的屏幕截图：
- en: '![How to do it…](img/1505_03_23.jpg)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_23.jpg)'
- en: 'Start another command line terminal, and enter the following command in it:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动另一个命令行终端，并在其中输入以下命令：
- en: '[PRE41]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will result into the following output:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![How to do it…](img/1505_03_24.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_03_24.jpg)'
- en: Change the line in `mylog.h` from `#define LOG_LEVEL 9` to `#define LOG_LEVEL
    4`. Rebuild the application, then restart the application.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mylog.h`中的行从`#define LOG_LEVEL 9`更改为`#define LOG_LEVEL 4`。重新构建应用程序，然后重新启动应用程序。
- en: The outputs of the two terminals we started earlier are the same.![How to do
    it…](img/1505_03_25.jpg)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前启动的两个终端的输出是相同的。![如何操作…](img/1505_03_25.jpg)
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe shows how to use Android log messages. Each log message in Android
    consists of the following three parts:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了如何使用Android日志消息。Android中的每个日志消息由以下三部分组成：
- en: '**Priority**: It is usually used to filter log messages. In our project, we
    can control the log by changing the following code:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：通常用于过滤日志消息。在我们的项目中，我们可以通过更改以下代码来控制日志：'
- en: '[PRE42]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Alternatively, we can selectively display the log output using `logcat`.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`logcat`有选择性地显示日志输出。
- en: '**Log tag**: It is usually used to identify the log source.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志标签**：通常用于标识日志来源。'
- en: '**Log message**: It provides the detailed log message.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志信息**：它提供了详细的日志信息。'
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Sending log messages on Android consumes CPU resources and frequent log messages
    can affect the application performance. In addition, the logs are stored in a
    circular buffer. Too many logs will overwrite some earlier logs, which may not
    be desirable. Due to these facts, it is recommended we only log errors and exceptions
    at the release build.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上发送日志消息会消耗CPU资源，频繁的日志消息可能会影响应用程序性能。此外，日志存储在一个循环缓冲区中。过多的日志会覆盖一些早期的日志，这可能是我们不希望看到的。由于这些原因，建议我们在发布版本中只记录错误和异常。
- en: '`logcat` is the command-line tool to view Android logs. It allows one to filter
    logs according to the log tag and priority. It is also capable of dispalying logs
    in different formats.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`logcat`是查看Android日志的命令行工具。它可以根据日志标签和优先级过滤日志，并能够以不同的格式显示日志。'
- en: For example, we used the following `logcat` command in step 8 of the preceding
    *How to do it...* section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面*如何操作…*部分的步骤8中，我们使用了以下`logcat`命令。
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The command filters out logs except those with the `NDKLoggingDemo` tag and
    priority `I` (information) or higher. The filter is given in a `tag:priority`
    format. `NDKLoggingDemo:I` indicates logs with a `NDKLoggingDemo` tag and priority
    information or higher will be displayed. `*:S` sets the priority level for all
    other tags as "silent".
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令过滤除了具有`NDKLoggingDemo`标签和优先级`I`（信息）或更高优先级的日志。过滤器以`tag:priority`格式给出。`NDKLoggingDemo:I`表示将显示具有`NDKLoggingDemo`标签和优先级信息或更高的日志。`*:S`将所有其他标签的优先级设置为“静默”。
- en: More details about logcat filtering and format can be found at [http://developer.android.com/tools/help/logcat.html](http://developer.android.com/tools/help/logcat.html)
    and [http://developer.android.com/tools/debugging/debugging-log.html#outputFormat](http://developer.android.com/tools/debugging/debugging-log.html#outputFormat).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`logcat`过滤和格式的更多详细信息可以在[http://developer.android.com/tools/help/logcat.html](http://developer.android.com/tools/help/logcat.html)和[http://developer.android.com/tools/debugging/debugging-log.html#outputFormat](http://developer.android.com/tools/debugging/debugging-log.html#outputFormat)找到。
- en: Debugging an Android NDK application with CheckJNI
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`CheckJNI`调试Android NDK应用程序
- en: JNI does little error checking for better performance. As a result, errors usually
    lead to a crash. A mode called `CheckJNI` is offered by Android. In this mode,
    a set of JNI functions with extended checks are called instead of the normal JNI
    functions. This recipe discusses how to enable the CheckJNI mode to debug Android
    NDK applications.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: JNI为了更好的性能，错误检查很少。因此，错误通常会导致崩溃。Android提供了一个名为`CheckJNI`的模式。在这个模式下，将调用具有扩展检查的JNI函数集，而不是正常的JNI函数。本食谱讨论如何启用`CheckJNI`模式以调试Android
    NDK应用程序。
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps create a sample Android project and enable the `CheckJNI`
    mode:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤创建一个示例Android项目并启用`CheckJNI`模式：
- en: Create an Android application named `CheckJNIDemo`. Set the package name as
    `cookbook.chapter3`. Create an activity named `CheckJNIDemoActivity`. Please refer
    to the *Loading native libraries and registering native methods* recipe of [Chapter
    2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*, if
    you want more detailed instructions.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CheckJNIDemo`的Android应用程序。将包名设置为`cookbook.chapter3`。创建一个名为`CheckJNIDemoActivity`的活动。如果你想获得更详细的说明，请参考[第2章](ch02.html
    "第2章. Java Native Interface")中的*加载本地库和注册本地方法*菜谱。
- en: Right-click on the project `CheckJNIDemo`, select **Android Tools** | **Add
    Native Support**. A window appears; click on **Finish** to dismiss it.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目`CheckJNIDemo`，选择**Android Tools** | **添加本地支持**。会出现一个窗口；点击**完成**以关闭它。
- en: Add the following content to `CheckJNIDemo.cpp`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`CheckJNIDemo.cpp`添加以下内容。
- en: 'Change `CheckJNIDemoActivity.java` to the following:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CheckJNIDemoActivity.java`更改为以下内容：
- en: '[PRE44]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Right-click on `CheckJNIDemo` project, and select **Build Project**.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`CheckJNIDemo`项目，并选择**构建项目**。
- en: Start the monitor logcat output by entering "`adb logcat -v time`" on a command-line
    console. Then, start the sample Android app on an Android device. The application
    will crash, and the logcat output will be displayed as follows:![How to do it...](img/1505_03_35.jpg)
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行控制台输入"`adb logcat -v time`"启动monitor logcat输出。然后在Android设备上启动示例Android应用。应用程序将崩溃，logcat输出将如下显示：![如何操作...](img/1505_03_35.jpg)
- en: Enable CheckJNI.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用CheckJNI。
- en: When the emulator is being used by you, the CheckJNI is on by default.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用模拟器时，CheckJNI默认是开启的。
- en: If you're using a rooted device, the following sequence of commands can be used
    to restart the runtime with CheckJNI enabled. The commands stop the running Android
    instance, change the system properties to enable CheckJNI, and then restart Android.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是已获得root权限的设备，可以使用以下命令序列重新启动启用了CheckJNI的运行时。这些命令停止正在运行的Android实例，更改系统属性以启用CheckJNI，然后重新启动Android。
- en: '[PRE45]'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you have a regular device, you can use the following command:'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个常规设备，你可以使用以下命令：
- en: '[PRE46]'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the Android application again. The logcat output will be displayed as follows:![How
    to do it...](img/1505_03_26.jpg)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行Android应用程序。logcat输出将如下显示：![如何操作...](img/1505_03_26.jpg)
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The CheckJNI mode uses a set of JNI functions, which have more error checking
    than the default one. This makes it easier to find JNI programming bugs. The CheckJNI
    mode currently checks the following errors:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: CheckJNI模式使用一组JNI函数，这些函数比默认的具有更多的错误检查。这使得查找JNI编程错误变得更加容易。目前，CheckJNI模式检查以下错误：
- en: '**Negative-sized array**: It attempts to allocate an array of negative size.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负尺寸数组**：它尝试分配一个负尺寸的数组。'
- en: '**Bad reference**: It passes a bad reference `jarray`/`jclass`/`jobject`/`jstring`
    to a JNI function. Passing `NULL` to JNI function expecting a non-NULL argument.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误引用**：它向JNI函数传递了错误的引用`jarray`/`jclass`/`jobject`/`jstring`。向期望非`NULL`参数的JNI函数传递`NULL`。'
- en: '**Class names**: It passes the class names of invalid style to the JNI function.
    Valid class names are separate by "`/`" as in "`java`/`lang`/`String`".'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类名**：它向JNI函数传递了无效样式的类名。有效的类名由"`/`"分隔，例如"`java`/`lang`/`String`"。'
- en: '**Critical calls**: It calls a JNI function between a "critical" get function
    and its corresponding release.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键调用**：它在“关键”get函数及其相应的释放之间调用一个JNI函数。'
- en: '**Exceptions**: It calls a JNI function when there''s a pending exception.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常**：它在有挂起异常时调用JNI函数。'
- en: '**jfieldIDs**: It invalidates `jfieldIDs` or assigns `jfieldIDs` from one type
    to another.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jfieldIDs**：它会无效化`jfieldIDs`或将`jfieldIDs`从一个类型赋值给另一个类型。'
- en: '**jmethodIDs**: It''s similar to jfieldIDs.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jmethodIDs**：它与jfieldIDs类似。'
- en: '**References**: It uses `DeleteGlobalRef`/`DeleteLocalRef` on references of
    wrong types.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用**：它对错误类型的引用使用`DeleteGlobalRef`/`DeleteLocalRef`。'
- en: '**Release mode**: It passes a release mode other than `0`, `JNI_ABORT`, and
    `JNI_COMMIT` to a release call.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放模式**：它向释放调用传递了除了`0`、`JNI_ABORT`和`JNI_COMMIT`之外的释放模式。'
- en: '**Type safety**: It returns an incompatible type from a native method.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：它从一个本地方法返回了不兼容的类型。'
- en: '**UTF-8**: It passes invalid modified UTF-8 string to JNI functions.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UTF-8**：它向JNI函数传递了无效的修改后的UTF-8字符串。'
- en: 'More error checking may be added to CheckJNI as Android evolves. Currently,
    the following checks are not supported:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Android的发展，可能会向CheckJNI中添加更多的错误检查。目前，以下检查还不受支持：
- en: Misuse of local references
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地引用的误用
- en: Debugging an Android NDK application with NDK GDB
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NDK GDB调试Android NDK应用程序
- en: Android NDK introduces a shell script named `ndk-gdb` to help one to launch
    a debugging session to debug the native code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK引入了一个名为`ndk-gdb`的shell脚本，帮助启动一个调试会话来调试本地代码。
- en: Getting ready
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project must meet the following requirements in order to debug it with
    `ndk-gdb`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ndk-gdb`调试项目，项目必须满足以下要求：
- en: The application is built with the `ndk-build` command.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是通过`ndk-build`命令构建的。
- en: '`AndroidManifest.xml` has the `android:debuggable` attribute of the `<application>`
    element set to `true`. This indicates that the application is debuggable even
    when it is running on a device in the user mode.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`中的`<application>`元素的`android:debuggable`属性设置为`true`。这表示即使应用程序在用户模式下运行在设备上，应用程序也是可调试的。'
- en: The application should be running on Android 2.2 or higher.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该在Android 2.2或更高版本上运行。
- en: Please read the *Building Android NDK Application at Eclipse* recipe before
    going through this one.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这一步之前，请阅读*在Eclipse中构建Android NDK应用程序*的菜谱。
- en: How to do it...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps create a sample Android project and debug it using NDK GDB.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤创建一个示例Android项目，并使用NDK GDB进行调试。
- en: Create an Android application named `HelloNDKGDB`. Set the package name as `cookbook.chapter3`.
    Create an activity named `HelloNDKGDBActivity`. Please refer to the *Loading native
    libraries and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HelloNDKGDB`的Android应用程序。将包名设置为`cookbook.chapter3`。创建一个名为`HelloNDKGDBActivity`的活动。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章。Java本地接口")，*Java Native Interface*中的*加载本地库和注册本地方法*的菜谱。
- en: Right-click on the project `HelloNDKGDB`, select **Android Tools** | **Add Native
    Support**. A window appears; click on **Finish** to dismiss it.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目`HelloNDKGDB`，选择**Android Tools** | **添加本地支持**。会出现一个窗口；点击**完成**关闭它。
- en: 'Add the following code to `HelloNDKGDB.cpp`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`HelloNDKGDB.cpp`文件中添加以下代码：
- en: '[PRE47]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Change the content of `HelloNDKGDBActivity.java` to the following:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HelloNDKGDBActivity.java`的内容更改为以下内容：
- en: '[PRE48]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Make sure that the `debuggable` attribute in `AndroidManifest.xml` is set to
    `true`. The following code snippet is a part of the application element extracted
    from `AndroidManifest.xml` of our sample project:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`AndroidManifest.xml`中的`debuggable`属性设置为`true`。以下代码段是从我们示例项目的`AndroidManifest.xml`中的应用程序元素中提取的一部分：
- en: '[PRE49]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Build the native library with the command "`ndk-build NDK_DEBUG=1`". Alternatively,
    we can configure the `build` command at Eclipse under **C/C++ Build** of the project
    **Properties**. This is demonstrated in the *Debugging Android NDK application
    at Eclipse* recipe .
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令"`ndk-build NDK_DEBUG=1`"构建本地库。或者，我们可以在Eclipse中配置项目的**属性**下的**C/C++ Build**中的`build`命令。这在*在Eclipse中调试Android
    NDK应用程序*的菜谱中有演示。
- en: 'Run the application on an Android device. Then, start a terminal and enter
    the following command:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android设备上运行应用程序。然后，启动一个终端并输入以下命令：
- en: '[PRE50]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Once the debugger is attached to the remote process, we can issue GDB commands
    to start debugging the app. This is shown as follows:![How to do it...](img/1505_03_27.jpg)
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调试器连接到远程进程，我们就可以发出GDB命令开始调试应用程序。如下所示：![如何操作...](img/1505_03_27.jpg)
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Along with Android NDK comes a shell script named as `ndk-gdb` to launch a native
    debugging session with the native code. In order to use `ndk-gdb`, we must build
    the native code in the debug mode. This will produce a `gdbserver` binary and
    a `gdb.setup` file along with the native library. At installation, `gdbserver`
    will be installed and `ndk-gdb` will start `gdbserver` on the Android device.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 随Android NDK附带的名为`ndk-gdb`的shell脚本可以启动本地调试会话与本地代码。为了使用`ndk-gdb`，我们必须以调试模式构建本地代码。这将生成一个`gdbserver`二进制文件和一个`gdb.setup`文件以及本地库。在安装时，`gdbserver`将被安装并在Android设备上启动`gdbserver`。
- en: By default, `ndk-gdb` searches for a running application and attaches `gdbserver`
    to it. There also are options to launch the application automatically before starting
    the debugging. Because the application starts first before `gdbserver` is attached
    to it, some code will be executed before debugging. If we want to debug the code
    that is executed at the application start up, we can insert a `while(true)` block.
    After the debugging session starts, we change the flag value to escape from the
    `while(true)`block. This is demonstrated in our sample project.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ndk-gdb`会搜索正在运行的应用程序，并将`gdbserver`附加到它上面。也有选项可以在开始调试之前自动启动应用程序。因为应用程序在`gdbserver`附加之前首先启动，所以在调试之前会执行一些代码。如果我们想调试在应用程序启动时执行的代码，可以插入一个`while(true)`块。调试会话开始后，我们改变标志值以跳出`while(true)`块。这在我们示例项目中得到了演示。
- en: Once the debug session starts, we can use `gdb` commands to debug our code.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 调试会话开始后，我们可以使用`gdb`命令来调试我们的代码。
- en: Debugging an Android NDK application with CGDB
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CGDB调试Android NDK应用程序
- en: CGDB is a terminal-based lightweight interface to the GNU debugger `gdb`. It
    provides a split screen view, which displays the source code along with the debug
    information. This recipe discusses how to debug Android application with `cgdb`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: CGDB是基于终端的轻量级GNU调试器`gdb`的界面。它提供了一个分割屏幕视图，同时显示源代码和调试信息。本教程将讨论如何使用`cgdb`调试Android应用程序。
- en: Getting ready
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following instructions install `cgdb` on different operating systems:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在不同操作系统上安装`cgdb`的说明：
- en: 'If you''re using Ubuntu, you can use the following command to install `cgdb`:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是Ubuntu，可以使用以下命令安装`cgdb`：
- en: '[PRE51]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alternatively, you can download the source code from [http://cgdb.github.com/](http://cgdb.github.com/),
    and perform the following instructions to install `cgdb`:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以从[http://cgdb.github.com/](http://cgdb.github.com/)下载源代码，并按照以下说明安装`cgdb`：
- en: '[PRE52]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that `cgdb` requires `libreadline` and `ncurses` development libraries.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`cgdb`需要`libreadline`和`ncurses`开发库。
- en: If you're using Windows, a Windows binary is available at [http://cgdb.sourceforge.net/download.php](http://cgdb.sourceforge.net/download.php).
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows系统，可以在[http://cgdb.sourceforge.net/download.php](http://cgdb.sourceforge.net/download.php)找到Windows二进制文件。
- en: 'If you''re using MacOS, you can use the MacPorts installation command as follows:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是MacOS，可以使用以下MacPorts安装命令：
- en: '[PRE53]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Please read the *Debugging Android NDK Application with NDK GDB* recipe before
    going through this one.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本篇内容之前，请先阅读《使用NDK GDB调试Android NDK应用程序》的教程。
- en: How to do it...
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps enable `cgdb` for Android NDK application debugging:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤为Android NDK应用程序调试启用`cgdb`：
- en: 'Make a copy of the `ndk-gdb` script under the Android NDK `root` directory.
    This can be done with the following command:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android NDK的`根`目录下复制`ndk-gdb`脚本。这可以通过以下命令完成：
- en: '[PRE54]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, `$ANDROID_NDK` refers to the Android NDK `root` directory.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`$ANDROID_NDK`指的是Android NDK的`根`目录。
- en: 'Change the following line in the `ndk-cgdb` script from:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ndk-cgdb`脚本中的以下行更改为：
- en: '[PRE55]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To the following:'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改为以下内容：
- en: '[PRE56]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We'll use the project created in the *Debugging Android NDK application with
    NDK GDB* recipe. If you don't have the project open in your Eclipse IDE, click
    on **File** | **Import**. Select **Existing Projects into Workspace** under **General**,
    then click on **Next**. In the import window, check **Select root directory**,
    and browse to the `HelloNDKGDB` project. Click on **Finish** to import the project:![How
    to do it...](img/1505_03_33_new.jpg)
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用在《使用NDK GDB调试Android NDK应用程序》教程中创建的项目。如果您在Eclipse IDE中没有打开项目，点击**文件** |
    **导入**。在**常规**下选择**现有项目到工作空间**，然后点击**下一步**。在导入窗口中，勾选**选择根目录**，并浏览到`HelloNDKGDB`项目。点击**完成**以导入项目：![如何操作...](img/1505_03_33_new.jpg)
- en: 'Run the application on an Android device. Then, start a termina, and enter
    the following command:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android设备上运行应用程序。然后，启动一个终端，输入以下命令：
- en: '[PRE57]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following is a screenshot of the `cgdb` interface:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是`cgdb`界面的截图：
- en: '![How to do it...](img/1505_03_28.jpg)'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_03_28.jpg)'
- en: We can issue `gdb` commands. Note that the upper-half of the window will mark
    the current execution line with an arrow and all the breakpoints with red.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以输入`gdb`命令。注意，窗口上半部分会用箭头标记当前执行行，并用红色标记所有断点。
- en: How it works...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As shown in the preceding screenshot, `cgdb` provides a more intuitive interface
    for debugging the native code in Android. We can view the source code as we enter
    `gdb` commands. This recipe demonstrates the basic setup of `cgdb` for debugging
    the native code. The details of how to use `cgdb` can be found at its documentation
    available at [http://cgdb.github.com/docs/cgdb.html](http://cgdb.github.com/docs/cgdb.html).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，`cgdb`为在 Android 中调试本地代码提供了一个更直观的界面。我们可以输入`gdb`命令时查看源代码。这个食谱演示了使用`cgdb`调试本地代码的基本设置。有关如何使用`cgdb`的详细信息，请参阅其文档，地址为[http://cgdb.github.com/docs/cgdb.html](http://cgdb.github.com/docs/cgdb.html)。
- en: Debugging an Android NDK application in Eclipse
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Eclipse 中调试 Android NDK 应用程序
- en: Debugging at terminals with GDB or CGDB is cumbersome for developers who are
    used to the graphical development tools. With **Android Development Tools** (**ADT**)
    20.0.0 or above, debugging NDK application in Eclipse is fairly easy.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于图形化开发工具的开发者来说，在终端中使用 GDB 或 CGDB 进行调试是很麻烦的。使用**Android 开发工具**（**ADT**）20.0.0
    或更高版本，在 Eclipse 中调试 NDK 应用程序相当简单。
- en: Getting ready
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure you have ADT 20.0.0 or above installed. If not, please refer to recipes
    in [Chapter 1](ch01.html "Chapter 1. Hello NDK"), *Hello NDK*, that explain how
    to set your environment up.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装 ADT 20.0.0 或更高版本。如果没有，请参考[第一章](ch01.html "第1章. 你好 NDK")中的食谱，*你好 NDK*，了解如何设置您的环境。
- en: Make sure you have configured the NDK path in Eclipse. In addition, you are
    expected to have built and run at least one Android NDK application before reading
    this recipe. If not, please go through the *Building Android NDK Application at
    Eclipse* recipe.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已在 Eclipse 中配置了 NDK 路径。此外，在阅读这个食谱之前，您应该至少构建和运行过一个 Android NDK 应用程序。如果没有，请阅读*在
    Eclipse 中构建 Android NDK 应用程序*的食谱。
- en: How to do it...
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps create a sample Android project and debug it using Eclipse:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将创建一个示例 Android 项目，并使用 Eclipse 进行调试：
- en: We'll use the project created in the *Building Android NDK application at Eclipse*
    recipe. If you don't have the project open in your Eclipse IDE, click on **File**
    | **Import**. Select **Existing Projects into Workspace** under **General**, then
    click on **Next**. In the **import** window, check **Select root directory**,
    and browse to the `HelloNDKEclipse` project. Click on **Finish** to import the
    project:![How to do it...](img/1505_03_29.jpg)
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用在*在 Eclipse 中构建 Android NDK 应用程序*的食谱中创建的项目。如果您在 Eclipse IDE 中没有打开项目，请点击**文件**
    | **导入**。在**常规**下选择**现有项目到工作空间**，然后点击**下一步**。在**导入**窗口中，勾选**选择根目录**，并浏览到`HelloNDKEclipse`项目。点击**完成**以导入项目：![如何操作...](img/1505_03_29.jpg)
- en: Right-click on the `HelloNDKEclipse` project, and select **Properties**. In
    the **Properties** window, select **C/C++ Build**. Uncheck **Use default build
    command**, and change the **Build** command to `ndk-build NDK_DEBUG=1`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HelloNDKEclipse`项目上右键点击，选择**属性**。在**属性**窗口中，选择**C/C++ 构建器**。取消勾选**使用默认构建命令**，并将**构建**命令更改为`ndk-build
    NDK_DEBUG=1`。
- en: Click on **OK** to dismiss the window:![How to do it...](img/1505_03_30.jpg)
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**关闭窗口：![如何操作...](img/1505_03_30.jpg)
- en: Add the following code before the native method is called at `HelloNDKEclipseActivity.java`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HelloNDKEclipseActivity.java`中调用本地方法之前添加以下代码。
- en: 'Set two breakpoints in `HelloNDKEclipse.cpp`:'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`HelloNDKEclipse.cpp`中设置两个断点：
- en: '![How to do it...](img/1505_03_31.jpg)'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_03_31.jpg)'
- en: Right-click on your project and then select **Debug As** | **Android Native
    Application**. We'll see if the breakpoints are hit.![How to do it...](img/1505_03_32.jpg)
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目上右键点击，然后选择**调试为** | **Android 原生应用程序**。我们将看看是否触发了断点。![如何操作...](img/1505_03_32.jpg)
- en: How it works...
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: Because there is a delay of a few seconds between the application start and
    the debugging session start, the source code where the breakpoint is set may have
    already been executed before debugging. In this case, the breakpoint is never
    hit. We demonstrated using a `while(true)` loop to overcome this issue in the
    *Debugging Android NDK application with NDK GDB* recipe. We show another approach
    here, which sends code to sleep for several seconds at application start. This
    gives the debugger enough time to start. Once the debugging starts, we can use
    the normal Eclipse debugging interface to debug our code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序启动和调试会话启动之间存在几秒钟的延迟，设置断点的源代码可能在调试开始之前就已经执行了。在这种情况下，断点永远不会被触发。在*使用 NDK
    GDB 调试 Android NDK 应用程序*的食谱中，我们演示了使用`while(true)`循环来解决这个问题。这里我们展示了另一种方法，在应用程序启动时让代码休眠几秒钟。这为调试器提供了足够的时间来启动。一旦开始调试，我们可以使用正常的
    Eclipse 调试界面来调试我们的代码。
- en: There's more...
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There're a few more debuggers available for debugging Android NDK applications.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些调试器可用于调试Android NDK应用程序。
- en: '**Data Display Debugger** (**DDD**) is a graphical front end for GDB. It is
    possible to set up DDD to debug Android applications. Detailed instructions for
    the same can be found at [http://omappedia.org/wiki/Android_Debugging#Debugging_with_GDB_and_DDD](http://omappedia.org/wiki/Android_Debugging#Debugging_with_GDB_and_DDD).'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据显示调试器**（**DDD**）是GDB的图形前端。可以设置DDD来调试Android应用程序。详细的操作指南可以在[http://omappedia.org/wiki/Android_Debugging#Debugging_with_GDB_and_DDD](http://omappedia.org/wiki/Android_Debugging#Debugging_with_GDB_and_DDD)找到。'
- en: '**NVIDIA Debug Manager** is an Eclipse plugin that assists in debugging Android
    NDK applications on devices based on NVIDIA''s Tegra platform. More information
    about this tool can be found at [https://developer.nvidia.com/nvidia-debug-manager-android-ndk](https://developer.nvidia.com/nvidia-debug-manager-android-ndk).'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**NVIDIA调试管理器**是一个Eclipse插件，用于协助在基于NVIDIA Tegra平台的设备上调试Android NDK应用程序。关于此工具的更多信息可以在[https://developer.nvidia.com/nvidia-debug-manager-android-ndk](https://developer.nvidia.com/nvidia-debug-manager-android-ndk)找到。'
