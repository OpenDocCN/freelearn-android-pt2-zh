- en: Chapter 3. Build and Debug NDK Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an Android NDK application at the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Android NDK application in Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Android NDK application for different ABIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Android NDK applications for different CPU features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with logging messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with CheckJNI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with NDK GDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with CGDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application in Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the environment set up in [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK*, and JNI programming in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*. To build Android NDK applications,
    we'll also need to use the **build** and **debug** tools for Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Android NDK comes with the `ndk-build` script to facilitate the easy build of
    any Android NDK application. This script hides the complications of invoking cross
    compilers, cross linkers, and so on, from developers. We'll start by introducing
    the usage of the `ndk-build` command.
  prefs: []
  type: TYPE_NORMAL
- en: A recent release of the **Android Development Tools** (**ADT**) plugin has enabled
    the building of Android NDK applications from Eclipse. We'll demonstrate how to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore building NDK applications for different **Application Binary Interfaces**
    (**ABIs**) and making use of optional CPU features. This is essential to achieve
    best performance on different Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Besides build, we will also introduce various debugging tools and techniques
    for Android NDK applications. Starting with the simple but powerful logging technique,
    we'll show how to debug NDK applications from both the command line and the Eclipse
    IDE. The `CheckJNI` mode will also be introduced, which can help us capture JNI
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Android NDK application at the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though Eclipse is the recommended IDE for Android development, sometimes we
    want to build an Android application in the command line so that the process can
    be automated easily and become part of a continuous integration process. This
    recipe focuses on how to build an Android DNK application at the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache Ant is a tool mainly used for building Java applications. It accepts
    an XML file to describe the build, deploy and test processes, manage the processes,
    and to automatically keep a track of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use Apache Ant to build and deploy our sample project. If you
    don''t have it installed yet, you can follow these commands to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re on Ubuntu Linux, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you''re using a Mac, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you're using Windows, you can download the `winant` installer from [http://code.google.com/p/winant/downloads/list](http://code.google.com/p/winant/downloads/list),
    and install it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers are supposed to have the NDK development environment set up and read
    the *Writing a Hello NDK program* recipe in [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK*, before going through this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create and build a sample `HelloNDK` application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the project. Start a command-line console and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `android` tool can be found under the `tools/` directory of the Android
    SDK folder. If you have followed [Chapter 1](ch01.html "Chapter 1. Hello NDK"),
    *Hello NDK*, to set up the SDK and NDK development with `PATH` configured properly,
    you can execute the `android` command directly from the command line. Otherwise,
    you will need to enter the relative or full path to the `android` program. This
    also applies to other SDK and NDK tools used in the book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the command output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Go to the `HelloNDK` project folder and create a folder named `jni` by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `hello.c` under the `jni` folder, and add the following
    content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `Android.mk` under the `jni` folder with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the native library using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `HelloNDKActivity.java` file to the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the project. We have added a native library, so we need to update the
    project with the following command. Note that this command is only needed once
    unless we change the project settings, while the previous `ndk-build` command
    needs to be executed every time we update the native code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the command output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Go to the project `root` folder, and build our project in the debug mode using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following screenshot, we show the last few lines of the output, which
    indicates a successful build is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The output `apk` will be produced at `bin/HelloNDK-debug.apk`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an emulator using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the command output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Start the emulator, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can start the **Android Virtual Device Manager** window by
    using the command "`android avd`", and then choosing an emulator to launch, as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Install the app on the emulator. We first check the device serial number by
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the command output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We then install the `debug.apk` file to the emulator by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/1505_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If only a single device is connected to the computer, there is no need to specify
    the device serial number. In the preceding commands , we can remove "-`s emulator-5554`".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the `HelloNDK` app on the emulator using the command in the following
    format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our example, we use the following ommand:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/1505_03_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Run the app on a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose the device serial number is `HT21HTD09025`, then we can use the following
    command to install the app on an Android device.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our example, we use the following command to start the app:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a release package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we confirm that our application can run successfully, we may want to create
    a release package for uploading to the Android market. You can perform the following
    steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a keystore. An Android app must be signed using a key from a keystore.
    A **keystore** is a collection of private keys. We can use the following command
    to create a keystore with a private key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the command output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As shown, a keystore with password as `testkwpw` is created, and a RSA key pair
    with password as `testkpw` is added to the keystore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type the command "`ant release`" to build an `apk` for the app. The output can
    be found in the b`i`n folder as `HelloNDK-release-unsigned.apk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sign the `apk` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our sample application, the command and output are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Zip-align the `apk` file. The `zipalign` tool aligns the data inside an `apk`
    file for performance optimization. The following command can be used to align
    a signed `apk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our sample application, the command and output are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe discusses how to build an Android NDK application from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android NDK provides a build system with the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: It handles most of the heavy lifting stuff for developers,
    and we only need to write brief build files (`Android.mk` and `Application.mk`)
    to describe the sources need to be compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility**: More build tools, platforms, and so on, may be added to
    NDK in future releases, but no changes are required for the build files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android NDK comes with a set of cross toolchains, including cross-compilers,
    cross-linkers, cross-assemblers, and so on. These tools can be found under `toolchains`
    folder of the NDK `root` directory. They can be used to generate binaries on different
    Android platforms (ARM, x86, or MIPS) on Linux, Mac OS, or Windows. Although it
    is possible to use the toolchains directly to build native code for Android, it
    is not recommended unless we're porting a project with its own build scripts.
    In this case, we may only need to change the original compiler to the NDK cross
    compiler to build it for Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, we''ll describe the sources in `Android.mk` and specify the
    ABIs on `Application.mk`. Android NDK''s `ndk-build` script will internally invoke
    the cross toolchain to build the native code for us. The following is a list of
    commonly used `ndk-build` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndk-build`: It is used to build binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndk-build clean`: It cleans the generated binaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndk-build V=1`: This builds binaries and displays the build commands. It is
    handy when we want to find out how things are built or checked for build bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndk-build -B`: This command forces a rebuild.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndk-build NDK_DEBUG=1`: It generates debuggable build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndk-build NDK_DEBUG=0`: It generates a release build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a lot of command-line tools in the Android SDK. This allows
    us to present complete instructions of how to create, build, and deploy an Android
    NDK project. However, we won't provide the details about these tools in this book
    since this book is dedicated to Android NDK. You may read more about those tools
    at [http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Taking screenshots from the command line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Taking a screenshot from command line can be handy to record the display results
    for an automated test. However, Android does not provide a command-line tool to
    take a screenshot currently.
  prefs: []
  type: TYPE_NORMAL
- en: A Java program found at `\development\tools\screenshot\src\com\android\screenshot\`
    of the Android source code can be used to take screenshot. The code uses a similar
    method as the Eclipse DDMS plugin to take a screenshot, but from the command line.
    We incorporated the preceding code into an Eclipse Java project named `screenshot`,
    which can be downloaded from the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can import the project and export an executable JAR file to use the tool.
    Suppose the exported JAR file is named `screenshot.jar`, then the following sample
    command uses it to take a screenshot from an emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking screenshots from the command line](img/1505_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building an Android NDK application in Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe discusses how to build an Android NDK application in the
    command line. This recipe demonstrates how to do it in the Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add NDK Preferences. Start Eclipse, then click on **Window** | **Preferences**.
    In the **Preferences** window, select **NDK** under **Android**. Click on **Browse**
    and select the NDK `root` folder. Click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1505_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create an NDK project using Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `HelloNDKEclipse`. Set the package name
    as `cookbook.chapter3`. Create an activity named `HelloNDKEclipseActivity`. Please
    refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*,
    if you want more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `HelloNDKEclipse`, select **Android Tools** | **Add
    Native Support**. A window similar to the following screenshot will appear. Click
    on **Finish** to dismiss it:![How to do it…](img/1505_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will add a `jni` folder with two files (`HelloNDKEclipse.cpp` and `Android.mk`)
    inside, and switch Eclipse to C/C++ perspective.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following content to `HelloNDKEclipse.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the content of HelloNDKEclipseActivity.java to below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on `HelloNDKEclipse` project, and select **Build Project**. This
    will build the native library for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project, go to **Run As**, and select **Android Application**.
    The phone screen will display something similar to the following screenshot:![How
    to do it…](img/1505_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe discusses building the Android NDK application at Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: We have been using C in all previous recipes. Starting from this recipe, we'll
    be writing our code in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Android provides minimal C++ support. There''s no **Run-time Type
    Information** (**RTTI**) and C++ exceptions support, and even the C++ standard
    library support, is partial. The following is a list of the C++ headers supported
    by Android NDK by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to add more C++ support by using different C++ libraries. NDK
    comes with the `gabi++`, `stlport`, and `gnustl` C++ libraries, besides the system
    default one.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample code, we used an external "C" to wrap the C++ method. This is
    to avoid C++ mangling of the JNI function names. C++ name mangling could change
    the function names to include type information about parameters, whether the function
    is virtual or not, and so on. While this enables C++ to link overloaded functions,
    it breaks the JNI function discovery mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the explicit function registration method covered in the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, to get rid of the
    wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Android NDK application for different ABIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Native code is compiled into binaries. Therefore, one set of binaries can only
    run on a specific architecture. Android NDK comes with techniques and tools to
    allow developers to compile the same source code for multiple architectures easily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **Application Binary Interface** (**ABI**) defines how the Android application's
    machine code is supposed to interact with the system at runtime, including the
    CPU instruction set, endianness, alignment of memory, and so on. An ABI basically
    defines a type of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table briefly summarizes the four ABIs supported by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ABI name | Support | Not support | Optional |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `armeabi` |'
  prefs: []
  type: TYPE_TB
- en: ARMv5TE instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thumb (also known as Thumb-1) instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Hardware-assisted floating point computation |   |'
  prefs: []
  type: TYPE_TB
- en: '| `armeabi-v7a` |'
  prefs: []
  type: TYPE_TB
- en: Whatever is supported in `armeabi`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VFP hardware FPU instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thumb-2 instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VFPv3-D16 is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: Advanced SIMD (also known as NEON)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VFPv3-D32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ThumbEE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `x86` |'
  prefs: []
  type: TYPE_TB
- en: Instruction set commonly known as "x86" or "IA-32".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MMX, SSE, SSE2, and SSE3 instruction set extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: MOVBE instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSSE3 "supplemental SSE3" extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any variant of "SSE4"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `mips` |'
  prefs: []
  type: TYPE_TB
- en: MIPS32r1 instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard-Float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: DSP application specific extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIPS16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: micromips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: 'armeabi and armeabi-v7a are the two most commonly used ABIs for Android devices.
    ABI armeabi-v7a is compatible with armeabi, which means applications compiled
    for armeabi can run on armeabi-v7a too. But the reverse is not true, since armeabi-v7a
    includes additional features. In the following section, we briefly introduce some
    technical terms referred to frequently in armeabi and armeabi-v7a:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thumb**: This instruction set consists of 16-bit instructions, which is a
    subset of the 32-bit instruction set of the standard ARM. Some instructions in
    the 32-bit instruction set are not available for Thumb, but can be simulated with
    several Thumb instructions. The narrower 16-bit instruction set can offer memory
    advantages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thumb-2 extends Thumb-1 by adding some 32-bit instructions, which results in
    a variable-length instruction set. Thumb-2 aims to attain code density like to
    Thumb-1 and performance similar to standard ARM instruction set on a 32-bit memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Android NDK generates the thumb code by default, unless `LOCAL_ARM_MODE` is
    defined in the `Android.mk` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Vector Floating Point (VFP)**: It is an extension to the ARM processor, which
    provides low cost floating point computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VFPv3-D16 and VFPv3-D32**: VFPv3-D16 refers to 16 dedicated 64-bit floating
    point registers. Similarly, VFPv3-D32 means there are 32 64-bit floating point
    registers. These registers speed up floating point computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NEON**: NEON is the nickname for the ARM **Advanced Single Instruction Multiple
    Data** (**SIMD**) instruction set extension. It requires VFPv3-D32, which means
    32 hardware FPU 64-bit registers will be used. It provides a set of scalar/vector
    instructions and registers, which are comparable to MMX/SSE/SDNow! in the x86
    world. It is not supported by all Android devices, but many new devices have NEON
    support. NEON can accelerate media and signal processing applications significantly
    by executing up to 16 operations simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can refer to ARM documentation website at [http://infocenter.arm.com/help/index.jsp](http://infocenter.arm.com/help/index.jsp)
    for more detailed information. We don't discuss x86 and mips ABI here, because
    few Android devices run on these architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Read the *Building Android NDK Application at Eclipse* recipe before going through
    this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps build an Android project for different ABIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `HelloNDKMultipleABI`. Set the package name
    as `cookbook.chapter3`. Create an activity named `HelloNDKMultipleABIActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `HelloNDKMultipleABI` project, select **Android Tools** |
    **Add Native Support**. A window appears, click on **Finish** to dismiss it. This
    will add a `jni` folder with two files (`HelloNDKMultipleABI.cpp` and `Android.mk`)
    inside, and switch Eclipse to the C/C++ perspective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following content to the `HelloNDKMultipleABI.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `HelloNDKMultipleABIActivity.java` file to the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new file named `Application.mk` under the project''s `jni` folder with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the `HelloNDKMultipleABIActivity` project, and select **Build
    Project**. This will build the native library for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two emulators, with ABI set to `armeabi` and `armeabi-v7a` respectively.
    The following screenshot depicts how an emulator is created with the `armeabi`
    ABI:![How to do it...](img/1505_03_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the sample Android application on the two emulators. The same result is
    shown on both of them:![How to do it...](img/1505_03_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the content of `Application.mk` to the following code snippet and run
    the sample application on the two emulators. The application will still work on
    both the emulators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the content of `Application.mk` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the sample application on the two emulators. The application works on the
    `armeabi-v7a` emulator, but crashes on `armeabi` emulator, as shown in the following
    screenshot:![How to do it...](img/1505_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Android device can define one or two ABIs. For typical x86-, MIPS-, ARMv5-,
    and ARMv6-based devices, there's only a primary ABI. Based on the platform, it
    can be x86, mips, or armeabi. For a typical ARMv7-based device, the primary ABI
    is usually armeabi-v7a, and it also has a secondary ABI as armeabi. This enables
    binaries compiled for either armeabi or armeabi-v7a to run on ARMv7 devices. In
    our example, we demonstrated that the app can work on both armeabi and armeabi-v7a
    emulators when built against only armeabi.
  prefs: []
  type: TYPE_NORMAL
- en: At installation, the Android package manager searches for native libraries built
    for the primary ABI and copies them to the application's data directory. If not
    found, it then searches the native libraries built for the secondary ABI. This
    ensures that only the proper native libraries are installed.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, when we compile the binary against armeabi-v7a only, the native
    library won't get installed on the armeabi emulator, subsequently the native library
    cannot be loaded, and a crash will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Building Android NDK applications for different CPU features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many projects use native code to improve performance. One advantage of developing
    in NDK over SDK is that we can build different packages for different CPUs, which
    is the topic of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please read the *Building Android NDK application for different ABIs* recipe
    before going through this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps build Android NDK applications for different CPU features.
  prefs: []
  type: TYPE_NORMAL
- en: At Eclipse, click on **File** | **New** | **Other**. Select **Android Project**
    from **Existing Code** under **Android** as shown in the following screenshot.
    Then click on **Next**:![How to do it…](img/1505_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the `samples/hello-neon` folder of the Android NDK folder. Then click
    on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a terminal, then go to the `samples/hello-neon/jni` folder. Type the command
    "`ndk-build`" to build the binaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the Android project on different devices and emulators. Based on your device/emulator
    ABI and availability of the NEON feature, you should be able to see the results
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Android device with armeabi ABI, the result is as follows:![How to do it…](img/1505_03_20.jpg)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Android device with armeabi-v7a ABI and NEON, the result is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android devices are roughly divided by ABIs. However, different devices with
    the same ABI can have different CPU extensions and features. These extensions
    and features are optional and therefore we don't know whether a user's device
    has them until runtime. Detecting and making use of these features can sometimes
    improve app performance significantly on certain devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android NDK contains a library named `cpufeatures`, which can be used to detect
    the CPU family and optional features at runtime. As illustrated in the sample
    code, the following steps indicate how to use this library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add it in the static library list in `Android.mk` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `Android.mk` file, import the `cpufeatures` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code, include the header file `<cpu-features.h>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call detection functions; Currently `cpufeatures` provides only three functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the CPU family. The function prototype is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It returns an enum. The supported CPU families are listed in the section to
    follow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the optional CPU features. Each CPU feature is represented by a bit flag
    and the bit is set to `1` if the feature is available. The function prototype
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the ARM CPU family, the supported CPU feature detections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANDROID_CPU_ARM_FEATURE_ARMv7`: It means that the ARMv7-a instruction is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANDROID_CPU_ARM_FEATURE_VFPv3`: It means that the VFPv3 hardware FPU instruction
    set extension is supported. Note that this refers to VFPv3-D16, which provides
    16 hardware FP registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANDROID_CPU_ARM_FEATURE_NEON`: It means that he ARM Advanced SIMD (also known
    as NEON) vector instruction set extension is supported. Note that such CPUs also
    support VFPv3-D32, which provides 32 hardware FP registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the x86 CPU family, the supported CPU feature detections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANDROID_CPU_X86_FEATURE_SSSE3`: It means that the `SSSE3` instruction extension
    set is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANDROID_CPU_X86_FEATURE_POPCNT`: It means that the `POPCNT` instruction is
    supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANDROID_CPU_X86_FEATURE_MOVBE`: It means that the `MOVBE` instruction is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can do a "`&`" operation to detect if a feature is available or not, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the number of CPU cores on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since NDK r8c, more CPU feature detections are available. Please refer to `sources/android/cpufeatures/cpu-features.c`
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few more noteworthy points about CPU features on Android.
  prefs: []
  type: TYPE_NORMAL
- en: More about CPU feature detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `cpufeatures` library can only detect a limited set of CPU features. It
    is possible to implement our own CPU detection mechanisms. By looking at the NDK
    source code at `/sources/android/cpufeatures/`, one can find that the `cpufeatures`
    library essentially looks at the `/proc/cpuinfo` file. We can read this file and
    parse the content in our application. The following is a screenshot of the file
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More about CPU feature detection](img/1505_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please refer to the Android project `cpuinfo`, available in the book's website
    for how to do this programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Different approaches of building for different cpu features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few approaches to building native code for different CPU features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single library, different binaries at build time**: This is demonstrated
    in the sample project. The `helloneon-intrinsics.c` file is only compiled for
    armeabi-v7a ABI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single library, different execution paths at runtime**: This is also shown
    in the sample project. The code detects whether the NEON feature is available
    or not at runtime and executes different code blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different libraries, load appropriate library at runtime**: Sometimes, we
    may want to compile the source code into different libraries and differentiate
    them by names. For example, we may have `libmylib-neon.so` and `libmylib-vfpv3.so`
    . We detect the CPU feature at runtime and load the appropriate library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different packages, load appropriate library at runtime**: If the library
    is big, it is desirable to deploy different binaries for different CPUs as separate
    packages. This is done by many video players available on Google Play (for example,
    MX Player).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with logging messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android logging system provides a method for collecting logs from various applications
    into a series of circular buffers. The `logcat` command is used to view the logs.
    Log message is the simplest method of debugging a program, yet one of the most
    powerful ones. This recipe focuses on message logging in NDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create our sample Android project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NDKLoggingDemo`. Set the package name as
    `cookbook.chapter3`. Create an activity named `NDKLoggingDemoActivity`. Please
    refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*,
    if you want more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `NDKLoggingDemo`, select **Android Tools** | **Add
    Native Support**. A window appears, click on **Finish** to dismiss it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new file named `mylog.h` under the `jni` folder, and add the following
    content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following content to `NDKLoggingDemo.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the content of `NDKLoggingDemoActivity.java` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `Android.mk` file to include the Android log library as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the `NDKLoggingDemo` project, and select **Build Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the monitor logcat output by entering the following command. Then, start
    the sample Android app on an Android device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the logcat output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Start another command line terminal, and enter the following command in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will result into the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/1505_03_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Change the line in `mylog.h` from `#define LOG_LEVEL 9` to `#define LOG_LEVEL
    4`. Rebuild the application, then restart the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The outputs of the two terminals we started earlier are the same.![How to do
    it…](img/1505_03_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe shows how to use Android log messages. Each log message in Android
    consists of the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Priority**: It is usually used to filter log messages. In our project, we
    can control the log by changing the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alternatively, we can selectively display the log output using `logcat`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Log tag**: It is usually used to identify the log source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log message**: It provides the detailed log message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sending log messages on Android consumes CPU resources and frequent log messages
    can affect the application performance. In addition, the logs are stored in a
    circular buffer. Too many logs will overwrite some earlier logs, which may not
    be desirable. Due to these facts, it is recommended we only log errors and exceptions
    at the release build.
  prefs: []
  type: TYPE_NORMAL
- en: '`logcat` is the command-line tool to view Android logs. It allows one to filter
    logs according to the log tag and priority. It is also capable of dispalying logs
    in different formats.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we used the following `logcat` command in step 8 of the preceding
    *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The command filters out logs except those with the `NDKLoggingDemo` tag and
    priority `I` (information) or higher. The filter is given in a `tag:priority`
    format. `NDKLoggingDemo:I` indicates logs with a `NDKLoggingDemo` tag and priority
    information or higher will be displayed. `*:S` sets the priority level for all
    other tags as "silent".
  prefs: []
  type: TYPE_NORMAL
- en: More details about logcat filtering and format can be found at [http://developer.android.com/tools/help/logcat.html](http://developer.android.com/tools/help/logcat.html)
    and [http://developer.android.com/tools/debugging/debugging-log.html#outputFormat](http://developer.android.com/tools/debugging/debugging-log.html#outputFormat).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with CheckJNI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JNI does little error checking for better performance. As a result, errors usually
    lead to a crash. A mode called `CheckJNI` is offered by Android. In this mode,
    a set of JNI functions with extended checks are called instead of the normal JNI
    functions. This recipe discusses how to enable the CheckJNI mode to debug Android
    NDK applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create a sample Android project and enable the `CheckJNI`
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `CheckJNIDemo`. Set the package name as
    `cookbook.chapter3`. Create an activity named `CheckJNIDemoActivity`. Please refer
    to the *Loading native libraries and registering native methods* recipe of [Chapter
    2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*, if
    you want more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `CheckJNIDemo`, select **Android Tools** | **Add
    Native Support**. A window appears; click on **Finish** to dismiss it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following content to `CheckJNIDemo.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `CheckJNIDemoActivity.java` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on `CheckJNIDemo` project, and select **Build Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the monitor logcat output by entering "`adb logcat -v time`" on a command-line
    console. Then, start the sample Android app on an Android device. The application
    will crash, and the logcat output will be displayed as follows:![How to do it...](img/1505_03_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable CheckJNI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the emulator is being used by you, the CheckJNI is on by default.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're using a rooted device, the following sequence of commands can be used
    to restart the runtime with CheckJNI enabled. The commands stop the running Android
    instance, change the system properties to enable CheckJNI, and then restart Android.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a regular device, you can use the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Run the Android application again. The logcat output will be displayed as follows:![How
    to do it...](img/1505_03_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CheckJNI mode uses a set of JNI functions, which have more error checking
    than the default one. This makes it easier to find JNI programming bugs. The CheckJNI
    mode currently checks the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Negative-sized array**: It attempts to allocate an array of negative size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad reference**: It passes a bad reference `jarray`/`jclass`/`jobject`/`jstring`
    to a JNI function. Passing `NULL` to JNI function expecting a non-NULL argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class names**: It passes the class names of invalid style to the JNI function.
    Valid class names are separate by "`/`" as in "`java`/`lang`/`String`".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Critical calls**: It calls a JNI function between a "critical" get function
    and its corresponding release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exceptions**: It calls a JNI function when there''s a pending exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jfieldIDs**: It invalidates `jfieldIDs` or assigns `jfieldIDs` from one type
    to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jmethodIDs**: It''s similar to jfieldIDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References**: It uses `DeleteGlobalRef`/`DeleteLocalRef` on references of
    wrong types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release mode**: It passes a release mode other than `0`, `JNI_ABORT`, and
    `JNI_COMMIT` to a release call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety**: It returns an incompatible type from a native method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UTF-8**: It passes invalid modified UTF-8 string to JNI functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More error checking may be added to CheckJNI as Android evolves. Currently,
    the following checks are not supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Misuse of local references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with NDK GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android NDK introduces a shell script named `ndk-gdb` to help one to launch
    a debugging session to debug the native code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project must meet the following requirements in order to debug it with
    `ndk-gdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: The application is built with the `ndk-build` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndroidManifest.xml` has the `android:debuggable` attribute of the `<application>`
    element set to `true`. This indicates that the application is debuggable even
    when it is running on a device in the user mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application should be running on Android 2.2 or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please read the *Building Android NDK Application at Eclipse* recipe before
    going through this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps create a sample Android project and debug it using NDK GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `HelloNDKGDB`. Set the package name as `cookbook.chapter3`.
    Create an activity named `HelloNDKGDBActivity`. Please refer to the *Loading native
    libraries and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project `HelloNDKGDB`, select **Android Tools** | **Add Native
    Support**. A window appears; click on **Finish** to dismiss it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `HelloNDKGDB.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the content of `HelloNDKGDBActivity.java` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure that the `debuggable` attribute in `AndroidManifest.xml` is set to
    `true`. The following code snippet is a part of the application element extracted
    from `AndroidManifest.xml` of our sample project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the native library with the command "`ndk-build NDK_DEBUG=1`". Alternatively,
    we can configure the `build` command at Eclipse under **C/C++ Build** of the project
    **Properties**. This is demonstrated in the *Debugging Android NDK application
    at Eclipse* recipe .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application on an Android device. Then, start a terminal and enter
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the debugger is attached to the remote process, we can issue GDB commands
    to start debugging the app. This is shown as follows:![How to do it...](img/1505_03_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with Android NDK comes a shell script named as `ndk-gdb` to launch a native
    debugging session with the native code. In order to use `ndk-gdb`, we must build
    the native code in the debug mode. This will produce a `gdbserver` binary and
    a `gdb.setup` file along with the native library. At installation, `gdbserver`
    will be installed and `ndk-gdb` will start `gdbserver` on the Android device.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `ndk-gdb` searches for a running application and attaches `gdbserver`
    to it. There also are options to launch the application automatically before starting
    the debugging. Because the application starts first before `gdbserver` is attached
    to it, some code will be executed before debugging. If we want to debug the code
    that is executed at the application start up, we can insert a `while(true)` block.
    After the debugging session starts, we change the flag value to escape from the
    `while(true)`block. This is demonstrated in our sample project.
  prefs: []
  type: TYPE_NORMAL
- en: Once the debug session starts, we can use `gdb` commands to debug our code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an Android NDK application with CGDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CGDB is a terminal-based lightweight interface to the GNU debugger `gdb`. It
    provides a split screen view, which displays the source code along with the debug
    information. This recipe discusses how to debug Android application with `cgdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following instructions install `cgdb` on different operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Ubuntu, you can use the following command to install `cgdb`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can download the source code from [http://cgdb.github.com/](http://cgdb.github.com/),
    and perform the following instructions to install `cgdb`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `cgdb` requires `libreadline` and `ncurses` development libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you're using Windows, a Windows binary is available at [http://cgdb.sourceforge.net/download.php](http://cgdb.sourceforge.net/download.php).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re using MacOS, you can use the MacPorts installation command as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please read the *Debugging Android NDK Application with NDK GDB* recipe before
    going through this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps enable `cgdb` for Android NDK application debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a copy of the `ndk-gdb` script under the Android NDK `root` directory.
    This can be done with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `$ANDROID_NDK` refers to the Android NDK `root` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the following line in the `ndk-cgdb` script from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use the project created in the *Debugging Android NDK application with
    NDK GDB* recipe. If you don't have the project open in your Eclipse IDE, click
    on **File** | **Import**. Select **Existing Projects into Workspace** under **General**,
    then click on **Next**. In the import window, check **Select root directory**,
    and browse to the `HelloNDKGDB` project. Click on **Finish** to import the project:![How
    to do it...](img/1505_03_33_new.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application on an Android device. Then, start a termina, and enter
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the `cgdb` interface:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_03_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can issue `gdb` commands. Note that the upper-half of the window will mark
    the current execution line with an arrow and all the breakpoints with red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, `cgdb` provides a more intuitive interface
    for debugging the native code in Android. We can view the source code as we enter
    `gdb` commands. This recipe demonstrates the basic setup of `cgdb` for debugging
    the native code. The details of how to use `cgdb` can be found at its documentation
    available at [http://cgdb.github.com/docs/cgdb.html](http://cgdb.github.com/docs/cgdb.html).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an Android NDK application in Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging at terminals with GDB or CGDB is cumbersome for developers who are
    used to the graphical development tools. With **Android Development Tools** (**ADT**)
    20.0.0 or above, debugging NDK application in Eclipse is fairly easy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have ADT 20.0.0 or above installed. If not, please refer to recipes
    in [Chapter 1](ch01.html "Chapter 1. Hello NDK"), *Hello NDK*, that explain how
    to set your environment up.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have configured the NDK path in Eclipse. In addition, you are
    expected to have built and run at least one Android NDK application before reading
    this recipe. If not, please go through the *Building Android NDK Application at
    Eclipse* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps create a sample Android project and debug it using Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the project created in the *Building Android NDK application at Eclipse*
    recipe. If you don't have the project open in your Eclipse IDE, click on **File**
    | **Import**. Select **Existing Projects into Workspace** under **General**, then
    click on **Next**. In the **import** window, check **Select root directory**,
    and browse to the `HelloNDKEclipse` project. Click on **Finish** to import the
    project:![How to do it...](img/1505_03_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `HelloNDKEclipse` project, and select **Properties**. In
    the **Properties** window, select **C/C++ Build**. Uncheck **Use default build
    command**, and change the **Build** command to `ndk-build NDK_DEBUG=1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the window:![How to do it...](img/1505_03_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following code before the native method is called at `HelloNDKEclipseActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set two breakpoints in `HelloNDKEclipse.cpp`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_03_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Right-click on your project and then select **Debug As** | **Android Native
    Application**. We'll see if the breakpoints are hit.![How to do it...](img/1505_03_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because there is a delay of a few seconds between the application start and
    the debugging session start, the source code where the breakpoint is set may have
    already been executed before debugging. In this case, the breakpoint is never
    hit. We demonstrated using a `while(true)` loop to overcome this issue in the
    *Debugging Android NDK application with NDK GDB* recipe. We show another approach
    here, which sends code to sleep for several seconds at application start. This
    gives the debugger enough time to start. Once the debugging starts, we can use
    the normal Eclipse debugging interface to debug our code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There're a few more debuggers available for debugging Android NDK applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Display Debugger** (**DDD**) is a graphical front end for GDB. It is
    possible to set up DDD to debug Android applications. Detailed instructions for
    the same can be found at [http://omappedia.org/wiki/Android_Debugging#Debugging_with_GDB_and_DDD](http://omappedia.org/wiki/Android_Debugging#Debugging_with_GDB_and_DDD).'
  prefs: []
  type: TYPE_NORMAL
- en: '**NVIDIA Debug Manager** is an Eclipse plugin that assists in debugging Android
    NDK applications on devices based on NVIDIA''s Tegra platform. More information
    about this tool can be found at [https://developer.nvidia.com/nvidia-debug-manager-android-ndk](https://developer.nvidia.com/nvidia-debug-manager-android-ndk).'
  prefs: []
  type: TYPE_NORMAL
