- en: Chapter 6. Putting it All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 将它们整合在一起
- en: At last we have made it to the end of our process of gaining basic knowledge
    and skills to work with Android Canvas. In this chapter, we will develop a complete
    application step-by-step from scratch with all the functionality, using all the
    knowledge and techniques that we have used in the previous chapters. In each chapter,
    throughout this book, we have learned and practiced one core essential component
    of drawing with Canvas. Now in this chapter, we will bring all those components
    together with some additional features to create a fully functional application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经学完了使用Android Canvas的基础知识和技能的过程。在本章中，我们将从零开始逐步开发一个完整的应用程序，实现所有功能，使用我们在前几章中学到的所有知识和技巧。在本书的每一章中，我们都学习和练习了使用Canvas绘图的一个核心基本组件。现在，在本章中，我们将把这些组件与一些额外的功能结合起来，创建一个功能齐全的应用程序。
- en: To create any application or game, we need to have a plan, plot, or story board
    for it. The story board will tell us how things will work and appear in our application,
    what will be the core functionality or output of our application, and what are
    the extra or supporting features that we need to make our application useful and
    complete. The plan could be some rough bulleted notes on a paper or it can be
    some hand-drawn sketches, but it will encapsulate all our needs and outputs that
    we want from it. Some notes attached to the drawing will complete our plan and
    the overall vision of our application. One good thing about planning is that it
    freezes the requirements and our application. In normal software engineering,
    before starting the development of an application, a **Software Requirements Specification**
    document is prepared in that all the requirements are written and signed by both
    parties. It defines the boundaries of the project and this is very important.
    Without defining the boundaries or limits of requirements, the development of
    an application will never end because, with time, requirements increase during
    development. So we must have a defined set of requirements and functions. Later
    on, we can add more functionality in the new versions of the application, but
    at least the core requirements and functionality will be complete in the base
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建任何应用程序或游戏，我们需要有一个计划、情节或故事板。故事板将告诉我们应用程序中事物的工作和展示方式，应用程序的核心功能或输出是什么，以及我们需要使应用程序有用和完整的一些额外或支持功能。计划可以是纸上的一些粗略的子弹笔记，也可以是一些手绘草图，但它将包含我们从它那里需要的所有需求和输出。附在绘图上的一些注释将完成我们的计划和对应用程序的整体构想。规划的好处在于它冻结了需求和我们的应用程序。在正常的软件工程中，在开始应用程序开发之前，会准备一份**软件需求规范**文档，其中写明了所有需求，并由双方签字。它定义了项目的边界，这非常重要。如果没有定义需求的边界或限制，应用程序的开发将永无止境，因为在开发过程中，随着时间的推移，需求会增加。所以我们必须有一套明确的需求和功能。以后，我们可以在应用程序的新版本中添加更多功能，但至少基础应用程序中的核心需求和功能将是完整的。
- en: The story board
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事板
- en: We will start with the wireframe of our application with some notes on it and
    some pointers and sections; then we will explain the sketch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用程序的线框开始，上面有一些注释、指针和部分内容；然后我们会解释这个草图。
- en: 'The following diagram shows the story board of our application that we will
    develop:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们将要开发的应用程序的故事板：
- en: '![The story board](img/5396OS_06_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![故事板](img/5396OS_06_01.jpg)'
- en: The previous diagram is quite self-explanatory and gives us a complete sketch
    of what we are planning to do. The top-most area shows the application title and
    will also display a small icon if we have used one while creating the application.
    Below the title bar is the major empty **Drawing Area,** where we will perform
    all our free-hand drawing and painting. At the bottom of the screen, we will have
    a **Control panel**, from where we can select the function as well as the drawing
    and painting style. The **Control panel** will help us in selecting the colors
    for our brush. We can change the size of the brush. We can perform certain functions
    such as create a new drawing, save the existing drawing, select a brush size,
    click on the eraser to select it, and erase the currently drawn painting. We will
    use our fingers and touch events to draw on the Canvas. Later, we can either **Save**,
    **Erase**, or change the color and brush size, and proceed with our painting.
    So our goal is a simple Paint-like application for Android.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The project and application development
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will achieve our goal by dividing the project into four stages. During the
    development process, we will go through each stage step-by-step and at the end,
    we will have our working paint application. Following are the stages:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The user interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the touch and painting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the color selection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spicing up our application with more functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our project by creating a new Android application in Eclipse through
    the wizard, as we have practiced earlier in this book. Only the first screen of
    the new Android application wizard is attached.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the first screen of the new Android application
    wizard:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![The user interface](img/5396OS_06_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: We will name our application as `OurFirstPaintApp`, the **Project Name** will
    be populated automatically, and we will change the **Package Name** to `com.learningandroidcanvasmini`.
    During the development of this application, we will be working with XML files
    in the `res` folder and Java files in the `src` folder of our project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Screen orientation
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start anything, we need to decide what orientation our project will
    support. Let's say we want our project application to always be in **Portrait**
    form even if the user is holding the device in landscape mode. To do this, we
    will open the `AndroidManifest.xml` file and will change `android:screenOrientation="landscape"`
    in the `Activity` tag to `android:screenOrientation="portrait"`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The paint brush
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From our story board, we know that we have to use different sizes of brushes;
    for this, we will define some numbers that will refer to certain brush sizes.
    We will go to the `res/values` folder and will open the `dimens.xml` file. If
    the file is not there, we will create a new XML file with the name `dimens.xml`
    and will put our values in it. In this file, we will look for the `<resources></resources>`
    tag. Inside this tag, we will put our values as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will keep the dimension and the integer value the same so that the user interface
    can show the exact brush size when we use it for drawing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Control panel
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Control panel that we have in our story board sketch, we have a row
    of colors and another row with some button that performs certain functions. Now
    we will start designing the **Control panel**. To begin with, we will add all
    the strings that we will use in the **Control panel**. To do this, we will open
    the `string.xml` file in the `res/values` folder and will add the following code
    to the file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting up the layout
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will either create or download the following images from the Web
    and copy them in the `res/drawable` folder. The following screenshot shows the
    images in the `res/drawable` folder:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the layout](img/5396OS_06_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Now, we will set up the **Layout** for our Canvas and **Control panel**, the
    drawing space, and the space that will host our buttons. We will open the `activity_main.xml`
    file. Inside the main `Layout` tag, we will enter three sub layout tags as mentioned
    in the following code snippet. The first one will hold the image for the new,
    brush, erase, and save buttons and the next two will each hold a row of colors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next we will add two more layouts in which we will have two rows of colored
    buttons as shown:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The dots in the preceding code represent the code for the rest of the color
    buttons that we would like to add. The only thing that needs to be changed in
    the preceding block of code is the `android:tag="#FF660000"` code, which is the
    value of the color. Now we have the layout ready to for our Control panel. We
    need to fix some space in the layout for our drawing. Here, we will create a new
    Java class in the `src` folder by the name of `CustomDrawingView` that will extend
    View. For the time being, we will only create the skeleton code of the class so
    that we can refer to it in our layout XML file. Later, we will customize every
    section of our `CustomDrawingView` class and will put in all the functionality
    that we want our application to have. The skeleton code will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So we have added a `CustomDrawingView` class with a constructor and a `setupDrawing()`
    method. These are the most essential components right now. Without the constructor,
    the program will generate an error. Now we will come back to our `activity_main.xml`
    file and will add the following code just below the opening tag of the parent
    `layout` tag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line of code, `<com.learningandroidcanvasmini.ourfirstpaintapp.CustomDrawingView`,
    in our XML file shows the package directory of our custom view. Second, this also
    shows us how we can add customized code-based layouts in our XML layout files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we now have our layout almost ready, it is still not complete. We
    need color selection buttons that are proper rectangles in our **Control panel**.
    So far, we have defined the image buttons, but some configuration is still needed
    such as the shape of those buttons. We want the same square-shaped buttons with
    slightly rounded corners. For this purpose, we will create a new `paint.xml` file
    in the `res/drawables` folder. In this file, we will use the technique explained
    in Drawables from Resource XML. We will create a two-layered Drawable shape: one
    layer for the rectangle object and the other for rounding its corners.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have used a layer-list tag in which we have used two
    items. The first item is for the rectangle shape and the second is for rounding
    its corner. We will save all files and will run our code in the emulator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our application without any functionality:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the layout](img/5396OS_06_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: So far, we have completed the user interface and are done with the graphics
    work. Now we have to make our application touch enabled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the touch and painting using touch
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The target is to enable the touch: in other words, our application will paint
    as we drag our finger on the screen. We will start with opening our `CustomDrawingView`
    class and will add the following objects and variables:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After this in the `setupDrawing()` method, we will instantiate the `Path` and
    `Paint` objects and will set its different attributes to certain values that we
    want it to get as default values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, in the method we will instantiate the canvasPaint object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we will jump to the `onDraw()` method and will add the following lines
    of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `onDraw()` method receives an object of type `Canvas` as an argument and
    is used to draw the bitmap and the drawing or painting that we want. Each time
    we touch the screen and drag our finger, the `invalidate()` method will be called
    on the previous painting on the Canvas and the `onDraw()` method will be called
    automatically, displaying our current painting.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'We have almost everything in place but we have still not made our application
    touch enabled. For this, we will add an `onTouchEvent()` method to our `CustomDrawingView`
    class, as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside this method, we have to do two jobs: detect the user''s touch and check
    the motion direction. The touch can be either up, meaning the finger is not touching
    the screen, or down, meaning that the finger is pressed on the screen. Motion
    can be a pressed finger moving in any direction. First, we will get the x, y location
    of the touch using the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we will respond to that touch event according to one of the possible cases,
    which we will include in the following switch code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the down action event, the finger is pressed. Move the drawing point to
    the location touched:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the motion event, the finger is pressed and dragged in some direction.
    First, the point of drawing will be the point that is touched and then a line
    will be drawn along the motion of the finger during the dragging action:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, when the finger is lifted, a path on the Canvas will be drawn and the
    `Path` object will be refreshed so that it''s ready to draw a new line from the
    next location touched:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the end, we will call the `invalidate()` method so that we can activate
    the `onDraw()` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The whole code of the class is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Enabling the color selection
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will enable the color selection from the user interface that we created
    earlier. We know that we have two rows of different colors. Now we need our application
    to be able to set the color of our paint brush to the color that we select from
    the available color palette. To do this, we will open our main activity class
    and will add `import` statements for `View`, `ImageButton`, and `LinearLayout`
    to our import section of the main activity class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, inside our main activity class, we will create an object of our `CustomDrawingView`
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `onCreate()` method of our main activity class, we will instantiate
    the `drawView` object by getting a reference to its layout as defined in the `activity_main.xml`
    file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will add another object that will let us know which paint button is clicked:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next in the `onCreate()` method, we will add the following code. First we will
    get the layout that hosts our paint buttons. The `paint_colors` property is defined
    in the `activity_main.xml` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will select the first color in the top-color row as the default selected
    color:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To differentiate between the select color button and others, we will use a
    different Drawable for the selected one. To have a separate `Drawable` object
    for the selected button, we will first define a separate XML file in our `drawable`
    folder. The code of the selected button in the XML file is listed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The code is exactly the same as the previous XML file that we created in the
    `drawable` folder for our normal paint buttons. The only difference here would
    be a different value for `android:color` and solid `android:color`. After this,
    we will open our main activity class and, in the `onCreate()` method, which is
    below the image button code that we have recently added, we will add the following
    line to enable a different style for the select button:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next we will create a method in the `CustomDrawingView` class to update the
    paint color used when we draw our painting:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use the preceding method in our main activity class shortly. Note that,
    in the code of our image buttons in the XML file, we have mentioned an `onClick()`
    method with the method name `paintClicked`. Now is the time to create the `paintClicked`
    method in our main activity class. We will start by defining the method as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we will check whether the clicked color button is not already selected:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If not selected, we will get the tag from the button clicked and will set the
    current color for our painting to the selected tag color:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following line of code will call the `setColor()` method created earlier
    in the `CustomDrawingView` class to change the paint color:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this, we will simply update the **Control panel** to display that the
    selected button is modified by changing the Drawable of the selected button; we
    will revert the previously selected button to its normal state:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our progress status shows that we have covered three quarters of our project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We have a relatively attractive user interface for our application in place
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our application is touch enabled
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are able to draw using finger touch and drag actions; moreover, we can change
    the color or the paint brush with which we are drawing
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our current state with a rough drawing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the color selection](img/5396OS_06_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: I have tried to draw a brush that appears on the brush button, as shown in the
    preceding screenshot. I am not a good artist and it's not even a good drawing,
    but it's good enough to explain where we stand now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Spicing up our application with more functions
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core structure of our application is already complete, but we should still
    make it more useful and attractive; we need to make it more spicy with more functions,
    rather than just providing a selection of colors and painting. We will start with
    the functionality of saving our paintings to the device.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Saving the painting
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create an instance of `savePaintingButton` in our main activity class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will create its instances and will listen to its clicks in the `onCreate()`
    method in our main activity class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we write the preceding line of code for the click listener, a red line
    will appear under it, warning us that something is wrong. Right-clicking on this
    line will give us all the possible options to fix the problem. Select the option
    that best solves the problem. Let''s say that, in the example, we select the option
    of the main activity implementing the inherited `OnClickListner`; two things will
    happen. First our main activity class will inherit `OnClickListner` as shown in
    the line of code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And second, the following method will be created inside our main activity class
    with an empty body.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we will write our saving logic here inside the preceding method. To save
    our painting we will start with a reference to the layout that contains our painting
    and will enable the drawing cache for it. Then we will create a `Bitmap` object
    and will provide a drawing cache with our view objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will define a string that will contain the path where we will save
    our file and will create a `File` object that will be provided with that path:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the path doesn''t exist, we will create a new directory at that location
    and, if the path exists, we will create our file at that location, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After this we will create a `FileOutputStream` object. An output stream writes
    bytes to a file if it exists; if not, a new file is created and the stream is
    written to it. The `Bitmap` object that we have created earlier that has our drawing
    cache, we will use it to call a method `compress()` providing it with the information
    of compression type and the `FileOutputStream` object to create an image file
    for us with a `JPEG` extension. To track it back, that is, to see how the painting
    information got here in this JPEG file, the `Bitmap` object is provided with the
    `FileOutputStream` object that contains the `myPath` object. The `myPath` object
    contains the complete path where the file has to be saved and the name with which
    the file will be saved. In addition, the `Bitmap` object has already got the necessary
    information of our painting from the `View` object that we created and what''s
    available in the drawing cache at the specific moment. The block of code explains
    the creation of the output steam object and supplies it to our already created
    `Bitmap` object. The last line in the `try` block uses `MediaStore`. `MediaStore`
    contains metadata for all available media on external and internal storage devices.
    The `insertImage` from `MediaStore` will insert an image and will create a thumbnail
    for it in our gallery:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Lastly, we will add the following permission to our `AndroidManifest.xml` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Without these permissions, our application will not be allowed to read or write
    from the storage drives. For more details on permissions and its understanding,
    visit the link [http://developer.android.com/guide/topics/security/permissions.html](http://developer.android.com/guide/topics/security/permissions.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'With the end of this block of code, our saving functionality completes. Now
    we can draw and save our paintings in our gallery. The following screenshot shows
    us the saved paintings:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving the painting](img/5396OS_06_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: If we check the gallery, we will find our image saved there if we check the
    details of the newly created image, it will show us a thumbnail of the image,
    its name, and the date created. Our image is saved with our application name because
    that's what we provided as the filename in our code. We must also make sure that
    our emulator is created with SD card options. If our emulator is created without
    SD card options, this code will not work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new drawing
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a new painting or enabling the functionality of the new button, we
    need to clear whatever is currently drawn on the Canvas and clear the previous
    drawing cache. To do this, we will create an instance of the new button, a listener,
    and an `onCreate()` method just as we did for the `savePaintingButton` button.
    We will add the following code in the listener of the new button:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code will clear the screen and cache. I won''t go into the details
    of `PorterDuff` but will only write here that it''s not Android-specific. `PorterDuff`
    is the `AlphaComposite` class implementing the 12 rules defined by Porter and
    Duff. More details in reference to Android can be found in the following link:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/android/graphics/PorterDuff.html](http://developer.android.com/reference/android/graphics/PorterDuff.html)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Enabling eraser in our application
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will add one more functionality to our application in this chapter: using
    the eraser. I know I am not a Picasso and I''ll definitely need an eraser in my
    painting application. So we will write some more code to make our application
    eraser enabled. First, we will create an instance of the eraser button and a listener
    for it, as we did for the `savePaintingButton` button. The simplest way of making
    the eraser functionality is to set the paint color to that of the background color.
    It will appear that we are erasing the drawing but actually, we will be painting
    it with the paint color set as the background color.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code of our paint selection:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We know that our background color is white and, from our XML layout file, we
    know that the tag we have defined for the color white is `#FFFFFFFF` and the background
    color for our white button is `#FFFFFFFF`. So, to enable erasing in our application,
    we will simply change the values of `String color = view.getTag().toString();`
    to `String color = "#FFFFFFFF";`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and run the application. Now our application will have the erasing
    functionality. The following screenshot shows the eraser used in our application
    on our previous paint brush drawing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling eraser in our application](img/5396OS_06_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'With the eraser functionality in place, our basic paint application is complete
    but, in terms of extra spice, the extra functionalities are not limited to new,
    paint, erase, and save. We can put in a lot of other functionalities, as far as
    our imagination can take us. But one thing is clear that: whatever we plan to
    put in there, we will be using one of the things that are explained in the course
    of this book. The approach and the order in which things will be coded might be
    different but, as far as the basic 2D graphics are concerned, the lessons and
    examples in this book will cover it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned more than we actually promised at the beginning.
    What we have learned is listed as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Planning our application and the use of story boards
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rich, complex user interface with nested layouts
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of graphic objects using just XML
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of our own separate `View` class and referencing to that class in XML
    files and our main activity file code
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the `Path`, `Paint`, `Bitmap`, and `Canvas` objects
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining listeners and capturing touch events
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to those touch events
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching the color for the paint brush
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a filesystem and output streams
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving files to the storage devices
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding permissions to the `AndroidManifest.xml` file
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing the Canvas, drawing cache, and creating a new drawing
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing the already drawn painting using very simple logic
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We made it to the end of this book. This book only focuses on the very basics,
    starting from level 0 to mid-level knowledge of working with Canvas for Android.
    Still, the knowledge that is enclosed in this book will work for all kinds of
    basic 2D Android graphic applications. For a more complex application with animation,
    we might need advance-level knowledge of Android Canvas and some core knowledge
    of working with 3D in OpenGL ES. OpenGL ES is a flavor of OpenGL for embedded
    devices or handheld devices.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
