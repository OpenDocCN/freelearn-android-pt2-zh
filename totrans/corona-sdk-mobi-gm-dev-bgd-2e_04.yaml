- en: Chapter 4. Game Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So far, we have completed the first half of our game in the previous chapter.
    We started by developing the initial structure for the project by introducing
    the game objects to the screen. Currently, the paddle and ball movement is inactive,
    but everything displayed in the simulator is scaled according to the original
    game design. The last phase of completing this tutorial is to add in all the actions
    that will occur in the game, including object movement and updating the score.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the paddle using touch events and accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection between all game objects in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing objects upon collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ball movement within the screen boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Win and lose conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home stretch! We can do it!
  prefs: []
  type: TYPE_NORMAL
- en: Moving in the up direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If making objects appear on screen is exciting to you, wait till you see them
    move! The main object of Breakout is to keep the ball above the paddle position
    to stay in play and have it collide with all the bricks to complete the level.
    What keeps the suspense going is the anticipation of the ball movement around
    the game screen. This wouldn't be possible without adding physical boundaries
    on the game objects to react to collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get even more physical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about how to integrate the physics engine
    into your code. We also started implementing physical bodies to the brick objects,
    and now, we'll need to do the same with other active game objects, such as the
    paddle and ball. Let's continue with this last half of the tutorial. We will continue
    using our `main.lua` file from the `Breakout` project folder.
  prefs: []
  type: TYPE_NORMAL
- en: physics.addBody()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Corona display objects can be turned into simulated physical objects using
    one line of code. The following information explains the different forms of physics
    bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: If no shape information is specified, the display object takes on the form of
    the actual rectangular boundary of the original image to create the physics body.
    For example, if a display object is 100 x 100 pixels, then this would be the actual
    size of the physics body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a shape is specified, then the body boundaries will follow the polygon provided
    by the shape. The shape coordinates must be defined in a clockwise order, and
    the resulting shape must be convex only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a radius is specified, then the body boundaries will be circular, centered
    at the middle of the display object used to create the physics body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A body shape is a table of local (x,y) coordinates relative to the center of
    the display object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntaxes for the body shapes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Circular shapes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Polygon shapes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are the examples of the body shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Circular bodies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Polygon bodies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will discuss the parameters of the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object`: This is a display object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bodyType`: This is a string that specifies that the body type is optional.
    It uses a string parameter before the first body element. The possible types are
    `"static"`, `"dynamic"`, and `"kinematic"`. The default type is `"dynamic"` if
    no value is specified. Let''s talk about these types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static bodies don't move unless manually moved in code, and they don't interact
    with each other; examples of static objects would include the ground or the walls
    of a pinball machine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic bodies are affected by gravity and collisions with the other body types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinematic objects are affected by forces but not by gravity, so you should generally
    set draggable objects to kinematic, at least for the duration of the drag event.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Density`: This is a number that is multiplied by the area of the body''s shape
    to determine mass. It is based on a standard value of 1.0 for water. Lighter materials
    (such as wood) have a density below 1.0, and heavier materials (such as stone)
    have a density greater than 1.0\. The default value is `1.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Friction`: This is a number. This may be any non-negative value; a value of
    0 means no friction, and 1.0 means fairly strong friction. The default value is
    `0.3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bounce`: This is a number that determines the object''s velocity that is returned
    after a collision. The default value is `0.2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radius`: This is a number. This is the radius of the bounding circle in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shape`: This is a number. It is the shape value in the form of a table of
    the shape vertices, that is, {x1, y1, x2, y2, …, xn, yn}, for example, `rectangleShape
    = { -6,-48, 6,-48, 6,48, -6,48 }`. The coordinates must be defined in a clockwise
    order, and the resulting shape must be convex only. Physics assumes that the (0,0)
    point of an object is the center of the object. A *-x* coordinate will be to the
    left of object''s center and *-y* coordinate will be at the top of object''s center.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – starting physics for the paddle and ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, our display objects are rather stagnant. In order for the game play
    to initiate, we have to activate physics for collision detection to occur between
    the paddle and ball. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `gameLevel1()` function, create a new function called `startGame()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the following lines to instantiate the physics for the paddle and ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an event listener that uses the background display object to remove
    the `"tap"` event for `startGame()`. Close the function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `addGameScreen()` function that we created in the previous chapter,
    we have to add the following line after the call to the `gameLevel1()` function.
    This starts the actual game when the background is touched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The paddle object has a `"static"` body type, so it is not affected by any collision
    that occurs against it.
  prefs: []
  type: TYPE_NORMAL
- en: The ball object has a `"dynamic"` body type because we want it to be affected
    by the collisions on the screen due to directional changes caused by the wall
    borders, bricks, and paddle.
  prefs: []
  type: TYPE_NORMAL
- en: The event listener on the background is removed from the `startGame()` function;
    this way, it doesn't affect any of the other touch events that are applied in
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Paddle movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting the paddle to move side to side is one of the key actions that needs
    to be accomplished. Part of the game design is to prevent the ball from reaching
    the bottom of the screen. We will be separating the paddle movement in the simulator
    and the accelerometer. The movement in the simulator enables us to test with touch
    events since accelerometer actions cannot be tested in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – dragging the paddle in the simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, the paddle does not move at all. There are no coordinates set that
    will allow the paddle to move side to side on the screen. So let''s create them
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `addGameScreen()` function, create a new function called `dragPaddle(event)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll focus on moving the paddle side to side within the boundary of
    the game screen. Add in the following block of code to enable paddle movement
    in the simulator and then close the function. The reason for adding this block
    is because the simulator does not support accelerometer events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'See the following image of the ball colliding with the bricks and the paddle
    and anticipate where the ball will move towards next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – dragging the paddle in the simulator](img/9343OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a function where the drag event only works in the simulator.
    For `if event.phase == "began"`, a touch event has been made to the paddle. On
    `elseif event.phase == "moved"`, a touch event where the paddle moved from its
    original position has been made.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep the paddle from moving past the wall boundaries, `paddle.x`
    does not go less than `0` in the *x* direction when it hits the coordinate. When
    the paddle slides to the right-hand side of the screen, `paddle.x` does not go
    greater than `display.contentWidth` in the *x* direction.
  prefs: []
  type: TYPE_NORMAL
- en: There is no designated coordinate for the right-hand side of the screen since
    the code is supposed to be universal for all screen sizes on iOS and Android devices.
    Both platforms have varying screen resolutions, so `display.contentWidth` takes
    this into account.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – moving the paddle with the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, accelerometer events cannot be tested in the simulator.
    They only work when a game build is uploaded to a device to see the results. The
    paddle movement will stay within the wall borders of the level across the *x*
    axis. To move the paddle, follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `dragPaddle()` function, create a new function called `movePaddle(event)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the accelerometer movement using `yGravity`. It provides acceleration
    due to gravity in the *y* direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the wall borders for the level and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for the landscape mode,
    the `xGravity` and `yGravity` values are switched to compensate for the events
    to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have applied the same code for the paddle from `function dragPaddle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This still keeps the paddle from going past any wall boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Ball collision with the paddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motion of the ball has to flow in a fluid manner every time it collides
    with the paddle. This means proper direction changes on all sides of the game
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the ball bounce against the paddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will check which side of the paddle the ball has hit to choose the side
    where it will move next. It''s important to have the motion to follow through
    any directional hits as it would in a realistic environment. With every paddle
    collision, we want to make sure that the ball goes in the up direction. For this,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `bounce()` for the ball after the `movePaddle()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in a value of `-3` for velocity in the *y* direction. This will make the
    ball move in an upward motion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check when a collision is made with the `paddle` and `ball` objects and close
    the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the ball collides with the paddle, the motion follows through, depending
    on what side of the paddle is touched by the ball. In the first part of the `if`
    statement, the ball travels toward 0 in the *x* direction. The last part of the
    `if` statement shows the ball travelling toward the opposite side of the screen
    in the *x* direction.
  prefs: []
  type: TYPE_NORMAL
- en: Removing objects from the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are limited resources on a device. As much as we wish they were as powerful
    as a desktop to hold so much memory, it's not at that point yet. This is why it
    is important to remove display objects from the display hierarchy when you no
    longer use them in your application. This helps overall system performance by
    reducing memory consumption and eliminates unnecessary drawing.
  prefs: []
  type: TYPE_NORMAL
- en: When a display object is created, it is added by default to the root object
    of the display hierarchy. This object is a special kind of group object known
    as the **stage** object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep an object from rendering on screen, it needs to be removed
    from the scene. The object needs to be removed explicitly from its parent. This
    removes the object from the display hierarchy. This can be done in either in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be done using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This does not free all the memory from the display object. To make sure that
    the display object is removed properly, we need to eliminate all the variable
    references to it.
  prefs: []
  type: TYPE_NORMAL
- en: Variable references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though a display object has been removed from the hierarchy, there are
    situations in which the object continues to exist. To do this, we will set the
    property to `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Brick by brick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bricks in the game are the main obstacles, since they have to be cleared
    in order to move on to the next round. In this version of Breakout, the player
    must destroy all the bricks in one turn. Failure to do so results in starting
    over from the beginning of the current level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – removing the bricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the ball collides with a brick, we will use the same technique applied
    to the paddle to determine the path the ball will follow. When a brick is hit,
    we''ll need to figure out which brick has been touched and then remove it from
    both the stage and the bricks group. Each brick removal will increment 100 points
    to the score. The score will be taken from the `score` constant and added to the
    current score as text. To remove the bricks from the game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `gameLevel2()` function, create a function called `removeBrick(event)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check which side of the brick the ball hits by using the `if` statement. When
    checking for an event, we''ll refer the event to the object name, `"brick"`. This
    is the name we gave our `brick` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the following `if` statement to remove the brick from the scene when
    the ball collides with one. After a collision has been made, increase `score`
    by 1\. Initiate `scoreNum` to take the value of the score and multiply it by `scoreIncrease`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When all the bricks in the level are destroyed, create an `if` statement that
    pops up the alert screen for a win condition and set the `gameEvent` string to
    `"win"`;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the ball colliding with the paddle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – removing the bricks](img/9343OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember from the previous chapter, we gave the `brick` objects a name
    called `"brick"`.
  prefs: []
  type: TYPE_NORMAL
- en: When the ball hits the left-hand side of any of the individual bricks, it travels
    towards the left. When the ball hits the right-hand side of the bricks, it travels
    toward the right. The width of each object is taken as a whole to calculate the
    direction in which the ball travels.
  prefs: []
  type: TYPE_NORMAL
- en: When a brick is hit, the ball bounces upward (the *y* direction). After every
    collision the ball makes with a brick, the brick is removed from the scene and
    destroyed from the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `bricks.numChildren – 1` statement subtracts the count from the total number
    of bricks it started out with originally. When a brick is removed, the score increments
    100 points each time. The `scoreNum` text object updates the score every time
    a brick is hit.
  prefs: []
  type: TYPE_NORMAL
- en: When all the bricks are gone, the alert screen pops up with a notification that
    the player has won the level. We also set `gameEvent` equal to `"win"`, which
    will be used in another function that will transition the event to a new scene.
  prefs: []
  type: TYPE_NORMAL
- en: Directional changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the ball motion against the paddle, the other factor is the collision
    state against the wall borders. When a collision occurs, the ball diverts its
    direction in the opposite way. For every action, there is a reaction, just like
    real-world physics.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – updating the ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ball needs to move in a continuous motion without gravity affecting it.
    We''ll have to take into account the side walls and the top and bottom walls.
    The velocity in the *x* and *y* direction have to reflect the other way when a
    collision happens on any of the boundaries. We need to set coordinates so that
    the ball is only allowed to move through and alert when it passes through the
    area below the paddle region. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `function updateBall()` below the `removeBrick(event)`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the ball movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the ball movement for the *x* direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the movement of ball in the *x* direction:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – updating the ball](img/9343OT_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add in the ball movement for the *y* direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the movement of the ball in the *y* direction:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – updating the ball](img/9343OT_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add in the ball movement when it collides with the bottom of the game play
    screen. Create the lost alert screen and a game event for `"lose"`. Close the
    function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the lost alert screen when the ball collides
    with the bottom of the game play screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – updating the ball](img/9343OT_04_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everywhere the ball travels, proper direction change is needed when it hits
    the wall. Any time the ball hits the side walls, we used `vx = -vx`. When the
    ball hits the top boundary, `vy = -vy` is used. The only time the ball doesn't
    reflect the opposite direction is when it hits the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The alert screen displays the lose condition, which emphasizes to the player
    to play again. The `gameEvent = "lose"` statement will be used in another `if`
    statement to reset the current level.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a win or lose condition occurs, the game needs a way to transition to the
    next level or repeat the current one. The main game objects have to be reset to
    their starting position and the bricks redrawn. It's pretty much the same idea
    as when you first start a game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – resetting and changing levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll need to create functions that set up the first and second levels in
    the game. If a level needs to be replayed, only the current level the user lost
    in can be accessed. Follow these steps to transition between the levels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `changeLevel1()`. This will be placed below the
    `updateBall()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clear the `bricks` group when the player loses the round, and then reset them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove `alertDisplayGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reset the `ball` and `paddle` positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Redraw the bricks for the current level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an event listener to the `background` object for `startGame()`. Close the
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new function called `changeLevel2()`. Apply the same code used
    for `changeLevel1()`, but make sure that the bricks are redrawn for `gameLevel2()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a level needs to be reset or changed, the display objects have to be wiped
    from the screen. In this case, we removed the `bricks` group using `bricks:removeSelf()`.
  prefs: []
  type: TYPE_NORMAL
- en: When any alert screen pops up, whether win or lose, the entire `alertDisplayGroup`
    is removed during the reset as well. The `ball` and `paddle` objects are set back
    to their starting position.
  prefs: []
  type: TYPE_NORMAL
- en: The `gameLevel1()` function is called to redraw the bricks for level 1\. The
    function holds the initial setup for the `brick` display objects and `bricks`
    group.
  prefs: []
  type: TYPE_NORMAL
- en: The `background` object is used again to call the `startGame()` function with
    an event listener. When level 2 needs to be set up, the same procedure like in
    function `changeLevel1()`is used, but `changeLevel2()` and `gameLevel2()` are
    called to redraw the bricks.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero –add more levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, the game only has two levels. What can be done to extend this game
    is to add more levels. They can be created using the same logic used for `gameLevel1()`
    and `gameLevel2()`, by adjusting the numbers used to create rows and columns of
    bricks. You'll have to create a new function that resets the level. We can use
    the same method followed for `changeLevel1()` and `changeLevel2()` to recreate
    a level and reset it.
  prefs: []
  type: TYPE_NORMAL
- en: You win some, you lose some
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing is more exhilarating than the anticipation of winning. That is until
    you make that one small mistake, and it causes you to start over. Don't worry;
    it's not the end of the world; you can always try again and learn from your errors
    to beat the level.
  prefs: []
  type: TYPE_NORMAL
- en: Game events such as a win or lose condition will alert the player of their progress.
    The game has to have some way of guiding the player about what action they need
    to take next to replay the level or move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action –making win and lose conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For any game alerts to even appear during game play, we need to create some
    `if` statements for every possible scenario available in each level. When this
    occurs, the score needs to be reset back to zero. To make the win and lose conditions,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `alertScreen()` function, create a new function called `restart()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `if` statement for a `"win"` game event when the first level has
    been completed and transitions to level 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tostring()` method converts any argument to a string. In the preceding
    example, the `currentLevel` value changes from `1` to `2` when a `"win"` game
    event occurs. The value will convert to a string format that the `levelNum` text
    object can display on screen for level 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an `elseif` statement for a `"win"` game event when the second level has
    been completed and when it notifies the player that the game has been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `elseif` statement for the `"lose"` game event at the first level.
    Reset the score to zero and replay level 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `elseif` statement for a `"lose"` game event at the second level.
    Reset the score to zero and replay level 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add another `elseif` statement for `gameEvent = "completed"`. Close
    the function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to backtrack and add an event listener to the `alertScreen()`
    function using the `alertBox` object. We will add it to the bottom of the function.
    This will activate the `restart()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `restart()` function checks all the `gameEvent` and `currentLevel` variables
    that occur during game play. When a game event checks for the `"win"` string,
    it also goes down the list of statements to see what comes out true. For example,
    if the player wins and is currently on level 1, then the player moves on to level
    2.
  prefs: []
  type: TYPE_NORMAL
- en: If the player loses, `gameEvent == "lose"` becomes true, and the code checks
    what level the player lost in. For any level the player loses in, the score reverts
    to 0, and the current level the player was on is set up again.
  prefs: []
  type: TYPE_NORMAL
- en: Activating event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event listeners in this game basically turn the movements of the objects
    on and off. We have already coded the functions that carry out the actions of
    our game objects to run the level. Now, it's time to activate them using a certain
    type of events. As you've noticed from the previous chapter, we can add event
    listeners to display objects or have them run globally.
  prefs: []
  type: TYPE_NORMAL
- en: Collision events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collision events within the physics engine occur through Corona''s event listener
    model. There are three new event types, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"collision"`: This event includes phases for `"began"` and `"ended"`, which
    signify the moments of initial contact and broken contact. These phases exist
    for both normal two-body collisions and body-sensor collisions. If you do not
    implement a `"collision"` listener, this event will not fire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"preCollision"`: This is an event type that fires right before the objects
    start to interact. Depending on your game logic, you may wish to detect this event
    and conditionally override the collision. It may also result in multiple reports
    per contact and affect the application''s performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"postCollision"`: This is an event type that fires right after the objects
    have interacted. This is the only event in which the collision force is reported.
    If you do not implement a `"postCollision"` listener, this event will not fire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collisions are reported between pairs of objects and can be detected either
    globally, using a runtime listener, or locally within an object, using a table
    listener.
  prefs: []
  type: TYPE_NORMAL
- en: Global collision listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When detected as a runtime event, each collision event includes `event.object1`,
    which contains the table ID of the Corona display object involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Local collision listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When detected with a table listener within an object, each collision event includes
    `event.other`, which contains the table ID of the other display object involved
    in the collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – adding game listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For many of the functions we have created for our game objects, we need to
    activate the event listeners so that they will run the code and then disable them
    when game play has stopped. To add game listeners, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function we need to create in order to complete this game is called
    `gameListeners()`, which will also have a parameter called `event`. This should
    be added right after the `gameLevel2()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the following event listeners that will start several events in the
    application, using an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll add in an `elseif` statement for the event listeners that will
    remove the events and then close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order for `function gameListeners()` to work properly, we need to instantiate
    it in the `startGame()` function using the `"add"` string in the parameter. Place
    it before the end of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `alertScreen()` function, add the `"remove"` string in the parameter
    and place it at the start of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the code has been written! Go ahead and run the game in the simulator. The
    application is also device ready. Make a simple icon image that fits the required
    dimensions for the device you're developing on. Compile a build and run it on
    your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two sets of `if` statements for the `event` parameter: `"add"` and
    `"remove"`.'
  prefs: []
  type: TYPE_NORMAL
- en: All the event listeners in this function play an important role in making the
    game run. The `"accelerometer"` and `"enterframe"` events are used as runtime
    events since they have no specific target.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `paddle` and `ball` objects have `"collision"` events that will carry
    out their purpose in any object contact made.
  prefs: []
  type: TYPE_NORMAL
- en: The `"touch"` event allows the user to touch and drag the paddle so that it
    can move back and forth in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when `event == "remove"`, it removes all the event listeners that
    were active in the game. When the game starts, `gameListeners("add")` is activated.
    When a win or lose condition is achieved, `gameListeners("remove")` is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – let's turn everything upside down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we decided to flip the game upside down, that is, have the paddle placed
    near the top of the screen, the ball below the paddle, and the group of bricks
    closer to the bottom of the screen?
  prefs: []
  type: TYPE_NORMAL
- en: 'Things you''ll have to consider are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The top wall is now the area you have to keep the ball from entering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *y* direction is where the ball travels when it collides with the bricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ball has to reflect off the bottom wall when it collides with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are a couple of things to consider before switching values
    from negative to positive and vice versa. Be sure to verify your logic and ensure
    that it makes sense when creating this new variation.
  prefs: []
  type: TYPE_NORMAL
- en: The results are in!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's summarize what has been made to make sure that you have everything added
    into your game. You can also refer to the `Breakout Final` folder in the `Chapter
    4` folder to see the final code. You made sure that the necessary variables were
    introduced in the game. You also initialized the `main()` function that starts
    the game play. A main menu screen was implemented with the game title and a play
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you transitioned the `menuScreenGroup` away from the screen to load the
    main playing field. The main display objects of the game, such as the paddle,
    ball, and bricks, were added. The score and level number were displayed as the
    UI elements and updated throughout game play. Paddle movement in both the simulator
    and accelerometer were added as well as the collision detection with the paddle
    and the ball.
  prefs: []
  type: TYPE_NORMAL
- en: The physical properties of the paddle and ball were added at the start of the
    game. The brick layouts for each of the two levels were created. You have also
    added event listeners to all our game objects from the point when they need to
    be activated during the game and removed when game play is over.
  prefs: []
  type: TYPE_NORMAL
- en: Every time the ball collides with a brick, the brick is removed from the scene.
    The directional changes of the ball are updated for every wall, paddle, or brick
    collision made. Every time a win or lose condition occurred, all game objects
    are reset to begin the start of the current or new level.
  prefs: []
  type: TYPE_NORMAL
- en: When a condition occurs, an alert screen pops up, notifying the player of what
    has happened. The display objects that initiate the alerts are created in a function.
    Finally, the win and lose arguments are created to determine whether the current
    level has to be replayed, whether the player goes to the next level, or whether
    the game has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of case-sensitive variables and functions in case you run into errors.
    Also, be sure to check whether you're missing any punctuation required in your
    code. These can be easily overlooked. Refer to your terminal window in the simulator
    for any error references.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – working with game controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. How do you properly remove a display object from the stage?
  prefs: []
  type: TYPE_NORMAL
- en: '`remove()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object: remove()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object:removeSelf()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object = nil`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What is the correct way to make the following display object into a physics
    object?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`physics.addBody( ball, { density=2.0, friction=0.5, bounce=0.2,radius = 25
    })`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`physics.addBody( ball, "dynamic", { density=2.0, friction=0.5, bounce=0.2,radius
    = 15 } )`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1and 2`.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What best represents what `"began"` means in the following function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A finger was moved on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A finger was lifted from the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system cancelled tracking the start touch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A finger touched the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You have completed making your very first game! You should
    be very proud of yourself. Now, you have experienced how simple it is to make
    an application with Corona SDK. It can take just a few hundred lines of code to
    make an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Added movement to the paddle with touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced the accelerometer features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented collision event listeners for all game objects affected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed objects from memory when they weren't needed on the game screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented movement of the ball as a physical object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated a scoreboard for every brick collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to handle win and lose conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two chapters weren't so bad now, were they? You're getting familiar
    with the workflow as you continue programming in Lua. It will definitely get easier
    to understand as long as you keep progressing and working with different game
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter holds another game that will surely catch your attention. You'll
    create animated sprite sheets for your display objects. How's that for eye candy?
  prefs: []
  type: TYPE_NORMAL
