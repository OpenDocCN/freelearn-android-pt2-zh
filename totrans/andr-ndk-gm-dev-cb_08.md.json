["```kt\n    Java_com_packtpub_ndkcookbook_game1_Game1Activity_SendMotion(\n      JNIEnv * env, jobject obj, int PointerID, int x, int y,\n      bool Pressed, int Flag)\n      {                        \n      LVector2 Pos = LVector2( (float)x / (float)g_Width,\n      (float)y / (float)g_Height );\n      GestureHandler_SendMotion( PointerID, (eMotionFlag)Flag,\n        Pos,Pressed );\n    }\n    ```", "```kt\n    struct sSendMotionData\n    {\n      int ContactID;\n      eMotionFlag Flag;\n      LVector2 Pos;\n      bool Pressed;\n    };\n    ```", "```kt\n    Mutex g_MotionEventsQueueMutex;\n    std::vector<sSendMotionData> g_MotionEventsQueue;\n    ```", "```kt\n    Java_com_packtpub_ndkcookbook_game1_Game1Activity_SendMotion(\n      JNIEnv * env, jobject obj, int PointerID, int x, int y,\n      bool Pressed, int Flag)\n    {                        \n      sSendMotionData M;\n      M.ContactID = PointerID;\n      M.Flag = (eMotionFlag)Flag;\n      M.Pos = LVector2( (float)x / (float)g_Width,\n        (float)y / (float)g_Height );\n      M.Pressed = Pressed;\n      LMutex Lock( &g_MotionEventsQueueMutex );\n      g_MotionEventsQueue.push_back( M );\n    }\n    ```", "```kt\nJava_com_packtpub_ndkcookbook_game1_Game1Activity_DrawFrame(\n  JNIEnv* env, jobject obj )\n{\n```", "```kt\n  {\n    LMutex Lock(&g_MotionEventsQueueMutex );\n    for( auto m : g_MotionEventsQueue )\n    {\n      GestureHandler_SendMotion( m.ContactID, m.Flag,\n        m.Pos, m.Pressed );\n    }\n    g_MotionEventsQueue.clear();\n  }\n  GenerateTicks();\n}\n```", "```kt\n    class clAudioThread: public iThread\n    {\n    public:\n    …\n      void RegisterSource( clAudioSource* Src );\n      void UnRegisterSource( clAudioSource* Src );\n    ```", "```kt\n    private:\n    …\n      std::vector< clAudioSource* > FActiveSources;\n      Mutex FMutex;\n    };\n    ```", "```kt\n    void clAudioThread::Run()\n    {\n      if ( !LoadAL() ) { return; }\n      FDevice = alcOpenDevice( NULL );\n      FContext = alcCreateContext( FDevice, NULL );\n      alcMakeContextCurrent( FContext );\n      FInitialized = true;\n      FPendingExit = false;\n      double Seconds = GetSeconds();\n    ```", "```kt\n      while ( !IsPendingExit() )\n      {\n        float DeltaSeconds = static_cast<float>(\n        GetSeconds() - Seconds );\n    ```", "```kt\n        {\n          LMutex Lock(&FMutex );\n          for( auto i = FActiveSources.begin();\n          i != FActiveSources.end(); i++ )\n          {\n            ( *i )->Update( DeltaSeconds );\n          }\n        }\n        Seconds = GetSeconds();\n    ```", "```kt\n        Env_Sleep( 100 );\n      }\n      alcDestroyContext( FContext );\n      alcCloseDevice( FDevice );\n      UnloadAL();\n    }\n    ```", "```kt\n    void clAudioThread::RegisterSource( clAudioSource* Src )\n    {\n      LMutex Lock(&FMutex );\n    ```", "```kt\n      auto i = std::find( FActiveSources.begin(),\n      FActiveSources.end(), Src );\n      if ( i != FActiveSources.end() ) return;\n      FActiveSources.push_back( Src );\n    }\n    void clAudioThread::UnRegisterSource( clAudioSource* Src )\n    {\n      LMutex Lock(&FMutex );\n    ```", "```kt\n      auto i = std::find( FActiveSources.begin(),\n    FActiveSources.end(), Src );\n      if ( i != FActiveSources.end() ) FActiveSources.erase( i );\n    }\n    ```", "```kt\nclAudioSource::clAudioSource()\n{\n…\n  g_Audio.RegisterSource( this );\n}\n\nclAudioSource::~clAudioSource()\n{\n…\n  g_Audio.UnRegisterSource( this );\n}\n```", "```kt\nclAudioThread g_Audio;\n```", "```kt\ng_Audio.Start( iThread::Priority_Normal );\ng_Audio.Wait();\n```", "```kt\nMusic = new clAudioSource();\nMusic->BindWaveform(new\nclModPlugProvider( LoadFileAsBlob(\"test.xm\")) );\nMusic->LoopSound( true );\nMusic->Play();\n```", "```kt\n      @Override protected void onPause()\n      {\n        super.onPause();\n        ExitNative();\n      }\n      public static native void ExitNative();\n    ```", "```kt\n    JNIEXPORT void JNICALL Java_com_packtpub_ndkcookbook_game1_Game1Activity_ExitNative(\n      JNIEnv* env, jobject obj )\n    {\n    OnStop();\n      exit( 0 );\n    }\n    ```", "```kt\nvoid OnStop()\n{\n}\n```", "```kt\nwhile ( !PendingExit )\n{\n  …\n}\nOnStop();\n```", "```kt\n    void GenerateTicks()\n    {\n    ```", "```kt\n      NewTime = GetSeconds();\n      float DeltaSeconds = static_cast<float>( NewTime - OldTime );\n      OldTime = NewTime;\n    ```", "```kt\n      const float TIME_QUANTUM = 1.0f / 60.0f;\n    ```", "```kt\n      const float MAX_EXECUTION_TIME = 10.0f * TIME_QUANTUM;\n    ```", "```kt\n      ExecutionTime += DeltaSeconds;\n      if ( ExecutionTime > MAX_EXECUTION_TIME )\n      { ExecutionTime = MAX_EXECUTION_TIME; }\n    ```", "```kt\n      while ( ExecutionTime > TIME_QUANTUM )\n      {\n        ExecutionTime -= TIME_QUANTUM;\n        OnTimer( TIME_QUANTUM );\n      }\n    ```", "```kt\n      OnDrawFrame();\n    }\n    ```", "```kt\nif ( ExecutionTime > MAX_EXECUTION_TIME )\n  { ExecutionTime = MAX_EXECUTION_TIME; }\n```", "```kt\nif ( !IsPaused() ) OnDrawFrame();\n```", "```kt\n    LGL3->glDisable( GL_DEPTH_TEST );\n    ```", "```kt\n    BackTexture_Bottom->Bind(2);\n    BackTexture_Top->Bind(1);\n    BackTexture->Bind(0);\n    BackShader->Bind();\n    ```", "```kt\n    BackShader->SetUniformNameFloatArray( \"b_MoveLeft\",  1, \n      b_Flags[b_MoveLeft] );\n    BackShader->SetUniformNameFloatArray( \"b_Down\",      1, \n      b_Flags[b_Down] );\n    BackShader->SetUniformNameFloatArray( \"b_MoveRight\", 1, \n      b_Flags[b_MoveRight] );\n    BackShader->SetUniformNameFloatArray( \"b_TurnLeft\",  1, \n      b_Flags[b_TurnLeft] );\n    BackShader->SetUniformNameFloatArray( \"b_TurnRight\", 1, \n      b_Flags[b_TurnRight] );\n    BackShader->SetUniformNameFloatArray( \"b_Reset\",     1, \n      b_Flags[b_Reset] );\n    BackShader->SetUniformNameFloatArray( \"b_Paused\",    1, \n      b_Flags[b_Paused] );\n    ```", "```kt\n    Canvas->GetFullscreenRect()->Draw(false);\n    ```", "```kt\n    for ( int i = 0; i < g_Field.FWidth; i++ )\n    {\n      for ( int j = FIELD_INVISIBLE_RAWS;j < g_Field.FHeight; j++ )\n      {\n        int c = g_Field.FField[i][j];\n        if ( c >= 0 && c < NUM_COLORS )\n        {\n          int Img = c % NUM_BRICK_IMAGES;\n          int P = ( j - FIELD_INVISIBLE_RAWS );\n    ```", "```kt\n          DrawTexQuad( i * 20.0f + 2.0f,\n          P * 20.0f + 2.0f,16.0f, 16.0f,\n          Field_X1, Field_Y1,\n          g_Colors[c], Img );\n        }\n      }\n    }\n    ```", "```kt\n    DrawFigure(&g_CurrentFigure, g_GS.FCurX,\n          g_GS.FCurY - FIELD_INVISIBLE_RAWS,Field_X1, Field_Y1,\n          BLOCK_SIZE );\n    ```", "```kt\n      int Cx1, Cy1, Cx2, Cy2;\n      g_NextFigure.GetTopLeftCorner(&Cx1, &Cy1 );\n      g_NextFigure.GetBottomRightCorner(&Cx2, &Cy2 );\n      LRect FigureSize = g_NextFigure.GetSize();\n      float dX = ( float )Cx1 * BLOCK_SIZE_SMALL / 800.0f;\n      float dY = ( float )Cy1 * BLOCK_SIZE_SMALL / 600.0f;\n      float dX2 = 0.5f * (float)Cx2 * BLOCK_SIZE_SMALL/800.0f;\n      float dY2 = 0.5f * (float)Cy2 * BLOCK_SIZE_SMALL/600.0f;\n      DrawFigure( &g_NextFigure, 0, 0, 0.415f - dX - dX2,\n        0.77f - dY - dY2, BLOCK_SIZE_SMALL );\n    ```", "```kt\n    std::string ScoreString( Str_GetFormatted( \"%02i:%06i\",\n    g_GS.FLevel, g_GS.FScore ) );\n    if ( g_ScoreText != ScoreString )\n    {\n      g_ScoreText = ScoreString;\n      g_ScoreBitmap = g_TextRenderer->RenderTextWithFont(\n        ScoreString.c_str(), g_Font,32, 0xFFFFFFFF, true );\n      g_ScoreTexture->LoadFromBitmap( g_ScoreBitmap );\n    }\n    ```", "```kt\n      LVector4 Color( 0.741f, 0.616f, 0.384f, 1.0f );\n      Canvas->TexturedRect2D( 0.19f, 0.012f, 0.82f, 0.07f,Color,\n      g_ScoreTexture );\n    ```", "```kt\n      if ( g_GS.FGameOver )\n      {\n        DrawBorder( 0.05f, 0.25f, 0.95f, 0.51f, 0.19f );\n        std::string ScoreStr = Str_GetPadLeft(\n        Str_ToStr( g_GS.FScore ), 6, '0' );\n        Canvas->TextStr( 0.20f, 0.33f, 0.84f, 0.37f,\n        LocalizeString(\"Your score:\"), 32,\n        LVector4( 0.796f, 0.086f,0.086f, 1.0f ),\n        g_TextRenderer, g_Font );\n        Canvas->TextStr( 0.20f, 0.38f, 0.84f, 0.44f,ScoreStr,\n        32, LVector4( 0.8f, 0.0f, 0.0f,1.0f ),\n        g_TextRenderer, g_Font );\n      }\n    ```", "```kt\nvoid DrawTexQuad( float x, float y, float w, float h,\nfloat OfsX, float OfsY,\nconst LVector4& Color, int ImageID )\n{\n```", "```kt\n  float X1 = x / 800.0f;\n  float Y1 = y / 600.0f;\n  float X2 = ( x + w ) / 800.0f;\n  float Y2 = ( y + h ) / 600.0f;\n```", "```kt\n  X1 *= Field_Width / 0.35f;\n  X2 *= Field_Width / 0.35f;\n  Y1 *= Field_Height / 0.75f;\n  Y2 *= Field_Height / 0.75f;\n  Canvas->TexturedRect2D( X1 + OfsX, Y1 + OfsY,\n  X2 + OfsX, Y2 + OfsY,\n  Color, BricksImage[ImageID] );\n  }\n```", "```kt\nvoid DrawFigure( clBricksShape* Figure, int X, int Y,\nfloat OfsX, float OfsY, float BlockSize )\n{\n  for ( int i = 0 ; i < Figure->FWidth ; i++ )\n  {\n    for ( int j = 0 ; j < Figure->FHeight ; j++ )\n    {\n```", "```kt\n      if ( Y + j < 0 ) { continue; }\n      intc = Figure->GetMask( i, j );\n      if ( c >= 0 && c < NUM_COLORS )\n      {\n        DrawTexQuad(\n          (X + i) *(BlockSize + 4.0f) + 2.0f,\n          (Y + j) * (BlockSize + 4.0f) + 2.0f,\n          BlockSize, BlockSize, OfsX, OfsY,\n          g_Colors[c], c % NUM_BRICK_IMAGES );\n        }\n    }\n  }\n}\n```", "```kt\nvoid DrawBorder( float X1, float Y1, float X2, float Y2,\n float Border )\n{\n  Canvas->TexturedRect2D( X1, Y1, X1+Border, Y2,\n    LVector4( 1.0f ), MsgFrameLeft  );\n  Canvas->TexturedRect2D( X2-Border, Y1, X2, Y2,\n    LVector4( 1.0f ), MsgFrameRight );\n  Canvas->TexturedRect2DTiled( X1+Border, Y1, X2-Border, Y2,\n    3, 1, LVector4( 1.0f ), MsgFrameCenter );\n}\n```", "```kt\nuniform float b_MoveLeft;\nuniform float b_Down;\nuniform float b_MoveRight;\nuniform float b_TurnLeft;\nuniform float b_TurnRight;\nuniform float b_Reset;\nuniform float b_Paused;\n```", "```kt\nbool ContainsPoint( vec2 Point, vec4 Rect )\n{\n  return Point.x >= Rect.x && Point.y >= Rect.y &&\n  Point.x <= Rect.z && Point.y <= Rect.w;\n}\n```", "```kt\nvoid main()\n{\n  const vec4 MoveLeft  = vec4( 0.0,  0.863, 0.32, 1.0 );\n  const vec4 Down      = vec4( 0.32, 0.863, 0.67, 1.0 );\n  const vec4 MoveRight = vec4( 0.67, 0.863, 1.0,  1.0 );\n  const vec4 TurnLeft  = vec4( 0.0,  0.7,  0.4,  0.863);\n  const vec4 TurnRight = vec4( 0.6,  0.7,  1.0,  0.863);\n  const vec4 Reset     = vec4( 0.0,  0.0,  0.2,  0.1 );\n  const vec4 Paused    = vec4( 0.8,  0.0,  1.0,  0.1 );\n```", "```kt\n  vec4 Color      = texture( Texture0,TexCoord );\n  vec4 ColorHighT = texture( Texture1,TexCoord*vec2(4.0,8.0) );\n  vec4 ColorHighB = texture( Texture2,TexCoord*vec2(1.0,2.0) );\n```", "```kt\n  if ( b_MoveLeft>0.5 &&ContainsPoint(TexCoord.xy, MoveLeft))\n    Color = ColorHighB;\n  if ( b_Down> 0.5 && ContainsPoint( TexCoord.xy, Down ) )\n    Color = ColorHighB;\n  if ( b_MoveRight>0.5 && ContainsPoint(TexCoord.xy,MoveRight) )\n    Color = ColorHighB;\n  if ( b_TurnLeft>0.5 && ContainsPoint(TexCoord.xy, TurnLeft) )\n    Color = ColorHighB;\n  if ( b_TurnRight>0.5 && ContainsPoint(TexCoord.xy,TurnRight) )\n    Color = ColorHighB;\n  if ( b_Reset> 0.5 && ContainsPoint( TexCoord.xy, Reset) )\n    Color = ColorHighT;\n  if ( b_Paused> 0.5 && ContainsPoint( TexCoord.xy, Paused ) )\n    Color = ColorHighT;\n```", "```kt\n   out_FragColor = Color;\n}\n```", "```kt\n    class clBricksShape\n    {\n    public:\n    ```", "```kt\n      static const int FWidth  = SHAPES_X;\n      static const int FHeight = SHAPES_Y;\n    ```", "```kt\n    private:\n      int FColor[NUM_COLORS];\n    ```", "```kt\n      int FFigureIndex;\n    ```", "```kt\n      int FRotationIndex;\n    ```", "```kt\n    public:\n      int GetMask( int i, int j ) const\n      {\n        if ( i < 0 || j < 0 ) return -1;\n        if ( i >= FWidth || j >= FHeight ) return -1;\n        int ColorIdx =\n        Shapes[FFigureIndex][FRotationIndex][i][j];\n        return ColorIdx ? FColor[ColorIdx] : -1;\n      }\n    ```", "```kt\n      void Rotate( bool CW )\n      {\n        FRotationIndex = CW ?\n             ( FRotationIndex ? FRotationIndex - 1 : ROTATIONS - 1 ) :\n             ( FRotationIndex + 1 ) % ROTATIONS;\n      }\n    ```", "```kt\n      void GenFigure( int FigIdx, int Col )\n      {\n        for ( int i = 0; i != NUM_COLORS; i++ )\n          FColor[i] = Random( NUM_COLORS );\n        FFigureIndex = FigIdx;\n        FRotationIndex = 0;\n      }\n    ```", "```kt\n    void GetTopLeftCorner( int* x, int* y ) const;\n      void GetBottomRightCorner( int* x, int* y ) const;\n      LRect GetSize() const;\n    };\n    ```", "```kt\nstatic const int NUM_SHAPES = 22;\nstatic const int SHAPES_X = 5;\nstatic const int SHAPES_Y = 5;\nstatic const int ROTATIONS = 4;\nextern char\n  Shapes[ NUM_SHAPES ][ ROTATIONS ][ SHAPES_X ][ SHAPES_Y ];\n```", "```kt\nchar Shapes [ NUM_SHAPES ][ ROTATIONS ][ SHAPES_X ][ SHAPES_Y ] =\n{\n  {\n    {\n      {0, 0, 0, 0, 0},\n      {0, 0, 0, 1, 0},\n      {0, 0, 3, 2, 0},\n      {0, 5, 4, 0, 0},\n      {0, 0, 0, 0, 0}\n    },\n    {\n      {0, 0, 0, 0, 0},\n      {0, 5, 0, 0, 0},\n      {0, 4, 3, 0, 0},\n      {0, 0, 2, 1, 0},\n      {0, 0, 0, 0, 0}\n    },\n    {\n      {0, 0, 0, 0, 0},\n      {0, 0, 4, 5, 0},\n      {0, 2, 3, 0, 0},\n      {0, 1, 0, 0, 0},\n      {0, 0, 0, 0, 0}\n    },\n    {\n      {0, 0, 0, 0, 0},\n      {0, 1, 2, 0, 0},\n      {0, 0, 3, 4, 0},\n      {0, 0, 0, 5, 0},\n      {0, 0, 0, 0, 0}\n    }\n  },\n```", "```kt\n    class clBricksField\n    {\n    public:\n    ```", "```kt\n      static const int FWidth = 11;\n      static const int FHeight = 22;\n    public:\n      void clearField()\n    ```", "```kt\n      bool figureFits( int x, int y, const clBricksShape& fig )\n      bool figureWillHitNextTurn( int x, int y,\n        const clBricksShape& fig )\n    ```", "```kt\n      void addFigure( int x, int y, const clBricksShape& fig )\n    ```", "```kt\n      int deleteLines();\n      int CalcNeighbours( int i, int j, int Col );\n      void FillNeighbours( int i, int j, int Col );\n    ```", "```kt\n      int deleteRegions( int NumRegionsToDelete );\n      void collapseField();\n    ```", "```kt\n    public:\n        int FField[ FWidth ][ FHeight ];\n    };\n    ```", "```kt\nint clBricksField::deleteRegions( int NumRegionsToDelete )\n{\n  int NumRegions = 0;\n  for ( int j = 0; j != FHeight; j++ )\n  {\n    for ( int i = 0 ; i != FWidth ; i++ )\n    {\n      if ( FField[i][j] != -1 )\n      {\n```", "```kt\n        int Neighbors = CalcNeighbours( i, j,\n        FField[i][j] );\n```", "```kt\n        if ( Neighbors >= NumRegionsToDelete )\n        {\n          FillNeighbours( i, j, FField[i][j] );\n          NumRegions += Neighbours;\n        }\n      }\n    }\n  }\n```", "```kt\n  CollapseField(); \n```", "```kt\n  return NumRegions;\n}\n```", "```kt\nintclBricksField::CalcNeighbours( int i, int j, int Col )\n{\n  if ( i < 0 || j < 0 || i >= FWidth ||\n  j >= FHeight || FField[i][j] != Col ) return 0;\n  FField[i][j] = -1;\n  int Result =  1 + CalcNeighbours( i + 1, j + 0, Col ) +\n  CalcNeighbours( i - 1, j + 0, Col ) +\n  CalcNeighbours( i + 0, j + 1, Col ) +\n  CalcNeighbours( i + 0, j - 1, Col );\n  FField[i][j] = Col;\n  return Result;\n}\n```", "```kt\nvoid clBricksField::FillNeighbours( int i, int j, int Col )\n{\n  if ( i < 0 || j < 0 || i >= FWidth ||\n    j >= FHeight || FField[i][j] != Col ) { return; }\n  FField[i][j] = -1;\n  FillNeighbours( i + 1, j + 0, Col );\n  FillNeighbours( i - 1, j + 0, Col );\n  FillNeighbours( i + 0, j + 1, Col );\n  FillNeighbours( i + 0, j - 1, Col );\n}\n```", "```kt\n    bool MoveFigureLeft()\n    {\n      if ( g_Field.FigureFits( g_GS.FCurX - 1, g_GS.FCurY,\n      g_CurrentFigure ) )\n      {\n        g_GS.FCurX--;\n        return true;\n      }\n      return false;\n    }\n    ```", "```kt\n    bool MoveFigureDown()\n    {\n      if ( g_Field.FigureFits( g_GS.FCurX, g_GS.FCurY + 1,\n      g_CurrentFigure ) )\n      {\n        g_GS.FScore += 1 + g_GS.FLevel / 2;\n        g_GS.FCurY++;\n        return true;\n      }\n      return false;\n    }\n    ```", "```kt\n    bool RotateFigure( bool CW )\n    {\n      clBricksShape TempFigure( g_CurrentFigure );\n      TempFigure.Rotate( CW );\n      if ( g_Field.FigureFits(g_GS.FCurX, g_GS.FCurY, TempFigure))\n      {\n        g_CurrentFigure = TempFigure;\n        return false;\n      }\n      return true;\n    }\n    ```", "```kt\nvoid ProcessClick( bool Pressed )\n{\n```", "```kt\n  b_Flags[b_MoveLeft] = 0.0f;\n  b_Flags[b_MoveRight] = 0.0f;\n  b_Flags[b_Down] = 0.0f;\n  b_Flags[b_TurnLeft] = 0.0f;\n  b_Flags[b_TurnRight] = 0.0f;\n  b_Flags[b_Paused] = 0.0f;\n  b_Flags[b_Reset] = 0.0f;\n  bool MousePressed = Pressed;\n  if ( Reset.ContainsPoint( g_Pos ) )\n  {\n    if ( MousePressed ) { ResetGame(); }\n    b_Flags[b_Reset] = MousePressed ? 1.0f : 0.0f;\n  }\n```", "```kt\n  if ( g_GS.FGameOver ) { if ( !Pressed ) ResetGame(); return; }\n```", "```kt\n  if ( Pressed )\n  {\n    if ( MoveLeft.ContainsPoint( g_Pos ) )\n    { MoveFigureLeft(); b_Flags[b_MoveLeft] = 1.0f; }\n    if ( MoveRight.ContainsPoint( g_Pos ) )\n    { MoveFigureRight(); b_Flags[b_MoveRight] = 1.0f; }\n\n    if ( Down.ContainsPoint( g_Pos ) )\n{\nif ( !MoveFigureDown() ) { NextFigure(); } b_Flags[b_Down] = 1.0f;\n}\n    if ( TurnLeft.ContainsPoint( g_Pos ) )\n    { rotateFigure( false ); b_Flags[b_TurnLeft] = 1.0f; }\n    if ( TurnRight.ContainsPoint( g_Pos ) )\n    { rotateFigure( true ); b_Flags[b_TurnRight] = 1.0f; }\n    if ( Paused.ContainsPoint( g_Pos ) )\n    {\n      b_Flags[b_Paused] = 1.0f;\n```", "```kt\n      g_KeyPressTime = 0.0f;\n    }\n  }\n}\n```", "```kt\nvoid OnTimer( float DeltaTime )\n{\n  if ( g_GS.FGameOver ) { return; }\n  g_GS.FGameTimeCount += DeltaTime;\n  g_GS.FGameTime += DeltaTime;\n  g_KeyPressTime += DeltaTime;\n```", "```kt\n  if ( (b_Flags[b_MoveLeft] > 0 || \n      b_Flags[b_MoveRight] > 0 || \n      b_Flags[b_Down] > 0 || \n      b_Flags[b_TurnLeft] > 0 || \n      b_Flags[b_TurnRight] > 0 ) &&\n  g_KeyPressTime > g_KeyTypematicDelay )\n  {\n    g_KeyPressTime -= g_KeyTypematicRate;\n    ProcessClick( true );\n  }\n  while ( g_GS.FGameTimeCount > g_GS.FUpdateSpeed )\n  {\n    if ( !MoveFigureDown() )\n    {\n      NextFigure();\n    }\n```", "```kt\n    int Count = g_Field.deleteRegions( BlocksToDisappear );\n\n    …Update the game score here…\n  }\n}\n```", "```kt\nconst float g_KeyTypematicDelay = 0.2f;  // 200 ms delay\nconst float g_KeyTypematicRate  = 0.03f; // 33 Hz repeat rate\n```"]