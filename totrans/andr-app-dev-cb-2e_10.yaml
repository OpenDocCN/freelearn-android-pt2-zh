- en: Chapter 10. A First Look at OpenGL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 初识OpenGL ES
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节，我们将涵盖以下主题：
- en: Setting up the OpenGL ES environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置OpenGL ES环境
- en: Drawing shapes on GLSurfaceView
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GLSurfaceView上绘制形状
- en: Applying projection and camera view while drawing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制时应用投影和摄像机视图
- en: Moving the triangle with rotation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用旋转移动三角形
- en: Rotating the triangle with user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户输入旋转三角形
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As we saw in the previous chapter, Android offers many tools for handling graphics
    and animations. Though the canvas and drawable objects are designed for custom
    drawing, when you need high performance graphics, especially 3D gaming graphics,
    Android also supports OpenGL ES. **Open Graphics Library for Embedded Systems**
    (**OpenGL ES**), is targeted for embedded system. (Embedded systems include consoles
    and phones.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章看到的，Android提供了许多处理图形和动画的工具。尽管画布和可绘制对象是为了自定义绘图设计的，但当你需要高性能图形，尤其是3D游戏图形时，Android也支持OpenGL
    ES。**嵌入式系统开放图形库**（**OpenGL ES**）针对的是嵌入式系统。（嵌入式系统包括游戏机和手机。）
- en: This chapter is meant to serve as an introduction to using OpenGL ES on Android.
    As usual, we'll provide the steps and explain how things work, but we aren't going
    to be digging into the math or technical details of OpenGL. If you are already
    familiar with OpenGL ES from other platforms, such as iOS, this chapter should
    get you up and running quickly. If you are new to OpenGL, hopefully, these recipes
    will help you decide whether this is an area you want to pursue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在作为在Android上使用OpenGL ES的入门介绍。像往常一样，我们会提供步骤并解释事物是如何工作的，但不会深入探讨OpenGL的数学或技术细节。如果你在其他平台（如iOS）上已经熟悉OpenGL
    ES，那么本章应能让你快速上手。如果你是OpenGL的新手，希望这些教程能帮助你决定这是否是一个你想追求的领域。
- en: 'Android supports the following versions of OpenGL:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持以下版本的OpenGL：
- en: '**OpenGL ES 1.0**: Android 1.0'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 1.0**：Android 1.0'
- en: '**OpenGL ES 2.0**: Introduced in Android 2.2 (API 8)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 2.0**：在Android 2.2（API 8）中引入'
- en: '**OpenGL ES 3.0**: Introduced in Android 4.3 (API 18)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 3.0**：在Android 4.3（API 18）中引入'
- en: '**OpenGL ES 3.1**: Introduced in Android 5.0 (API 21)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 3.1**：在Android 5.0（API 21）中引入'
- en: The recipes for this chapter are of an introductory nature and target OpenGL
    ES 2.0 and higher. OpenGL ES 2.0 is available for nearly all devices currently
    available. Unlike OpenGL ES 2.0 and lower, OpenGL 3.0 and higher require driver
    implementation from the hardware manufacturer. This means, even if your application
    is running on Android 5.0, OpenGL 3.0 and higher may not be available. Therefore,
    it's a good programming practice to check the available OpenGL versions at runtime.
    Alternatively, if your application requires 3.0 and higher features, you can add
    a `<uses-feature/>` element to your Android manifest. (We'll discuss this in the
    first recipe that follows.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的教程具有入门性质，针对的是OpenGL ES 2.0及更高版本。几乎所有的现有设备都支持OpenGL ES 2.0。与OpenGL ES 2.0及更低版本不同，OpenGL
    3.0及更高版本需要硬件制造商提供驱动程序实现。这意味着，即使你的应用程序运行在Android 5.0上，OpenGL 3.0及更高版本可能也无法使用。因此，在运行时检查可用的OpenGL版本是一个好的编程实践。另外，如果你的应用程序需要3.0及更高版本的功能，你可以在Android清单中添加一个`<uses-feature/>`元素。（我们将在接下来的第一个教程中讨论这个问题。）
- en: Unlike the other chapters in this book, this chapter is written more as a tutorial
    with each recipe building on lessons learned from the previous recipe. The *Getting
    ready* section of each recipe will clarify the prerequisites.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的其他章节不同，本章更像是一个教程，每个教程都建立在从前一个教程中学到的知识上。《准备就绪》部分将每个教程的前提条件讲清楚。
- en: Set up the OpenGL ES environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立OpenGL ES环境
- en: Our first recipe will start by showing the steps to set up an activity to use
    an OpenGL `GLSurfaceView`. Similar to the Canvas, the `GLSurfaceView` is where
    your will perform your OpenGL drawing. As this is the starting point, the other
    recipes will refer to this recipe as the base step when they need a `GLSurfaceView`
    created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个教程将从展示如何设置一个活动以使用OpenGL `GLSurfaceView`的步骤开始。与画布类似，`GLSurfaceView`是你执行OpenGL绘图的地方。由于这是起点，其他教程在需要创建`GLSurfaceView`时会将这个教程作为基本步骤引用。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `SetupOpenGL`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为：`SetupOpenGL`。使用默认的**手机 & 平板**选项，并在提示**活动类型**时选择**空活动**。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll start by indicating the application''s use of OpenGL in the Android
    Manifest, and then we''ll add the OpenGL classes to the activity. Here are the
    steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在Android Manifest中指明应用程序对OpenGL的使用开始，然后将OpenGL类添加到活动中。以下是步骤：
- en: 'Open the Android Manifest and add the following XML:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Manifest并添加以下XML：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并添加以下全局变量：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following inner class to the `MainActivity` class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`MainActivity`类添加以下内部类：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add another inner class to the `MainActivity` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`MainActivity`类添加另一个内部类：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code to the existing `onCreate()` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`onCreate()`方法中添加以下代码：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在设备或模拟器上运行这个应用程序了。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you ran the preceding application, you saw the activity created and the
    background set to gray. Since these are the basic steps to setting up OpenGL,
    you''ll be reusing this code for the other recipes in this chapter as well. Here
    is the process explained in detail:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了前面的应用程序，你会看到活动创建并且背景设置为灰色。由于这些是设置OpenGL的基本步骤，你将在这个章节的其他食谱中重用这段代码。以下是详细解释的过程：
- en: Declaring OpenGL in the Android Manifest
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android Manifest中声明OpenGL
- en: 'We start by declaring our requirement to use OpenGL ES version 2.0 in the Android
    Manifest with this line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Android Manifest中通过这行代码声明我们要求使用OpenGL ES版本2.0：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we were using Version 3.0, we would use this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是版本3.0，我们会使用这个：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For Version 3.1, use this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本3.1，使用这个：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Extending the GLSurfaceView class
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展GLSurfaceView类
- en: 'Create a custom OpenGL `SurfaceView` class by extending `GLSurfaceView`, as
    we do in this code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`GLSurfaceView`创建一个自定义的OpenGL `SurfaceView`类，就像这段代码中做的那样：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we instantiate an OpenGL rendered class and pass it to the `GLSurfaceView`
    class with the `setRenderer()` method. The OpenGL `SurfaceView` provides a surface
    for our OpenGL drawing, similar to the `Canvas` and `SurfaceView` objects. The
    actual drawing is done in the `Renderer`, which we''ll create next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化一个OpenGL渲染类，并通过`setRenderer()`方法将其传递给`GLSurfaceView`类。OpenGL `SurfaceView`为我们的OpenGL绘制提供了一个表面，类似于`Canvas`和`SurfaceView`对象。实际的绘制在`Renderer`中完成，我们接下来会创建它：
- en: Creating an OpenGL rendered class
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个OpenGL渲染类
- en: 'The last step is to create the `GLSurfaceView.Renderer` class and implement
    the following three callbacks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建`GLSurfaceView.Renderer`类并实现以下三个回调：
- en: '`onSurfaceCreated()`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceCreated()`'
- en: '`onDrawFrame()`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDrawFrame()`'
- en: '`onSurfaceChanged()`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceChanged()`'
- en: 'Here is the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right now, all we're doing with this class is setting up the callbacks and clearing
    the screen using the color we specify with `glClearColor()` (gray in this case).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们用这个类所做的就是设置回调并使用`glClearColor()`（在这种情况下是灰色）清除屏幕。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the OpenGL environment set up, we'll continue to the next recipe where
    we'll actually draw on the view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好OpenGL环境后，我们将继续下一个食谱，在那里我们将实际在视图中进行绘制。
- en: Drawing shapes on GLSurfaceView
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GLSurfaceView上绘制形状
- en: The previous recipe set up the activity to use OpenGL. This recipe will continue
    by showing how to draw on `OpenGLSurfaceView`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个食谱设置了使用OpenGL的活动。这个食谱将继续展示如何在`OpenGLSurfaceView`上进行绘制。
- en: First, we need to define the shape. With OpenGL, it is important to realize
    the order in which the vertices of a shape are defined are very important, as
    they determine the front (face) and back of the shape. It's customary (and the
    default behavior) to define the vertices counter clockwise. (Though this behavior
    can be changed, it requires additional code and is not standard practice.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义形状。使用OpenGL时，要意识到形状顶点的定义顺序非常重要，因为它们决定了形状的前面（面）和后面。通常（也是默认行为）是按逆时针定义顶点。（尽管这种行为可以改变，但这需要额外的代码，并不是标准做法。）
- en: 'It''s also important to understand the OpenGL screen coordinate system, as
    it differs from the Android canvas. The default coordinate system defines (`0,0,0`)
    as the center of the screen. The four edge points are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 了解OpenGL屏幕坐标系统同样重要，因为它与Android画布的坐标系统不同。默认的坐标系统将(`0,0,0`)定义为屏幕中心。四个边缘点的坐标如下：
- en: '**Top left**: (-1.0, 1.0, 0)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左上角**：(-1.0, 1.0, 0)'
- en: '**Top right**: (1.0, 1.0, 0)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右上角**：(1.0, 1.0, 0)'
- en: '**Bottom left**: (-1.0, -1.0, 0)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左下角**：(-1.0, -1.0, 0)'
- en: '**Bottom right**: (1.0, -1.0, 0)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右下角**：(1.0, -1.0, 0)'
- en: The *Z* axis comes straight out of the screen or straight behind.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*z*轴直接从屏幕前或屏幕后出来。'
- en: 'Here is an illustration showing the *X*, *Y*, and *Z* axes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个展示*x*、*y*和*z*轴的图示：
- en: '![Drawing shapes on GLSurfaceView](img/B05057_10_01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![在GLSurfaceView上绘制形状](img/B05057_10_01.jpg)'
- en: 'We''re going to create a `Triangle` class since it is the base shape. In OpenGL,
    you generally use a collection of triangles to create objects. To draw a shape
    with OpenGL, we need to define the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Triangle`类，因为它是基本形状。在OpenGL中，你通常会使用一系列三角形来创建对象。要使用OpenGL绘制形状，我们需要定义以下内容：
- en: '**Vertex shader**: This is to draw the shape'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这是为了绘制形状'
- en: '**Fragment shader**: This is to color the shape'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片元着色器**：这是为了给形状上色'
- en: '**Program**: This is an OpenGL ES object for the preceding shaders'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序**：这是前面着色器的OpenGL ES对象'
- en: The shaders are defined using **OpenGL Shading Language** (**GLSL**), and then
    compiled and added to the OpenGL program object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器使用**OpenGL着色语言**（**GLSL**）定义，然后编译并添加到OpenGL程序对象中。
- en: 'Here are two screenshots showing the triangle in both portrait and landscape
    orientation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两张屏幕截图，展示了三角形在纵向和横向的显示效果：
- en: '![Drawing shapes on GLSurfaceView](img/B05057_10_02.jpg)![Drawing shapes on
    GLSurfaceView](img/B05057_10_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![在GLSurfaceView上绘制形状](img/B05057_10_02.jpg)![在GLSurfaceView上绘制形状](img/B05057_10_03.jpg)'
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `ShapesWithOpenGL`. Use
    the default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为：`ShapesWithOpenGL`。使用默认的**手机 & 平板**选项，并在提示**活动类型**时选择**空活动**。
- en: This recipe uses the OpenGL environment created in the previous recipe *Set
    up the Open GL environment*. Refer to the previous recipe if you have not already
    completed those steps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱使用了前一个食谱*设置OpenGL环境*中创建的OpenGL环境。如果你还没有完成那些步骤，请参考前一个食谱。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As indicated previously, we''ll be using the OpenGL environment created in
    the previous recipe. The steps that follow will walk you through creating a class
    for the triangle shape and drawing it on the GLSurfaceView:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用前一个食谱中创建的OpenGL环境。以下步骤将指导你创建一个三角形形状的类并在GLSurfaceView上绘制它：
- en: Create a new Java class called `Triangle`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Triangle`的新Java类。
- en: 'Add the following global declarations to the `Triangle` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Triangle`类中添加以下全局声明：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `loadShader()` method to the `Triangle` class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Triangle`类中添加以下`loadShader()`方法：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `Triangle` constructor, as shown:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加如下所示的`Triangle`构造函数：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the `draw()` method, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加如下`draw()`方法：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now open `MainActivity.java` and add a `Triangle` variable to the `GLRenderer`
    class as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MainActivity.java`，并向`GLRenderer`类中添加一个`Triangle`变量，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize the `Triangle` variable in the `onSurfaceCreated()` callback, as
    follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSurfaceCreated()`回调中初始化`Triangle`变量，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the `draw()` method in the `onDrawFrame()` callback:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onDrawFrame()`回调中调用`draw()`方法：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As mentioned in the introduction, to draw with OpenGL, we first have to define
    the shaders, which we do with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如引言中所述，要使用OpenGL绘图，我们首先必须定义着色器，我们使用以下代码来完成：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this is uncompiled **OpenGL Shading Language** (**OpenGLSL**), the next
    step is to compile and attach it to our OpenGL object, which we do with the following
    two OpenGL ES methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是未编译的**OpenGL着色语言**（**OpenGLSL**），下一步是编译并将其附加到我们的OpenGL对象上，我们使用以下两个OpenGL
    ES方法来完成：
- en: '`glAttachShader()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glAttachShader()`'
- en: '`glLinkProgram()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glLinkProgram()`'
- en: After setting up the shaders, we create `ByteBuffer` to store the triangle vertices,
    which are defined in `triangleCoords`. The `draw()` method is where the actual
    drawing occurs using the GLES20 library calls, which is called from the `onDrawFrame()`
    callback.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设置着色器后，我们创建`ByteBuffer`来存储三角形顶点，这些顶点在`triangleCoords`中定义。`draw()`方法是实际使用GLES20库调用进行绘制的位置，它从`onDrawFrame()`回调中被调用。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may have noticed, from the screenshots in the introduction, that the triangles
    in the Portrait and Landscape do look identical. As you can see from the code,
    we make no distinction in the orientation when drawing. We'll explain why this
    is happening and show how to correct this issue in the next recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从引言中的屏幕截图注意到，纵向和横向的三角形看起来是相同的。从代码中可以看出，在绘制时我们没有区分方向。我们将在下一个食谱中解释为什么会这样，并展示如何纠正这个问题。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on the OpenGL Shading Language, refer the following link:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenGL着色语言的更多信息，请参考以下链接：
- en: '[https://www.opengl.org/documentation/glsl/](https://www.opengl.org/documentation/glsl/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.opengl.org/documentation/glsl/](https://www.opengl.org/documentation/glsl/)'
- en: Applying Projection and Camera View while drawing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在绘制时应用投影和摄像机视角
- en: As we saw in the previous recipe, when we draw our shape to the screen, the
    shape is skewed by the screen orientation. The reason for this is because, by
    default, OpenGL assumes a perfectly square screen. We mentioned before, the default
    screen coordinates for the top right is (1,1,0) and bottom left is (-1,-1,0).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前一个食谱中我们所看到的，当我们把形状绘制到屏幕上时，形状会被屏幕方向扭曲。之所以会发生这种情况，是因为OpenGL默认假设屏幕是完美正方形。我们之前提到过，默认的屏幕坐标右上角是(1,1,0)，左下角是(-1,-1,0)。
- en: 'Since most device screens are not perfectly square, we need to map the display
    coordinates to match our physical device. In OpenGL, we do this with *Projection*.
    This recipe will show how to use Projection to match the GLSurfaceView coordinates
    with the device coordinates. Along with the Projection, we''ll also show how to
    set the Camera View. Here''s a screenshot showing the final result:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数设备屏幕都不是完美正方形，我们需要将显示坐标映射到与我们的物理设备相匹配。在OpenGL中，我们通过*投影*来实现这一点。这个食谱将展示如何使用投影将GLSurfaceView坐标与设备坐标相匹配。除了投影，我们还将展示如何设置摄像机视角。以下是显示最终结果的屏幕截图：
- en: '![Applying Projection and Camera View while drawing](img/B05057_10_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![在绘制时应用投影和摄像机视角](img/B05057_10_04.jpg)'
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `ProjectionAndCamera`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for **Activity Type**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为：`ProjectionAndCamera`。使用默认的**手机 & 平板**选项，在选择**活动类型**时选择**空活动**。
- en: This recipe builds on the previous recipe *Drawing shapes on the GLSurfaceView*.
    If you have not already typed in the previous recipe, do so before starting these
    steps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱基于之前的食谱*在GLSurfaceView上绘制形状*。如果你还没有输入之前的食谱，请在开始这些步骤之前完成它。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As stated previously, this recipe will build on the previous recipe, so complete
    those steps before starting. We will be modifying the previous code to add projection
    and camera view to the drawing calculations. Here are the steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个食谱将基于前一个食谱，所以在开始之前请完成那些步骤。我们将修改之前的代码，在绘图计算中添加投影和摄像机视角。以下是步骤：
- en: 'Open the `Triangle` class and add the following global declaration to the existing
    declarations:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Triangle`类，并在现有声明中添加以下全局声明：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a matrix variable to `vertexShaderCode` and use it in the position calculation.
    Here is the final result:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vertexShaderCode`中添加一个矩阵变量，并在位置计算中使用它。以下是最终结果：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Change the `draw()` method to pass in a matrix parameter as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变`draw()`方法，按以下方式传入一个矩阵参数：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To use the transformation matrix, add the following code to the `draw()` method
    just before the `GLES20.glDrawArrays()` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用变换矩阵，在`draw()`方法中，在`GLES20.glDrawArrays()`方法之前添加以下代码：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open `MainActivity.java` and add the following class variables to the `GLRenderer`
    class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件，在`GLRenderer`类中添加以下类变量：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `onSurfaceChanged()` callback to calculate the position matrix as
    follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`onSurfaceChanged()`回调，按照以下方式计算位置矩阵：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify the `onDrawFrame()` callback to calculate the Camera View as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`onDrawFrame()`回调，按照以下方式计算摄像机视角：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we modify the `vertexShaderCode` to include a matrix variable. We calculate
    the matrix in the `onSurfaceChanged()` callback using the height and width, which
    are passed in as parameters. We pass the transformation matrix to the `draw()`
    method to use it when calculating the position to draw.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们修改`vertexShaderCode`以包含一个矩阵变量。我们在`onSurfaceChanged()`回调中使用传入的宽度和高度参数来计算矩阵。我们将变换矩阵传递给`draw()`方法，在计算绘图位置时使用它。
- en: 'Before we call the `draw()` method, we calculate the camera view. These two
    lines of code calculate the camera view:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`draw()`方法之前，我们计算摄像机视角。这两行代码计算摄像机视角：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Without this code, there would actually be no triangle drawn as the camera perspective
    would not "see" our vertices. (This goes back to our discussion on how the order
    of the vertices dictate the front and back of the image.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这段代码，实际上不会绘制出三角形，因为摄像机视角无法“看到”我们的顶点。（这回到了我们之前讨论的顶点顺序如何决定图像的前后。）
- en: When you run the program now, you'll see the output shown in the *Introduction*.
    Notice we have a uniform triangle now, even when the display is rotated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序，你会看到在*引言*中展示的输出。注意，即使屏幕旋转，我们现在也有一个均匀的三角形。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next recipe, we will start showing the power of OpenGL by rotating the
    triangle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个教程中，我们将通过旋转三角形来展示 OpenGL 的强大功能。
- en: Moving the triangle with rotation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过旋转移动三角形
- en: What we've demonstrated so far with OpenGL would probably be easier using the
    traditional canvas or drawable objects. This recipe will show a bit of the power
    of OpenGL by rotating the triangle. Not that we can't create movement with the
    other drawing methods, but how easily we can do this with OpenGL!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们用 OpenGL 展示的内容可能使用传统的画布或可绘制对象更容易实现。这个教程将通过旋转三角形来展示 OpenGL 的一些强大功能。并不是说我们不能用其他绘图方法创建运动，但是使用
    OpenGL 可以轻松实现这一点！
- en: 'This recipe will demonstrate how to rotate the triangle, as this screenshot
    shows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将演示如何旋转三角形，如下面的截图所示：
- en: '![Moving the triangle with rotation](img/B05057_10_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![通过旋转移动三角形](img/B05057_10_05.jpg)'
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `CreatingMovement`. Use
    the default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新项目，并将其命名为：`CreatingMovement`。在选择**活动类型**时，使用默认的**手机 &
    平板**选项，并选择**空活动**。
- en: This recipe builds on the previous recipe *Applying Projection and Camera View
    While Drawing*. If you have not already typed in the previous recipe, do so before
    continuing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程基于之前的教程*在绘制时应用投影和相机视图*。如果你还没有输入之前的教程，请在继续之前完成。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are continuing from the previous recipe, we have very little work
    to do. Open `MainActivity.java` and follow these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从上一个教程继续，所以需要做的工作非常少。打开 `MainActivity.java` 并按照以下步骤操作：
- en: 'Add a Matrix to the `GLRendered` class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GLRendered` 类中添加一个矩阵：
- en: '[PRE26]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `onDrawFrame()` callback, replace the existing `mTriangle.draw(mMVPMatrix);`
    statement with the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onDrawFrame()` 回调中，用以下代码替换现有的 `mTriangle.draw(mMVPMatrix);` 语句：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We're using the `Matrix.setRotateM()` method to calculate a new rotation matrix
    based on the angle we pass in. For this example, we're using the system uptime
    to calculate an angle. We can use whatever method we want to derive an angle,
    such as a sensor reading or touch events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Matrix.setRotateM()` 方法来根据我们传入的角度计算新的旋转矩阵。在这个例子中，我们使用系统运行时间来计算一个角度。我们可以使用任何我们想要的方法来推导一个角度，比如传感器读数或触摸事件。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using the system clock provides the added benefit of creating continuous movement,
    which certainly looks better for demonstration purposes. The next recipe will
    demonstrate how to use user input to derivate an angle for rotating the triangle.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统时钟提供了创建连续运动的额外好处，这对于演示目的来说肯定看起来更好。下一个教程将展示如何使用用户输入来导出一个旋转三角形的角。
- en: The render mode
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染模式
- en: 'OpenGL offers a `setRenderMode()` option to draw only when the view is dirty.
    This can be enabled by adding the following code to the `CustomGLSurfaceView()`
    constructor just below the `setRenderer()` call:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 提供了一个 `setRenderMode()` 选项，只有在视图变脏时才绘制。通过在 `setRenderer()` 调用下面的 `CustomGLSurfaceView()`
    构造函数中添加以下代码，可以启用此功能：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will cause the display to update once, then wait until we request an update
    with `requestRender()`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致显示更新一次，然后等待我们通过 `requestRender()` 请求更新。
- en: Rotating the triangle with user input
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户输入旋转三角形
- en: The previous example demonstrated rotating the triangle based on the system
    clock. This created a continuously rotating triangle, depending on the render
    mode we used. But what if you wanted to respond to the input from the user?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例演示了基于系统时钟旋转三角形。这创建了一个根据我们使用的渲染模式连续旋转的三角形。但是，如果你想要响应用户的输入呢？
- en: In this recipe, we'll show how to respond to user input by overriding the `onTouchEvent()`
    callback from `GLSurfaceView`. We'll still rotate the triangle using the `Matrix.setRotateM()`
    method, but instead of deriving an angle from the system time, we'll calculate
    an angle based on the touch location.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将通过覆盖 `GLSurfaceView` 的 `onTouchEvent()` 回调来展示如何响应用户输入。我们将仍然使用 `Matrix.setRotateM()`
    方法来旋转三角形，但不是从系统时间导出角度，而是根据触摸位置计算角度。
- en: 'Here''s a screenshot showing this recipe running on a physical device (to highlight
    the touch, the **Show touches** developer option is enabled):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张在物理设备上运行此食谱的截图（为了突出触摸，启用了**显示触摸**的开发者选项）：
- en: '![Rotating the triangle with user input](img/B05057_10_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![使用用户输入旋转三角形](img/B05057_10_06.jpg)'
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `RotateWithUserInput`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for **Activity Type**.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为`RotateWithUserInput`。使用默认的**手机 & 平板**选项，并在提示**活动类型**时选择**空活动**。
- en: This recipe demonstrates an alternative approach to the previous recipe and
    therefore will be based on *Applying projection and camera view while drawing*
    (the same starting point as the previous recipe.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了与上一个食谱不同的方法，因此将基于*绘制时应用投影和摄像机视图*（与上一个食谱相同的起点）。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As stated previously, we will continue, not from the previous recipe, but from
    the *Applying projection and camera view while drawing* recipe. Open `MainActivity.java`
    and follow these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将继续从*绘制时应用投影和摄像机视图*的食谱开始，而不是从上一个食谱。打开`MainActivity.java`并按照以下步骤操作：
- en: 'Add the following global variables to the `MainActivity` class:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`类中添加以下全局变量：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following code the `GLRendered` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GLRendered`类中添加以下代码：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same class, modify the `onDrawFrame()` method by replacing the existing
    `mTriangle.draw(mMVPMatrix);` statement with the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类中，通过替换现有的`mTriangle.draw(mMVPMatrix);`语句，修改`onDrawFrame()`方法，使用以下代码：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the `onSurfaceChanged()` callback:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSurfaceChanged()`回调中添加以下代码：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following code to the `CustomGLSurfaceView` constructor, which is below
    `setRenderer()`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomGLSurfaceView`构造函数中添加以下代码，位于`setRenderer()`下方：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following `onTouchEvent()` to the `CustomGLSurfaceView` class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomGLSurfaceView`类中添加以下`onTouchEvent()`：
- en: '[PRE34]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The obvious difference between this example and the previous recipe is how we
    derive the angle to pass to the `Matrix.setRotateM()` call. We also changed the
    `GLSurfaceView` render mode using `setRenderMode()` to only draw on request. We
    made the request using `requestRender()` after calculating a new angle in the
    `onTouchEvent()` callback.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例与上一个食谱最明显的区别在于我们如何导出传递给`Matrix.setRotateM()`调用的角度。我们还通过使用`setRenderMode()`更改了`GLSurfaceView`的渲染模式，仅在请求时绘制。在`onTouchEvent()`回调中计算出新角度后，我们使用`requestRender()`发出请求。
- en: We also demonstrated the importance of deriving our own `GLSurfaceView` class.
    Without our `CustomGLSurfaceView` class, we would not have a way to override the
    `onTouchEvent` callback, or any other callbacks from `GLSurfaceView`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还证明了派生我们自己的`GLSurfaceView`类的重要性。如果没有我们的`CustomGLSurfaceView`类，我们将无法重写`onTouchEvent`回调，也无法重写来自`GLSurfaceView`的其他任何回调。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This concludes the OpenGL ES recipes but we've only just touched upon the power
    of OpenGL. If you're serious about learning OpenGL, see the links in the next
    section and check out one of the many books written on OpenGL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了OpenGL ES的食谱，但我们只是触及了OpenGL的强大功能。如果你认真想要学习OpenGL，请查看下一节中的链接，并阅读关于OpenGL的众多书籍之一。
- en: 'It''s also worth checking out one of the many frameworks available, such as
    the Unreal Engine:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可用的众多框架之一，例如Unreal Engine，也是值得的：
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unreal Engine 4 is a complete suite of game development tools made by game developers,
    for game developers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 4是由游戏开发者为游戏开发者制作的一套完整的游戏开发工具。
- en: '[https://www.unrealengine.com/what-is-unreal-engine-4](https://www.unrealengine.com/what-is-unreal-engine-4)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.unrealengine.com/what-is-unreal-engine-4](https://www.unrealengine.com/what-is-unreal-engine-4)'
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '**OpenGL**: The Industry Standard for High Performance Graphics'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL**：高性能图形的行业标准'
- en: '[https://www.opengl.org/](https://www.opengl.org/)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.opengl.org/](https://www.opengl.org/)'
- en: '**OpenGL ES**: The Standard for Embedded Accelerated 3D Graphics'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES**：嵌入式加速3D图形的标准'
- en: '[https://www.khronos.org/opengles/](https://www.khronos.org/opengles/)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.khronos.org/opengles/](https://www.khronos.org/opengles/)'
- en: '**Unreal Engine**: Android Quick Start'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unreal Engine**：Android快速入门'
- en: '[https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html](https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html](https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html)'
