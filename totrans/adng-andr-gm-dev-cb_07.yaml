- en: Chapter 7. Working with Update Handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Update handlers** give us a way to run specific portions of code every time
    that the engine updates. Some game engines have one built in as a main loop, but
    with AndEngine we can create as many of these loops as necessary with ease. This
    chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with update handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching an update handler to an entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using update handlers with conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the removal of an entity from the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding game timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting entity properties based on the time passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with update handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Update handlers are essentially portions of code that we register with either
    entities or the engine, that are run whenever the engine updates the scene. In
    most situations, this updating occurs every time a frame is drawn, regardless
    of whether entities or the scene have been altered. Update handlers can be a powerful
    means of running a game, but overusing them or performing heavy calculations in
    them will lead to poor performance. This recipe will cover the basics of adding
    a simple update handler to an activity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class named `UpdateHandlersActivity` that extends `BaseGameActivity`.
    We will use this class to create a basic update handler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an update handler that displays how many updates
    have occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following definitions within our `UpdateHandlersActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add the following overridden methods to the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, insert this last method into our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and the second step cover the creation of a simple `BaseGameActivity`
    class. For more information on creating a `BaseGameActivity` class, see the *Know
    the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*. Notice, however, that we create and load a `Font`
    object in the `onCreateResources()` method. For more information on fonts and
    the `Text` entities that use them, see the *Applying text to a layer* recipe in
    [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we create a `Text` entity, `countingText`, by passing the `fontDefault32Bold`
    font, created in the `onCreateResources()` method of the activity, to the `Text`
    constructor, with location parameters to center it on the screen and a maximum
    string length parameter of `10` characters. After attaching the `countingText`
    entity to the scene, we register our update handler. In the `onUpdate()` method
    of our update handler, we increment the `countingInt` integer and set the `countingText`
    entity's text to the integer. This gives us a direct textual display in our game
    of how many updates have occurred, and thus how many frames have been drawn.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching an update handler to an entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to being able to register an update handler with a `Scene` object,
    we can register update handlers with specific entities. By registering an update
    handler with an entity, the handler is only called whenever the entity is attached
    to the engine's scene. This recipe demonstrates this process by creating an update
    handler, which is registered with an initially unattached entity, that increments
    the onscreen text.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class named `AttachUpdateHandlerToEntityActivity` that extends
    `BaseGameActivity` and implements `IOnSceneTouchListener`. We will use this class
    to attach an update handler to an `Entity` object that will wait to be attached
    to the scene until the scene is touched.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an activity that demonstrates how update handlers
    depend on their parent entity to run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following definitions into our new activity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, place the following overridden methods within the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add this overridden `onPopulateScene()` method to our activity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, insert the following overridden method in our `AttachUpdateHandlerToEntityActivity`
    class to compete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and the second step cover the creation of a simple `BaseGameActivity`
    class. For more information on creating a BaseGameActivity class, see the *Know
    the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*. Notice, however, that we create and load a `Font`
    object in the `onCreateResources()` method. For more information on fonts and
    the `Text` entities that use them, see the *Applying text to a layer* recipe in
    [Chapter 2](ch02.html "Chapter 2. Working with Entities"), *Working with Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: Step three creates a text entity, `countingText`, and attaches it to the center
    of our scene. Then, our blank entity, `blankEntity`, is created by calling the
    `Entity()` constructor and our update handler is registered with it. Note that
    the blank entity is not attached to the scene until a touch occurs within the
    `onSceneTouchEvent()` method in step four. The `onUpdate()` method of the update
    handler simply increments the `countingText` entity's text to show that the update
    handler it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Step four creates the `onSceneTouchEvent()` method that gets called when the
    scene is touched. We check to make sure that the touch event is a down action
    and that our blank entity does not already have a parent before attaching `blankEntity`
    to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running this recipe, we can see that the update handler is not called until
    the blank entity is attached to the scene. This effect is similar to overriding
    the `onManagedUpdate()` method of entities. The process of registering an update
    handler with an entity can be useful for creating enemies that have their own
    logic, or portions of the scene that should not be animated until shown. Update
    handlers registered with a child `Entity` object of another `Entity` object that
    is attached to the `Scene` object will still be active. Furthermore, the visibility
    of entities does not affect whether or not their registered update handlers will
    run.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Getting started with update handlers* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding AndEngine entities* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overriding onManagedUpdate* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using update handlers with conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To reduce the performance cost of running an update handler with heavy calculations,
    we can include a conditional statement that tells the update handler to run a
    specific set of instructions over another. For instance, if we have enemies that
    check to see if the player is within their sight, we can choose to let the vision
    calculations run only once every three updates. In this recipe, we will demonstrate
    a simple conditional statement that switches between a performance-intensive calculation
    and a very simple calculation by touching the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class named `UpdateHandlersAndConditionalsActivity` that extends
    `BaseGameActivity` and implements `IOnSceneTouchListener`. We will use this class
    to demonstrate how to use conditional statements with an update handler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an update handler that uses a conditional block
    to determine which code to run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following definitions in the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following overridden methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, insert the following overridden `onPopulateScene()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create this `onSceneTouchEvent()` method to complete our activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we define variables that are common to our test bed as well as
    a Boolean `performanceIntensiveLoop` variable, that tells our update handler which
    action to take and a double variable, `performanceHeavyVariable`, that we will
    use in our performance-intensive calculation. Step two creates the standard methods
    for our activity. For more information on creating `BaseGameActivity` classes,
    see the *Know the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we create `countingText` before registering our update handler
    with the scene. On every update, it checks the `performanceIntensiveLoop` Boolean
    variable to determine whether it should perform a heavy task, calling the `Math`
    class' `sqrt()` method almost one million times, or a simple task, decrementing
    the `countingInt` variable's text.
  prefs: []
  type: TYPE_NORMAL
- en: Step four is the `onSceneTouchEvent()` method that switches the `performanceIntensiveLoop`
    Boolean variable every time the screen is touched.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Getting started with update handlers* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the removal of an entity from the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detaching entities within an update handler can occasionally throw an `IndexOutOfBoundsException`
    exception, because the entity is removed in the middle of an engine update. To
    avoid that exception, we create a `Runnable` parameter that is run last on the
    update thread, after all other updating has occurred. In this recipe, we will
    safely remove an entity from the game by using the BaseGameActivity class' `runOnUpdateThread()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class named `HandlingRemovalOfEntityActivity` that extends `BaseGameActivity`.
    We will use this class to learn how to safely remove an entity from an update
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to see how we can remove an entity from its parent without
    throwing an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following definitions into the `HandlingRemovalOfEntityActivity`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add these overridden methods to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, place the following `onPopulateScene()` method in the activity to finish
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we define the normal `BaseGameActivity` variables as well as a
    square `Rectangle` object, `spinningRect`, that will spin in place and a float
    variable, `totalElapsedSeconds`, to keep track of how many seconds have elapsed
    since the start of our update handler. Step two creates the standard `BaseGameActivity`
    methods. For more information on creating AndEngine activities, see the *Know
    the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we create the `spinningRect` rectangle defined in step one by
    calling the `Rectangle` constructor with a location at the center of the screen.
    The `Rectangle` object is then set to a black color via the `setColor()` method.
    Next, it has our update handler registered with it that records the elapsed time
    and removes the rectangle from the screen if more than `5` seconds have elapsed
    since the start of the activity. Notice that the way we detach the rectangle from
    the scene is by calling `runOnUpdateThread()`. This method passes the `Runnable`
    parameter to the engine to be run at the completion of the update cycle.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Getting started with update handlers* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying primitives to a layer* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding game timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games count down time and challenge the player to complete a task within
    the given amount of time. Such challenges are rewarding for the player, and often
    add replay value to a game. In the previous recipe, we kept track of the total
    elapsed time. In this recipe, we will start with a time and subtract from it the
    elapsed time provided by the update handler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class named `GameTimerActivity` that extends `BaseGameActivity`.
    We will use this class to create a game timer from an update handler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a game timer using an update handler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place these variable definitions in our new activity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, insert the following standard, overridden methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add this overridden `onPopulateScene()` method to the `GameTimerActivity`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step one, we define common `BaseGameActivity` variables as well as an `EndingTimer`
    float variable set at `10` seconds. Step two creates the common methods for our
    activity. For more information on creating a BaseGameActivity class, see the *Know
    the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: In step three, we create the `countingText` entity, and use our scene to register
    an update handler, which counts down the `EndingTimer` variable using the `pSecondsElapsed`
    variable until it reaches `0`. When it reaches `0`, we simply unregister the update
    handler from the scene by calling the scene's `unregisterUpdateHandler()` method.
    In an actual game, the timer ending could end a level or even call the next wave
    of enemies to attack the player.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Getting started with update handlers* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applying text to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting entity properties based on the time passed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consistency across devices is one of the more important aspects of mobile game
    development. Players expect a game to scale properly for their device's screen,
    but another important, and often overlooked, aspect of game development is basing
    movements and animations on time instead of engine updates. In this recipe, we
    will set an entity's property using an update handler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class named `SettingEntityPropertiesBasedOnTimePassedActivity`
    that extends `BaseGameActivity`. We will use this class to demonstrate how to
    set entity properties in time with an update handler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to see how we can set an entity''s property based on how
    much time has passed in an udate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the following variables in the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, place these overridden methods in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, insert this `onPopulateScene()` method at the end of the activity to
    complete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the other recipes in this chapter, we first create common `BaseGameActivity`
    variables. For this recipe, we also define a `Rectangle` object, `spinningRect`,
    that will spin at specific revolutions per second. For more information on creating
    AndEngine activities, see the *Know the life cycle* recipe in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step three, we fill the `onPopulateScene()` method by first creating our
    `spinningRect` rectangle, which we then use to register our update handler. Inside
    the update handler''s `onUpdate()` method, we set the rotation of the rectangle
    to equal its current rotation, via the `getRotation()` method, plus a calculation
    that adjusts the `pSecondsElapsed` variable to a set number of rotations per second.
    The following diagram shows how the updates in our games do not have equal durations
    and thus must take advantage of the `pSecondsElapsed` parameter instead of a constant
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8987OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The calculation that we use in the `onUpdate()` method of our update handler
    sets the `Rectangle` object to rotate at half of a rotation per second. If we
    were to multiply the `(pSecondsElapsed*360f)` portion of the calculation by `4`,
    the rectangle would spin at 4 revolutions per second. For linear movements based
    on time, simply multiply the desired pixels per second with the `pSecondsElap`
    `ed` variable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Getting started with update handlers* in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
