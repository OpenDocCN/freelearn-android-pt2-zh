["```kt\n    class SoundThread: public iThread\n    {\n    ```", "```kt\n      ALCdevice*  FDevice;\n      ALCcontext* FContext;\n    ```", "```kt\n      ALuint FSourceID;\n      ALuint FBufferID;\n    ```", "```kt\n      virtual void Run()\n      {\n    ```", "```kt\n        LoadAL();\n    ```", "```kt\n        FDevice = alcOpenDevice( NULL );\n        FContext = alcCreateContext( FDevice, NULL );\n    ```", "```kt\n        alcMakeContextCurrent( FContext );\n    ```", "```kt\n        alGenSources( 1, &FSourceID );\n    ```", "```kt\n        alSourcef( FSourceID, AL_GAIN, 1.0f );\n    ```", "```kt\n        clPtr<iIStream> Sound = g_FS->CreateReader(\"test.wav\");\n    ```", "```kt\n        int DataSize = (int)Sound->GetSize();\n        const ubyte* Data = Sound->MapStream();\n    ```", "```kt\n        PlayBuffer( Data + sizeof( sWAVHeader ),\n        DataSize - sizeof( sWAVHeader ));\n    ```", "```kt\n        while ( IsPlaying() ) {}\n    ```", "```kt\n        alSourceStop( FSourceID );\n        alDeleteSources( 1, &FSourceID );\n        alDeleteBuffers( 1, &FBufferID );\n        alcDestroyContext( FContext );\n        alcCloseDevice( FDevice );\n    ```", "```kt\n        UnloadAL();\n    ```", "```kt\n        exit( 0 );\n      }\n    ```", "```kt\n      bool IsPlaying()\n      {\n        int State;\n        alGetSourcei( FSourceID, AL_SOURCE_STATE, &State );\n        return State == AL_PLAYING;\n      }\n    ```", "```kt\n      void PlayBuffer(const unsigned char* Data, int DataSize)\n      {\n        alGenBuffers( 1, &FBufferID );\n        alBufferData( FBufferID, AL_FORMAT_MONO16,\n        Data, DataSize, 22050 );\n        alSourcei( FSourceID, AL_BUFFER, FBufferID );\n        alSourcePlay( FSourceID );\n      }\n    };\n    ```", "```kt\n    struct __attribute__((packed,aligned(1))) sWAVHeader\n    {\n      unsigned char    RIFF[4];\n      unsigned int     Size;\n      unsigned char    WAVE[4];\n      unsigned char    FMT[4];\n      unsigned int     SizeFmt;\n      unsigned short   FormatTag;\n      unsigned short   Channels;\n      unsigned int     SampleRate;\n      unsigned int     AvgBytesPerSec;\n      unsigned short   nBlockAlign;\n      unsigned short   nBitsperSample;\n      unsigned char    Reserved[4];\n      unsigned int     DataSize;\n    };\n    ```", "```kt\nclPtr<FileSystem> g_FS;\nSoundThread g_Sound;\n```", "```kt\nvoid OnStart( const std::string& RootPath )\n{\n  …\n  g_FS = new FileSystem();\n  g_FS->Mount( \".\" );\n#if defined(ANDROID)\n  g_FS->Mount( RootPath );\n  g_FS->AddAliasMountPoint( RootPath, \"assets\" );\n#endif\n  g_Sound.Start( iThread::Priority_Normal );\n}\n```", "```kt\n    class AudioThread: public iThread\n    {\n    public:\n      AudioThread():\n        FDevice( NULL ),\n        FContext( NULL ),\n        FInitialized( false ) {}\n      virtual ~AudioThread() {}\n\n      virtual void Run()\n      {\n    ```", "```kt\n        if ( !LoadAL() ) { return; }\n\n        FDevice = alcOpenDevice( NULL );\n        FContext = alcCreateContext( FDevice, NULL );\n        alcMakeContextCurrent( FContext );\n    ```", "```kt\n        FInitialized = true;\n    ```", "```kt\n        FPendingExit = false;\n        while ( !IsPendingExit() ) { Env_Sleep( 100 ); }\n    ```", "```kt\n        alcDestroyContext( FContext );\n        alcCloseDevice( FDevice );\n        UnloadAL();\n      }\n    ```", "```kt\n      bool FInitialized;\n    private:\n      ALCdevice*     FDevice;\n      ALCcontext*    FContext;\n    };\n    ```", "```kt\n    void Env_Sleep( int Milliseconds )\n    {\n    #if defined _WIN32\n      Sleep( Milliseconds );\n    #else\n      usleep( static_cast<useconds_t>( Milliseconds ) * 1000 );\n    #endif\n    }\n    ```", "```kt\n    class iWaveDataProvider: public iObject\n    {\n    public:\n      iWaveDataProvider(): FChannels( 0 ),\n        FSamplesPerSec( 0 ),\n        FBitsPerSample( 0 ) {}\n    ```", "```kt\n      virtual ubyte* GetWaveData() = 0;\n      virtual size_t GetWaveDataSize() const = 0;\n    ```", "```kt\n      ALuint GetALFormat() const\n      {\n        if ( FBitsPerSample == 8 )\n           {\n          return (FChannels == 2) ?\n            AL_FORMAT_STEREO8  : AL_FORMAT_MONO8;\n           }\n        else if ( FBitsPerSample == 16)\n           {\n          return (FChannels == 2) ?\n            AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n           }\n        return AL_FORMAT_MONO8;\n      }\n    ```", "```kt\n      int FChannels;\n      int FSamplesPerSec;\n      int FBitsPerSample;\n    };\n    ```", "```kt\n    class AudioSource: public iObject\n    {\n    public:\n    ```", "```kt\n      AudioSource(): FWaveDataProvider( NULL )\n      {\n        alGenSources( 1, &FSourceID );\n        alSourcef( FSourceID, AL_GAIN,    1.0 );\n        alSourcei( FSourceID, AL_LOOPING, 0   );\n      }\n    ```", "```kt\n      virtual ~AudioSource()\n      {\n        Stop();\n        FWaveDataProvider = NULL;\n        alDeleteSources( 1, &FSourceID );\n        alDeleteBuffers( 1, &FBufferID );\n      }\n    ```", "```kt\n      void Play()\n      {\n        if ( IsPlaying() ) { return; }\n        alSourcePlay( FSourceID );\n      }\n    ```", "```kt\n      void Stop()\n      {\n        alSourceStop( FSourceID );\n      }\n    ```", "```kt\n      bool IsPlaying() const\n      {\n        int State;\n        alGetSourcei( FSourceID, AL_SOURCE_STATE, &State );\n        return State == AL_PLAYING;\n      }\n    ```", "```kt\n      void SetVolume( float Volume )\n      {\n        alSourcef( FSourceID, AL_GAIN, Volume );\n      }\n    ```", "```kt\n      void BindWaveform( clPtr<iWaveDataProvider> Wave )\n      {\n        FWaveDataProvider = Wave;\n        if ( !Wave ) return;\n\n        alGenBuffers( 1, &FBufferID );\n        alBufferData( FBufferID,\n          Wave->GetALFormat(),\n          Wave->GetWaveData(),\n          (int)Wave->GetWaveDataSize(),\n          Wave->FSamplesPerSec );\n        alSourcei( FSourceID, AL_BUFFER, FBufferID );\n      }\n    ```", "```kt\n    private:\n      clPtr<iWaveDataProvider> FWaveDataProvider;\n      ALuint FSourceID;\n      ALuint FBufferID;\n    };\n    ```", "```kt\n    class WavProvider: public iWaveDataProvider\n    ```", "```kt\n      clPtr<Blob> FRawData;\n    ```", "```kt\n      WavProvider( const clPtr<clBlob>& blob )\n      {\n        FRawData = blob;\n        sWAVHeader H = *(sWAVHeader*)FRawData->GetData();\n\n        const unsigned short FORMAT_PCM = 1;\n        FChannels      = H.Channels;\n        FSamplesPerSec = H.SampleRate;\n        FBitsPerSample = H.nBitsperSample;\n      }\n    ```", "```kt\n      virtual ~WavProvider() {}\n    ```", "```kt\n      virtual ubyte* GetWaveData()\n      {\n        return (ubyte*)FRawData->GetDataConst() +\n          sizeof( sWAVHeader );\n      }\n    ```", "```kt\n      virtual size_t GetWaveDataSize() const\n      {\n        return FRawData->GetSize() - sizeof( sWAVHeader );\n      };\n    ```", "```kt\nAudioThread g_Audio;\n```", "```kt\ng_Audio.Start( iThread::Priority_Normal );\n```", "```kt\nwhile ( !g_Audio.FInitialized ) {}\n```", "```kt\nclPtr<AudioSource> Src = new AudioSource();\n```", "```kt\nclPtr<Blob> Data = LoadFileAsBlob(\"test.wav\");\nSrc->BindWaveform( new WavProvider( Data ) );\nSrc->Play();\nwhile ( Src->IsPlaying() ) {}\n```", "```kt\nSrc = NULL;\ng_Audio.Exit(true);\n```", "```kt\nclPtr<Blob> LoadFileAsBlob( const std::string& FName )\n{\n  clPtr<iIStream> input = g_FS->CreateReader( FName );\n  clPtr<Blob> Res = new Blob();\n  Res->CopyMemoryBlock( input->MapStream(), input->GetSize() );\n  return Res;\n}\n```", "```kt\nvoid Pause()\n{\n  alSourcePause( FSourceID );\n  UnqueueAll();\n}\nvoid UnqueueAll()\n{\n  int Queued;\n  alGetSourcei( FSourceID, AL_BUFFERS_QUEUED, &Queued );\n\n  if ( Queued > 0 )\n  alSourceUnqueueBuffers(FSourceID, Queued, &FBufferID);\n}\n```", "```kt\nvoid LoopSound( bool Loop )\n{\n  alSourcei( FSourceID, AL_LOOPING, Loop ? 1 : 0);\n}\n```", "```kt\nWavProvider(clPtr<Blob> source)\n{\n  FRawData = source;\n  sWAVHeader H = *(sWAVHeader*)(FRawData->GetData());\n#if __BIG_ENDIAN__\n  Header.FormatTag = SwapBytes16(Header.FormatTag);\n  Header.Channels  = SwapBytes16(Header.Channels);\n  Header.SampleRate = SwapBytes32(Header.SampleRate);\n  Header.DataSize   = SwapBytes32(Header.DataSize);\n  Header.nBlockAlign = SwapBytes16(Header.nBlockAlign);\n  Header.nBitsperSample = SwapBytes16(Header.nBitsperSample);\n```", "```kt\n  if ( (Header.nBitsperSample == 16) )\n  {\n    clPtr<Blob> NewBlob = new clBlob();\n    NewBlob->CopyBlob( FRawData.GetInternalPtr() );\n    FRawData = NewBlob;\n    unsigned short* Ptr =\n      (unsigned short*)FRawData->GetData();\n    for ( size_t i = 0 ; i != Header.DataSize / 2; i++ )\n    {\n      *Ptr = SwapBytes16(*Ptr);\n      Ptr++;\n     }\n  }\n#endif\n  FChannels      = H.Channels;\n  FSamplesPerSec = H.SampleRate;\n  FBitsPerSample = H.nBitsperSample;\n}\n```", "```kt\nunsigned short SwapBytes16( unsigned short Val )\n{\n  return (Val >> 8) | ((Val & 0xFF) << 8);\n}\nunsigned int SwapBytes32( unsigned int Val )\n{\n  return\t(( Val & 0xFF ) << 24 ) |\n    (( Val & 0xFF00   ) <<  8 ) |\n    (( Val & 0xFF0000 ) >>  8 ) |\n    (  Val >> 24);\n}\n```", "```kt\n    class iWaveDataProvider: public iObject\n      …\n      virtual bool IsStreaming() const { return false; }\n      virtual int  StreamWaveData( int Size ) { return 0; }\n      …\n    };\n    ```", "```kt\n    class StreamingWaveDataProvider: public iWaveDataProvider\n    {\n    public:\n      virtual bool IsStreaming() const { return true; }\n\n      virtual ubyte* GetWaveData() { return (ubyte*)&FBuffer[0]; }\n      virtual size_t GetWaveDataSize() const { return FBufferUsed; }\n\n      std::vector<char> FBuffer;\n      int               FBufferUsed;\n    };\n    ```", "```kt\n    class AudioSource: public iObject\n    {\n    private:\n      unsigned int FSourceID;\n      int          FBuffersCount;\n      unsigned int FBufferID[2];\n    ```", "```kt\n      void BindWaveform( clPtr<iWaveDataProvider> Wave )\n      {\n        FWaveDataProvider = Wave;\n        if ( !Wave ) return;\n\n        if ( Wave->IsStreaming() )\n        {\n          FBuffersCount = 2;\n          alGenBuffers( FBuffersCount, &FBufferID[0] );\n        }\n        else\n        {\n          FBuffersCount = 1;\n          alGenBuffers( FBuffersCount, &FBufferID[0] );\n          alBufferData( FBufferID[0],\n            Wave->GetALFormat(),\n            Wave->GetWaveData(),\n            (int)Wave->GetWaveDataSize(),\n            Wave->FSamplesPerSec );\n          alSourcei( FSourceID, AL_BUFFER, FBufferID[0] );\n        }\n      }\n    ```", "```kt\n      void Play()\n      {\n        if ( IsPlaying() ) { return; }\n        if ( !FWaveDataProvider ) { return; }\n\n        int State;\n        alGetSourcei( FSourceID, AL_SOURCE_STATE, &State );\n\n        if (  State != AL_PAUSED &&\n          FWaveDataProvider->IsStreaming() )\n        {\n          UnqueueAll();\n    ```", "```kt\n          StreamBuffer( FBufferID[0], BUFFER_SIZE );\n          StreamBuffer( FBufferID[1], BUFFER_SIZE );\n          alSourceQueueBuffers(FSourceID, 2, &FBufferID[0]);\n        }\n        alSourcePlay( FSourceID );\n      }\n    ```", "```kt\n      void   UnqueueAll()\n      {\n        int Queued;\n        alGetSourcei(FSourceID, AL_BUFFERS_QUEUED, &Queued);\n        if ( Queued > 0 )\n          alSourceUnqueueBuffers(FSourceID,\n            Queued, &FBufferID[0]);\n      }\n    ```", "```kt\n      void Update( float DeltaSeconds )\n      {\n        if ( !FWaveDataProvider ) { return; }\n        if ( !IsPlaying() ) { return; }\n\n        if ( FWaveDataProvider->IsStreaming() )\n        {\n          int Processed;\n          alGetSourcei( FSourceID,\n          AL_BUFFERS_PROCESSED, &Processed );\n\n          while ( Processed-- )\n          {\n            unsigned int BufID;\n            alSourceUnqueueBuffers(FSourceID,1,&BufID);\n            StreamBuffer( BufID, BUFFER_SIZE );\n            alSourceQueueBuffers(FSourceID, 1, &BufID);\n          }\n        }\n      }\n    ```", "```kt\n      int StreamBuffer( unsigned int BufferID, int Size )\n      {\n        int ActualSize = \n          FWaveDataProvider->StreamWaveData(Size);\n\n        ubyte* Data = FWaveDataProvider->GetWaveData();\n        int Sz = (int)FWaveDataProvider->GetWaveDataSize();\n\n        alBufferData( BufferID,\n          FWaveDataProvider->GetALFormat(),\n          Data, Sz,\n          FWaveDataProvider->FSamplesPerSec );\n\n        return ActualSize;\n      }\n    ```", "```kt\n    const int BUFFER_SIZE = 352800;\n    ```", "```kt\nclass ToneGenerator : public StreamingWaveDataProvider\n{\n```", "```kt\n  int   FSignalFreq;\n  float FFrequency;\n  float FAmplitude;\nprivate:\n  int LastOffset;\n```", "```kt\npublic:\n  ToneGenerator()\n  {\n    FBufferUsed = 100000;\n    FBuffer.resize( 100000 );\n\n    FChannels = 2;\n    FSamplesPerSec = 4100;\n    FBitsPerSample = 16;\n\n    FAmplitude = 350.0f;\n    FFrequency = 440.0f;\n  }\n  virtual ~ToneGenerator() {}\n```", "```kt\n  virtual int StreamWaveData( int Size )\n  {\n    if ( Size > static_cast<int>( FBuffer.size() ) )\n    {\n      FBuffer.resize( Size );\n      LastOffset = 0;\n    }\n\n    for ( int i = 0 ; i < Size / 4 ; i++ )\n    {\n```", "```kt\n      float t = ( 2.0f * 3.141592654f *\n        FFrequency * ( i + LastOffset ) ) / \n         (float) FSamplesPerSec;\n        float val = FAmplitude * std::sin( t );\n```", "```kt\n      short V = static_cast<short>( val );\n      FBuffer[i * 4 + 0] = V & 0xFF;\n      FBuffer[i * 4 + 1] = V >> 8;\n      FBuffer[i * 4 + 2] = V & 0xFF;\n      FBuffer[i * 4 + 3] = V >> 8;\n    }\n```", "```kt\n    LastOffset += Size / 2;\n    LastOffset %= FSamplesPerSec;\n```", "```kt\n    FBufferUsed = Size;\n    return FBufferUsed;\n  }\n};\n```", "```kt\nclass SoundThread: public iThread\n{\n  virtual void Run()\n  {\n    while ( !g_Audio.Finitialized ) {}\n\n    clPtr<AudioSource> Src = new AudioSource();\n    Src->BindWaveform( new ToneGenerator() );\n    Src->Play();\n\n    FPendingExit = false;\n    double Seconds = Env_GetSeconds();\n```", "```kt\n    While ( !IsPendingExit() )\n    {\n      float DeltaSeconds =\n         (float)( Env_GetSeconds() - Seconds );\n      Src->Update( DeltaSeconds );\n      Seconds = Env_GetSeconds();\n    }\n  }\n}\n```", "```kt\n      virtual bool    IsEOF() const { return true; }\n    ```", "```kt\n      virtual void    Seek( float Time ) {}\n    ```", "```kt\n    class DecodingProvider: public StreamingWaveDataProvider\n    {\n      clPtr<Blob> FRawData;\n    public:\n      bool FEof;\n      virtual bool IsEOF() const { return FEof; }\n    ```", "```kt\n      bool FLoop;\n    public:\n      DecodingProvider( const clPtr<Blob>& blob )\n      {\n        FRawData = blob;\n        FEof = false;\n      }\n    ```", "```kt\n      virtual int StreamWaveData( int Size )\n      {\n    ```", "```kt\n        int OldSize = (int)FBuffer.size();\n        if ( Size > OldSize )\n        {\n          FBuffer.resize( Size );\n          for ( int i = 0 ; i < OldSize - Size ; i++ )\n            FBuffer[OldSize + i] = 0;\n        }\n    ```", "```kt\n        if ( FEof ) { return 0; }\n    ```", "```kt\n        int BytesRead = 0;\n        while ( BytesRead < Size )\n        {\n          int Ret = ReadFromFile(Size);\n    ```", "```kt\n          if ( Ret > 0 )\n          {\n            BytesRead += Ret;\n          }\n    ```", "```kt\n          else if (Ret == 0)\n            {\n            FEof = true;\n    ```", "```kt\n            if ( FLoop )\n            {\n              Seek(0);\n              FEof = false;\n              continue;\n            }\n            break;\n          } else\n    ```", "```kt\n          {\n            Seek( 0 );\n            FEof = true;\n            break;\n          }\n        }\n    ```", "```kt\n        return ( FBufferUsed = BytesRead );\n      }\n    ```", "```kt\n    protected:\n      virtual int ReadFromFile(int Size) = 0;\n    };\n    ```", "```kt\n    class OggProvider: public DecodingProvider\n    {\n    ```", "```kt\n      OggVorbis_File         FVorbisFile;\n      ogg_int64_t            FOGGRawPosition;\n      int                    FOGGCurrentSection;\n    ```", "```kt\n    public:\n      OggProvider( const clPtr<Blob>& Blob ): DecodingProvider(Blob)\n      {\n        FOGGRawPosition = 0;\n    ```", "```kt\n        ov_callbacks Callbacks;\n        Callbacks.read_func  = OGG_ReadFunc;\n        Callbacks.seek_func  = OGG_SeekFunc;\n        Callbacks.close_func = OGG_CloseFunc;\n        Callbacks.tell_func  = OGG_TellFunc;\n        OGG_ov_open_callbacks( this, &FVorbisFile,\n        NULL, -1, Callbacks );\n    ```", "```kt\n        vorbis_info* VorbisInfo;\n        VorbisInfo     = OGG_ov_info ( &FVorbisFile, -1 );\n        FChannels      = VorbisInfo->channels;\n        FSamplesPerSec = VorbisInfo->rate;\n    ```", "```kt\n        FBitsPerSample = 16;\n      }\n    ```", "```kt\n      virtual ~OggProvider() { OGG_ov_clear( &FVorbisFile ); }\n    ```", "```kt\n      virtual int ReadFromFile(int Size, int BytesRead)\n      {\n        return (int)OGG_ov_read( &FVorbisFile,\n          &FBuffer[0] + BytesRead,\n          Size - BytesRead,\n    ```", "```kt\n          0, // 0 for LITTLE_ENDIAN, 1 for BIG_ENDIAN\n          FBitsPerSample >> 3,\n          1,\n          &FOGGCurrentSection );\n      }\n    ```", "```kt\n      virtual void Seek( float Time )\n      {\n        FEof = false;\n        OGG_ov_time_seek( &FVorbisFile, Time );\n      }\n    ```", "```kt\n    private:\n      #include \"OGG_Callbacks.h\"\n    };\n    ```", "```kt\n    size_t OGG_ReadFunc( void* Ptr, size_t Size, size_t NMemB,\n      void* DataSource )\n      {\n        OggProvider* OGG = (OggProvider*)DataSource;\n\n        size_t DataSize = OGG->FRawData->GetSize();\n\n        ogg_int64_t BytesRead = DataSize - OGG- >FOGGRawPosition;\n        ogg_int64_t BytesSize = Size * NMemB;\n\n        if ( BytesSize < BytesRead ) { BytesRead = BytesSize; }\n\n        memcpy( Ptr,\n          (ubyte*)OGG->FRawData->GetDataConst() +\n            OGG->FOGGRawPosition, (size_t)BytesRead );\n\n        OGG->FOGGRawPosition += BytesRead;\n        return (size_t)BytesRead;\n      }\n    ```", "```kt\n      int OGG_SeekFunc( void* DataSource, ogg_int64_t Offset,\n      int Whence )\n      {\n        OggProvider* OGG = (OggProvider*)DataSource;\n        size_t DataSize = OGG->FRawData->GetSize();\n        if ( Whence == SEEK_SET )\n        {\n          OGG->FOGGRawPosition = Offset;\n        }\n        else if ( Whence == SEEK_CUR )\n        {\n          OGG->FOGGRawPosition += Offset;\n        }\n        else if ( Whence == SEEK_END )\n        {\n          OGG->FOGGRawPosition = DataSize + Offset;\n        }\n    ```", "```kt\n        if ( OGG->FOGGRawPosition > (ogg_int64_t)DataSize )\n        {\n          OGG->FOGGRawPosition = (ogg_int64_t)DataSize;\n        }\n        return static_cast<int>( OGG->FOGGRawPosition );\n      }\n    ```", "```kt\n      int OGG_CloseFunc( void* DataSource ) { return 0; }\n    ```", "```kt\n      long OGG_TellFunc( void* DataSource )\n      {\n        return (int)\n          (((OggProvider*)DataSource)->FOGGRawPosition);\n      }\n    ```", "```kt\n  clPtr<AudioSource> Src = new AudioSource();\n  clPtr<Data> = LoadFileAsBlob( \"test.ogg\" );\n  Src->BindWaveform( new OggProvider(Data) );\n  Src->Play();\n  FPendingExit = false;\n  double Seconds = Env_GetSeconds();\n```", "```kt\n  While ( !IsPendingExit() )\n  {\n    float DeltaSeconds =\n       (float)(Env_GetSeconds() - Seconds );\n    Src->Update(DeltaSeconds);\n    Seconds = Env_GetSeconds();\n  }\n```", "```kt\n    class ModPlugProvider: public DecodingProvider\n    {\n    ```", "```kt\n    private:\n      ModPlugFile* FModFile;\n    ```", "```kt\n    public:\n      explicit ModPlugProvider( const clPtr<Blob>& Blob )\n      : DecodingProvider(Blob)\n      {\n        FChannels = 2;\n        FSamplesPerSec = 44100;\n        FBitsPerSample = 16;\n\n        FModFile = ModPlug_Load_P(\n          ( const void* )FRawData->GetDataConst(),\n          ( int )FRawData->GetSize() );\n      }\n    ```", "```kt\n      virtual ~ModPlugProvider() { ModPlug_Unload_P( FModFile ); }\n    ```", "```kt\n      virtual int ReadFromFile(int Size, int BytesRead)\n      {\n        return ModPlug_Read_P( FModFile,\n          &FBuffer[0] + BytesRead,\n          Size - BytesRead );\n      }\n    ```", "```kt\n      virtual void Seek( float Time )\n      {\n        FEof = false;\n        ModPlug_Seek_P( FModFile, ( int )( Time * 1000.0f ) );\n      }\n    };\n    ```"]