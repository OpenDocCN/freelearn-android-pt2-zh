- en: 'Chapter 7. Native Interaction: StageWebView and URI Handlers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a website in the default Android browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a website within an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the StageWebView history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using StageWebView to load ads using ActionScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using StageWebView to load ads within a Flex mobile project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a phone call from an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a text message from an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking Google maps from an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking the Android market using application URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mail from an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, Flash platform developers have not had access to render HTML
    websites as part of their applications; that all changes with the introduction
    of StageWebView in AIR for Android. This chapter includes tips on what makes such
    a mechanism different from normal display list objects, and how to use it effectively.
    We will also look at URI handling functions, which allow us to tap into native
    applications on an Android device such as the web browser, e-mail client, maps,
    and telephone.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a website in the default Android browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to desktop Flash and AIR applications, the default system Web browser
    can be invoked through classes in the `flash.net` package based upon some user
    interaction. On Android, since all applications take up a full window, we must
    be extra mindful of any disruption this may cause while the user is interacting
    with our application. For instance, when the user received a phone call or text
    message and must exit the application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the application invoke `navigateToURL` and passing in a new `URLRequest`
    will open the default web browser. In this example, we will open a website once
    a `TOUCH_TAP` event is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application on our device, the interactive `Sprite` should
    appear as follows:![How to do it...](img/1420_07_01a.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a touch tap, is detected our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` containing the HTTP or HTTPS address we want to
    open up from our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the application upon our device, a simple touch tap upon our button
    will invoke the native web browser application and load up our `URL request:`![How
    to do it...](img/1420_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android web browser,
    as the URL we've supplied is loaded over the network, displaying the requested
    web site. This is accomplished by passing a `URLRequest` through the `navigateToURL`
    method, which is very similar to the way we accomplish the same thing with a desktop
    application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While invoking the Android web browser from within our application can be very
    useful. It is much more interesting to be able to load web pages into an application
    without having to jump between applications. The user can, of course, use the
    Android back button to return to our application from the browser (if it is still
    open), but there are ways to ensure a more seamless experience. The next few recipes
    will describe how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a website within an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Flash content, it is traditionally not possible to display a fully rendered
    HTML website within an application. Adobe AIR initially changed this by allowing
    web pages to be loaded into the application on the desktop and interpreted through
    the internal AIR build of the web kit rendering engine through the desktop only
    `HTMLLoader` class. On Android, AIR allows us to do similar things through the
    use of `StageWebView`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will construct a new `StageWebView` instance to display a web page within
    our mobile Android application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label. Additionally, declare a `StageWebView`
    instance along with a `Rectangle` to define our view port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` view port to appear within
    our application. In this example, we determine the properties of our `Rectangle`
    based upon the position of the previously created `Sprite`, and the dimensions
    of the application `Stage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is good practice to check whether `StageWebView` is supported by invoking
    `StageWebView.isSupported` before constructing our `StageWebView` instance. To
    actually create a `StageWebView` object, we do a simple instantiation and assign
    the application `stage` to `StageWebView.stage`. Now assign the previously constructed
    `Rectangle` to the `StageWebView viewport` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application upon our device, the interactive `Sprite` with
    accompanying `StageWebView` should appear as follows:![How to do it...](img/1420_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which will instantiate a page load. We will also register an event of type `Event.COMPLETE`
    upon our `StageWebView` object to determine when a page load has been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`;
    it will begin to load a web page using `StageWebView.loadURL()`, passing in the
    page address as a `String` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the page load has been completed, we can gather information about the
    loaded content, such as the page `title`. In this case, we assign the page `title`
    to our `TextField` as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting application, once the web page has been completely loaded, will
    appear as follows:![How to do it...](img/1420_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StageWebView` class will use whichever web control is default on the host
    operating system to render any HTML that is displayed in the view port. It is
    important to note that `StageWebView` is not part of the traditional Flash `DisplayList`
    and cannot be added to our application in the normal way visual elements are added
    to the `DisplayList` (through `addChild())`.
  prefs: []
  type: TYPE_NORMAL
- en: As `StageWebView` is not part of the traditional `DisplayList`, we must use
    an alternative way of defining where it will appear on the `stage` and what space
    it will occupy. This is done through the use of a `Rectangle` object assigned
    to the `StageWebView.viewPort` property. The `StageWebView` class also requires
    a `stage` property to which is assigned the present application `stage`. So long
    as these two properties are correctly assigned, a viewport will appear within
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As `StageWebView` is not a part of the `DisplayList`, we should always call
    the `dispose()` method upon it once we have finished using it to allow complete
    removal from our application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the preceding section, AIR for Android will use the native
    WebKit rendering engine when invoking `StageWebView`. WebKit is used by a number
    of popular web browsers, including the Android browser, Apple Safari, and Google
    Chrome. Also of note: WebKit is actually a part of the Adobe AIR desktop runtime.
    For more information about WebKit, visit [http://www.webkit.org/](http://www.webkit.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the StageWebView history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing applications for Android, AIR allows us to render complete websites
    through the use of theStageWebView class. We also can tap into the navigation
    history of our `StageWebView` instance and apply that in different ways within
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a user has loaded a number of pages within our `StageWebView` instance,
    we will be able to navigate back and forth through the navigation history:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare two `Sprite` objects to act as our interactive elements,
    along with a `TextField` and `TextFormat` pair to serve as an address indicator.
    Additionally, declare a `StageWebView` instance along with a `Rectangle` to define
    our viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we will create two methods, which will build our previous and next history
    controls and add them to the `stage`. Instantiate a new `Sprite` for each and
    add a unique `name` property, specifying the desired function of the interaction.
    We will be able to read this later off our `touch tap` event to determine which
    `Sprite` was tapped. Draw a basic background using the graphics API and perform
    positioning upon the `stage` before adding each `Sprite` to the `DisplayList:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To complete our address indicator, we will continue to set up our `TextField`
    and apply a `TextFormat` object. In this example, we center the `TextField` upon
    the `stage` (between our two interactive `Sprites)` to simulate a web browser
    address bar. Create a method to perform all of these actions along with some stylistic
    enhancements and assign the default `String` of **Loading** to the `TextField`
    in order to let the user know something is going on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` to appear within our application.
    In this example, we determine the properties of our `Rectangle` based upon the
    position of the previously created `Sprite` and `TextField` objects as well as
    the dimensions of the application `Stage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is good practice to check whether `StageWebView` is supported by invoking
    `StageWebView. is supported` before constructing our `StageWebView` instance.
    To actually create a `StageWebView` object, we do a simple instantiation and assign
    the application `stage` to `StageWebView.stage`. Now assign the previously constructed
    `Rectangle` to the `StageWebViewviewport` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon both of our `Sprite` buttons. This will detect
    any touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which will determine whether to go back or forward in the navigation history depending
    upon which `Sprite` was tapped. We will also register an event of type `LocationChangeEvent.LOCATION_CHANGE`
    upon our `StageWebView` object to determine when a page load has been completed.
    Finally, we can invoke `StageWebView.loadURL`, passing in a web address as the
    only argument. This will begin to load our default location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we were to run the application at this point, we would see all of our interactive
    elements appear on the stage and the desired Web page would render within our
    `StageWebView` instance:![How to do it...](img/1420_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As `Sprite` interactions are detected, we determine which particular `Sprite`
    was tapped by examining the `name` attribute that was provided directly after
    instantiation. In this way, we know whether to attempt to move forward or backward
    through the `StageWebView` history through the use of either the `historyBack()`
    or `historyForward()` methods. In order to detect whether we can actually do so,
    we can first check to see whether the back or forward history is enabled on the
    device as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the current location being rendered by our `StageWebView` instance changes,
    we update our `TextField` with the present URL much in the way a standard web
    browser address bar would do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The user will now be able to navigate back and forth through the `StageWebView`
    history as they begin to click on various hyperlinks as shown in the following
    screenshot:![How to do it...](img/1420_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StageWebView` class will use whichever web control is default on the host
    operating system to render any HTML that is displayed in the view port. It is
    important to note that `StageWebView` is not part of the traditional Flash `DisplayList`
    and cannot be added to our application in the normal way visual elements are added
    to the `DisplayList` (through `addChild())`.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the `StageWebView` history, we can use either the `historyBack()`
    or `historyForward()` methods to navigate along the user history within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Neither of these methods will do anything unless the user has begun clicking
    on hyperlinks and performing actual navigation within the `StageWebView` instance.
    We have basically just created our own little web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Using StageWebView to load ads using ActionScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most sought after features of mobile Android development using the
    Flash platform has been the ability to include advertisements from services such
    as Google AdSense or AdMob within applications. This allows developers to distribute
    their applications for no charge to users, but still receive revenue from advertisements
    displayed within the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StageWebView` opens up a lot of possibilities for mobile application development,
    one of which is the ability to load HTML-based advertisements in running applications.
    In the following example, we will examine how simple it is to manage this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now declare a `StageWebView` instance along with a `Rectangle` to define
    our viewport. Lastly, set up a `Timer`, which will serve as a mechanism to refresh
    our ads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` to appear within our application.
    It is good practice to check whether `StageWebView` is supported by invoking `StageWebView.isSupported`
    before constructing our `StageWebView` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To actually create a `StageWebView` object, we do a simple instantiation and
    assign the application `stage` to `StageWebView.stage`. Now assign the previously
    constructed `Rectangle` to the `StageWebViewviewport` property, and alternatively
    load up a web page using `loadURL()`, passing in the page address as a `String:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we have not done so already, in order for this to function correctly, we
    must set up a web page on our server to interface with the ad service we have
    chosen. In this example, we are using AdMob ([http://www.admob.com/](http://www.admob.com/))
    because the ads are tuned for and directed at mobile web and mobile device applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One important thing here is to be sure and set the `bodymargin` and `padding`
    to `0` through CSS to avoid any space around our ad. `StageWebView` is essentially
    just running HTML, so if we don't modify things slightly, the default HTML rendering
    engine (in the case of Android, this is web Kit) will simply interpret all stylistic
    elements through its default settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will want to replace the `pubid` attribute with your own, or register with
    a different ad service. Use this snippet as a reference to create your own HTML
    file to store upon a server and invoke through your particular application as
    we have done in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to set up our `Timer` to switch out ads every 10 seconds. We
    do this by instantiating a new `Timer` object, and passing 10000 milliseconds
    (or your preferred amount of time). Now, register an event listener of type `TimerEvent.Timer`
    to fire off a method of our construction every time the `Timer` hits 10 seconds.
    To start the `Timer`, we invoke `Timer.start():`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All that remains is to create our `onTimer` method to reload the `StageWebView`
    instance every time the `Timer` hits 10 seconds. This will make a new call to
    the web, pulling the HTML down again, thus invoking the ad serving script anew.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The page will refresh every time our `Timer` is fired, revealing a new advertisement
    in our application:![How to do it...](img/1420_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StageWebView` class will use whichever web control is default on the host
    operating system to render any HTML that is displayed in the view port. It is
    important to note that `StageWebView` is not part of the traditional Flash `DisplayList`
    and cannot be added to our application in the normal way visual elements are added
    to the `DisplayList` (through `addChild())`.
  prefs: []
  type: TYPE_NORMAL
- en: To actually render advertisements within the application, we can initially load
    up a web page using `loadURL()`, passing in the page address as a `String`. This
    address should point to an HTML document that interfaces with an ad service of
    our choosing, for which we have previously registered for. Normally, these services
    simple provide you with a chunk of JavaScript to place into your HTML, which will
    invoke ads for you upon page load. To refresh our view port and load up a new
    add, we can simply invoke `StageWebView.reload()`. In the case of our example,
    we employ a `Timer` to perform this action every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we decided to use AdMob for this example, a developer can generally include
    any ad system they prefer. In the following screenshot, I am ingesting ads from
    Google AdSense in the very same way. You will notice though, that with the normal
    version of AdSense (when not using mobile content units), the ads do not conform
    to the screen in an intelligent way. AdMob is tailored for mobile, so works much
    better in these situations. In the future, there should be plenty of new opportunities
    in this space beyond the two ad providers mentioned here. We must also keep in
    mind that these are third-party services, and may change at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1420_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using StageWebView to load ads within a Flex mobile project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As `StageWebView` instances are not part of the `DisplayList`, we could have
    a perceived problem when it comes to using it within a `ViewNavigatorApplication`.
    The main problem being that the `StageWebView` will always remain an overlay above
    all other objects, and that it will not be able to transition along with other
    items within a particular view. In this recipe, we will examine this and demonstrate
    some techniques for coping with the inordinate behaviour of the `StageWebView`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we'll be using Google AdSense **Mobile content | Ad units**.
    You will need to sign up for an AdSense account at [https://www.google.com/adsense/](http://https://www.google.com/adsense/)
    and configure a **Mobile content Ad unit:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/1420_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you already have an AdMob account (or some other service), you can always
    use that instead, or even a simple ad of your own creation for this demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new `ViewNavigatorApplication` with two distinct views, demonstrating
    how the `StageWebView` exists outside of this structure, how to remove the `StageWebView`
    from view, and provide reference to an additional ad serving system.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a number of files involved in this example; we will approach their
    assembly using different sections for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTML file to display our ads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we have not done so already, in order for this to function correctly, we
    must set up a web page on our server to interface with Google AdSense. You will
    want to replace the `client` attribute from the following example with your own.
    Use this snippet as a reference to create your own HTML file to store upon a server
    and invoke through your particular application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating the MXML files for our ViewNavigatorApplication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we create our main application file with a root node of `ViewNavigatorApplication`
    in order to take advantage of the view-based layout it provides. We can set the
    `applicationDPI`, if need be, and employ the `firstView` attribute to reference
    the initial `View`. We will define this `View` a bit later on in the recipe. Before
    moving on, let''s register a method called `init()` to fire once our application
    completes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a script block to hold all of the ActionScript for our application. The
    code for doing so will be defined in another step for clarity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will add some functionality to our `ActionBar` by adding two `Button`
    controls to the `navigationContent` node. Each of these `Button` controls will
    invoke the `ViewNavigator.pushView()` method. This method accepts a `View` reference
    as an argument, and when invoked, will bring that `View` to the top of our view
    stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will assemble our two views for this example. Place a `Button` control
    in each `View` along with a `click` event handler, which will invoke a method
    in our main application file to toggle the ads on and off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FlexAdsHomeView.mxml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: FlexAdsOtherView.mxml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generating the ActionScript code to tie it all together
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This code will exist within our main application file `script` block, which
    we had previously defined:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `StageWebView` instance along with a `Rectangle` to define
    our view port. Lastly, set up a `Timer`, which will serve as a mechanism to refresh
    our ads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the initialization function referred to earlier, which will simply invoke
    the methods we will construct to set up the `StageWebView` instance and our ad
    refresh `Timer:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` to appear within our application.
    It is good practice to check whether `StageWebView` is supported by invoking `StageWebView.isSupported`
    before constructing our `StageWebView` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To actually create a `StageWebView` object, we do a simple instantiation and
    assign the application `stage` to `StageWebView.stage`. Now assign the previously
    constructed `Rectangle` to the `StageWebViewviewport` property, and alternatively
    load up a web page using `loadURL()`, passing in the page address as a `String:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To toggle the ads on and off from within the individual views, we simply check
    whether the `StageWebView.viewPort` is `null` or not and based upon this result,
    either set it to a `Rectangle` object or assign upon it a value of `null`. If
    the `viewPort` is `null`, the ad will no longer be visible to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to set up our `Timer` to switch out ads every 8 seconds. We
    do this by instantiating a new `Timer` object, passing in 8000 milliseconds (or
    your preferred amount of time). Now, register an event listener of type `TimerEvent.Timer`
    to fire off a method of our construction every time the `Timer` hits 8 seconds.
    To start the `Timer`, we invoke `Timer.start():`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that remains is to create our `onTimer` method to reload the `StageWebView`
    instance every time the `Timer` hits 10 seconds. This will make a new call to
    the web, pulling the HTML down again, thus invoking the ad serving script anew:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application is run, an ad will immediately be displayed within the
    `StageWebView` instance and our initial `View` is made present to the user. At
    this point, the user can interact with the `ActionBar` and switch between each
    `View`. The `StageWebView` instance will remain in place even though the `View`
    contents shift as the application `ViewNavigator` shuffles views. At any point,
    the user can toggle the ads off or on through the `Button` instances in either
    `View:`![Generating the ActionScript code to tie it all together](img/1420_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `StageWebView` within a `ViewNavigatorApplication` may seem troublesome
    at first, if we keep in mind some of the limitations of this particular object,
    and manage the `StageWebView` in a mindful way, it isn't that difficult to produce
    a workable implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If ever we want to completely remove a `StageWebView` object from our application,
    we can invoke `StageWebView.dispose(),which` will remove the `StageWebView` object
    and allow it to be processed by the garbage collector. Even if we remove a `StageWebView`
    instance in this way, we can always create a new one, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Making a phone call from an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the great features and sheer power of the Android operating system,
    it is easy to forget that these devices are primarily telephones. In this recipe,
    we will demonstrate how to invoke the native Android telephone utility from within
    an application, passing along a phone number to dial.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the application invoke `navigateToURL` and passing in a new `URLRequest`
    with the correct URI of `tel:` will open the default telephone application along
    with the specified phone number loaded up and ready to be dialed. In this example,
    we will perform this action once a `TOUCH_TAP` event is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as the following screenshot:![How to do it...](img/1420_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` containing the `tel:` URI prefix followed by the
    phone number we want to dial from our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the application upon our device, a simple touch tap on our button
    will invoke the native telephone application along with our specified phone number
    already entered:![How to do it...](img/1420_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android telephone utility.
    Along with this invocation is supplied a phone number, which was assigned to this
    call by passing a `URLRequest` with a `tel:` URI prefix through the `navigateToURL`
    method. In this way, we can easily allow users of our application access to a
    phone number without their even having to dial it.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a text message from an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Flash on Android, we have the ability to invoke the native Android SMS
    utility through classes in the `flash.net` package based upon user interaction.
    We do not have the ability to supply any content for the text message, unfortunately.
    On Android, since all applications take up a full window, we must be extra mindful
    of any disruption this may cause while the user is interacting with our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the application invoke `navigateToURL` and passing in a new `URLRequest`
    with the correct URI prefix of `sms:` will open the default SMS utility along
    with the specified phone number loaded up, ready to text. In this example, we
    will perform this action once a `TOUCH_TAP` event is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as follows:![How to do it...](img/1420_07_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` containing the `tel:` URI prefix followed by the
    phone number we want to dial from our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we will lose application focus and be presented with the Android
    SMS utility, prepopulated with our desired phone number and ready to compose a
    text message:![How to do it...](img/1420_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, once we hit **Send**, our text message is transmitted to the targeted
    recipient specified through the phone number used. In this example, it is not
    a real phone number, of course:![How to do it...](img/1420_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android SMS utility.
    Along with this invocation is supplied a phone number, which was assigned to this
    text message by passing a `URLRequest` with a `sms:` URI prefix through the `navigateToURL`
    method. In this way, we can easily allow users of our application access to a
    phone number for texting without their even having to input a numeric sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking Google maps from an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being that most Android devices are mobile, the ability to tap into some sort
    of mapping is expected by both developers and users. The Android OS is managed
    by Google, and the company has a long history of great mapping technologies on
    the web. This is great for developers because we can piggyback on the very cool
    Maps application on Android and pass in all sorts of coordinates from our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have the application detect the device geolocation coordinates, invoke `navigateToURL,`
    and pass in a new `URLRequest` with a correctly formatted URL to access the Android
    maps application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label. We will be employing the `Geolocation`
    API, and so declare an object for this purpose along with `Number` variables to
    hold latitude and longitude data values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us, along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as in the following screenshot:![How to do it...](img/1420_07_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Upon the detection of a touch tap event, we will set up a `Geolocation` object
    and assign an event listener to it, listening specifically for a `GeolocationEvent.UPDATE`
    event. We will no longer need to listen for our `TouchEvent.TOUCH_TAP` event,
    so may remove it to allow for garbage collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once `Geolocation` data is gathered and reported back to our application, the
    `onGeoEvent` method will fire, providing us with the `longitude` and `latitude`
    data we need to pass in to the native Android maps application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To complete our sequence, we will invoke `navigateToURL` and pass in a `URLRequest`
    containing the `http://maps.google.com/` URL followed by a query string containing
    the `latitude` and `longitude` values from our `Geolocation` update event data.
    Since we now have all the data we need, remove the `GeolocationEvent.UPDATE` event
    listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the URI prefix used in this example is simply `http://`, a model dialog will
    appear over our application, asking whether we would like to open the `URLRequest`
    using the **Browser** or **Maps** application. We will choose **Maps**. Selecting
    the **Use by default for this action** checkbox will prevent this dialog from
    appearing in the future:![How to do it...](img/1420_07_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the **Maps** application will appear and present the user with a view
    based upon the detected latitude and longitude Geolocation coordinates that our
    application was able to detect:![How to do it...](img/1420_07_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    we configure a `Geolocation` object to listen for location data. Once this data
    is acquired, we can then pass a `URLRequest` with the `http://` URI prefix through
    the `navigateToURL` method to summon `maps.google.com`. We also append a query
    string formed from the collected `Geolocation` latitude and longitude data, informing
    the **Maps** application the exact coordinates to navigate to on our map.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to detecting `Geolocation` data from device sensors would be
    to store a variety of coordinates within the application and then present the
    user with a number of choices. This would be useful for a specialized restaurant
    application, allowing users to easily view locations on a map, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the Android Market using application URIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android Market is unique to the Android platform and there is a dedicated
    application which allows users to easily search for, find, and install applications
    on their devices. Android allows a developer to tap into the Market application
    by passing in certain search terms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build a small application to invoke `navigateToURL` and pass a predefined
    search term through a `URLRequest` object with the `market:` URI prefix. This
    will open the Android Market application and have it perform a search for us.
    In this example, we will open a new request once a `TOUCH_TAP` event is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as shown in the following screenshot:![How to do it...](img/1420_07_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` with a URI prefix of `market:` containing the search
    terms we want to have the application perform against the Market inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the application upon our device, a simple touch tap upon our button
    will invoke the Android Market application and perform a search for the terms
    that we've passed over from our application:![How to do it...](img/1420_07_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the Android Market application,
    where a search is instantly performed against the search terms specified in our
    request. The Android Market application will reveal to the user whatever applications
    it finds in the current inventory. For instance, passing in the exact title of
    our application will allow a user to manually check for updates from within the
    application. Passing in our company or developer name will bring up all of the
    applications we have made available for the user to browse.
  prefs: []
  type: TYPE_NORMAL
- en: If further specificity is required, there are additional search queries that
    can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for a specific application, we can use the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for a specific publisher, we use the following (notice we are escaping
    quotes by using the "\" character in our query string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Sending e-mail from an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to desktop Flash and AIR applications, the default system e-mail client
    can be invoked through classes in the `flash.net` package based upon some user
    interaction. On Android, since all applications take up a full window, we must
    be extra mindful of any disruption this may cause while the user is interacting
    with our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the application invoke `navigateToURL` and passing an e-mail address
    through a new `URLRequest` with the `mailto:` URI prefix will open the default
    e-mail utility. In this example, we will open a new e-mail once a `TOUCH_TAP`
    event is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as follows:![How to do it...](img/1420_07_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in aURLRequest with a URI prefix of `mailto:` containing the e-mail
    address we want to open up from our application, along with a subject parameter,
    if desired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the application on our device, a simple touch tap upon our button
    will invoke the native e-mail client and populate it with the values that we've
    passed over from our application.![How to do it...](img/1420_07_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android e-mail client.
    This is accomplished by passing the desired e-mail address through a `URLRequest`
    with a URI prefix of `mailto:` along with a set of appended parameters through
    the `navigateToURL` method, which is very similar to the way we accomplish the
    same thing with a desktop or web application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, we could always write an application that handles e-mail internally,
    just as we would on a web application. So long as we have access to a server with
    e-mail capability; this may be preferred for some applications.
  prefs: []
  type: TYPE_NORMAL
