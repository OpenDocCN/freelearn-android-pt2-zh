- en: 'Chapter 7. Native Interaction: StageWebView and URI Handlers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章.本地交互：StageWebView 和 URI 处理程序
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Opening a website in the default Android browser
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在默认的 Android 浏览器中打开网站
- en: Rendering a website within an application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序内渲染网站
- en: Managing the StageWebView history
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 StageWebView 历史记录
- en: Using StageWebView to load ads using ActionScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 StageWebView 和 ActionScript 加载广告
- en: Using StageWebView to load ads within a Flex mobile project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flex 移动项目中使用 StageWebView 加载广告
- en: Making a phone call from an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序拨打电话
- en: Sending a text message from an application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序发送短信
- en: Invoking Google maps from an application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序调用 Google 地图
- en: Invoking the Android market using application URIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序 URI 调用 Android 市场
- en: Sending e-mail from an application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序发送电子邮件
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Traditionally, Flash platform developers have not had access to render HTML
    websites as part of their applications; that all changes with the introduction
    of StageWebView in AIR for Android. This chapter includes tips on what makes such
    a mechanism different from normal display list objects, and how to use it effectively.
    We will also look at URI handling functions, which allow us to tap into native
    applications on an Android device such as the web browser, e-mail client, maps,
    and telephone.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Flash 平台开发者无法将 HTML 网站渲染为应用程序的一部分；随着 AIR for Android 中 StageWebView 的引入，这一切都改变了。本章包括关于这种机制与普通显示列表对象的不同之处，以及如何有效地使用它的小贴士。我们还将探讨
    URI 处理功能，它允许我们接入 Android 设备上的本地应用程序，如网页浏览器、电子邮件客户端、地图和电话。
- en: Opening a website in the default Android browser
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在默认的 Android 浏览器中打开网站
- en: Similar to desktop Flash and AIR applications, the default system Web browser
    can be invoked through classes in the `flash.net` package based upon some user
    interaction. On Android, since all applications take up a full window, we must
    be extra mindful of any disruption this may cause while the user is interacting
    with our application. For instance, when the user received a phone call or text
    message and must exit the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于桌面 Flash 和 AIR 应用程序，默认的系统 Web 浏览器可以通过 `flash.net` 包中的类在用户交互的基础上调用。在 Android
    上，由于所有应用程序都占用一个完整的窗口，因此我们必须特别注意这可能会在用户与我们的应用程序交互时造成干扰。例如，当用户接到电话或短信必须退出应用程序时。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Having the application invoke `navigateToURL` and passing in a new `URLRequest`
    will open the default web browser. In this example, we will open a website once
    a `TOUCH_TAP` event is detected:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序调用 `navigateToURL` 并传入一个新的 `URLRequest` 将打开默认的 Web 浏览器。在这个例子中，我们将在检测到 `TOUCH_TAP`
    事件时打开一个网站：
- en: 'First, import the following classes into your project:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个 `Sprite` 作为我们的交互元素，以及一个 `TextField` 和 `TextFormat` 对作为按钮标签：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的 `TextField`，应用一个 `TextFormat` 对象，并使用图形 API 构造一个具有简单背景填充的 `Sprite`。我们按钮构建的最后一步是将
    `TextField` 添加到 `Sprite` 中，然后将 `Sprite` 添加到 `DisplayList` 中。在这里，我们创建一个方法来执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we now run the application on our device, the interactive `Sprite` should
    appear as follows:![How to do it...](img/1420_07_01a.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用程序，交互式 `Sprite` 应如下所示：![如何操作...](img/1420_07_01a.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现将 `Multitouch.inputMode` 设置为通过 `MultitouchInputMode.TOUCH_POINT` 常量响应原始触摸事件。在
    `Sprite` 按钮上注册一个类型为 `TouchEvent.TOUCH_TAP` 的事件监听器。这将检测用户发起的任何触摸点击事件，并调用名为 `onTouchTap`
    的方法，该方法包含我们的其余逻辑：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once a touch tap, is detected our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` containing the HTTP or HTTPS address we want to
    open up from our application:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦检测到轻触，我们的`onTouchTap`方法将被触发，调用`navigateToURL`并传入一个包含我们想要从应用程序中打开的HTTP或HTTPS地址的`URLRequest`：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we run the application upon our device, a simple touch tap upon our button
    will invoke the native web browser application and load up our `URL request:`![How
    to do it...](img/1420_07_02.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上运行应用程序时，只需轻触按钮就会调用原生的网络浏览器应用程序并加载我们的`URL请求:`![如何操作...](img/1420_07_02.jpg)
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android web browser,
    as the URL we've supplied is loaded over the network, displaying the requested
    web site. This is accomplished by passing a `URLRequest` through the `navigateToURL`
    method, which is very similar to the way we accomplish the same thing with a desktop
    application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序用户轻触我们创建的交互式`Sprite`时，他们会离开我们的应用程序，进入默认的安卓网络浏览器，因为我们提供的URL通过网络加载，显示请求的网页。这是通过`navigateToURL`方法传递一个`URLRequest`实现的，这与我们在桌面应用程序中实现相同功能的方式非常相似。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While invoking the Android web browser from within our application can be very
    useful. It is much more interesting to be able to load web pages into an application
    without having to jump between applications. The user can, of course, use the
    Android back button to return to our application from the browser (if it is still
    open), but there are ways to ensure a more seamless experience. The next few recipes
    will describe how to accomplish this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从我们的应用程序中调用Android网络浏览器可能非常有用，但能够将网页加载到应用程序中而不必在应用程序之间跳转则更有趣。当然，用户可以使用Android返回按钮从浏览器返回到我们的应用程序（如果它仍然打开），但还有方法可以确保更无缝的体验。接下来的几个食谱将描述如何实现这一点。
- en: Rendering a website within an application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中渲染网站
- en: With Flash content, it is traditionally not possible to display a fully rendered
    HTML website within an application. Adobe AIR initially changed this by allowing
    web pages to be loaded into the application on the desktop and interpreted through
    the internal AIR build of the web kit rendering engine through the desktop only
    `HTMLLoader` class. On Android, AIR allows us to do similar things through the
    use of `StageWebView`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flash内容，传统上不可能在应用程序中显示完全渲染的HTML网站。Adobe AIR最初通过允许将网页加载到桌面应用程序中并仅通过桌面`HTMLLoader`类通过内部AIR构建的web
    kit渲染引擎来改变这一点。在Android上，AIR允许我们通过使用`StageWebView`来做类似的事情。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will construct a new `StageWebView` instance to display a web page within
    our mobile Android application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个新的`StageWebView`实例，在移动Android应用程序中显示一个网页：
- en: 'First, import the following classes into your project:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label. Additionally, declare a `StageWebView`
    instance along with a `Rectangle` to define our view port:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`Sprite`作为我们的交互元素，以及一个`TextField`和`TextFormat`对作为按钮标签。此外，声明一个`StageWebView`实例以及一个`Rectangle`来定义我们的视口：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个具有简单背景填充的`Sprite`。按钮构建的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`中。这里，我们创建一个方法来为我们执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` view port to appear within
    our application. In this example, we determine the properties of our `Rectangle`
    based upon the position of the previously created `Sprite`, and the dimensions
    of the application `Stage`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来构建我们的`StageWebView`对象，通过定义一个新的`Rectangle`，设定我们希望`StageWebView`视口在应用程序中的位置和大小。在这个例子中，我们根据之前创建的`Sprite`的位置以及应用程序`Stage`的尺寸来确定我们的`Rectangle`的属性。
- en: 'It is good practice to check whether `StageWebView` is supported by invoking
    `StageWebView.isSupported` before constructing our `StageWebView` instance. To
    actually create a `StageWebView` object, we do a simple instantiation and assign
    the application `stage` to `StageWebView.stage`. Now assign the previously constructed
    `Rectangle` to the `StageWebView viewport` property:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造我们的 `StageWebView` 实例之前，通过调用 `StageWebView.isSupported` 来检查是否支持 `StageWebView`
    是一个好习惯。实际上，要创建一个 `StageWebView` 对象，我们只需进行简单的实例化并将应用程序 `stage` 分配给 `StageWebView.stage`。现在，将先前构建的
    `Rectangle` 分配给 `StageWebView viewport` 属性：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we now run the application upon our device, the interactive `Sprite` with
    accompanying `StageWebView` should appear as follows:![How to do it...](img/1420_07_03.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用程序，带有伴随 `StageWebView` 的交互式 `Sprite` 应如下所示：![如何操作...](img/1420_07_03.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which will instantiate a page load. We will also register an event of type `Event.COMPLETE`
    upon our `StageWebView` object to determine when a page load has been completed:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将 `Multitouch.inputMode` 分配给通过 `MultitouchInputMode.TOUCH_POINT` 常量响应原始触摸事件。在
    `Sprite` 按钮上注册一个类型为 `TouchEvent.TOUCH_TAP` 的事件监听器。这将检测用户发起的任何触摸点击事件，并调用名为 `onTouchTap`
    的方法，该方法将实例化页面加载。我们还将为 `StageWebView` 对象注册一个类型为 `Event.COMPLETE` 的事件，以确定页面加载何时完成：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`;
    it will begin to load a web page using `StageWebView.loadURL()`, passing in the
    page address as a `String` argument:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当检测到触摸点击时，我们的 `onTouchTap` 方法将被触发，调用 `navigateToURL`；它将开始使用 `StageWebView.loadURL()`
    加载网页，传入页面地址作为 `String` 参数：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the page load has been completed, we can gather information about the
    loaded content, such as the page `title`. In this case, we assign the page `title`
    to our `TextField` as an example:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦页面加载完成，我们可以收集有关已加载内容的信息，例如页面 `title`。在这种情况下，我们将页面 `title` 分配给我们的 `TextField`
    作为示例：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The resulting application, once the web page has been completely loaded, will
    appear as follows:![How to do it...](img/1420_07_04.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当网页完全加载后，生成的应用程序将如下所示：![如何操作...](img/1420_07_04.jpg)
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `StageWebView` class will use whichever web control is default on the host
    operating system to render any HTML that is displayed in the view port. It is
    important to note that `StageWebView` is not part of the traditional Flash `DisplayList`
    and cannot be added to our application in the normal way visual elements are added
    to the `DisplayList` (through `addChild())`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageWebView` 类将使用主机操作系统上的默认网页控件来渲染视口中显示的任何HTML内容。需要注意的是，`StageWebView` 并不是传统Flash
    `DisplayList` 的一部分，不能像将视觉元素添加到 `DisplayList`（通过 `addChild()`）那样以常规方式添加到我们的应用程序中。'
- en: As `StageWebView` is not part of the traditional `DisplayList`, we must use
    an alternative way of defining where it will appear on the `stage` and what space
    it will occupy. This is done through the use of a `Rectangle` object assigned
    to the `StageWebView.viewPort` property. The `StageWebView` class also requires
    a `stage` property to which is assigned the present application `stage`. So long
    as these two properties are correctly assigned, a viewport will appear within
    our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `StageWebView` 不属于传统的 `DisplayList`，我们必须使用另一种方式来定义它在 `stage` 上的位置以及它将占用的空间。这是通过将
    `Rectangle` 对象分配给 `StageWebView.viewPort` 属性来完成的。`StageWebView` 类还需要一个 `stage`
    属性，将其分配给当前应用程序的 `stage`。只要这两个属性正确分配，视口就会出现在我们的应用程序中。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As `StageWebView` is not a part of the `DisplayList`, we should always call
    the `dispose()` method upon it once we have finished using it to allow complete
    removal from our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `StageWebView` 不是 `DisplayList` 的一部分，一旦我们使用完毕，应该始终对其调用 `dispose()` 方法，以便从应用程序中完全移除。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As mentioned in the preceding section, AIR for Android will use the native
    WebKit rendering engine when invoking `StageWebView`. WebKit is used by a number
    of popular web browsers, including the Android browser, Apple Safari, and Google
    Chrome. Also of note: WebKit is actually a part of the Adobe AIR desktop runtime.
    For more information about WebKit, visit [http://www.webkit.org/](http://www.webkit.org/).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所述，当调用`StageWebView`时，AIR for Android 将使用原生的 WebKit 渲染引擎。WebKit 被众多流行的网络浏览器使用，包括
    Android 浏览器、Apple Safari 和 Google Chrome。值得注意的是：WebKit 实际上是 Adobe AIR 桌面运行时的一部分。关于
    WebKit 的更多信息，请访问[http://www.webkit.org/](http://www.webkit.org/)。
- en: Managing the StageWebView history
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 StageWebView 历史
- en: When developing applications for Android, AIR allows us to render complete websites
    through the use of theStageWebView class. We also can tap into the navigation
    history of our `StageWebView` instance and apply that in different ways within
    our application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Android 开发应用程序时，AIR 允许我们通过使用 StageWebView 类来渲染完整的网站。我们还可以利用`StageWebView`实例的导航历史，并在应用程序中以不同的方式应用它。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once a user has loaded a number of pages within our `StageWebView` instance,
    we will be able to navigate back and forth through the navigation history:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户在我们的`StageWebView`实例中加载了一些页面，我们就可以通过导航历史前后导航：
- en: 'First, import the following classes into your project:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will now declare two `Sprite` objects to act as our interactive elements,
    along with a `TextField` and `TextFormat` pair to serve as an address indicator.
    Additionally, declare a `StageWebView` instance along with a `Rectangle` to define
    our viewport:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明两个`Sprite`对象作为我们的交互元素，以及一个`TextField`和`TextFormat`对作为地址指示器。此外，声明一个`StageWebView`实例以及一个`Rectangle`来定义我们的视口：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we will create two methods, which will build our previous and next history
    controls and add them to the `stage`. Instantiate a new `Sprite` for each and
    add a unique `name` property, specifying the desired function of the interaction.
    We will be able to read this later off our `touch tap` event to determine which
    `Sprite` was tapped. Draw a basic background using the graphics API and perform
    positioning upon the `stage` before adding each `Sprite` to the `DisplayList:`
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建两个方法，用来构建我们的前进和后退历史控制，并将它们添加到`stage`上。为每个方法实例化一个新的`Sprite`，并添加一个唯一的`name`属性，指定交互的预期功能。我们稍后可以通过`touch
    tap`事件读取它，以确定哪个`Sprite`被点击。使用图形 API 绘制基本背景，并在将每个`Sprite`添加到`DisplayList`之前在`stage`上进行定位：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To complete our address indicator, we will continue to set up our `TextField`
    and apply a `TextFormat` object. In this example, we center the `TextField` upon
    the `stage` (between our two interactive `Sprites)` to simulate a web browser
    address bar. Create a method to perform all of these actions along with some stylistic
    enhancements and assign the default `String` of **Loading** to the `TextField`
    in order to let the user know something is going on.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的地址指示器，我们继续设置我们的`TextField`并应用一个`TextFormat`对象。在这个例子中，我们将`TextField`在`stage`上居中（位于两个交互式`Sprites`之间）以模拟网络浏览器的地址栏。创建一个方法来执行所有这些操作以及一些样式增强，并将默认的**加载中**字符串分配给`TextField`，以让用户知道正在发生的事情。
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` to appear within our application.
    In this example, we determine the properties of our `Rectangle` based upon the
    position of the previously created `Sprite` and `TextField` objects as well as
    the dimensions of the application `Stage`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来构建我们的`StageWebView`对象，通过定义一个新的`Rectangle`，设定我们希望`StageWebView`在应用程序中显示的位置和大小。在这个例子中，我们根据之前创建的`Sprite`和`TextField`对象的位置以及应用程序`Stage`的尺寸来确定我们`Rectangle`的属性。
- en: 'It is good practice to check whether `StageWebView` is supported by invoking
    `StageWebView. is supported` before constructing our `StageWebView` instance.
    To actually create a `StageWebView` object, we do a simple instantiation and assign
    the application `stage` to `StageWebView.stage`. Now assign the previously constructed
    `Rectangle` to the `StageWebViewviewport` property:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建我们的`StageWebView`实例之前，通过调用`StageWebView.is supported`来检查是否支持`StageWebView`是一个好习惯。实际上，要创建一个`StageWebView`对象，我们只需进行简单的实例化并将应用程序`stage`分配给`StageWebView.stage`。现在，将之前构建的`Rectangle`分配给`StageWebView`的`viewport`属性：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon both of our `Sprite` buttons. This will detect
    any touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which will determine whether to go back or forward in the navigation history depending
    upon which `Sprite` was tapped. We will also register an event of type `LocationChangeEvent.LOCATION_CHANGE`
    upon our `StageWebView` object to determine when a page load has been completed.
    Finally, we can invoke `StageWebView.loadURL`, passing in a web address as the
    only argument. This will begin to load our default location:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`设置为通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在两个`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用一个名为`onTouchTap`的方法，该方法将根据点击的`Sprite`决定是在导航历史中后退还是前进。我们还会在`StageWebView`对象上注册一个类型为`LocationChangeEvent.LOCATION_CHANGE`的事件，以确定页面加载何时完成。最后，我们可以调用`StageWebView.loadURL`，传入一个网页地址作为唯一参数。这将开始加载我们的默认位置：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we were to run the application at this point, we would see all of our interactive
    elements appear on the stage and the desired Web page would render within our
    `StageWebView` instance:![How to do it...](img/1420_07_05.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行这个应用，我们会看到所有的交互元素都出现在舞台上，并且我们想要的网页会在`StageWebView`实例中渲染出来：![如何操作...](img/1420_07_05.jpg)
- en: 'As `Sprite` interactions are detected, we determine which particular `Sprite`
    was tapped by examining the `name` attribute that was provided directly after
    instantiation. In this way, we know whether to attempt to move forward or backward
    through the `StageWebView` history through the use of either the `historyBack()`
    or `historyForward()` methods. In order to detect whether we can actually do so,
    we can first check to see whether the back or forward history is enabled on the
    device as shown in the following code snippet:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当检测到`Sprite`交互时，我们通过检查实例化后直接提供的`name`属性来确定被点击的特定`Sprite`。这样，我们就知道是否应该使用`historyBack()`或`historyForward()`方法尝试通过历史记录向前或向后移动。为了检测我们是否真的可以这样做，我们可以首先检查设备上是否启用了后退或前进历史，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As the current location being rendered by our `StageWebView` instance changes,
    we update our `TextField` with the present URL much in the way a standard web
    browser address bar would do:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们`StageWebView`实例正在渲染的当前位置发生变化时，我们会像标准网络浏览器的地址栏一样，用当前的URL更新我们的`TextField`：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The user will now be able to navigate back and forth through the `StageWebView`
    history as they begin to click on various hyperlinks as shown in the following
    screenshot:![How to do it...](img/1420_07_06.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户现在可以通过点击各种超链接，在`StageWebView`的历史记录中前后导航，如下面的截图所示：![如何操作...](img/1420_07_06.jpg)
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `StageWebView` class will use whichever web control is default on the host
    operating system to render any HTML that is displayed in the view port. It is
    important to note that `StageWebView` is not part of the traditional Flash `DisplayList`
    and cannot be added to our application in the normal way visual elements are added
    to the `DisplayList` (through `addChild())`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageWebView`类将使用主机操作系统上的默认网络控件来渲染视口中显示的任何HTML。需要注意的是，`StageWebView`不是传统Flash
    `DisplayList`的一部分，不能像将视觉元素添加到`DisplayList`（通过`addChild()`）那样以常规方式添加到我们的应用程序中。'
- en: To manage the `StageWebView` history, we can use either the `historyBack()`
    or `historyForward()` methods to navigate along the user history within our application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理`StageWebView`的历史记录，我们可以使用`historyBack()`或`historyForward()`方法，在应用内沿着用户的历史记录进行导航。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Neither of these methods will do anything unless the user has begun clicking
    on hyperlinks and performing actual navigation within the `StageWebView` instance.
    We have basically just created our own little web browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除非用户开始点击超链接并在`StageWebView`实例中实际进行导航，否则这两种方法不会执行任何操作。我们基本上是创建了一个小型的网络浏览器。
- en: Using StageWebView to load ads using ActionScript
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 StageWebView 通过 ActionScript 加载广告
- en: One of the most sought after features of mobile Android development using the
    Flash platform has been the ability to include advertisements from services such
    as Google AdSense or AdMob within applications. This allows developers to distribute
    their applications for no charge to users, but still receive revenue from advertisements
    displayed within the application itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flash 平台进行移动 Android 开发时，最受追捧的功能之一是在应用中包含来自如 Google AdSense 或 AdMob 等服务的广告。这使得开发者可以免费向用户分发应用程序，但仍然可以从应用内显示的广告中获得收入。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`StageWebView` opens up a lot of possibilities for mobile application development,
    one of which is the ability to load HTML-based advertisements in running applications.
    In the following example, we will examine how simple it is to manage this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageWebView` 为移动应用开发开辟了众多可能性，其中之一就是能够在运行中的应用程序中加载基于 HTML 的广告。在以下示例中，我们将看看如何轻松管理这一点：'
- en: 'First, import the following classes into your project:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will now declare a `StageWebView` instance along with a `Rectangle` to define
    our viewport. Lastly, set up a `Timer`, which will serve as a mechanism to refresh
    our ads.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个 `StageWebView` 实例以及一个 `Rectangle` 来定义我们的视口。最后，设置一个 `Timer`，作为刷新我们广告的机制。
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` to appear within our application.
    It is good practice to check whether `StageWebView` is supported by invoking `StageWebView.isSupported`
    before constructing our `StageWebView` instance.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来构建我们的 `StageWebView` 对象，通过定义一个新的 `Rectangle` 来确定 `StageWebView` 在应用中的位置和大小。在构建
    `StageWebView` 实例之前，最好先调用 `StageWebView.isSupported` 来检查是否支持 `StageWebView`。
- en: To actually create a `StageWebView` object, we do a simple instantiation and
    assign the application `stage` to `StageWebView.stage`. Now assign the previously
    constructed `Rectangle` to the `StageWebViewviewport` property, and alternatively
    load up a web page using `loadURL()`, passing in the page address as a `String:`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，要创建一个 `StageWebView` 对象，我们只需进行简单的实例化并将应用程序的 `stage` 赋值给 `StageWebView.stage`。现在，将之前构建的
    `Rectangle` 赋值给 `StageWebView` 的 `viewport` 属性，或者使用 `loadURL()` 加载一个网页，传入页面地址作为
    `String`：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we have not done so already, in order for this to function correctly, we
    must set up a web page on our server to interface with the ad service we have
    chosen. In this example, we are using AdMob ([http://www.admob.com/](http://www.admob.com/))
    because the ads are tuned for and directed at mobile web and mobile device applications.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还没有这样做，为了使其正确运行，我们必须在服务器上设置一个网页，以便与我们选择的广告服务进行接口交互。在这个例子中，我们使用 AdMob ([http://www.admob.com/](http://www.admob.com/))，因为广告针对的是移动网络和移动设备应用。
- en: One important thing here is to be sure and set the `bodymargin` and `padding`
    to `0` through CSS to avoid any space around our ad. `StageWebView` is essentially
    just running HTML, so if we don't modify things slightly, the default HTML rendering
    engine (in the case of Android, this is web Kit) will simply interpret all stylistic
    elements through its default settings.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个重要的事情，就是确保通过 CSS 将 `bodymargin` 和 `padding` 设置为 `0`，以避免广告周围出现任何空间。`StageWebView`
    本质上只是运行 HTML，因此如果我们不稍作修改，默认的 HTML 渲染引擎（在 Android 中，这是 web Kit）将简单地通过其默认设置解释所有风格元素。
- en: 'You will want to replace the `pubid` attribute with your own, or register with
    a different ad service. Use this snippet as a reference to create your own HTML
    file to store upon a server and invoke through your particular application as
    we have done in this example:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将 `pubid` 属性替换成你自己的，或者注册一个不同的广告服务。使用这个代码片段作为参考，创建你自己的 HTML 文件，并将其存储在服务器上，然后通过你的特定应用程序调用，正如这个例子中所做的那样：
- en: '[PRE23]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next step is to set up our `Timer` to switch out ads every 10 seconds. We
    do this by instantiating a new `Timer` object, and passing 10000 milliseconds
    (or your preferred amount of time). Now, register an event listener of type `TimerEvent.Timer`
    to fire off a method of our construction every time the `Timer` hits 10 seconds.
    To start the `Timer`, we invoke `Timer.start():`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置我们的 `Timer`，以每10秒更换一次广告。我们通过实例化一个新的 `Timer` 对象并传递10000毫秒（或者你选择的时间量）来实现这一点。现在，注册一个类型为
    `TimerEvent.Timer` 的事件监听器，以便每次 `Timer` 达到10秒时触发我们构建的方法。要启动 `Timer`，我们调用 `Timer.start()`：
- en: '[PRE24]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All that remains is to create our `onTimer` method to reload the `StageWebView`
    instance every time the `Timer` hits 10 seconds. This will make a new call to
    the web, pulling the HTML down again, thus invoking the ad serving script anew.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是创建我们的`onTimer`方法，以便每次`Timer`达到10秒时重新加载`StageWebView`实例。这将再次调用网络，下拉HTML，从而重新调用广告服务脚本。
- en: '[PRE25]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The page will refresh every time our `Timer` is fired, revealing a new advertisement
    in our application:![How to do it...](img/1420_07_07.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们的`Timer`触发时，页面都会刷新，揭示我们应用程序中的新广告：![如何操作...](img/1420_07_07.jpg)
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `StageWebView` class will use whichever web control is default on the host
    operating system to render any HTML that is displayed in the view port. It is
    important to note that `StageWebView` is not part of the traditional Flash `DisplayList`
    and cannot be added to our application in the normal way visual elements are added
    to the `DisplayList` (through `addChild())`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageWebView`类将使用主机操作系统上的默认Web控件来渲染视口中显示的任何HTML。需要注意的是，`StageWebView`不是传统Flash
    `DisplayList`的一部分，不能像将视觉元素添加到`DisplayList`（通过`addChild()`）那样以常规方式添加到我们的应用程序中。'
- en: To actually render advertisements within the application, we can initially load
    up a web page using `loadURL()`, passing in the page address as a `String`. This
    address should point to an HTML document that interfaces with an ad service of
    our choosing, for which we have previously registered for. Normally, these services
    simple provide you with a chunk of JavaScript to place into your HTML, which will
    invoke ads for you upon page load. To refresh our view port and load up a new
    add, we can simply invoke `StageWebView.reload()`. In the case of our example,
    we employ a `Timer` to perform this action every 10 seconds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序中实际渲染广告，我们可以首先使用`loadURL()`加载一个网页，传入页面地址作为`String`。该地址应指向与我们所选择的广告服务接口的HTML文档，我们之前已经注册过。通常，这些服务会提供一个JavaScript代码块，让你放入你的HTML中，它会在页面加载时调用广告。要刷新我们的视口并加载新的广告，我们可以简单地调用`StageWebView.reload()`。在我们的示例中，我们使用`Timer`每10秒执行此操作。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: While we decided to use AdMob for this example, a developer can generally include
    any ad system they prefer. In the following screenshot, I am ingesting ads from
    Google AdSense in the very same way. You will notice though, that with the normal
    version of AdSense (when not using mobile content units), the ads do not conform
    to the screen in an intelligent way. AdMob is tailored for mobile, so works much
    better in these situations. In the future, there should be plenty of new opportunities
    in this space beyond the two ad providers mentioned here. We must also keep in
    mind that these are third-party services, and may change at any time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们决定在本例中使用AdMob，但开发者通常可以包括他们喜欢的任何广告系统。在以下屏幕截图中，我以完全相同的方式从Google AdSense获取广告。但您会注意到，使用正常版本的AdSense（不使用移动内容单元）时，广告不会以智能方式适应屏幕。AdMob专为移动设备设计，因此在这些情况下效果更好。将来，除了这里提到的两个广告提供商之外，应该还有许多新的机会。我们还必须记住，这些都是第三方服务，可能会随时更改。
- en: '![There''s more...](img/1420_07_08.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/1420_07_08.jpg)'
- en: Using StageWebView to load ads within a Flex mobile project
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flex移动项目中使用StageWebView加载广告
- en: As `StageWebView` instances are not part of the `DisplayList`, we could have
    a perceived problem when it comes to using it within a `ViewNavigatorApplication`.
    The main problem being that the `StageWebView` will always remain an overlay above
    all other objects, and that it will not be able to transition along with other
    items within a particular view. In this recipe, we will examine this and demonstrate
    some techniques for coping with the inordinate behaviour of the `StageWebView`
    object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`StageWebView`实例不是`DisplayList`的一部分，在`ViewNavigatorApplication`中使用它可能会出现感知上的问题。主要问题是`StageWebView`总是位于所有其他对象的顶层，并且无法与特定视图中的其他项目一起过渡。在本教程中，我们将研究这个问题，并展示一些应对`StageWebView`对象不规则行为的技术。
- en: Getting ready…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: For this example, we'll be using Google AdSense **Mobile content | Ad units**.
    You will need to sign up for an AdSense account at [https://www.google.com/adsense/](http://https://www.google.com/adsense/)
    and configure a **Mobile content Ad unit:**
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用Google AdSense的**移动内容 | 广告单元**。您需要访问[https://www.google.com/adsense/](http://https://www.google.com/adsense/)注册AdSense账户，并配置一个**移动内容广告单元**：
- en: '![Getting ready…](img/1420_07_09.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作...](img/1420_07_09.jpg)'
- en: If you already have an AdMob account (or some other service), you can always
    use that instead, or even a simple ad of your own creation for this demonstration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了AdMob账户（或其他服务），你可以选择使用它，或者甚至为本演示创建一个简单的广告。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will create a new `ViewNavigatorApplication` with two distinct views, demonstrating
    how the `StageWebView` exists outside of this structure, how to remove the `StageWebView`
    from view, and provide reference to an additional ad serving system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`ViewNavigatorApplication`，其中包含两个不同的视图，演示`StageWebView`如何存在于这个结构之外，如何从视图中移除`StageWebView`，并提供对额外广告服务系统的引用。
- en: There will be a number of files involved in this example; we will approach their
    assembly using different sections for clarity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将涉及多个文件；我们将通过不同的部分来组装它们，以便更清晰。
- en: Creating the HTML file to display our ads
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建HTML文件以展示我们的广告
- en: 'If we have not done so already, in order for this to function correctly, we
    must set up a web page on our server to interface with Google AdSense. You will
    want to replace the `client` attribute from the following example with your own.
    Use this snippet as a reference to create your own HTML file to store upon a server
    and invoke through your particular application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有这样做，为了使其正确工作，我们必须在服务器上设置一个网页以与Google AdSense进行接口。你可能希望将以下示例中的`client`属性替换为你自己的。使用这段代码作为参考，在服务器上创建你自己的HTML文件，并通过你的特定应用程序调用：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating the MXML files for our ViewNavigatorApplication
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的ViewNavigatorApplication创建MXML文件
- en: 'First, we create our main application file with a root node of `ViewNavigatorApplication`
    in order to take advantage of the view-based layout it provides. We can set the
    `applicationDPI`, if need be, and employ the `firstView` attribute to reference
    the initial `View`. We will define this `View` a bit later on in the recipe. Before
    moving on, let''s register a method called `init()` to fire once our application
    completes:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建主应用程序文件，其根节点为`ViewNavigatorApplication`，以便利用它提供的基于视图的布局。如有需要，我们可以设置`applicationDPI`，并使用`firstView`属性引用初始`View`。我们将在本例稍后定义这个`View`。在继续之前，让我们注册一个名为`init()`的方法，以便在应用程序完成后执行：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Create a script block to hold all of the ActionScript for our application. The
    code for doing so will be defined in another step for clarity.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个脚本块以保存我们应用程序的所有ActionScript代码。进行此操作的代码将在另一个步骤中定义，以便更清晰。
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we will add some functionality to our `ActionBar` by adding two `Button`
    controls to the `navigationContent` node. Each of these `Button` controls will
    invoke the `ViewNavigator.pushView()` method. This method accepts a `View` reference
    as an argument, and when invoked, will bring that `View` to the top of our view
    stack:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`ActionBar`中添加一些功能，具体来说是在`navigationContent`节点中添加两个`Button`控件。这两个`Button`控件将调用`ViewNavigator.pushView()`方法。这个方法接受一个`View`引用作为参数，当调用时，会将该`View`置于我们的视图栈顶部：
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we will assemble our two views for this example. Place a `Button` control
    in each `View` along with a `click` event handler, which will invoke a method
    in our main application file to toggle the ads on and off:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为本例组装两个视图。在每个`View`中放置一个`Button`控件以及一个`click`事件处理程序，该处理程序将调用主应用程序文件中的方法以切换广告的显示和隐藏：
- en: FlexAdsHomeView.mxml
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FlexAdsHomeView.mxml
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: FlexAdsOtherView.mxml
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FlexAdsOtherView.mxml
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Generating the ActionScript code to tie it all together
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成ActionScript代码以连接所有内容
- en: 'This code will exist within our main application file `script` block, which
    we had previously defined:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将存在于我们之前定义的主应用程序文件的`script`块中：
- en: 'First, import the following classes into the project:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到项目中：
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will now declare a `StageWebView` instance along with a `Rectangle` to define
    our view port. Lastly, set up a `Timer`, which will serve as a mechanism to refresh
    our ads:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`StageWebView`实例以及一个`Rectangle`以定义我们的视口。最后，设置一个`Timer`，它将作为刷新我们广告的机制：
- en: '[PRE33]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Set up the initialization function referred to earlier, which will simply invoke
    the methods we will construct to set up the `StageWebView` instance and our ad
    refresh `Timer:`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置前面提到的初始化函数，它将简单地调用我们将要构建的方法来设置`StageWebView`实例和我们的广告刷新`Timer`：
- en: '[PRE34]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create a method to construct our `StageWebView` object by defining a new `Rectangle`
    with the position and size we want the `StageWebView` to appear within our application.
    It is good practice to check whether `StageWebView` is supported by invoking `StageWebView.isSupported`
    before constructing our `StageWebView` instance.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来构建我们的`StageWebView`对象，通过定义一个新的`Rectangle`，设置我们希望`StageWebView`在应用程序中显示的位置和大小。在构建`StageWebView`实例之前，最好通过调用`StageWebView.isSupported`来检查是否支持`StageWebView`。
- en: To actually create a `StageWebView` object, we do a simple instantiation and
    assign the application `stage` to `StageWebView.stage`. Now assign the previously
    constructed `Rectangle` to the `StageWebViewviewport` property, and alternatively
    load up a web page using `loadURL()`, passing in the page address as a `String:`
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上要创建一个`StageWebView`对象，我们只需简单地实例化并将其分配给应用程序的`stage`到`StageWebView.stage`。现在，将之前构建的`Rectangle`赋值给`StageWebView`的`viewport`属性，然后使用`loadURL()`加载一个网页，传入页面地址作为`String`：
- en: '[PRE35]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To toggle the ads on and off from within the individual views, we simply check
    whether the `StageWebView.viewPort` is `null` or not and based upon this result,
    either set it to a `Rectangle` object or assign upon it a value of `null`. If
    the `viewPort` is `null`, the ad will no longer be visible to the user:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从各个视图中切换广告的显示与隐藏，我们只需检查`StageWebView.viewPort`是否为`null`，根据这个结果，要么将其设置为一个`Rectangle`对象，要么赋值为`null`。如果`viewPort`为`null`，广告将不再对用户可见：
- en: '[PRE36]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The next step is to set up our `Timer` to switch out ads every 8 seconds. We
    do this by instantiating a new `Timer` object, passing in 8000 milliseconds (or
    your preferred amount of time). Now, register an event listener of type `TimerEvent.Timer`
    to fire off a method of our construction every time the `Timer` hits 8 seconds.
    To start the `Timer`, we invoke `Timer.start():`
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置我们的`Timer`，以每8秒更换一次广告。我们通过实例化一个新的`Timer`对象，传入8000毫秒（或您选择的时间量）来实现这一点。现在，注册一个类型为`TimerEvent.Timer`的事件监听器，以便每次`Timer`达到8秒时触发我们构建的方法。要启动`Timer`，我们调用`Timer.start()`：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All that remains is to create our `onTimer` method to reload the `StageWebView`
    instance every time the `Timer` hits 10 seconds. This will make a new call to
    the web, pulling the HTML down again, thus invoking the ad serving script anew:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是创建我们的`onTimer`方法，以便每次`Timer`达到10秒时重新加载`StageWebView`实例。这将再次调用网络，拉取HTML，从而重新调用广告服务脚本：
- en: '[PRE38]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When the application is run, an ad will immediately be displayed within the
    `StageWebView` instance and our initial `View` is made present to the user. At
    this point, the user can interact with the `ActionBar` and switch between each
    `View`. The `StageWebView` instance will remain in place even though the `View`
    contents shift as the application `ViewNavigator` shuffles views. At any point,
    the user can toggle the ads off or on through the `Button` instances in either
    `View:`![Generating the ActionScript code to tie it all together](img/1420_07_10.jpg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行应用程序时，广告将立即在`StageWebView`实例中显示，并且我们的初始`View`将呈现给用户。此时，用户可以与`ActionBar`交互，并在每个`View`之间切换。即使`View`内容随着应用程序`ViewNavigator`的切换而变化，`StageWebView`实例仍将保持原位。在任何时候，用户都可以通过任一`View`中的`Button`实例切换广告的显示与隐藏：![生成将所有内容联系在一起的
    ActionScript 代码](img/1420_07_10.jpg)
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Using `StageWebView` within a `ViewNavigatorApplication` may seem troublesome
    at first, if we keep in mind some of the limitations of this particular object,
    and manage the `StageWebView` in a mindful way, it isn't that difficult to produce
    a workable implementation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewNavigatorApplication`中使用`StageWebView`一开始可能会觉得有些麻烦，如果我们记住这个特定对象的限制，并以一种经过深思熟虑的方式管理`StageWebView`，那么创建一个可行的实现并不那么困难。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: If ever we want to completely remove a `StageWebView` object from our application,
    we can invoke `StageWebView.dispose(),which` will remove the `StageWebView` object
    and allow it to be processed by the garbage collector. Even if we remove a `StageWebView`
    instance in this way, we can always create a new one, if necessary.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想完全从应用程序中移除一个`StageWebView`对象，我们可以调用`StageWebView.dispose()`，这将移除`StageWebView`对象，使其能被垃圾收集器处理。即使我们以这种方式移除`StageWebView`实例，如果需要，我们仍然可以创建一个新的实例。
- en: Making a phone call from an application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序中拨打电话
- en: With all the great features and sheer power of the Android operating system,
    it is easy to forget that these devices are primarily telephones. In this recipe,
    we will demonstrate how to invoke the native Android telephone utility from within
    an application, passing along a phone number to dial.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android操作系统具有众多出色的功能和强大的实力，很容易让人忘记这些设备首先是电话。在本教程中，我们将展示如何从应用内部调用本地Android电话工具，并传递一个要拨打的电话号码。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Having the application invoke `navigateToURL` and passing in a new `URLRequest`
    with the correct URI of `tel:` will open the default telephone application along
    with the specified phone number loaded up and ready to be dialed. In this example,
    we will perform this action once a `TOUCH_TAP` event is detected:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序调用`navigateToURL`并传入带有正确`tel:` URI的新`URLRequest`，将打开默认的电话应用，并加载指定的电话号码，准备拨号。在这个例子中，我们将在检测到`TOUCH_TAP`事件时执行此操作：
- en: 'First, import the following classes into your project:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`Sprite`作为我们的交互元素，以及一个`TextField`和`TextFormat`对，作为按钮标签：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续设置我们的`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个具有简单背景填充的`Sprite`。我们按钮构建的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`中。这里，我们创建一个方法来为我们执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as the following screenshot:![How to do it...](img/1420_07_01.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用，交互式`Sprite`应该会如以下截图所示：![如何操作...](img/1420_07_01.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`设置为通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用一个名为`onTouchTap`的方法，其中包含我们剩余的逻辑：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` containing the `tel:` URI prefix followed by the
    phone number we want to dial from our application:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当检测到一次触摸点击时，我们的`onTouchTap`方法将被触发，调用`navigateToURL`并传入一个包含`tel:` URI前缀以及我们应用中想要拨打的电话号码的`URLRequest`：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we run the application upon our device, a simple touch tap on our button
    will invoke the native telephone application along with our specified phone number
    already entered:![How to do it...](img/1420_07_12.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上运行应用时，只需在按钮上简单触摸点击，就会调用本地电话应用，并显示我们指定的电话号码：![如何操作...](img/1420_07_12.jpg)
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android telephone utility.
    Along with this invocation is supplied a phone number, which was assigned to this
    call by passing a `URLRequest` with a `tel:` URI prefix through the `navigateToURL`
    method. In this way, we can easily allow users of our application access to a
    phone number without their even having to dial it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用用户触摸点击我们创建的交互式`Sprite`时，他们会从我们的应用中跳转出来，进入默认的Android电话工具。这次调用还会提供一个电话号码，这是通过`navigateToURL`方法传递带有`tel:`
    URI前缀的`URLRequest`来指定此通话的。
- en: Sending a text message from an application
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用中发送短信
- en: With Flash on Android, we have the ability to invoke the native Android SMS
    utility through classes in the `flash.net` package based upon user interaction.
    We do not have the ability to supply any content for the text message, unfortunately.
    On Android, since all applications take up a full window, we must be extra mindful
    of any disruption this may cause while the user is interacting with our application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上使用Flash，我们有能力通过`flash.net`包中的类根据用户交互调用原生的Android短信工具。不幸的是，我们无法为短信提供任何内容。在Android上，由于所有应用程序都占用一个完整的窗口，因此我们必须特别留意这可能会在用户与我们的应用程序交互时造成任何干扰。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Having the application invoke `navigateToURL` and passing in a new `URLRequest`
    with the correct URI prefix of `sms:` will open the default SMS utility along
    with the specified phone number loaded up, ready to text. In this example, we
    will perform this action once a `TOUCH_TAP` event is detected:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序调用`navigateToURL`并传入带有正确`sms:` URI前缀的新`URLRequest`将打开默认的短信工具，并加载指定的电话号码，准备好发短信。在这个例子中，我们将在检测到`TOUCH_TAP`事件时执行此操作：
- en: 'First, import the following classes into your project:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`Sprite`作为我们的交互元素，以及一个`TextField`和`TextFormat`对作为按钮标签：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个带有简单背景填充的`Sprite`。我们按钮构建的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`中。在这里，我们创建了一个方法来执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as follows:![How to do it...](img/1420_07_13.jpg)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用程序，交互式`Sprite`应该如下所示：![如何操作...](img/1420_07_13.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`设置为通过常量`MultitouchInputMode.TOUCH_POINT`响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用名为`onTouchTap`的方法，其中包含我们的其余逻辑：
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` containing the `tel:` URI prefix followed by the
    phone number we want to dial from our application:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦检测到触摸点击，我们的`onTouchTap`方法将被触发，调用`navigateToURL`，并传入一个包含`tel:` URI前缀以及我们想要从应用程序中拨打的电话号码的`URLRequest`：
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At this point, we will lose application focus and be presented with the Android
    SMS utility, prepopulated with our desired phone number and ready to compose a
    text message:![How to do it...](img/1420_07_14.jpg)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，我们将失去应用程序焦点，并显示Android短信工具，预先填充了我们想要的电话号码，并准备好撰写短信：![如何操作...](img/1420_07_14.jpg)
- en: Finally, once we hit **Send**, our text message is transmitted to the targeted
    recipient specified through the phone number used. In this example, it is not
    a real phone number, of course:![How to do it...](img/1420_07_15.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们点击**发送**，我们的短信将通过使用的电话号码发送给指定的收件人。在这个例子中，当然这不是一个真实的电话号码：![如何操作...](img/1420_07_15.jpg)
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android SMS utility.
    Along with this invocation is supplied a phone number, which was assigned to this
    text message by passing a `URLRequest` with a `sms:` URI prefix through the `navigateToURL`
    method. In this way, we can easily allow users of our application access to a
    phone number for texting without their even having to input a numeric sequence.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序用户触摸点击我们创建的交互式`Sprite`时，他们会从我们的应用程序中退出，进入默认的Android短信工具。这次调用还提供了一个电话号码，这是通过`navigateToURL`方法传递带有`sms:`
    URI前缀的`URLRequest`分配给这条短信的。这样，我们就可以轻松地让应用程序用户访问电话号码发短信，而无需他们输入数字序列。
- en: Invoking Google maps from an application
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序中调用谷歌地图
- en: Being that most Android devices are mobile, the ability to tap into some sort
    of mapping is expected by both developers and users. The Android OS is managed
    by Google, and the company has a long history of great mapping technologies on
    the web. This is great for developers because we can piggyback on the very cool
    Maps application on Android and pass in all sorts of coordinates from our application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数安卓设备都是移动设备，开发者和用户都期望能够使用某种类型的地图。安卓操作系统由谷歌管理，该公司在网页上拥有悠久的优秀地图技术历史。这对于开发者来说非常棒，因为我们可以在安卓上的非常酷的地图应用程序上搭便车，并从我们的应用程序中传入各种坐标。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Have the application detect the device geolocation coordinates, invoke `navigateToURL,`
    and pass in a new `URLRequest` with a correctly formatted URL to access the Android
    maps application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让应用程序检测设备的地理坐标，调用`navigateToURL`，并传入一个格式正确的URL的`URLRequest`以访问安卓地图应用程序：
- en: 'First, import the following classes into your project:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到你的项目中：
- en: '[PRE49]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label. We will be employing the `Geolocation`
    API, and so declare an object for this purpose along with `Number` variables to
    hold latitude and longitude data values:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`Sprite`作为我们的交互元素，以及一个`TextField`和`TextFormat`对作为按钮标签。我们将使用`Geolocation`
    API，因此为此目的声明一个对象，以及用于保存纬度和经度数据值的`Number`变量：
- en: '[PRE50]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us, along with some stylistic enhancements:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续设置我们的`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个带有简单背景填充的`Sprite`。构建按钮的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`中。在这里，我们创建一个方法来执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE51]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as in the following screenshot:![How to do it...](img/1420_07_16.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用程序，交互式`Sprite`应该会如以下截图所示显示：![如何操作...](img/1420_07_16.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`设置为通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用一个名为`onTouchTap`的方法，其中包含我们剩余的逻辑：
- en: '[PRE52]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Upon the detection of a touch tap event, we will set up a `Geolocation` object
    and assign an event listener to it, listening specifically for a `GeolocationEvent.UPDATE`
    event. We will no longer need to listen for our `TouchEvent.TOUCH_TAP` event,
    so may remove it to allow for garbage collection:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测到触摸点击事件时，我们将设置一个`Geolocation`对象，并为它分配一个事件监听器，专门监听`GeolocationEvent.UPDATE`事件。我们将不再需要监听`TouchEvent.TOUCH_TAP`事件，因此可以移除它以允许垃圾回收：
- en: '[PRE53]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once `Geolocation` data is gathered and reported back to our application, the
    `onGeoEvent` method will fire, providing us with the `longitude` and `latitude`
    data we need to pass in to the native Android maps application.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦收集到`Geolocation`数据并将其报告回我们的应用程序，`onGeoEvent`方法将会触发，为我们提供需要传入到原生安卓地图应用程序的`longitude`和`latitude`数据。
- en: 'To complete our sequence, we will invoke `navigateToURL` and pass in a `URLRequest`
    containing the `http://maps.google.com/` URL followed by a query string containing
    the `latitude` and `longitude` values from our `Geolocation` update event data.
    Since we now have all the data we need, remove the `GeolocationEvent.UPDATE` event
    listener:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的流程，我们将调用`navigateToURL`，并传入一个包含`http://maps.google.com/` URL的`URLRequest`，后面跟着一个查询字符串，其中包含来自我们的`Geolocation`更新事件数据的`latitude`和`longitude`值。既然我们现在有了所需的所有数据，可以移除`GeolocationEvent.UPDATE`事件监听器：
- en: '[PRE54]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As the URI prefix used in this example is simply `http://`, a model dialog will
    appear over our application, asking whether we would like to open the `URLRequest`
    using the **Browser** or **Maps** application. We will choose **Maps**. Selecting
    the **Use by default for this action** checkbox will prevent this dialog from
    appearing in the future:![How to do it...](img/1420_07_17.jpg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此示例中使用的 URI 前缀仅为 `http://`，因此一个模型对话框将出现在我们的应用程序上方，询问我们是否希望使用 **浏览器** 或 **地图**
    应用程序打开 `URLRequest`。我们将选择 **地图**。勾选 **默认使用此操作** 复选框将防止将来出现此对话框：![如何操作...](img/1420_07_17.jpg)
- en: Finally, the **Maps** application will appear and present the user with a view
    based upon the detected latitude and longitude Geolocation coordinates that our
    application was able to detect:![How to do it...](img/1420_07_18.jpg)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，**地图** 应用程序将出现，并根据我们应用程序能够检测到的纬度和经度 Geolocation 坐标向用户展示视图：![如何操作...](img/1420_07_18.jpg)
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    we configure a `Geolocation` object to listen for location data. Once this data
    is acquired, we can then pass a `URLRequest` with the `http://` URI prefix through
    the `navigateToURL` method to summon `maps.google.com`. We also append a query
    string formed from the collected `Geolocation` latitude and longitude data, informing
    the **Maps** application the exact coordinates to navigate to on our map.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用程序的用户触摸点击我们创建的交互式 `Sprite` 时，我们会配置一个 `Geolocation` 对象来监听位置数据。一旦获取到这些数据，我们就可以通过
    `navigateToURL` 方法传递带有 `http://` URI 前缀的 `URLRequest` 来召唤 `maps.google.com`。我们还添加了一个由收集的
    `Geolocation` 纬度和经度数据形成的查询字符串，告诉 **地图** 应用程序在我们的地图上导航的确切坐标。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An alternative to detecting `Geolocation` data from device sensors would be
    to store a variety of coordinates within the application and then present the
    user with a number of choices. This would be useful for a specialized restaurant
    application, allowing users to easily view locations on a map, for instance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代从设备传感器检测 `Geolocation` 数据的方法是在应用程序中存储各种坐标，然后向用户提供多个选择。这对于一个专门的餐厅应用程序很有用，例如，允许用户轻松在地图上查看位置。
- en: Invoking the Android Market using application URIs
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序 URI 调用 Android Market
- en: The Android Market is unique to the Android platform and there is a dedicated
    application which allows users to easily search for, find, and install applications
    on their devices. Android allows a developer to tap into the Market application
    by passing in certain search terms.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Android Market 是 Android 平台独有的，有一个专门的应用程序，允许用户轻松搜索、查找并安装设备上的应用程序。Android 允许开发者通过传递特定的搜索词来利用
    Market 应用程序。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will build a small application to invoke `navigateToURL` and pass a predefined
    search term through a `URLRequest` object with the `market:` URI prefix. This
    will open the Android Market application and have it perform a search for us.
    In this example, we will open a new request once a `TOUCH_TAP` event is detected:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个小应用程序来调用 `navigateToURL` 函数，并通过带有 `market:` URI 前缀的 `URLRequest` 对象传递一个预定义的搜索词。这将打开
    Android Market 应用程序，并让它为我们执行搜索。在这个例子中，一旦检测到 `TOUCH_TAP` 事件，我们将打开一个新的请求：
- en: 'First, import the following classes into your project:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE55]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个 `Sprite` 作为我们的交互元素，以及一个 `TextField` 和 `TextFormat` 对，作为按钮标签：
- en: '[PRE56]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续设置我们的 `TextField`，应用一个 `TextFormat` 对象，并使用图形 API 构造一个具有简单背景填充的 `Sprite`。按钮构建的最后一步是将
    `TextField` 添加到我们的 `Sprite` 中，然后将 `Sprite` 添加到 `DisplayList` 中。这里，我们创建了一个方法来执行所有这些操作，并进行一些样式增强：
- en: '[PRE57]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as shown in the following screenshot:![How to do it...](img/1420_07_19.jpg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用程序，交互式 `Sprite` 应该如以下屏幕截图所示出现：![如何操作...](img/1420_07_19.jpg)
- en: We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将`Multitouch.inputMode`设置为通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用名为`onTouchTap`的方法，该方法包含我们的其余逻辑。
- en: '[PRE58]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in a `URLRequest` with a URI prefix of `market:` containing the search
    terms we want to have the application perform against the Market inventory:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦检测到触摸点击，我们的`onTouchTap`方法将被触发，调用`navigateToURL`并传入带有`market:` URI前缀的`URLRequest`，其中包含我们希望应用程序针对市场库存执行的搜索词：
- en: '[PRE59]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When we run the application upon our device, a simple touch tap upon our button
    will invoke the Android Market application and perform a search for the terms
    that we've passed over from our application:![How to do it...](img/1420_07_20.jpg)
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上运行应用程序时，只需点击按钮，就会调用安卓市场应用程序，并针对我们传递的搜索词进行搜索：![如何操作...](img/1420_07_20.jpg)
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the Android Market application,
    where a search is instantly performed against the search terms specified in our
    request. The Android Market application will reveal to the user whatever applications
    it finds in the current inventory. For instance, passing in the exact title of
    our application will allow a user to manually check for updates from within the
    application. Passing in our company or developer name will bring up all of the
    applications we have made available for the user to browse.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序用户触摸点击我们所创建的交互式`Sprite`时，他们会从我们的应用程序中被带到安卓市场应用程序中，在那里会立即针对我们请求中指定的搜索词进行搜索。安卓市场应用程序会向用户展示当前库存中找到的所有应用程序。例如，传入我们应用程序的确切标题，将允许用户在应用程序内手动检查更新。传入我们的公司或开发者名称，则会显示我们提供给用户浏览的所有应用程序。
- en: If further specificity is required, there are additional search queries that
    can be performed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更具体的信息，还可以执行其他搜索查询。
- en: 'To search for a specific application, we can use the format:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定的应用程序，我们可以使用以下格式：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To search for a specific publisher, we use the following (notice we are escaping
    quotes by using the "\" character in our query string):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定的发布者，我们使用以下格式（注意我们在查询字符串中使用反斜杠"\"字符来转义引号）：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Sending e-mail from an application
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序发送电子邮件
- en: Similar to desktop Flash and AIR applications, the default system e-mail client
    can be invoked through classes in the `flash.net` package based upon some user
    interaction. On Android, since all applications take up a full window, we must
    be extra mindful of any disruption this may cause while the user is interacting
    with our application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于桌面Flash和AIR应用程序，基于用户交互，可以通过`flash.net`包中的类调用默认的系统电子邮件客户端。在Android上，由于所有应用程序都占用整个窗口，我们必须特别留意这可能会在用户与我们的应用程序交互时造成干扰。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Having the application invoke `navigateToURL` and passing an e-mail address
    through a new `URLRequest` with the `mailto:` URI prefix will open the default
    e-mail utility. In this example, we will open a new e-mail once a `TOUCH_TAP`
    event is detected:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序调用`navigateToURL`并通过带有`mailto:` URI前缀的新`URLRequest`传递电子邮件地址时，将打开默认的电子邮件工具。在这个例子中，一旦检测到`TOUCH_TAP`事件，我们就会打开一封新的电子邮件：
- en: 'First, import the following classes into your project:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下类导入到您的项目中：
- en: '[PRE62]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will now declare a `Sprite` as our interactive element, along with a `TextField`
    and `TextFormat` pair to serve as a button label:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将声明一个`Sprite`作为我们的交互元素，以及一个`TextField`和`TextFormat`对，作为按钮标签：
- en: '[PRE63]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we will continue to set up our `TextField`, apply a `TextFormat` object,
    and construct a `Sprite` with a simple background fill using the graphics API.
    The final step in the construction of our button is to add the `TextField` to
    our `Sprite` and then add the `Sprite` to the `DisplayList`. Here, we create a
    method to perform all of these actions for us along with some stylistic enhancements:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续设置我们的`TextField`，应用一个`TextFormat`对象，并使用图形API构建一个具有简单背景填充的`Sprite`。我们按钮构建的最后一步是将`TextField`添加到我们的`Sprite`中，然后将`Sprite`添加到`DisplayList`。在这里，我们创建了一个方法来执行所有这些操作，并进行一些风格上的增强：
- en: '[PRE64]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If we now run the application upon our device, the interactive `Sprite` should
    appear as follows:![How to do it...](img/1420_07_21.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在设备上运行应用程序，交互式`Sprite`应该如下所示：![如何操作...](img/1420_07_21.jpg)
- en: 'We will now assign the `Multitouch.inputMode` to respond to raw touch events
    through the `MultitouchInputMode.TOUCH_POINT` constant. Register an event listener
    of type `TouchEvent.TOUCH_TAP` upon the `Sprite` button. This will detect any
    touch tap events initiated by the user and invoke a method called `onTouchTap`,
    which contains the remainder of our logic:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将`Multitouch.inputMode`分配给通过`MultitouchInputMode.TOUCH_POINT`常量响应原始触摸事件。在`Sprite`按钮上注册一个类型为`TouchEvent.TOUCH_TAP`的事件监听器。这将检测用户发起的任何触摸点击事件，并调用一个名为`onTouchTap`的方法，其中包含我们的其余逻辑：
- en: '[PRE65]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Once a touch tap is detected, our `onTouchTap` method will fire, invoking `navigateToURL`
    and passing in aURLRequest with a URI prefix of `mailto:` containing the e-mail
    address we want to open up from our application, along with a subject parameter,
    if desired:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦检测到触摸点击，我们的`onTouchTap`方法将被触发，调用`navigateToURL`并传递带有`mailto:` URI前缀的`URLRequest`，其中包含我们想要从应用程序中打开的电子邮件地址，如果需要，还可以包含一个主题参数：
- en: '[PRE66]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When we run the application on our device, a simple touch tap upon our button
    will invoke the native e-mail client and populate it with the values that we've
    passed over from our application.![How to do it...](img/1420_07_22.jpg)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设备上运行应用程序时，只需简单地在按钮上触摸点击，就会调用本地电子邮件客户端，并用我们从应用程序传递的值填充它。![如何操作...](img/1420_07_22.jpg)
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a user of our application touch taps the interactive `Sprite` we've created,
    they are taken out of our application and into the default Android e-mail client.
    This is accomplished by passing the desired e-mail address through a `URLRequest`
    with a URI prefix of `mailto:` along with a set of appended parameters through
    the `navigateToURL` method, which is very similar to the way we accomplish the
    same thing with a desktop or web application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序用户触摸点击我们所创建的交互式`Sprite`时，他们会从我们的应用程序中被带出到默认的安卓电子邮件客户端。这是通过使用带有`mailto:`
    URI前缀的`URLRequest`传递所需的电子邮件地址，并通过`navigateToURL`方法附加一系列参数来实现的，这与我们在桌面或网络应用程序中实现相同功能的方式非常相似。
- en: There's more...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of course, we could always write an application that handles e-mail internally,
    just as we would on a web application. So long as we have access to a server with
    e-mail capability; this may be preferred for some applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们完全可以在内部处理电子邮件的应用程序中编写代码，就像在网页应用程序上一样。只要我们能够访问具有电子邮件功能的服务器，这对于某些应用程序来说可能是首选。
