["```kt\nprivate Bitmap backgroundBitmap; \n```", "```kt\npublic CircularActivityIndicator(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n\n    backgroundBitmap = BitmapFactory.decodeResource(getResources(),\n    R.mipmap.ic_launcher); \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    if (backgroundBitmap != null) { \n        canvas.drawBitmap(backgroundBitmap, 0, 0, null); \n    } \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    // apply a rotation of the bitmap based on the selectedAngle \n    if (backgroundBitmap != null) { \n        canvas.save(); \n        canvas.rotate(selectedAngle, backgroundBitmap.getWidth() / 2,\n        backgroundBitmap.getHeight() / 2); \n        canvas.drawBitmap(backgroundBitmap, 0, 0, null); \n        canvas.restore(); \n    } \n```", "```kt\nprivate Bitmap backgroundBitmap; \nprivate Rect bitmapSource; \nprivate Rect bitmapDest; \n```", "```kt\npublic CircularActivityIndicator(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n\n    backgroundBitmap = BitmapFactory.decodeResource(getResources(),\n    R.mipmap.ic_launcher); \n    bitmapSource = new Rect(); \n\n    bitmapSource.top = 0; \n    bitmapSource.left = 0; \n    if(backgroundBitmap != null) { \n        bitmapSource.left = backgroundBitmap.getWidth() / 2; \n        bitmapSource.right = backgroundBitmap.getWidth(); \n        bitmapSource.botto \n        m = backgroundBitmap.getHeight(); \n    } \n    bitmapDest = new Rect(); \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    if (backgroundBitmap != null) { \n        bitmapDest.right = getWidth(); \n        bitmapDest.bottom = getHeight(); \n\n        canvas.drawBitmap(backgroundBitmap, bitmapSource, bitmapDest,\n        null); \n    } \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    if (backgroundBitmap != null) { \n        if ((bitmapSource.width() > bitmapSource.height() && getHeight() >\n        getWidth()) || \n            (bitmapSource.width() <= bitmapSource.height() && getWidth() >=\n            getHeight())) { \n\n            double ratio = ((double) getHeight()) / ((double)\n            bitmapSource.height()); \n            int scaledWidth = (int) (bitmapSource.width() * ratio); \n            bitmapDest.top = 0; \n            bitmapDest.bottom = getHeight(); \n            bitmapDest.left = (getWidth() - scaledWidth) / 2; \n            bitmapDest.right = bitmapDest.left + scaledWidth; \n        } else { \n            double ratio = ((double) getWidth()) / ((double)\n            bitmapSource.width()); \n            int scaledHeight = (int) (bitmapSource.height() * ratio); \n            bitmapDest.left = 0; \n            bitmapDest.right = getWidth(); \n            bitmapDest.top = 0; \n            bitmapDest.bottom = scaledHeight; \n        } \n\n        canvas.drawBitmap(backgroundBitmap, bitmapSource, bitmapDest,\n        null); \n    } \n```", "```kt\nprivate Matrix matrix; \n```", "```kt\nmatrix = new Matrix(); \nmatrix.postScale(0.2f, 0.2f); \nmatrix.postTranslate(0, 200); \n```", "```kt\ncanvas.drawBitmap(backgroundBitmap, matrix, null); \n```", "```kt\nindicatorBorderPaint = new Paint(); \nindicatorBorderPaint.setAntiAlias(false); \nindicatorBorderPaint.setColor(BLACK_COLOR); \nindicatorBorderPaint.setStyle(Paint.Style.STROKE); \nindicatorBorderPaint.setStrokeWidth(BORDER_SIZE); \nindicatorBorderPaint.setStrokeCap(Paint.Cap.BUTT); \n```", "```kt\nprivate static final Paint.Cap[] caps = new Paint.Cap[] { \n        Paint.Cap.BUTT, \n        Paint.Cap.ROUND, \n        Paint.Cap.SQUARE \n}; \n```", "```kt\nint xPos = (getWidth() - 100) / 2; \nint yPos = getHeight() / 2 - BORDER_SIZE * CAPS.length / 2; \nfor(int i = 0; i < CAPS.length; i++) { \n    indicatorBorderPaint.setStrokeCap(CAPS[i]); \n    canvas.drawLine(xPos, yPos, xPos + 100, yPos,\n    indicatorBorderPaint); \n    yPos += BORDER_SIZE * 2; \n} \nindicatorBorderPaint.setStrokeCap(Paint.Cap.BUTT); \n```", "```kt\ncanvas.drawArc( \n       horMargin + BORDER_SIZE / 4, \n       verMargin + BORDER_SIZE / 4, \n       horMargin + circleSize - BORDER_SIZE /2, \n       verMargin + circleSize - BORDER_SIZE /2, \n       0, selectedAngle, true, indicatorBorderPaint); \n```", "```kt\ncanvas.drawArc( \n       clipX - BORDER_SIZE / 4, \n       clipY - BORDER_SIZE / 4, \n       clipX + clipWidth + BORDER_SIZE / 2, \n       clipY + clipWidth + BORDER_SIZE / 2, \n       0, selectedAngle, true, indicatorBorderPaint); \n```", "```kt\nprivate Paint paint; \nprivate ArrayList<Float> rects; \nprivate ArrayList<Integer> colors; \n```", "```kt\npublic PrimitiveDrawer(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n\n    rects = new ArrayList<>(); \n    colors = new ArrayList<>(); \n\n    paint = new Paint(); \n    paint.setStyle(Paint.Style.FILL); \n    paint.setAntiAlias(true); \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    canvas.drawColor(BACKGROUND_COLOR); \n\n    int width = getWidth(); \n    int height = getHeight(); \n\n    for (int i = 0; i < 2; i++) { \n        rects.add((float) Math.random() * width); \n        rects.add((float) Math.random() * height); \n    } \n    colors.add(0xff000000 | (int) (0xffffff * Math.random())); \n\n    for (int i = 0; i < rects.size() / 4; i++) { \n        paint.setColor(colors.get(i)); \n        canvas.drawRoundRect( \n                rects.get(i * 4    ), \n                rects.get(i * 4 + 1), \n                rects.get(i * 4 + 2), \n                rects.get(i * 4 + 3), \n                40, 40, paint); \n    } \n\n    if (rects.size() < 400) postInvalidateDelayed(20); \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    canvas.drawColor(BACKGROUND_COLOR); \n\n    if (points == null) { \n        points = new float[POINTS * 2]; \n        for(int i = 0; i < POINTS; i++) { \n            points[i * 2    ] = (float) Math.random() * getWidth(); \n            points[i * 2 + 1] = (float) Math.random() * getHeight(); \n        } \n    } \n\n    paint.setColor(0xffa0a0a0); \n    paint.setStrokeWidth(4.f); \n    paint.setStrokeCap(Paint.Cap.BUTT); \n    canvas.drawLines(points, paint); \n\n    paint.setColor(0xffffffff); \n    paint.setStrokeWidth(10.f); \n    paint.setStrokeCap(Paint.Cap.ROUND); \n    canvas.drawPoints(points, paint); \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    canvas.drawColor(BACKGROUND_COLOR); \n\n    if (points == null) { \n        points = new float[POINTS * 3]; \n        for(int i = 0; i < POINTS; i++) { \n            points[i * 3    ] = (float) Math.random() * getWidth(); \n            points[i * 3 + 1] = (float) Math.random() * getHeight(); \n            points[i * 3 + 2] = (float) Math.random() * (getWidth()/4); \n        } \n    } \n\n    for (int i = 0; i < points.length / 3; i++) { \n        canvas.drawCircle( \n                points[i * 3    ], \n                points[i * 3 + 1], \n                points[i * 3 + 2], \n                paint); \n    } \n} \n```", "```kt\npaint = new Paint(); \npaint.setStyle(Paint.Style.FILL); \npaint.setAntiAlias(true); \npaint.setColor(0xffffffff); \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    if (path == null) { \n        float[] points = new float[POINTS * 3]; \n        for(int i = 0; i < POINTS; i++) { \n            points[i * 3    ] = (float) Math.random() * getWidth(); \n            points[i * 3 + 1] = (float) Math.random() * getHeight(); \n            points[i * 3 + 2] = (float) Math.random() * (getWidth()/4); \n        } \n\n        path = new Path(); \n\n        for (int i = 0; i < points.length / 3; i++) { \n            path.addCircle( \n                    points[i * 3    ], \n                    points[i * 3 + 1], \n                    points[i * 3 + 2], \n                    Path.Direction.CW); \n        } \n\n        path.close(); \n    } \n```", "```kt\n    canvas.save(); \n\n    if (!touching) canvas.clipPath(path); \n    if(background != null) { \n        backgroundTranformation.reset(); \n        float scale = ((float) getWidth()) / background.getWidth(); \n        backgroundTranformation.postScale(scale, scale); \n        canvas.drawBitmap(background, backgroundTranformation, null); \n    } \n    canvas.restore(); \n} \n```", "```kt\npathPaint = new Paint(); \npathPaint.setStyle(Paint.Style.STROKE); \npathPaint.setAntiAlias(true); \npathPaint.setColor(0xffffffff); \npathPaint.setStrokeWidth(5.f); \n\npointsPaint = new Paint(); \npointsPaint.setStyle(Paint.Style.STROKE); \npointsPaint.setAntiAlias(true); \npointsPaint.setColor(0xffff0000); \npointsPaint.setStrokeCap(Paint.Cap.ROUND); \npointsPaint.setStrokeWidth(40.f); \n```", "```kt\npoints = new ArrayList<>(); \npath = new Path(); \n```", "```kt\n@Override \npublic boolean onTouchEvent(MotionEvent event) { \n    if (event.getAction() == MotionEvent.ACTION_DOWN) { \n        points.add(event.getX()); \n        points.add(event.getY()); \n\n        invalidate(); \n    } \n\n    return super.onTouchEvent(event); \n} \n```", "```kt\nwhile(points.size() - currentIndex >= 6) { \n    float x1 = points.get(currentIndex); \n    float y1 = points.get(currentIndex + 1); \n\n    float x2 = points.get(currentIndex + 2); \n    float y2 = points.get(currentIndex + 3); \n\n    float x3 = points.get(currentIndex + 4); \n    float y3 = points.get(currentIndex + 5); \n\n    if (currentIndex == 0) path.moveTo(x1, y1); \n    path.cubicTo(x1, y1, x2, y2, x3, y3); \n    currentIndex += 6; \n} \n```", "```kt\ncanvas.drawColor(BACKGROUND_COLOR); \ncanvas.drawPath(path, pathPaint); \n\nfor (int i = 0; i < points.size() / 2; i++) { \n    float x = points.get(i * 2    ); \n    float y = points.get(i * 2 + 1); \n    canvas.drawPoint(x, y, pointsPaint); \n} \n```", "```kt\npathPaint.setTextSize(50.f); \npathPaint.setTextAlign(Paint.Align.CENTER); \n```", "```kt\ncanvas.drawTextOnPath(\"Building Android UIs with Custom Views\", path, 0, 0, pathPaint); \n```", "```kt\nprivate static final float[] getTextSize(String str, Paint paint) { \n    float[] out = new float[2]; \n    Rect boundaries = new Rect(); \n    paint.getTextBounds(str, 0, str.length(), boundaries); \n\n    out[0] = paint.measureText(str); \n    out[1] = boundaries.height(); \n    return out; \n} \n```", "```kt\n@Override \nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) { \n    super.onLayout(changed, left, top, right, bottom); \n\n    // create a layout of half the width of the View \n    if (layout == null) { \n        layout = new StaticLayout( \n                LONG_TEXT, \n                0, \n                LONG_TEXT.length(), \n                paint, \n                (right - left) / 2, \n                Layout.Alignment.ALIGN_NORMAL, \n                1.f, \n                1.f, \n                true); \n    } \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    canvas.drawColor(BACKGROUND_COLOR); \n\n    canvas.save(); \n    // center the layout on the View \n    canvas.translate(canvas.getWidth()/4, 0); \n    layout.draw(canvas); \n    canvas.restore(); \n} \n```", "```kt\npublic PrimitiveDrawer(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n\n    paint = new Paint(); \n    paint.setStyle(Paint.Style.STROKE); \n    paint.setAntiAlias(true); \n    paint.setColor(0xffffffff); \n} \n```", "```kt\n@Override \n protected void onLayout(boolean changed, int left, int top, int right,\n int bottom) { \n     super.onLayout(changed, left, top, right, bottom); \n\n     int smallerDimension = (right - left); \n     if (bottom - top < smallerDimension) smallerDimension = bottom -\n     top; \n\n     rectSize = smallerDimension / 10; \n     timeStart = System.currentTimeMillis(); \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    float angle = (System.currentTimeMillis() - timeStart) / 100.f; \n\n    canvas.drawColor(BACKGROUND_COLOR); \n\n    canvas.save(); \n    canvas.translate(canvas.getWidth() / 2, canvas.getHeight() / 2); \n\n    for (int i = 0; i < 15; i++) { \n        canvas.rotate(angle); \n        canvas.drawRect(-rectSize / 2, -rectSize / 2, rectSize / 2,\n        rectSize / 2, paint); \n        canvas.scale(1.2f, 1.2f); \n    } \n\n    canvas.restore(); \n    invalidate(); \n} \n```", "```kt\npublic final void scale(float sx, float sy, float px, float py) { \n    translate(px, py); \n    scale(sx, sy);\n    translate(-px, -py); \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    float angle = (System.currentTimeMillis() - timeStart) / 100.f; \n\n    canvas.drawColor(BACKGROUND_COLOR); \n\n    canvas.save(); \n    canvas.translate(canvas.getWidth() / 2, \n                     canvas.getHeight() / 2); \n\n    for (int i = 0; i < 15; i++) { \n        canvas.rotate(angle, rectSize / 2, rectSize / 2); \n        canvas.drawRect(0, 0, rectSize, rectSize, paint); \n        canvas.scale(1.2f, 1.2f, rectSize / 2, rectSize / 2); \n    } \n\n    canvas.restore(); \n    invalidate(); \n} \n```"]