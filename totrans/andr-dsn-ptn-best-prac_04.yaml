- en: Chapter 4. Layout Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have looked at the most important patterns used
    for creating objects and at some of the most used material components. To bring
    these together, we need to consider the overall layouts an application might need.
    This allows us to plan our app in greater detail as well as introducing the interesting
    challenge of designing an app for different-sized screens and orientations. Android
    makes developing for a variety of screen sizes and shapes very simple and intuitive,
    and with a minimum of extra coding. We will then conclude by exploring and creating
    a strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use relative and linear layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply gravity and weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale weights with weightSum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the percent support library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop layouts for specific screen sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android platform provides a variety of layout classes. These range from
    the very simple **frame layout** to the quite complex layouts provided by the
    support library. By far the most widely used and most versatile are the linear
    and relative layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Linear layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing between a relative layout and a linear one is normally very simple.
    If your components line up from side to side on top of each other, then a **linear
    layout** is the obvious choice. Although it is quite possible to nest view groups,
    for more complex layouts, the relative version is often the best choice. This
    is largely because nesting layouts is resource hungry and deep hierarchies should
    be avoided where possible. The **relative layout** can be used to create a huge
    number of intricate layouts with very little need for nesting.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever form best suits our needs, once we begin testing our layouts on screens
    of different shapes, or even rotate a screen through 90°, we soon see that all
    the thought that we put into creating components with pleasing proportions is
    lost. Very often, these issues can be remedied by positioning elements using **gravity**
    properties and scaling them with the **weight** property.
  prefs: []
  type: TYPE_NORMAL
- en: Weight and gravity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to set position and proportion without having to worry overly about
    exact screen shape can save us a lot of work. By setting the weight property of
    components and widgets, we can determine the relative amount of screen width or
    height an individual component takes up. This is particularly useful when we want
    most of our widgets set with `wrap_content`, so that they grow as the user needs,
    but also want one view to take up as much space as is available.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the image in the following layout will shrink appropriately as
    the text above it grows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Weight and gravity](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The image view is the only view to have weight applied, the other views all
    have their `height` declared with `wrap_content`. As seen here, we have to set
    the `layout_height` to `0dp` here to avoid any internal conflicts when setting
    the view''s height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Weight can not only be applied to individual widgets and views, but to view
    groups and nested layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically filling screen space that is liable to change is very useful,
    but weight can be applied to more than one view to create layouts where views
    each consume a specified relative area of an activity. For example, the following
    images were scaled with weights of `1`, `2`, `3`, and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Weight and gravity](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although nesting layouts within each other is something to generally avoid,
    it is often worth considering one or two levels as this can produce some very
    workable activities. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weight and gravity](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This layout uses only two nested view groups and the use of weight can keep
    the structure very workable across quite a wide range of form factors. Of course,
    this layout would look terrible in portrait, but we see how this issue is countered
    later in the chapter. The XML to generate such a layout would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The example above begs an interesting question. What if we do not want to fill
    the entire width or height of our layout? What if we want some space left? This
    is easily managed with the **weightSum** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how weightSum works, add the following highlighted property to the inner
    linear layout definition in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting a maximum weight for the layout, the inner weights will be set in
    proportion to this. In this example, a `weightSum` of `10` sets the inner weights,
    which are `3` and `2`, to 3/10 and 2/10 of the layout height, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |   |'
  prefs: []
  type: TYPE_TB
- en: '|  | ![Weight and gravity](img/image_04_004.jpg) |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that both the weight and `weightSum` are floating point properties, and
    a greater level of accuracy can be achieved with lines such as this: `android:weightSum="20.5"`.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of weight is an extremely useful way to make the most of unknown screen
    sizes and shapes. Another technique for managing overall screen space is to use
    gravity to position components and their contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **gravity** property is used to justify views and/or their contents. In
    the example given previously, the following markup was used to position the action
    at the bottom of the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates how `layout_gravity` is used to justify a view (or
    view group) within its container. The contents of a single view can also be positioned
    within that view with the `gravity` property, which can be set with something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Ordering our layouts into rows and columns is perhaps the simplest way to consider
    screen layouts, but it is not the only one. The **relative layout** provides an
    alternative technique that is based on position rather than proportion. The relative
    layout also allows us to proportion its content by using the **percent support
    library**.
  prefs: []
  type: TYPE_NORMAL
- en: Relative layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the biggest advantage of the relative layout is the way it can be
    used to reduce the number of nested view groups when building complex layouts.
    This works by defining views'' positions in accordance to how they are positioned
    and aligned to each other with properties such as `layout_below` and `layout_toEndOf`.
    To see how this is done, consider the linear layout of the previous example. We
    can recreate this as a relative layout with no nested viewgroups, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Despite the obvious advantage that this approach requires no nested view groups,
    we have to set the individual view's dimensions explicitly, and as soon as we
    preview the output on different screens, these proportions are soon lost or, at
    the very least, distorted.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this issue could be to create separate `dimens.xml` files for
    different screen configurations, but if we want something that fills a precise
    percentage of the screen, then we will never be able to guarantee this across
    every possible device. Fortunately, Android provides a very useful support library.
  prefs: []
  type: TYPE_NORMAL
- en: The percent support library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to define exact proportions for a given component could be something
    of a problem in a relative layout, as we can only really describe where things
    are rather than their prominence within the group. Fortunately, the percent library
    provides **PercentRelativeLayout** to counter this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other support libraries, the percent library must be included in the
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the same layout as previously, we would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The percent library provides an intuitive and simple way to create proportions
    that are not easily distorted by being displayed on an untested form factor. These
    models work very well when tested on other devices with the same orientation.
    However, once we rotate these layouts through 90°, we can see the problem. Fortunately,
    the Android SDK allows us to reuse our layout patterns to create alternative versions
    with the minimum of re-coding. As we might expect, this is achieved by creating
    designated layout configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Screen rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most, if not all, mobile devices allow for screen reorientation. Many apps,
    such as video players, are better suited to one orientation than another. Generally
    speaking, we want our apps to look their best, however rotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most layouts look terrible when translated from portrait to landscape or vice
    versa. Clearly, we need to create alternatives for these situations. Fortunately,
    we do not have to start from scratch. The best way to see how this is done is
    to start with a standard portrait layout like the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen rotation](img/image_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be recreated with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, once this is rotated, it looks very poorly designed. To create an acceptable
    landscape version, view your layout in design mode and click on the configuration
    icon in the top-left corner of the design panel and select **Create Landscape
    Variation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen rotation](img/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This produces a copy of our file in a folder that will be referred to for its
    layout definitions whenever the app finds itself in landscape mode. This directory
    lies alongside the `res/layout` folder and is called `res/layout-land`. It is
    simply a matter now of rearranging our views to suit this new format, and we can,
    in fact, use the layout from earlier in the chapter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Screen rotation](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It only takes a few seconds to apply these changes and create a landscape layout,
    but there is more we can do here. In particular, we can create layouts designed
    specifically for larger screens and tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Large screen layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were creating a landscape version of our layout from the configuration
    menu, you will no doubt have noticed the **Create layout-xlarge** **Version**
    option, and, as you would imagine, this is used to create layouts suitable for
    the larger screens of tablets and even TVs.
  prefs: []
  type: TYPE_NORMAL
- en: If you select this option, you will immediately see that our judicious use of
    the percent library has produced an identical layout, and it is tempting to feel
    that this layout is unnecessary, but this would be to miss the point. Devices
    such as a 10'' tablet provide a lot more space and rather than just enlarge our
    layout, we should use this opportunity to provide more content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will just add an extra frame for the xlarge version. This
    is easily done by adding the following XML and adjusting the height percentage
    value of some of the other views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Large screen layouts](img/image_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As well as making the most of larger screens, we can also achieve the opposite
    for small screens with the `small` qualifier. This is useful to optimize layouts
    for small screens by making elements smaller or even removing less important content.
  prefs: []
  type: TYPE_NORMAL
- en: Qualifiers like those we have seen here are very useful but they are still quite
    broad. Depending on device resolution, we could very easily find the same layout
    being applied to a large phone and a small tablet. Fortunately, the framework
    provides a way for us to be more precise when defining our layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Width qualifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As developers, we spend a lot of time and energy sourcing and creating great
    imagery and other media. It is important that we do this work justice and ensure
    it is displayed at its best. Imagine that you have a layout that deserves to be
    at least 720 pixels across, to be best appreciated. In such a case, there are
    two things we can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can ensure that our app is only available on devices that have,
    at least, our desired screen resolution, and this can be done by editing the `AndroidManifest`
    file, by adding the following tag within the `manifest` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Usually it would be a shame to make our app unavailable to users of small screens
    and the times we might do this are rare. Apps designed for large TV screens or
    for precise photo editing might be the exception. More often we would rather create
    layouts to suit as many screen sizes as possible and that leads us to our second
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android platform allows us to design layouts for specific screen sizes
    according to criteria such as **minimum and available width** in pixels. By *minimum*,
    we mean the narrowest of the two screen dimensions, regardless of orientation.
    For most devices, this would mean width when viewed in portrait mode and height
    in landscape mode. The use of *available* width provides another level of flexibility,
    in that the width is measured according to how a screen is orientated, allowing
    us to design some very specific layouts. Optimizing layouts according to the smallest
    width is very simple and is done with qualifiers as before. So a file named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: will replace
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: on devices with a shortest side of 720 dp or greater.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can create a folder for any size we choose, for example `res/layout-sw600dp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is great for designing layouts for large screens regardless
    of orientation. However, it could be very useful to design a layout that would
    be applied according to the apparent width based on how a device is oriented at
    any given moment. This is achieved in a similar manner, by designating directories.
    To design for available width, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And to optimize for available height, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These qualifiers provide very useful techniques for ensuring our designs make
    the most of available hardware, but there is a slight drawback if we want to develop
    for devices running Android 3.1 or lower. On these devices, the minimum and available
    width qualifiers are not available and we have to use `large` and `xlarge` qualifiers.
    This can lead to two identical layouts, wasting space and adding to our maintenance
    costs. Thankfully there is a way around this, in the form of layout aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Layout aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how layout aliases work we will imagine a simple case where
    we have just two layouts, our default `activity_main.xml` file which will have
    just two views and a second layout that we will call `activity_main_large.xml`
    which will have three views to take advantage of larger screens. To see how this
    is done, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `activity_main` file and provide it with these two views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy this file, call it `activity_main_large` and add the following view to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create two **New | Android resource directories** called `res/values-large`
    and `res/values-sw720dp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `values-large` folder, create a file called `layout.xml` and complete
    it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, create an identical file in the `values-sw720dp` folder:![Layout aliases](img/image_04_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using layout aliases in this way means we only have to create one large layout
    and it will be applied to larger screens regardless of which Android platform
    a device is running.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we chose `720dp` as our threshold. In most cases this would
    target 10'' tablets and larger. If we wanted our large layout to run on most 7''
    tablets and large phones, we would use `600dp`, and we can of course select any
    value that suits our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some, very rare, occasions where we might want to restrict an app
    to only landscape or portrait. This can be achieved by adding `android:screenOrientation="portrait"`
    or `android:screenOrientation="landscape"`to the activity tag in the manifest
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, we should create landscape and portrait layouts for phones,
    7'' tablets and 10'' tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Designing appealing and intuitive layouts is among the most important tasks
    we face as developers, and the shortcuts introduced here greatly reduce the amount
    of work we have to do, freeing us up to concentrate on designing attractive applications.
  prefs: []
  type: TYPE_NORMAL
- en: As with the last chapter, we have concentrated on the more practical issue of
    layout structure, and this is of course prerequisite to further development. However,
    there are a lot of patterns for us to familiarize ourselves with and the sooner
    we become familiar with them the better and the more likely that we will identify
    structures that would benefit from having a pattern applied. Once such pattern
    that could be applied in situations like those explored in this chapter is the
    strategy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The strategy pattern is another widely used and incredibly useful. Its beauty
    lies in its versatility as it can be applied in numerous situations. Its purpose
    is to provide a selection of solutions (strategies) to a given problem at runtime.
    A good example would be an app with a strategy to run different code depending
    whether the app was being installed on Windows, Mac OS, or Linux. Were the system
    of designation we used above to design UIs for different devices so efficient,
    we could easily use a strategy pattern to carry out this task. It would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The strategy pattern](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For now, we will step ahead a little and imagine a situation where the users
    of our sandwich maker app are ready to pay. We will assume three methods: credit
    card, cash, and a coupon. Those paying cash will simply pay the set price. A little
    unfairly, those paying by card will be charged a small fee and those with a coupon
    will get 10% off. We will also use a singleton to represent the basic price before
    these strategies are applied. Follow these steps to set up a strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start, as is often the case, with an interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create concrete implementations of this interface, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the singleton class that is going to provide our basic price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is all that we need to do to create the pattern. A singleton was used
    because the price of the current sandwich is something that needs to only have
    a single instance and be reached from anywhere in the code. Before we build a
    UI and test our pattern, let''s take a quick look at the strategy class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The strategy pattern](img/image_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see from the diagram that the activity contains an `onClick()` callback.
    Before we can see how this works, we need to create a layout with three action
    buttons to test each of our three payment options. Follow these steps to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a layout file with a horizontal linear layout at its root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following view and inner layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add buttons to the relative layout. The first two look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third is the same as the second, with the following exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open the Java activity file extend it so that it implements this listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next add the following field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include these lines on the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally add the `onClick()` method, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now test our output on a device or emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The strategy pattern](img/image_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The strategy pattern can be applied to many situations and as you develop almost
    any software, you will come across situations where it can be applied time and
    again. We will certainly return to it here. Hopefully, introducing it now will
    help you spot situations where it can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to get the most out of Android layouts. This
    has involved deciding which layout type to use for which purpose, and although
    there are many others, the linear and relative layouts offer the functionality
    and flexibility for very many possible layouts. Once a layout has been selected,
    we can then organize the space with weight and gravity properties. The process
    of designing layouts for a variety of possible screen sizes was greatly helped
    by employing the percent library and PercentRelativeLayout.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest challenge a developer faces when designing Android layouts for an
    enormous number of real world devices our apps might find themselves running on.
    Fortunately, the use of resource designation makes light work of this.
  prefs: []
  type: TYPE_NORMAL
- en: With a working layout in place, we can move on to look at how we can now use
    this space to display some useful information. This will take us on to look at
    how lists and their data are managed by the recycler view, which we shall do in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
