- en: Chapter 5. Exploring Fragments, AppWidgets, and the System UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a Fragment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing Fragments during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data between Fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a shortcut on the Home screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Home screen widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Search to the Action Bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing your app full screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a firm understanding of layouts from [Chapter 2](ch02.html "Chapter 2. Layouts"),
    *Layouts*, we'll dig deeper into UI development with Fragments. Fragments are
    a way to separate your UI into smaller sections that can easily be reused. Think
    of Fragments as mini-activities, complete with their own classes, layouts, and
    lifecycle. Instead of designing your screen in one Activity Layout, possibly duplicating
    functionality across multiple layouts, you can break the screen into smaller,
    logical sections and turn them in to Fragments. Your Activity Layout can then
    reference one or multiple Fragments, as needed. The first three recipes will explore
    Fragments in-depth.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of Fragments, we're ready to expand on our discussion
    of Widgets. In [Chapter 3](ch03.html "Chapter 3. Views, Widgets, and Styles"),
    *Views, Widgets, and Styles*, we discussed how to add widgets to your own app.
    Now, we'll look at how to create an App Widget so users can put their app on their
    Home screen.
  prefs: []
  type: TYPE_NORMAL
- en: The last recipes of the chapter will explore System UI options. We have a recipe
    for adding a `Search` option to the Action Bar using the Android `SearchManager`
    API. The last recipe shows Full Screen mode and several additional variations
    of altering the System UI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a Fragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android didn't always support Fragments. The early versions of Android were
    designed for phones, when screens had relatively small displays. It wasn't until
    Android started being used on tablets that there was a need to split the screen
    into smaller sections. Android 3.0 introduced the `Fragments` class and the Fragment
    Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Along with a new class, also came the Fragment Lifecycle. The Fragment Lifecycle
    is similar to the Activity Lifecycle introduced in [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, as most events parallel the Activity Lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a brief overview of the main callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onAttach()`: It''s called when the Fragment is associated with an Activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreate()`: It''s called when the Fragment is first created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreateView()`: It''s called when the Fragment is about to be displayed for
    the first time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onActivityCreated()`: It''s called when the associated Activity is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStart()`: It''s called when the Fragment will become visible to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResume()`: It''s called just before a Fragment is displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPause()`: It''s called when the Fragment is first suspended. The user may
    return to the Fragment, but this is where you should persist any user data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStop()`: It''s called when the Fragment is no longer visible to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDestroyView()`: It''s called to allow final cleanup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDetach()`: It''s called when the Fragment is no longer associated with the
    Activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our first exercise, we will create a new Fragment derived from the standard
    `Fragment` class. But there are several other `Fragment` classes we could derive
    from, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DialogFragment`: It''s used for creating a floating dialog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListFragment`: It''s creates a `ListView` in a Fragment, similar to the `ListActivity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreferenceFragment`: It''s creates a list of Preference objects, commonly
    used for a Settings page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will walk through creating a basic Fragment derived from
    the `Fragment` class and include it in an Activity Layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `CreateFragment`. Use the
    default **Phone & Tablet** options and select the **Empty Activity** option when
    prompted for the Activity Type.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a new `Fragment` class with an accompanying
    layout file. We will then add the Fragment to the Activity Layout so it will be
    visible when the Activity starts. Here are the steps to create and display a new
    Fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new layout called `fragment_one.xml` using the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Java file called `FragmentOne` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `main_activity.xml` file and replace the existing `<TextView>` element
    with the following `<fragment>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating a new class, the same as we do for an Activity. In this
    recipe, we only create an overwrite for the `onCreateView()` method to load our
    Fragment layout. But, just like with the Activity events, we can override the
    other events as we need them. Once the new Fragment is created, we then add it
    to the Activity Layout. Since the `Activity` class was created before `Fragments`
    existed, they do not support `Fragments`. If we were using pure framework classes,
    we would want to use `FragmentActivity` instead. If you used the Android Studio
    New Project Wizard, then by default the `MainActivity` extends `AppCompatActivity`,
    which already includes support for Fragments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're only creating a single, simple Fragment in this recipe to teach the fundamentals
    of Fragments. But this is a good time to point out the power of Fragments. If
    we are creating multiple Fragments (and usually we are, as that's the point of
    using Fragments), when creating the Activity Layouts as we did in Step 4, we could
    create different layout configurations using the Android Resource Folders. The
    portrait layout may have only a single Fragment while the landscape may have two
    or more.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing Fragments during runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining a Fragment in the layout, as we did in the previous recipe, is known
    as a static Fragment and cannot be changed during runtime. Rather than using the
    `<fragment>` element, we will create a container to hold the Fragment, then create
    the Fragment dynamically in the Activity's `onCreate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FragmentManager` provides the APIs for adding, removing, and changing
    Fragments during runtime using a `FragmentTransaction`. A Fragment transaction
    consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing one or multiple actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing the transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe will demonstrate the `FragmentManager` by adding and removing Fragments
    during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `RuntimeFragments`. Use
    the default **Phone & Tablet** options and select the **Empty Activity** option
    when prompted for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate adding and removing Fragments, we first need to create the Fragments,
    which we will do be extending the `Fragment` class. After creating the new Fragments,
    we need to alter the layout for the Main Activity to include the `Fragment` container.
    From there, we just add the code to handle the Fragment transactions. Here are
    the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new layout file called `fragment_one.xml` and include the following
    XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second layout file called `fragment_two.xml` is almost identical, with
    the only difference being the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Java file called `FragmentOne` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import from the following library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the second Java file called `FragmentTwo` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import from the following library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to add a container and a button to the Main Activity layout. Change
    `main_activity.xml` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the Fragments created and the container added to the layout, we are now
    ready to write the code to manipulate the Fragments. Open `MainActivity.java`
    and add the following code below the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the existing `onCreate()` method, below `setContentView()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import from the following libraries:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last code we need to add handles the Fragment switching, called by the
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the steps for this recipe involve setting up the Fragments. Once the
    Fragments are declared, we create them in the `onCreate()` method. Though the
    code can be condensed to a single line, it's shown in the long form as it makes
    it easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the `FragmentManager` so we can begin a `FragmentTransaction`.
    Once we have a `FragmentTransaction`, we start the transaction with `beginTransaction()`.
    Multiple actions can occur within the transaction, but all we need here is to
    `add()` our initial Fragment. We call the `commit()` method to finalize the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the Fragment transaction, here is the succinct version
    for `onCreate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`switchFragment` does basically the same type of Fragment transaction. Instead
    of calling the `add()` method, we call the `replace()` method with the existing
    Fragment. We keep track of the current Fragment with the `showingFragment` variable
    so we know which Fragment to show next. We are not limited to switching between
    two Fragments either. If we needed additional Fragments, we just need to create
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Switching between activities* recipe from [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, we discussed the back stack. Most users would expect the back key
    to move backward through the "screens" and they don't know or care if those screens
    are activities or Fragments. Fortunately, Android makes it very easy to add Fragments
    to the back stack just by adding a call to `addToBackStack()` before calling `commit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Fragment is removed or replaced without adding it to the back stack,
    it is immediately destroyed. If it is added to the back stack, it is stopped and,
    if the user returns to the Fragment, it is restarted, instead of recreated.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data between Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the need arises to pass information between the Fragments. An email application
    serves as a classic example. It's common to have the list of emails in one Fragment,
    and show the email details in another Fragment (this is commonly referred to as
    a Master/Detail pattern). Fragments make creating this pattern easier because
    we only have to code each Fragment once, then we can include them in different
    layouts. We can easily have a single Fragment in a portrait layout with the ability
    to swap out the master Fragment with the detail Fragment when an email is selected.
    We can also create a two-panel layout where both the list and detail Fragments
    are side-by-side. Either way, when the user clicks the email in the list, the
    email opens up in the detail panel. This is when we need to communicate between
    two Fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Since one of the primary goals of Fragments is that they be completely self-contained,
    direct communication between Fragments is discouraged, and for good reason. If
    Fragments had to rely on other Fragments, your code would likely break when the
    layouts changed and only one Fragment was available. Fortunately, direct communication
    is not required for this scenario either. All Fragment communication should pass
    through the host Activity. The host activity is responsible for managing the Fragments
    and can properly route the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the question becomes: How do Fragments communicate with the activity? The
    answer is with an `interface`. You''re probably already familiar with an interface,
    as that''s how a view communicates an event back to an activity. A button click
    is a common example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will create two Fragments to demonstrate passing data from
    one Fragment to another via the host activity. We''ll also build on what we learned
    from the previous recipe by including two different Activity Layouts—one for portrait
    and one for landscape. When in portrait mode, the activity will swap the Fragments
    as needed. Here is a screenshot of when the application first runs in portrait
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing data between Fragments](img/B05057_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the screen showing the detail Fragment when you click on a country
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing data between Fragments](img/B05057_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When in landscape, both Fragments will be side-by-side, as shown in the landscape
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing data between Fragments](img/B05057_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the Master/Detail pattern generally involves a list for the master, we'll
    take advantage of the `ListFragment` (mentioned in the *Creating and using a Fragment*
    introduction.) When an item in the list is selected, the item text (country name
    in our example) will be sent to the detail Fragment via the host Activity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `Fragmentcommunication`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fully demonstrate working Fragments, we'll need to create two Fragments.
    The first Fragment will extend from the `ListFragment` so it will not need a layout.
    We're going to go one step further by creating both portrait and landscape layouts
    for our Activity. For portrait mode, we'll swap Fragments and for landscape mode,
    we'll show both Fragments side-by-side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When typing this code, Android Studio will offer two different library import
    options. Since the New Project Wizard automatically references the `AppCompat`
    library, we need to use the support library APIs instead of the framework APIs.
    Though very similar, the following code uses the support Fragment APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps, starting with the first Fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class called `MasterFragment` and change it so it extends
    `ListFragment` as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import from the following library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following `interface` inside the `MasterFragment` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the interface callback listener with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step for the `MasterFragment` is to create a `ListAdapter` to populate
    the `ListView`, which we do in the `onViewCreated()` method. We''ll use the `setOnItemClickListener()`
    to call our `OnMasterSelectedListener` interface when a country name is selected
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we need to create the `DetailFragment`, starting with the Layout. Create
    a new layout file called: `fragment_detail.xml` with the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Java class called `DetailFragment` extending from `Fragment` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import from the following library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following constant to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override `onCreateView()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code the `onViewCreated()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step for this Fragment is to update the TextView when we receive the
    selected country name. Add the following method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The existing `activity_main.xml` layout will handle the portrait mode layout.
    Remove the existing `<TextView>` and replace with the following `<FrameLayout>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new directory in the **res** folder for the landscape layout as: `res/layout-land`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not see the new res/layout-land directory, change from **Android**
    **view** to **Project** **view**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `activity_main.xml` layout in `res/layout-land` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final steps are to set up the `MainActivity` to handle the Fragments. Open
    the `MainActivity.java` file and add the following class variable to track single/dual
    pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, change `onCreate()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last code to add is the `sendCountryName()` method, which handles sending
    the country name to `DetailFragment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating the `MasterFragment`. In the Master/Detail pattern we are
    using, this usually represents a list, so we create a list by extending the `ListFragment`.
    The `ListFragment` is the Fragment equivalent of the `ListActivity`. Other than
    extending from a Fragment, it's basically the same.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the recipe introduction, we shouldn't attempt to communicate directly
    with other Fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a means to communicate the list item selection, we expose the interface:
    `OnMasterSelectedListener`. We call `onItemSelected()` every time an item is selected
    in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the work for passing data between Fragments is done in the host activity
    but, ultimately, the receiving Fragment needs a way to receive the data. `DetailFragment`
    supports this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the country name in the argument bundle, available at creation time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public method for the activity to call directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the activity creates the Fragment, it also creates a `bundle` to hold the
    data we want to send. Here we add the country name using `KEY_COUNTRY_NAME` defined
    in Step 7\. We retrieve this bundle with `getArguments()` in `onViewCreated()`.
    If the key is found in the bundle, it is extracted and displayed using the `showSelectedCountry()`
    method. This is the same method the activity will call directly if the Fragment
    is already visible (in the two-panel layout).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the work for this recipe is in the activity. We created two layouts:
    one for portrait and one for landscape. Android will choose the landscape layout
    using the `res/layout-land` directory created in *Step 12*. Both layouts use a
    `<FrameLayout>` placeholder, similar to the previous exercise. We manage the Fragments
    in both `onCreate()` and `sendCountryName()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `onCreate()`, we set the `dualPane` flag by checking whether the current
    layout includes the `frameLayout` view. If `frameLayout` is found (it won''t be
    null), then we have only a single panel because the `frameLayout` ID is only in
    the portrait layout. If frameLayout is not found, then we have two `<FrameLayout>`
    elements instead: one for the `MasterFragment` and another for the `DetailFragment`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in the `onCreate()` is to set up the `MasterFragment` listener
    by creating an anonymous callback, which passes the country name to `sendCountryName()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sendCountryName()` is where the data is actually passed to the `DetailFragment`.
    If we are in portrait (or single pane) mode, we need to create a `DetailFragment`
    and replace the existing `MasterFragment`. This is where we create the bundle
    with the country name and call `setArguments()`. Notice how we call `addToBackStack()`
    before committing the transaction? This allows the back key to bring the user
    back to the list (`MasterFragment`). If we are in landscape mode, the `DetailFragment`
    is already visible so we call the `showSelectedCountry()` public method directly.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `MasterFragment`, before sending the `onItemSelected()` event, we check
    to make sure the listener is not null with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Though it's the job of the activity to set up the callback to receive the events,
    we don't want this code to crash if there's no listener. An alternative approach
    would be to verify the activity extends our interface in the Fragment's `onAttach()`
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on ListViews, see *Using ListView, GridView and Adapters*
    in [Chapter 2](ch02.html "Chapter 2. Layouts"), *Layouts*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on resource directories, see *Selecting themes based on
    the Android version* in [Chapter 3](ch03.html "Chapter 3. Views, Widgets, and
    Styles"), *Views, Widgets, and Styles*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a shortcut on the Home screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe explains how to create a link or create a shortcut for your app
    on the user's Home screen. So as not to be too obtrusive, it's generally best
    to make this an option for the user to initiate, such as in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot showing our shortcut on the Home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a shortcut on the Home screen](img/B05057_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this is just a shortcut, but we will explore creating a Home
    screen (AppWidget) in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `HomescreenShortcut`. Use
    the default **Phone & Tablet** options and select the **Empty Activity** option
    when prompted for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to add the appropriate permission. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest` file and add the following permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open `activity_main.xml` and replace the existing TextView with the following
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to `ActivityMain.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator. Notice, each time you press the button,
    the app will make a shortcut on the Home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you set up the proper permission, this is a rather straightforward task.
    When the button is clicked, the code creates a new intent called: `shortcutIntent`.
    This is the intent that will be called when the icon is pressed on the Home screen.
    The next intent created, `installIntent`, is responsible for actually creating
    the shortcut.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you also wanted to remove the shortcut, you would need the following permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the INSTALL_SHORTCUT action, you would set the following action
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Home screen widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dig in to the code for creating an App Widget, let''s cover the basics.
    There are three required and one optional component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppWidgetProviderInfo` file: It''s an XML resource described later on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AppWidgetProvider` class: This is a Java class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The View layout file: It''s a standard layout XML file, with some restrictions
    listed later on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The App Widget configuration Activity (optional): This Activity launches when
    placing the widget to set configuration options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AppWidgetProvider` must also be declared in the `AndroidManifest` file.
    Since the `AppWidgetProvider` is a helper class based on the Broadcast Receiver,
    it is declared in the manifest with the `<receiver>` element. Here is an example
    manifest entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The meta-data points to the `AppWidgetProviderInfo` file, which is placed in
    the `res/xml` directory. Here is a sample `AppWidgetProviderInfo.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief overview of the available attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minWidth`: The default width when placed on the Home screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minHeight`: The default height when placed on the Home screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatePeriodMillis`: It''s part of `onUpdate()` polling interval (in milliseconds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialLayout`: The AppWidget layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previewImage` (optional): The image shown when browsing App Widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure` (optional): The activity to launch for configuration settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resizeMode` (optional): The flags indicate resizing options — `horizontal`,
    `vertical`, `none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minResizeWidth` (optional): The minimum width allowed when resizing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minResizeHeight` (optional): The minimum height allowed when resizing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`widgetCategory` (optional): Android 5+ only supports Home screen widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AppWidgetProvider` extends the `BroadcastReceiver` class, which is why
    `<receiver>` is used when declaring the `AppWidget` in the Manifest. As it''s
    `BroadcastReceiver`, the class still receives the OS broadcast events, but the
    helper class filters those events down to those applicable for an App Widget.
    The `AppWidgetProvider` class exposes the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onUpdate()`: It''s called when initially created and at the interval specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAppWidgetOptionsChanged()`: It''s called when initially created and any
    time the size changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDeleted()`: It''s called any time a widget is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onEnabled()`: It''s called the first time a widget is placed (is not called
    when adding a second and subsequent widgets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDisabled()`: It''s called when the last widget is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onReceive()`: It''s called on every event received, including the preceding
    event. Usually not overridden as the default implementation only sends the applicable
    events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last required component is the layout. Remote Views only support a subset
    of the available layouts. As an App Widget is a Remote View, only the following
    layouts are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FrameLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelativeLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the following widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnalogClock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chronometer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressBar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewFlipper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AdapterViewFlipper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the App Widget basics covered, it's now time to start coding. Our example
    will cover the basics so you can expand the functionality as needed. This recipe
    uses a View with a clock, which, when pressed, opens our activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot shows the widget in the widget list when adding to the Home
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Home screen widget](img/B05057_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The widget list appearance varies by launcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot showing the widget after it is added to the Home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Home screen widget](img/B05057_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `AppWidget`. Use the default
    **Phone & Tablet** options and select the **Empty Activity** option when prompted
    for the **Activity Type**.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start by creating the widget layout, which resides in the standard layout
    resource directory. Then we'll create the xml resource directory to store the
    `AppWidgetProviderInfo` file. We'll add a new Java class and extend `AppWidgetProvider`,
    which handles the `onUpdate()` call for the widget. With the receiver created,
    we can then add it to the Android Manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the detailed steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `res/layout` called `widget.xml` using the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new directory called `xml` in the resource directory. The final result
    will be: `res/xml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in `res/xml` called `appwidget_info,xml` using the following
    xml:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you cannot see the new xml directory, switch from **Android** view to **Project**
    view in the **Project** panel dropdown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new Java class called `HomescreenWidgetProvider` extending `AppWidgetProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `onUpdate()` method to the `HomescreenWidgetProvider` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `HomescreenWidgetProvider` to `AndroidManifest` using the following XML
    declaration within the `<application>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator. After first running the application,
    the widget will then be available to add to the Home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first step is to create the layout file for the widget. This is a standard
    layout resource with the restrictions based on the App Widget being a Remote View,
    as discussed in the recipe introduction. Though our example uses an Analog Clock
    widget, this is where you'd want to expand the functionality based on your application
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: The xml resource directory serves to store the `AppWidgetProviderInfo`, which
    defines the default widget settings. The configuration settings determine how
    the widget is displayed when initially browsing the available widgets. We use
    very basic settings for this recipe, but they can easily be expanded to include
    additional features such as a preview image to show a functioning widget and sizing
    options. The `updatePeriodMillis` attribute sets the update frequency. Since the
    update will wake up the device, it's a trade-off between having up-to-date data
    and battery life. (This is where the optional Settings Activity is useful to let
    the user decide.)
  prefs: []
  type: TYPE_NORMAL
- en: The `AppWidgetProvider` class is where we handle the `onUpdate()` event triggered
    by the `updatePeriodMillis` polling. Our example doesn't need any updating so
    we set the polling to zero. The update is still called when initially placing
    the widget. The `onUpdate()` is where we set the pending intent to open our app
    when the clock is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `onUpdate()` method is probably the most complicated aspect of AppWidgets,
    we'll explain this is some detail. First, it's worth noting that `onUpdate()`
    will occur only once each polling interval for all the widgets is created by this
    provider. (Widgets created after the first will be on the cycle of the first widget.)
    This explains the `for` loop, as we need it to iterate through all the existing
    widgets. This is where we create a pending intent to call our app when the clock
    is pressed. As discussed earlier, an AppWidget is a Remote View. Therefore, to
    get the layout, we call `RemoteViews()` with our fully qualified package name
    and the layout ID. Once we have the layout, we can attach the pending intent to
    the clock view using `setOnClickPendingIntent()`. We call the `AppWidgetManager`
    named `updateAppWidget()` to initiate the changes we made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to make all this work is to declare the widget in the Android
    Manifest. We identify the action we want to handle with the `<intent-filter>`.
    Most App Widgets will likely want to handle the Update event, as ours does. The
    other item to note in the declaration is this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This tells the system where to find our configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding an App Widget configuration Activity allows greater flexibility with
    your widget. Not only can you offer polling options, but you could offer different
    layouts, click behaviors, and so on. Users tend to really appreciate flexible
    App Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a configuration Activity requires a few additional steps. The Activity
    needs to be declared in the Manifest as usual, but needs to include the `APPWIDGET_CONFIGURE`
    action, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Activity also needs to be specified in the `AppWidgetProviderInfo` file
    using the configure attribute, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `configure` attribute requires the fully qualified package name as this
    Activity will be called from outside of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the `onUpdate()` method will not be called when using a configuration
    Activity. The configuration Activity is responsible for handling any initial setup,
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For App Widget Design Guidelines, visit Google''s page at: [http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Search to the Action Bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the Action Bar, Android 3.0 introduced the `SearchView` widget, which
    can be included as a menu item when creating a menu. This is now the recommended
    UI pattern to provide a consistent user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the initial appearance of the Search icon in
    the Action Bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Search to the Action Bar](img/B05057_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This screenshot shows how the Search option expands when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Search to the Action Bar](img/B05057_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to add a Search functionality to your application, this recipe will
    walk you through the steps to set up your User Interface and properly configure
    the Search Manager API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `SearchView`. Use the default
    **Phone & Tablet** options and select **Empty Activity** when prompted for the
    Activity Type.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up the Search UI pattern, we need to create the Search menu item and
    a resource called `searchable`. We''ll create a second activity to receive the
    search query. Then we''ll hook it all up in the `AndroidManifest` file. To get
    started, open the `strings.xml` file in `res/values` and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following string resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the menu directory: `res/menu`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new menu resource called `menu_options.xml` in `res/menu` using the
    following xml:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override `onCreateOptionsMenu()` to inflate the menu and set up the Search
    Manager as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new xml resource directory: `res/xml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in the `res/xml` called `searchable.xml` using the following
    xml:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Crate a new layout called `activity_search_result.xml` using this xml:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new Activity called `SearchResultActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following variable to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `onCreate()` to load our layout, set the TextView and check for
    the `QUERY` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to handle the search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the User Interface and code now complete, we just need to hook everything
    up correctly in the `AndroidManifest`. Here is the complete manifest including
    both activities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application on a device or emulator. Type in a search query and hit
    the **Search** button (or press enter). The `SearchResultActivity` will display
    showing the search query entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the New Project Wizard uses the `AppCompat` library, our example uses
    the support library API. Using the support library provides the greatest device
    compatibility as it allows the use of modern features (such as the Action Bar)
    on older versions of the Android OS. This can sometimes provide an extra challenge
    as often the official documentation focuses on the framework API. Though usually
    the support library closely follows the framework API, they are not always interchangeable.
    The Search UI pattern is one of those situations, so it's worth paying extra attention
    to the steps outlined previously.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating string resources for the `searchable`, as declared in Step
    6.
  prefs: []
  type: TYPE_NORMAL
- en: In Step 3, we create the menu resource, as we've done many times. One difference
    is that we use the `app` namespace for the `showAsAction` and `actionViewClass`
    attributes. The earlier versions of the Android OS don't include these attributes
    in their Android namespace. This serves as a way to bring new functionality to
    older versions of the Android OS
  prefs: []
  type: TYPE_NORMAL
- en: In Step 4, we set up the `SearchManager`, again using the support library APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 is where we define the `searchable`, which is an xml resource used by
    the `SearchManager`. The only required attribute is the `label`, but the `hint`
    is recommended so the user will have an idea of what they should type in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `android:label` must match the application name or the activity name and
    must use a string resource (as it does not work with a hard-coded string).
  prefs: []
  type: TYPE_NORMAL
- en: Steps 7-11 are for the `SearchResultActivity`. Calling a second activity is
    not a requirement of the `SearchManager`, but is commonly done to provide a single
    activity for all searches initiated in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ran the application at this point, you would see the search icon, but
    nothing would work. Step 12 is where we put it all together in the `AndroidManifest`
    file. The first item to note is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Notice this is in the application element and not in either of the `<activity>`
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the searchable resource in the `SearchResultActivity <meta-data>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to set the intent filter for `SearchResultActivity` as we do here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SearchManager` broadcasts the `SEARCH` intent when the user initiates
    the search. This declaration directs the intent to the `SearchResultActivity`
    activity. Once the search is triggered, the query text is sent to the `SearchResultActivity`
    using the `SEARCH` intent. We check for the `SEARCH` intent in the `onCreate()`
    and extract the query string using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You now have the Search UI pattern fully implemented. With the UI pattern complete,
    how you handle the search is specific to your application needs. Depending on
    your application, you might search a local database or maybe a web service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To take your search to the Internet, see *Internet queries* in [Chapter 12](ch12.html
    "Chapter 12. Telephony, Networks, and the Web"), *Telephony, Networks, and the
    Web*.
  prefs: []
  type: TYPE_NORMAL
- en: Showing your app full screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike
    the previous full screen flag, your app receives all the touch events while in
    Immersive Mode. This mode is ideal for certain activities, such as reading books
    and news, full-screen drawing, gaming, or watching a video. There are several
    different approaches to full screen, and each have a best use case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading books/articles, and so on: Immersive Mode with easy access to the system
    UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Game/Drawing app: Immersive Mode for full screen use but minimal system UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Watching video: Full screen and normal system UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key difference between the modes is how the System UI responds. In the first
    two scenarios, your app is expecting user interaction, so the System UI is hidden
    to make it easier for your user (such as not hitting the back button while playing
    a game). While using full screen with a normal system UI, such as watching a video,
    you wouldn't expect your user to use the screen at all, so when they do, the system
    UI should respond normally. In all modes, the user can bring back the System UI
    with a swipe inward across the hidden System Bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since watching a video doesn''t require the new **Immersive Mode**, full-screen
    mode can be achieved using the two flags: `SYSTEM_UI_FLAG_FULLSCREEN` and `SYSTEM_UI_FLAG_HIDE_NAVIGATION`,
    available since Android 4.0 (API 14).'
  prefs: []
  type: TYPE_NORMAL
- en: Our recipe will demonstrate setting up Immersive Mode. We're also going to add
    the ability to toggle the System UI with a tap on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and call it: `ImmersiveMode`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for the **Activity Type**. When selecting the **Minimum API Level**, choose **API
    19** or higher.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll create two functions for handling the system UI visibility, then we''ll
    create a gesture listener to detect the screen tap. All the steps for this recipe
    are adding code to `MainActivity.java`, so open the file and let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to hide the System UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to show the System UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following class variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `GestureListener` class at the class level, below the previous
    class variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `onTouchEvent()` callback with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `onCreate()` method to set the `GestureListener`
    and hide the System UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application on a device or emulator. Swiping inward across a hidden
    System Bar will show the System UI. Tapping the screen will toggle the System
    UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create the `showSystemUI()` and `hideSystemUI()` methods by using `setSystemUiVisibility()`
    on the application window. The flags we set (and don't set) control what is visible
    and what is hidden. When we set the visibility without the `SYSTEM_UI_FLAG_IMMERSIVE`
    flag, we in effect, disable Immersive Mode.
  prefs: []
  type: TYPE_NORMAL
- en: If all we wanted to do was hide the System UI, we could just add `hideSystemUI()`
    to `onCreate()` and we'd be done. The problem is it wouldn't stay hidden. Once
    the user exited Immersive Mode, it would stay in the regular display mode. That's
    why we created the `GestureListener`. (We'll discuss gestures again in [Chapter
    8](ch08.html "Chapter 8. Using the Touchscreen and Sensors"), *Using the Touchscreen
    and Sensors*.) Since we only want to respond to the `onSingleTapUp()` gesture,
    we don't implement the full range of gestures. When `onSingleTapUp` is detected,
    we toggle the System UI.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at some of the other important tasks that can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Sticky Immersion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's another option we can use if we want the System UI to stay hidden automatically.
    Instead of using `SYSTEM_UI_FLAG_IMMERSIVE` to hide the UI, we can use `SYSTEM_UI_FLAG_IMMERSIVE_STICKY`.
  prefs: []
  type: TYPE_NORMAL
- en: Dimming the System UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If all you need is to reduce the visibility of the Navigation bar, there's also
    `SYSTEM_UI_FLAG_LOW_PROFILE` to dim the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this flag with the same `setSystemUiVisibility()` call as the Immersive
    Mode flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `setSystemUiVisibility()` with 0 to clear all flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Setting the Action Bar as an Overlay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you just need to hide or show the Action Bar, use these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'One problem with this approach is that the system resizes the layout each time
    either method is called. Instead, you might want to consider using a theme option
    to make the System UI behave as an overlay. To enable overlay mode, add the following
    to the theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Translucent system bars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two themes enable the translucent settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are creating your own theme, use the following theme settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Recognizing a gesture* recipe in [Chapter 8](ch08.html "Chapter 8. Using
    the Touchscreen and Sensors"), *Using the Touchscreen and Sensors*.
  prefs: []
  type: TYPE_NORMAL
