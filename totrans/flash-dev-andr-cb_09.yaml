- en: 'Chapter 9. Manifest Assurance: Security and Android Permissions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting application permissions with the Android Manifest file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing the device screen from dimming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing Android Custom URI Schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anticipating Android Compatibility Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructing an Application to be installed to Device SDCard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting a Local SQLite Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android has in place a very specific permissions and security system based around
    manifest file declarations which allow or restrict applications from accessing
    various device capabilities. This chapter will detail how to enable your Flash
    Platform applications to correctly identify the permissions needed to take advantage
    of the Android Market filtering, apply local application database encryption,
    and other useful tidbits!
  prefs: []
  type: TYPE_NORMAL
- en: Setting application permissions with the Android Manifest file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When users choose to install an application on Android, they are always presented
    with a warning about which permissions the application will have within their
    particular system. From Internet access to full Geolocation, Camera, or External
    Storage permissions; the user is explicitly told what rights the application will
    have on their system. If it seems as though the application is asking for more
    permissions than necessary, the user will usually refuse the install and look
    for another application to perform the task they need. It is very important to
    only require the permissions your application truly needs, or else users might
    be suspicious of you and the applications you make available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three ways in which we can modify the `Android Manifest` file to set
    application permissions for compiling our application with Adobe AIR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Flash Professional:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within an AIR for Android project, open the **Properties** panel and click
    the little wrench icon next to **Player** selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Flash Professional:](img/1420_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **AIR for Android Settings** dialog window will appear. You will be presented
    with a list of permissions to either enable or disable for your application. Check
    only the ones your application will need and click **OK** when finished.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Flash Professional:](img/1420_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using Flash Builder:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When first setting up your AIR for Android project in Flash Builder, define
    everything required in the **Project Location** area, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now in the **Mobile Settings** area of the **New Flex Mobile Project**
    dialog. Click the **Permissions** tab, making sure that **Google Android** is
    the selected platform. You will be presented with a list of permissions to either
    enable or disable for your application. Check only the ones your application will
    need and continue along with your project setup:![Using Flash Builder:](img/1420_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To modify any of these permissions after you've begun developing the application,
    simply open the AIR descriptor file and edit it as is detailed in the following
    sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using a simple text editor:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Find the AIR Descriptor File in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the file for a node named `<android>` within this node will be another
    called `<manifestAdditions>which` holds a child node called `<manifest>`. This
    section of the document contains everything we need to set permissions for our
    Android application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All we need to do is either comment out or remove those particular permissions
    that our application does not require. For instance, this application needs Internet,
    External Storage, and Camera access. Every other permission node is commented
    out using the standard XML comment syntax of `<!-- {comment here} -->:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The permissions you define within the AIR descriptor file will be used to create
    an Android Manifest file to be packaged within the `.apk` produced by the tool
    used to compile the project. These permissions restrict and enable the application,
    once installed on a user's device, and also alert the user as to which activities
    and resources the application will be given access to prior to installation. It
    is very important to provide only the permissions necessary for an application
    to perform the expected tasks once installed upon a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the possible permissions for the Android manifest
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ACCESS_COARSE_LOCATION:` Allows the `Geoloctaion` class to access WIFI and
    triangulated cell tower location data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCESS_FINE_LOCATION:` Allows the `Geolocation` class to make use of the device
    GPS sensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCESS_NETWORK_STATE:` Allows an application to access the network state through
    the `NetworkInfo` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCESS_WIFI_STATE:` Allows and application to access the WIFI state through
    the `NetworkInfo` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAMERA:` Allows an application to access the device camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTERNET:` Allows the application to access the Internet and perform data
    transfer requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ_PHONE_STATE:` Allows the application to mute audio when a phone call
    is in effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RECORD_AUDIO:` Allows microphone access to the application to record or monitor
    audio data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WAKE_LOCK:` Allows the application to prevent the device from going to sleep
    using the `SystemIdleMode` class. (Must be used alongside `DISABLE_KEYGUARD.)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISABLE_KEYGUARD:` Allows the application to prevent the device from going
    to sleep using the `SystemIdleMode` class. (Must be used alongside `WAKE_LOCK.)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WRITE_EXTERNAL_STORAGE:` Allows the application to write to external memory.
    This memory is normally stored as a device SD card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing the device screen from dimming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android operating system will dim, and eventually turn off the device screen
    after a certain amount of time has passed. It does this to preserve battery life,
    as the display is the primary power drain on a device. For most applications,
    if a user is interacting with the interface, that interaction will prevent the
    screen from dimming. However, if your application does not involve user interaction
    for lengthy periods of time, yet the user is looking at or reading something upon
    the display, it would make sense to prevent the screen from dimming.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two settings in the AIR descriptor file that can be changed to ensure
    the screen does not dim. We will also modify properties of our application to
    complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the file for a node named `<android>` within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`. This
    section of the document contains everything we need to set permissions for our
    Android application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All we need to do is make sure the following two nodes are present within this
    section of the descriptor file. Note that enabling both of these permissions is
    required to allow application control over the system through the `SystemIdleMode`
    class. Uncomment them if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within our application, we will import the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` pair to trace out messages to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will set the system idle mode for our application by assigning the
    `SystemIdleMode.KEEP_AWAKE` constant to the `NativeApplication.nativeApplication.systemIdleMode`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we simply output the currently assigned system idle mode String to our
    `TextField`, letting the user know that the device will not be going to sleep:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application is run on a device, the **System Idle Mode** will be set
    and the results traced out to our display. The user can leave the device unattended
    for as long as necessary and the screen will not dim or lock. In the following
    example, this application was allowed to run for five minutes without user intervention:![How
    to do it...](img/1420_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two things that must be done in order to get this to work correctly
    and both are absolutely necessary. First, we have to be sure the application has
    correct permissions through the Android Manifest file. Allowing the application
    permissions for `WAKE_LOCK` and `DISABLE_KEYGUARD` within the AIR descriptor file
    will do this for us. The second part involves setting the `NativeApplication.systemIdleMode`
    property to `keepAwake`. This is best accomplished through use of the `SystemIdleMode.KEEP_AWAKE`
    constant. Ensuring that these conditions are met will enable the application to
    keep the device display lit and prevent Android from locking the device after
    it has been idle.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have edited the AIR descriptor file through a basic text
    editor. For other ways of setting these permissions in a variety of environments,
    refer to the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing Android custom URI schemes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android exposes a number of useful URI protocols to AIR for standard operations
    such as mapping, sms, and telephone. Defining a custom URI for our application
    allows it to be invoked from anywhere on the system: through the web browser,
    email, or even a native application. Custom URIs provides an alternative method
    of invoking an AIR application.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application that can be opened from the device web browser
    using a custom URI. We define the URI intent settings through modification of
    the AIR descriptor file:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the file for a node named `<android>`; within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`. This
    section of the document contains everything we need to set permissions for our
    Android application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now add the highlighted `<intent-filter>` node to our descriptor file.
    The portion of the intent which defines our URI is `<data android:scheme="fvm"/>`.
    This will enable our application to use the `fvm://` URI. Note that `"fvm"` is
    being used for this example; when authoring an application based on such an example,
    we are free to change this value to whatever is suited to a particular application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within our application, we will import the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` pair to trace out messages to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register an event listener of type InvokeEvent.INVOKE upon the NativeApplication.
    This will detect any application invocation events initiated by the user employing
    our defined URI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application is opened from our URI, the following method will be processed.
    We can gather a certain amount of information from our invoke event, such as the
    `reason` property. This property will have a value of either `"login"` or `"standard"`.
    If the application is launched automatically at system login, the value will read
    `"login"`. In the case of URI invocation, it will read `"standard"`. We can also
    access the `currentDirectory`. The app may have been invoked from within the file
    system, or access any `arguments` passed through the URI. Note that in the case
    of a URI invocation from a web browser, as we have here, the `arguments` property
    will only contain the full URL from the selected link. This is a way in which
    we can pass in data to our application at launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For this example, let us set up a simple web page which includes a link with
    our defined `fvm:// URI:<a href="fvm://arg1=Hello&arg2=AIRAndroid">Open AIR Android
    App!</a>`. If a user has the application already installed and clicks this link,
    the application should open as our URI intent is registered on the device:![How
    to do it...](img/1420_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user clicks upon the link which uses our defined URI, the AIR application
    will open and detect an `InvokeEvent`, which displays the following information
    upon the device display. We can see here that the directory URL is empty, as the
    application was not invoked from within the device file system:![How to do it...](img/1420_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we define the URI intent within our application descriptor file, this gets
    compiled into the Android manifest file along with our application. Installing
    this application on a device informs the operating system of the URI intent we
    have defined. This makes the OS aware of that specific URI and instructs it to
    open the application when that URI is encountered. We can place the URI in a number
    of different locations, including native Android applications upon the system.
    This allows native applications to open AIR for Android applications. In the earlier
    example, we embed the URI within HTML and use the Android web browser to open
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more on working with URI protocols in AIR for Android, have a look through
    [Chapter 7](ch07.html "Chapter 7. Native Interaction: StageWebView and URI Handlers"),
    *Native Interaction: StageWebView and URI Handlers.*'
  prefs: []
  type: TYPE_NORMAL
- en: Anticipating Android Compatibility Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending upon which APIs is used in a particular application, some Android
    devices may not be able to provide access to expected sensors or hardware hooks.
    If a user downloads an application which does not work as expected, that user
    will become frustrated and will most likely provide us with a poor rating and
    perhaps even a nasty comment. Luckily, there is a bit of filtering that the Android
    Market can perform, on our behalf, to ensure that only devices which support our
    application will be served the option to download and install it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the Android Manifest file to specify which particular features are required
    by our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the file for a node named `<android>`; within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`. This
    section of the document will contain everything we need to declare compatibility
    for our Android application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will add certain tags based upon our needs. See the following information
    layout to determine what you should add within the manifest node for a particular
    feature dependency. Setting `android:required="false"` makes a feature optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When using features of the Android camera:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When using features of the Android microphone:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the Geolocation Sensor:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the Accelerometer Sensor:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By specifying certain required or optional features of the camera and microphone,
    we can ensure that only users whose devices meet these specific requirements will
    be presented with the option to download and install our application. We make
    these specifications known through the modification of the Android manifest file
    through additions to our AIR description file as demonstrated in this recipe.
    Compiling our application with these modifications will ensure that these specifications
    are encoded along with our `.APK` and exposed through the Android Market once
    our application is published.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more on working with the camera and microphone in AIR for Android, have
    a look at [Chapter 4](ch04.html "Chapter 4. Visual and Audio Input: Camera and
    Microphone Access"), *Visual and Audio Input: Camera and Microphone Access.*'
  prefs: []
  type: TYPE_NORMAL
- en: Instructing an application to be installed to Device SDCard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By slightly modifying the Android manifest instructions within our AIR application
    descriptor file, we can inform the device operating system that our application
    should, if possible, be installed on the external SD card rather than internal
    storage. This will help reserve internal device storage for the operating system
    and associated files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the Android Manifest file to determine installation location options:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the AIR Descriptor File in your project. It is normally named something
    like `{MyProject}-app.xmland` resides at the project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the file for a node named `<android>`; within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add the `installLocation` attribute to our `<manifest>` node. To set
    the application to install at the discretion of Android:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the application to prefer the device SD card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no guarantee that setting `installLocation="preferExternal` will actually
    install the application to the device SD card.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The user can also move the application, if allowed, via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to the **application management** screen on the device where
    our AIR application is installed. The location of this screen on most Android
    devices is **Settings | Applications | Manage Applications**. Now choose an AIR
    application you have created from this screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To move the application to the device SD card, simply click the button labeled
    **Move to SD card:**![How to do it...](img/1420_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a good idea to allow the user some degree of choice as to where they
    can install their application. On Android, there are only two options: the device
    storage area or external SD card. Taking into consideration that most devices
    have a lot more storage on the SD card than internal; it is probably best to prefer
    the SD card by setting `android:installLocation="preferExternal"` on our manifest
    node within the AIR descriptor file. While there is no guarantee that Android
    will use the external SD card when installing our application, this will at least
    let the system know that location is preferred. Whether or not Android is able
    to install applications to external storage has mostly to do with the operating
    system version. Generally, if the device can install and run the AIR for Android
    runtime, it should have the capability to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve seen earlier, the user can always move the application from internal
    storage to external storage and back again if they wish. Also of note: the application
    storage directory, local shared objects, and any temporary files are still written
    to internal storage even when the application is installed on the device SD card.
    If we intend to save lots of data with our application, then we will use `File.documents`
    directory or `File.user` directory to store this data onto the external SD card.'
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more on working with the local file system, have a look through [Chapter
    8](ch08.html "Chapter 8. Abundant Access: File System and Local Database"), *Abundant
    Access: File System and Local Database.*'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting a local SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, a local SQLite database does not require any security or encryption.
    However, if our application contains sensitive data stored within the local application
    database files, we would want to ensure that an intruder or thief cannot access
    this information. Thankfully, we can encrypt the databases available to us on
    AIR for Android to ensure that even if a user's device is lost or stolen, their
    private information remains secure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to properly encrypt a database file, we will need to use an encryption
    library. In this example, we will use the as3crypto package available at [http://code.google.com/p/as3crypto/](http://code.google.com/p/as3crypto/).
    Download the `.SWC` to follow along with this example.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make the `.SWC` available within our project. Depending upon the
    tool being used, the procedure to do this does vary.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to include a .SWC package into a Flash Builder project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within your project, select the **File** menu and choose **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left column, click **ActionScript Build Path** and choose the **Library
    path** tab. Locate the button labeled **Add SWC** within this screen and click
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dialog window will appear. Choose the **Browse to SWC** option, locate the
    `.SWC` containing our encryption library, and hit **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The encryption library will now appear within the **Build path libraries** section
    of this screen. Verify that this is correct and exit out of the **Properties**
    window. The encryption library is now ready to be used within our mobile Android
    project.![Instructions to include a .SWC package into a Flash Builder project](img/1420_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instructions to include a .SWC package into a Flash Professional project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within your Flash project, navigate to the **Properties** panel and click the
    little wrench icon next to the **Script** selection box:![Instructions to include
    a .SWC package into a Flash Professional project](img/1420_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open the **Advanced ActionScript 3.0 Settings** dialog window. Choose
    the **Library path** tab. Locate the **Browse to SWC file** icon within this screen
    and click it. It appears as a white and red box and is the only icon which is
    not grayscale upon this screen:![Instructions to include a .SWC package into a
    Flash Professional project](img/1420_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **file browse** dialog window will appear. Locate the `.SWC` containing our
    encryption library, and hit **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The encryption library will now appear within the **Library path** section of
    this screen. Verify that this is correct and exit out of the **Advanced ActionScript
    3.0 Settings** window. The encryption library is now ready to be used within our
    mobile Android project:![Instructions to include a .SWC package into a Flash Professional
    project](img/1420_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to encrypt an application database, we will declare a password and
    encrypt it using an external encryption library. This will be used when creating
    and opening our database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our application, we will import the following classes. Be sure to import
    the `MD5` class or an equivalent for proper key encryption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must now declare a number of objects for use within this application. A
    `String` constant will hold our plain text password for later encryption. Normally,
    this would be supplied by the user and is hard-coded here for simplicity. We will
    need a `SQLConnection` to create or open our database file along with a set of
    `ByteArray` objects and a `MD5` object to perform the actual encryption. Finally,
    we declare a `TextField` and `TextFormat` pair to trace out messages to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList` for textual output. Here, we create a method to
    perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To perform the encryption of our database, we will first instantiate a `ByteArray`
    and invoke the `writeUTFBytes()` method, passing in our predefined password constant.
    This will write our `String` to the byte stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, instantiate a new `MD5` object along with another `ByteArray`, assigning
    the `ByteArray` to the result of the `MD5.hash()` method, passing in the previous
    `ByteArray` holding the password bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate an `SQLConnection` and register an event listener of type `SQLEvent.OPEN`.
    This will fire an event once the database is either created or opened successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, invoke the `SQLConnection.open()` method, passing in the path to the
    database as a `File` object, the open mode constant of `SQLMode.CREATE`, an auto-compact
    `Boolean`, default page size of 1024, and most importantly for this example, our
    MD5-encrypted `ByteArray:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So long as the database is created (or opened) successfully along with valid
    encryption, the following method will fire, outputting information about the encrypted
    database to our display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application is run on our Android device, it will appear as follows.
    As the key is a truly MD5-encrypted `ByteArray`, it appears as garbled characters
    in the `TextField`, for it is no longer a plain text `String:`![How to do it...](img/1420_09_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an application requires encryption on a database, the encryption key must
    be applied when our database is created. Implementing the `SQLConnection.open()`
    or `SQLConnection.openAsync()` methods require us to pass in an encrypted `ByteArray`
    key created using `as3Crypto` or a similar encryption library. If we ever need
    to modify the encryption key, we can use the `SQLConnection.reencrypt()` to do
    so, generating the key in the same manner as demonstrated in this recipe. Note
    that a valid encryption key must be 16 bytes in length.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more on working with local databases in AIR for Android, have a look through
    [Chapter 8](ch08.html "Chapter 8. Abundant Access: File System and Local Database"),
    *Abundant Access: File System and Local Database.*'
  prefs: []
  type: TYPE_NORMAL
