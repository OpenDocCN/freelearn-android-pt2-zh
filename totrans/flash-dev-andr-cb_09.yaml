- en: 'Chapter 9. Manifest Assurance: Security and Android Permissions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 清单保障：安全与Android权限
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下内容：
- en: Setting application permissions with the Android Manifest file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android Manifest文件设置应用程序权限
- en: Preventing the device screen from dimming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止设备屏幕变暗
- en: Establishing Android Custom URI Schemes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立Android自定义URI方案
- en: Anticipating Android Compatibility Filtering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期Android兼容性筛选
- en: Instructing an Application to be installed to Device SDCard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指导应用程序安装到设备SD卡
- en: Encrypting a Local SQLite Database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密本地SQLite数据库
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Android has in place a very specific permissions and security system based around
    manifest file declarations which allow or restrict applications from accessing
    various device capabilities. This chapter will detail how to enable your Flash
    Platform applications to correctly identify the permissions needed to take advantage
    of the Android Market filtering, apply local application database encryption,
    and other useful tidbits!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android有一个非常特定的权限和安全系统，基于清单文件声明，允许或限制应用程序访问各种设备功能。本章将详细介绍如何为你的Flash平台应用程序正确识别所需权限，以便利用Android市场筛选，应用本地应用程序数据库加密，以及其他有用的技巧！
- en: Setting application permissions with the Android Manifest file
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android Manifest文件设置应用程序权限
- en: When users choose to install an application on Android, they are always presented
    with a warning about which permissions the application will have within their
    particular system. From Internet access to full Geolocation, Camera, or External
    Storage permissions; the user is explicitly told what rights the application will
    have on their system. If it seems as though the application is asking for more
    permissions than necessary, the user will usually refuse the install and look
    for another application to perform the task they need. It is very important to
    only require the permissions your application truly needs, or else users might
    be suspicious of you and the applications you make available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择在Android上安装应用程序时，他们总会收到关于应用程序将在其系统中拥有哪些权限的警告。从互联网访问到完整的地理位置、相机或外部存储权限；用户会明确知道应用程序在他们的系统上会拥有哪些权利。如果看起来应用程序请求的权限比实际需要的多，用户通常会拒绝安装并寻找其他可以完成所需任务的应用程序。只请求应用程序真正需要的权限非常重要，否则用户可能会对你和你提供的应用程序产生怀疑。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: There are three ways in which we can modify the `Android Manifest` file to set
    application permissions for compiling our application with Adobe AIR.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三种方式修改`Android Manifest`文件，为使用Adobe AIR编译应用程序时设置应用权限。
- en: 'Using Flash Professional:'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Flash Professional：
- en: 'Within an AIR for Android project, open the **Properties** panel and click
    the little wrench icon next to **Player** selection:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在AIR for Android项目中，打开**属性**面板，点击**播放器**选择旁边的扳手图标：
- en: '![Using Flash Professional:](img/1420_09_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用Flash Professional：](img/1420_09_01.jpg)'
- en: The **AIR for Android Settings** dialog window will appear. You will be presented
    with a list of permissions to either enable or disable for your application. Check
    only the ones your application will need and click **OK** when finished.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将会出现**Android的AIR设置**对话框窗口。你将看到一个权限列表，可以选择为你的应用程序启用或禁用。只选中你的应用程序需要的权限，完成后点击**确定**。
- en: '![Using Flash Professional:](img/1420_09_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用Flash Professional：](img/1420_09_02.jpg)'
- en: 'Using Flash Builder:'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Flash Builder：
- en: When first setting up your AIR for Android project in Flash Builder, define
    everything required in the **Project Location** area, and click **Next**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Flash Builder中首次设置你的AIR for Android项目时，在**项目位置**区域定义所需的一切，然后点击**下一步**。
- en: You are now in the **Mobile Settings** area of the **New Flex Mobile Project**
    dialog. Click the **Permissions** tab, making sure that **Google Android** is
    the selected platform. You will be presented with a list of permissions to either
    enable or disable for your application. Check only the ones your application will
    need and continue along with your project setup:![Using Flash Builder:](img/1420_09_03.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在处于**新建Flex移动项目**对话框的**移动设置**区域。点击**权限**标签，确保已选择**Google Android**作为平台。你将看到一个权限列表，可以选择为你的应用程序启用或禁用。只选中你的应用程序需要的权限，然后继续你的项目设置：![使用Flash
    Builder：](img/1420_09_03.jpg)
- en: To modify any of these permissions after you've begun developing the application,
    simply open the AIR descriptor file and edit it as is detailed in the following
    sections.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始开发应用程序后，若要修改这些权限，只需打开AIR描述文件，按照下面几节的详细说明进行编辑。
- en: 'Using a simple text editor:'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用简单的文本编辑器：
- en: Find the AIR Descriptor File in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中找到AIR描述文件。它通常被命名为类似`{MyProject}-app.xml`的名称，位于项目根目录。
- en: Browse the file for a node named `<android>` within this node will be another
    called `<manifestAdditions>which` holds a child node called `<manifest>`. This
    section of the document contains everything we need to set permissions for our
    Android application.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览文件，寻找名为`<android>`的节点，在这个节点内会有一个名为`<manifestAdditions>`的节点，它包含一个名为`<manifest>`的子节点。本文档的这一部分包含了我们为Android应用程序设置权限所需的一切。
- en: All we need to do is either comment out or remove those particular permissions
    that our application does not require. For instance, this application needs Internet,
    External Storage, and Camera access. Every other permission node is commented
    out using the standard XML comment syntax of `<!-- {comment here} -->:`
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的就是注释掉或移除那些应用程序不需要的特定权限。例如，这个应用程序需要互联网、外部存储和相机访问权限。其他所有权限节点都使用标准的XML注释语法`<!--
    {在此处注释} -->`进行注释。
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理如下...
- en: The permissions you define within the AIR descriptor file will be used to create
    an Android Manifest file to be packaged within the `.apk` produced by the tool
    used to compile the project. These permissions restrict and enable the application,
    once installed on a user's device, and also alert the user as to which activities
    and resources the application will be given access to prior to installation. It
    is very important to provide only the permissions necessary for an application
    to perform the expected tasks once installed upon a device.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在AIR描述文件中定义的权限将被用于创建一个Android清单文件，该文件将被打包进编译项目时产生的`.apk`文件中。这些权限限制并启用了应用程序，一旦安装在用户设备上，也会在安装前告知用户应用程序将获得哪些活动和资源的访问权限。为应用程序提供仅完成预期任务所需的权限非常重要。
- en: 'The following is a list of the possible permissions for the Android manifest
    document:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Android清单文档可能包含的权限列表：
- en: '`ACCESS_COARSE_LOCATION:` Allows the `Geoloctaion` class to access WIFI and
    triangulated cell tower location data.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_COARSE_LOCATION:` 允许`Geoloctaion`类访问WIFI和三角定位的基站位置数据。'
- en: '`ACCESS_FINE_LOCATION:` Allows the `Geolocation` class to make use of the device
    GPS sensor.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_FINE_LOCATION:` 允许`Geolocation`类使用设备的GPS传感器。'
- en: '`ACCESS_NETWORK_STATE:` Allows an application to access the network state through
    the `NetworkInfo` class.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_NETWORK_STATE:` 允许应用程序通过`NetworkInfo`类访问网络状态。'
- en: '`ACCESS_WIFI_STATE:` Allows and application to access the WIFI state through
    the `NetworkInfo` class.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_WIFI_STATE:` 允许应用程序通过`NetworkInfo`类访问WIFI状态。'
- en: '`CAMERA:` Allows an application to access the device camera.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAMERA:` 允许应用程序访问设备摄像头。'
- en: '`INTERNET:` Allows the application to access the Internet and perform data
    transfer requests.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERNET:` 允许应用程序访问互联网并执行数据传输请求。'
- en: '`READ_PHONE_STATE:` Allows the application to mute audio when a phone call
    is in effect.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_PHONE_STATE:` 允许应用程序在电话通话过程中静音音频。'
- en: '`RECORD_AUDIO:` Allows microphone access to the application to record or monitor
    audio data.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RECORD_AUDIO:` 允许应用程序访问麦克风以录制或监控音频数据。'
- en: '`WAKE_LOCK:` Allows the application to prevent the device from going to sleep
    using the `SystemIdleMode` class. (Must be used alongside `DISABLE_KEYGUARD.)`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAKE_LOCK:` 允许应用程序使用`SystemIdleMode`类防止设备进入休眠状态。（必须与`DISABLE_KEYGUARD`一起使用）'
- en: '`DISABLE_KEYGUARD:` Allows the application to prevent the device from going
    to sleep using the `SystemIdleMode` class. (Must be used alongside `WAKE_LOCK.)`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISABLE_KEYGUARD:` 允许应用程序使用`SystemIdleMode`类防止设备进入休眠状态。（必须与`WAKE_LOCK`一起使用）'
- en: '`WRITE_EXTERNAL_STORAGE:` Allows the application to write to external memory.
    This memory is normally stored as a device SD card.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WRITE_EXTERNAL_STORAGE:` 允许应用程序写入外部存储。这部分存储通常是指设备的SD卡。'
- en: Preventing the device screen from dimming
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止设备屏幕变暗
- en: The Android operating system will dim, and eventually turn off the device screen
    after a certain amount of time has passed. It does this to preserve battery life,
    as the display is the primary power drain on a device. For most applications,
    if a user is interacting with the interface, that interaction will prevent the
    screen from dimming. However, if your application does not involve user interaction
    for lengthy periods of time, yet the user is looking at or reading something upon
    the display, it would make sense to prevent the screen from dimming.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓操作系统会在经过一定时间后，降低亮度并最终关闭设备屏幕。这样做是为了节省电池寿命，因为显示屏幕是设备上的主要耗电项。对于大多数应用程序，如果用户正在与界面互动，那么这种互动将阻止屏幕变暗。然而，如果你的应用程序在长时间内不涉及用户互动，但用户正在观看或阅读屏幕上的内容，那么阻止屏幕变暗是合理的。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are two settings in the AIR descriptor file that can be changed to ensure
    the screen does not dim. We will also modify properties of our application to
    complete this recipe:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: AIR描述文件中有两个设置可以更改，以确保屏幕不会变暗。我们还将修改应用程序的属性来完成这个配方：
- en: Find the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中找到AIR描述文件。它通常像`{MyProject}-app.xml`这样命名，位于项目根目录。
- en: Browse the file for a node named `<android>` within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`. This
    section of the document contains everything we need to set permissions for our
    Android application.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览文件，寻找名为`<android>`的节点，在这个节点内会有一个名为`<manifestAdditions>`的节点，它包含一个名为`<manifest>`的子节点。本文档的这一部分包含了我们为Android应用程序设置权限所需的一切。
- en: All we need to do is make sure the following two nodes are present within this
    section of the descriptor file. Note that enabling both of these permissions is
    required to allow application control over the system through the `SystemIdleMode`
    class. Uncomment them if necessary.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保以下两个节点存在于描述文件的这一部分中。请注意，启用这两个权限是允许应用程序通过`SystemIdleMode`类控制系统的必要条件。如有必要，请取消注释它们。
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within our application, we will import the following classes:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将导入以下类：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare a `TextField` and `TextFormat` pair to trace out messages to the user:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextField`和`TextFormat`对，以向用户输出跟踪信息：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will set the system idle mode for our application by assigning the
    `SystemIdleMode.KEEP_AWAKE` constant to the `NativeApplication.nativeApplication.systemIdleMode`
    property:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过将`SystemIdleMode.KEEP_AWAKE`常量赋值给`NativeApplication.nativeApplication.systemIdleMode`属性，为我们的应用程序设置系统空闲模式：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们继续设置我们的`TextField`，应用`TextFormat`，并将其添加到`DisplayList`中。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we simply output the currently assigned system idle mode String to our
    `TextField`, letting the user know that the device will not be going to sleep:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们简单地将当前分配的系统空闲模式字符串输出到我们的`TextField`中，让用户知道设备不会进入休眠状态：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the application is run on a device, the **System Idle Mode** will be set
    and the results traced out to our display. The user can leave the device unattended
    for as long as necessary and the screen will not dim or lock. In the following
    example, this application was allowed to run for five minutes without user intervention:![How
    to do it...](img/1420_09_04.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序在设备上运行时，**系统空闲模式**将被设置，结果将输出到我们的显示屏幕。用户可以将设备留置不管，只要需要，屏幕就不会变暗或锁定。在以下示例中，这个应用程序在五分钟内没有用户干预的情况下被允许运行：![如何操作...](img/1420_09_04.jpg)
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are two things that must be done in order to get this to work correctly
    and both are absolutely necessary. First, we have to be sure the application has
    correct permissions through the Android Manifest file. Allowing the application
    permissions for `WAKE_LOCK` and `DISABLE_KEYGUARD` within the AIR descriptor file
    will do this for us. The second part involves setting the `NativeApplication.systemIdleMode`
    property to `keepAwake`. This is best accomplished through use of the `SystemIdleMode.KEEP_AWAKE`
    constant. Ensuring that these conditions are met will enable the application to
    keep the device display lit and prevent Android from locking the device after
    it has been idle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此功能正确工作，必须完成两件事，这两件事都是绝对必要的。首先，我们必须确保应用程序通过 Android 清单文件具有正确的权限。在 AIR 描述符文件中允许应用程序具有
    `WAKE_LOCK` 和 `DISABLE_KEYGUARD` 权限将为我们完成此操作。第二部分涉及将 `NativeApplication.systemIdleMode`
    属性设置为 `keepAwake`。最好使用 `SystemIdleMode.KEEP_AWAKE` 常量来完成此操作。确保满足这些条件将使应用程序能够保持设备显示屏亮起，并防止
    Android 在设备空闲后锁定设备。
- en: See also...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: In this recipe, we have edited the AIR descriptor file through a basic text
    editor. For other ways of setting these permissions in a variety of environments,
    refer to the previous recipe.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们通过基本文本编辑器编辑了 AIR 描述符文件。有关在其他环境中设置这些权限的其他方法，请参阅之前的食谱。
- en: Establishing Android custom URI schemes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立 Android 自定义 URI 方案
- en: 'Android exposes a number of useful URI protocols to AIR for standard operations
    such as mapping, sms, and telephone. Defining a custom URI for our application
    allows it to be invoked from anywhere on the system: through the web browser,
    email, or even a native application. Custom URIs provides an alternative method
    of invoking an AIR application.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Android 向 AIR 公开了许多有用的 URI 协议，用于标准操作，如映射、短信和电话。为我们应用程序定义自定义 URI 允许它从系统的任何地方调用：通过网页浏览器、电子邮件，甚至本地应用程序。自定义
    URI 提供了调用 AIR 应用程序的一种替代方法。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create an application that can be opened from the device web browser
    using a custom URI. We define the URI intent settings through modification of
    the AIR descriptor file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个可以从设备网页浏览器使用自定义 URI 打开的应用程序。我们通过修改 AIR 描述符文件来定义 URI 意图设置：
- en: Find the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中找到 AIR 描述符文件。它通常像 `{MyProject}-app.xml` 这样命名，位于项目根目录。
- en: Browse the file for a node named `<android>`; within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`. This
    section of the document contains everything we need to set permissions for our
    Android application.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览文件以查找名为 `<android>` 的节点；在此节点内将有一个名为 `<manifestAdditions>` 的节点，其中包含一个名为 `<manifest>`
    的子节点。本文档的此部分包含设置我们 Android 应用程序权限所需的一切。
- en: 'We will now add the highlighted `<intent-filter>` node to our descriptor file.
    The portion of the intent which defines our URI is `<data android:scheme="fvm"/>`.
    This will enable our application to use the `fvm://` URI. Note that `"fvm"` is
    being used for this example; when authoring an application based on such an example,
    we are free to change this value to whatever is suited to a particular application:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将突出显示的 `<intent-filter>` 节点添加到我们的描述符文件中。定义我们 URI 的意图部分是 `<data android:scheme="fvm"/>`。这将使我们的应用程序能够使用
    `fvm://` URI。请注意，本例中使用了 `"fvm"`；在根据此类示例编写应用程序时，我们可以自由地将此值更改为适合特定应用程序的任何值：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within our application, we will import the following classes:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将导入以下类：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a `TextField` and `TextFormat` pair to trace out messages to the user:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `TextField` 和 `TextFormat` 对，以向用户输出消息：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList`. Here, we create a method to perform all of these
    actions for us:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们将继续设置我们的 `TextField`，应用 `TextFormat`，并将其添加到 `DisplayList` 中。在这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Register an event listener of type InvokeEvent.INVOKE upon the NativeApplication.
    This will detect any application invocation events initiated by the user employing
    our defined URI:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NativeApplication` 上注册一个类型为 `InvokeEvent.INVOKE` 的事件监听器。这将检测用户使用我们定义的 URI
    发起的任何应用程序调用事件：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the application is opened from our URI, the following method will be processed.
    We can gather a certain amount of information from our invoke event, such as the
    `reason` property. This property will have a value of either `"login"` or `"standard"`.
    If the application is launched automatically at system login, the value will read
    `"login"`. In the case of URI invocation, it will read `"standard"`. We can also
    access the `currentDirectory`. The app may have been invoked from within the file
    system, or access any `arguments` passed through the URI. Note that in the case
    of a URI invocation from a web browser, as we have here, the `arguments` property
    will only contain the full URL from the selected link. This is a way in which
    we can pass in data to our application at launch.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序从我们的 URI 打开时，将处理以下方法。我们可以从我们的调用事件中收集一定量的信息，比如 `reason` 属性。这个属性将具有 `"login"`
    或 `"standard"` 的值。如果应用程序在系统登录时自动启动，该值将显示为 `"login"`。在 URI 调用的情况下，它将显示为 `"standard"`。我们还可以访问
    `currentDirectory`。应用程序可能从文件系统内部调用，或者访问通过 URI 传递的任何 `arguments`。请注意，在从网络浏览器进行
    URI 调用的这种情况下，`arguments` 属性将只包含所选链接的完整 URL。这是我们可以在启动时向应用程序传递数据的一种方式。
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For this example, let us set up a simple web page which includes a link with
    our defined `fvm:// URI:<a href="fvm://arg1=Hello&arg2=AIRAndroid">Open AIR Android
    App!</a>`. If a user has the application already installed and clicks this link,
    the application should open as our URI intent is registered on the device:![How
    to do it...](img/1420_09_05.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们设置一个简单的网页，其中包含一个使用我们定义的 `fvm:// URI:<a href="fvm://arg1=Hello&arg2=AIRAndroid">打开
    AIR Android 应用!</a>` 的链接。如果用户已经安装了该应用程序并点击了这个链接，应用程序应该会打开，因为我们的 URI 意图在设备上已经注册了：![如何操作...](img/1420_09_05.jpg)
- en: Once the user clicks upon the link which uses our defined URI, the AIR application
    will open and detect an `InvokeEvent`, which displays the following information
    upon the device display. We can see here that the directory URL is empty, as the
    application was not invoked from within the device file system:![How to do it...](img/1420_09_06.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户点击了使用我们定义的 URI 的链接，AIR 应用程序将会打开并检测到一个 `InvokeEvent`，在设备显示屏上显示以下信息。我们可以看到这里目录
    URL 是空的，因为应用程序不是从设备文件系统中调用的：![如何操作...](img/1420_09_06.jpg)
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: When we define the URI intent within our application descriptor file, this gets
    compiled into the Android manifest file along with our application. Installing
    this application on a device informs the operating system of the URI intent we
    have defined. This makes the OS aware of that specific URI and instructs it to
    open the application when that URI is encountered. We can place the URI in a number
    of different locations, including native Android applications upon the system.
    This allows native applications to open AIR for Android applications. In the earlier
    example, we embed the URI within HTML and use the Android web browser to open
    our application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序描述符文件中定义 URI 意图时，这会被编译到 Android 清单文件中，与应用程序一起安装到设备上。在设备上安装此应用程序会告知操作系统我们定义的
    URI 意图。这使得操作系统知道特定的 URI，并指示在遇到该 URI 时打开应用程序。我们可以将 URI 放置在多个不同的位置，包括系统上的本地 Android
    应用程序。这使得本地应用程序能够打开 AIR for Android 应用程序。在之前的示例中，我们将 URI 嵌入 HTML 中，并使用 Android
    网络浏览器打开我们的应用程序。
- en: See also...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more on working with URI protocols in AIR for Android, have a look through
    [Chapter 7](ch07.html "Chapter 7. Native Interaction: StageWebView and URI Handlers"),
    *Native Interaction: StageWebView and URI Handlers.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于在 AIR for Android 中使用 URI 协议的信息，请查看 [第7章](ch07.html "第 7 章. 本地交互：StageWebView
    和 URI 处理器")，*本地交互：StageWebView 和 URI 处理器。*
- en: Anticipating Android Compatibility Filtering
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期 Android 兼容性筛选
- en: Depending upon which APIs is used in a particular application, some Android
    devices may not be able to provide access to expected sensors or hardware hooks.
    If a user downloads an application which does not work as expected, that user
    will become frustrated and will most likely provide us with a poor rating and
    perhaps even a nasty comment. Luckily, there is a bit of filtering that the Android
    Market can perform, on our behalf, to ensure that only devices which support our
    application will be served the option to download and install it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定应用程序中使用的 API，一些 Android 设备可能无法提供对预期传感器或硬件钩子的访问。如果用户下载了一个无法按预期工作的应用程序，这个用户将会感到沮丧，很可能会给我们一个差评，甚至可能是一条恶评。幸运的是，Android
    市场可以代表我们进行一些筛选，以确保只有支持我们应用程序的设备才有下载和安装的选项。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Modify the Android Manifest file to specify which particular features are required
    by our application:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 修改Android Manifest文件，以指定我们的应用程序需要哪些特定特性：
- en: Find the AIR descriptor file in your project. It is normally named something
    like `{MyProject}-app.xml` as it resides at the project root.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中找到AIR描述文件。它通常被命名为类似`{MyProject}-app.xml`的名称，因为它位于项目根目录。
- en: Browse the file for a node named `<android>`; within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`. This
    section of the document will contain everything we need to declare compatibility
    for our Android application.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览文件，查找名为`<android>`的节点；在这个节点内，会有一个名为`<manifestAdditions>`的节点，它包含一个名为`<manifest>`的子节点。文档的这一部分将包含我们需要声明Android应用程序兼容性的所有内容。
- en: We will add certain tags based upon our needs. See the following information
    layout to determine what you should add within the manifest node for a particular
    feature dependency. Setting `android:required="false"` makes a feature optional.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根据需求添加某些标签。查看以下信息布局，以确定你应该在manifest节点中为特定的特性依赖添加什么内容。设置`android:required="false"`可以使一个特性成为可选。
- en: 'When using features of the Android camera:'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当使用Android摄像头的特性时：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When using features of the Android microphone:'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当使用Android麦克风的特性时：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When using the Geolocation Sensor:'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当使用Geolocation传感器时：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When using the Accelerometer Sensor:'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当使用加速度传感器时：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By specifying certain required or optional features of the camera and microphone,
    we can ensure that only users whose devices meet these specific requirements will
    be presented with the option to download and install our application. We make
    these specifications known through the modification of the Android manifest file
    through additions to our AIR description file as demonstrated in this recipe.
    Compiling our application with these modifications will ensure that these specifications
    are encoded along with our `.APK` and exposed through the Android Market once
    our application is published.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定摄像头和麦克风的一些必需或可选特性，我们可以确保只有设备满足这些具体要求的用户才会被提供下载和安装我们应用程序的选项。我们通过修改Android
    manifest文件，通过向我们的AIR描述文件中添加内容来公开这些规范，如本食谱所示。使用这些修改编译我们的应用程序将确保这些规范与我们的`.APK`一起编码，并在我们的应用程序发布后通过Android
    Market公开。
- en: See also...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more on working with the camera and microphone in AIR for Android, have
    a look at [Chapter 4](ch04.html "Chapter 4. Visual and Audio Input: Camera and
    Microphone Access"), *Visual and Audio Input: Camera and Microphone Access.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在AIR for Android中使用摄像头和麦克风的内容，请查看[第4章](ch04.html "第4章. 视觉和音频输入：摄像头和麦克风访问")，*视觉和音频输入：摄像头和麦克风访问*。
- en: Instructing an application to be installed to Device SDCard
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指示应用程序安装到设备SD卡
- en: By slightly modifying the Android manifest instructions within our AIR application
    descriptor file, we can inform the device operating system that our application
    should, if possible, be installed on the external SD card rather than internal
    storage. This will help reserve internal device storage for the operating system
    and associated files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微修改我们AIR应用程序描述文件中的Android manifest指令，我们可以通知设备操作系统，如果可能，我们的应用程序应该安装在SD卡上，而不是内部存储。这将有助于将内部设备存储保留给操作系统和相关文件。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Modify the Android Manifest file to determine installation location options:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 修改Android Manifest文件以确定安装位置选项：
- en: Find the AIR Descriptor File in your project. It is normally named something
    like `{MyProject}-app.xmland` resides at the project root.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中找到AIR描述文件。它通常被命名为类似`{MyProject}-app.xml`的名称，并且位于项目根目录。
- en: Browse the file for a node named `<android>`; within this node will be another
    called `<manifestAdditions>`, which holds a child node called `<manifest>`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览文件，查找名为`<android>`的节点；在这个节点内，会有一个名为`<manifestAdditions>`的节点，其中包含一个名为`<manifest>`的子节点。
- en: 'We will add the `installLocation` attribute to our `<manifest>` node. To set
    the application to install at the discretion of Android:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`<manifest>`节点中添加`installLocation`属性。要设置应用程序由Android自行决定安装位置：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To set the application to prefer the device SD card:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置应用程序优先选择设备SD卡：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no guarantee that setting `installLocation="preferExternal` will actually
    install the application to the device SD card.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不能保证设置`installLocation="preferExternal"`实际上会将应用程序安装到设备SD卡。
- en: 'The user can also move the application, if allowed, via the following steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以通过以下步骤，如果允许的话，移动应用程序：
- en: First, navigate to the **application management** screen on the device where
    our AIR application is installed. The location of this screen on most Android
    devices is **Settings | Applications | Manage Applications**. Now choose an AIR
    application you have created from this screen.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在设备上导航到安装了我们的AIR应用程序的**应用程序管理**屏幕。在大多数Android设备上，这个屏幕的位置是**设置 | 应用程序 | 管理应用程序**。现在从这个屏幕上选择你创建的AIR应用程序。
- en: To move the application to the device SD card, simply click the button labeled
    **Move to SD card:**![How to do it...](img/1420_09_07.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将应用程序移动到设备SD卡，只需点击标记为**移动到SD卡**的按钮：![如何操作...](img/1420_09_07.jpg)
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'It is a good idea to allow the user some degree of choice as to where they
    can install their application. On Android, there are only two options: the device
    storage area or external SD card. Taking into consideration that most devices
    have a lot more storage on the SD card than internal; it is probably best to prefer
    the SD card by setting `android:installLocation="preferExternal"` on our manifest
    node within the AIR descriptor file. While there is no guarantee that Android
    will use the external SD card when installing our application, this will at least
    let the system know that location is preferred. Whether or not Android is able
    to install applications to external storage has mostly to do with the operating
    system version. Generally, if the device can install and run the AIR for Android
    runtime, it should have the capability to do this.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户在一定程度上选择应用程序的安装位置是一个好主意。在Android上，只有两个选项：设备存储区域或外部SD卡。考虑到大多数设备在外部SD卡上的存储空间比内部存储要多，最好是在AIR描述符文件中的清单节点上设置`android:installLocation="preferExternal"`，优先选择SD卡。尽管不能保证Android在安装我们的应用程序时会使用外部SD卡，但这至少会让系统知道该位置是首选的。Android是否能够将应用程序安装到外部存储，主要取决于操作系统版本。一般来说，如果设备能够安装和运行适用于Android的AIR运行时，它应该具备这个功能。
- en: 'As we''ve seen earlier, the user can always move the application from internal
    storage to external storage and back again if they wish. Also of note: the application
    storage directory, local shared objects, and any temporary files are still written
    to internal storage even when the application is installed on the device SD card.
    If we intend to save lots of data with our application, then we will use `File.documents`
    directory or `File.user` directory to store this data onto the external SD card.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，如果用户愿意，他们总是可以将应用程序从内部存储移动到外部存储，然后再移回来。同样值得注意的是：即使应用程序安装在设备的SD卡上，应用程序存储目录、本地共享对象和任何临时文件仍然会被写入内部存储。如果我们打算与我们的应用程序一起保存大量数据，那么我们将使用`File.documents`目录或`File.user`目录将这些数据存储在外部SD卡上。
- en: See also...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见...
- en: 'For more on working with the local file system, have a look through [Chapter
    8](ch08.html "Chapter 8. Abundant Access: File System and Local Database"), *Abundant
    Access: File System and Local Database.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本地文件系统的更多信息，请查看[第8章](ch08.html "第8章. 丰富访问：文件系统和本地数据库")，*丰富访问：文件系统和本地数据库*。
- en: Encrypting a local SQLite database
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密本地SQLite数据库
- en: Normally, a local SQLite database does not require any security or encryption.
    However, if our application contains sensitive data stored within the local application
    database files, we would want to ensure that an intruder or thief cannot access
    this information. Thankfully, we can encrypt the databases available to us on
    AIR for Android to ensure that even if a user's device is lost or stolen, their
    private information remains secure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，本地SQLite数据库不需要任何安全或加密。然而，如果我们的应用程序包含存储在本地应用程序数据库文件中的敏感数据，我们会希望确保入侵者或小偷无法访问这些信息。幸运的是，我们可以加密在Android上可用的数据库，以确保即使用户的设备丢失或被盗，他们的私人信息仍然保持安全。
- en: Getting ready...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: In order to properly encrypt a database file, we will need to use an encryption
    library. In this example, we will use the as3crypto package available at [http://code.google.com/p/as3crypto/](http://code.google.com/p/as3crypto/).
    Download the `.SWC` to follow along with this example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确加密数据库文件，我们需要使用一个加密库。在这个例子中，我们将使用位于[http://code.google.com/p/as3crypto/](http://code.google.com/p/as3crypto/)的as3crypto包。下载`.SWC`文件，跟随这个例子操作。
- en: We need to make the `.SWC` available within our project. Depending upon the
    tool being used, the procedure to do this does vary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使`.SWC`在我们的项目中可用。根据所使用的工具不同，操作过程也会有所不同。
- en: Instructions to include a .SWC package into a Flash Builder project
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于将.SWC包包含到Flash Builder项目的说明
- en: Within your project, select the **File** menu and choose **Properties**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中，选择**文件**菜单，然后选择**属性**。
- en: In the left column, click **ActionScript Build Path** and choose the **Library
    path** tab. Locate the button labeled **Add SWC** within this screen and click
    it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列中，点击**ActionScript构建路径**并选择**库路径**标签页。在这个屏幕中找到标记为**添加SWC**的按钮并点击它。
- en: A dialog window will appear. Choose the **Browse to SWC** option, locate the
    `.SWC` containing our encryption library, and hit **OK**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个对话框窗口。选择**浏览到SWC**选项，找到包含我们加密库的`.SWC`文件，然后点击**确定**。
- en: The encryption library will now appear within the **Build path libraries** section
    of this screen. Verify that this is correct and exit out of the **Properties**
    window. The encryption library is now ready to be used within our mobile Android
    project.![Instructions to include a .SWC package into a Flash Builder project](img/1420_09_08.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密库现在将显示在此屏幕的**构建路径库**部分。确认这是正确的，并退出**属性**窗口。加密库现在可以在我们的移动Android项目中使用了：![将.SWC包包含到Flash
    Builder项目的操作指南](img/1420_09_08.jpg)
- en: Instructions to include a .SWC package into a Flash Professional project
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将.SWC包包含到Flash Professional项目的操作指南
- en: Within your Flash project, navigate to the **Properties** panel and click the
    little wrench icon next to the **Script** selection box:![Instructions to include
    a .SWC package into a Flash Professional project](img/1420_09_09.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Flash项目中，导航到**属性**面板，点击**脚本**选择框旁边的扳手图标：![将.SWC包包含到Flash Professional项目的操作指南](img/1420_09_09.jpg)
- en: This will open the **Advanced ActionScript 3.0 Settings** dialog window. Choose
    the **Library path** tab. Locate the **Browse to SWC file** icon within this screen
    and click it. It appears as a white and red box and is the only icon which is
    not grayscale upon this screen:![Instructions to include a .SWC package into a
    Flash Professional project](img/1420_09_10.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开**高级ActionScript 3.0设置**对话框窗口。选择**库路径**标签页。在这个屏幕中找到**浏览到SWC文件**的图标并点击它。它显示为一个白色和红色的盒子，是此屏幕上唯一不是灰度的图标：![将.SWC包包含到Flash
    Professional项目的操作指南](img/1420_09_10.jpg)
- en: A **file browse** dialog window will appear. Locate the `.SWC` containing our
    encryption library, and hit **OK**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个**文件浏览**对话框窗口。找到包含我们加密库的`.SWC`文件，然后点击**确定**。
- en: The encryption library will now appear within the **Library path** section of
    this screen. Verify that this is correct and exit out of the **Advanced ActionScript
    3.0 Settings** window. The encryption library is now ready to be used within our
    mobile Android project:![Instructions to include a .SWC package into a Flash Professional
    project](img/1420_09_11.jpg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密库现在将显示在此屏幕的**库路径**部分。确认这是正确的，并退出**高级ActionScript 3.0设置**窗口。加密库现在可以在我们的移动Android项目中使用了：![将.SWC包包含到Flash
    Professional项目的操作指南](img/1420_09_11.jpg)
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to encrypt an application database, we will declare a password and
    encrypt it using an external encryption library. This will be used when creating
    and opening our database connection:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加密应用程序数据库，我们将声明一个密码，并使用外部加密库对其进行加密。这将用于创建和打开我们的数据库连接：
- en: 'Within our application, we will import the following classes. Be sure to import
    the `MD5` class or an equivalent for proper key encryption:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将导入以下类。确保导入`MD5`类或等效类以进行正确的密钥加密：
- en: '[PRE19]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We must now declare a number of objects for use within this application. A
    `String` constant will hold our plain text password for later encryption. Normally,
    this would be supplied by the user and is hard-coded here for simplicity. We will
    need a `SQLConnection` to create or open our database file along with a set of
    `ByteArray` objects and a `MD5` object to perform the actual encryption. Finally,
    we declare a `TextField` and `TextFormat` pair to trace out messages to the user:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在必须声明一些在此应用程序中使用的对象。一个`String`常量将保存我们的纯文本密码以供稍后加密。通常，这会由用户提供，这里为了简单起见而硬编码。我们将需要一个`SQLConnection`来创建或打开我们的数据库文件，以及一组`ByteArray`对象和一个`MD5`对象来执行实际的加密。最后，我们声明一个`TextField`和`TextFormat`对，以向用户输出跟踪消息：
- en: '[PRE20]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will, at this point, continue to set up our `TextField`, apply a `TextFormat`,
    and add it to the `DisplayList` for textual output. Here, we create a method to
    perform all of these actions for us:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们将继续设置我们的`TextField`，应用`TextFormat`，并将其添加到`DisplayList`以进行文本输出。这里，我们创建一个方法来执行所有这些操作：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To perform the encryption of our database, we will first instantiate a `ByteArray`
    and invoke the `writeUTFBytes()` method, passing in our predefined password constant.
    This will write our `String` to the byte stream.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行我们数据库的加密，我们首先会实例化一个`ByteArray`并调用`writeUTFBytes()`方法，传递我们预定义的密码常量。这将把我们的`String`写入字节流。
- en: Now, instantiate a new `MD5` object along with another `ByteArray`, assigning
    the `ByteArray` to the result of the `MD5.hash()` method, passing in the previous
    `ByteArray` holding the password bytes.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实例化一个新的`MD5`对象以及另一个`ByteArray`，将`ByteArray`分配给`MD5.hash()`方法的结果，传递包含密码字节的先前的`ByteArray`。
- en: Instantiate an `SQLConnection` and register an event listener of type `SQLEvent.OPEN`.
    This will fire an event once the database is either created or opened successfully.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`SQLConnection`并注册一个类型为`SQLEvent.OPEN`的事件监听器。这将在数据库成功创建或打开后触发一个事件。
- en: Finally, invoke the `SQLConnection.open()` method, passing in the path to the
    database as a `File` object, the open mode constant of `SQLMode.CREATE`, an auto-compact
    `Boolean`, default page size of 1024, and most importantly for this example, our
    MD5-encrypted `ByteArray:`
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`SQLConnection.open()`方法，传递数据库路径作为`File`对象，`SQLMode.CREATE`的打开模式常量，自动压缩`Boolean`，默认页面大小为1024，以及对于此示例最重要的是，我们的MD5加密`ByteArray`：
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So long as the database is created (or opened) successfully along with valid
    encryption, the following method will fire, outputting information about the encrypted
    database to our display:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要数据库成功创建（或打开）并验证加密有效，以下方法就会触发，将有关加密数据库的信息输出到我们的显示界面：
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the application is run on our Android device, it will appear as follows.
    As the key is a truly MD5-encrypted `ByteArray`, it appears as garbled characters
    in the `TextField`, for it is no longer a plain text `String:`![How to do it...](img/1420_09_12.jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序在我们的Android设备上运行时，它将如下所示。由于密钥是一个真正MD5加密的`ByteArray`，它在`TextField`中显示为乱码字符，因为它不再是明文`String`：![如何操作...](img/1420_09_12.jpg)
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: If an application requires encryption on a database, the encryption key must
    be applied when our database is created. Implementing the `SQLConnection.open()`
    or `SQLConnection.openAsync()` methods require us to pass in an encrypted `ByteArray`
    key created using `as3Crypto` or a similar encryption library. If we ever need
    to modify the encryption key, we can use the `SQLConnection.reencrypt()` to do
    so, generating the key in the same manner as demonstrated in this recipe. Note
    that a valid encryption key must be 16 bytes in length.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序需要在数据库上进行加密，那么在创建我们的数据库时必须应用加密密钥。实现`SQLConnection.open()`或`SQLConnection.openAsync()`方法需要我们传递一个使用`as3Crypto`或类似加密库创建的加密`ByteArray`密钥。如果我们需要修改加密密钥，可以使用`SQLConnection.reencrypt()`来进行修改，以本食谱中演示的方式生成密钥。请注意，有效的加密密钥长度必须为16字节。
- en: See also...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more on working with local databases in AIR for Android, have a look through
    [Chapter 8](ch08.html "Chapter 8. Abundant Access: File System and Local Database"),
    *Abundant Access: File System and Local Database.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关在AIR for Android中使用本地数据库的更多信息，请查看[第8章](ch08.html "第8章. 丰富的访问：文件系统和本地数据库")，*丰富的访问：文件系统和本地数据库*。
