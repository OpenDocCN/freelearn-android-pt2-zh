["```kt\n-- Public Method: saveValue() --> save single-line file (replace contents)\n\nfunction saveValue( strFilename, strValue )\n  -- will save specified value to specified file\n  local theFile = strFilename\n  local theValue = strValue\n\n  local path = system.pathForFile( theFile, system.DocumentsDirectory)\n\n  -- io.open opens a file at path. returns nil if no file found\n  -- \"w+\": update mode, all previous data is erased\n  local file = io.open( path, \"w+\" )\n  if file then\n  -- write game score to the text file\n  file:write( theValue )\n  io.close( file )\n  end\nend\n\n-- Public Method: loadValue() --> load single-line file and store it into variable\n\nfunction loadValue( strFilename )\n  -- will load specified file, or create new file if it doesn't exist\n\n  local theFile = strFilename\n\n  local path = system.pathForFile( theFile, system.DocumentsDirectory)\n\n  -- io.open opens a file at path. returns nil if no file found\n  -- \"r\": read mode\n  local file = io.open( path, \"r\" )\n  if file then\n    -- read all contents of file into a string\n    -- \"*a\": reads the whole file, starting at the current position\n    local contents = file:read( \"*a\" )\n    io.close( file )\n    return contents\n  else\n    -- create file b/c it doesn't exist yet\n    -- \"w\": write mode\n    file = io.open( path, \"w\" )\n    file:write( \"0\" )\n    io.close( file )\n    return \"0\"\n  end\nend\n```", "```kt\nlocal path = system.pathForFile( \"Icon.png\", system.ResourceDirectory)\n```", "```kt\n    local highScoreText\n    local highScore\n    ```", "```kt\n      local saveValue = function( strFilename, strValue )\n        -- will save specified value to specified file\n        local theFile = strFilename\n        local theValue = strValue\n\n        local path = system.pathForFile( theFile, system.DocumentsDirectory )\n\n        -- io.open opens a file at path. returns nil if no file found\n        local file = io.open( path, \"w+\" )\n        if file then\n          -- write game score to the text file\n          file:write( theValue )\n          io.close( file )\n        end\n      end\n    ```", "```kt\n      local loadValue = function( strFilename )\n        -- will load specified file, or create new file if it doesn't exist\n\n        local theFile = strFilename\n\n        local path = system.pathForFile( theFile, system.DocumentsDirectory )\n\n        -- io.open opens a file at path. returns nil if no file found\n        local file = io.open( path, \"r\" )\n        if file then\n          -- read all contents of file into a string\n          local contents = file:read( \"*a\" )\n          io.close( file )\n          return contents\n         else\n          -- create file b/c it doesn't exist yet\n          file = io.open( path, \"w\" )\n          file:write( \"0\" )\n          io.close( file )\n           return \"0\"\n        end\n      end\n    ```", "```kt\n        if gameScore > highScore then\n          highScore = gameScore\n          local highScoreFilename = \"highScore.data\"\n          saveValue( highScoreFilename, tostring(highScore) )\n        end\n    ```", "```kt\n        highScoreText = display.newText( \"Best Game Score: \" .. tostring( highScore ), 0, 0, \"Arial\", 30 )\n        highScoreText:setTextColor( 1, 1, 1 )\t\n        highScoreText.xScale = 0.5; highScoreText.yScale = 0.5\n        highScoreText.x = 240\n        highScoreText.y = 120\n\n        gameGroup:insert( highScoreText )\n    ```", "```kt\n          local highScoreFilename = \"highScore.data\"\n          local loadedHighScore = loadValue( highScoreFilename )\n\n          highScore = tonumber(loadedHighScore)\n    ```", "```kt\n    -- Place near other game variables\n    local pauseBtn\n    local pauseBG\n\n    -- Place after gameOverSound\n    local btnSound = audio.loadSound( \"btnSound.wav\" )\n    ```", "```kt\n        local onPauseTouch = function( event )\n          if event.phase == \"release\" and pauseBtn.isActive then\n            audio.play( btnSound )\n\n            -- Pause the game\n\n            if gameIsActive then\n\n              gameIsActive = false\n              physics.pause()\n\n              local function pauseGame()\n                timer.pause( startDrop )\n                print(\"timer has been paused\")\n              end\n              timer.performWithDelay(1, pauseGame)\n\n              -- SHADE\n              if not shade then\n                shade = display.newRect( 0, 0, 570, 380 )\n                shade:setFillColor( 0, 0, 0 )\n                shade.x = 240; shade.y = 160\n                gameGroup:insert( shade )\n              end\n              shade.alpha = 0.5\n\n              -- SHOW MENU BUTTON\n              if pauseBG then\n                pauseBG.isVisible = true\n                pauseBG.isActive = true\n                pauseBG:toFront()\n              end\n\n              pauseBtn:toFront()\n    ```", "```kt\n              else\n\n                if shade then\n                  display.remove( shade )\n                  shade = nil\n                end\n\n                if pauseBG then\n                  pauseBG.isVisible = false\n                  pauseBG.isActive = false\n                end\n\n                gameIsActive = true\n                physics.start()\n\n                local function resumeGame()\n                timer.resume( startDrop )\n                print(\"timer has been resumed\")\n              end\n              timer.performWithDelay(1, resumeGame)\n\n            end\n          end\n        end\n    ```", "```kt\n        pauseBtn = ui.newButton{\n          defaultSrc = \"pausebtn.png\",\n          defaultX = 44,\n          defaultY = 44,\n          overSrc = \"pausebtn-over.png\",\n          overX = 44,\n          overY = 44,\n          onEvent = onPauseTouch,\n          id = \"PauseButton\",\n          text = \"\",\n          font = \"Helvetica\",\n          textColor = { 255, 255, 255, 255 },\n          size = 16,\n          emboss = false\n        }\n\n        pauseBtn.x = 38; pauseBtn.y = 288\n        pauseBtn.isVisible = false\n        pauseBtn.isActive = false\n\n        gameGroup:insert( pauseBtn )\n\n        pauseBG = display.newImageRect( \"pauseoverlay.png\", 480, 320 )\n        pauseBG.x = 240; pauseBG.y = 160\n        pauseBG.isVisible = false\n        pauseBG.isActive = false\n\n        gameGroup:insert( pauseBG )\n    ```", "```kt\n        pauseBtn.isVisible = true\n        pauseBtn.isActive = true\n    ```", "```kt\n        pauseBtn.isVisible = false\n        pauseBtn.isActive = false\n    ```", "```kt\n    display.setStatusBar( display.HiddenStatusBar )\n    local gameGroup = display.newGroup()\n    ```", "```kt\n    local composer = require( \"composer\" )\n    local scene = composer.newScene()\n    ```", "```kt\n    -- Called when the scene's view does not exist:\n    function scene:create ( event )\n      local gameGroup = self.view\n\n      -- completely remove loadgame's view\n      composer.removeScene( \"loadgame\" )\n\n      print( \"\\nmaingame: create event\")\n    end\n    ```", "```kt\n    -- Called immediately after scene has moved onscreen:\n    function scene:show( event )\n      local gameGroup = self.view\n    ```", "```kt\n    return gameGroup -- Code will not run if this line is not removed \n    ```", "```kt\n      print( \"maingame: show event\" )\n\n    end\n    ```", "```kt\n    -- Called when scene is about to move offscreen:\n    function scene:hide( event )\n\n      print( \"maingame: hide event\" )\n\n    end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying maingame's view\" )\n\n    end \n    ```", "```kt\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\n\n    return scene \n    ```", "```kt\n    display.setStatusBar( display.HiddenStatusBar )\n    ```", "```kt\n    -- require controller module\n    local composer = require ( \"composer\" )\n\n    -- load first screen\n    composer.gotoScene( \"loadmainmenu\" )\n    ```", "```kt\n        local onMenuTouch = function( event )\n          if event.phase == \"release\" then\n            audio.play( btnSound )\n            composer.gotoScene( \"mainmenu\", \"fade\", 500  )\n\n          end\n        end\n\n        menuBtn = ui.newButton{\n          defaultSrc = \"menubtn.png\",\n          defaultX = 60,\n          defaultY = 60,\n          overSrc = \"menubtn-over.png\",\n          overX = 60,\n          overY = 60,\n          onEvent = onMenuTouch,\n          id = \"MenuButton\",\n          text = \"\",\n          -- Can use any font available per platform\n          font = \"Helvetica\",   \n          textColor = { 255, 255, 255, 255 },\n          size = 16,\n          emboss = false\n        }\n\n        menuBtn.x = 100; menuBtn.y = 260\n\n        gameGroup:insert( menuBtn )\n    ```", "```kt\n    local composer = require( \"composer\" )\n    local scene = composer.newScene()\n    ```", "```kt\n    local myTimer\n    local loadingImage\n\n    -- Called when the scene's view does not exist:\n    function scene:create( event )\n      local sceneGroup = self.view\n\n      print( \"\\nloadmainmenu: create event\" )\n    end\n    ```", "```kt\n      -- Called immediately after scene has moved onscreen:\n    function scene:show( event )\n      local sceneGroup = self.view\n\n      print( \"loadmainmenu: show event\" )\n    ```", "```kt\n      loadingImage = display.newImageRect( \"loading.png\", 480, 320)\n      loadingImage.x = 240; loadingImage.y = 160\n      sceneGroup:insert( loadingImage )\n    ```", "```kt\n        local goToMenu = function()\n          composer.gotoScene( \"mainmenu\", \"zoomOutInFadeRotate\", 500)\n        end\n    ```", "```kt\n        myTimer = timer.performWithDelay( 1000, goToMenu, 1 )\n      end\n    ```", "```kt\n    -- Called when scene is about to move offscreen:\n    function scene:hide()\n\n      if myTimer then timer.cancel( myTimer ); end\n\n      print( \"loadmainmenu: hide event\" )\n\n    end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying loadmainmenu's view\" )\n    end\n    ```", "```kt\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\n\n    return scene\n    ```", "```kt\n    local composer = require( \"composer\" )\n    local scene = composer.newScene()\n\n    local myTimer\n    local loadingImage\n\n    -- Called when the scene's view does not exist:\n    function scene:create( event )\n      local sceneGroup = self.view\n\n      -- completely remove mainmenu\n      composer.removeScene( \"mainmenu\" )\n\n      print( \"\\nloadgame: create event\" )\n    end\n\n    -- Called immediately after scene has moved onscreen:\n    function scene:show( event )\n      local sceneGroup = self.view\n\n      print( \"loadgame: show event\" )\n\n      loadingImage = display.newImageRect( \"loading.png\", 480, 320)\n      loadingImage.x = 240; loadingImage.y = 160\n      sceneGroup:insert( loadingImage )\n\n      local changeScene = function()\n        composer.gotoScene( \"maingame\", \"flipFadeOutIn\", 500 )\n      end\n      myTimer = timer.performWithDelay( 1000, changeScene, 1 )\n\n    end\n\n    -- Called when scene is about to move offscreen:\n    function scene:hide()\n\n      if myTimer then timer.cancel( myTimer ); end\n\n      print( \"loadgame: hide event\" )\n\n    end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying loadgame's view\" )\n    end\n\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\n\n    return scene\n    ```", "```kt\n    local composer = require( \"composer\" )\n    local scene = Composer.newScene()\n\n    local ui = require(\"ui\")\n\n    local btnAnim\n\n    local btnSound = audio.loadSound( \"btnSound.wav\" )\n    ```", "```kt\n    -- Called when the scene's view does not exist:\n    function scene:create( event )\n      local sceneGroup = self.view\n\n      -- completely remove maingame and options\n      composer.removeScene( \"maingame\" )\n      composer.removeScene( \"options\" )\n\n      print( \"\\nmainmenu: create event\" )\n    end\n    ```", "```kt\n    -- Called immediately after scene has moved onscreen:\n    function scene:show( event )\n      local sceneGroup = self.view\n\n      print( \"mainmenu: show event\" )\n\n      local backgroundImage = display.newImageRect( \"mainMenuBG.png\", 480, 320 )\n      backgroundImage.x = 240; backgroundImage.y = 160\n      sceneGroup:insert( backgroundImage )\n    ```", "```kt\n      local playBtn\n\n      local onPlayTouch = function( event )\n        if event.phase == \"release\" then\n\n          audio.play( btnSound )\n          composer.gotoScene( \"loadgame\", \"fade\", 300  )\n\n        end\n      end\n\n      playBtn = ui.newButton{\n        defaultSrc = \"playbtn.png\",\n        defaultX = 100,\n        defaultY = 100,\n        overSrc = \"playbtn-over.png\",\n        overX = 100,\n        overY = 100,\n        onEvent = onPlayTouch,\n        id = \"PlayButton\",\n        text = \"\",\n        font = \"Helvetica\",\n        textColor = { 255, 255, 255, 255 },\n        size = 16,\n        emboss = false\n      }\n\n      playBtn.x = 240; playBtn.y = 440\n        sceneGroup:insert( playBtn )\n    ```", "```kt\n    btnAnim = transition.to( playBtn, { time=1000, y=260, transition=easing.inOutExpo } )\n    ```", "```kt\n    local optBtn\n\n      local onOptionsTouch = function( event )\n        if event.phase == \"release\" then\n\n          audio.play( btnSound )\n          composer.gotoScene( \"options\", \"crossFade\", 300)\n\n        end\n      end\n\n      optBtn = ui.newButton{\n        defaultSrc = \"optbtn.png\",\n        defaultX = 60,\n        defaultY = 60,\n        overSrc = \"optbtn-over.png\",\n        overX = 60,\n        overY = 60,\n        onEvent = onOptionsTouch,\n        id = \"OptionsButton\",\n        text = \"\",\n        font = \"Helvetica\",\n        textColor = { 255, 255, 255, 255 },\n        size = 16,\n        emboss = false\n      }\n      optBtn.x = 430; optBtn.y = 440\n      sceneGroup:insert( optBtn )\n    ```", "```kt\n      btnAnim = transition.to( optBtn, { time=1000, y=280, transition=easing.inOutExpo } )\n\n    end\n    ```", "```kt\n    -- Called when scene is about to move offscreen:\n    function scene:hide()\n\n      if btnAnim then transition.cancel( btnAnim ); end\n\n      print( \"mainmenu: hide event\" )\n\n    end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying mainmenu's view\" )\n    end\n    ```", "```kt\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\n\n    return scene\n    ```", "```kt\n    local composer = require( \"composer\" )\n    local scene = composer.newScene()\n\n    local ui = require(\"ui\")\n\n    local btnAnim\n\n    local btnSound = audio.loadSound( \"btnSound.wav\" )\n    ```", "```kt\n    -- Called when the scene's view does not exist:\n    function scene:create( event )\n      local sceneGroup = self.view\n\n      -- completely remove mainmenu and creditsScreen\n      composer.removeScene( \"mainmenu\" )\n      composer.removeScene( \"creditsScreen\" )\n\n      print( \"\\noptions: create event\" )\n    end\n    ```", "```kt\n    -- Called immediately after scene has moved onscreen:\n    function scene:show( event )\n      local sceneGroup = self.view\n\n      print( \"options: show event\" )\n\n      local backgroundImage = display.newImageRect( \"optionsBG.png\", 480, 320 )\n      backgroundImage.x = 240; backgroundImage.y = 160\n      sceneGroup:insert( backgroundImage )\n    ```", "```kt\n      local creditsBtn\n\n      local onCreditsTouch = function( event )\n        if event.phase == \"release\" then\n\n          audio.play( btnSound )\n          Composer.gotoScene( \"creditsScreen\", \"crossFade\", 300 )\n\n        end\n      end\n\n      creditsBtn = ui.newButton{\n        defaultSrc = \"creditsbtn.png\",\n        defaultX = 100,\n        defaultY = 100,\n        overSrc = \"creditsbtn-over.png\",\n        overX = 100,\n        overY = 100,\n        onEvent = onCreditsTouch,\n        id = \"CreditsButton\",\n        text = \"\",\n        font = \"Helvetica\",\n        textColor = { 255, 255, 255, 255 },\n        size = 16,\n        emboss = false\n      }\n\n      creditsBtn.x = 240; creditsBtn.y = 440\n      sceneGroup:insert( creditsBtn )\n\n      btnAnim = transition.to( creditsBtn, { time=1000, y=260, transition=easing.inOutExpo } )\n    ```", "```kt\n      local closeBtn\n\n      local onCloseTouch = function( event )\n        if event.phase == \"release\" then\n          audio.play( tapSound )\n          composer.gotoScene( \"mainmenu\", \"zoomInOutFadeRotate\", 500 ) \n        end\n      end\n\n      closeBtn = ui.newButton{\n        defaultSrc = \"closebtn.png\",\n        defaultX = 60,\n        defaultY = 60,\n        overSrc = \"closebtn-over.png\",\n        overX = 60,\n        overY = 60,\n        onEvent = onCloseTouch,\n        id = \"CloseButton\",\n        text = \"\",\n        font = \"Helvetica\",\n        textColor = { 255, 255, 255, 255 },\n        size = 16,\n        emboss = false\n      }\n\n      closeBtn.x = 50; closeBtn.y = 280\n      sceneGroup:insert( closeBtn ) \n    end\n    ```", "```kt\n    -- Called when scene is about to move offscreen:\n    function scene:hide()\n\n      if btnAnim then transition.cancel( btnAnim ); end\n\n      print( \"options: hide event\" )\n\n    end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying options's view\" )\n    end\n\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\t\n\n    return scene\n    ```", "```kt\n    local composer = require( \"composer\" )\n    local scene = composer.newScene()\n\n    local backgroundImage\n    ```", "```kt\n    -- Called when the scene's view does not exist:\n    function scene:create( event )\n      local sceneGroup = self.view\n\n      -- completely remove options\n      composer.removeScene( \"options\" )\n\n      print( \"\\ncreditsScreen: create event\" )\n    end\n    ```", "```kt\n    -- Called immediately after scene has moved onscreen:\n    function scene:show( event )\n      local sceneGroup = self.view\n\n      print( \"creditsScreen: show event\" )\n\n      backgroundImage = display.newImageRect( \"creditsScreen.png\", 480, 320 )\n      backgroundImage.x = 240; backgroundImage.y = 160\n      sceneGroup:insert( backgroundImage )\n    ```", "```kt\n      local changeToOptions = function( event )\n        if event.phase == \"began\" then\n\n          composer.gotoScene( \"options\", \"crossFade\", 300  )\n\n        end\n      end\n\n      backgroundImage:addEventListener( \"touch\", changeToOptions)\n    end\n    ```", "```kt\n    -- Called when scene is about to move offscreen:\n    function scene:hide()\n\n      print( \"creditsScreen: hide event\" )\n\n    end\n\n    -- Called prior to the removal of scene's \"view\" (display group)\n    function scene:destroy( event )\n\n      print( \"destroying creditsScreen's view\" )\n    end\n\n    -- \"create\" event is dispatched if scene's view does not exist\n    scene:addEventListener( \"create\", scene )\n\n    -- \"show\" event is dispatched whenever scene transition has finished\n    scene:addEventListener( \"show\", scene )\n\n    -- \"hide\" event is dispatched before next scene's transition begins\n    scene:addEventListener( \"hide\", scene )\n\n    -- \"destroy\" event is dispatched before view is unloaded, which can be\n    scene:addEventListener( \"destroy\", scene )\n\n    return scene\n    ```"]