- en: 'Chapter 3. Movement through Space: Accelerometer and Geolocation Sensors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting whether or not an Android device supports the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting Android device movement in 3D space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the accelerometer sensor update interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating display object position through accelerometer sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between portrait and landscape based upon device tilt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting whether or not a device supports a geolocation sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting whether the geolocation sensor has been disabled by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving device geolocation sensor data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the geolocation sensor update interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving map data through geolocation coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android devices are not only equipped with touch panels, virtual keyboards,
    and other input mechanisms, but they also include sensors such as accelerometer
    for detecting change in 3D space, and geolocation on both a fine (satellite) and
    coarse (triangulation) level. This chapter will examine how to tap into these
    sensors in meaningful ways within Flash platform-based Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: All of the recipes in this chapter are represented as pure ActionScript 3 classes
    and are not dependent upon external libraries or the Flex framework. Therefore,
    we will be able to use these examples in any IDE we wish.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting whether or not an Android device supports the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing projects which target the Android operating system, it is always
    a good idea to make sure that certain sensors, such as the accelerometer, are
    actually supported on the device. In the case of an Android phone, this will probably
    always be the case, but we should never assume the capabilities of any device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to use Accelerometer API classes to detect whether or not an accelerometer
    is supported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, simply invoke `Accelerometer.isSupported` to confirm support for this
    capability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This invocation will return a Boolean value of `true` or `false`, indicating
    device support for this sensor:![How to do it...](img/1420_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detecting whether the device includes an accelerometer sensor will determine
    whether or not a user can effectively utilize an application that is dependent
    upon such data. If our query returns as false, then it is up to us to notify the
    user or provide some sort of alternative to gathering accelerometer data from
    the device as a form of interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Android device movement in 3D space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Accelerometer` class works in tandem with the device's motion sensor to
    measure and report movement and acceleration coordinates as the device is moved
    through 3D space. To measure this data and react to these measurements, we must
    perform certain actions to allow the gathering of accelerometer data within our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to employ certain ActionScript classes to allow monitoring of
    accelerometer feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device, along with an `Accelerometer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must now instantiate an `Accelerometer` object to register an `AccelerometerEvent`
    listener to. In this case, we will have it invoke a function called `movementDetected.`
    We also first check to see whether or not the `Accelerometer API` is actually
    supported on the device by checking the `Accelerometer.isSupported` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now able to monitor and respond to device movement through the `movementDetected`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output will look similar to this:![How to do it...](img/1420_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By registering an event listener to `AccelerometerEvent.UPDATE` we are able
    to detect changes reported by the movement sensor on an Android device. There
    are four properties that are reported back through this event: `accelerationX,
    accelerationY, accelerationZ`, and `timestamp`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`accelerationX:` A `Number` which measures acceleration along the x-axis, which
    runs from left to right when the device is placed in an upright position. A positive
    acceleration is indicated when the device is moved to the right. Leftward movement
    is presented as a negative number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accelerationY:` A `Number` which measures acceleration along the y-axis, which
    runs from bottom to top when the device is placed in an upright position. A positive
    acceleration is indicated when the device is moved upwards. Downward movement
    is presented as a negative number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accelerationZ:` A `Number` which measures acceleration along the z-axis, which
    runs perpendicular to the face of the device. A positive acceleration is indicated
    when the device is moved so that the face points skyward. Movement positioning
    the face at an earthward angle will be represented as a negative number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timestamp:` An `int` which measures the amount of milliseconds since the application
    has been initialized. This can be used to track update events over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The accelerometer is often used when creating balance-based games on Android
    such as having a ball travel through a maze based upon device tilt, but we can
    use this data in any way we wish to monitor changes in space, tilt, or other movement-based
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the accelerometer sensor update interval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the default accelerometer sensor update interval may be just fine for
    most applications, what if we would like to speed up or slow down this interval
    for a specific purpose?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to change the accelerometer sensor update interval using methods
    included with the `Accelerometer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll now declare a number of objects to use in the example. First, a `TextField`
    and `TextFormat` object pair to allow visible output upon the device, along with
    an `Accelerometer` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we will need to also employ a `Number` to keep track of our interval amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also needed are two `Sprite` objects for the user to interact with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To detect user input through touch, we will create two `Sprite` instances and
    add each to the `Stage`. To differentiate between `Sprite` instances in any event
    listener we register with these objects, we will provide a unique `name` property
    upon each `Sprite:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also first check to see whether or not the Accelerometer API is actually
    supported on the device by checking the `Accelerometer.isSupported` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then need to set the specific input mode for the multitouch APIs to
    support touch input by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT`
    constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each Sprite will register a `TouchEvent.TOUCH_TAP` listener so that it will
    be able to invoke a method to shift the update interval upon touch tap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can instantiate an `Accelerometer` object and invoke the `setRequestedUpdateInterval`
    method, which requires an interval measured in milliseconds to be passed into
    the method call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll also register an event listener to respond to any device movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `shiftInterval` method will now respond to any touch taps intercepted by
    the two `Sprite` boxes we created. We are checking to see what `name` property
    has been given to each `Sprite` and shift the `accelerometerInterval` accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The accelerometer sensor update interval will now invoke the following function,
    which will output detected movement and interval data through our `TextField:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By setting the accelerometer update interval through `setRequestedUpdateInterval()`,
    we are able to adjust this interval based upon circumstances in our particular
    application. In the preceding demonstration class, we have rendered two `Sprites`
    acting as an increase and decrease `TouchEvent.TOUCH_TAP` event receptors. Tapping
    upon these `DisplayObjects` will either increase or decrease the accelerometer
    update interval, which is monitored through our `TextField` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the default accelerometer sensor update interval is dependent upon
    whichever device is running our application. This strategy can also be used to
    try and even out the interval across devices.
  prefs: []
  type: TYPE_NORMAL
- en: Updating display object position through accelerometer events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The accelerometer sensor can be used when creating all sorts of games or applications
    for an Android device. One of the more frequent uses of this data is to update
    the position of a `DisplayObject` on the `Stage` in response to accelerometer
    update event data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to employ certain ActionScript classes to allow monitoring of
    accelerometer feedback through a `DisplayObject` instance. In this example, we
    will employ a simple `Shape` object and change its position based upon this data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll now declare a number of objects to use in the example. First, a `TextField`
    and `TextFormat` object pair, along with a `Shape` to allow visible output upon
    the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must also declare an `Accelerometer` object in order to monitor and respond
    to device movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new `Shape` object called `box`, draw a rectangle with the `Graphics`
    API, and add it to the `Stage:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must now instantiate an `Accelerometer` object to register an `AccelerometerEvent`
    listener to. In this case, we will have it invoke a function called `movementDetected`.
    We also first check to see whether or not the Accelerometer API is actually supported
    on the device by checking the `Accelerometer.isSupported` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now able to monitor and respond to device movement through the `movementDetected`
    method by adjusting the x and y coordinates of our `Shape` object, based upon
    the `accelerationX` and `accelerationY` data reported through the `AccelerometerEvent.UPDATE`
    data being reported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following function, we are going to perform a number of checks to be
    sure our `Shape` does not move off of the `Stage` as the device is tilted. We
    will also output the x and y properties of our `Sprite` to a `TextField`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting output will appear similar to the following:![How to do it...](img/1420_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By registering an event listener to `AccelerometerEvent.UPDATE` we are able
    to detect changes reported by the movement sensor on an Android device. Using
    ActionScript, we can then respond to these changes in movement and tilt, as the
    code example demonstrates, by moving a `DisplayObject` around the screen based
    upon the reported sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, not only are we moving the `Shape` object around the screen,
    but we are also being mindful to never allow the shape to leave the screen through
    a number of conditional statements taking into account object width, height, and
    detected screen dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between portrait and landscape based upon device tilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Android devices will allow both portrait and landscape views for the user
    to interact with. The portrait mode is enabled when the device is held with the
    y-axis aligned from top to bottom, while landscape mode is enabled by holding
    the device so that the y-axis is measured from left to right. By using data reported
    from the accelerometer sensor, we can know when these movements have occurred
    and respond to them within our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to employ the `Accelerometer` API to detect device rotation and
    tilt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll now declare a number of objects to use in the example. First, a `TextField`
    and `TextFormat` object pair to allow visible output upon the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must also declare an `Accelerometer` object in order to monitor and respond
    to device movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add it to the
    `DisplayList`. Here, we create a method to perform all of these actions for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must create an `Accelerometer` instance and assign an event listener
    of type `AccelerometerEvent.UPDATE` to it. This will trigger the `movementDetected`
    method whenever a change in accelerometer data is detected. We also first check
    to see whether or not the Accelerometer API is actually supported on the device
    by checking the `Accelerometer.isSupported` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within our `movementDetected` method, we simply need to monitor the acceleration
    data reported by the sensor and adjust our application accordingly. We''ll also
    output data to our `TextField` to monitor device movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following:![How to do it...](img/1420_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the accelerometer movement is detected within our application, the `movementDetected`
    method will report data regarding the `x, y`, and `z` axis of the device. If we
    monitor the acceleration value that is reported, we can respond to device tilt
    in a way that takes into account the vertical orientation and thus know whether
    or not to adjust elements on the `Stage` for portrait or landscape viewing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are using pure ActionScript to detect accelerometer senor
    data and respond to it. When using the mobile Flex framework in developing our
    application, we can allow the framework to handle device orientation for us when
    setting up our **Flex Mobile Project** by choosing the **Automatically reorient**
    option in the **Mobile Settings** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1420_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Structural Adaptation: Handling Device Layout
    and Scaling"), *Structural Adaptation: Handling Device Layout and Scaling*, also
    has more information on adapting to device orientation changes using alternative
    detection methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting whether or not a device supports a geolocation sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing projects which target the Android operating system, it is always
    a good idea to make sure that certain sensors, such as the geolocation sensor,
    are actually supported on the device. In the case of an Android device, this will
    probably always be the case, but we should never assume the capabilities of any
    device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to use internal classes to detect whether or not the geolocation
    API is supported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, simply invoke `Geolocation.isSupported` to confirm support for this capability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This invocation will return a Boolean value of `true` or `false`, indicating
    device support for this sensor. This result will be output to the `TextField`
    we created:![How to do it...](img/1420_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detecting whether the device includes a geolocation sensor will determine whether
    or not a user can effectively utilize an application that is dependent upon such
    data. If our query returns as false, then it is up to us to notify the user or
    provide some sort of alternative to gathering such data from the user. This is
    normally handled by the user inputting specific location data manually.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The availability of the geolocation sensors must be requested by the application
    developer through an Android manifest file. In order for our application to use
    these sensors, permissions must be stated within the manifest file. See [Chapter
    9](ch09.html "Chapter 9. Manifest Assurance: Security and Android Permissions"),
    *Manifest Assurance: Security and Android Permissions*, for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting whether the geolocation sensor has been disabled by the user
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why the Android geolocation sensor may not be available
    for use in our application. The user could have simply switched this sensor off
    to conserve battery life, or perhaps we, as developers, did not provide adequate
    permissions through the Android manifest file to allow geolocation access. In
    any case, it is a good idea to check and respond with a kind prompt if the sensor
    has been disabled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to check the `muted` property included with the `Geolocation`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device along with a `Geolocation` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we must instantiate a `Geolocation` instance and register an event listener
    to determine whether geolocation becomes disabled while our application is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We could also simply check the `muted` property at any time now that we have
    defined a `Geolocation` instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we invoke the method, check the muted property. If this returns `true`,
    we can access the device geolocation sensor; if it returns `false`, then we know
    the sensor has been disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will be output to the device screen as shown in the following screenshot:![How
    to do it...](img/1420_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we construct a `Geolocation` instance, we then are able to access the `muted`
    property of that class. By checking the `muted` property of a `Geolocation` object,
    we can either disable geolocation features in our application, prompt the user
    to manually enter their location, or simply notify the user that they must enable
    the geolocation sensor on the device in order to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in our example, the `Geolocation` object can have a `status`
    event registered to it, which will alert us when the `muted` property changes.
    We can use this to detect changes in the property while running the application
    and respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The availability of the geolocation sensors must be requested by the application
    developer through an Android manifest file. In order for our application to use
    these sensors, permissions must be stated within the manifest file. See [Chapter
    9](ch09.html "Chapter 9. Manifest Assurance: Security and Android Permissions")
    for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving device geolocation sensor data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Geolocation` class can be used to reveal a full set of properties for tracking
    device position on the globe. This is useful for mapping, weather, travel, and
    other location-aware applications. To measure this data and react to these measurements,
    we must perform certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to employ certain ActionScript classes to allow monitoring of
    geolocation feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextField` and `TextFormat` object pair to allow visible output
    upon the device along with a `Geolocation` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must now instantiate a `Geolocation` object to register a `GeolocationEvent`
    listener to. In this case, we will have it invoke a function called `geolocationUpdate`.
    We also first check to see whether or not the Geolocation API is actually supported
    on the device by checking the `Geolocation.isSupported` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now able to monitor and respond to device movement through the `geolocationUpdate`
    method. In this case, we are outputting the collected data to a `TextField:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output will look something like this:![How to do it...](img/1420_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By registering an event listener to `GeolocationEvent.UPDATE` we are able to
    detect changes reported by the geolocation sensor on an Android device. Note that
    not every Android device will be able to report upon all of these properties;
    it will vary based upon device being used. There are eight possible properties
    that are reported back through this event: `altitude, heading, horizontalAccuracy,
    latitude, longitude, speed, timestamp`, and `verticalAccuracy`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`altitude:` A `Number` measuring current altitude, in meters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heading:` A `Number` representative of the direction of movement, in degrees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`horizontalAccuracy:` A `Number` measuring the horizontal accuracy of the sensor
    measurement, in meters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`latitude:` A `Number` representative of the current device latitude, in degrees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longitude:` A `Number` representative of the current device longitude, in
    degrees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speed:` A `Number` measuring speed in meters per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timestamp:` An `int` representative of the number of milliseconds since application
    initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalAccuracy:` A `Number` measuring the vertical accuracy of the sensor
    measurement, in meters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the geolocation sensor update interval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the default geolocation sensor update interval may be just fine for most
    applications, what if we would like to speed up or slow down this interval for
    a specific purpose?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to change the geolocation sensor update interval using methods
    included with the `Geolocation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll now declare a number of objects to use in the example. First, a `TextField`
    and `TextFormat` object to allow visible output upon the device, along with an
    `Geolocation` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we will need to also employ a `Number` to keep track of our interval amount.
    Also needed are two `Sprite` objects for the user to interact with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To detect user input through touch, we will create two `Sprite` instances and
    add each to the `Stage`. To differentiate between `Sprite` instances in any event
    listener we register with these objects, we will provide a unique name property
    upon each `Sprite:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first check to see whether or not the Geolocation API is actually supported
    on the device by checking the `Geolocation.isSupported` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then need to set the specific input mode for the multitouch APIs to
    support touch input by setting `Multitouch.inputMode` to the `MultitouchInputMode.TOUCH_POINT`
    constant. Each `Sprite` will register a `TouchEvent.TOUCH_TAP` listener so that
    it will be able to invoke a method to shift the update interval upon touch tap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can also instantiate a `Geolocation` object and invoke the `setRequestedUpdateInterval`
    method, which requires an interval measured in milliseconds to be passed into
    the method call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll register an event listener to respond to any device movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `shiftInterval` method will now respond to any touch taps intercepted by
    the two `Sprite` boxes we created. We are checking to see what name property has
    been given to each `Sprite` and shift the `accelerometerInterval` accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The geolocation sensor update interval will now invoke the following function
    which will output detected movement and interval data through our `TextField:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will appear similar to the following screenshot:![How to do it...](img/1420_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By setting the geolocation update interval through `setRequestedUpdateInterval()`,
    we are able to adjust this interval based upon circumstances in our particular
    application. In the `demonstration` class in the preceding section, we have rendered
    two `Sprites` acting as an increase and decrease `TouchEvent.TOUCH_TAP` event
    receptors. Tapping upon these `DisplayObjects` will either increase or decrease
    the geolocation update interval, which is monitored through our `TextField` on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the default geolocation sensor update interval is dependent upon whichever
    device is running our application. This strategy can also be used to try and even
    out the interval across devices. Some things, however, are totally out of our
    control. For instance, if a user is located deep inside of a building and has
    a poor GPS signal, the update interval can actually be well over a minute. Various
    factors such as this should be kept in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving map data through geolocation coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve a map through the use of geolocation coordinates is one of the fundamental
    uses of the ActionScript Geolocation API. In this recipe, we will examine how
    to render a map on the Stage and generate a marker based on latitude and longitude
    coordinates reported by the device geolocation sensors using the Google Maps API
    for Flash.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few steps we will need to take before getting into the recipe itself.
    These steps will prepare our project with the proper code libraries and allow
    us access to the Google Maps services:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must download the Google Maps API for Flash from [http://code.google.com/apis/maps/documentation/flash/](http://code.google.com/apis/maps/documentation/flash/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package will include two separate `.swc` files. One for Flex, and the other
    for ActionScript projects. In this example, we will extract the pure `AS3 .swc`
    to our local hard drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the same URL (in the first point) click on the link that reads **Sign up
    for a Google Maps API Key** to generate an API key and register a URL. You will
    need both of these items to complete the example.![Getting ready...](img/1420_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, include the Google Maps SDK into your development environment by either
    adding the .swc through the **ActionScript Build Path** properties dialog in the
    case of Flash Builder (you can also simply drag the `.swc` into the `libs` directory)
    or FDT or through the **Advanced ActionScript Properties** dialog in Flash Professional:![Getting
    ready...](img/1420_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to proceed with the recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to create our map `DisplayObject`, generate event listeners for
    `Geolocation` API updates, and adjust map properties based upon our current location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the following classes into your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will want to import a number of classes included in the Google Maps
    SDK. These classes will allow us to render a `Map` on the `Stage`, listen for
    map-specific events, and render a `Marker` on our current location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now create a number of object references to be used in this example.
    First, a `TextField` and `TextFormat` object pair to allow visible output upon
    the device, along with a `Geolocation` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we will need to also employ `Map` and `LatLng` objects to render a map
    of our location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to create our `Map` by passing in the API key and URL we set
    up when registering with Google, and adding the `Map` to the display list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now set up our `TextField`, apply a `TextFormat`, and add the `TextField`
    to the `DisplayList`. Here, we create a method to perform all of these actions
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is important that we register listeners for both geolocation updates, and
    `Map` completion events, so that we are able to read coordinate data, and know
    when our `Map` is ready for interaction. We also first check to see whether or
    not the Geolocation API is actually supported on the device by checking the `Geolocation.isSupported`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the geolocation updates are being handled locally, this will most likely
    be our first event listener to fire. We will grab the `longitude` and `latitude`
    from data provided by the device geolocation sensor through this event and create
    a `LatLong` object from this which will be fed into the `Map` upon initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once our `mapReady` listener method fires, we will already have the coordinate
    information needed to display our current coordinates through the `Map` and also
    render a simple `Marker` at this precise location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will look similar to this:![How to do it...](img/1420_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By tapping into a mapping service such as Google Maps, we can listen for local
    device geolocation updates and feed the necessary data into the mapping service
    to perform numerous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this example, we simply center the `Map` to our device coordinates
    and place a `Marker` overlay upon the `Map`. Whenever you are using a service
    such as this, it is always a good idea to thoroughly read the documentation to
    know both the possibilities and limitation n of the service.
  prefs: []
  type: TYPE_NORMAL
- en: The `url` property should be set to an online location where the purpose and
    scope of the application is described, as per Google's request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are setting the `sensor` property of our `Map` instance to `true`. This is
    required if the `Map` is reacting to data based upon device geolocation sensors
    by Google. If we were simply allowing the user to input coordinates and adjust
    the `Map` location in that way, we would set the `sensor` property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we are using the Google Maps API for Flash. It is quite robust,
    but you may want to use another mapping system such as Yahoo! Maps, MapQuest,
    or some other service. That is fine since they will all require similar information;
    only the specific API setup will differ.
  prefs: []
  type: TYPE_NORMAL
