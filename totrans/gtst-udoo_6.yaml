- en: Chapter 6. Building a Chronotherm for Home Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 为智能家居构建Chronotherm电路
- en: For many decades now it has been possible, even easy, to control home devices
    such as lights, thermostats, and appliances with automatic and remote controls.
    On the one hand, these automation devices save effort and energy, but on the other
    hand, even modest adjustments are inconvenient to final users because they need
    a good knowledge of the system to make any changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，控制家庭设备如灯光、恒温器和电器已经变得可能，甚至简单，通过自动和远程控制。一方面，这些自动化设备节省了人力和能源，但另一方面，即使是微小的调整对最终用户来说也不方便，因为他们需要对系统有很好的了解才能进行任何更改。
- en: During the last few years, people were reluctant to adopt **home automation**
    technologies because of a lack of a standard or an easy-to-customize solution.
    Nowadays, things are changing and prototyping boards such as UDOO, play a great
    role during the design and the building of **DIY** (**Do It Yourself**) automated
    devices. Best of all, thanks to open source projects, these platforms are easy
    to extend and can be controlled by different devices, such as personal computers
    with web browsers, mobile phones, and tablets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，由于缺乏标准或易于定制的解决方案，人们不愿采用**智能家居**技术。如今，情况正在发生变化，UDOO等原型开发板在设计及构建**DIY**（**自己动手做**）自动化设备时发挥着重要作用。更妙的是，由于开源项目，这些平台易于扩展，并且可以被不同的设备控制，如个人电脑上的网络浏览器、手机和平板电脑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the advantages of home automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索智能家居的优势
- en: Building a chronotherm circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个chronotherm电路
- en: Sending data and receiving commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据与接收指令
- en: Writing the Chronotherm Android application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Chronotherm安卓应用程序
- en: Home automation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能家居
- en: 'The term *home automation* is quite generic and may have a lot of different
    meanings: a timer controlling ambient lights, an intelligent system that takes
    actions in response to events coming from the outside, or a programmable device
    responsible for accomplishing repetitive tasks.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “智能家居”这个词相当通用，可能有多种不同的含义：控制环境灯光的定时器，响应来自外部的各种事件做出动作的智能系统，或者负责完成重复任务的编程设备。
- en: These are all valid examples of home automation as they share the same key concept
    making us able to manage house work and activities even when we are not at home.
    Home-automated devices usually operate on public or private networks to communicate
    with each other, as well as with other kinds of devices such as smartphones or
    tablets, taking commands or exchanging information about their status. But what
    happens when we need to automate simple appliances or electronic components such
    as light bulbs? A common solution to address this problem is by developing a sort
    of **Control System** device, physically connected to the appliances we want to
    manage; being the Control System, a home-automated device, we can use it to drive
    the behavior of every appliance it is connected to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是智能家居的有效示例，因为它们共享同一个关键概念，使我们即使不在家也能管理家务和活动。智能家居设备通常在公共或私人网络上运行，以相互通信，以及与其他类型的设备如智能手机或平板电脑进行通信，接收指令或交换它们的状态信息。但当我们需要自动化简单的电器或电子元件，如灯泡时，该怎么办？解决这个问题的常见方法是通过开发一种**控制系统**设备，物理连接到我们想要管理的电器上；由于控制系统是一种智能家居设备，我们可以使用它来驱动它所连接的每个电器的行为。
- en: If we manage to get enough experience in the home-automation field, the chances
    are that we will be able to develop and build a high-end system for our own house,
    flexible enough to be easily extended without any further knowledge.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在智能家居领域积累足够的经验，我们有可能开发并构建一个高端系统，用于我们自己的房子，这个系统足够灵活，可以轻松扩展，而不需要进一步的知识。
- en: Building a chronotherm circuit
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个chronotherm电路
- en: A chronotherm is mainly composed of a *Control Unit,* that has the responsibility
    to check whether the environment temperature is below a preconfigured setpoint,
    and in this case, turn on the boiler to warm up the room. This behavior is quite
    simple, but without any further logic isn't so useful. Indeed, we can extend this
    behavior adding the *time* parameter to the chronotherm logic. In this way, users
    can define a temperature setpoint for each hour of the day, making the temperature
    check smarter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fact that in this prototype the Control Unit is the onboard Arduino is an
    implementation detail to simplify the overall design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a traditional chronotherm works and to realize it, we should:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Build the circuit with a temperature sensor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the microcontroller logic to check the users' setpoints with the current
    temperature
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, the second part is not so easy because the users'' setpoints
    should be stored in the microcontroller, and for this reason, we can delegate
    this task to our Android application saving settings in the microSD card. This
    approach decouples responsibilities in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Arduino sketch:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collects data from a temperature sensor
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends the detected temperature to Android
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Expects an Android command to start or stop the boiler
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android application:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages user's interactions
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements user's settings to store temperature setpoints for each hour of the
    day
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads the temperature sent by the microcontroller
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements the logic to choose whether the boiler should be turned on or off
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends a command to the microcontroller to start or stop the boiler
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With this plan, we can rely on the Android user interface components to easily
    implement a lean and usable interface, while avoiding the complexity of the settings
    storage layer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To start building the prototype, we need to plug into our breadboard a temperature
    sensor, such as the *TMP36*, to obtain the following circuit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a chronotherm circuit](img/1942OS_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'The following is a step-wise procedure to get the components connected, as
    shown in the preceding schema:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Put the TMP36 sensor on the right part of the breadboard.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the UDOO +3.3V pin to the positive line of the power bus. Be sure not
    to connect the +5V power pin because it may damage the analog input pins during
    future connections.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the UDOO ground to the negative line of the power bus.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left terminal of the TMP36 sensor to the positive line of the power
    bus.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When using packaged sensors, we can deduce the orientation looking at the flat
    part. Use this approach to find the left and the right terminal.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect the right terminal of the TMP36 sensor to the negative line of the power
    bus.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the middle terminal of the TMP36 sensor to the analog input A0.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This packaged sensor is really simple to use and it doesn't require any other
    components or voltage dividers to provide the voltage variation to the microcontroller.
    Now we should proceed managing the boiler ignition from our circuit. For the sake
    of the prototype, we're going to replace the boiler actuator with a simple LED,
    like we did in [Chapter 2](ch02.html "Chapter 2. Know Your Tools"), *Know your
    Tools*. This will keep our circuit simpler.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add an LED to the breadboard to achieve the following schema:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a chronotherm circuit](img/1942OS_06_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'The following is the procedure of connecting the components, as shown in the
    preceding schema:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Put the LED on the left-hand side of the breadboard.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the LED longer terminal (anode) to the UDOO digital pin 12.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the LED smaller terminal (cathode) to the negative line of the power
    bus, using a 220 Ohm resistor.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this circuit, we have all the components required to collect data from
    the environment and to simulate a boiler ignition. Now we need to open the Arduino
    IDE and start a new sketch. The first goal is to retrieve and convert the detected
    temperature into a convenient unit of measurement. To achieve this goal, we have
    to perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Define these object-like macros and variables at the top of the sketch:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We define the `SENSOR` object to represent the analog pin A0 while the `BOILER`
    object is related to our digital pin 12\. We also declare a `reading` variable
    that we use later to store the current detected temperature. The `TEMPERATURE_POLL_PERIOD`
    macro represents how many seconds the microcontroller waits between readings and
    before it notifies the Android application with the detected temperature.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `setup()` function, add the pin mode declaration and open the serial
    communication as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the bottom of the sketch, create the `convertToCelsius()`function as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this function, we expect a sensor reading and return its representation in
    *Celsius degrees*. To achieve this, we're using a little math to figure out what
    the real detected voltage is. Because the analog to digital converters of the
    UDOO microcontroller provide values in the range [0-1023], but we want to calculate
    the range from 0 to 3.3V, we should divide the value by 1024.0 and then multiply
    the result by 3.3.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the voltage in the Celsius conversion because if we read the TMP36 datasheet,
    we find that every 10 millivolts of change from the sensor is equivalent to a
    temperature change of 1 Celsius degree and this is why we multiply the value by
    100\. We also need to subtract the voltage by 0.5 because this sensor handles
    temperatures below 0 degrees, and 0.5 is the chosen offset.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This function easily converts TMP36 readings into Celsius degrees. If you want
    to use another unit of measurement, such as Fahrenheit, or if you use a different
    sensor or thermistor, you have to change this implementation.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the main `loop()` function, read the analog signal from the sensor and use
    the `loop()` function to print the converted result:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we upload the sketch and open the serial monitor, we''ll notice the current
    room temperature. Indeed, if we put our finger around the sensor, we will see
    an increase in the previously detected temperature immediately. The following
    screenshot is an example of the sketch output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a chronotherm circuit](img/1942OS_06_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Sending data and receiving commands
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to enable the ADK communication as usual, and we need to add
    the *accessory descriptor* code at the top of the sketch as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have to send the detected float temperature back to the Android application,
    like we did in [Chapter 5](ch05.html "Chapter 5. Managing Interactions with Physical
    Components"), *Managing Interactions with Physical Components*. To load the buffer
    with a float number and send the value through the internal bus, we have to add
    a `writeToAdk()` helper function with the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding function expects a float temperature converted from the sensor
    reading. We use the `sprintf()` function call to fill a temporary buffer and then
    use the `memcpy()` function to replace the ADK buffer content with the `tempBuffer`
    variable. When the loading is done, we send the buffer contents to the Android
    application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'During the main `loop()` function, we also need to listen to any commands sent
    by Android that describe the need to turn on or off the boiler. For this reason,
    we need to create an executor function like we did in [Chapter 2](ch02.html "Chapter 2. Know
    Your Tools"), *Know your Tools*. Then, we have to read commands from the ADK and
    pass the result to the executor. To achieve this, we need to perform the following
    steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `executor()` function that reads a command and turns the external device
    on or off:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the `executeFromAdk()` function that reads a command from the ADK and passes
    that command to the preceding `executor()` function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we take a look at the plan defined at the beginning of the chapter, we have
    all the required components for the Arduino sketch, so we can put everything together
    in the main `loop()` function using the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the ADK is ready, we read the sensor value and write its Celsius degrees
    conversion in the ADK buffer. We then expect a command from the ADK and, if it's
    available, we execute that command turning the boiler on or off. Now that the
    sketch is completed, we can proceed writing the Chronotherm Android application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Managing the chronotherm through Android
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're building physical applications through the UDOO platform, we have
    to bear in mind that we can make use of Android components and services to enhance
    the quality of our projects. Moreover, Android UI elements are more user-friendly
    and maintainable than the hardware counterpart. For this reason, we will create
    a software component to manage temperature setpoints instead of the use of potentiometers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: To begin the application prototyping, open Android Studio and start a new application
    named **Chronotherm** with Android API 19\. During the bootstrap process, choose
    a **Blank Activity** called *Overview*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the ADK Toolkit
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we proceed with the application layout, we need to configure the ADKToolkit
    for internal communication. Remember to follow these reminders to achieve the
    correct configuration:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Add the *ADKToolkit* library dependency in the `app/build.gradle` file.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sync your Gradle configuration.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the accessory filter file `usb_accessory_filter.xml` under `res/xml/`
    with the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add the *USB accessory support* option requirement and the *USB accessory intent
    filter* option in the `AndroidManifest.xml` file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Overview.java` class file, declare the `AdkManager` object at the top
    of the class.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `AdkManager` object initialization inside the `onCreate()` method of
    the `Overview` activity class.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `onResume()` activity callback to start the ADK connection when
    the activity is opening. In this project, we don't close the ADK connection in
    the `onPause()` callback because we will use two different activities and the
    connection should remain active.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the ADK communication up and running, we may proceed and write the Chronotherm
    user interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Android user interface
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is designing the Chronotherm application''s user interface to
    handle the proper feedback together with setpoints management. We will achieve
    these requirements writing two different Android activities with the following
    responsibilities:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: An *Overview* activity showing the current time, the detected temperature, and
    the current boiler status. It should include a widget showing the user's setpoints
    for each hour of the day. These setpoints are used to decide whether to turn the
    boiler on or off.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Settings* activity used to change the current setpoints for each hour of
    the day. This activity should use the same widget of the `Overview` activity to
    represent the temperature setpoints.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We begin the implementation starting with the `Overview` activity and the temperature
    setpoints widget.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Overview activity
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This activity should provide all details regarding the current status of the
    Chronotherm application. All the required components are summarized in the following
    mock-up that defines the order in which the components will be created:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the Overview activity](img/1942OS_06_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'The first step is to update the activity layout, and following the suggestion
    in the preceding mock-up, we should go through the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the layout, we could include a `TextClock` view that shows the
    current system time.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The top bar should provide a feedback for the boiler status. We can add a gray
    `TextView` with the **Active** text that becomes green when the boiler is turned
    on.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Overview` body must provide the current detected temperature. Because this
    is one of the most important details provided by the Chronotherm application,
    we will emphasize this value making it bigger than other components.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Near the room temperature, we will create a widget for the current activated
    schedule through a set of vertical bars that show the user's setpoints for each
    hour of the day. In the `Overview` activity, this widget will remain in read-only
    mode only to provide a quick overview of the active program.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the activity action bar, we should provide a menu item that opens the `Settings`
    activity. This activity will be used to store setpoints within the Chronotherm
    application.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We begin the `Overview` implementation starting from the top bar and the detected
    temperature components; the following steps are required to achieve the preceding
    layout:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `res/values/dimens.xml` file, add the following highlighted resources:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `res/values/styles.xml` file, add the following resources and change
    the `AppTheme parent` attribute as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To emphasize the current detected temperature, we can create a circle shape
    that should surround the temperature value. To realize it, create the `circle.xml`
    file under `res/drawable/` with the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now proceed and replace the layout in the `activity_overview.xml` file
    under `res/layout/`, with the following highlighted code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Place the following code in the preceding `LinearLayout` to create the activity
    top bar, which contains the current system time and the boiler status:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to create the activity body. It should contain two different
    items: the first is a `LinearLayout`, where we will inflate the setpoints widget
    using the `LayoutInflater` class in the activity `onCreate()` callback, and the
    second is the current detected temperature surrounded by the circle shape we created
    before. In the root `LinearLayout`, nest the following elements:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As last steps, store all the view references in the activity code. At the top
    of the `Overview` class, add the reference for the `temperature` and `boiler_status`
    views views with the highlighted code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `Overview` `onCreate()` callback, get the references with the following
    code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These steps provide a partial layout that we will complete adding the setpoints
    widget and the settings menu item.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom UI component
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep the user interface lean, usable, and intuitive, we can use a set of
    vertical bars, such as an audio equalizer, so that users can instantly know the
    room temperature trend they want to obtain. Android ships with a built-in component
    called `SeekBar` that we can use to choose a temperature setpoint. Unfortunately,
    this component draws a horizontal bar and isn't provided with its vertical counterpart;
    for this reason, we will extend its default behavior.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android API 11 and later adds the `rotate` attribute for each component inside
    the XML. Even if we use a rotation of 270 degrees to obtain a vertical component,
    we will have some issues to correctly place one bar next to another. In this case,
    our initial efforts to customize this component will simplify our work later.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Android offers sophisticated and componentized models for building custom UI
    elements and we can delve into further details at [http://developer.android.com/guide/topics/ui/custom-components.html](http://developer.android.com/guide/topics/ui/custom-components.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SeekBar` component''s customization could be organized as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, we should create a `TemperatureBar` class implementing the
    vertical sliding behavior. Most of the changes are related to inherit the `SeekBar`
    class while switching the component width with its height.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The widget needs an XML layout to be programmatically added from our code. For
    this reason, we will create a layout that includes the `TemperatureBar` view,
    the chosen degrees and the hour related to the bar.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When any changes occur to the vertical bar component, the degrees number should
    be updated. In this step, we will create a listener that propagates bar changes
    to the degrees component providing proper feedback to the users.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our customized component that includes the `TemperatureBar` class, the degrees
    and hour views, should be programmatically created for each hour of the day. We
    will create a utility class that is responsible for inflating the component layout
    24 times adding the proper listeners.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We begin writing the vertical `SeekBar` class that could be realized with the
    following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package in your namespace called `widget`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the newly created package, add the `TemperatureBar` class that extends the
    `SeekBar` class implementation while defining the default class constructors as
    follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Continue the `TemperatureBar` class implementation, adding the draw and measure
    methods at the bottom of the class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first methods, we're switching the widget width with its height so that
    we can use this parameter to provide an accurate measurement of the component
    contents. Then we override the `onDraw()` method called by the Android system
    during component drawing, by applying a translation to the `SeekBar` canvas and
    placing it vertically. As the last step, we call the `onSizeChanged` callback
    once again to resize the component after the canvas translation.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Because we have switched the bar width and height, we need to override the
    `onTouchEvent()` method to use the component height during value calculation.
    At the bottom of the `TemperatureBar()` class, add the following callback:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们已经切换了条宽和高度，我们需要重写`onTouchEvent()`方法，以便在计算值时使用组件高度。在`TemperatureBar()`类的底部，添加以下回调：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the preceding code, we update the component progress every time an `ACTION_DOWN`,
    `ACTION_MOVE`, or `ACTION_UP` method event occurs. We don't need any other behaviors
    for the purpose of this project, so we leave the remaining implementation as it
    is.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们每次在`ACTION_DOWN`、`ACTION_MOVE`或`ACTION_UP`方法事件发生时更新组件进度。由于本项目不需要其他行为，所以我们保留其余实现不变。
- en: 'Now we can proceed writing the XML layout that hosts the preceding component
    with a degrees and hour `TextView`. Through the following steps, we can achieve
    a layout that we will inflate from our utility class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续编写承载前一个组件以及度和小时的`TextView`的XML布局。通过以下步骤，我们可以实现一个从我们的工具类中填充的布局：
- en: 'Add the `bar_height` declaration to the `dimens.xml` file under `res/values/`,
    so we can easily change it in the future if needed:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values/`下的`dimens.xml`文件中添加`bar_height`声明，这样我们可以在需要时轻松地更改它：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `temperature_bar.xml` file under `res/layout/` that contains the
    widget layout. In this file, we should add this `LinearLayout` as the root element:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout/`目录下创建`temperature_bar.xml`文件，其中包含小部件布局。在这个文件中，我们应该将此`LinearLayout`作为根元素添加：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To the preceding `LinearLayout`, include the following components:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向前一个`LinearLayout`中包含以下组件：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always change the `me.palazzetti` namespace occurrences with your own.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 始终将`me.palazzetti`命名空间替换为你的命名空间。
- en: 'Now that we have the temperature bar component and the widget layout, we need
    to create a binding between the `degrees` and the `seekbar` views. Proceed with
    the widget implementation through the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了温度条组件和小部件布局，我们需要创建一个将`degrees`和`seekbar`视图绑定的绑定。通过以下步骤进行小部件实现：
- en: Create the `DegreeListener` class in the `widget` package.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`widget`包中创建`DegreeListener`类。
- en: 'The preceding class should implement the `SeekBar` listener while storing the
    reference for the connected `degrees` view. We use this `TextView` reference to
    propagate the vertical bar value:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个类应该实现`SeekBar`监听器，同时存储连接的`degrees`视图的引用。我们使用这个`TextView`引用来传播垂直条的价值：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Propagate the progress value to the `mDegrees` view, overriding the following
    methods required by the `OnSeekBarChangeListener` interface:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将进度值传播到`mDegrees`视图，覆盖`OnSeekBarChangeListener`接口所需的以下方法：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last missing part is to provide the utility class used to inflate the widget
    layout initializing the `TemperatureBar` class with the `DegreeListener` class.
    The inflate process should be repeated for each hour of the day and it needs the
    reference of the layout in which the widget will be inflated. To complete the
    implementation, go through the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺失的部分是提供一个工具类，用于初始化带有`DegreeListener`类的`TemperatureBar`类来填充小部件布局。该填充过程应针对一天的每个小时重复进行，并且需要引用小部件将被填充的布局。要完成实现，请按照以下步骤操作：
- en: Create the `TemperatureWidget` class in the `widget` package.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`widget`包中创建`TemperatureWidget`类。
- en: 'This class should expose a static `addTo()` method that expects the activity
    context, the parent element, and whether vertical bars should be created in read-only
    mode. In this way, we can use this widget both for visualization and edit. We
    can find the complete implementation in the following code snippet:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类应该公开一个静态的`addTo()`方法，该方法需要活动上下文、父元素以及是否应以只读模式创建垂直条。这样，我们可以将此小部件用于可视化和编辑。我们可以在以下代码片段中找到完整的实现：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At the top of the class, we're defining the generated bar's number. In the `addTo()`
    method, we inflate the `temperature_bar` layout to create an instance of the bar
    object. Then, we get all the references of `time`, `degrees`, and `seekbar` objects
    so that we can set initial values and create the `DegreeListener` class with the
    `degrees TextView` binding. We proceed adding the widget to the `parent` node,
    filling the `bars` array with the currently created bar. As the last step, we
    return this array so that it can be used from the caller activity.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finishing the Overview activity
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The setpoints widget is now completed and we can proceed with the last steps
    inflating temperature bars during the activity creation. We will also add the
    action to start the `Settings` activity in the activity menu. To complete the
    `Overview` class, follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Inflate the setpoints widget in the `Overview` `onCreate()` callback by adding
    the highlighted code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Handle the action bar menu to start the `Settings` activity, changing the `onOptionsItemSelected()`
    method as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Settings` activity is not available at the moment and we will create it
    in the next section.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ve completed the `Overview` class layout and the following screenshot is
    the obtained result:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the Overview activity](img/1942OS_06_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Writing the Settings activity
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step before implementing the logic of our chronotherm, is to create
    the `Settings` activity that can be used to change the temperature setpoints during
    the day. To bootstrap a new activity, click on **File** from the window menu and
    choose **New** to open the context menu. There, choose **Activity** and then **Blank
    Activity**. This will open a new window and we can write `Settings` in the **Activity
    Name** and then click on **Finish**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if we can use the built-in settings template with synchronized preferences,
    we're using a blank activity to keep this part as easy as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'We start designing the activity layout with the following mock-up, showing
    all the required components:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the Settings activity](img/1942OS_06_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'The first required step is to update the activity layout and, following the
    suggestion in the previous mock-up, we should:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Save** button that will call an activity method to save the selected
    setpoints from the temperature widgets.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inflate the temperature widget used during the setpoints selection.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To achieve the preceding layout, update the `activity_settings.xml` file under
    `res/layout/` with the following changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the root layout element with the following `LinearLayout`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding layout, add the widget placeholder and the **Save** button:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can complete the activity adding the widget initialization in the `Settings`
    class through the following steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted variable at the top of `Settings` class:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `onCreate()` method of the `Settings` class, add the highlighted code
    to inflate the setpoints widget:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we upload the Android application again, we can use the menu options to
    open the `Settings` activity, which presents itself as shown in the following
    screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the Settings activity](img/1942OS_06_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: The Chronotherm application's interface is completed and we can proceed managing
    the storage layer for the user's settings.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Managing user's setpoints
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chronotherm application's activities provide the required user interface
    components to show and change the user's setpoints. To let them work, we should
    implement the logic to save persistent application data. Based on our needs, we
    can use the `SharedPreferences` class to store primitive data in key-value pairs
    to provide setpoint values for the entire application. In this project, we will
    use the setpoint hour as the key and the chosen temperature as the value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SharedPreferences` class is a storage option provided by the Android framework.
    If in other projects we need a different storage, we may take a look at Android''s
    official documentation at [developer.android.com/guide/topics/data/data-storage.html](http://developer.android.com/guide/topics/data/data-storage.html).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Reading setpoints from the Overview activity
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We begin with the `Overview` activity implementing a method that reads stored
    setpoints and updates the temperature bar values. We can proceed with the following
    steps reading the user''s preferences during the activity creation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'For each bar, we set the progress with the stored value. We use `0` as the
    default when no settings are found. This implementation requires the following
    code that we should add in the `Overview` class:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We open the application's preferences and update each bar using the hour of
    the day as a key. The related hour is indirectly represented by the `i` loop counter.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the preceding method from the `onResume()` activity callback, adding the
    highlighted code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Through these steps, we've completed setpoints management in the `Overview`
    activity and we will proceed working with the `Settings` activity.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Writing setpoints from the Settings activity
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `Settings` activity, we should implement the logic to store the users
    setpoints when they click on the **Save settings** button. Moreover, when the
    activity is created, we must load the previously stored setpoints so that we can
    present the current schedule to the users before they start changing their preferences.
    To implement these functionalities, we may proceed with the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Like we did in the `Overview` activity, we need to load setpoint values and
    update temperature bars. Because we've already implemented this functionality,
    we can simply copy and paste the `readPreferences()` method as is from the `Overview`
    class to the `Settings` class.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code at the bottom of the `Settings` class to store the selected
    setpoints:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After we've retrieved and stored all setpoints using a background commit, we
    close the current activity.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `activity_settings.xml` layout file under `res/layout/`, update the
    save button so that it will call the preceding method on click, as you can see
    in the following highlighted code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This was the last step to implement the Chronotherm application interface and
    settings management. Now we can proceed implementing the required logic to read
    the detected temperature and to turn the boiler on or off.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Arduino
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application is ready to receive temperature data checking whether the boiler
    should be activated or not. The overall design is to use the `ExecutorService`
    class that runs a periodical scheduled thread and it should:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Read the detected temperature from ADK.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the boiler status checking whether the temperature is below the current
    selected setpoint.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the temperature to the main thread so that it can update the `temperature`
    `TextView`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the command to Arduino to turn the boiler on or off. This task should be
    done only if the current boiler status has changed from the previous task execution.
    In this case, it should also send the boiler status to the main thread so that
    it can update the related `TextView`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we proceed with thread implementation, we should provide a Java interface
    that exposes the required methods to update the activity''s user interface. We
    can fulfill this with the following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java interface called `OnDataChangeListener` and add the following
    code snippet:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the preceding interface to the `Overview` class using the highlighted code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the interface by writing the code that updates the current temperature
    and the boiler status TextViews:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can proceed implementing the scheduled thread, following the overall
    design explained previously:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package in your namespace called `adk`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `adk` package, add a new class named `DataReader`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class, add the following declarations:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We define the polling time for the scheduled thread and the message types used
    in the main thread handler to identify a temperature or a boiler update. We store
    the references for the `AdkManager` instance, the activity context, and the caller
    activity that implements the previous interface. Then we define the `ExecutorService`
    implementation that we will use to create short-lived threads for sensor readings.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `DataReader` constructor to set the message handler when the
    main thread receives messages from the sensor thread:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We store all the required references and then we define the main thread handler.
    Within the handler, we use the `OnDataChangeListener` callbacks to update the
    temperature or the boiler status in the view, according to the message type.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the bottom of the `DataReader` constructor, add the following `Runnable`
    method implementation that realizes the overall design previously defined:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this implementation, we create the `isBelowSetpoint()` method that checks
    whether the temperature is below the chosen setpoint for the current hour. We
    retrieve this value from the application's shared preferences.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个实现中，我们创建了一个`isBelowSetpoint()`方法，用于检查当前小时的温度是否低于所选的设定点。我们从应用程序的共享偏好设置中获取这个值。
- en: 'Add a method to the `DataReader` class to start the scheduler that spawns short-lived
    threads periodically as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DataReader`类添加一个方法，以定期创建短生命周期的线程来启动调度程序，如下所示：
- en: '[PRE43]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `stop()` method at the bottom of the class to stop the scheduler from
    spawning new threads through the `shutdown()` executor''s method:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部添加`stop()`方法，通过执行器的`shutdown()`方法停止调度程序创建新线程：
- en: '[PRE44]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we should go back to the `Overview` class to start and stop the scheduler
    within the activity lifecycle. Add the `DataReader` declaration at the top of
    the `Overview` class:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该回到`Overview`类中，在活动生命周期内开始和停止调度程序。在`Overview`类的顶部添加`DataReader`声明：
- en: '[PRE45]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Initialize the `DataReader` instance in the `onCreate()` callback through the
    following highlighted code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`回调中初始化`DataReader`实例，通过以下突出显示的代码：
- en: '[PRE46]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Start and stop the reading scheduler in the `onResume()` and `onPause()` activity''s
    callbacks, as you can see in the highlighted code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onResume()`和`onPause()`活动的回调中开始和停止读取调度程序，如突出显示的代码所示：
- en: '[PRE47]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The communication between UDOO and Android is up and running and the logic
    of our chronotherm is ready to activate and deactivate the boiler. Now, we can
    upload the Android application again, add some temperature settings, and start
    playing with the prototype. We''ve completed our prototype and the last missing
    task is to update the application version in the `app/build.gradle` file with
    a `0.1.0` version, as you can see in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: UDOO和Android之间的通信已经运行起来，我们恒温器的逻辑已经准备好激活和关闭锅炉。现在，我们可以再次上传Android应用程序，添加一些温度设置，并开始玩原型。我们已经完成了原型，最后缺少的任务是在`app/build.gradle`文件中将应用程序版本更新为`0.1.0`版本，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Improving the prototype
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进原型
- en: During this chapter we've made different design decisions making the chronotherm
    easier to implement. While this application is good proof of concept for home
    automation, we have to bear in mind that many things should be done to improve
    the quality and reliability of the prototype. This application is a classical
    scenario with a **Human-Machine Interface (HMI)** and a **Control System** implemented
    respectively, with an Android application and an Arduino microcontroller. In such
    scenarios, a driving principle of automation design is that the control unit should
    be capable of making *reasonable and safe decisions* even in the absence of the
    HMI part.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做出了不同的设计决策，使恒温器的实现更加容易。尽管这个应用程序对于家庭自动化来说是一个很好的概念验证，但我们必须牢记，还需要做很多事情来提高原型的质量和可靠性。这个应用程序是一个经典场景，分别用Android应用程序和Arduino微控制器实现了**人机界面（HMI）**和**控制系统**。在这种场景中，自动化设计的一个基本原则是，即使在没有HMI部分的情况下，控制单元也应该能够做出*合理且安全的决策*。
- en: In our case, we've decoupled responsibilities delegating the decision to turn
    the boiler on or off to the Android application. While this isn't a mission-critical
    system, with this design, we may risk that if the Android application crashes,
    the boiler remains turned on forever. A better decoupling would be using the HMI
    only for showing feedback and storing the user's setpoints, while the decision
    to change the boiler status remains in the control unit. This means that instead
    of sending on or off commands to Arduino, we should send the current setpoint
    that will be stored in the microcontroller's memory. In this way, the control
    unit could make safe choices according to the last received setpoint.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们解耦了责任，将打开或关闭锅炉的决定委托给Android应用程序。虽然这不是一个任务关键的系统，但这样的设计可能会导致如果Android应用程序崩溃，锅炉可能会永远保持开启状态。更好的解耦方式是只使用HMI显示反馈和存储用户的设定点，而改变锅炉状态的决定仍然留在控制单元中。这意味着，我们不应该向Arduino发送开或关的命令，而应该发送当前的设定点，该设定点将存储在微控制器的内存中。这样，控制单元可以根据最后收到的设定点做出安全的选择。
- en: Another improvement that we may take into account as an exercise is to implement
    a **hysteresis logic**. Our chronotherm is designed to turn the boiler on or off,
    respectively, when the detected temperature exceeds or is below the chosen setpoint.
    This behavior should be improved because with such design, when the temperature
    is stabilized around the setpoint, the chronotherm will start to turn the boiler
    on and off very frequently. We can find useful details and suggestions about applying
    hysteresis logic in control systems at [http://en.wikipedia.org/wiki/Hysteresis#Control_systems](http://en.wikipedia.org/wiki/Hysteresis#Control_systems).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以作为练习考虑的改进是实施**滞后逻辑**。我们的恒温器设计为在检测到的温度超过或低于选定设定点时分别开启或关闭锅炉。这种行为应该得到改进，因为在这种设计中，当温度稳定在设定点周围时，恒温器将开始频繁地开启和关闭锅炉。我们可以在[控制系统的滞后逻辑应用](http://en.wikipedia.org/wiki/Hysteresis#Control_systems)中找到有关详细信息和建议。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the land of home automation and how UDOO can be
    used to work out some daily tasks. You learned about the advantages of using smart
    objects that are capable of solving place and time problems when you aren't at
    home. Then, we planned a chronotherm prototype to control our living room temperature
    through a sensor. To make the device fully automated, we designed a use case where
    users can decide temperature setpoints for each hour of the day.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了智能家居领域以及如何使用UDOO解决一些日常任务。你了解了使用智能对象的优势，这些对象能够在你不在家时解决地点和时间问题。然后，我们规划了一个恒温器原型，通过传感器控制我们的客厅温度。为了使设备完全自动化，我们设计了一个用例，用户可以决定每天每个小时的温度设定点。
- en: At the beginning, we built the application circuit using a temperature sensor
    and an LED to simulate the boiler. We started programming the Android user interface
    customizing a regular UI component to fit our needs better. We started writing
    the overview activity that showed the current time, the boiler status, the current
    room temperature, and the widget with chosen setpoints for the whole day. We continued
    with the settings activity used to store the chronotherm temperature schedule.
    As the last step, we wrote a scheduled thread that reads the environment temperature
    and turns the boiler on or off, matching the detected temperature with the current
    setpoint.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们使用温度传感器和LED构建了应用电路，模拟了锅炉。我们开始编写Android用户界面程序，自定义常规UI组件以更好地满足我们的需求。我们开始编写概述活动，显示当前时间、锅炉状态、当前室温以及全天选择的设定点的小部件。接着，我们继续编写设置活动，用于存储恒温器温度计划。作为最后一步，我们编写了一个计划任务线程，读取环境温度并根据检测到的温度与当前设定点匹配来开启或关闭锅炉。
- en: In the next chapter, we will extend this prototype with new functionalities
    to enhance the human interaction thanks to a powerful set of Android APIs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用一系列强大的Android API扩展此原型，增加新功能以增强人与设备的交互。
