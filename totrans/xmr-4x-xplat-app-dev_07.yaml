- en: Chapter 7. Deploying and Testing on Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying to devices is both important and somewhat a hassle when you try it
    the first time. Certain issues will only happen on a mobile device, and cannot
    be reproduced in the iOS simulator or Android emulator. You can also test things
    that are only possible on real devices such as GPS, camera, memory limitations,
    or cellular network connectivity. There are also a few common pitfalls that exist
    when developing for Xamarin, which will only surface when testing on a physical
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: iOS provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android device settings for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ahead-of-time (AOT) compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common memory pitfalls with Xamarin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin this chapter, it is important to note that a valid iTunes account
    or iOS Developer Program membership is required to deploy to iOS devices. Feel
    free to go back to [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Xamarin Setup"),
    *Xamarin Setup*, to walk through that process.
  prefs: []
  type: TYPE_NORMAL
- en: iOS provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple has a strict process for deploying applications to iOS devices. While
    being quite convoluted and sometimes painful for developers, Apple can enable
    a certain level of security by preventing the average user from sideloading potentially
    malicious applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can deploy our application to an iOS device, there are a few things
    we will need to set up in the **iOS Dev Center**. We will begin by creating an
    App ID or bundle ID for your account. This is the primary identifier for any iOS
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by navigating to [http://developer.apple.com/account](http://developer.apple.com/account)
    and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in with your developer account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Certificates, IDs, & Profiles** on the right-hand-side navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **App IDs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button to add a new iOS App ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Name** field, enter something meaningful, such as `YourCompanyNameWildcard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Wildcard App ID** radio button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Bundle ID** field, select a reverse domain styled name for your company,
    such as `com.yourcompanyname.*`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the final setting and hit **Submit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave this webpage open, as we will be using it throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We just registered a wildcard bundle ID for your account; use this as a prefix
    for all future applications you wish to identify with this account. Later, when
    you are preparing to deploy an app to the Apple App Store, you will create an
    **Explicit App ID** such as `com.yourcompanyname.yourapp`. This allows you to
    deploy the specific app to the store, while the wildcard ID is best used for deploying
    to devices for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Next we need to locate the unique identifier on each device you plan to debug
    your application on. Apple requires each device to be registered under your account
    and has a limit of 110 devices per device type per developer (110 iPhones, iPads,
    iPods, Apple TVs, or Apple Watches). The only way to circumvent this requirement
    is to register for the iOS Developer Enterprise Program, which has a $299 yearly
    fee that is separate from the standard $99 developer fee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by launching Xcode and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Window** | **Devices** in the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug in your target device with a USB cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand-side navigation, you should see your device's name; select
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice the **Identifier** value for your device. Copy it to your clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what your screen should look like with your
    device selected in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS provisioning](img/image00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Return to [http://developer.apple.com/account](http://developer.apple.com/account)
    (hopefully, it is still open from earlier in the chapter) and perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Devices | All** on the left-hand-side navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button in the top-right corner of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a meaningful name for your device and paste the **Identifier** from your
    clipboard into the **UDID** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the information you entered and hit **Register**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Down the road, when your account is fully set up, you can just click on the
    **Use for Development** button in Xcode and skip this second set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what your device list should look like when
    complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS provisioning](img/image00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will need to generate a certificate to represent you as the developer
    for your account. Prior to Xcode 5, you had to create a certificate-signing request
    by using the **Keychain** app on your Mac. The newer versions of Xcode make things
    a lot easier by integrating a lot of this process into Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Xcode and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Xcode** | **Preferences** in the menu at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Accounts** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button on the bottom-left and then click on **Add Apple ID**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the e-mail and password for your developer account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon creating the account, click on **View Details** on the bottom-right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Download All** button on the bottom-left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is a new account, Xcode will display a warning that no certificates
    exist yet. Check each box and click on **Request** to generate the certificates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Xcode will now automatically create a developer certificate for your account
    and install it into your Mac's keychain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what your screen will look after setting up
    your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS provisioning](img/image00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to create a **provisioning profile**. This is the final file that
    allows applications to be installed on an iOS device. A provisioning profile contains
    an App ID, a list of device IDs, and, finally, a certificate for the developer.
    You must also have the private key of the developer certificate in your Mac's
    keychain to use a provisioning profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few types of provisioning profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development**: This is used for debug or release builds; you will actively
    use this type of profile when your applications are in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ad Hoc**: This is used mainly for release builds; this type of certificate
    is great for beta testing or distribution to a small set of users. You can distribute
    to an unlimited number of users using this method with an enterprise developer
    account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Store**: This is used for release builds for submission to the App Store.
    You cannot deploy an app to your device using this certificate; it can only be
    used for store submission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s return to [http://developer.apple.com/apple](http://developer.apple.com/apple)
    and create a new provisioning profile by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Provisioning Profiles | All** on the left-hand-side navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the plus button on the top-right of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **iOS App Development** and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your wildcard App ID created earlier in the chapter and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the certificate we created earlier in the chapter and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the devices you want to deploy to and click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an appropriate **Profile Name**, such as `YourCompanyDev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Continue** and your provisioning profile will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows the new profile that you will end up with upon
    creation. Don't worry about downloading the file; we'll use Xcode to import the
    final profile.
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS provisioning](img/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To import the provisioning profile, return to Xcode and perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Xcode** | **Preferences** in the menu at the top of the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Accounts** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your account and click on **View Details**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Download All** button on the bottom-left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few seconds, your provisioning profiles will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Xcode should automatically include any provisioning profiles you have created
    on the Apple developer site. Xcode will also create a few profiles on its own.
  prefs: []
  type: TYPE_NORMAL
- en: In the latest version of Xamarin Studio, you can view these profiles, but will
    not be able to sync them. Navigate to **Xamarin Studio** | **Preferences** | **Developer
    Accounts** to view the provisioning profiles from Xamarin Studio. You can also
    see Xamarin's documentation on iOS provisioning on their documentation website
    at [http://developer.xamarin.com/guides/ios/getting_started/device_provisioning/](http://developer.xamarin.com/guides/ios/getting_started/device_provisioning/).
  prefs: []
  type: TYPE_NORMAL
- en: Android device settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the hassle of deploying your application on iOS devices, Android
    is a breeze. To deploy an application to a device, you merely have to set a few
    settings on the device. This is due to Android's openness in comparison to iOS.
    Android device debugging is turned off for most users, but it can be easily turned
    on by any user that wishes to have a try at writing Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by opening the **Settings** application. You may have to locate this
    by looking through all the applications on the device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scroll down and click on the section labeled **Developer options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the action bar at the top, you may have to toggle a switch to the **ON**
    position. This varies on each device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down and check **USB Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A warning confirmation will appear; click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some newer Android devices have made it a little more difficult for
    the average user to turn on USB debugging. You have to click on the **Developer
    options** item seven times to turn this option on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what your device will look like during the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android device settings](img/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After enabling this option, all you have to do is plug in your device via USB
    and debug an Android application in Xamarin Studio. You will see your device listed
    in the **Select Device** dialog. Note that if you are on Windows or have a non-standard
    device, you may have to visit your device vendor's website to install drivers.
    Most Samsung and Nexus devices install their drivers automatically. On Android
    4.3 and higher, there is also a confirmation dialog on the device that appears
    before beginning a USB debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows what your device will look like for a Samsung
    Galaxy in the **Select Device** dialog. Xamarin Studio will display the model
    number, which is not always a name that you may recognize. You can view this model
    number in your device's settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android device settings](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the linker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep Xamarin applications small and lightweight for mobile devices, Xamarin
    has created a feature for their compiler called the **linker**. Its main purpose
    is to strip unused code out of the core Mono assemblies (such as `System.dll`)
    and platform-specific assemblies (`Mono.Android.dll` and `Xamarin.iOS.dll`); however,
    it can also give you the same benefits if set up to run on your own assemblies.
    Without running the linker, the entire Mono framework can be around 30 megabytes.
    This is why linking is enabled by default in device builds, which enables you
    to keep your applications small.
  prefs: []
  type: TYPE_NORMAL
- en: The linker uses static analysis to work through the various code paths in an
    assembly. If it determines that a method or class is never used, it removes the
    unused code from that assembly. This can be a time-consuming process, so builds
    running in the simulator skip this step by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin applications have the following three main settings for the linker:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t Link**: In this, the linker compilation step is skipped. This is best
    for builds running in the simulator or if you need to diagnose a potential issue
    with the linker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link SDK Assemblies Only**: In this, the linker will only be run on the core
    Mono assemblies such as `System.dll`, `System.Core.dll` and `System.Xml.dll`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link All Assemblies**: In this, the linker is run against all the assemblies
    in your application, which includes any class libraries or third party assemblies
    you are using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These settings can be found in the **Project** options of any Xamarin.iOS or
    Xamarin.Android application. These settings are generally not present in class
    libraries as they are generally associated with an iOS or Android application
    that will be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The linker can also cause potential issues at runtime as there are cases in
    which its analysis determines incorrectly that a piece of code is unused. This
    can happen if you are using features in the `System.Reflection` namespace instead
    of accessing the method or property directly. This is one reason why it is important
    for you to test your application on physical devices, as linking is enabled for
    device builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this issue, let''s look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will work fine using the options for **Don''t Link**
    or **Link SDK Assemblies Only**. However, if you try to run this when using **Link
    All Assemblies**, you will get an exception similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Name` property's getter was never used directly from code, the linker
    stripped it from the assembly. This caused the reflection code to fail at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Even though potential issues can arise in your code, the option of **Link All
    Assemblies** is still quite useful. There are a few optimizations that can only
    be performed in this mode, and Xamarin can reduce your application to the smallest
    possible size. If performance or a tiny download size is the requirement for your
    application, give this option a try. However, thorough testing should be performed
    to verify that no problems are caused by linking your assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve issues in your code, Xamarin has included a complete set of workarounds
    to prevent specific parts of your code from being stripped away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark class members with `[Preserve]`; this will force the linker to include
    the attributed method, field, or property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark an entire class with `[Preserve(AllMembers=true)]`; this will preserve
    all code within the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mark an entire assembly with `[assembly: Preserve]`; this is an assembly-level
    attribute that will preserve all code contained within it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip an entire assembly by modifying **Additional mtouch arguments** in your
    project options; use `--linkskip=System` to skip an entire assembly. This can
    be used on assemblies that you do not have the source code for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom linking via an XML file, which is the best option when you need to skip
    linking on a specific class or method that you do not have the source code for.
    Use `--xml=YourFile.xml` in **Additional mtouch arguments**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample XML file demonstrating custom linking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Custom linking is the most complicated option and is usually the last resort.
    Luckily, most Xamarin applications will not have to work around many linker issues.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AOT compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The runtime behind Mono and .NET on Windows is based on a **just-in-time** (**JIT**)
    compiler. C# and other .NET languages are compiled into **Microsoft intermediate
    language** (**MSIL**). At runtime, MSIL is compiled into a native code (just in
    time) to run on whatever type of architecture is running your application. Xamarin.Android
    follows this exact pattern. However, due to Apple's restrictions on dynamically
    generated code, a **just-in-time (JIT)** compiler is not allowed on iOS.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this restriction, Xamarin has developed a new option called **ahead-of-time**
    (**AOT**) compilation, in which your C# code is compiled into native, platform-specific
    machine code. In addition to making .NET possible on iOS, AOT has other benefits,
    such as a shorter startup time and potentially better performance.
  prefs: []
  type: TYPE_NORMAL
- en: AOT also has some limitations that are generally related to C# generics. To
    compile an assembly ahead of time, the compiler will need to run some static analysis
    against your code to determine the type information. Generics throw a wrench into
    this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few cases that are not supported with AOT, but are completely valid
    in C#. The first is a generic interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler cannot determine the classes that may implement this interface
    ahead of time, especially when multiple assemblies are involved. The second limitation
    is related to the first: you cannot override virtual methods that contain generic
    parameters or return values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, the static analysis of the compiler cannot determine which classes may
    override this method at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another limitation is that you cannot use `DllImport` in a generic class, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with the language feature, `DllImport` is a way to call
    native C/C++ methods from C#. Using them inside generic classes is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: These limitations are another good reason why testing on devices is important,
    since the preceding code will work fine on other platforms that can run C# code,
    but not Xamarin.iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding common memory pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory on mobile devices is certainly not an unlimited commodity. Because of
    this, memory usage in your application can be much more important than on desktop
    applications. At times, you might find the need to use a memory profiler or improve
    your code to use memory more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most common memory pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: The **garbage collector** (**GC**) is unable to collect large objects fast enough
    to keep up with your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code inadvertently causes a memory leak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A C# object is garbage collected, but is later attempted to be used by native
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the first problem, where the GC cannot keep up. Let''s
    say we have a Xamarin.iOS application with a button for sharing an image on Twitter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now let's assume the image is a 10 MB image from the user's camera roll. If
    the user clicks on the button and cancels the Twitter post rapidly, there could
    be the possibility of your application running out of memory. iOS will commonly
    force apps using too much memory to close, and you don't want users to experience
    this with your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best solution is to call `Dispose` on the image when you are finished with
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An even better approach would be to take advantage of the C# `using` statement,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The C# `using` statement will automatically call `Dispose` in a `try-finally`
    block, so the object will get disposed of even if an exception is thrown. I recommend
    taking advantage of the `using` statement for any `IDisposable` class, where possible.
    It is not always necessary for small objects, such as `NSString`, but it is always
    a good idea for larger, more heavyweight `UIKit` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar situation can occur in Android with the `Bitmap` class. Although slightly
    different, it is best to call the `Dispose` method on this class, the same as
    you would with `UIImage` on iOS.
  prefs: []
  type: TYPE_NORMAL
- en: A memory leak is the next potential issue. C#, being a managed, garbage-collected
    language, prevents a lot of memory leaks, but not all of them. The most common
    leaks in C# are caused by events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a static class with an event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we need to subscribe to the event from an iOS controller, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that the static class will hold a reference to the controller
    until the event is unsubscribed. This is a situation that a lot of developers
    might miss. To fix this issue on iOS, I would subscribe to the event in `ViewWillAppear`
    and unsubscribe from `ViewWillDisappear`. On Android, use `OnStart` and `OnStop`,
    or `OnPause` and `OnResume`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would correctly implement this event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, an event is not a surefire cause of a memory leak. Subscribing to the
    `TouchUpInside` event on a button inside the `ViewDidLoad` method, for example,
    is just fine. Since the button lives in memory just as long as the controller,
    everything can be garbage collected without causing a problem.
  prefs: []
  type: TYPE_NORMAL
- en: For the final issue, the garbage collector can sometimes remove a C# object;
    later, an Objective-C object attempts to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of adding a button to `UITableViewCell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the built-in info button as an accessory view to the cell. The problem
    here is that the button will be garbage collected, but its Objective-C counterpart
    will remain in use as it is displayed on the screen. If you click on the button
    after a period of time, you will get a crash that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not the most descriptive error message, but, in general, you know that
    something went wrong in the native Objective-C code. To resolve the issue, create
    a custom subclass of `UITableViewCell` and create a dedicated member variable
    for the button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your `GetCell` implementation will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the button is not a local variable, it will no longer be garbage collected
    sooner than needed. A crash is avoided, and, in some ways, this code is a bit
    cleaner. Similar situations can happen on Android with the interaction between
    C# and Java; however, it is less likely, since both are garbage-collected languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started out learning the process of setting up iOS provision
    profiles to deploy to iOS devices. Next, we looked at the required device settings
    for deploying your application to an Android device. We discovered the Xamarin
    linker, and how it can make your applications smaller and more performant. We
    went over the various settings for resolving problems caused by your code and
    the linker, and we explained AOT compilation on iOS and the limitations that occur.
    Finally, we covered the most common memory pitfalls that can occur with Xamarin
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Xamarin application on mobile devices is important for various
    reasons. Some bugs are only displayed on the device due to the platform limitations
    that Xamarin has to work around. Your PC is much more powerful, so you will see
    different performance using the simulator compared to on a physical device. In
    the next chapter, we'll create a real web service using Windows Azure to drive
    our XamChat application. We will use a feature called Azure Mobile Services, and
    implement push notifications on iOS and Android.
  prefs: []
  type: TYPE_NORMAL
