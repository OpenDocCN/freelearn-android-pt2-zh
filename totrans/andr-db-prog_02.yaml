- en: Chapter 2. Using a SQLite Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier we were introduced to various methods for storing data on Android data
    ranging from small and simple primitive values to large and complex file types.
    In this chapter, we''ll dive deeper into an extremely powerful and efficient way
    to save and retrieve structured data: namely, by using SQLite databases. For the
    time being, we''ll focus on the versatility and robustness of the SQLite database
    as a local backend for your application, before switching focus in later chapters
    and looking at ways to bind this SQLite backend with the user interface frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating advanced SQLite schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we ran through a simple example of creating and using
    a table with two fields: an integer ID field and a String name field. However,
    oftentimes the database schema that your application will need will require much
    more than one table. And so, now that you suddenly need multiple tables, some
    potentially dependent on one another, how can you effectively leverage the `SQLiteOpenHelper`
    class to make the development of the application clean and straightforward without
    compromising the robustness of your schema? Let''s walk through an example together
    to tackle this problem!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple schema with three tables: the first a `Students` table with
    fields ID, name, state, and grade, and the second a `Courses` table with fields
    ID, and name, and the third a `Classes` table with fields ID, student ID, and
    course ID. What we''re going to try and create is a schema where we can add/remove
    students, add/remove courses, and enroll/drop students from different courses.
    Some of the challenges we can immediately think of are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we obtain simple analytics, such as number of students per course?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when we drop a course with students in it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when we remove a student who is enrolled in courses?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On that note, let''s go straight into the code. We begin by defining the schema
    with a couple of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the code for creating the database schema (this should look very
    similar to what we saw earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So here we see that in our `onCreate()` method we execute SQL commands to create
    all three tables, and furthermore, in the `onUpgrade()` method we execute SQL
    commands that drop all three tables and subsequently recreate all three tables.
    Of course, since we are overriding the `SQLiteOpenHelper` class, in theory we
    can customize the behavior of these methods in any way we want (for instance,
    some developer's might not want to drop the entire schema in the `onUpgrade()`
    method), but for now let's keep the functionality simple.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, for those who are well versed in SQL programming and database
    schemas, you might be wondering if it's possible to add triggers and key constraints
    to your SQLite database schemas. The answer is, "yes, you can use triggers but
    no, you cannot use foreign key constraints." In any case, to spend any time on
    writing and implementing triggers would be deviating too much from the core content
    of this book, and so I chose to omit that discussion (though these could certainly
    be helpful even in our simple example).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our schema created, before moving on to designing all kinds
    of complex queries for pulling different groups of data (this we'll see in the
    next chapter), it's time to write some wrapper methods. This will help us to address
    some of the questions mentioned previously, which will ultimately help us in creating
    a robust database.
  prefs: []
  type: TYPE_NORMAL
- en: Wrappers for your SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we have this somewhat complicated schema in front of us now, and earlier
    we mentioned the questions of what would happen if we removed a student who is
    enrolled in courses, and vice versa what would happen if we dropped a course with
    multiple students enrolled in it? Certainly, we wouldn't want either case to happen
    - in the first, we'd have courses filled with students who are no longer even
    enrolled in the university, and in the second, we'd have students showing up for
    courses that are no longer even being offered!
  prefs: []
  type: TYPE_NORMAL
- en: 'And so it''s time to enforce some of these rules and we''ll do this by adding
    some convenient methods to our `SchemaHelper` class. Again, some of these rules
    could be enforced by using trigger statements (remember that Android''s SQLite
    database doesn''t support key constraints), but one of the benefits of using wrapper
    methods is that they are much more intuitive to developers who may be new to your
    application''s code base. By using a wrapper class, a developer is able to safely
    interact with a database whose schema the developer may know very little about.
    Now, let''s start by tackling the simple wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have three simple wrapper methods for adding data into our schema. The
    first two involve adding new students and new courses into the database and the
    last one involves adding a new mapping between a student (represented by his/her
    ID) and a course (essentially, we are enrolling a student into a course through
    this mapping). Notice that in each wrapper method, we''re simply adding the values
    into a `ContentValue` object, retrieving the writeable SQLite database, and then
    inserting this `ContentValue` as a new row into the specified table. Next, let''s
    write some wrapper methods for retrieving data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have three fairly similar methods which allow us to get very practical
    datasets from our schema:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to grab a list of students in a given course
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to grab a list of courses for a given student
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly (just to add some complexity), being able to grab a list of students
    of a certain grade for a given course
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that in all three methods we begin to play with some of the parameters
    in the `SQLiteDatabase` object''s `query()` method, and so now seems like a great
    time to take a closer look at what those parameters are and what exactly we did
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And alternatively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And just for simplicity, here''s how we''re calling the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So a quick explanation of the three methods. The first `query()` method is
    the standard one, where you specify the table in the first argument and then which
    columns you want to return in the second argument. This is equivalent to performing
    a `SELECT` statement in standard SQL. Then, in the third argument we begin to
    filter our query and the syntax for these filters is equivalent to including a
    `WHERE` clause at the end of our `SELECT` query. In our example, we see that we
    only ask to return the column containing student IDs, as this is the only column
    we care about (since we''re filtering on the course ID column, it would be unnecessarily
    redundant to return this column as well). Then, in the filter parameter, we ask
    to filter by the course ID and the syntax is equivalent to passing in the following
    String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the question mark acts as a place card for whatever value we will pass
    into the filter. In other words, the format of the `WHERE` statement is there,
    but we just need to substitute into the question mark the actual value we want
    to filter by. In this case, we pass into the fourth parameter the given course
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last three arguments (`groupBy`, `having`, and `orderBy)` should make a
    lot of sense for those familiar with SQL, but for those who aren''t, here''s a
    quick explanation of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupBy` - adding this will allow you to group the results by a specified
    column(s). This would come in handy if you needed to obtain, say, a table with
    course IDs and the number of students enrolled in that course: simply grouping
    by course ID in the `Class` table would accomplish this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`having` - used in conjunction with a `groupBy` clause, this clause allows
    you to filter the aggregated results. Say you grouped by course ID in the `Class`
    table and wanted to filter out all classes with having less than 10 students enrolled,
    you could accomplish this with the `having` clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orderBy` - a fairly straightforward clause to use, the `orderBy` clause allows
    us to sort our query''s resulting sub table by a specified column(s) and by ascending
    or descending order. For instance, say you wanted to sort the `Students` table
    by grade and then by name — specifying an `orderBy` clause would allow you to
    do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, in the two `query()` variants, you'll see the added parameters `limit`
    and `distinct:` the `limit` parameter allows you to limit how many rows you want
    back, and the `distinct` boolean allows you to specify whether you only want to
    return distinct rows. If this still doesn't make too much sense to you, no fears
    - we'll focus on building complex queries in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand how the `query()` method works, let''s revisit our earlier
    example and flush out the `getStudentsByGradeForCourse()` method. Though there
    are many ways to execute this method, conceptually they are all very similar:
    first, we query for all the students in the given course, and then of these students
    we want to filter and only keep those in the specified grade. The way I implemented
    it was by first obtaining a set of all student IDs from the given course, then
    obtaining a set of all the students for the given grade, and simply returning
    the intersection of those two sets. As for whether or not this is the optimal
    implementation simply depends on the size of your database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, last but not least, let''s enforce those removal rules mentioned earlier
    with some special remove wrapper methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So here we have two remove methods, and in each one we manually enforce some
    schema rules by preventing someone from dropping a course without first removing
    those courses from the `Class` mapping table and vice versa. We call the `SQLiteDatabase`
    class's `delete()` method which, much like the `query()` method, allows you to
    pass in the table name, specify a filter argument (that is, a `WHERE` clause),
    and then allows you to pass in those filters' values (note that in both the `delete()`
    and `query()` methods, you can specify multiple filters, but more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s put these methods in action and implement an `Activity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So first we add some dummy data into our schema; in my case, I will add five
    students and three courses, and then enroll those students into some classes.
    Once the schema has some data in it, I will try out some methods and first request
    all the students signed up for CS106A. Afterwards, I will test another wrapper
    method we wrote and request all the students signed up for CS106A, but this time
    only those students in grade 11\. And so the output from running this `Activity`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers for your SQLite database](img/8123OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And voila! We quickly see that Students 1, 2, 3, and 5 were all enrolled in
    CS106A. However, after filtering by grade 11, we see that Student 3 is the only
    one signed up for CS106A in grade 11 - poor George. Now let''s test out the remove
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This time around, we first ask for all the classes that Student 1 (myself)
    is enrolled in. But oh no! Something happened to Math51 this quarter and so it
    was cancelled! We remove the course and make another request to look at all the
    classes that Student 1 is – enrolled in expecting to see that Math51 has been
    removed from the list. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrappers for your SQLite database](img/8123OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Indeed, we see that at first I was enrolled in both Math51 and CS106A, but after
    the course was removed, I'm not only enrolled in CS106A! By putting wrappers around
    some of these common insert, get, and remove functions, we can both simplify our
    development lives going forward while also enforcing certain schema rules.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's conclude this chapter with how you can hook into a SQLite terminal
    to look at your data in table form and also issue SQLite queries - something extremely
    useful when debugging your application and making sure that your data is being
    added/updated/removed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android platform provides you with a very powerful debugging friend called
    the **Android Debug Bridge (adb)**. The adb shell is a versatile command-line
    interface that allows you to communicate with a running emulator or a connected
    Android device. The adb tool can be found in your SDK's/platform-tools directory
    and, once, started is capable of doing everything from installing applications,
    to pushing and pulling data from your emulator, to plugging into your sqlite3
    database and issuing queries (see the developer docs [http://developer.android.com/guide/developing/tools/adb.html](http://developer.android.com/guide/developing/tools/adb.html)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use adb, simply open your terminal and navigate to `/<your-sdk-directory>/platform-tools/`
    and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'or type the following command if you want to target a specific emulator to
    connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have started the adb tool, at which point you need
    to tell it to connect to the emulator''s sqlite3 database. This can be done by
    issuing the command sqlite3 and then passing the path to your application''s database
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the command looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And at this point, we should be able to issue all kinds of SQL queries that
    allow us to do everything from looking at our database schema to updating and
    removing individual rows of data in any of our tables. Some sample commands that
    you''ll probably find most useful are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.tables` shows you a list of all the tables in your database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.output FILENAME` allows you to output the results of a query into a file
    (say, for further analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.mode MODE` allows you to specify the output file format (that is, as a CSV,
    HTML, and so on, could be useful for spreadsheet type analytics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT * FROM table_name` standard query for selecting all columns of a given
    table (this is equivalent to a `get()` command for rows of a table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT * FROM table_name WHERE col = ''value''` standard query for selecting
    all columns of a given table but with a column filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT col1, col2 FROM table_name` standard query for selecting specific columns
    of a given table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here''s an example of us putting some of these commands to use with our
    previous schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging your SQLite database](img/8123OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hopefully this should get you going, but for a full list of sqlite3 commands
    just check out [http://www.sqlite.org/sqlite.html](http://www.sqlite.org/sqlite.html),
    and for a more extensive list of complex queries just stay put - it's coming up
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went from a super bare-bones database schema that just contained
    one table to an entire schema containing multiple interdependent tables. We first
    saw how to create and upgrade multiple tables through overriding the `SQLiteOpenHelper`
    class, and then thought about some of the challenges surrounding a database schema
    with interdependencies. We decided to tackle these challenges by surrounding our
    database schema and its tables with an army of wrapper methods, designed for both
    ease of future development, as well as robustness in future data. These wrapper
    methods included everything from simple add methods, helpful as we were able to
    conceal the need to constantly request a writeable `SQLiteDatabase`, to more complex
    remove methods which concealed all of the functionality needed for enforcing various
    schema rules.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we actually implemented an `Activity` class to show off our new database
    schema and ran through some sample database commands to test their functionality.
    Though we were able to validate and output the results of all our commands, we
    realized that this was a pretty verbose and suboptimal way for debugging our sqlite3
    database, and so we looked into the Android Debug Bridge (adb) tool. With the
    adb tool, we were able to open a command-line terminal that then hooked into a
    running instance of an emulator or Android device, and subsequently, connect to
    that emulator/device's sqlite3 database. Here we were able to interact with the
    sqlite3 database in a very natural way by issuing various SQL commands and queries.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the queries that we've seen so far have been pretty elementary, but if
    necessary, will do the trick for the majority of your application development
    needs. However, we'll see in the next chapter that by mastering more advanced
    SQL query concepts, we can enjoy both a substantial performance boost as well
    as a substantial memory boost in our application!
  prefs: []
  type: TYPE_NORMAL
