- en: Chapter 4. Exploiting Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Information disclosure via logcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting the network traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive intent sniffing via the activity manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking broadcast receivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating vulnerable content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from vulnerable content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data into content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating SQL-injection vulnerable content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting debuggable applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Man-in-the-middle attacks on applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've covered some of the basic development and security assessment
    tools, and we even covered some examples of extending and customizing these tools.
    This chapter will focus on the use of these tools to analyze the Android applications
    to identify vulnerabilities and develop exploits for them. Although, given the
    arbitrary nature of application functionality and the almost limitless creativity
    Android application developers can exercise, it's not hard to see that assessing
    the security of Android applications must be considered an art. What this means
    for you as a security auditor, analyst, consultant, or hobbyist is that you can
    be sure that there will never be a fully autonomous method to analyze the security
    of the Android application. Almost always, you'd need to rely on your creativity
    and analysis to deliver a concrete assessment of an Android application's security.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start banging away at some apps, it's important to frame the Android
    application security problem, define some goals, and enumerate the application
    attack surface. In the next few sections, we will discuss some of the generic
    goals of application security and the controls that should be in place to help
    achieve these goals. The reason discussing application security goals is so important
    is because it helps to make sure that you've got the right mindset and principles
    in place when accessing the security of an application. Also, it makes auditing
    application security as simple as verifying the existence of these controls and
    then developing ways to exploit either the lack or the inadequacy of the mentioned
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: So what are the goals of application security?
  prefs: []
  type: TYPE_NORMAL
- en: Protecting user data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Applications are often entrusted with very sensitive data related to users,
    some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP addresses or domain names to sensitive services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each application's data is cached if it is so inclined, and may often explicitly
    save the user content in the databases, XML files, or any other disk storage format;
    they have the freedom to use any file format or storage mechanism they need. It's
    important to assess the security of these data stores with the same diligence
    that is applied to assessing and auditing online or cloud-based databases and
    information storage mechanisms, especially because the information stored in an
    application can influence the security of websites and other cloud services. For
    example, if an attacker proliferates authentication credentials to a cloud service
    from an application, he/she immediately has access to the actual cloud service.
    Think about online banking apps as well, and the two factor authentication tokens
    these apps store and how they are stored—the SMS inbox? Really!
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications need to enforce many of the controls that online databases use
    independent of those provided by the Android operating system; namely, the controls
    that ensure the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonrepudiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss how to ensure these controls in the later chapters. For now,
    all that you need to concentrate on is understanding the risks which the user
    incurs when these controls are not enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting applications from one another (isolation and privilege separation)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications are protected via the Android sandbox, which is just another way
    of saying that each application is assigned a user ID and only inherently has
    access to its own resources. This is the story of application isolation as far
    as the Linux portion of Android is concerned. Android introduced some of its own
    protection mechanisms to keep apps from abusing each other's components and data;
    the most notable being the Android permissions framework, which operates at the
    application level and is enforced by the application middleware. It exists to
    translate the Linux access control mechanism to application level and vice versa.
    Speaking more practically, this means that every time an application is granted
    a permission, it may mean that the related UID is assigned a corresponding GID.
    For example, `android.permission.INTERNET`, which is mapped to the `inet` group.
    Any application granted this permission will be placed in the `inet` group.
  prefs: []
  type: TYPE_NORMAL
- en: Applications often consist of many instances of the classic application components,
    services, content providers, activities, and broadcast receivers. To protect these
    components from malicious or any unintentional harmful influence, it's imperative
    that application developers communicate and mitigate the risk their applications
    introduce to the user with regard to the services and data they can access. The
    application developers should also respect the integrity of these resources. These
    two principles of secure development can be enforced by the permissions framework
    by ensuring that they only request the necessary permissions and are not overzealous
    in the permissions they expect to be granted. The key here is making sure that
    developers practice the principle of least privilege. Protection from malicious
    apps can be enforced partly by ensuring that the correct permissions are required
    to access a given application's components and data, and only the necessary services
    and components are made available to the rest of the system at large, that is,
    don't export components when you don't need to.
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing the isolation an application enforces for its data and components,
    it's important to take into context the permissions required to access them. How
    easy is it to get these permissions granted? Are permissions required to access
    a given component assigned the correct protection level? A bad example would be
    an app that facilitates searching and retrieving a user's bank statements with
    only the `android.permission.SEARCH` permission.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting communication of sensitive information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not enough that application developers protect the data their applications
    store, they also need to be mindful of the way this information is communicated.
    For instance, consider an application that stores a user's data securely but allows
    it to be communicated to unauthorized parties. All the data storage security in
    the world means nothing if communication isn't done securely!
  prefs: []
  type: TYPE_NORMAL
- en: 'Communication can be done in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inter-component communication**: Applications often need to send information
    between their respective components, for example, between a broadcast receiver
    and an activity. Seeing that this communication may be facilitated via intents
    and intent filters, and given the nonexclusive nature of intent filters, it''s
    possible that unauthorized applications may intercept this communication in various
    ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-application communication**: Data communication between applications
    should be done in a way that will prevent unauthorized applications from tampering,
    intercepting, or gaining access to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra-device communication**: It''s possible that apps will make use of NFC,
    Bluetooth, GMS, or Wi-Fi communication mediums to transmit sensitive data. Application
    developers must take the proper precautions to ensure the confidentiality, integrity,
    and non-repudiation of data communicated this way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, when auditing an application for communication faults, it''s important
    to look for controls that provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication between both the receiving and initiating application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control preventing unauthorized parties/applications from gaining access
    to the communicated data or controlling the flow of communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So hopefully, you actually read the introduction and have a good grasp of the
    controls that are expected from secure applications; because in the next sections,
    I'll walk through how to verify whether these controls are in place or not, and
    how to take advantage of the lack of these controls.
  prefs: []
  type: TYPE_NORMAL
- en: Information disclosure via logcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications may leak sensitive information either inherently or as
    a result of harmful influence. When this happens, it's called an *Information
    disclosure* vulnerability. This recipe talks about how to check an application
    for potential leaks of sensitive information by inspecting the Android logcat,
    which is used by the application developers as a debugging tool. We will also
    talk about how you can take advantage of one of Android's built-in benchmarking
    tools to help make logcat inspection a little more rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An emulator or an Android device set up and connected to your machine via ADB,
    this will require USB Debugging to be enabled on your Android device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Android Debug Bridge** (**ADB**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before beginning with this recipe, you should have already downloaded and updated
    your Android SDK. You should have either set up your `PATH` variables appropriately,
    or you should be in the working directory that contains the appropriate tools/binaries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, let''s enable debugging via the ADB. On either Windows or Linux
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will only work if you are in the correct working directory, which is `[path-to-sdk]/sdk/platform-tools/`
    for Linux users or `[path-to-sdk]\sdk\platformtools\` for Windows users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will output the logging information of some of the software- and hardware-level
    events. Naturally, we would like to focus this on the events and applications
    we are inspecting for security vulnerabilities. Luckily, logcat is capable of
    filtering through the log information. Here''s a breakdown of all the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `[options]` can be any one of the following—I''ve omitted some of them
    to keep things short and to the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v <format>`: This option sets the format of the output; this could be either
    `brief`, `process`, `tag`, `thread`, `raw`, `time`, `threadtime`, or `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d`: This option dumps the logfile and exits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And `[filter]` is a list of the `tag:priority` command, which is discussed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tag`: It is the string that identifies a log component. Log components are
    the strings that log outputs. For instance, if the log output looks like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ClockAlarmWidget`, the part that is highlighted in the previous code would
    be the log component tag. The part preceding the `/` is called the priority. Here,
    the priority is `Error`, and it is indicated by an `E`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`priority`: It can be any one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V, verbose`: It enables verbose logging'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D, debug`: It enables debug logging'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I, Info`: It enables logging for informational purposes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W, Warn`: It enables logging for all warning information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E, Error`: It enables logging for errors'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, if you want to monitor the logs for `Error` level priority log
    components and higher, you would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `*` indicates that we want the `Error` level priority for all log component
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Another way you could filter through the log quite effectively is to dump the
    logcat output to a text file and search through it using either `grep`, which
    comes with most Linux/Unix distributions, or a text editor like Notepad++ for
    Windows users. A link to the download page of Notepad++ and `grep` are available
    in the *See also* section of this recipe. For Windows users, there's a Microsoft
    version of `grep` called WinGrep if you really want to do some powerful regular
    expression-based matching. A link to the WinGrep download page has also been made
    available in the *See also* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve decided how you want to search the text, it really doesn''t matter
    how you do this as long as you know how to find what you''re looking for in the
    logs. You can dump the output of the logfile by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This works the same way via the Linux terminal or Windows command prompt. You
    can also "pipe"—which means feeding the output of one program into the input of
    another—this directly into another program like this. This works in either the
    Windows command prompt or the Linux terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If your using `grep`, you would do it by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `[pattern]` would be the text pattern you''re searching, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I really don't want to write a full tutorial on how to use `grep` here. If you
    want to make use of some of the more powerful features of either `grep` or WinGrep,
    please see the *See also* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples you may find useful; monitor the logfile for web-related
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I know these are not very strict examples, but they are just strict enough to
    match web addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The previous logs were generated by the Google Play Store app on a Samsung Galaxy
    S3 mobile phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also try to catch some sign-on or authentication-type token strings
    being leaked through the logfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When looking for valuable information in the logfile, it's generally a good
    idea to look for information that you would otherwise need permissions to get
    hold of or directly cause you to gain knowledge of information protected by other
    apps. For instance, if an app logs the cookie values returned after a user logs
    into his/her LinkedIn profile, would this be dangerous?
  prefs: []
  type: TYPE_NORMAL
- en: Yes! Effectively you have just bypassed the need to know his/her LinkedIn password,
    or the need to have your app be granted rights to some of the authentication functions
    in the LinkedIn application. During the hours you will probably spend reading
    the logfile, you should try to focus on finding this kind of information.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Case and point! The cookies being logged here are being disclosed harmfully
    by the Android LinkedIn app on a Galaxy S3 mobile phone. Another real-world example
    of this vulnerability can be found at *Discovering a Major Security Hole in Facebook's
    Android SDK*. The link for the same is provided in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course applications are often developed to respond to hardware or software
    events, either via broadcast receivers or intents from other applications or system
    services. And naturally, you would like to know how applications respond to these
    events, or whether their behavior becomes potentially harmful in response to these
    kind of events. Then the question is, how do you create/send these events to the
    application you're testing without pressing your volume up button, locking and
    unlocking your screen, and pressing buttons yourself? The answer is the Android
    Monkey testing framework. It's designed to send system- and hardware-level events
    to an application, so that developers can gauge how well their application handles
    these events. It operates somewhat as a device event "fuzzing" framework for applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining how to use it, it's important to mention that it's probably
    not a good idea to run the Monkey tester against applications installed on either
    your or someone else's personal Android device. This is because the way these
    applications respond to the Monkey tester may cause some damage to the applications
    being "monkey'd", cause loss of application data, or even crash your phone. Unless
    you have the proper permission or acceptance that you may lose or corrupt some
    data stored by the application(s) you are testing, you should only do this on
    an emulated or security testing-dedicated device.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use this framework is to have a device connected via the ADB, and
    executing the following command via your command prompt or terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `[package]` is the name of the package/application to which you want
    to send these events, and `[event count]` is the number of random events you want
    to send. Here''s an example of how to use it against the Flipboard app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will send 10 randomly-selected events to the Flipboard app, and report
    back on the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Android Debug Bridge – Enabling logcat logging* webpage at [https://developer.android.com/tools/help/adb.html#logcat](https://developer.android.com/tools/help/adb.html#logcat)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Vogella Tutorials – Monkey Testing* webpage at [http://www.vogella.com/articles/AndroidTesting/article.html](http://www.vogella.com/articles/AndroidTesting/article.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Notepad++* software at [http://notepad-plus-plus.org/download/v6.3.3.html](http://notepad-plus-plus.org/download/v6.3.3.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Android Developer – logcat* webpage at [https://developer.android.com/tools/help/logcat.html](https://developer.android.com/tools/help/logcat.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *WinGrep* software at [http://www.wingrep.com/download.htm](http://www.wingrep.com/download.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Discovering a Major Security Hole in Facebook's Android SDK* webpage at
    [http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/](http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Android Developer – Reading and Writing Logs* webpage at [http://developer.android.com/tools/debugging/debugging-log.html](http://developer.android.com/tools/debugging/debugging-log.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting network traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, applications can make use of the networking services available on
    an Android device, and many applications are developed as frontends to cloud-based
    services. What this means is that understanding how it communicates with the Internet
    services is a very important part of the security risk profile—the collection
    of risks an application exposes its users and its device to.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, I'm going to show you some novel methods that you can use to
    monitor network traffic directly from an Android device using the ever popular
    **Wireshark**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can get cracking, there are a couple of tools you will need to install
    both on your local machine and the Android device. Here are the tools you''ll
    need to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wireshark**: It is available for download at the Wireshark site [http://www.wireshark.org](http://www.wireshark.org),
    Wireshark supports both Linux/Unix and Windows machines. You should make sure
    this is installed on your host machine before starting. Installing Wireshark is
    pretty straightforward; the Wireshark folks have even provided some very useful
    documentation for both Windows and Unix/Linux distributions, which is available
    at [http://www.wireshark.org/docs/wsug_html_chunked/ChapterBuildInstall.html](http://www.wireshark.org/docs/wsug_html_chunked/ChapterBuildInstall.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Netcat**: It is available for download for Linux/Unix users at [http://netcat.sourceforge.net/download.php](http://netcat.sourceforge.net/download.php),
    and for Windows users at [http://joncraton.org/blog/46/netcat-for-windows/](http://joncraton.org/blog/46/netcat-for-windows/).
    Linux/Unix users may not need to explicitly download Netcat as it comes packaged
    with many Linux/Unix distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCPdump for Android**: It is available for download at [http://www.strazzere.com/android/tcpdump](http://www.strazzere.com/android/tcpdump).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve got all the tools set up and ready to go, you can monitor the
    traffic of your Android device by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming your Android device is rooted, you should create a directory to host
    your TCPdump binary as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Android device, execute the following commands via ADB in the order
    they appear:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then on the local machine, in the folder where you''ve downloaded the TCPdump
    version for Android, execute the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the TCPdump Android version is uploaded to the device and marked as executable.
    You should make sure Netcat is available on the Android device by trying to run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/00085.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This is merely a sanity check, most Android versions come shipped with Netcat
    by default. If not, there is an Android version available from the Google Source
    Android GitHub repository with an NDK Makefile at [https://android.googlesource.com/platform/external/netcat/+/master](https://android.googlesource.com/platform/external/netcat/+/master).
    To find out how to use this Makefile, refer the *Cross-compiling native executables*
    recipe in [Chapter 8](part0077_split_000.html#page "Chapter 8. Native Exploitation
    and Analysis"), *Native Exploitation and Analysis*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make sure that everything works, after you''ve managed to confirm that both
    TCPdump and Netcat are installed on your Android device, you can actually dump
    some network traffic and try executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following appear on your screen if everything is working
    well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00086.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To see some actual output you might try opening an app that makes requests to
    the Web or using some networking APIs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If everything works fine, you should be able to start feeding the TCPdump output
    to the Wireshark installed on your local device. To do this, you first need to
    set up some port forwarding via ADB, which is done by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the port forwarding is set up, you should be able to use Netcat on your
    local machine by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means all the traffic is being forwarded correctly. You should be able
    to pipe the output into Wireshark, which will interpret it and facilitate deep
    packet inspection and other useful things. To pipe the output into Wireshark,
    execute the following command on your local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few seconds, if everything works properly, you should see Wireshark
    launch. The following shows up on your screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00087.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we used Netcat, Wireshark, and TCPdump to extract network traffic
    directly from an Android device for analysis and deep-packet inspection. Given
    that very little explanation was given for the command-line arguments and combinations
    of tools in the walkthrough, this recipe details how and why each one of the actions
    were performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Step 1, the following commands where executed in order to create a directory
    to host the TCPdump installation on the Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `su` command which stands for **Substitute User** (**SU**) allows us to
    assume root privileges—this is the behavior of `su` when no arguments are supplied.
    The root privileges we assume using `su` include being able to modify and view
    any directory or file on the Android file system. This was needed since we created
    the `tcpdump` directory inside the `/data/ folder`.
  prefs: []
  type: TYPE_NORMAL
- en: After executing `su`, we executed the `mkdir` command with an argument of `/data/tcpdump/`,
    which created the `tcpdump/` directory under the `/data/ folder`.
  prefs: []
  type: TYPE_NORMAL
- en: Following this is the `chmod` command—which is an abbreviation of change mode—with
    an argument of `755`. It modifies the access mode for the `/data/tcpdump` folder
    and allows users with lower privileges to access the `tcpdump` path. This is needed
    because we will be using the `adb push` command to store the `tcpdump` binary
    under this path.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `tcpdump` folder, we execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These ensure that the `tcpdump` binary is stored under the `tcpdump` path. The
    first command passes the `push` command to `adb` with an argument of `tcpdump`,
    which is the TCPdump version for Android. You will notice that a dot is supplied
    as the name for the `tcpdump` binary under the `/data/tcpdump` folder; this is
    a shorthand that ensures whichever file is being copied keeps its filename after
    being copied. This is evident since we copied a file called `tcpdump` from the
    local machine, which also ended up being called `tcpdump` on the Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Following the `push` command is the `adb shell` command with an argument of
    `chmod 755 /data/tcpdump/tcpdump`, which changes the access mode for the `tcpdump`
    binary, allowing users with lower privileges to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we used the `nc` command—which is an abbreviation of Netcat. This
    tool serves as a Swiss army knife for interacting with networking services. In
    this recipe, we will use it to read data from and into a network connection. Running
    `nc` without any arguments prints the usage specification. This allowed us to
    make sure `nc` was running properly and is actually installed on our Android device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 3, we used `tcpdump` with the argument of `–w`, which allows us to
    specify a file to write out to, and the second argument ensures that the output
    is written to the terminal screen. As part of the command we executed, we also
    specified the following: `| nc –l –p 31337`. The `|` character, which is called
    a pipe in operating system terminology, feeds the output of the preceding program
    to the program after the pipe as input. Netcat is invoked using the `–l` argument
    which causes Netcat to listen for connections on the port supplied as an argument
    to the `–p` command-line switch. In this context, all this means that the raw
    binary network traffic from `tcpdump` is fed to Netcat as input; which means it
    will output this raw traffic from port number `31337`.'
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we use ADB's port forwarding feature. It allows us to couple a port
    on the Android device (supplied as the second argument `tcp:12345`) with a port
    on the local machine (supplied as the first argument `tcp:31337`). You will notice
    that we couple port `12345` to port `31337` and tell Netcat in the previous step
    to listen for connection on port `31337`. This is so that we can interact with
    the Netcat instance via port `31337` on our local machines. To summarize in simpler
    terms, port `31337` on the Android device becomes port `12345` on our local machines.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, we launched Netcat with the arguments `127.0.0.1`, which is the address
    of our local machine (termed the loopback address), and `12345`, which is a port
    that we forwarded in the previous step. This tells Netcat to connect to port `12345`
    on our local machine; and since port `12345` is coupled to port `31337` on the
    Android device, it actually means we are interacting with port `31337` by proxy
    of port `12345` locally. The result of this is that we can grab the network traffic
    piped into Netcat on the Android device from our local machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Step 6, we combined all the commands relevant to our local machines in order
    to ensure that Wireshark gets the raw binary network traffic and interprets it
    for us. We launched Wireshark with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–k`: This argument, according to the Wireshark manual, does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts the capture session immediately. If the `-i` flag was specified, the
    capture uses the specified interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, Wireshark searches the list of interfaces, choosing the first non-loopback
    interface if there are any non-loopback interfaces and choosing the first loopback
    interface if there are no non-loopback interfaces.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no interfaces, Wireshark reports an error and doesn't start the
    capture.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–S`: This argument specifies the snapshot length, which is the number of bytes
    to capture per packet. If no argument is given as length, the full packet is captured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–i`: This argument specifies the input from which to capture packets. Here
    we supplied the – symbol again, which tells Wireshark to read the input from standard
    input. We do this because the input for Wireshark is funneled to it via the pipe
    from Netcat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more interesting use of this idea, you could try building tools that analyze
    Android traffic for active threats by running an **Intrusion Detection System**
    (**IDS**) or other security-focused network monitoring tools like Snort on some
    network traffic generated by an Android device. This idea would make for a very
    interesting malware and vulnerability analysis.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Analyzing Android Network Traffic* webpage at [http://mobile.tutsplus.com/tutorials/android/analyzing-android-network-traffic/](http://mobile.tutsplus.com/tutorials/android/analyzing-android-network-traffic/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Wireshark User's Guide* at [http://www.wireshark.org/docs/wsug_html_chunked/](http://www.wireshark.org/docs/wsug_html_chunked/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Wireshark DisplayFilters* webpage at [http://wiki.wireshark.org/DisplayFilters](http://wiki.wireshark.org/DisplayFilters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Wireshark CaptureFilters* webpage at [http://wiki.wireshark.org/CaptureFilters](http://wiki.wireshark.org/CaptureFilters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *TCPdump* man page at [http://www.tcpdump.org/tcpdump_man.html](http://www.tcpdump.org/tcpdump_man.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive intent sniffing via the activity manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good way to proliferate information about application and their components
    is to eavesdrop on inter-application communication. One way you could do this
    is by requesting information about the most recent intents from the activity manager.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty straightforward and, as it turns out, can be done via drozer
    (which was introduced in [Chapter 3](part0032_split_000.html#page "Chapter 3. Android
    Security Assessment Tools"), *Android Security Assessment Tools*) if you're willing
    to do some Python scripting. The folks at iSec Partners have developed an Android
    application that is capable of doing this, and most of the inspiration for the
    drozer module discussed in the following recipe comes from their app. To find
    out how to get your hands on this app see the *See also* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we actually write this module, we need to modify the drozer Agent a little
    so it has the required permissions to actually request information about intents
    from the activity manager. The simplest way to do this is to augment the permissions
    requested by drozer via its `AndroidManifest.xml` file. Here, I'll show you how
    to do this using Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to grab a copy of the drozer Agent and its dependencies from
    the following sites:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *drozer Agent* webpage at [https://github.com/mwrlabs/drozer-agent](https://github.com/mwrlabs/drozer-agent)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *jdiesel (fuels the drozer)* webpage at [https://github.com/mwrlabs/jdiesel](https://github.com/mwrlabs/jdiesel)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *TLS Support* webpage at [https://github.com/mwrlabs/mwr-tls](https://github.com/mwrlabs/mwr-tls)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Android utilities for drozer* webpage at [https://github.com/mwrlabs/mwr-android](https://github.com/mwrlabs/mwr-android)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have these downloaded and saved them in the same folder, you can open
    Eclipse and import each of them as Android projects. For each of them, once Eclipse
    is opened, navigate to **File** | **Import**.![Getting ready](img/00088.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Android** folder, then go to **Existing Android Code into Workspace**
    and click on **Next**.![Getting ready](img/00089.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, Eclipse will ask you to specify a folder to import from. You'll
    need to add one of the folders you downloaded in step 1\. To select a folder,
    click on **Browse...** and a file selection dialog will pop up.![Getting ready](img/00090.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **File** dialog, navigate to the file path where you've downloaded
    the drozer Agent and dependencies. You'll need to add each one of them this way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you import each of the folders this way. Until you do so, Eclipse
    will not be able to build the drozer Agent successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you''ve imported all the projects, you''ll need to edit the drozer Agent''s
    `AndroidManifest.xml`. You do this by double-clicking on the `AndroidManifest.xml`
    file in the `drozer-agent project` folder in Eclipse (make sure that you select
    the `AndroidManifest.xml` tab before editing so you can edit the XML directly).
    Then, enter the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AndroidManifest.xml` file should look like the following screenshot if
    you''ve performed the step correctly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Getting ready](img/00091.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: And that's it! You've just added an extra permission to the drozer Agent. Now
    you can export the drozer Agent as an APK file, upload it to your device, and
    get cracking.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please note you may need to uninstall the drozer Agent currently installed on
    your device before installing the modified one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So that's the drozer Agent done and dusted. We can now move onto developing
    the intent sniffer module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to your drozer module repository; if you haven''t set one up please
    refer to the *Writing a drozer module – a device enumeration module* recipe in
    [Chapter 3](part0032_split_000.html#page "Chapter 3. Android Security Assessment
    Tools"), *Android Security Assessment Tools*, to see how this is done. Once you
    are in your module repository, create a file called `ex.sniffer.intents` and type
    the following into it (the following code will be available in this book''s code
    repository):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once that''s done, install the module into drozer by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then run it by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see something similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00092.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The intent sniffer script is actually quite simple. Here I'll break down what
    it's doing and how it manages to actually sniff some intents.
  prefs: []
  type: TYPE_NORMAL
- en: The intent sniffer makes a call to `Context.getSystemService()` and passes it
    the identifier for the `ACTIVITY_SERVICE` flag, which is simply a string with
    the value of "activity". This returns an instance of the `ActivityManager` class,
    which allows the script to interact with the activity manager and make calls like
    `ActivityManager.getRecentTasks()`. This method takes in two arguments, the first
    is an integer which is the maximum number of the `RecentTaskInfo` objects the
    script wants to receive from the activity manager, and the second is a flag specifying
    the kind of recent activities. In this example, the script is written to request
    the full list without omitting any of the tasks. The reason I've written the script
    this way is because the intent that was sent to start each recent task comes bundled
    with the `RecentTaskInfo` object as a field called `RecentTaskInfo.baseIntent`.
    The script can then use it to extract some useful information about the intent,
    such as the component name, flags, actions, and categories. To keep things quick
    and easy here, the script then logs a call to the `Intent.toString()` method,
    which simply formats the information about the intent as string and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you are welcome to do more intelligent parsing of the intent information.
    You could even try working out a way to determine which package made the original
    call. Though this is very difficult, it would be quite a rewarding drozer module
    to pull off.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Intent Sniffer* Android application at [https://www.isecpartners.com/tools/mobile-security/intent-sniffer.aspx](https://www.isecpartners.com/tools/mobile-security/intent-sniffer.aspx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Context.getSystemService(String name)` command at [http://developer.android.com/reference/android/content/Context.html#getSystemService%28java.lang.String%29](http://developer.android.com/reference/android/content/Context.html#getSystemService%28java.lang.String%29)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ActivityManager.RecentTaskInfo* reference at [http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html](http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the *Intent* reference at [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services may not seem very dangerous, and they stick to working in the background.
    But they are developed to support the other application components, and could
    potentially perform very sensitive operations such as logging into an online profile,
    resetting a password, or even facilitating some potentially dangerous processes
    by serving as a proxy to the system services of the host device. Either way, they
    must not be overlooked during an application assessment.
  prefs: []
  type: TYPE_NORMAL
- en: When is a service vulnerable? Well, a service is exploitable when you can use
    its functionality to abuse the user, escalate the privileges of another application/user,
    or use it to extract sensitive information. This means that you need to be able
    to interact with the service, which means it must be exported, or respond/accept
    input from message formats like intents, files, or the network stack. Another
    thing to consider is what kind of permission is required to interact with the
    service—whether it's a potentially dangerous service, performs very sensitive
    operations, or could be abused to cause a **Denial of Service** (**DoS** ) condition
    (that is, when an attacker bars access to a service by forcing it to stop working
    or denying users its service) in the application or even the device! Not to mention
    what a bad situation the application and its user will be in should the potentially
    dangerous service not require any permissions at all!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I've highlighted some of the important areas here. You should notice that the
    service called `.services.LocationService`, which probably facilitates determining
    the user's location via the GPS services or Geolocation API, doesn't require any
    permissions to start! Given that the application itself would be granted both
    `android.permission.ACCESS_COARSE_LOCATION` and `android.permission.ACCESS_FINE_LOCATION`
    this means that there's a great chance that attackers may be able to make unauthorized
    use of this service should they be close enough to this service (which could be
    physical access to the device, or via a malicious application installed on the
    user's device).
  prefs: []
  type: TYPE_NORMAL
- en: The previous sample was taken from the *OWASPS GoatDroid* project, see the *See
    also* section for a link to the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: So that's what the vulnerability looks like from the code source, or rather
    the developer/reverse engineer's perspective. Let's get down to actually using
    drozer to attack some vulnerable services and give you the attacker's perspective
    of this vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how you go about finding some vulnerable services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a sample application, find out which services are exported. You can do
    this via drozer by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As I've explained in the previous chapter, this command finds services that
    don't require any permissions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you''ve found a bunch of services, you can launch them using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a simple example, this is how you would launch one of the services in the
    `com.linkedin.android` application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's always a good idea to have logcat running while you're stopping and starting
    these services, in case they might divulge some sensitive information about the
    way they operate and leak some authentication credentials or other useful data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Of course, if you want to send the service some data via an intent, you would
    need to know what the intent filters look like for the service you are targeting.
    And, if you haven't already guessed, the easiest way to know this is by inspecting
    the application manifest. If you need a recap on how to do this, refer to the
    *Inspecting the AndroidManifest.xml file* recipe in [Chapter 2](part0025_split_000.html#page
    "Chapter 2. Engaging with Application Security"), *Engaging with Application Security*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Essentially, the piece of XML you''re looking for would look something like
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To fire off intents to this service, you can execute the following command
    via the drozer console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As a side note, some services may interface native libraries and actually pass
    data accepted from intents to C/C++ data structures like the stack or heap-based
    variables. When auditing the security of a service that requires data to be passed
    via an intent, you should always try to identify any potential memory corruption
    vulnerabilities caused by the intent data. Keep this in mind when inspecting other
    application component types for vulnerabilities, since any application component
    may facilitate these kinds of vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some default system services that behave quite strangely when handcrafted
    intents are sent to them. Consider the following example of an intent send to
    `com.android.systemui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result on the Samsung Galaxy S3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a classic example of a DoS vulnerability. The System UI service does
    not anticipate intents with empty metadata or extra data fields. As a result,
    when an intent with no extra data is sent, it causes a null pointer exception
    and the entire service comes tumbling down. This vulnerability may not seem too
    harsh seeing that it's just a UI service. But if a key security mechanism or the
    UI component of a security-relevant service relies on the system UI service to
    be running in order for it to operate (for example, maybe the lock screen or the
    settings application), this simple dataless intent can cascade into a very complex,
    quite high-risk vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: To help you picture the danger here, imagine a malicious application installed
    on your phone that repeatedly sends harmful intents to your system UI service.
    This causes it to crash over and over again, filling your screen with pop ups
    and warnings, and effectively disallows your interaction with the user interface
    of your phone. It would make quite a nasty bug, and it wouldn't require any permissions
    to install!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Vulnerability Summary for CVE-2011-4276* webpage at [http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4276&cid=6](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4276&cid=6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *OWASP – GoatDroid* webpage at [https://github.com/jackMannino/OWASP-GoatDroid-Project/blob/master/](https://github.com/jackMannino/OWASP-GoatDroid-Project/blob/master/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking broadcast receivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadcast receivers respond to hardware- and software-level events; they get
    notifications for these events via intents. Often, broadcast receivers may use
    information sent via intents to perform sensitive operations and do so in a way
    that can be maliciously influenced by the data being broadcast or received.
  prefs: []
  type: TYPE_NORMAL
- en: When exploiting a broadcast receiver, the challenge is determining whether or
    not the input is trusted and how *badly*. For this, you may need to effectively
    fuzz the intent filter definitions for the broadcast receivers in your target
    application or read the actual code, if you manage to get your hands on it, to
    find out what kind of data the receiver operates on and how.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous recipes, here we are going to see a sample of a classic
    vulnerable broadcast receivers. The following sample, too, is from the OWASP GoatDroid
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The key issue in the code is that this application will be granted the `android.permission.SEND_SMS`
    permission while leaving its `.SendSMSNowReceiver` vulnerable receiver, without
    the protection of appropriate permissions and exposed to other applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is not all there is to these kinds of vulnerabilities; there is another
    part. Just because the receiver leaves other applications to interact with it
    doesn't necessarily mean that it's exploitable; to verify whether its exploitable,
    you can actually try firing off some of the commands discussed later in the recipe
    and—if possible—read some of the source code for the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code that determines how the receiver handles the `org.owasp.goatdroid.fourgoats.SOCIAL_SMS`
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The key issue in the code is that the receiver takes values straight from the
    `bundle` object without first checking the calling application or the values being
    supplied and plugs it into a `sendTextMessage` call. This basically means any
    application will be able to send arbitrary, uncontrolled SMSs.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so that's what a classic broadcast receiver vulnerability looks like;
    let's look at how one exploits these vulnerabilities practically, using drozer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To send an intent to a broadcast receiver, you execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, in the introduction section of this recipe, we saw a receiver
    that could accept phone numbers and text messages. To attack that receiver, you
    would fire-off the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Executing the previous command would send a text message containing the message
    `PWNED` to a phone number of `1234567890`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we abused the inadequate permissions protecting the `org.owasp.goatdroid.fourgoats.broadcastreceivers.SendSMSNowReceive`
    broadcast receiver. The lack of permissions protecting this component allows attackers
    with no `SEND_SMS` permission to actually send SMSs. The danger of this is that
    malicious attackers can develop applications that target this receiver to send
    SMSs to a premium service or leak information from the device.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, many Android Trojans and Android-based malware make use of this pattern
    to steal money from their victims; there are hundreds of practical examples of
    this. For good resources on some of them, see the *See also* section. Hopefully,
    this will make you aware of how dangerous inadequate permissions are for broadcast
    receivers like these.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *SMS Trojans: all around the world* article by *Denis Maslennikov* at Securelist
    ([https://www.securelist.com/en/blog/208193261/](https://www.securelist.com/en/blog/208193261/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Android Trojan Horse* project by *Jeremy Klein* and *Parker Spielman* ([http://www.cs.wustl.edu/~jain/cse571-11/ftp/trojan/index.html](http://www.cs.wustl.edu/~jain/cse571-11/ftp/trojan/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The First Android SMS Trojan Found in the Wild* article by *Tim Wyatt* at
    Lookout ([https://blog.lookout.com/blog/2010/08/10/security-alert-first-android-sms-trojan-found-in-the-wild/](https://blog.lookout.com/blog/2010/08/10/security-alert-first-android-sms-trojan-found-in-the-wild/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating vulnerable content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content providers often hold a lot of valuable information, such as users' phone
    numbers or Twitter passwords, and you may want to find out whether or not it's
    possible for malicious attackers to get their hands on this information. The best
    way to find out whether a content provider is vulnerable to attack is by trying
    to attack it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: For you to be able to attack a content provider, as with many application-level
    attacks, it usually comes down to sending a malicious intent to an application.
    When it comes to content providers, your intent will be honed towards its target
    by the URI string it contains, since this URI identifies which content provider
    should handle the intent.
  prefs: []
  type: TYPE_NORMAL
- en: So then there's just one problem—how do we find out which URIs to use? One simple
    solution would be to guess them, but that could take ages! drozer has a module
    called `app.provider.info` that solves this problem for you.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe details a few drozer modules that you can use to find content providers
    that may be vulnerable to attack.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find some content providers that will most likely be vulnerable to attack,
    you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding content providers that require no permissions is really easy with drozer;
    all you need to do is execute the following command from your drozer console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command lists all the content providers that don't require any
    read/write permissions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you''ve found an appropriate content provider, you may want to enumerate
    the URIs it has authority over; you can do this using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding command, `[package]` is the full name of the package you want
    to extract information about.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following command is an example you can try out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So what you've just done is find a possible entry point into the data that a
    given package saves in its content provider. The next recipe discusses how to
    extract this data.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.finduri` module is pretty straightforward; it actually uses a very "sneaky"
    method to enumerate the possible content URIs. What it basically does is open
    the `DEX` file for the application and scan the unparsed file for any string literals
    resembling the valid content URI-format strings. The reason this is so effective
    is that application developers usually save these as static strings in the source
    of the application. The following is the actual source code for the Python script.
    It is extracted from [https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: drozer Master repository – Provider.py ([https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/app/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/app/provider.py))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: drozer Master – Common/Provider.py ([https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Developer – URI permissions ([http://developer.android.com/guide/topics/security/permissions.html#uri](http://developer.android.com/guide/topics/security/permissions.html#uri))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CVE-2013-231 – MovatwiTouch content provider vulnerability ([http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2318&cid=3](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2318&cid=3))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marakana – Android content provider tutorial ([http://marakana.com/s/post/1375/android_content_provider_tutorial](http://marakana.com/s/post/1375/android_content_provider_tutorial))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from vulnerable content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If some of the content provider's URIs require no **read** permissions and/or
    **GrantURI** is set to `true`, you may be able to extract data from it using some
    of the drozer tools. Also, in certain situations, the way **read**/**write** permissions
    are issued and enforced also exposes the data in a content provider to attacks.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will covers some simple tricks that you can use to get a feel of
    the kind of information stored in the provider. This recipe follows from the previous
    one and assumes you've already enumerated some content URIs and determined that
    either none or insufficient permissions are required to interact and query the
    related URIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve found a URI, you''d query using the commands detailed in the previous
    recipe, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will give you some pretty useful URIs to target; you
    can then execute the following command to extract some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a simple example; the drozer help documents about a lot of
    the content-provider-related scripts use this very example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example from a sample vulnerable content provider. In this example,
    the attacker uses drozer-extracted information about a user''s banking transactions;
    see the following screenshot for the output from the query command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some content providers support the querying of files, especially those of file-manager-type
    applications. If the content provider makes no restrictions over the kinds of
    files and paths that applications are allowed to read from, it means that the
    attacker may be able to either perform the path traversal of directories outside
    the files that the content provider actually intends to offer or in many cases,
    allow attackers to extract files from sensitive directories on the victim''s device.
    To extract files, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, `URI` would be the URI to the file that you want
    to extract from the content provider. If there is no protection or filtering of
    input performed in the actual implementation of the part of the content provider
    that handles these kinds of queries, you could inject file paths and abuse the
    lack of protection to enumerate files and files'' contents in other areas of the
    device''s filesystem; you would do this by trying different file paths as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, `[valid-URI]` would be a URI that the vulnerable
    content provider has authority over or has been registered to handle, `[other
    file path]` would be the path to the file you wish to extract, and `[local-path]`
    would be a file path to the place you would like this file to be "downloaded".
    The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For those of you who have any experience in hacking/auditing web applications,
    this is quite similar to path traversal and local file inclusion vulnerabilities
    in web applications. It also exposes Android applications to many of the same
    risks. A couple of practical examples of this vulnerability have been reported
    against very popular applications; see the *See Also...* section of the recipe
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your content provider sets path level permissions using the `PATTERN_LITERAL`
    matching type, the Android permissions framework will only enforce checks to protect
    your content provider if the paths requested match yours exactly! The following
    screenshot an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This current example is taken from MWR labs' Sieve Android app, which was developed
    with certain vulnerabilities built into it; see the *See also* section for a link
    to the download page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous screenshot, we can see that this app uses `PATTERN_LITERAL`-type
    matching to protect the `Keys` path, which means that if we try to query it using
    drozer, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output from previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows how a permission denial is caused because drozer
    doesn''t have the required permissions to interact with the provider. But, if
    we simply append `/` to the path, it will still be valid, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A forward slash was added to the path, so the `PATTERN_LITERAL` check failed
    to find the `content://com.mwr.example.sieve.DBConentProvider/Keys` path and found
    the `content://com.mwr.example.sieve.DBConentProvider/Keys/` path instead. This
    means that the application querying the content provider would then need permissions
    for the `/Keys/` path, which was not defined and thus required no permissions,
    allowing the query to be resolved without a hitch. In the previous screenshot,
    we can see that in this instance, a malicious application would be able to extract
    details of a user's login pin for the Sieve password manager application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Path traversal vulnerability on Shazam (Android) application* article ([http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-shazam-android-application/](http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-shazam-android-application/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Path traversal vulnerability in Adobe Reader (Android) application* article
    ([http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application/](http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *WinZip for Android Content Handling Directory Traversal Vulnerability*
    article ([http://vuln.sg/winzip101-en.html](http://vuln.sg/winzip101-en.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android 2.3.4 Browser Local File Inclusion at CVE Details; **CVE-2010-4804**
    ([http://www.cvedetails.com/cve/CVE-2010-4804/](http://www.cvedetails.com/cve/CVE-2010-4804/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: drozer Sieve – A password manager app that showcases some common Android vulnerabilities
    ([https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk](https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data into content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any database-orientated application, content providers may also facilitate
    the ability to insert data into their SQLite databases or file stores; should
    any content provider not restrict this functionality using the appropriate **write**
    permissions, an attacker may be able to insert data into the SQLite database maliciously.
    This tutorial discusses how you can perform this kind of attack; in the next chapter,
    we will look at the actual code that causes these vulnerabilities and discuss
    some remedies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go inserting data into the content providers, we need to know what
    the schema or column set up for the database looks like; you can enumerate this
    information using the following command from your drozer console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command `[URI]` is the URI you wish to find out about. For
    instance, if you want to run it against Sieve, you would execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The reason enumerating the columns of a database is useful is that it may help
    you structure your future attacks against the content provider; you may need to
    know a little about the schema to be able to know which columns and rows you might
    be interested in extracting from and inserting into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you know a little about the database''s structure and which column names
    you may need to be able to structure your queries correctly, you can insert data
    into a content provider using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, `[URI]` is the URI pointing to the related database
    and `--boolean`, `--integer`, and `--string` is a flag you should provide to mark
    a given piece of data as a given data type. This module supports the following
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Each of them require the `[name]` value, which indicates the column name, and
    `[value]`, which indicates the actual value you wish to insert.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The following is a fictitious example. The `content://com.example.vulnerabledatabase.contentprovider/statement`
    URI probably doesn't exist on your device, unless you've explicitly developed
    some app that handles it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following a working example against Sieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you query Sieve''s Passwords URI and perform the previous command, the
    following data is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can clearly see that for **_id** **3** the data we just injected actually
    appears in the database. This means we've just managed to corrupt the data in
    the Passwords database with some forged data. In a practical context, this could
    allow attackers to change a user's passwords or delete them, which could deny
    users access to the related accounts; more specifically, in a password-management
    application such as Sieve—used here as an example—attackers would be able to bar
    users' access to their stored passwords and maybe even their Gmail, Twitter, or
    LinkedIn accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little side note about the example: we injected the password string `woopwoop`
    merely as a marker to make sure we can inject password data—its merely a string
    that''s pretty easy to recognize; if you''re going to test this password, it probably
    would not work. To actually inject a working password, you need to inject the
    base64 encoded value of the password.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating SQL-injection vulnerable content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like web applications, Android applications may use untrusted input to
    construct SQL queries and do so in a way that's exploitable. The most common case
    is when applications do not sanitize input for any SQL and do not limit access
    to content providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would you want to stop a SQL-injection attack? Well, let''s say you''re
    in the classic situation of trying to authorize users by comparing a username
    supplied by querying a database for it. The code would look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, none of the `projection`, `selection`, `selectionArgs`,
    or `sortOrder` variables are sourced directly from external applications. If the
    content provider is exported and grants URI permissions or, as we've seem before,
    does not require any permissions, it means that attackers will be able to inject
    arbitrary SQL to augment the way the malicious query is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how you actually go about attacking SQL-injection vulnerable content
    providers using drozer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, I''ll talk about two kinds of SQL-injection vulnerabilities:
    one is when the select clause of a SQL statement is injectable and the other is
    when the projection is injectable. Using drozer, it is pretty easy to find select-clause-injectable
    content providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The previous will try to inject what's called a logical tautology into the SQL
    statement being parsed by the content provider and eventually the database query
    parser. Due to the nature of the module being used here, you can tell whether
    or not it actually worked, because it should return all the data from the database;
    that is, the select-clause criteria is applied to every row and because it will
    always return true, every row will be returned!
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also try any values that would always be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of using a purposely vulnerable content provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the entire table being queried, which is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can, of course, inject into the projection of the `SELECT` statement, that
    is, the part before `FROM` in the statement, that is, `SELECT [projection] FROM
    [table] WHERE [select clause]`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *SQL As Understood By SQLite* article at the SQLite Language Reference guide
    ([http://www.sqlite.org/lang.html](http://www.sqlite.org/lang.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL-injection article at [https://www.owasp.org/index.php/SQL_Injection](https://www.owasp.org/index.php/SQL_Injection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting debuggable applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications can be marked as debuggable to make functionality testing and error
    tracking a lot easier by allowing you to set breakpoints during app execution.
    To do this, view the VM stack and suspend and resume threads while the app is
    running on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, some applications on the Google Play store are still flagged
    as debuggable. This may not always be the end of the world, but if the app hopes
    to protect any authentication data, passwords addresses, or any values stored
    in the applications memory, having it marked as debuggable means that attackers
    will be able to gain access to this data very easily.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe discusses how to leak variable values from a debuggable application.
    Attackers may also be able to trigger remote-code execution via the app and run
    some code within the applications context.
  prefs: []
  type: TYPE_NORMAL
- en: The example being used here is the Android Wall Street Journal app and at the
    time of writing, it was one of the applications on the Google Play store that
    were published as debuggable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you''ll need to do is determine whether or not the application
    is debuggable. This is fairly simple, because whether or not an application is
    debuggable depends directly on its application manifest. The `debuggable` field
    in the application element of the Android application manifest. To enumerate and
    exploit debuggable applications you will need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether or not an application is debuggable, you can either extract
    the manifest or execute the following command from your drozer console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will list all the packages that are set as debuggable and display the
    permissions they''ve been granted. The following screenshot shows a list of the
    packages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00100.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You may be asking yourself whether or not a simple vulnerability like this
    actually occurs in the real world? Well, yes, it actually still does! The following
    screenshot shows a relatively well known app that''s been published to the Google
    Play market as debuggable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00101.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This example shows an output from the `.debuggable` module indicating that the
    Wall Street Journal Reader app is debuggable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you''ve identified a good target, you should launch it using a command
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it''s running, you can use ADB to get the Java Debug Wire Protocol Port
    which has been opened for that instance of the VM for debugging; the following
    is how you do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see something like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00102.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The number returned by ADB is the port you can use to connect to the VM, but
    before you can do that from your machine, you need to forward that port via `adb`;
    the following is how you do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the example in the screenshot, you would execute the following command
    to forward the port:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00103.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You can now access the VM running this app from your machine. From this point
    on, you can rely on the Java Debugger to connect to the VM; you do this by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `[PORT]` port you would use would be the one forwarded in the previous
    step; in this example, that would be `31337`. Connecting via `jdb` would work
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00104.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Then you would be connected to the VM running this app on the Android device;
    you can then do things such as extract information about the classes compiled
    with the application; this is done by executing the following command from within
    your `jdb` session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This would produce output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00105.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You can also enumerate the methods per class by firing off the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding command, `[class-path]` is the full class path of the class
    would like to know about.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following is a screenshot demonstrating the previous command against an
    application package called `com.example.readmycontacts`. Here we are extracting
    information about the `.MainActivity` class, which is the class called to launch
    the activity.![How to do it...](img/00106.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can even dig a little deeper and list the "fields" or class attribute names
    and values for a given class; this is done by executing the following command
    from within JDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why would you, as an Android application hacker, be interested in reading values
    from the fields in a class file? Well, because developers may often explicitly
    store sensitive details inside a class file instead of fetching them from the
    cloud; so you can expect values, such as passwords, API tokens, single-sign-on
    tokens, default usernames, and generally any data used for authentication or other
    sensitive operations saved inside a class's fields.
  prefs: []
  type: TYPE_NORMAL
- en: For some Android operating systems, specifically any unpatched Gingerbread device
    and any lower version. This vulnerability could mean that malicious applications
    may be able to execute the arbitrary command in the context of another application.
    Why only Gingerbread and lower? Well before the update of the Dalvik virtual machine
    to Gingerbread, the Dalvik caused debuggable applications to try to connect to
    the Java Debug Wire Protocol port even when ADB was not running; this means that
    malicious applications capable of opening networking sockets on the targeted device
    would be able to accept connections from debuggable applications and, because
    of how Java Debugging works, be able to execute arbitrary code. For more details
    on this behavior, visit the link to the *Debuggable Apps in Android Market article*
    in the *See also* section as well as the links to the Dalvik Virtual Machine code
    for different versions.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot more things you can do with the Java debugger; for those of
    you who want to learn a little more about it, I've included some useful links
    in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Jdb – The Java Debugger* article at [http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/jdb.html](http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/jdb.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Java Platform Debugger Architecture* article at [http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/index.html](http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Android:debuggable – Android Developer Reference* guide at [http://developer.android.com/guide/topics/manifest/application-element.html#debug](http://developer.android.com/guide/topics/manifest/application-element.html#debug)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debuggable Apps in Android Market* article at MWRLabs ([http://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/](http://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Exploit (& Fix) Android "Master Key"* article by Saurik at [http://www.saurik.com/id/17](http://www.saurik.com/id/17)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging Java Programs using JDB* article at [http://www.packtpub.com/article/debugging-java-programs-using-jdb](http://www.packtpub.com/article/debugging-java-programs-using-jdb)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JdwpAdb.c – Kitkat release, Android Source Code repository ([https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/jdwp/JdwpAdb.cpp](https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/jdwp/JdwpAdb.cpp))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JdwpAdb.c – Éclair Passion release, Android Source Code repository ([https://android.googlesource.com/platform/dalvik/+/eclair-passion-release/vm/jdwp/JdwpAdb.c](https://android.googlesource.com/platform/dalvik/+/eclair-passion-release/vm/jdwp/JdwpAdb.c))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JdwpAdb.c – Gingerbread release, Android Source Code repository ([https://android.googlesource.com/platform/dalvik/+/gingerbread-release/vm/jdwp/JdwpAdb.c](https://android.googlesource.com/platform/dalvik/+/gingerbread-release/vm/jdwp/JdwpAdb.c))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Man-in-the-middle attacks on applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile phone users often use public Wi-Fi networks to access the Internet in
    coffee shops, libraries, and anywhere they are available. Unfortunately, due to
    how certain applications are developed, they can still fall victim to **man-in-the-middle**
    (**MITM**) attacks. For those of you who don't know about MITM attacks, they are
    essentially attacks that allow adversaries to intercept your communication with
    the devices on your network; if you'd like to know more about the danger and technical
    specifics of these attacks in nonmobile contexts, check out some of the links
    in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: Why should we care about MITM attacks on mobile phones? Well, depending on how
    badly the content from an "insecure" channel to network-based resources is trusted,
    attackers may be able to do anything, from fingerprinting the applications running
    on your device to detailing every place where you've been, approximately where
    you live and work, and even take control of some applications on your mobile device
    and maybe even your entire phone—if its rooted insecurely or can be rooted. There
    are numerous practical examples of vulnerabilities in very popular applications,
    which can be exploited using man-in-the-middle attacks; check out the links in
    the *See also* section for some of them.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to perform an MITM attack on an Android phone and
    one simple exploit that can be used during an MITM attack, namely DNS poisoning.
  prefs: []
  type: TYPE_NORMAL
- en: One small caveat here is that Ettercap, the tool being used to perform the MITM
    attack, doesn't officially provide any Windows support. Though, if you don't have
    an Ubuntu or Debian Linux machine, you can set one up, simply download a CD/DVD
    image for Ubuntu and run it from a virtual machine using Oracle's Virtualbox,
    or VMware works quite well for this too. To find out how to install a virtual
    machine, see the *There's more…* section of the *Installing and setting up Santuko*
    recipe in [Chapter 3](part0032_split_000.html#page "Chapter 3. Android Security
    Assessment Tools"), *Android Security Assessment Tools*. If you're really keen
    on using Ettercap on your Windows machines, you can check out the download links
    to the unofficial Windows binaries in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make this whole process a lot simpler, I''m going show you guys how to download
    an awesome tool that makes MITM attacks really easy. You can download Ettercap
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once it's downloaded and set up, you can get going with the MITM attack.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start setting up the MITM attack, you will need to set up the DNS
    Spoof plugin for Ettercap; the only thing you need to do is add some useful addresses
    to the DNS configs script for Ettercap that is saved in `/usr/share/ettercap/etter.dns`
    on Linux machines.![How to do it...](img/00108.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `etter.dns` file should look a little something like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00109.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'After editing this file, it should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00110.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The address `192.168.10.102` should be replaced with the Internet address of
    your machine, since you'd like to spoof the DNS server using your machine, which
    basically means your machine will act as the DNS server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the DNS plugin has been set up properly, you can start an MITM attack
    by executing the following command from your terminal or command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding command, `[interface]` is the network interface you're using
    to connect to the network; it could be either an Ethernet or wireless interface.
    `[address of target]` is the Internet address of your Android device; you can
    find this on your Android phone under **Settings** | **Wi-Fi** | **[name of network]**
    | **IP Address**. `[address of gateway]` is the Internet address of the default
    gateway for this network. This attack fools your mobile phone into thinking that
    the machine you are attacking from is the actual gateway by abusing the lack of
    authentication of the **Address Resolution Protocol** (**ARP**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, if your gateway''s IP address is `192.168.10.1` and your Android
    device''s IP is `192.168.10.106`, the following is how you would set up the MITM
    attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can interchange the last two addresses; the order doesn''t matter as long
    as they are both there. After executing this command, you should see the following
    appear on your terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00111.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: After a while, you should see something similar to the following screenshot
    of the traffic being logged by Ettercap:![How to do it...](img/00112.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you start some apps using this "poisoned" network, you'll be able to see
    some strange things happen on your attacker machine; for instance, you'll be able
    to see the DNS requests being sent by your Android apps; The following screenshot
    shows the DNS requests sent by the Flipboard app:![How to do it...](img/00113.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This output was generated by Wireshark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have a web server configured on your machine, you'll be able to serve
    some content to your Android phone by pretending to be websites such as LinkedIn
    and Google; the following are some screenshots demonstrating this:![How to do
    it...](img/00114.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s another example; a request to [www.google.com](http://www.google.com)
    has been intercepted in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00115.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Clearly, these are not LinkedIn and Google webpages; in fact, the page returned
    here is from a local machine to the network. This may be a very mundane demonstration,
    though it covers the hard part of the attack, which is establishing the MITM context
    in which an attacker is capable of controlling the responses an application issues
    to the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: What you can do from here, once you have established your MITM context, is either
    exploit the mobile browser using something such as Metasploit and its `browser_autopwn`
    module or use some social engineering by mirroring these sites using a tool—the
    Social Engineering Toolkit works great for this. See the *See also* section for
    links to information about these great tools.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the run-of-the-mill MITM attacks, there are classes of MITM attacks
    specific to Android, namely, those targeting applications that use an unsecured
    `addJavaScriptInterface` WebKit and related API calls. For more on this vulnerability,
    see the links to the *Adventures with Android WebViews* article and the *Attacks
    on WebView in the Android System* in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Attacks on WebView in the Android System* paper by Tongbo Luo, Hao Hao,
    Wenliang Yifei Wang, and Heng Yin ([http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf](http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *WebView addJavaScriptInterface Remote Code Execution* paper at MWR InfoSecurity
    ([https://labs.mwrinfosecurity.com/system/assets/563/original/mwri_webview-addjavascriptinterface-code-execution_2013-09-23.pdf](https://labs.mwrinfosecurity.com/system/assets/563/original/mwri_webview-addjavascriptinterface-code-execution_2013-09-23.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adventures with Android WebViews* article at MWR labs ([https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/](https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ettercap Windows Binaries ([http://sourceforge.net/projects/ettercap/files/unofficial%20binaries/windows/](http://sourceforge.net/projects/ettercap/files/unofficial%20binaries/windows/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ettercap homepage ([http://ettercap.github.io/ettercap/index.html](http://ettercap.github.io/ettercap/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Metasploit Browser Autopwn* article at Penetration Testing Lab ([http://pentestlab.wordpress.com/2012/04/23/metasploit-browser-autopwn/](http://pentestlab.wordpress.com/2012/04/23/metasploit-browser-autopwn/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cain and Abel homepage ([http://www.oxid.it/cain.html](http://www.oxid.it/cain.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethernet Address Resolution Protocol, Internet Standard STD 37 ([http://tools.ietf.org/html/rfc826](http://tools.ietf.org/html/rfc826))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
