- en: Chapter 4. Exploiting Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 利用应用程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Information disclosure via logcat
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过logcat泄露信息
- en: Inspecting the network traffic
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查网络流量
- en: Passive intent sniffing via the activity manager
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过活动管理器进行被动意图嗅探
- en: Attacking services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击服务
- en: Attacking broadcast receivers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击广播接收器
- en: Enumerating vulnerable content providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举易受攻击的内容提供者
- en: Extracting data from vulnerable content providers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从易受攻击的内容提供者中提取数据
- en: Inserting data into content providers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向内容提供者插入数据
- en: Enumerating SQL-injection vulnerable content providers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举易受SQL注入攻击的内容提供者
- en: Exploiting debuggable applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用可调试的应用程序
- en: Man-in-the-middle attacks on applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应用程序进行中间人攻击
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: So far, we've covered some of the basic development and security assessment
    tools, and we even covered some examples of extending and customizing these tools.
    This chapter will focus on the use of these tools to analyze the Android applications
    to identify vulnerabilities and develop exploits for them. Although, given the
    arbitrary nature of application functionality and the almost limitless creativity
    Android application developers can exercise, it's not hard to see that assessing
    the security of Android applications must be considered an art. What this means
    for you as a security auditor, analyst, consultant, or hobbyist is that you can
    be sure that there will never be a fully autonomous method to analyze the security
    of the Android application. Almost always, you'd need to rely on your creativity
    and analysis to deliver a concrete assessment of an Android application's security.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了一些基本开发和安全评估工具，甚至还涵盖了扩展和定制这些工具的一些示例。本章将重点介绍如何使用这些工具分析Android应用程序，以识别漏洞并为它们开发利用程序。尽管如此，鉴于应用程序功能的任意性以及Android应用程序开发人员几乎无限的创造力，不难看出评估Android应用程序的安全性必须被视为一门艺术。对于作为安全审计师、分析师、顾问或爱好者的你来说，这意味着可以肯定，永远不会有一个完全自动化的方法来分析Android应用程序的安全性。几乎总是，你需要依赖自己的创造力和分析能力，为Android应用程序的安全性提供一个具体的评估。
- en: Before we start banging away at some apps, it's important to frame the Android
    application security problem, define some goals, and enumerate the application
    attack surface. In the next few sections, we will discuss some of the generic
    goals of application security and the controls that should be in place to help
    achieve these goals. The reason discussing application security goals is so important
    is because it helps to make sure that you've got the right mindset and principles
    in place when accessing the security of an application. Also, it makes auditing
    application security as simple as verifying the existence of these controls and
    then developing ways to exploit either the lack or the inadequacy of the mentioned
    controls.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入探讨一些应用程序之前，重要的是要明确Android应用程序的安全问题，定义一些目标，并列举应用程序的攻击面。在接下来的几节中，我们将讨论应用程序安全的一些通用目标以及为实现这些目标应该实施的控件。之所以讨论应用程序安全目标非常重要，是因为这有助于确保在评估应用程序安全性时，你拥有正确的心态和原则。同时，它也使得审核应用程序安全变得简单，只需验证这些控件的存在，然后开发利用这些控件缺失或不足的方法。
- en: So what are the goals of application security?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么应用程序安全的目的是什么？
- en: Protecting user data
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护用户数据
- en: 'Applications are often entrusted with very sensitive data related to users,
    some examples are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序常常被托付与用户相关的非常敏感的数据，以下是一些例子：
- en: Passwords
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Authentication tokens
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证令牌
- en: Contacts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人
- en: Communication records
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信记录
- en: IP addresses or domain names to sensitive services
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址或域名到敏感服务
- en: Each application's data is cached if it is so inclined, and may often explicitly
    save the user content in the databases, XML files, or any other disk storage format;
    they have the freedom to use any file format or storage mechanism they need. It's
    important to assess the security of these data stores with the same diligence
    that is applied to assessing and auditing online or cloud-based databases and
    information storage mechanisms, especially because the information stored in an
    application can influence the security of websites and other cloud services. For
    example, if an attacker proliferates authentication credentials to a cloud service
    from an application, he/she immediately has access to the actual cloud service.
    Think about online banking apps as well, and the two factor authentication tokens
    these apps store and how they are stored—the SMS inbox? Really!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个应用程序有此倾向，其数据将被缓存，并且通常会明确地将用户内容保存在数据库、XML文件或其他任何磁盘存储格式中；它们有自由使用所需的任何文件格式或存储机制。评估这些数据存储的安全性同样重要，就像评估和审计在线或基于云的数据库和信息存储机制一样，特别是由于应用程序中存储的信息可能影响网站和其他云服务的安全性。例如，如果攻击者从应用程序传播到云服务的认证凭据，他/她立即可以访问实际的云服务。同样考虑在线银行应用，以及这些应用存储的双重认证令牌以及它们的存储方式——短信收件箱？真的吗！
- en: 'Applications need to enforce many of the controls that online databases use
    independent of those provided by the Android operating system; namely, the controls
    that ensure the following properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要实施许多在线数据库所使用的控制措施，这些措施独立于Android操作系统所提供的；即确保以下属性的控制措施：
- en: Confidentiality
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机密性
- en: Integrity
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性
- en: Availability
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Nonrepudiation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可抵赖性
- en: Authentication
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: We will discuss how to ensure these controls in the later chapters. For now,
    all that you need to concentrate on is understanding the risks which the user
    incurs when these controls are not enforced.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中讨论如何确保这些控制措施。现在，你需要集中精力理解的是，当这些控制措施不被执行时，用户所承担的风险。
- en: Protecting applications from one another (isolation and privilege separation)
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护应用彼此之间（隔离与权限分离）
- en: Applications are protected via the Android sandbox, which is just another way
    of saying that each application is assigned a user ID and only inherently has
    access to its own resources. This is the story of application isolation as far
    as the Linux portion of Android is concerned. Android introduced some of its own
    protection mechanisms to keep apps from abusing each other's components and data;
    the most notable being the Android permissions framework, which operates at the
    application level and is enforced by the application middleware. It exists to
    translate the Linux access control mechanism to application level and vice versa.
    Speaking more practically, this means that every time an application is granted
    a permission, it may mean that the related UID is assigned a corresponding GID.
    For example, `android.permission.INTERNET`, which is mapped to the `inet` group.
    Any application granted this permission will be placed in the `inet` group.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过Android沙盒受到保护，这意味着每个应用程序都被分配了一个用户ID，本质上只能访问自己的资源。这是就Android中Linux部分而言的应用程序隔离的故事。Android引入了一些自己的保护机制，以防止应用程序相互滥用组件和数据；最值得注意的是Android权限框架，它在应用程序级别上操作，并由应用程序中间件执行。它的存在是为了将Linux访问控制机制转换为应用程序级别，反之亦然。从更实际的角度来说，这意味着每次应用程序被授予一个权限，可能意味着相关的UID被分配了一个相应的GID。例如，`android.permission.INTERNET`
    权限被映射到 `inet` 组。任何被授予此权限的应用程序将被放置在 `inet` 组中。
- en: Applications often consist of many instances of the classic application components,
    services, content providers, activities, and broadcast receivers. To protect these
    components from malicious or any unintentional harmful influence, it's imperative
    that application developers communicate and mitigate the risk their applications
    introduce to the user with regard to the services and data they can access. The
    application developers should also respect the integrity of these resources. These
    two principles of secure development can be enforced by the permissions framework
    by ensuring that they only request the necessary permissions and are not overzealous
    in the permissions they expect to be granted. The key here is making sure that
    developers practice the principle of least privilege. Protection from malicious
    apps can be enforced partly by ensuring that the correct permissions are required
    to access a given application's components and data, and only the necessary services
    and components are made available to the rest of the system at large, that is,
    don't export components when you don't need to.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用通常由许多经典应用组件的实例组成，如服务、内容提供者、活动和广播接收器。为了保护这些组件免受恶意或任何非意图的损害，应用开发者必须与用户沟通并减轻他们的应用在服务和数据访问方面给用户带来的风险。应用开发者还应尊重这些资源的完整性。通过确保他们只请求必要的权限并且不过分要求被授予的权限，安全开发这两大原则可以通过权限框架来实施。关键是确保开发者遵循最小权限原则。通过确保访问给定应用的组件和数据需要正确的权限，并且只向整个系统提供必要的服务和组件，可以在一定程度上防止恶意应用，即在不必要时不要导出组件。
- en: When analyzing the isolation an application enforces for its data and components,
    it's important to take into context the permissions required to access them. How
    easy is it to get these permissions granted? Are permissions required to access
    a given component assigned the correct protection level? A bad example would be
    an app that facilitates searching and retrieving a user's bank statements with
    only the `android.permission.SEARCH` permission.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析应用对其数据和组件实施的隔离措施时，考虑访问它们所需的权限是非常重要的。获取这些权限是否容易？访问给定组件所需的权限是否被赋予了正确的保护级别？一个不好的例子是，仅使用`android.permission.SEARCH`权限就能轻松搜索和获取用户银行对账单的应用。
- en: Protecting communication of sensitive information
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护敏感信息的通信
- en: It's not enough that application developers protect the data their applications
    store, they also need to be mindful of the way this information is communicated.
    For instance, consider an application that stores a user's data securely but allows
    it to be communicated to unauthorized parties. All the data storage security in
    the world means nothing if communication isn't done securely!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用开发者保护应用存储的数据是不够的，他们还需要注意这些信息的通信方式。例如，考虑一个应用虽然安全地存储了用户数据，但却允许将其传达给未经授权的第三方。如果通信不安全，那么世界上所有的数据存储安全都毫无意义！
- en: 'Communication can be done in the following ways:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通信可以通过以下方式完成：
- en: '**Inter-component communication**: Applications often need to send information
    between their respective components, for example, between a broadcast receiver
    and an activity. Seeing that this communication may be facilitated via intents
    and intent filters, and given the nonexclusive nature of intent filters, it''s
    possible that unauthorized applications may intercept this communication in various
    ways.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件间通信**：应用通常需要在其各自组件之间发送信息，例如，在广播接收器和活动之间。考虑到这种通信可能通过意图和意图过滤器来促进，并且意图过滤器的非排他性，未授权的应用可能以各种方式截取此通信。'
- en: '**Inter-application communication**: Data communication between applications
    should be done in a way that will prevent unauthorized applications from tampering,
    intercepting, or gaining access to it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用间通信**：应用之间的数据通信应以防止未授权应用篡改、截取或获取数据的方式进行。'
- en: '**Extra-device communication**: It''s possible that apps will make use of NFC,
    Bluetooth, GMS, or Wi-Fi communication mediums to transmit sensitive data. Application
    developers must take the proper precautions to ensure the confidentiality, integrity,
    and non-repudiation of data communicated this way.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨设备通信**：应用可能会利用NFC、蓝牙、GMS或Wi-Fi等通信媒介传输敏感数据。应用开发者必须采取适当的预防措施，确保以这种方式通信的数据的保密性、完整性和不可抵赖性。'
- en: 'So, when auditing an application for communication faults, it''s important
    to look for controls that provide the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在审核应用程序的通信故障时，查看提供以下内容的控制措施非常重要：
- en: Authentication between both the receiving and initiating application
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收和发起应用程序之间的身份验证
- en: Access control preventing unauthorized parties/applications from gaining access
    to the communicated data or controlling the flow of communication
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制，防止未经授权的第三方/应用程序获取通信数据或控制通信流程
- en: So hopefully, you actually read the introduction and have a good grasp of the
    controls that are expected from secure applications; because in the next sections,
    I'll walk through how to verify whether these controls are in place or not, and
    how to take advantage of the lack of these controls.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，希望你已经阅读了介绍，并对安全应用程序所期望的控制措施有了很好的了解；因为接下来，我将介绍如何验证这些控制措施是否已经实施，以及如何利用这些控制措施的缺失。
- en: Information disclosure via logcat
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过logcat信息泄露
- en: Android applications may leak sensitive information either inherently or as
    a result of harmful influence. When this happens, it's called an *Information
    disclosure* vulnerability. This recipe talks about how to check an application
    for potential leaks of sensitive information by inspecting the Android logcat,
    which is used by the application developers as a debugging tool. We will also
    talk about how you can take advantage of one of Android's built-in benchmarking
    tools to help make logcat inspection a little more rewarding.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序可能会固有地或由于有害影响而泄露敏感信息。当这种情况发生时，它被称为*信息泄露*漏洞。这个环节讲述了如何通过检查应用程序开发人员用作调试工具的Android
    logcat来检查应用程序潜在的敏感信息泄露。我们还将讨论如何利用Android内置的一个基准测试工具，使logcat检查更有成效。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, you will need the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要以下内容：
- en: An emulator or an Android device set up and connected to your machine via ADB,
    this will require USB Debugging to be enabled on your Android device
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通过ADB连接到你的机器的模拟器或Android设备，这将需要在你Android设备上启用USB调试
- en: The **Android Debug Bridge** (**ADB**)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android调试桥**（**ADB**）'
- en: Before beginning with this recipe, you should have already downloaded and updated
    your Android SDK. You should have either set up your `PATH` variables appropriately,
    or you should be in the working directory that contains the appropriate tools/binaries.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个环节之前，你应该已经下载并更新了你的Android SDK。你应该已经适当地设置了你的`PATH`变量，或者你应该处于包含适当工具/二进制文件的工作目录中。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start off, let''s enable debugging via the ADB. On either Windows or Linux
    execute the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过ADB启用调试。在Windows或Linux上执行以下命令：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will only work if you are in the correct working directory, which is `[path-to-sdk]/sdk/platform-tools/`
    for Linux users or `[path-to-sdk]\sdk\platformtools\` for Windows users.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在您处于正确的的工作目录下才会起作用，对于Linux用户来说是 `[path-to-sdk]/sdk/platform-tools/`，对于Windows用户来说是
    `[path-to-sdk]\sdk\platformtools\`。
- en: 'This will output the logging information of some of the software- and hardware-level
    events. Naturally, we would like to focus this on the events and applications
    we are inspecting for security vulnerabilities. Luckily, logcat is capable of
    filtering through the log information. Here''s a breakdown of all the options:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一些软件和硬件级别事件的日志信息。自然地，我们希望将关注点放在我们正在检查安全漏洞的事件和应用程序上。幸运的是，logcat能够筛选日志信息。以下是所有选项的详细说明：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Where `[options]` can be any one of the following—I''ve omitted some of them
    to keep things short and to the point:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`[options]`可以是以下任何一个——为了简洁和切中要点，我省略了一些：
- en: '`-v <format>`: This option sets the format of the output; this could be either
    `brief`, `process`, `tag`, `thread`, `raw`, `time`, `threadtime`, or `long`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v <format>`：这个选项设置输出的格式；可能是`brief`、`process`、`tag`、`thread`、`raw`、`time`、`threadtime`或`long`'
- en: '`-d`: This option dumps the logfile and exits'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：这个选项会转存日志文件并退出'
- en: 'And `[filter]` is a list of the `tag:priority` command, which is discussed
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`[filter]`是一个`tag:priority`命令列表，下面将进行讨论：'
- en: '`tag`: It is the string that identifies a log component. Log components are
    the strings that log outputs. For instance, if the log output looks like the following:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`：它是标识日志组件的字符串。日志组件是输出日志的字符串。例如，如果日志输出如下所示：'
- en: '[PRE2]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`ClockAlarmWidget`, the part that is highlighted in the previous code would
    be the log component tag. The part preceding the `/` is called the priority. Here,
    the priority is `Error`, and it is indicated by an `E`.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ClockAlarmWidget`，在之前代码中高亮的部分将是日志组件标签。在`/`之前的部分称为优先级。这里，优先级是`Error`，由`E`表示。'
- en: '`priority`: It can be any one of the following:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority`：可以是以下任何一个：'
- en: '`V, verbose`: It enables verbose logging'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V, verbose`：它启用了详细日志记录'
- en: '`D, debug`: It enables debug logging'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D, debug`：它启用了调试日志记录'
- en: '`I, Info`: It enables logging for informational purposes'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I, Info`：它启用了信息目的的日志记录'
- en: '`W, Warn`: It enables logging for all warning information'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W, Warn`：它启用了所有警告信息的日志记录'
- en: '`E, Error`: It enables logging for errors'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E, Error`：它启用了错误日志记录'
- en: 'For instance, if you want to monitor the logs for `Error` level priority log
    components and higher, you would use the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想监控`Error`级别优先级日志组件及更高级别的日志，你会使用以下命令：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `*` indicates that we want the `Error` level priority for all log component
    tags.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`表示我们希望所有日志组件标签的`Error`级别优先级。'
- en: Another way you could filter through the log quite effectively is to dump the
    logcat output to a text file and search through it using either `grep`, which
    comes with most Linux/Unix distributions, or a text editor like Notepad++ for
    Windows users. A link to the download page of Notepad++ and `grep` are available
    in the *See also* section of this recipe. For Windows users, there's a Microsoft
    version of `grep` called WinGrep if you really want to do some powerful regular
    expression-based matching. A link to the WinGrep download page has also been made
    available in the *See also* section of this recipe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有效筛选日志的方法是将logcat输出转储到一个文本文件中，并使用`grep`（大多数Linux/Unix发行版随附）或Windows用户的文本编辑器如Notepad++进行搜索。Notepad++和`grep`的下载页面链接在本食谱的*另请参阅*部分提供。对于Windows用户，如果你真的想进行一些基于强大正则表达式的匹配，有一个名为WinGrep的Microsoft版本的`grep`。WinGrep下载页面的链接也已在食谱的*另请参阅*部分提供。
- en: 'Once you''ve decided how you want to search the text, it really doesn''t matter
    how you do this as long as you know how to find what you''re looking for in the
    logs. You can dump the output of the logfile by executing the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦决定了如何搜索文本，只要你知道如何在日志中找到你要找的内容，实际上怎么做并不重要。你可以通过执行以下命令转储日志文件的输出：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This works the same way via the Linux terminal or Windows command prompt. You
    can also "pipe"—which means feeding the output of one program into the input of
    another—this directly into another program like this. This works in either the
    Windows command prompt or the Linux terminal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于Linux终端或Windows命令提示符。你也可以将输出“管道化”——这意味着将一个程序的输出传递给另一个程序的输入——直接进入另一个程序，如下所示。这在Windows命令提示符或Linux终端中都可以工作。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If your using `grep`, you would do it by executing the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`grep`，你可以通过执行以下命令来完成：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Where `[pattern]` would be the text pattern you''re searching, for example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`[pattern]`是你搜索的文本模式，例如：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I really don't want to write a full tutorial on how to use `grep` here. If you
    want to make use of some of the more powerful features of either `grep` or WinGrep,
    please see the *See also* section of this recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的不想在这里写一个关于如何使用`grep`的完整教程。如果你想利用`grep`或WinGrep更强大的功能，请查看本食谱的*另请参阅*部分。
- en: 'Here are some examples you may find useful; monitor the logfile for web-related
    information:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能觉得有用的例子；监控与网页相关的信息的日志文件：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I know these are not very strict examples, but they are just strict enough to
    match web addresses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这些例子不是非常严格，但它们足以匹配网页地址。
- en: '![How to do it...](img/00083.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00083.jpeg)'
- en: The previous logs were generated by the Google Play Store app on a Samsung Galaxy
    S3 mobile phone.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的日志是由三星Galaxy S3手机上的Google Play商店应用生成的。
- en: 'You could also try to catch some sign-on or authentication-type token strings
    being leaked through the logfile:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试捕获通过日志文件泄露的一些登录或认证类型的令牌字符串：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When looking for valuable information in the logfile, it's generally a good
    idea to look for information that you would otherwise need permissions to get
    hold of or directly cause you to gain knowledge of information protected by other
    apps. For instance, if an app logs the cookie values returned after a user logs
    into his/her LinkedIn profile, would this be dangerous?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志文件中寻找有价值的信息时，通常一个好主意是寻找那些否则需要权限才能获取的信息，或者直接导致你获得其他应用程序保护的信息的知识。例如，如果应用程序记录了用户登录他/她的LinkedIn个人资料后返回的cookie值，这会危险吗？
- en: Yes! Effectively you have just bypassed the need to know his/her LinkedIn password,
    or the need to have your app be granted rights to some of the authentication functions
    in the LinkedIn application. During the hours you will probably spend reading
    the logfile, you should try to focus on finding this kind of information.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！实际上你刚刚绕过了需要知道他/她的LinkedIn密码的需求，或者你的应用程序需要被授予LinkedIn应用程序中某些身份验证功能的权限。在你阅读日志文件的时间里，你应该尽量关注查找这类信息。
- en: '![How to do it...](img/00084.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00084.jpeg)'
- en: Case and point! The cookies being logged here are being disclosed harmfully
    by the Android LinkedIn app on a Galaxy S3 mobile phone. Another real-world example
    of this vulnerability can be found at *Discovering a Major Security Hole in Facebook's
    Android SDK*. The link for the same is provided in the *See also* section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 案例证明！这里记录的cookie是由Android LinkedIn应用程序在Galaxy S3手机上有害地泄露的。在*发现Facebook Android
    SDK中的主要安全漏洞*中可以找到这种漏洞的另一个真实世界示例。相关链接在*参见以下内容*部分提供。
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of course applications are often developed to respond to hardware or software
    events, either via broadcast receivers or intents from other applications or system
    services. And naturally, you would like to know how applications respond to these
    events, or whether their behavior becomes potentially harmful in response to these
    kind of events. Then the question is, how do you create/send these events to the
    application you're testing without pressing your volume up button, locking and
    unlocking your screen, and pressing buttons yourself? The answer is the Android
    Monkey testing framework. It's designed to send system- and hardware-level events
    to an application, so that developers can gauge how well their application handles
    these events. It operates somewhat as a device event "fuzzing" framework for applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，应用程序通常是为了响应硬件或软件事件而开发的，可以通过广播接收器或其他应用程序或系统服务的意图来实现。自然而然地，你会想知道应用程序是如何响应这些事件的，或者它们在响应这类事件时的行为是否可能有害。那么问题来了，在不按下音量键、锁定和解锁屏幕、自己按键的情况下，你如何创建/发送这些事件给正在测试的应用程序呢？答案是Android
    Monkey测试框架。它旨在向应用程序发送系统和硬件级别的事件，以便开发者可以衡量应用程序处理这些事件的效率。它在某种程度上可以作为应用程序的设备事件“模糊测试”框架。
- en: Before explaining how to use it, it's important to mention that it's probably
    not a good idea to run the Monkey tester against applications installed on either
    your or someone else's personal Android device. This is because the way these
    applications respond to the Monkey tester may cause some damage to the applications
    being "monkey'd", cause loss of application data, or even crash your phone. Unless
    you have the proper permission or acceptance that you may lose or corrupt some
    data stored by the application(s) you are testing, you should only do this on
    an emulated or security testing-dedicated device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释如何使用它之前，重要的是要提到，对安装在个人Android设备上的应用程序运行Monkey测试可能不是一个好主意，无论是你的还是别人的。这是因为应用程序对Monkey测试的响应可能会导致被“猴子”的应用程序受损，导致应用程序数据丢失，甚至使手机崩溃。除非你有适当的权限或接受可能会丢失或损坏你正在测试的应用程序存储的数据，否则你只能在模拟器或专门用于安全测试的设备上进行此操作。
- en: 'One way to use this framework is to have a device connected via the ADB, and
    executing the following command via your command prompt or terminal:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个框架的一种方式是通过ADB连接一个设备，并通过命令提示符或终端执行以下命令：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Where `[package]` is the name of the package/application to which you want
    to send these events, and `[event count]` is the number of random events you want
    to send. Here''s an example of how to use it against the Flipboard app:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`[package]`是你想要发送这些事件的包/应用程序的名称，`[event count]`是你想要发送的随机事件的数量。以下是针对Flipboard应用程序使用它的一个例子：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will send 10 randomly-selected events to the Flipboard app, and report
    back on the application's behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向Flipboard应用程序发送10个随机选择的事件，并报告应用程序的行为。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见以下内容
- en: The *Android Debug Bridge – Enabling logcat logging* webpage at [https://developer.android.com/tools/help/adb.html#logcat](https://developer.android.com/tools/help/adb.html#logcat)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安卓调试桥 - 启用 logcat 日志*的网页，位于[https://developer.android.com/tools/help/adb.html#logcat](https://developer.android.com/tools/help/adb.html#logcat)'
- en: The *Vogella Tutorials – Monkey Testing* webpage at [http://www.vogella.com/articles/AndroidTesting/article.html](http://www.vogella.com/articles/AndroidTesting/article.html)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Vogella 教程 - 猴子测试*的网页，位于[http://www.vogella.com/articles/AndroidTesting/article.html](http://www.vogella.com/articles/AndroidTesting/article.html)'
- en: The *Notepad++* software at [http://notepad-plus-plus.org/download/v6.3.3.html](http://notepad-plus-plus.org/download/v6.3.3.html)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Notepad++*软件，位于[http://notepad-plus-plus.org/download/v6.3.3.html](http://notepad-plus-plus.org/download/v6.3.3.html)'
- en: The *Android Developer – logcat* webpage at [https://developer.android.com/tools/help/logcat.html](https://developer.android.com/tools/help/logcat.html)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安卓开发者 - logcat*的网页，位于[https://developer.android.com/tools/help/logcat.html](https://developer.android.com/tools/help/logcat.html)'
- en: The *WinGrep* software at [http://www.wingrep.com/download.htm](http://www.wingrep.com/download.htm)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WinGrep*软件，位于[http://www.wingrep.com/download.htm](http://www.wingrep.com/download.htm)'
- en: The *Discovering a Major Security Hole in Facebook's Android SDK* webpage at
    [http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/](http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发现 Facebook 安卓 SDK 重大安全漏洞*的网页，位于[http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/](http://blog.parse.com/2012/04/10/discovering-a-major-security-hole-in-facebooks-android-sdk/)'
- en: The *Android Developer – Reading and Writing Logs* webpage at [http://developer.android.com/tools/debugging/debugging-log.html](http://developer.android.com/tools/debugging/debugging-log.html)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安卓开发者 - 读写日志*的网页，位于[http://developer.android.com/tools/debugging/debugging-log.html](http://developer.android.com/tools/debugging/debugging-log.html)'
- en: Inspecting network traffic
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查网络流量
- en: As we know, applications can make use of the networking services available on
    an Android device, and many applications are developed as frontends to cloud-based
    services. What this means is that understanding how it communicates with the Internet
    services is a very important part of the security risk profile—the collection
    of risks an application exposes its users and its device to.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，应用程序可以利用安卓设备上可用的网络服务，许多应用程序被开发为基于云服务的界面。这意味着理解它如何与互联网服务通信是安全风险概况中非常重要的一部分——应用程序向其用户和设备暴露的风险集合。
- en: In this recipe, I'm going to show you some novel methods that you can use to
    monitor network traffic directly from an Android device using the ever popular
    **Wireshark**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个指南中，我将向你展示一些新颖的方法，你可以使用它们直接从安卓设备监控网络流量，使用的是一直很受欢迎的**Wireshark**。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we can get cracking, there are a couple of tools you will need to install
    both on your local machine and the Android device. Here are the tools you''ll
    need to get:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要在本地机器和安卓设备上安装一些工具。以下是你会需要获取的工具：
- en: '**Wireshark**: It is available for download at the Wireshark site [http://www.wireshark.org](http://www.wireshark.org),
    Wireshark supports both Linux/Unix and Windows machines. You should make sure
    this is installed on your host machine before starting. Installing Wireshark is
    pretty straightforward; the Wireshark folks have even provided some very useful
    documentation for both Windows and Unix/Linux distributions, which is available
    at [http://www.wireshark.org/docs/wsug_html_chunked/ChapterBuildInstall.html](http://www.wireshark.org/docs/wsug_html_chunked/ChapterBuildInstall.html).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wireshark**：你可以在 Wireshark 网站下载它[http://www.wireshark.org](http://www.wireshark.org)，Wireshark
    支持Linux/Unix 和 Windows 机器。在开始之前，你应该确保你的主机上已安装它。安装 Wireshark 非常简单；Wireshark 开发团队甚至为
    Windows 和 Unix/Linux 发行版提供了一些非常有用的文档，可在[http://www.wireshark.org/docs/wsug_html_chunked/ChapterBuildInstall.html](http://www.wireshark.org/docs/wsug_html_chunked/ChapterBuildInstall.html)找到。'
- en: '**Netcat**: It is available for download for Linux/Unix users at [http://netcat.sourceforge.net/download.php](http://netcat.sourceforge.net/download.php),
    and for Windows users at [http://joncraton.org/blog/46/netcat-for-windows/](http://joncraton.org/blog/46/netcat-for-windows/).
    Linux/Unix users may not need to explicitly download Netcat as it comes packaged
    with many Linux/Unix distributions.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netcat**：Linux/Unix 用户可以在[http://netcat.sourceforge.net/download.php](http://netcat.sourceforge.net/download.php)下载它，Windows
    用户可以在[http://joncraton.org/blog/46/netcat-for-windows/](http://joncraton.org/blog/46/netcat-for-windows/)下载。Linux/Unix
    用户可能不需要明确下载 Netcat，因为它已经包含在许多 Linux/Unix 发行版中。'
- en: '**TCPdump for Android**: It is available for download at [http://www.strazzere.com/android/tcpdump](http://www.strazzere.com/android/tcpdump).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用于 Android 的 TCPdump**：可以在[http://www.strazzere.com/android/tcpdump](http://www.strazzere.com/android/tcpdump)下载。'
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Once you''ve got all the tools set up and ready to go, you can monitor the
    traffic of your Android device by performing the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置好所有工具并准备就绪，你可以通过执行以下步骤来监控你的 Android 设备的流量：
- en: 'Assuming your Android device is rooted, you should create a directory to host
    your TCPdump binary as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你的 Android 设备已经获得 root 权限，你应该创建一个目录来存放你的 TCPdump 二进制文件，如下所示：
- en: 'On the Android device, execute the following commands via ADB in the order
    they appear:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Android 设备上，通过 ADB 按照出现的顺序执行以下命令：
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then on the local machine, in the folder where you''ve downloaded the TCPdump
    version for Android, execute the following commands:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在本地机器上，在你下载了适用于 Android 的 TCPdump 版本的文件夹中，执行以下命令：
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the TCPdump Android version is uploaded to the device and marked as executable.
    You should make sure Netcat is available on the Android device by trying to run
    the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将 TCPdump 的 Android 版本上传到设备并标记为可执行。你应该确保 Android 设备上可用 Netcat，尝试运行以下命令：
- en: '[PRE14]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![How to do it…](img/00085.jpeg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00085.jpeg)'
- en: This is merely a sanity check, most Android versions come shipped with Netcat
    by default. If not, there is an Android version available from the Google Source
    Android GitHub repository with an NDK Makefile at [https://android.googlesource.com/platform/external/netcat/+/master](https://android.googlesource.com/platform/external/netcat/+/master).
    To find out how to use this Makefile, refer the *Cross-compiling native executables*
    recipe in [Chapter 8](part0077_split_000.html#page "Chapter 8. Native Exploitation
    and Analysis"), *Native Exploitation and Analysis*.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是一个健全性检查，大多数 Android 版本默认都会安装 Netcat。如果没有，可以在 Google Source Android GitHub
    仓库中找到带有 NDK Makefile 的适用于 Android 的版本，地址是[https://android.googlesource.com/platform/external/netcat/+/master](https://android.googlesource.com/platform/external/netcat/+/master)。要了解如何使用此
    Makefile，请参考[第8章](part0077_split_000.html#page "Chapter 8. Native Exploitation
    and Analysis")中的*跨编译本地可执行文件*菜谱，*本地利用与分析*。
- en: 'To make sure that everything works, after you''ve managed to confirm that both
    TCPdump and Netcat are installed on your Android device, you can actually dump
    some network traffic and try executing the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保一切正常工作，在确认你的 Android 设备上已经安装了 TCPdump 和 Netcat 之后，你可以实际捕获一些网络流量并尝试执行以下命令：
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following appear on your screen if everything is working
    well:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会在屏幕上看到以下内容：
- en: '![How to do it…](img/00086.jpeg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00086.jpeg)'
- en: To see some actual output you might try opening an app that makes requests to
    the Web or using some networking APIs.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看一些实际输出，你可以尝试打开一个会向 Web 发送请求的应用程序或使用一些网络 API。
- en: 'If everything works fine, you should be able to start feeding the TCPdump output
    to the Wireshark installed on your local device. To do this, you first need to
    set up some port forwarding via ADB, which is done by executing the following
    command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能够将 TCPdump 的输出传递给本地设备上安装的 Wireshark。为此，你首先需要通过 ADB 设置一些端口转发，这是通过执行以下命令完成的：
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the port forwarding is set up, you should be able to use Netcat on your
    local machine by executing the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置好端口转发，你就可以在本地机器上通过执行以下命令来使用 Netcat：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This means all the traffic is being forwarded correctly. You should be able
    to pipe the output into Wireshark, which will interpret it and facilitate deep
    packet inspection and other useful things. To pipe the output into Wireshark,
    execute the following command on your local machine:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着所有流量都被正确转发。你应该能够将输出传递给 Wireshark，Wireshark 将对其进行解释，并便于进行深度数据包检查和其他有用的事情。要在本地机器上执行输出传递给
    Wireshark 的命令，请执行以下操作：
- en: '[PRE18]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After a few seconds, if everything works properly, you should see Wireshark
    launch. The following shows up on your screen:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几秒钟后，如果一切正常，你应该会看到 Wireshark 启动。以下内容将显示在你的屏幕上：
- en: '![How to do it…](img/00087.jpeg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00087.jpeg)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe we used Netcat, Wireshark, and TCPdump to extract network traffic
    directly from an Android device for analysis and deep-packet inspection. Given
    that very little explanation was given for the command-line arguments and combinations
    of tools in the walkthrough, this recipe details how and why each one of the actions
    were performed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们使用了Netcat、Wireshark和TCPdump直接从Android设备提取网络流量进行分析和深度包检查。鉴于在演练中对命令行参数和工具组合的解释非常少，这个教程详细说明了每个操作是如何执行以及为什么这样执行。
- en: 'In Step 1, the following commands where executed in order to create a directory
    to host the TCPdump installation on the Android device:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，执行了以下命令以在Android设备上创建一个目录，用于承载TCPdump的安装：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `su` command which stands for **Substitute User** (**SU**) allows us to
    assume root privileges—this is the behavior of `su` when no arguments are supplied.
    The root privileges we assume using `su` include being able to modify and view
    any directory or file on the Android file system. This was needed since we created
    the `tcpdump` directory inside the `/data/ folder`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`su`命令代表**Substitute User**（**SU**），它允许我们获取root权限——这是在没有提供参数时`su`的行为。我们使用`su`假设的root权限包括能够修改和查看Android文件系统上的任何目录或文件。这是必需的，因为我们是在`/data/`文件夹内创建`tcpdump`目录。'
- en: After executing `su`, we executed the `mkdir` command with an argument of `/data/tcpdump/`,
    which created the `tcpdump/` directory under the `/data/ folder`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`su`之后，我们执行了带有参数`/data/tcpdump/`的`mkdir`命令，在`/data/`文件夹下创建了`tcpdump/`目录。
- en: Following this is the `chmod` command—which is an abbreviation of change mode—with
    an argument of `755`. It modifies the access mode for the `/data/tcpdump` folder
    and allows users with lower privileges to access the `tcpdump` path. This is needed
    because we will be using the `adb push` command to store the `tcpdump` binary
    under this path.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是`chmod`命令——它是改变模式的缩写，参数为`755`。它修改了`/data/tcpdump`文件夹的访问模式，允许低权限用户访问`tcpdump`路径。这是必需的，因为我们将会使用`adb
    push`命令将`tcpdump`二进制文件存储在此路径下。
- en: 'After creating the `tcpdump` folder, we execute the following commands:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`tcpdump`文件夹后，我们执行了以下命令：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These ensure that the `tcpdump` binary is stored under the `tcpdump` path. The
    first command passes the `push` command to `adb` with an argument of `tcpdump`,
    which is the TCPdump version for Android. You will notice that a dot is supplied
    as the name for the `tcpdump` binary under the `/data/tcpdump` folder; this is
    a shorthand that ensures whichever file is being copied keeps its filename after
    being copied. This is evident since we copied a file called `tcpdump` from the
    local machine, which also ended up being called `tcpdump` on the Android device.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令确保了`tcpdump`二进制文件存储在`tcpdump`路径下。第一个命令将`push`命令传递给`adb`，参数为`tcpdump`，这是适用于Android的TCPdump版本。您会注意到，在`/data/tcpdump`文件夹下为`tcpdump`二进制文件提供了一个点作为名称；这是确保被复制的文件在复制后保持其文件名的简写方式。这是显而易见的，因为我们从本地机器复制了一个名为`tcpdump`的文件，在Android设备上也同样被命名为`tcpdump`。
- en: Following the `push` command is the `adb shell` command with an argument of
    `chmod 755 /data/tcpdump/tcpdump`, which changes the access mode for the `tcpdump`
    binary, allowing users with lower privileges to execute it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`push`命令之后是带有参数`chmod 755 /data/tcpdump/tcpdump`的`adb shell`命令，它改变了`tcpdump`二进制文件的访问模式，允许低权限用户执行它。
- en: In step 2, we used the `nc` command—which is an abbreviation of Netcat. This
    tool serves as a Swiss army knife for interacting with networking services. In
    this recipe, we will use it to read data from and into a network connection. Running
    `nc` without any arguments prints the usage specification. This allowed us to
    make sure `nc` was running properly and is actually installed on our Android device.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用了`nc`命令——这是Netcat的缩写。这个工具作为与网络服务交互的多功能工具。在这个教程中，我们将使用它来读写网络连接中的数据。不带任何参数运行`nc`会打印使用说明。这让我们可以确认`nc`是否正常运行，并确认它实际上已经安装在Android设备上。
- en: 'In step 3, we used `tcpdump` with the argument of `–w`, which allows us to
    specify a file to write out to, and the second argument ensures that the output
    is written to the terminal screen. As part of the command we executed, we also
    specified the following: `| nc –l –p 31337`. The `|` character, which is called
    a pipe in operating system terminology, feeds the output of the preceding program
    to the program after the pipe as input. Netcat is invoked using the `–l` argument
    which causes Netcat to listen for connections on the port supplied as an argument
    to the `–p` command-line switch. In this context, all this means that the raw
    binary network traffic from `tcpdump` is fed to Netcat as input; which means it
    will output this raw traffic from port number `31337`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们使用了带有`–w`参数的`tcpdump`，这允许我们指定一个文件进行写入，第二个参数确保输出会同时写入到终端屏幕。作为我们执行的命令的一部分，我们还指定了如下内容：`|
    nc –l –p 31337`。在操作系统术语中，`|`字符被称为管道，它将前一个程序的输出作为输入传递给管道后面的程序。Netcat 使用`–l`参数被调用，这导致
    Netcat 监听作为`–p`命令行开关参数提供的端口上的连接。在这个上下文中，这意味着`tcpdump`的原始二进制网络流量作为输入传递给 Netcat；这意味着它将从端口号码`31337`输出这些原始流量。
- en: In step 4, we use ADB's port forwarding feature. It allows us to couple a port
    on the Android device (supplied as the second argument `tcp:12345`) with a port
    on the local machine (supplied as the first argument `tcp:31337`). You will notice
    that we couple port `12345` to port `31337` and tell Netcat in the previous step
    to listen for connection on port `31337`. This is so that we can interact with
    the Netcat instance via port `31337` on our local machines. To summarize in simpler
    terms, port `31337` on the Android device becomes port `12345` on our local machines.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们使用了 ADB 的端口转发功能。它允许我们将 Android 设备上的一个端口（作为第二个参数`tcp:12345`）与本地机器上的一个端口（作为第一个参数`tcp:31337`）连接起来。你会注意到我们将端口`12345`与端口`31337`耦合，并告诉前一步的
    Netcat 在端口`31337`上监听连接。这样我们就可以通过本地机器上的端口`31337`与 Netcat 实例进行交互。简单来说，Android 设备上的端口`31337`变成了我们本地机器上的端口`12345`。
- en: In step 5, we launched Netcat with the arguments `127.0.0.1`, which is the address
    of our local machine (termed the loopback address), and `12345`, which is a port
    that we forwarded in the previous step. This tells Netcat to connect to port `12345`
    on our local machine; and since port `12345` is coupled to port `31337` on the
    Android device, it actually means we are interacting with port `31337` by proxy
    of port `12345` locally. The result of this is that we can grab the network traffic
    piped into Netcat on the Android device from our local machines.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们使用参数`127.0.0.1`启动了 Netcat，这是我们的本地机器的地址（称为环回地址），以及`12345`，这是我们上一步转发的端口。这告诉
    Netcat 连接到本地机器的端口`12345`；由于端口`12345`与 Android 设备上的端口`31337`耦合，这意味着我们通过本地端口`12345`的代理与端口`31337`进行交互。这样做的结果是，我们可以从本地机器捕获传递到
    Android 设备上 Netcat 的网络流量。
- en: 'In Step 6, we combined all the commands relevant to our local machines in order
    to ensure that Wireshark gets the raw binary network traffic and interprets it
    for us. We launched Wireshark with the following arguments:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们将所有与本地机器相关的命令组合在一起，以确保 Wireshark 获取原始二进制网络流量并为我们的解释。我们使用以下参数启动了 Wireshark：
- en: '`–k`: This argument, according to the Wireshark manual, does the following:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–k`：根据 Wireshark 手册，此参数执行以下操作：'
- en: Starts the capture session immediately. If the `-i` flag was specified, the
    capture uses the specified interface.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即开始捕获会话。如果指定了`-i`标志，捕获将使用指定的接口。
- en: Otherwise, Wireshark searches the list of interfaces, choosing the first non-loopback
    interface if there are any non-loopback interfaces and choosing the first loopback
    interface if there are no non-loopback interfaces.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，Wireshark 会搜索接口列表，如果有非环回接口，则选择第一个非环回接口；如果没有非环回接口，则选择第一个环回接口。
- en: If there are no interfaces, Wireshark reports an error and doesn't start the
    capture.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有接口，Wireshark 会报告错误并且不会开始捕获。
- en: '`–S`: This argument specifies the snapshot length, which is the number of bytes
    to capture per packet. If no argument is given as length, the full packet is captured.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–S`：此参数指定快照长度，即每个数据包捕获的字节数。如果没有给出长度参数，则捕获整个数据包。'
- en: '`–i`: This argument specifies the input from which to capture packets. Here
    we supplied the – symbol again, which tells Wireshark to read the input from standard
    input. We do this because the input for Wireshark is funneled to it via the pipe
    from Netcat.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–i`：此参数指定了捕获数据包的输入来源。这里我们再次提供了 – 符号，告诉 Wireshark 从标准输入读取数据。这样做是因为 Wireshark
    的输入是通过 Netcat 的管道传输给它的。'
- en: For a more interesting use of this idea, you could try building tools that analyze
    Android traffic for active threats by running an **Intrusion Detection System**
    (**IDS**) or other security-focused network monitoring tools like Snort on some
    network traffic generated by an Android device. This idea would make for a very
    interesting malware and vulnerability analysis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想要更有趣地使用这个想法，你可以尝试构建工具，通过在由 Android 设备产生的网络流量上运行**入侵检测系统**（**IDS**）或其他以安全为重点的网络监控工具（如
    Snort），来分析 Android 流量中的活跃威胁。这个想法将非常适合进行恶意软件和漏洞分析。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Analyzing Android Network Traffic* webpage at [http://mobile.tutsplus.com/tutorials/android/analyzing-android-network-traffic/](http://mobile.tutsplus.com/tutorials/android/analyzing-android-network-traffic/)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分析 Android 网络流量](http://mobile.tutsplus.com/tutorials/android/analyzing-android-network-traffic/)网页'
- en: The *Wireshark User's Guide* at [http://www.wireshark.org/docs/wsug_html_chunked/](http://www.wireshark.org/docs/wsug_html_chunked/)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Wireshark 用户指南](http://www.wireshark.org/docs/wsug_html_chunked/)'
- en: The *Wireshark DisplayFilters* webpage at [http://wiki.wireshark.org/DisplayFilters](http://wiki.wireshark.org/DisplayFilters)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Wireshark 显示过滤器](http://wiki.wireshark.org/DisplayFilters)网页'
- en: The *Wireshark CaptureFilters* webpage at [http://wiki.wireshark.org/CaptureFilters](http://wiki.wireshark.org/CaptureFilters)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Wireshark 捕获过滤器](http://wiki.wireshark.org/CaptureFilters)网页'
- en: The *TCPdump* man page at [http://www.tcpdump.org/tcpdump_man.html](http://www.tcpdump.org/tcpdump_man.html)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TCPdump 手册页](http://www.tcpdump.org/tcpdump_man.html)'
- en: Passive intent sniffing via the activity manager
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过活动管理器进行被动意图嗅探
- en: A good way to proliferate information about application and their components
    is to eavesdrop on inter-application communication. One way you could do this
    is by requesting information about the most recent intents from the activity manager.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 想要广泛传播关于应用程序及其组件的信息，一个有效的方法是窃听应用程序间的通信。你可以通过请求活动管理器中最近意图的信息来实现这一点。
- en: This is pretty straightforward and, as it turns out, can be done via drozer
    (which was introduced in [Chapter 3](part0032_split_000.html#page "Chapter 3. Android
    Security Assessment Tools"), *Android Security Assessment Tools*) if you're willing
    to do some Python scripting. The folks at iSec Partners have developed an Android
    application that is capable of doing this, and most of the inspiration for the
    drozer module discussed in the following recipe comes from their app. To find
    out how to get your hands on this app see the *See also* section of this recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常直接，正如你所发现的，如果你愿意编写一些 Python 脚本，可以通过 drozer（在[第3章](part0032_split_000.html#page
    "Chapter 3. Android Security Assessment Tools")，*Android 安全评估工具*中介绍）来完成。iSec Partners
    的团队开发了一个能够执行此操作的应用程序，以下食谱中讨论的 drozer 模块的大部分灵感都来自他们的应用。想要了解如何获取这个应用，请查看本食谱的*另请参阅*部分。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we actually write this module, we need to modify the drozer Agent a little
    so it has the required permissions to actually request information about intents
    from the activity manager. The simplest way to do this is to augment the permissions
    requested by drozer via its `AndroidManifest.xml` file. Here, I'll show you how
    to do this using Eclipse.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际编写这个模块之前，我们需要对 drozer 代理进行一些修改，使其具有从活动管理器请求意图信息的必要权限。最简单的方法是通过其 `AndroidManifest.xml`
    文件增加 drozer 请求的权限。这里，我将向你展示如何使用 Eclipse 来完成这个操作。
- en: 'First you need to grab a copy of the drozer Agent and its dependencies from
    the following sites:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要从以下网站获取 drozer 代理及其依赖项的副本：
- en: The *drozer Agent* webpage at [https://github.com/mwrlabs/drozer-agent](https://github.com/mwrlabs/drozer-agent)
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[drozer 代理](https://github.com/mwrlabs/drozer-agent)网页'
- en: The *jdiesel (fuels the drozer)* webpage at [https://github.com/mwrlabs/jdiesel](https://github.com/mwrlabs/jdiesel)
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[jdiesel (为 drozer 提供动力)](https://github.com/mwrlabs/jdiesel)网页'
- en: The *TLS Support* webpage at [https://github.com/mwrlabs/mwr-tls](https://github.com/mwrlabs/mwr-tls)
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TLS 支持](https://github.com/mwrlabs/mwr-tls)网页'
- en: The *Android utilities for drozer* webpage at [https://github.com/mwrlabs/mwr-android](https://github.com/mwrlabs/mwr-android)
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问[https://github.com/mwrlabs/mwr-android](https://github.com/mwrlabs/mwr-android)的*Android
    utilities for drozer*网页。
- en: Once you have these downloaded and saved them in the same folder, you can open
    Eclipse and import each of them as Android projects. For each of them, once Eclipse
    is opened, navigate to **File** | **Import**.![Getting ready](img/00088.jpeg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并保存到同一文件夹后，你可以打开Eclipse并将它们作为Android项目导入。对于每一个项目，在Eclipse打开后，导航到**文件** | **导入**。[![准备就绪](img/00088.jpeg)]
- en: Click on the **Android** folder, then go to **Existing Android Code into Workspace**
    and click on **Next**.![Getting ready](img/00089.jpeg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Android**文件夹，然后选择**Existing Android Code into Workspace**，并点击**Next**。[![准备就绪](img/00089.jpeg)]
- en: At this point, Eclipse will ask you to specify a folder to import from. You'll
    need to add one of the folders you downloaded in step 1\. To select a folder,
    click on **Browse...** and a file selection dialog will pop up.![Getting ready](img/00090.jpeg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，Eclipse会要求你指定一个要导入的文件夹。你需要添加在第1步下载的文件夹之一。要选择文件夹，点击**浏览...**，文件选择对话框将会弹出。[![准备就绪](img/00090.jpeg)]
- en: Using the **File** dialog, navigate to the file path where you've downloaded
    the drozer Agent and dependencies. You'll need to add each one of them this way.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件**对话框，导航到下载drozer代理和依赖项的文件路径。你需要以这种方式添加它们。
- en: Make sure you import each of the folders this way. Until you do so, Eclipse
    will not be able to build the drozer Agent successfully.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保以这种方式导入每个文件夹。否则，Eclipse将无法成功构建drozer代理。
- en: 'Once you''ve imported all the projects, you''ll need to edit the drozer Agent''s
    `AndroidManifest.xml`. You do this by double-clicking on the `AndroidManifest.xml`
    file in the `drozer-agent project` folder in Eclipse (make sure that you select
    the `AndroidManifest.xml` tab before editing so you can edit the XML directly).
    Then, enter the following line:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有项目后，你需要编辑drozer代理的`AndroidManifest.xml`。你通过在Eclipse中双击`drozer-agent project`文件夹中的`AndroidManifest.xml`文件来进行编辑（确保在编辑前选择`AndroidManifest.xml`标签，以便直接编辑XML）。然后，输入以下行：
- en: '[PRE21]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `AndroidManifest.xml` file should look like the following screenshot if
    you''ve performed the step correctly:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果步骤正确，`AndroidManifest.xml`文件应该看起来像以下截图：
- en: '![Getting ready](img/00091.jpeg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备就绪](img/00091.jpeg)'
- en: And that's it! You've just added an extra permission to the drozer Agent. Now
    you can export the drozer Agent as an APK file, upload it to your device, and
    get cracking.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！你刚刚为drozer代理添加了一个额外的权限。现在你可以将drozer代理导出为APK文件，上传到你的设备上，开始工作了。
- en: Please note you may need to uninstall the drozer Agent currently installed on
    your device before installing the modified one.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在安装修改后的代理之前，你可能需要卸载设备上当前安装的drozer代理。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: So that's the drozer Agent done and dusted. We can now move onto developing
    the intent sniffer module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，drozer代理的安装就完成了。现在我们可以开始开发意图嗅探模块了。
- en: 'Navigate to your drozer module repository; if you haven''t set one up please
    refer to the *Writing a drozer module – a device enumeration module* recipe in
    [Chapter 3](part0032_split_000.html#page "Chapter 3. Android Security Assessment
    Tools"), *Android Security Assessment Tools*, to see how this is done. Once you
    are in your module repository, create a file called `ex.sniffer.intents` and type
    the following into it (the following code will be available in this book''s code
    repository):'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的drozer模块仓库；如果你还没有设置，请参考[第3章](part0032_split_000.html#page "第3章 安卓安全评估工具")中的*编写一个drozer模块——一个设备枚举模块*食谱，了解如何操作。进入模块仓库后，创建一个名为`ex.sniffer.intents`的文件，并输入以下内容（以下代码将包含在本书的代码仓库中）：
- en: '[PRE22]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once that''s done, install the module into drozer by executing the following
    command:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，通过执行以下命令将模块安装到drozer中：
- en: '[PRE23]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then run it by executing the following command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过执行以下命令运行它：
- en: '[PRE24]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see something similar to the following screenshot:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到类似于以下截图的内容：
- en: '![How to do it...](img/00092.jpeg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00092.jpeg)'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The intent sniffer script is actually quite simple. Here I'll break down what
    it's doing and how it manages to actually sniff some intents.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 意图嗅探脚本实际上非常简单。下面我会分解它的操作原理以及它是如何实际嗅探到意图的。
- en: The intent sniffer makes a call to `Context.getSystemService()` and passes it
    the identifier for the `ACTIVITY_SERVICE` flag, which is simply a string with
    the value of "activity". This returns an instance of the `ActivityManager` class,
    which allows the script to interact with the activity manager and make calls like
    `ActivityManager.getRecentTasks()`. This method takes in two arguments, the first
    is an integer which is the maximum number of the `RecentTaskInfo` objects the
    script wants to receive from the activity manager, and the second is a flag specifying
    the kind of recent activities. In this example, the script is written to request
    the full list without omitting any of the tasks. The reason I've written the script
    this way is because the intent that was sent to start each recent task comes bundled
    with the `RecentTaskInfo` object as a field called `RecentTaskInfo.baseIntent`.
    The script can then use it to extract some useful information about the intent,
    such as the component name, flags, actions, and categories. To keep things quick
    and easy here, the script then logs a call to the `Intent.toString()` method,
    which simply formats the information about the intent as string and returns it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 意图嗅探器调用了`Context.getSystemService()`方法，并传递了`ACTIVITY_SERVICE`标志的标识符，它只是一个值为"activity"的字符串。这返回了`ActivityManager`类的一个实例，使脚本能够与活动管理器交互，并调用如`ActivityManager.getRecentTasks()`等方法。这个方法接收两个参数，第一个是一个整数，表示脚本希望从活动管理器接收的`RecentTaskInfo`对象的最大数量；第二个是一个指定最近活动类型的标志。在这个例子中，脚本被编写为请求完整列表，不省略任何任务。我之所以这样编写脚本，是因为发送到启动每个最近任务的意图与`RecentTaskInfo`对象捆绑在一起，作为一个名为`RecentTaskInfo.baseIntent`的字段。然后脚本可以使用它来提取有关意图的一些有用信息，例如组件名称、标志、动作和类别。为了快速简便，脚本随后记录了对`Intent.toString()`方法的调用，该方法仅将意图信息格式化为字符串并返回。
- en: Of course, you are welcome to do more intelligent parsing of the intent information.
    You could even try working out a way to determine which package made the original
    call. Though this is very difficult, it would be quite a rewarding drozer module
    to pull off.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以对意图信息进行更智能的解析。你甚至可以尝试找出是哪个包发出了原始调用。尽管这非常困难，但如果能完成，这将是一个非常有价值的drozer模块。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Intent Sniffer* Android application at [https://www.isecpartners.com/tools/mobile-security/intent-sniffer.aspx](https://www.isecpartners.com/tools/mobile-security/intent-sniffer.aspx)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intent Sniffer* 安卓应用程序在[https://www.isecpartners.com/tools/mobile-security/intent-sniffer.aspx](https://www.isecpartners.com/tools/mobile-security/intent-sniffer.aspx)'
- en: The `Context.getSystemService(String name)` command at [http://developer.android.com/reference/android/content/Context.html#getSystemService%28java.lang.String%29](http://developer.android.com/reference/android/content/Context.html#getSystemService%28java.lang.String%29)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getSystemService(String name)`命令在[http://developer.android.com/reference/android/content/Context.html#getSystemService%28java.lang.String%29](http://developer.android.com/reference/android/content/Context.html#getSystemService%28java.lang.String%29)'
- en: The *ActivityManager.RecentTaskInfo* reference at [http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html](http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关*ActivityManager.RecentTaskInfo*的参考资料在[http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html](http://developer.android.com/reference/android/app/ActivityManager.RecentTaskInfo.html)
- en: the *Intent* reference at [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intent*参考资料在[http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html)'
- en: Attacking services
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击服务
- en: Services may not seem very dangerous, and they stick to working in the background.
    But they are developed to support the other application components, and could
    potentially perform very sensitive operations such as logging into an online profile,
    resetting a password, or even facilitating some potentially dangerous processes
    by serving as a proxy to the system services of the host device. Either way, they
    must not be overlooked during an application assessment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可能看起来并不危险，并且它们坚持在后台工作。但它们是为了支持其他应用程序组件而开发的，并且可能执行非常敏感的操作，如登录在线个人资料、重置密码，甚至通过作为主机系统服务的代理来促进一些潜在危险的过程。无论如何，在应用程序评估期间，它们绝不能被忽视。
- en: When is a service vulnerable? Well, a service is exploitable when you can use
    its functionality to abuse the user, escalate the privileges of another application/user,
    or use it to extract sensitive information. This means that you need to be able
    to interact with the service, which means it must be exported, or respond/accept
    input from message formats like intents, files, or the network stack. Another
    thing to consider is what kind of permission is required to interact with the
    service—whether it's a potentially dangerous service, performs very sensitive
    operations, or could be abused to cause a **Denial of Service** (**DoS** ) condition
    (that is, when an attacker bars access to a service by forcing it to stop working
    or denying users its service) in the application or even the device! Not to mention
    what a bad situation the application and its user will be in should the potentially
    dangerous service not require any permissions at all!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候服务是脆弱的？当一个服务能被用来对用户进行滥用、提升另一个应用程序/用户的权限，或者用来提取敏感信息时，这个服务就是可被利用的。这意味着你需要能够与服务进行交互，这意味着它必须是可导出的，或者能从意图、文件或网络堆栈等消息格式中响应/接受输入。另一个需要考虑的是与服务交互需要什么类型的权限——它是否是一个潜在危险的服务，执行非常敏感的操作，或者可能被滥用导致应用程序甚至设备出现**拒绝服务**（**DoS**）状况（即攻击者通过强制服务停止工作或拒绝提供服务来阻止访问服务）！更不用说如果这个潜在危险的服务根本不需要任何权限，应用程序及其用户将会陷入多么糟糕的境地！
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I've highlighted some of the important areas here. You should notice that the
    service called `.services.LocationService`, which probably facilitates determining
    the user's location via the GPS services or Geolocation API, doesn't require any
    permissions to start! Given that the application itself would be granted both
    `android.permission.ACCESS_COARSE_LOCATION` and `android.permission.ACCESS_FINE_LOCATION`
    this means that there's a great chance that attackers may be able to make unauthorized
    use of this service should they be close enough to this service (which could be
    physical access to the device, or via a malicious application installed on the
    user's device).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里突出了一些重要的区域。你应该注意到，名为`.services.LocationService`的服务可能通过 GPS 服务或地理定位 API 确定用户的位置，而且启动时不需要任何权限！考虑到应用程序本身会被授予`android.permission.ACCESS_COARSE_LOCATION`和`android.permission.ACCESS_FINE_LOCATION`这两个权限，这意味着攻击者如果足够接近这个服务（可能是物理访问设备，或者在用户设备上安装了恶意应用程序），很有可能会未经授权使用这项服务。
- en: The previous sample was taken from the *OWASPS GoatDroid* project, see the *See
    also* section for a link to the GitHub repository.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例来自*OWASPS GoatDroid*项目，有关 GitHub 仓库的链接请参见*另请参阅*部分。
- en: So that's what the vulnerability looks like from the code source, or rather
    the developer/reverse engineer's perspective. Let's get down to actually using
    drozer to attack some vulnerable services and give you the attacker's perspective
    of this vulnerability.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是从代码源头上看这个漏洞的样子，或者说从开发者/逆向工程师的角度来看。现在让我们实际使用 drozer 来攻击一些易受攻击的服务，并给你这个漏洞攻击者的视角。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here''s how you go about finding some vulnerable services:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何寻找一些易受攻击的服务的方法：
- en: 'Given a sample application, find out which services are exported. You can do
    this via drozer by executing the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个示例应用程序，找出哪些服务是可导出的。你可以通过 drozer 执行以下命令来实现：
- en: '[PRE27]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As I've explained in the previous chapter, this command finds services that
    don't require any permissions.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如在上一章中我解释的，这个命令可以找到那些不需要任何权限的服务。
- en: 'Once you''ve found a bunch of services, you can launch them using the following
    command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一批服务后，你可以使用以下命令来启动它们：
- en: '[PRE28]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As a simple example, this is how you would launch one of the services in the
    `com.linkedin.android` application:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，以下是启动`com.linkedin.android`应用程序中一个服务的方法：
- en: '[PRE29]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It's always a good idea to have logcat running while you're stopping and starting
    these services, in case they might divulge some sensitive information about the
    way they operate and leak some authentication credentials or other useful data.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在启动和停止这些服务时运行 logcat 总是一个好主意，以防它们可能会泄露一些关于它们操作方式的敏感信息，以及泄露一些认证凭据或其他有用的数据。
- en: Of course, if you want to send the service some data via an intent, you would
    need to know what the intent filters look like for the service you are targeting.
    And, if you haven't already guessed, the easiest way to know this is by inspecting
    the application manifest. If you need a recap on how to do this, refer to the
    *Inspecting the AndroidManifest.xml file* recipe in [Chapter 2](part0025_split_000.html#page
    "Chapter 2. Engaging with Application Security"), *Engaging with Application Security*.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，如果你想通过意图向服务发送一些数据，你需要知道你针对的服务意图过滤器看起来是什么样子。而且，如果你还没有猜到，了解这些的最简单方式就是检查应用程序清单。如果你需要回顾如何做到这一点，请参考[第2章](part0025_split_000.html#page
    "第2章. 应用程序安全参与")《*参与应用程序安全*》中的*检查AndroidManifest.xml文件*部分。
- en: 'Essentially, the piece of XML you''re looking for would look something like
    the following code snippet:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你要寻找的XML代码大致如下所示：
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To fire off intents to this service, you can execute the following command
    via the drozer console:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向此服务发送意图，你可以在drozer控制台执行以下命令：
- en: '[PRE32]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As a side note, some services may interface native libraries and actually pass
    data accepted from intents to C/C++ data structures like the stack or heap-based
    variables. When auditing the security of a service that requires data to be passed
    via an intent, you should always try to identify any potential memory corruption
    vulnerabilities caused by the intent data. Keep this in mind when inspecting other
    application component types for vulnerabilities, since any application component
    may facilitate these kinds of vulnerabilities.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便一提，一些服务可能会与本地库交互，并将意图接收的数据传递给C/C++数据结构，如栈或基于堆的变量。在审计需要通过意图传递数据的服务安全性时，你应该始终尝试识别意图数据可能导致的任何潜在内存破坏漏洞。在检查其他应用程序组件类型是否存在漏洞时，请记住这一点，因为任何应用程序组件都可能引发这类漏洞。
- en: 'There are some default system services that behave quite strangely when handcrafted
    intents are sent to them. Consider the following example of an intent send to
    `com.android.systemui`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送手工制作的意图时，一些默认的系统服务的行为会相当奇怪。考虑以下发送到`com.android.systemui`的意图示例：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the result on the Samsung Galaxy S3:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在三星Galaxy S3上的结果如下：
- en: '![How to do it...](img/00093.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00093.jpeg)'
- en: This is a classic example of a DoS vulnerability. The System UI service does
    not anticipate intents with empty metadata or extra data fields. As a result,
    when an intent with no extra data is sent, it causes a null pointer exception
    and the entire service comes tumbling down. This vulnerability may not seem too
    harsh seeing that it's just a UI service. But if a key security mechanism or the
    UI component of a security-relevant service relies on the system UI service to
    be running in order for it to operate (for example, maybe the lock screen or the
    settings application), this simple dataless intent can cascade into a very complex,
    quite high-risk vulnerability.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的拒绝服务（DoS）漏洞示例。系统UI服务没有预想到包含空元数据或额外数据字段的意图。因此，当发送不带额外数据的意图时，会导致空指针异常，整个服务随之崩溃。这个漏洞看起来可能不算严重，因为它只是一个UI服务。但如果关键的安全机制或与安全相关的服务的UI组件依赖于系统UI服务运行才能操作（例如，可能是锁屏或设置应用程序），这个简单的不带数据意图可能会引发非常复杂、风险相当高的漏洞。
- en: To help you picture the danger here, imagine a malicious application installed
    on your phone that repeatedly sends harmful intents to your system UI service.
    This causes it to crash over and over again, filling your screen with pop ups
    and warnings, and effectively disallows your interaction with the user interface
    of your phone. It would make quite a nasty bug, and it wouldn't require any permissions
    to install!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你了解这里的危险性，想象一下你的手机上安装了一个恶意应用程序，它不断地向你的系统UI服务发送有害意图。这导致它一次又一次地崩溃，屏幕上充满了弹窗和警告，有效地阻止了你对手机用户界面的交互。这将是一个相当讨厌的bug，而且安装时不需要任何权限！
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Vulnerability Summary for CVE-2011-4276* webpage at [http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4276&cid=6](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4276&cid=6)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请访问[*CVE-2011-4276漏洞概要*网页](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4276&cid=6)
- en: The *OWASP – GoatDroid* webpage at [https://github.com/jackMannino/OWASP-GoatDroid-Project/blob/master/](https://github.com/jackMannino/OWASP-GoatDroid-Project/blob/master/)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请访问[*OWASP – GoatDroid*网页](https://github.com/jackMannino/OWASP-GoatDroid-Project/blob/master/)
- en: Attacking broadcast receivers
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击广播接收器
- en: Broadcast receivers respond to hardware- and software-level events; they get
    notifications for these events via intents. Often, broadcast receivers may use
    information sent via intents to perform sensitive operations and do so in a way
    that can be maliciously influenced by the data being broadcast or received.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 广播接收器响应硬件和软件级别的事件；它们通过意图获取这些事件的提醒。通常，广播接收器可能会使用通过意图发送的信息来执行敏感操作，而且这种方式可能会受到恶意广播或接收的数据的影响。
- en: When exploiting a broadcast receiver, the challenge is determining whether or
    not the input is trusted and how *badly*. For this, you may need to effectively
    fuzz the intent filter definitions for the broadcast receivers in your target
    application or read the actual code, if you manage to get your hands on it, to
    find out what kind of data the receiver operates on and how.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在利用广播接收器时，挑战在于确定输入是否可信以及程度如何。为此，你可能需要对目标应用程序中的广播接收器的意图过滤器定义进行有效的模糊测试，或者如果你能弄到源代码，阅读实际代码，以找出接收器操作哪种类型的数据以及如何操作。
- en: 'As with the previous recipes, here we are going to see a sample of a classic
    vulnerable broadcast receivers. The following sample, too, is from the OWASP GoatDroid
    project:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱一样，这里我们将看到一个经典易受攻击的广播接收器的示例。以下示例同样来自OWASP GoatDroid项目：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The key issue in the code is that this application will be granted the `android.permission.SEND_SMS`
    permission while leaving its `.SendSMSNowReceiver` vulnerable receiver, without
    the protection of appropriate permissions and exposed to other applications.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的关键问题是，这个应用程序将被授予`android.permission.SEND_SMS`权限，同时其`.SendSMSNowReceiver`易受攻击的接收器没有得到适当的权限保护，从而暴露给其他应用程序。
- en: This is not all there is to these kinds of vulnerabilities; there is another
    part. Just because the receiver leaves other applications to interact with it
    doesn't necessarily mean that it's exploitable; to verify whether its exploitable,
    you can actually try firing off some of the commands discussed later in the recipe
    and—if possible—read some of the source code for the receiver.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是这类漏洞的全部；还有另一部分。仅仅因为接收器允许其他应用程序与其交互，并不意味着它一定可以被利用；要验证它是否可被利用，你实际上可以尝试执行本食谱后面讨论的一些命令，如果可能的话，阅读接收器的部分源代码。
- en: 'The following is the code that determines how the receiver handles the `org.owasp.goatdroid.fourgoats.SOCIAL_SMS`
    actions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是确定接收器如何处理`org.owasp.goatdroid.fourgoats.SOCIAL_SMS`动作的代码：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The key issue in the code is that the receiver takes values straight from the
    `bundle` object without first checking the calling application or the values being
    supplied and plugs it into a `sendTextMessage` call. This basically means any
    application will be able to send arbitrary, uncontrolled SMSs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的关键问题是接收器直接从`bundle`对象中获取值，而没有首先检查调用应用程序或提供的值，并将其插入到`sendTextMessage`调用中。这意味着任何应用程序都将能够发送任意的、不受控制的短信。
- en: Okay, so that's what a classic broadcast receiver vulnerability looks like;
    let's look at how one exploits these vulnerabilities practically, using drozer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么这就是一个经典广播接收器漏洞的样子；让我们看看如何使用drozer实际利用这些漏洞。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To send an intent to a broadcast receiver, you execute the following command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要向广播接收器发送意图，你可以执行以下命令：
- en: '[PRE36]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For example, in the introduction section of this recipe, we saw a receiver
    that could accept phone numbers and text messages. To attack that receiver, you
    would fire-off the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在本食谱的介绍部分，我们看到了一个可以接受电话号码和短信的接收器。要攻击该接收器，你会执行以下命令：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Executing the previous command would send a text message containing the message
    `PWNED` to a phone number of `1234567890`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 执行之前的命令将向电话号码`1234567890`发送包含消息`PWNED`的文本信息。
- en: How it works…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we abused the inadequate permissions protecting the `org.owasp.goatdroid.fourgoats.broadcastreceivers.SendSMSNowReceive`
    broadcast receiver. The lack of permissions protecting this component allows attackers
    with no `SEND_SMS` permission to actually send SMSs. The danger of this is that
    malicious attackers can develop applications that target this receiver to send
    SMSs to a premium service or leak information from the device.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们滥用了保护`org.owasp.goatdroid.fourgoats.broadcastreceivers.SendSMSNowReceive`广播接收器的不足权限。这个组件缺乏权限保护，允许没有`SEND_SMS`权限的攻击者实际发送短信。这种危险在于，恶意攻击者可以开发针对这个接收器的应用程序，向高级服务发送短信或从设备泄露信息。
- en: In fact, many Android Trojans and Android-based malware make use of this pattern
    to steal money from their victims; there are hundreds of practical examples of
    this. For good resources on some of them, see the *See also* section. Hopefully,
    this will make you aware of how dangerous inadequate permissions are for broadcast
    receivers like these.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多安卓木马和基于安卓的恶意软件都利用这种模式从受害者那里窃取钱财；有数百个实际例子。关于其中一些的好资源，请参阅*另请参阅*部分。希望这能让你意识到，对于像这样的广播接收器来说，权限不足是多么危险。
- en: See also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The *SMS Trojans: all around the world* article by *Denis Maslennikov* at Securelist
    ([https://www.securelist.com/en/blog/208193261/](https://www.securelist.com/en/blog/208193261/))'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*丹尼斯·马斯拉尼科夫*在Securelist撰写的文章《短信木马：全球范围内》([https://www.securelist.com/en/blog/208193261/](https://www.securelist.com/en/blog/208193261/))'
- en: The *Android Trojan Horse* project by *Jeremy Klein* and *Parker Spielman* ([http://www.cs.wustl.edu/~jain/cse571-11/ftp/trojan/index.html](http://www.cs.wustl.edu/~jain/cse571-11/ftp/trojan/index.html))
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*杰里米·克莱因*和*帕克·斯皮尔曼*的《安卓木马项目》([http://www.cs.wustl.edu/~jain/cse571-11/ftp/trojan/index.html](http://www.cs.wustl.edu/~jain/cse571-11/ftp/trojan/index.html))'
- en: '*The First Android SMS Trojan Found in the Wild* article by *Tim Wyatt* at
    Lookout ([https://blog.lookout.com/blog/2010/08/10/security-alert-first-android-sms-trojan-found-in-the-wild/](https://blog.lookout.com/blog/2010/08/10/security-alert-first-android-sms-trojan-found-in-the-wild/))'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蒂姆·怀亚特*在Lookout撰写的文章《野生的第一个安卓短信木马》([https://blog.lookout.com/blog/2010/08/10/security-alert-first-android-sms-trojan-found-in-the-wild/](https://blog.lookout.com/blog/2010/08/10/security-alert-first-android-sms-trojan-found-in-the-wild/))'
- en: Enumerating vulnerable content providers
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举容易受到攻击的内容提供者
- en: Content providers often hold a lot of valuable information, such as users' phone
    numbers or Twitter passwords, and you may want to find out whether or not it's
    possible for malicious attackers to get their hands on this information. The best
    way to find out whether a content provider is vulnerable to attack is by trying
    to attack it yourself.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者通常包含大量有价值的信息，比如用户的电话号码或Twitter密码，你可能想要找出恶意攻击者是否有可能获取这些信息。确定内容提供者是否容易受到攻击的最佳方式，就是尝试自己对其进行攻击。
- en: For you to be able to attack a content provider, as with many application-level
    attacks, it usually comes down to sending a malicious intent to an application.
    When it comes to content providers, your intent will be honed towards its target
    by the URI string it contains, since this URI identifies which content provider
    should handle the intent.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要对你能够攻击的内容提供者进行攻击，与许多应用程序级别的攻击一样，通常归结于向应用程序发送一个恶意意图。对于内容提供者来说，你的意图将通过它包含的URI字符串来精确指向目标，因为此URI标识了哪个内容提供者应该处理该意图。
- en: So then there's just one problem—how do we find out which URIs to use? One simple
    solution would be to guess them, but that could take ages! drozer has a module
    called `app.provider.info` that solves this problem for you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题来了——我们如何找出哪些URI可以使用？一个简单的解决方案就是猜测它们，但这可能需要很长时间！drozer有一个名为`app.provider.info`的模块，可以为你解决这个问题。
- en: This recipe details a few drozer modules that you can use to find content providers
    that may be vulnerable to attack.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档详细介绍了几个你可以用来查找可能容易受到攻击的内容提供者的drozer模块。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To find some content providers that will most likely be vulnerable to attack,
    you will need to do the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一些很可能容易受到攻击的内容提供者，你需要执行以下操作：
- en: 'Finding content providers that require no permissions is really easy with drozer;
    all you need to do is execute the following command from your drozer console:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用drozer查找不需要权限的内容提供者非常容易；你只需要在drozer控制台中执行以下命令：
- en: '[PRE38]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command lists all the content providers that don't require any
    read/write permissions.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令列出了所有不需要任何读写权限的内容提供者。
- en: 'Once you''ve found an appropriate content provider, you may want to enumerate
    the URIs it has authority over; you can do this using the following command:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到合适的内容提供者，你可能想要枚举它具有权限的URI；你可以使用以下命令来完成这个操作：
- en: '[PRE39]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding command, `[package]` is the full name of the package you want
    to extract information about.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的命令中，`[package]`是你想要提取信息包的完整名称。
- en: 'The following command is an example you can try out:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的命令是一个你可以尝试的示例：
- en: '[PRE40]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So what you've just done is find a possible entry point into the data that a
    given package saves in its content provider. The next recipe discusses how to
    extract this data.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你刚才所做的就是找到了一个可能的入口点，该入口点可以访问给定包在内容提供者中保存的数据。下一个食谱将讨论如何提取这些数据。
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `.finduri` module is pretty straightforward; it actually uses a very "sneaky"
    method to enumerate the possible content URIs. What it basically does is open
    the `DEX` file for the application and scan the unparsed file for any string literals
    resembling the valid content URI-format strings. The reason this is so effective
    is that application developers usually save these as static strings in the source
    of the application. The following is the actual source code for the Python script.
    It is extracted from [https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`.finduri` 模块非常直接；它实际上使用了一种非常“狡猾”的方法来枚举可能的内容 URI。它基本上是打开应用程序的 `DEX` 文件，并扫描未解析的文件，寻找类似于有效内容
    URI 格式的字符串字面量。之所以这样做非常有效，是因为应用程序开发人员通常将这些作为静态字符串保存在应用程序的源代码中。以下是 Python 脚本的实际源代码。它来自
    [https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py)。'
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: drozer Master repository – Provider.py ([https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/app/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/app/provider.py))
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: drozer 主仓库 – Provider.py ([https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/app/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/app/provider.py))
- en: drozer Master – Common/Provider.py ([https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py))
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: drozer 主模块 – Common/Provider.py ([https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py](https://github.com/mwrlabs/drozer/blob/master/src/drozer/modules/common/provider.py))
- en: Android Developer – URI permissions ([http://developer.android.com/guide/topics/security/permissions.html#uri](http://developer.android.com/guide/topics/security/permissions.html#uri))
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓开发者 – URI 权限 ([http://developer.android.com/guide/topics/security/permissions.html#uri](http://developer.android.com/guide/topics/security/permissions.html#uri))
- en: CVE-2013-231 – MovatwiTouch content provider vulnerability ([http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2318&cid=3](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2318&cid=3))
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CVE-2013-231 – MovatwiTouch 内容提供者漏洞 ([http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2318&cid=3](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2318&cid=3))
- en: Marakana – Android content provider tutorial ([http://marakana.com/s/post/1375/android_content_provider_tutorial](http://marakana.com/s/post/1375/android_content_provider_tutorial))
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Marakana – 安卓内容提供者教程 ([http://marakana.com/s/post/1375/android_content_provider_tutorial](http://marakana.com/s/post/1375/android_content_provider_tutorial))
- en: Extracting data from vulnerable content providers
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从易受攻击的内容提供者中提取数据
- en: If some of the content provider's URIs require no **read** permissions and/or
    **GrantURI** is set to `true`, you may be able to extract data from it using some
    of the drozer tools. Also, in certain situations, the way **read**/**write** permissions
    are issued and enforced also exposes the data in a content provider to attacks.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些内容提供者的 URI 不需要**读取**权限，或者将**GrantURI**设置为`true`，你可能可以使用一些 drozer 工具从中提取数据。在某些情况下，**读取**/**写入**权限的发放和执行方式也会将内容提供者的数据暴露给攻击。
- en: This recipe will covers some simple tricks that you can use to get a feel of
    the kind of information stored in the provider. This recipe follows from the previous
    one and assumes you've already enumerated some content URIs and determined that
    either none or insufficient permissions are required to interact and query the
    related URIs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将介绍一些简单技巧，你可以用它们来了解提供者中存储的信息类型。本指南接着上一条，并假定你已经枚举了一些内容 URI，并确定与之交互和查询相关 URI
    时不需要任何或权限不足。
- en: How to do it...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once you''ve found a URI, you''d query using the commands detailed in the previous
    recipe, namely:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个 URI 后，你可以使用前一个指南中详细描述的命令进行查询，具体为：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding commands will give you some pretty useful URIs to target; you
    can then execute the following command to extract some data:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令会为你提供一些相当有用的目标 URI；然后你可以执行以下命令来提取一些数据：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is a simple example; the drozer help documents about a lot of
    the content-provider-related scripts use this very example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单示例；关于许多与内容提供者相关的脚本，drozer 帮助文档都使用这个例子：
- en: '[PRE44]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s an example from a sample vulnerable content provider. In this example,
    the attacker uses drozer-extracted information about a user''s banking transactions;
    see the following screenshot for the output from the query command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个易受攻击的内容提供者的示例。在这个例子中，攻击者使用了 drozer 提取的关于用户银行交易的信息；请参阅以下屏幕截图以查看查询命令的输出：
- en: '![How to do it...](img/00094.jpeg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00094.jpeg)'
- en: 'Some content providers support the querying of files, especially those of file-manager-type
    applications. If the content provider makes no restrictions over the kinds of
    files and paths that applications are allowed to read from, it means that the
    attacker may be able to either perform the path traversal of directories outside
    the files that the content provider actually intends to offer or in many cases,
    allow attackers to extract files from sensitive directories on the victim''s device.
    To extract files, you can use the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 某些内容提供者支持查询文件，尤其是那些文件管理器类型的程序。如果内容提供者没有限制应用程序允许读取的文件类型和路径，这意味着攻击者可能能够执行路径遍历，访问内容提供者实际意图提供的文件之外的目录，或者在许多情况下，允许攻击者从受害者设备上的敏感目录中提取文件。要提取文件，你可以使用以下命令：
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding command, `URI` would be the URI to the file that you want
    to extract from the content provider. If there is no protection or filtering of
    input performed in the actual implementation of the part of the content provider
    that handles these kinds of queries, you could inject file paths and abuse the
    lack of protection to enumerate files and files'' contents in other areas of the
    device''s filesystem; you would do this by trying different file paths as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`URI` 是你希望从内容提供者那里提取的文件的 URI。如果在处理这类查询的内容提供者实际实现部分没有进行输入保护或过滤，你可以注入文件路径并利用这种缺乏保护来枚举设备文件系统中其他区域的文件及其内容；你可以通过尝试不同的文件路径来实现，如下所示：
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding command, `[valid-URI]` would be a URI that the vulnerable
    content provider has authority over or has been registered to handle, `[other
    file path]` would be the path to the file you wish to extract, and `[local-path]`
    would be a file path to the place you would like this file to be "downloaded".
    The following is an example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`[valid-URI]` 是脆弱的内容提供者有权处理或已注册处理的 URI，`[other file path]` 是你希望提取的文件的路径，`[local-path]`
    是你希望这个文件被 "下载" 的文件路径。以下是一个示例：
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For those of you who have any experience in hacking/auditing web applications,
    this is quite similar to path traversal and local file inclusion vulnerabilities
    in web applications. It also exposes Android applications to many of the same
    risks. A couple of practical examples of this vulnerability have been reported
    against very popular applications; see the *See Also...* section of the recipe
    for examples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有黑客攻击/审计 Web 应用程序经验的人来说，这类似于 Web 应用程序中的路径遍历和本地文件包含漏洞。它也使 Android 应用面临许多相同的风险。这种漏洞的一些实际示例已经针对一些非常流行的应用程序报告；有关示例，请参阅食谱的
    *另请参阅...* 部分。
- en: 'If your content provider sets path level permissions using the `PATTERN_LITERAL`
    matching type, the Android permissions framework will only enforce checks to protect
    your content provider if the paths requested match yours exactly! The following
    screenshot an example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的内容提供者使用 `PATTERN_LITERAL` 匹配类型设置路径级别的权限，那么 Android 权限框架只有在请求的路径与你的路径完全匹配时才会执行检查以保护你的内容提供者！以下是一个示例的屏幕截图：
- en: '![How to do it...](img/00095.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00095.jpeg)'
- en: This current example is taken from MWR labs' Sieve Android app, which was developed
    with certain vulnerabilities built into it; see the *See also* section for a link
    to the download page.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当前示例来自 MWR 实验室的 Sieve Android 应用，该应用内置了一些漏洞；有关下载页面的链接，请参阅 *另请参阅* 部分。
- en: 'In the previous screenshot, we can see that this app uses `PATTERN_LITERAL`-type
    matching to protect the `Keys` path, which means that if we try to query it using
    drozer, the result will be as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到这个应用使用 `PATTERN_LITERAL` 类型的匹配来保护 `Keys` 路径，这意味着如果我们尝试使用 drozer
    进行查询，结果将如下所示：
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following screenshot shows the output from previous command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了之前命令的输出：
- en: '![How to do it...](img/00096.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00096.jpeg)'
- en: 'The preceding screenshot shows how a permission denial is caused because drozer
    doesn''t have the required permissions to interact with the provider. But, if
    we simply append `/` to the path, it will still be valid, the result is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了由于drozer没有与提供者交互所需的权限而导致的权限拒绝。但是，如果我们简单地在路径后加上`/`，它仍然有效，结果如下：
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了前面命令的输出：
- en: '![How to do it...](img/00097.jpeg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00097.jpeg)'
- en: A forward slash was added to the path, so the `PATTERN_LITERAL` check failed
    to find the `content://com.mwr.example.sieve.DBConentProvider/Keys` path and found
    the `content://com.mwr.example.sieve.DBConentProvider/Keys/` path instead. This
    means that the application querying the content provider would then need permissions
    for the `/Keys/` path, which was not defined and thus required no permissions,
    allowing the query to be resolved without a hitch. In the previous screenshot,
    we can see that in this instance, a malicious application would be able to extract
    details of a user's login pin for the Sieve password manager application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 路径中添加了一个正斜杠，因此`PATTERN_LITERAL`检查未能找到`content://com.mwr.example.sieve.DBConentProvider/Keys`路径，而是找到了`content://com.mwr.example.sieve.DBConentProvider/Keys/`路径。这意味着查询内容提供者的应用程序将需要`/Keys/`路径的权限，该路径未定义，因此不需要权限，这使得查询能够顺利解决。在之前的屏幕截图中，我们可以看到在这种情况下，恶意应用程序能够提取用户针对Sieve密码管理应用程序的登录PIN码详情。
- en: See also
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Path traversal vulnerability on Shazam (Android) application* article ([http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-shazam-android-application/](http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-shazam-android-application/))
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Shazam (Android)应用程序上的路径遍历漏洞》文章（[http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-shazam-android-application/](http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-shazam-android-application/)）
- en: The *Path traversal vulnerability in Adobe Reader (Android) application* article
    ([http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application/](http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application/))
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Adobe Reader (Android)应用程序上的路径遍历漏洞》文章（[http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application/](http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application/)）
- en: The *WinZip for Android Content Handling Directory Traversal Vulnerability*
    article ([http://vuln.sg/winzip101-en.html](http://vuln.sg/winzip101-en.html))
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《WinZip for Android内容处理目录遍历漏洞》文章（[http://vuln.sg/winzip101-en.html](http://vuln.sg/winzip101-en.html)）
- en: The Android 2.3.4 Browser Local File Inclusion at CVE Details; **CVE-2010-4804**
    ([http://www.cvedetails.com/cve/CVE-2010-4804/](http://www.cvedetails.com/cve/CVE-2010-4804/))
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CVE Details上的Android 2.3.4浏览器本地文件包含漏洞；**CVE-2010-4804** ([http://www.cvedetails.com/cve/CVE-2010-4804/](http://www.cvedetails.com/cve/CVE-2010-4804/))
- en: drozer Sieve – A password manager app that showcases some common Android vulnerabilities
    ([https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk](https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk))
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: drozer Sieve – 一个展示了一些常见Android漏洞的密码管理应用（[https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk](https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk)）
- en: Inserting data into content providers
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向内容提供者中插入数据
- en: Like any database-orientated application, content providers may also facilitate
    the ability to insert data into their SQLite databases or file stores; should
    any content provider not restrict this functionality using the appropriate **write**
    permissions, an attacker may be able to insert data into the SQLite database maliciously.
    This tutorial discusses how you can perform this kind of attack; in the next chapter,
    we will look at the actual code that causes these vulnerabilities and discuss
    some remedies.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何以数据库为中心的应用程序一样，内容提供者也可能具备向其SQLite数据库或文件存储中插入数据的能力；如果任何内容提供者没有使用适当的**写入**权限来限制此功能，攻击者可能会恶意地向SQLite数据库中插入数据。本教程将讨论如何执行此类攻击；在下一章中，我们将查看导致这些漏洞的实际代码，并讨论一些补救措施。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before we go inserting data into the content providers, we need to know what
    the schema or column set up for the database looks like; you can enumerate this
    information using the following command from your drozer console:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向内容提供者插入数据之前，我们需要了解数据库的架构或列设置是什么样的；您可以使用以下命令从您的drozer控制台枚举此信息：
- en: '[PRE50]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding command `[URI]` is the URI you wish to find out about. For
    instance, if you want to run it against Sieve, you would execute the following
    command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中`[URI]`是你希望了解的 URI。例如，如果你想针对 Sieve 运行它，你会执行以下命令：
- en: '[PRE51]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding command will produce the output shown in the following screenshot:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将产生如下截图所示的输出：
- en: '![How to do it...](img/00098.jpeg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00098.jpeg)'
- en: The reason enumerating the columns of a database is useful is that it may help
    you structure your future attacks against the content provider; you may need to
    know a little about the schema to be able to know which columns and rows you might
    be interested in extracting from and inserting into.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举数据库列之所以有用，是因为它可能有助于你针对内容提供者构建未来的攻击；你可能需要了解一些关于模式的信息，以便知道你可能感兴趣从中提取和插入的列和行。
- en: 'Once you know a little about the database''s structure and which column names
    you may need to be able to structure your queries correctly, you can insert data
    into a content provider using the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当你了解了数据库的结构以及可能需要哪些列名以便正确构建查询时，你可以使用以下命令将数据插入内容提供者：
- en: '[PRE52]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding command, `[URI]` is the URI pointing to the related database
    and `--boolean`, `--integer`, and `--string` is a flag you should provide to mark
    a given piece of data as a given data type. This module supports the following
    data types:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`[URI]` 是指向相关数据库的 URI，而 `--boolean`、`--integer` 和 `--string` 是你应该提供的标志，以将给定的数据片段标记为给定的数据类型。此模块支持以下数据类型：
- en: '[PRE53]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Each of them require the `[name]` value, which indicates the column name, and
    `[value]`, which indicates the actual value you wish to insert.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都需要`[name]`值，这表示列名，以及`[value]`，表示你希望插入的实际值。
- en: 'The following code is an example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是一个示例：
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The following is a fictitious example. The `content://com.example.vulnerabledatabase.contentprovider/statement`
    URI probably doesn't exist on your device, unless you've explicitly developed
    some app that handles it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子是虚构的。`content://com.example.vulnerabledatabase.contentprovider/statement`
    URI 在你的设备上可能不存在，除非你已经明确开发了一些处理它的应用。
- en: 'The following a working example against Sieve:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是针对 Sieve 的工作示例：
- en: '[PRE55]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once you query Sieve''s Passwords URI and perform the previous command, the
    following data is returned:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查询 Sieve 的密码 URI 并执行之前的命令后，将返回以下数据：
- en: '![How to do it...](img/00099.jpeg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00099.jpeg)'
- en: We can clearly see that for **_id** **3** the data we just injected actually
    appears in the database. This means we've just managed to corrupt the data in
    the Passwords database with some forged data. In a practical context, this could
    allow attackers to change a user's passwords or delete them, which could deny
    users access to the related accounts; more specifically, in a password-management
    application such as Sieve—used here as an example—attackers would be able to bar
    users' access to their stored passwords and maybe even their Gmail, Twitter, or
    LinkedIn accounts.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，对于 **_id** **3** 的数据，我们刚刚注入的数据实际上出现在数据库中。这意味着我们刚刚成功用一些伪造数据破坏了 Passwords
    数据库中的数据。在实际情况下，这可能允许攻击者更改用户的密码或删除它们，从而拒绝用户访问相关账户；更具体地说，在像 Sieve 这样的密码管理应用（这里仅作为示例）中，攻击者能够阻止用户访问他们存储的密码，甚至可能是他们的
    Gmail、Twitter 或 LinkedIn 账户。
- en: 'A little side note about the example: we injected the password string `woopwoop`
    merely as a marker to make sure we can inject password data—its merely a string
    that''s pretty easy to recognize; if you''re going to test this password, it probably
    would not work. To actually inject a working password, you need to inject the
    base64 encoded value of the password.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 关于示例的一个小注：我们注入密码字符串 `woopwoop` 仅作为标记，以确保我们可以注入密码数据——它只是一个很容易识别的字符串；如果你要测试这个密码，它可能不会起作用。实际上，要注入一个有效的密码，你需要注入密码的
    base64 编码值。
- en: Enumerating SQL-injection vulnerable content providers
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举 SQL 注入漏洞的内容提供者
- en: Just like web applications, Android applications may use untrusted input to
    construct SQL queries and do so in a way that's exploitable. The most common case
    is when applications do not sanitize input for any SQL and do not limit access
    to content providers.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络应用一样，Android 应用可能会使用不可信的输入来构建 SQL 查询，并以可被利用的方式进行。最常见的情况是应用没有对任何 SQL 输入进行清理，也没有限制对内容提供者的访问。
- en: 'Why would you want to stop a SQL-injection attack? Well, let''s say you''re
    in the classic situation of trying to authorize users by comparing a username
    supplied by querying a database for it. The code would look similar to the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要阻止 SQL 注入攻击？嗯，假设你处于一种经典情况，通过查询数据库来为用户提供授权。代码可能类似于以下这样：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the previous code, none of the `projection`, `selection`, `selectionArgs`,
    or `sortOrder` variables are sourced directly from external applications. If the
    content provider is exported and grants URI permissions or, as we've seem before,
    does not require any permissions, it means that attackers will be able to inject
    arbitrary SQL to augment the way the malicious query is evaluated.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`projection`、`selection`、`selectionArgs` 或 `sortOrder` 变量都没有直接来自外部应用程序。如果内容提供者被导出并授予
    URI 权限，或者如我们之前所见，不需要任何权限，这意味着攻击者将能够注入任意的 SQL 来增强恶意查询的评估方式。
- en: Let's look at how you actually go about attacking SQL-injection vulnerable content
    providers using drozer.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际上是如何使用 drozer 攻击易受 SQL 注入攻击的内容提供者的。
- en: How to do it...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, I''ll talk about two kinds of SQL-injection vulnerabilities:
    one is when the select clause of a SQL statement is injectable and the other is
    when the projection is injectable. Using drozer, it is pretty easy to find select-clause-injectable
    content providers:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我将讨论两种 SQL 注入漏洞：一种是 SQL 语句的选择子句可注入，另一种是投影可注入。使用 drozer，查找可注入选择子句的内容提供者非常容易：
- en: '[PRE59]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The previous will try to inject what's called a logical tautology into the SQL
    statement being parsed by the content provider and eventually the database query
    parser. Due to the nature of the module being used here, you can tell whether
    or not it actually worked, because it should return all the data from the database;
    that is, the select-clause criteria is applied to every row and because it will
    always return true, every row will be returned!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 前文提到的方法将尝试向由内容提供者解析的 SQL 语句中注入所谓的逻辑恒真式，最终由数据库查询解析器处理。由于这里使用的模块的性质，你可以判断它是否真的起作用了，因为它应该返回数据库中的所有数据；也就是说，选择子句的条件被应用于每一行，并且因为它总是返回真，所以每一行都会被返回！
- en: 'You could also try any values that would always be true:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试任何总是为真的值：
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following is an example of using a purposely vulnerable content provider:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个故意使用易受攻击的内容提供者的例子：
- en: '[PRE61]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It returns the entire table being queried, which is shown in the following
    screenshot:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了被查询的整个表，如下面的截图所示：
- en: '![How to do it...](img/00094.jpeg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00094.jpeg)'
- en: You can, of course, inject into the projection of the `SELECT` statement, that
    is, the part before `FROM` in the statement, that is, `SELECT [projection] FROM
    [table] WHERE [select clause]`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以在 `SELECT` 语句的投影部分注入，即语句中 `FROM` 之前的部分，即 `SELECT [投影] FROM [表] WHERE
    [选择子句]`。
- en: See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *SQL As Understood By SQLite* article at the SQLite Language Reference guide
    ([http://www.sqlite.org/lang.html](http://www.sqlite.org/lang.html))
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLite 语言参考指南中的 *SQL As Understood By SQLite* 文章](http://www.sqlite.org/lang.html)'
- en: The SQL-injection article at [https://www.owasp.org/index.php/SQL_Injection](https://www.owasp.org/index.php/SQL_Injection)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于 SQL 注入的文章](https://www.owasp.org/index.php/SQL_Injection)'
- en: Exploiting debuggable applications
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用可调试的应用程序
- en: Applications can be marked as debuggable to make functionality testing and error
    tracking a lot easier by allowing you to set breakpoints during app execution.
    To do this, view the VM stack and suspend and resume threads while the app is
    running on the device.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以被标记为可调试，以便在进行功能测试和错误跟踪时，允许你在应用程序执行过程中设置断点，从而大大简化这些操作。为此，可以在应用程序在设备上运行时查看虚拟机堆栈并挂起或恢复线程。
- en: Unfortunately, some applications on the Google Play store are still flagged
    as debuggable. This may not always be the end of the world, but if the app hopes
    to protect any authentication data, passwords addresses, or any values stored
    in the applications memory, having it marked as debuggable means that attackers
    will be able to gain access to this data very easily.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，谷歌应用商店上的一些应用程序仍然被标记为可调试。这不一定总是世界末日，但如果应用程序希望保护任何认证数据、密码地址或存储在应用程序内存中的任何值，被标记为可调试意味着攻击者可以非常容易地获取这些数据。
- en: This recipe discusses how to leak variable values from a debuggable application.
    Attackers may also be able to trigger remote-code execution via the app and run
    some code within the applications context.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档讨论了如何从一个可调试的应用程序中泄露变量值。攻击者也可能能够通过应用程序触发远程代码执行，并在应用程序的上下文中运行一些代码。
- en: The example being used here is the Android Wall Street Journal app and at the
    time of writing, it was one of the applications on the Google Play store that
    were published as debuggable.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的例子是安卓版的华尔街日报应用，在撰写本文时，它是谷歌Play商店中作为可调试应用程序发布的应用之一。
- en: How to do it...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first thing you''ll need to do is determine whether or not the application
    is debuggable. This is fairly simple, because whether or not an application is
    debuggable depends directly on its application manifest. The `debuggable` field
    in the application element of the Android application manifest. To enumerate and
    exploit debuggable applications you will need to perform the following steps:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是确定应用程序是否可调试。这相当简单，因为一个应用程序是否可调试直接取决于其应用程序清单。在Android应用程序清单的应用元素中的`debuggable`字段。要枚举和利用可调试的应用程序，你需要执行以下步骤：
- en: 'To check whether or not an application is debuggable, you can either extract
    the manifest or execute the following command from your drozer console:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查一个应用程序是否可调试，你可以提取清单文件，或者从你的drozer控制台执行以下命令：
- en: '[PRE62]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will list all the packages that are set as debuggable and display the
    permissions they''ve been granted. The following screenshot shows a list of the
    packages:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将列出所有设置为可调试的包，并显示它们被授予的权限。以下截图显示了一个包列表：
- en: '![How to do it...](img/00100.jpeg)'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00100.jpeg)'
- en: 'You may be asking yourself whether or not a simple vulnerability like this
    actually occurs in the real world? Well, yes, it actually still does! The following
    screenshot shows a relatively well known app that''s been published to the Google
    Play market as debuggable:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会问自己，像这样的简单漏洞在现实世界中真的存在吗？嗯，是的，实际上仍然存在！以下截图显示了一个相对知名的应用程序，它被发布到谷歌Play市场时是可调试的：
- en: '![How to do it...](img/00101.jpeg)'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00101.jpeg)'
- en: This example shows an output from the `.debuggable` module indicating that the
    Wall Street Journal Reader app is debuggable.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本例显示`.debuggable`模块的输出，表明华尔街日报阅读器应用是可调试的。
- en: 'Once you''ve identified a good target, you should launch it using a command
    as follows:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你确定了一个好的目标，你应该使用如下命令来启动它：
- en: '[PRE63]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once it''s running, you can use ADB to get the Java Debug Wire Protocol Port
    which has been opened for that instance of the VM for debugging; the following
    is how you do that:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行起来，你可以使用ADB获取为该虚拟机实例打开的Java调试协议端口；以下是操作方法：
- en: '[PRE64]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should see something like the following:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到如下内容：
- en: '![How to do it...](img/00102.jpeg)'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00102.jpeg)'
- en: 'The number returned by ADB is the port you can use to connect to the VM, but
    before you can do that from your machine, you need to forward that port via `adb`;
    the following is how you do that:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ADB返回的数字是你可以用来连接到虚拟机的端口，但在你的机器上这样做之前，你需要通过`adb`转发这个端口；以下是操作方法：
- en: '[PRE65]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'For the example in the screenshot, you would execute the following command
    to forward the port:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于截图中给出的例子，你需要执行以下命令来转发端口：
- en: '![How to do it...](img/00103.jpeg)'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00103.jpeg)'
- en: 'You can now access the VM running this app from your machine. From this point
    on, you can rely on the Java Debugger to connect to the VM; you do this by running
    the following command:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以从你的机器上访问运行这个应用的虚拟机。从这一点开始，你可以依赖Java调试器连接到虚拟机；你可以通过运行以下命令来实现：
- en: '[PRE66]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `[PORT]` port you would use would be the one forwarded in the previous
    step; in this example, that would be `31337`. Connecting via `jdb` would work
    as follows:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将使用的`[PORT]`端口是上一步转发的端口；在这个例子中，那将是`31337`。通过`jdb`连接的操作如下：
- en: '[PRE67]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的截图显示了前面命令的输出：
- en: '![How to do it...](img/00104.jpeg)'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00104.jpeg)'
- en: 'Then you would be connected to the VM running this app on the Android device;
    you can then do things such as extract information about the classes compiled
    with the application; this is done by executing the following command from within
    your `jdb` session:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你将连接到在Android设备上运行这个应用虚拟机；然后你可以执行诸如提取与应用程序编译的类信息等操作；这是通过在`jdb`会话中执行以下命令完成的：
- en: '[PRE68]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This would produce output similar to the following:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生类似于以下的输出：
- en: '![How to do it...](img/00105.jpeg)'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00105.jpeg)'
- en: 'You can also enumerate the methods per class by firing off the following command:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以通过执行以下命令枚举每个类的方法：
- en: '[PRE69]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the preceding command, `[class-path]` is the full class path of the class
    would like to know about.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的命令中，`[class-path]`是你想要了解的类的完整类路径。
- en: The following is a screenshot demonstrating the previous command against an
    application package called `com.example.readmycontacts`. Here we are extracting
    information about the `.MainActivity` class, which is the class called to launch
    the activity.![How to do it...](img/00106.jpeg)
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图演示了针对名为`com.example.readmycontacts`的应用程序包执行前一个命令的情况。这里我们正在提取有关`.MainActivity`类的信息，这是调用启动活动的类。![如何操作...](img/00106.jpeg)
- en: 'You can even dig a little deeper and list the "fields" or class attribute names
    and values for a given class; this is done by executing the following command
    from within JDB:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你甚至可以进一步深入，列出给定类的“字段”或类属性名称和值；这是通过在JDB内部执行以下命令来完成的：
- en: '[PRE70]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For instance:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE71]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Why would you, as an Android application hacker, be interested in reading values
    from the fields in a class file? Well, because developers may often explicitly
    store sensitive details inside a class file instead of fetching them from the
    cloud; so you can expect values, such as passwords, API tokens, single-sign-on
    tokens, default usernames, and generally any data used for authentication or other
    sensitive operations saved inside a class's fields.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Android应用程序黑客，你为什么会对从类文件中的字段读取值感兴趣？因为开发人员可能会经常将敏感信息显式地存储在类文件中，而不是从云端获取；因此你可以期待在类的字段中保存诸如密码、API令牌、单点登录令牌、默认用户名以及通常用于身份验证或其他敏感操作的数据。
- en: For some Android operating systems, specifically any unpatched Gingerbread device
    and any lower version. This vulnerability could mean that malicious applications
    may be able to execute the arbitrary command in the context of another application.
    Why only Gingerbread and lower? Well before the update of the Dalvik virtual machine
    to Gingerbread, the Dalvik caused debuggable applications to try to connect to
    the Java Debug Wire Protocol port even when ADB was not running; this means that
    malicious applications capable of opening networking sockets on the targeted device
    would be able to accept connections from debuggable applications and, because
    of how Java Debugging works, be able to execute arbitrary code. For more details
    on this behavior, visit the link to the *Debuggable Apps in Android Market article*
    in the *See also* section as well as the links to the Dalvik Virtual Machine code
    for different versions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些Android操作系统，特别是任何未打补丁的Gingerbread设备及更低版本。这个漏洞可能意味着恶意应用程序能够在另一个应用程序的上下文中执行任意命令。为什么只有Gingerbread及更低版本？因为在Dalvik虚拟机更新到Gingerbread之前，Dalvik导致可调试的应用程序即使在没有运行ADB的情况下也会尝试连接到Java调试线协议端口；这意味着能够在目标设备上打开网络套接字的恶意应用程序能够接受来自可调试应用程序的连接，并且因为Java调试的工作方式，能够执行任意代码。有关此行为的更多详细信息，请访问*Android市场中的可调试应用程序*文章中的链接，以及不同版本的Dalvik虚拟机代码的链接。
- en: There are a lot more things you can do with the Java debugger; for those of
    you who want to learn a little more about it, I've included some useful links
    in the *See also* section.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Java调试器做更多的事情；对于那些想了解更多关于它的信息的读者，我在*另请参阅*部分包含了一些有用的链接。
- en: See also
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Jdb – The Java Debugger* article at [http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/jdb.html](http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/jdb.html)
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Jdb – Java调试器](http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/jdb.html)文章'
- en: The *Java Platform Debugger Architecture* article at [http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/index.html](http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/index.html)
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Java平台调试器架构](http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/index.html)文章'
- en: The *Android:debuggable – Android Developer Reference* guide at [http://developer.android.com/guide/topics/manifest/application-element.html#debug](http://developer.android.com/guide/topics/manifest/application-element.html#debug)
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Android:debuggable – Android 开发者参考指南](http://developer.android.com/guide/topics/manifest/application-element.html#debug)'
- en: The *Debuggable Apps in Android Market* article at MWRLabs ([http://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/](http://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/))
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于MWRLabs的*Android Market中的可调试应用*文章（[http://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/](http://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/)）
- en: The *Exploit (& Fix) Android "Master Key"* article by Saurik at [http://www.saurik.com/id/17](http://www.saurik.com/id/17)
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Saurik撰写的*利用（及修复）Android "Master Key"*文章，位于[http://www.saurik.com/id/17](http://www.saurik.com/id/17)
- en: The *Debugging Java Programs using JDB* article at [http://www.packtpub.com/article/debugging-java-programs-using-jdb](http://www.packtpub.com/article/debugging-java-programs-using-jdb)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于[http://www.packtpub.com/article/debugging-java-programs-using-jdb](http://www.packtpub.com/article/debugging-java-programs-using-jdb)的*使用JDB调试Java程序*文章
- en: JdwpAdb.c – Kitkat release, Android Source Code repository ([https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/jdwp/JdwpAdb.cpp](https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/jdwp/JdwpAdb.cpp))
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JdwpAdb.c – Kitkat版本，Android源代码仓库（[https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/jdwp/JdwpAdb.cpp](https://android.googlesource.com/platform/dalvik/+/kitkat-release/vm/jdwp/JdwpAdb.cpp)）
- en: JdwpAdb.c – Éclair Passion release, Android Source Code repository ([https://android.googlesource.com/platform/dalvik/+/eclair-passion-release/vm/jdwp/JdwpAdb.c](https://android.googlesource.com/platform/dalvik/+/eclair-passion-release/vm/jdwp/JdwpAdb.c))
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JdwpAdb.c – Éclair Passion版本，Android源代码仓库（[https://android.googlesource.com/platform/dalvik/+/eclair-passion-release/vm/jdwp/JdwpAdb.c](https://android.googlesource.com/platform/dalvik/+/eclair-passion-release/vm/jdwp/JdwpAdb.c)）
- en: JdwpAdb.c – Gingerbread release, Android Source Code repository ([https://android.googlesource.com/platform/dalvik/+/gingerbread-release/vm/jdwp/JdwpAdb.c](https://android.googlesource.com/platform/dalvik/+/gingerbread-release/vm/jdwp/JdwpAdb.c))
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JdwpAdb.c – Gingerbread版本，Android源代码仓库（[https://android.googlesource.com/platform/dalvik/+/gingerbread-release/vm/jdwp/JdwpAdb.c](https://android.googlesource.com/platform/dalvik/+/gingerbread-release/vm/jdwp/JdwpAdb.c)）
- en: Man-in-the-middle attacks on applications
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序中的中间人攻击
- en: Mobile phone users often use public Wi-Fi networks to access the Internet in
    coffee shops, libraries, and anywhere they are available. Unfortunately, due to
    how certain applications are developed, they can still fall victim to **man-in-the-middle**
    (**MITM**) attacks. For those of you who don't know about MITM attacks, they are
    essentially attacks that allow adversaries to intercept your communication with
    the devices on your network; if you'd like to know more about the danger and technical
    specifics of these attacks in nonmobile contexts, check out some of the links
    in the *See also* section.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 手机用户经常在咖啡店、图书馆以及任何可用之处通过公共Wi-Fi网络访问互联网。不幸的是，由于某些应用程序的开发方式，它们仍然可能成为**中间人**（**MITM**）攻击的受害者。对于那些不了解MITM攻击的人来说，它们本质上是一种允许攻击者截取你与网络设备通信的攻击；如果你想在非移动环境中了解这些攻击的危险性和技术细节，请查看*另请参阅*部分的一些链接。
- en: Why should we care about MITM attacks on mobile phones? Well, depending on how
    badly the content from an "insecure" channel to network-based resources is trusted,
    attackers may be able to do anything, from fingerprinting the applications running
    on your device to detailing every place where you've been, approximately where
    you live and work, and even take control of some applications on your mobile device
    and maybe even your entire phone—if its rooted insecurely or can be rooted. There
    are numerous practical examples of vulnerabilities in very popular applications,
    which can be exploited using man-in-the-middle attacks; check out the links in
    the *See also* section for some of them.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该关注手机上的中间人攻击（MITM）呢？因为，如果不受信任的渠道到网络资源的信任度很高，攻击者可能会做任何事情，从对你的设备上运行的应用程序进行指纹识别，到详细记录你曾经到过的每一个地方，你大概的居住和工作地点，甚至可能控制你手机上的某些应用程序，如果手机安全性不高或可以被root，甚至可能控制整部手机。一些非常流行的应用程序中存在实际的安全漏洞，这些漏洞可能被中间人攻击所利用；查看*另请参阅*部分中的链接了解其中一些。
- en: This recipe demonstrates how to perform an MITM attack on an Android phone and
    one simple exploit that can be used during an MITM attack, namely DNS poisoning.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南展示了如何在Android手机上执行MITM攻击，以及一种在MITM攻击期间可能使用的简单漏洞利用，即DNS投毒。
- en: One small caveat here is that Ettercap, the tool being used to perform the MITM
    attack, doesn't officially provide any Windows support. Though, if you don't have
    an Ubuntu or Debian Linux machine, you can set one up, simply download a CD/DVD
    image for Ubuntu and run it from a virtual machine using Oracle's Virtualbox,
    or VMware works quite well for this too. To find out how to install a virtual
    machine, see the *There's more…* section of the *Installing and setting up Santuko*
    recipe in [Chapter 3](part0032_split_000.html#page "Chapter 3. Android Security
    Assessment Tools"), *Android Security Assessment Tools*. If you're really keen
    on using Ettercap on your Windows machines, you can check out the download links
    to the unofficial Windows binaries in the *See also* section.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小警告，即执行 MITM 攻击所使用的 Ettercap 工具并没有官方提供任何 Windows 支持版本。不过，如果你没有 Ubuntu 或
    Debian Linux 机器，你可以设置一个，只需下载 Ubuntu 的 CD/DVD 镜像并在 Oracle 的 Virtualbox 或 VMware
    中使用虚拟机运行。要了解如何安装虚拟机，请查看 [第3章](part0032_split_000.html#page "Chapter 3. Android
    Security Assessment Tools") *Android Security Assessment Tools* 中 *安装和设置 Santuko*
    食谱的 *还有更多...* 部分。如果你真的想在 Windows 机器上使用 Ettercap，你可以查看 *另请参阅* 部分中非官方 Windows 二进制文件的下载链接。
- en: Getting ready
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To make this whole process a lot simpler, I''m going show you guys how to download
    an awesome tool that makes MITM attacks really easy. You can download Ettercap
    using the following command:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让整个过程变得更简单，我将向大家展示如何下载一个让 MITM 攻击变得非常简单的工具。你可以使用以下命令下载 Ettercap：
- en: '[PRE72]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了前面命令的输出：
- en: '![Getting ready](img/00107.jpeg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![Getting ready](img/00107.jpeg)'
- en: Once it's downloaded and set up, you can get going with the MITM attack.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并设置后，你就可以开始 MITM 攻击了。
- en: How to do it...
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s get started with the following steps:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: Before we start setting up the MITM attack, you will need to set up the DNS
    Spoof plugin for Ettercap; the only thing you need to do is add some useful addresses
    to the DNS configs script for Ettercap that is saved in `/usr/share/ettercap/etter.dns`
    on Linux machines.![How to do it...](img/00108.jpeg)
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始设置 MITM 攻击之前，你需要为 Ettercap 设置 DNS 欺骗插件；你需要做的唯一一件事就是为保存在 Linux 机器上的 `/usr/share/ettercap/etter.dns`
    的 Ettercap DNS 配置脚本添加一些有用的地址。![How to do it...](img/00108.jpeg)
- en: 'The `etter.dns` file should look a little something like the following:'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`etter.dns` 文件应该看起来像下面这样：'
- en: '![How to do it...](img/00109.jpeg)'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![How to do it...](img/00109.jpeg)'
- en: 'After editing this file, it should look like the following:'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑这个文件后，它应该看起来像下面这样：
- en: '![How to do it...](img/00110.jpeg)'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![How to do it...](img/00110.jpeg)'
- en: The address `192.168.10.102` should be replaced with the Internet address of
    your machine, since you'd like to spoof the DNS server using your machine, which
    basically means your machine will act as the DNS server.
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 地址 `192.168.10.102` 应该替换成你的机器的互联网地址，因为你想使用你的机器来欺骗 DNS 服务器，这意味着你的机器将充当 DNS 服务器。
- en: 'Once the DNS plugin has been set up properly, you can start an MITM attack
    by executing the following command from your terminal or command prompt:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 DNS 插件设置正确，你可以通过从终端或命令提示符执行以下命令来启动 MITM 攻击：
- en: '[PRE73]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding command, `[interface]` is the network interface you're using
    to connect to the network; it could be either an Ethernet or wireless interface.
    `[address of target]` is the Internet address of your Android device; you can
    find this on your Android phone under **Settings** | **Wi-Fi** | **[name of network]**
    | **IP Address**. `[address of gateway]` is the Internet address of the default
    gateway for this network. This attack fools your mobile phone into thinking that
    the machine you are attacking from is the actual gateway by abusing the lack of
    authentication of the **Address Resolution Protocol** (**ARP**).
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的命令中，`[interface]` 是你用来连接网络的网络接口，可能是以太网或无线接口。[address of target] 是你的安卓设备的互联网地址；你可以在安卓手机的
    **设置** | **Wi-Fi** | **[网络名称]** | **IP地址** 下找到这个地址。[address of gateway] 是这个网络的默认网关的互联网地址。这种攻击利用
    **地址解析协议** (**ARP**) 缺乏认证的弱点，让你的手机误认为你攻击的机器就是实际的网关。
- en: 'For example, if your gateway''s IP address is `192.168.10.1` and your Android
    device''s IP is `192.168.10.106`, the following is how you would set up the MITM
    attack:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果你的网关 IP 地址是 `192.168.10.1` 而你的安卓设备 IP 是 `192.168.10.106`，以下是设置 MITM 攻击的方法：
- en: '[PRE74]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can interchange the last two addresses; the order doesn''t matter as long
    as they are both there. After executing this command, you should see the following
    appear on your terminal:'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以互换最后两个地址；只要它们都在，顺序无关紧要。执行这个命令后，你应该能在终端上看到以下内容出现：
- en: '![How to do it...](img/00111.jpeg)'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00111.jpeg)'
- en: After a while, you should see something similar to the following screenshot
    of the traffic being logged by Ettercap:![How to do it...](img/00112.jpeg)
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后，你应该能看到类似以下截图的内容，这是由Ettercap记录的流量：![如何操作...](img/00112.jpeg)
- en: Once you start some apps using this "poisoned" network, you'll be able to see
    some strange things happen on your attacker machine; for instance, you'll be able
    to see the DNS requests being sent by your Android apps; The following screenshot
    shows the DNS requests sent by the Flipboard app:![How to do it...](img/00113.jpeg)
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你开始使用这个“中毒”的网络启动一些应用程序，你就能在攻击者机器上看到一些奇怪的事情发生；例如，你将能够看到你的安卓应用程序发送的DNS请求；以下截图显示了Flipboard应用程序发送的DNS请求：![如何操作...](img/00113.jpeg)
- en: This output was generated by Wireshark.
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个输出是由Wireshark生成的。
- en: If you have a web server configured on your machine, you'll be able to serve
    some content to your Android phone by pretending to be websites such as LinkedIn
    and Google; the following are some screenshots demonstrating this:![How to do
    it...](img/00114.jpeg)
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的机器上配置了一个网页服务器，你可以通过伪装成LinkedIn和Google等网站，向你的安卓手机提供一些内容；以下是演示这一点的截图：![如何操作...](img/00114.jpeg)
- en: 'Here''s another example; a request to [www.google.com](http://www.google.com)
    has been intercepted in the following screenshot:'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里还有一个例子；以下截图显示了被拦截的[www.google.com](http://www.google.com)的请求：
- en: '![How to do it...](img/00115.jpeg)'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00115.jpeg)'
- en: Clearly, these are not LinkedIn and Google webpages; in fact, the page returned
    here is from a local machine to the network. This may be a very mundane demonstration,
    though it covers the hard part of the attack, which is establishing the MITM context
    in which an attacker is capable of controlling the responses an application issues
    to the Internet.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些不是LinkedIn和Google的网页；实际上，这里返回的页面是从本地机器到网络的。这可能是一个非常平凡的演示，但它涵盖了攻击的难点部分，即建立MITM（中间人攻击）上下文，攻击者能够控制应用程序向互联网发出的响应。
- en: What you can do from here, once you have established your MITM context, is either
    exploit the mobile browser using something such as Metasploit and its `browser_autopwn`
    module or use some social engineering by mirroring these sites using a tool—the
    Social Engineering Toolkit works great for this. See the *See also* section for
    links to information about these great tools.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了MITM上下文之后，你可以利用移动浏览器，使用诸如Metasploit及其`browser_autopwn`模块之类的东西，或者使用一些社交工程工具来镜像这些网站——社会工程工具包在这方面非常出色。有关这些优秀工具的信息链接，请参阅*另请参阅*部分。
- en: Besides the run-of-the-mill MITM attacks, there are classes of MITM attacks
    specific to Android, namely, those targeting applications that use an unsecured
    `addJavaScriptInterface` WebKit and related API calls. For more on this vulnerability,
    see the links to the *Adventures with Android WebViews* article and the *Attacks
    on WebView in the Android System* in the *See also* section.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通的MITM攻击之外，还有一些特定于Android的MITM攻击类别，即针对那些使用未加密的`addJavaScriptInterface` WebKit和相关API调用的应用程序。关于这个漏洞的更多信息，请参阅*Android
    WebView的冒险*文章和*Android系统中的WebView攻击*的链接，在*另请参阅*部分。
- en: See also
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Attacks on WebView in the Android System* paper by Tongbo Luo, Hao Hao,
    Wenliang Yifei Wang, and Heng Yin ([http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf](http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf))
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tongbo Luo, Hao Hao, Wenliang Yifei Wang和Heng Yin的*Android系统中的WebView攻击*论文（[http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf](http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf)）
- en: The *WebView addJavaScriptInterface Remote Code Execution* paper at MWR InfoSecurity
    ([https://labs.mwrinfosecurity.com/system/assets/563/original/mwri_webview-addjavascriptinterface-code-execution_2013-09-23.pdf](https://labs.mwrinfosecurity.com/system/assets/563/original/mwri_webview-addjavascriptinterface-code-execution_2013-09-23.pdf))
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MWR InfoSecurity的*WebView addJavaScriptInterface 远程代码执行*论文（[https://labs.mwrinfosecurity.com/system/assets/563/original/mwri_webview-addjavascriptinterface-code-execution_2013-09-23.pdf](https://labs.mwrinfosecurity.com/system/assets/563/original/mwri_webview-addjavascriptinterface-code-execution_2013-09-23.pdf)）
- en: The *Adventures with Android WebViews* article at MWR labs ([https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/](https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/))
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MWR实验室的《*Android WebViews的冒险之旅*》文章 ([https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/](https://labs.mwrinfosecurity.com/blog/2012/04/23/adventures-with-android-webviews/))
- en: Ettercap Windows Binaries ([http://sourceforge.net/projects/ettercap/files/unofficial%20binaries/windows/](http://sourceforge.net/projects/ettercap/files/unofficial%20binaries/windows/))
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ettercap的Windows二进制文件 ([http://sourceforge.net/projects/ettercap/files/unofficial%20binaries/windows/](http://sourceforge.net/projects/ettercap/files/unofficial%20binaries/windows/))
- en: The Ettercap homepage ([http://ettercap.github.io/ettercap/index.html](http://ettercap.github.io/ettercap/index.html))
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ettercap的官方网站 ([http://ettercap.github.io/ettercap/index.html](http://ettercap.github.io/ettercap/index.html))
- en: The *Metasploit Browser Autopwn* article at Penetration Testing Lab ([http://pentestlab.wordpress.com/2012/04/23/metasploit-browser-autopwn/](http://pentestlab.wordpress.com/2012/04/23/metasploit-browser-autopwn/))
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Penetration Testing Lab的《*Metasploit浏览器Autopwn*》文章 ([http://pentestlab.wordpress.com/2012/04/23/metasploit-browser-autopwn/](http://pentestlab.wordpress.com/2012/04/23/metasploit-browser-autopwn/))
- en: The Cain and Abel homepage ([http://www.oxid.it/cain.html](http://www.oxid.it/cain.html))
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cain和Abel的官方网站 ([http://www.oxid.it/cain.html](http://www.oxid.it/cain.html))
- en: An Ethernet Address Resolution Protocol, Internet Standard STD 37 ([http://tools.ietf.org/html/rfc826](http://tools.ietf.org/html/rfc826))
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网地址解析协议，互联网标准STD 37 ([http://tools.ietf.org/html/rfc826](http://tools.ietf.org/html/rfc826))
