- en: Chapter 10. Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have looked closely at many of the most significant
    creational and structural design patterns. This has given us the power to construct
    all manner of architectures, but to perform the tasks we require, these structures
    need to be able to communicate, between their own elements and with other structures.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns were designed for modeling many of the general development
    problems we encounter on a regular basis, such as responding to a change in state
    of a particular object or adapting behavior to accord with a hardware change.
    We have already encountered one, in the last chapter with the observer, and here
    we will look further into some of the most useful behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns are far more adaptable in terms of the variety of tasks
    they can perform than creational and behavioral patterns, and although this flexibility
    is great, it can also complicate matters when it comes to selecting the best possible
    pattern, as there will often be two or three possible candidates for a given task.
    It is a good idea to take a look at several of these patterns together and see
    how understanding these sometimes subtle differences can help us apply behavioral
    patterns efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add specialization layers to the pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply a strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and use a visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a state machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generalized nature of these patterns means they can be applied in a huge
    number of various situations, but a good example of the type of task they can
    perform would be a click or touch listener and of course, the observer patterns
    of the previous chapter. Another common feature seen in many behavioral patterns
    is the use of abstract classes to create generalized algorithms, as we will see
    later in the chapter with the **visitor** and **strategy patterns** and in particular
    the **template pattern**, which we shall explore now.
  prefs: []
  type: TYPE_NORMAL
- en: The template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you are entirely new to design patterns, you will be familiar with how
    the template pattern works, as it employs abstract classes and methods to form
    a generalized (template) solution that can be used to create specialized subclasses
    in precisely the way that abstraction is intended to be used in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: At its very simplest, the template pattern is nothing more than a generalization
    in the form of an abstract class with at least one concrete realization. For example,
    a template might define an empty layout and its realizations then control the
    content. One big advantage of this approach is that common elements and shared
    logic need only be defined in the base class, meaning that we only need to write
    code where our realizations differ from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Template patterns can become even more powerful and flexible if another layer
    of abstraction is added in the form of specializations of the base class. These
    can then be used as sub-categories of their parent classes and treated similarly.
    Before exploring these multi-layered patterns, we will take a look at the simplest
    example of a base template that provides the properties and logic to produce different
    outputs in accordance with their concrete realizations.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, template patterns work on an algorithm or any set of procedures
    that can be broken down into steps. This template method is defined in the base
    class and made specific with realizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to see this is by way of example. Here we will imagine a simple
    news feed app with a generalized *story* template with *news* and *sport* realizations.
    Follow these steps to create this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project and create a main layout based on the following component
    tree:![The template pattern](img/image_10_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new abstract class called `Story`, as our generalization, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, extend this to create the `News` class, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Sport` realization is the same, but with the following exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add these lines to the main activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this code on a real or virtual device allows us to toggle between the
    two realizations of our `Story` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The template pattern](img/image_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This template example is nice and simple and familiar but nevertheless the
    template can be applied in numerous situations and provides a very convenient
    method to organize code, in particular when there are many derived classes to
    be defined. The class diagram is as straightforward as the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The template pattern](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extending templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous pattern is very useful when the individual realizations are very
    similar to each other, but there are often cases when we want to model objects
    that are similar enough to each other to warrant shared code but nevertheless
    possess different types or number of properties. A good example might be a database
    for a reading library. We could create a base class called *ReadingMaterial* and
    with the right properties, this could be used to cover almost any book, regardless
    of genre or content or age. If, however, we wanted to include magazines and periodicals,
    we might find our model failing to represent the multiple nature of such periodicals.
    In this situation, we could create an entirely new base class or alternatively
    create new and specialized abstract classes that extend the base class but are
    also extendable themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this above example to demonstrate this, more functional, template
    pattern. This model now has three layers, generalizations, specializations, and
    realizations. As it is the structure of the pattern that matters here, we will
    save time and use the debugger to output our realized objects. To see how this
    would be put in practice, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating an abstract, base class, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, another abstract class for the book category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Magazine` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create the concrete realization classes. First the book class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Followed by the magazine class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a POJO to use as dummy data, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This pattern can now be tested with code like the following in the main activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By changing the dummy document code, any realization can be tested, and will
    produce output along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example is short and simple, but it demonstrates each of the features
    that make the pattern so useful and versatile, as detailed in this list:'
  prefs: []
  type: TYPE_NORMAL
- en: Base classes provide standardized skeleton definitions and code, as demonstrated
    by the `fetchDocument()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that realizations have in common is defined in base classes, for example
    `title()` and `genre()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placeholders are defined in base classes for specialized implementations, as
    seen by the way `date()` is managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived classes can override placeholder methods and implemented methods; see
    `rating()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived classes can call back to base classes with `super`, as seen with the
    `fetchDocument()` method in the `Book` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the template pattern may seem complex at first, the fact that so many
    elements are shared, means that well thought out generalizations and specializations
    can lead to very simple and clear code in the concrete classes themselves, something
    we will be grateful for when dealing with more than just one or two template realizations.
    This concentration of code defined in the abstract classes can be seen very clearly
    in the pattern''s class diagram, where the derived classes contain only the code
    that pertains to it alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending templates](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned at the top of the chapter, there are often more than one behavioral
    pattern that can be used in a given situation and the template pattern we discussed
    previously, along with the strategy, visitor, and state patterns, all fit into
    this category, as all of them derive specialized cases from generalized outlines.
    Each of these patterns deserves exploring in a little detail.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern is very similar to the template pattern, the only difference
    really being the point at which individual realizations are created. This happens
    during compilation with a template pattern, but during runtime in a strategy pattern,
    and can be selected dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'A strategy pattern reflects changes as they happen and its output depends on
    a context in the same way the output of a weather app depends on a location. We
    can use this scenario in our demonstration, but first consider this class diagram
    of a strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The strategy pattern](img/image_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can easily be realized using the weather example. Open a new project and
    follow these steps to see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with strategy interface; it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create several concrete implementations along the lines of the class here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the context class, which here is the location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By mocking up the location with a string value, we can test the pattern with
    client code like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As this example demonstrates, strategy patterns, although similar to templates,
    are used for different tasks as they are applied at different occasions, runtime
    and compile time respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As well as applying our own templates and strategies, most platforms apply their
    own as part of the system. A good example of a strategy pattern at work in the
    Android framework can be seen every time a device is rotated and templates are
    applied to install layouts for different devices. We will take a closer look at
    this shortly, but first there are two other patterns we need to examine.
  prefs: []
  type: TYPE_NORMAL
- en: The visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the template and strategy patterns, the visitor pattern is flexible
    enough to perform any of the tasks we have so far considered, and as with other
    behavioral patterns, the trick lies in applying the right pattern to the right
    problem. The term *visitor* is perhaps not as self-explanatory as *template* or
    *strategy*.
  prefs: []
  type: TYPE_NORMAL
- en: The visitor pattern is designed so that a client can apply a process to a collection
    of unrelated objects, without having to worry about their differences. A good
    real-world example would be a trip to a supermarket where we might buy tinned
    products that have a bar code that can be scanned as well as fresh items that
    need to be weighed. This difference need not concern us in a supermarket as the
    cashier will take care of all this for us. In this case, the cashier is acting
    as the visitor, making all the necessary decisions regarding how to process individual
    items, leaving us (the client) only having to consider the final bill.
  prefs: []
  type: TYPE_NORMAL
- en: This does not really accord with our intuitive understanding of the word *visitor*,
    but from a design pattern point of view this is what it means. Another real-world
    example would be if we wished to travel across town. In this example, we might
    choose between a taxi or a bus. In both cases, we only concern ourselves with
    the final destination (and perhaps the cost) leaving the driver/visitor to negotiate
    the details of the actual route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to see how a visitor pattern can be implemented to model
    the supermarket scenario outlined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new Android project and add the following interface to define shopping
    items, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create two item examples. First one for canned foods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the fresh foods item class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can add the visitor interface itself, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can then be implemented as the following `Checkout` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now see how the pattern allows us to write clean client code, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should then produce an output like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The visitor pattern has two particular strengths. The first is that it saves
    us having to use convoluted conditional nesting to differentiate between item
    types. The second, more significant, strength lies in how visitor and visited
    are kept separate, meaning that new item types can be added and altered without
    making any changes to the client at all. To see how this is done, just add the
    following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open and edit the `Visitor` interface so that it has the extra line highlighted
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `SpecialOffer` class, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Overload the `visit()` method in the `Checkout` visitor class like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As this demonstrates, the visitor pattern can be extended to manage any number
    of items and any number of different solutions. Visitors can be used one at a
    time, or as part of a chain of processes, and are often used when importing files
    with different formats.
  prefs: []
  type: TYPE_NORMAL
- en: All the behavioral patterns we have looked at in this chapter have a very wide
    scope and can be used to solve an enormous variety of software design problems.
    There is one pattern, however, that has a wider scope even than these, the state
    design pattern or machine.
  prefs: []
  type: TYPE_NORMAL
- en: The state pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state pattern is without doubt the most flexible of all the behavioral patterns.
    The pattern demonstrates how we can implement **finite state machines** in our
    code. State machines were an invention of the mathematician Alan Turing, who used
    them to realize all-purpose computers and prove that any mathematically computable
    process can be performed mechanically. In short, state machines can be used to
    perform any task we choose.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics of the state design pattern are simple and elegant. At any point
    in the life-cycle of a finite state machine, the pattern is aware of its own internal
    state and the current external state, or input. Based on these two properties,
    the machine will then produce an output (which can be none) and change its own
    internal state (which can be the same). Believe it or not, very sophisticated
    algorithms can be realized with properly configured finite state machines.
  prefs: []
  type: TYPE_NORMAL
- en: A traditional way of demonstrating the state pattern is with the example of
    a coin operated turnstile of the type that might be found at a sports stadium
    or funfair. This has two possible states, locked and unlocked, and takes two forms
    of input, a coin and a physical push.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this can be modeled, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Android project and build a layout along the lines of the one here:![The
    state pattern](img/image_10_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next comes the `Locked` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Followed by the `Unlocked` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following singleton to hold the output string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next add the `Context` class, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally edit the main activity to match this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This example may be simple, but it demonstrates perfectly just how powerful
    this pattern is. It is easy to see how the same scheme could be expanded to model
    more complex locking systems, and finite state machines are often used to implement
    combination locks. As mentioned earlier, the state pattern can be used to model
    anything that can be mathematically modeled. The previous example is easily tested
    and easy to expand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The state pattern](img/image_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The true beauty of the state pattern lays in not just how incredibly flexible
    it is, but also how conceptually simple it is, and this can be seen most clearly
    with a class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The state pattern](img/image_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: State patterns, like all the patterns in this chapter and other behavioral patterns,
    are remarkably flexible and this ability to adapted to suit an enormous number
    of situations is down to their abstract nature. This can make behavioral patterns
    conceptually more difficult to grasp, but a little trial and error is a good way
    to find the right patterns for the right situations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral patterns can appear very similar in structure and there is a lot
    of functional overlap, and this chapter has been largely theoretical so that we
    could approach them collectively. Once we become familiar with these structures,
    we will find ourselves returning to them frequently and in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will concentrate on more technical matters and see how
    to develop apps for the wide variety of form factors available, such as wrist
    watches and TV screens. From the work we have done so far, we can see how patterns
    such as the visitor could be used to manage such choices. As we have already experienced,
    the system manages much of this for us, often using inbuilt patterns of its own.
    Nevertheless, there are many opportunities to simplify and rationalize our code
    with design patterns.
  prefs: []
  type: TYPE_NORMAL
