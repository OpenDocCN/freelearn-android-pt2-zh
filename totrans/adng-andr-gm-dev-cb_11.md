# 附录 A. MagneTank 的源代码

本章为游戏**MagneTank**中使用的所有类别提供了简短的描述和参考资料。MagneTank 可在谷歌 Play 商店([`play.google.com/store/apps/details?id=ifl.games.MagneTank`](http://play.google.com/store/apps/details?id=ifl.games.MagneTank))上找到，以前称为**Android Market**，本书代码捆绑包中可以找到源代码。游戏玩法包括通过触摸炮塔应该指向的位置来瞄准坦克的炮塔，并在同一位置轻敲以发射炮塔。为了展示物理启用的车辆，可以通过首先触摸坦克，然后向所需方向滑动，将坦克拉到左侧或右侧。

游戏的类别分布在以下主题中：

+   游戏关卡类别

+   输入类别

+   图层类别

+   管理类别

+   菜单类别

+   活动和引擎类别

以下图片是 MagneTank 第二关的游戏内截图：

![MagneTank 的源代码](img/8987OS_11_01.jpg)

# 游戏关卡类别

这些类别出现在游戏的可玩部分：

## ManagedGameScene.java

MagneTank 的`ManagedGameScene`类别在第五章，*场景和图层管理*中呈现的`ManagedGameScene`类别的基础上，通过添加分步加载屏幕来显示每个关卡加载的内容。使用加载步骤背后的想法与在加载游戏之前显示一帧加载屏幕类似，就像`SceneManager`类别在显示新场景时的功能一样，但是加载屏幕会在每个加载步骤更新，而不仅仅是第一次显示加载屏幕时更新一次。

这个类别基于以下配方：

+   在第二章，*使用实体*中*将文本应用于图层*

+   在第五章，*场景和图层管理*中*创建场景管理器*

+   在第七章，*使用更新处理器*中*更新处理器是什么？*

## GameLevel.java

`GameLevel`类别将所有其他游戏内类别汇集在一起，形成了 MagneTank 的可玩部分。它处理每个实际游戏关卡的构建和执行。它扩展了一个自定义的`ManagedGameScene`类别，该类别包含一系列`LoadingRunnable`对象，这些对象分步骤创建关卡，允许关卡构建的每个进度在屏幕上显示。`GameLevel`类别还使用`GameManager`类别来确定每个游戏关卡的完成或失败，以测试胜利或失败条件。

这个类别基于以下配方：

+   在第二章，*使用实体*中*了解 AndEngine 实体*

+   在第二章中，*处理实体*一节讲述了*使用精灵使场景生动*。

+   在第二章中，*处理实体*一节介绍了*给图层应用文本*。

+   在第二章中，*处理实体*一节介绍了*重写 onManagedUpdate 方法*。

+   在第二章中，*处理实体*一节讲解了*使用修改器和实体修改器*。

+   在第三章中，*设计你的菜单*一节解释了*使用视差背景创造透视感*。

+   在第四章中，*处理相机*一节引入了*相机对象*。

+   在第四章中，*处理相机*一节通过*使用边界相机限制相机区域*进行了说明。

+   在第四章中，*处理相机*一节通过*使用缩放相机近距离观察*进行了阐述。

+   在第四章中，*处理相机*一节介绍了*给相机应用 HUD*。

+   在第五章中，*场景和图层管理*一节讲述了*自定义管理和图层*。

+   在第六章中，*应用物理*一节介绍了 Box2D 物理扩展的*入门知识*。

+   在第七章中，*处理更新处理器*一节解释了*更新处理器是什么*。

+   在第八章中，*最大化性能*一节讲解了*创建精灵池*。

## LoadingRunnable.java

`LoadingRunnable`类在作为`Runnable`对象的同时，也会在`ManagedGameScene`类中更新加载屏幕。每个`ManagedGameScene`类中都存在一个`LoadingRunnable`对象的`ArrayList`类型，以便开发者可以控制玩家看到的加载进度。需要注意的是，虽然在 MagneTank 中更新加载屏幕不会占用太多处理器资源，但更复杂、图形复杂的加载屏幕可能会大大增加每个关卡的加载时间。

## Levels.java

`Levels`类保存了游戏中可以玩的所有关卡数组，以及帮助获取特定关卡的辅助方法。

## BouncingPowerBar.java

`BouncingPowerBar`类向玩家显示一个弹跳指示器，指示每次从车辆射击的威力大小。它将指示器的可见位置转换为一个分数值，然后应用一个立方曲线，使得在尝试实现最强大射击时更具挑战性。以下图片展示了由三张独立图片构建完成后的力量条的样子：

![BouncingPowerBar.java](img/8987OS_11_02.jpg)

`BouncingPowerBar`类的实现基于以下方法：

+   在第二章的*处理实体*中*理解 AndEngine 实体*

+   在第二章的*处理实体*中*使用精灵为场景注入生命*

+   在第二章的*处理实体*中*重写 onManagedUpdate 方法*

+   在第二章的*处理实体*中*将 HUD 应用到相机上*

## MagneTank.java

`MagneTank`类创建并控制游戏基于的车辆。它使用关节将 Box2D 刚体组合起来，创建具有物理效果的车辆，并通过`BoundTouchInputs`获取玩家输入，控制车辆每个部分的运动和功能。以下图片展示了 MagneTank 构建前后的样子：

![MagneTank.java](img/8987OS_11_03.jpg)

`MagneTank`类基于以下配方：

+   在第二章的*处理实体*中*理解 AndEngine 实体*

+   在第二章的*处理实体*中*使用精灵为场景注入生命*

+   在第二章的*处理实体*中*使用相对旋转*

+   在第二章的*处理实体*中*重写 onManagedUpdate 方法*

+   在第四章的*处理相机*中*使用边界相机限制摄像机区域*

+   在第六章的*物理应用*中*介绍 Box2D 物理扩展*

+   在第六章的*物理应用*中*理解不同的刚体类型*

+   在第六章的*物理应用*中*通过指定顶点创建独特的刚体*

+   在第六章的*物理应用*中*使用力、速度和扭矩*

+   在第六章的*物理应用*中*处理关节工作*

+   在第七章的*处理更新处理器*中*更新处理器是什么？*

+   在第十章的*深入了解 AndEngine*中*应用基于精灵的阴影*

## MagneticCrate.java

`MagneticCrate`类扩展了`MagneticPhysObject`类。它创建并处理了 MagneTank 车辆可发射的各种类型的箱子。每个箱子以平铺精灵的形式显示，平铺精灵的图像索引设置为箱子的类型。`MagneticCrate`类利用了物理世界的`ContactListener`中的 Box2D 的`postSolve()`方法。以下图片展示了游戏中可用的各种大小和类型的箱子：

![MagneticCrate.java](img/8987OS_11_04.jpg)

`MagneticCrate`类基于以下食谱：

+   *在第二章中了解 AndEngine 实体*，*使用实体*

+   *在第二章中使用精灵为场景注入生命*，*使用实体*

+   *重写第二章中的`onManagedUpdate`方法*，*使用实体*

+   *在第六章中介绍 Box2D 物理扩展*，*物理应用*

+   *在第六章中了解不同的物体类型*，*物理应用*

+   *在第六章中使用 preSolve 和 postSolve*，*物理应用*

+   *在第七章中更新处理程序是什么？*，*使用更新处理程序*

## MagneticOrb.java

`MagneticOrb`类会在 MagneTank 当前弹射体周围创建视觉效果。它让两张旋涡图像（见下图的图像）以相反的方向旋转，以产生球形力的错觉。当装填并发射弹射体时，`MagneticOrb`类会形成并逐渐消失。

![MagneticOrb.java](img/8987OS_11_05.jpg)

`MagneticOrb`类基于以下食谱：

+   *在第二章中了解 AndEngine 实体*，*使用实体*

+   *在第二章中使用精灵为场景注入生命*，*使用实体*

+   *在第二章中使用相对旋转*，*使用实体*

+   *在第二章中重写`onManagedUpdate`方法*，*使用实体*

## MagneticPhysObject.java

`MagneticPhysObject`类扩展了`PhysObject`类，允许物体被 MagneTank 车辆抓取或释放。被抓取时，物体不仅会受到反重力作用，还会受到向 MagneTank 炮塔方向拉扯物体的力。

`MagneticPhysObject`类基于以下食谱：

+   *在第六章中介绍 Box2D 物理扩展*，*物理应用*

+   *在第六章中了解不同的物体类型*，*物理应用*

+   *在第六章中使用力、速度和扭矩*，*物理应用*

+   *在第六章中将反重力应用于特定物体第六章 物理应用*

+   *在第六章中更新处理程序是什么？*，*使用更新处理程序*

## MechRat.java

`MechRat`类扩展了`PhysObject`类，以利用在与其他物理启用的对象碰撞时调用的`postSolve()`方法。如果力足够大，MechRat 就会被摧毁，并且之前加载的粒子效果会立即显示。MechRat 还有关节连接的轮子，这增加了摧毁它的挑战性。以下图片展示了 MechRat 的视觉组成：

![MechRat.java](img/8987OS_11_06.jpg)

这个类基于以下食谱：

+   *理解 AndEngine 实体*在章节 2，*处理更新处理器*

+   *使用精灵为场景注入生命*在章节 2，*处理更新处理器*

+   *重写`onManagedUpdate`方法*在章节 2，*处理更新处理器*

+   *在章节 2 中处理粒子系统*，*处理更新处理器*

+   *Box2D 物理扩展介绍*在第章节 6，*物理学的应用*

+   *理解不同的物体类型*在第章节 6，*物理学的应用*

+   *通过指定顶点创建独特的物体*在第章节 6，*物理学的应用*

+   *处理关节*在第章节 6，*物理学的应用*

+   *使用 preSolve 和 postSolve*在第章节 6，*物理学的应用*

+   *创建可破坏的物体*在第章节 6，*物理学的应用*

+   *更新处理器是什么？*在第章节 7，*使用更新处理器*

## MetalBeamDynamic.java

这个类代表了游戏中看到的非静态、物理启用的梁。由于它的重复纹理，每根梁的长度可以设置。

`MetalBeamDynamic`类基于以下食谱：

+   *理解 AndEngine 实体*在章节 2，*使用更新处理器*

+   *使用精灵为场景注入生命*在章节 2，*处理更新处理器*

+   *在章节 2 中使用相对旋转*，*使用实体*

+   *重写`onManagedUpdate`方法*在章节 2，*使用实体*

+   *Box2D 物理扩展介绍*在第章节 6，*物理学的应用*

+   *理解不同的物体类型*在第章节 6，*物理学的应用*

## MetalBeamStatic.java

与上面的`MetalBeamDynamic`类相似，这个类也代表一个桁架，但这个对象的`BodyType`选项设置为`Static`，以创建一个静止的屏障。

`MetalBeamStatic`类基于以下食谱：

+   *在第二章，*使用实体*中，了解 AndEngine 实体*

+   *在第二章，*使用实体*中，让场景通过精灵生动起来*

+   *在第二章，*使用实体*中使用相对旋转*

+   *在第六章，*物理应用*中，介绍 Box2D 物理扩展*

+   *在第六章，*物理应用*中，了解不同的身体类型*

## ParallaxLayer.java

由本书的合著者 Jay Schroeder 编写并发布的`ParallaxLayer`类，使得创建`ParallaxEntity`对象变得简单，这些对象在`Camera`对象在场景中移动时能产生深度感知。可以设置视差效果的程度，`ParallaxLayer`类负责正确渲染每个`ParallaxEntity`对象。以下图片展示了 MagneTank 的背景层，它们附着在一个`ParallaxLayer`类上：

![ParallaxLayer.java](img/8987OS_11_07.jpg)

`ParallaxLayer`类基于以下食谱：

+   *在第二章，*使用实体*中，了解 AndEngine 实体* （注意：这一行与第四行重复，根据注意事项，这里不重复翻译）

+   *在第二章，*使用实体*中，使用 OpenGL*

+   *在第二章，*使用实体*中，重写 onManagedUpdate 方法*

+   *在第三章，*设计你的菜单*中使用视差背景创造透视感*

## PhysObject.java

`PhysObject`类在 MagneTank 中用于委派从物理世界的`ContactListener`接收到的接触。它还提供了一个`destroy()`方法，使得销毁物理对象更加容易。

`PhysObject`类基于以下食谱：

+   *在第二章，*使用实体*中，了解 AndEngine 实体*

+   *在第六章，*物理应用*中，介绍 Box2D 物理扩展*

+   *在第六章，*物理应用*中，了解不同的身体类型*

+   *在第六章，*物理应用*中使用 preSolve 和 postSolve*

+   *更新处理程序是什么？* 在第七章，*使用更新处理程序*

## RemainingCratesBar.java

`RemainingCratesBar` 类为玩家提供了视觉表示，显示还有哪些箱子需要被 MagneTank 射击。每个级别剩余的箱子的大小、类型和数量从 `GameLevel` 类中获取，并且会从一级到另一级发生变化。当一个箱子被击中时，`RemainingCratesBar` 类会动画化以反映游戏状态的变化。

这个类基于以下食谱：

+   第二章中的*理解 AndEngine 实体*，*使用实体*

+   第二章中的*使用精灵为场景注入生命*，*使用实体*

+   第二章中的*使用 OpenGL*，*使用实体*

+   第二章中的*覆盖 onManagedUpdate 方法*，*使用实体*

+   第二章中的*使用修改器和实体修改器*，*使用实体*

## TexturedBezierLandscape.java

`TexturedBezierLandscape` 类创建了两个纹理网格和一个物理体，代表关卡的地面。顾名思义，该景观由贝塞尔曲线组成，以展示上升或下降的斜坡。纹理网格由重复的纹理制成，以避免景观区域之间的可见缝隙。以下图片展示了创建景观所使用的两种纹理以及应用贝塞尔斜坡后组合网格的外观示例：

![TexturedBezierLandscape.java](img/8987OS_11_08.jpg)

`TexturedBezierLandscape` 类基于以下食谱：

+   第二章中的*理解 AndEngine 实体*，*使用实体*

+   第二章中的*使用 OpenGL*，*使用实体*

+   第六章中的*Box2D 物理扩展介绍*，*物理应用*

+   第六章中的*理解不同的物体类型*，*物理应用*

+   第六章中的*通过指定顶点创建独特的物体*，*物理应用*

+   第十章中的*纹理网格*，*深入了解 AndEngine*

## TexturedMesh.java

这个类与第十章中*纹理网格*的食谱中找到的 `TexturedMesh` 类相同。

## WoodenBeamDynamic.java

这个类与 `MetalBeam` 类相似，但增加了一个健康方面，一旦其健康值达到零，就会用粒子效果替换 `WoodenBeamDynamic` 类。

`WoodenBeamDynamic` 类基于以下食谱：

+   在第二章，*处理实体*中*理解 AndEngine 实体*（注意：这里原文重复，根据注意事项，译文不应重复）

+   在第二章，*处理实体*中*使用精灵为场景注入生命*

+   在第二章，*处理实体*中*使用相对旋转*

+   在第二章，*处理实体*中*覆盖 onManagedUpdate 方法*

+   在第二章，*处理实体*中*使用粒子系统*

+   在第六章，*物理应用*中*Box2D 物理扩展介绍*

+   在第六章，*物理应用*中*理解不同的身体类型*

+   在第六章，*物理应用*中*使用 preSolve 和 postSolve*

+   在第七章，*使用更新处理器*中*更新处理器是什么？*

# 输入类

这些类中的每一个都处理游戏中使用的特定输入方法：

## BoundTouchInput.java

`BoundTouchInput` 类便于输入的委托，然后这些输入绑定到 `BoundTouchInput` 类。这可以在游戏中轻松看到，例如移动 MagneTank 以瞄准炮塔时。当触摸进入另一个可触摸区域时，它仍保持与原始区域的绑定。

## GrowButton.java

`GrowButton` 类仅显示一个图像，当玩家触摸它时，它会增长到特定的比例，并在触摸抬起或丢失时恢复到原始比例。

本类基于以下食谱：

+   在第二章，*处理实体*中*理解 AndEngine 实体*

+   在第二章，*处理实体*中*使用精灵为场景注入生命*

+   在第二章，*处理实体*中*覆盖 onManagedUpdate 方法*

+   在第二章，*处理实体*中*使用修改器和实体修改器*

## GrowToggleButton.java

本类基于 `GrowButton` 类，并增加了根据条件状态显示一个或两个 `TiledTextureRegion` 索引的功能。

`GrowToggleButton` 类基于以下食谱：

+   在第二章，*处理实体*中*理解 AndEngine 实体*

+   在第二章，*处理实体*中*使用精灵为场景注入生命*

+   在第二章，*处理实体*中*覆盖 onManagedUpdate 方法*

+   在第二章，*处理实体*中*使用修改器和实体修改器*

## GrowToggleTextButton.java

基于`GrowToggleButton`类，这个类使用`Text`对象而不是`TiledTextureRegion`对象来显示条件的状态。

`GrowToggleTextButton`类基于以下配方：

+   在第二章，*处理实体*中*理解 AndEngine 实体*

+   在第二章，*处理实体*中*使用精灵让场景生动起来*

+   在第二章，*处理实体*中*将文本应用到层上*

+   在第二章，*处理实体*中*覆盖 onManagedUpdate 方法*

+   在第二章，*处理实体*中*使用修饰符和实体修饰符*

# 层类

这些类表示游戏内存在的层：

## LevelPauseLayer.java

`LevelPauseLayer`类表示当关卡暂停时显示给玩家的层。它显示当前的关卡号码、分数和最高分，以及返回游戏、返回关卡选择屏幕、重新开始关卡或跳转到下一关卡的按钮。

这个类基于以下配方：

+   在第二章，*处理实体*中*理解 AndEngine 实体*

+   在第二章，*处理实体*中*使用精灵让场景生动起来*

+   在第二章，*处理实体*中*将文本应用到层上*

+   在第五章，*场景和层管理*中*自定义管理场景和层*

+   在第七章，*处理更新处理器*中*更新处理器是什么？*

## LevelWonLayer.java

`LevelWonLayer`类表示当玩家成功完成一个关卡时显示给玩家的层。它显示当前的关卡号码、分数和最高分，以及玩家获得的星级评价。还包括返回关卡选择屏幕、重玩关卡或进入下一关卡的按钮。以下图片展示了`LevelWonLayer`类的纹理以及它们在游戏中组合起来的样子：

![LevelWonLayer.java](img/8987OS_11_09.jpg)

`LevelWonLayer`类基于以下配方：

+   在第二章，*处理实体*中*理解 AndEngine 实体*

+   在第二章，*处理实体*中*使用精灵让场景生动起来*

+   在第二章，*处理实体*中*将文本应用到层上*

+   在第二章，*处理实体*中*使用修饰符和实体修饰符*

+   *在第五章中自定义管理场景和图层*，*场景和图层管理*

+   *第七章中的更新处理器是什么？*，*使用更新处理器*

## ManagedLayer.java

这个类与在第五章中*创建场景管理器*的食谱中找到的`ManagedLayer`类是相同的，*场景和图层管理*。

## OptionsLayer.java

这个图层可以从`MainMenu`场景访问，允许玩家启用或禁用音乐和声音，以及选择图形质量或重置他们已完成的关卡完成数据。

`OptionsLayer`类基于以下食谱：

+   *在第二章中了解 AndEngine 实体*，*使用实体*

+   *在第二章中使用精灵使场景生动*，*使用实体*

+   *在第二章中将文本应用于图层*，*使用实体*

+   *在第五章中自定义管理场景和图层*，*场景和图层管理*

+   *第七章中的更新处理器是什么？*，*使用更新处理器*

# 管理类

这些类各自管理游戏的一个特定方面：

## GameManager.java

`GameManager`类简单地为检查两个条件以确定一个关卡是否完成或失败提供便利。使用该信息，游戏管理器随后调用在`GameLevel`类中设置的正确方法。

这个类基于以下食谱：

+   *在第一章中创建游戏管理器*，*AndEngine 游戏结构*

+   *第七章中的更新处理器是什么？*，*使用更新处理器*

## ResourceManager.java

`ResourceManager`类与在第一章中找到的类非常相似，*AndEngine 游戏结构*，但它增加了如果需要可以使用一组低质量纹理的能力。它还包括用于确定精确字体纹理大小的方法，以防止浪费宝贵的纹理内存。

这个类基于以下食谱：

+   *在第一章中应用纹理选项*，*AndEngine 游戏结构*

+   *在第一章中使用 AndEngine 字体资源*，*AndEngine 游戏结构*

+   *在第一章中创建资源管理器*，*AndEngine 游戏结构*

+   *在第二章中*使用 OpenGL*，*使用实体*

+   在第五章的*场景和图层管理*部分，设置场景资源的资源管理器*《为场景资源设置资源管理器》*

## `SceneManager.java`

这个类与第五章中的*创建场景管理器*食谱中的`SceneManager`类完全相同*《场景和图层管理》*

## `SFXManager.java`

这个简单的类处理音乐和声音的播放以及它们的静音状态。

`SFXManager`类基于以下食谱：

+   在第一章的*AndEngine 游戏结构*部分，介绍声音和音乐*《介绍声音和音乐》*

# 菜单类

这些类仅用于游戏中的菜单。

## `LevelSelector.java`

这个类与第三章中的菜单设计中的关卡选择器类似，但使用一系列`LevelSelectorButton`对象代替了精灵*《设计你的菜单》*

这个类基于以下食谱：

+   在第二章的*使用实体工作*部分，了解`AndEngine`实体*《了解 AndEngine 实体》*

+   在第二章的*使用实体工作*部分，*《使用精灵使场景生动》*

+   在第三章的*设计你的菜单*部分，创建我们的关卡选择系统*《创建我们的关卡选择系统》*

## `LevelSelectorButton.java`

`LevelSelectorButton`类通过视觉向玩家展示一个关卡的当前状态，是锁定还是解锁，如果关卡已解锁，还会显示获得的星星数量。

这个类基于以下食谱：

+   在第二章的*使用实体工作*部分，了解`AndEngine`实体*《了解 AndEngine 实体》*

+   在第二章的*使用实体工作*部分，*《使用精灵使场景生动》*

+   在第二章的*使用实体工作*部分，将文本应用到图层*《将文本应用到图层》*

+   在第二章的*使用实体工作*部分，覆盖`onManagedUpdate`方法*《覆盖 onManagedUpdate 方法》*

+   在第二章的*使用实体工作*部分，使用修改器和实体修改器*《使用修改器和实体修改器》*

## `MainMenu.java`

`MainMenu`类包含两个`Entity`对象，一个代表标题屏幕，另一个代表关卡选择屏幕。两个屏幕之间的切换是通过实体修改器实现的。在首次显示主菜单时，会显示加载屏幕，同时加载游戏的资源。

`MainMenu`类基于以下食谱：

+   在第二章的*使用实体工作*部分，了解`AndEngine`实体*《了解 AndEngine 实体》*

+   在第二章的*使用实体工作*部分，介绍如何通过精灵使场景生动*《使用精灵使场景生动》*

+   在第二章的*使用实体工作*部分，覆盖`onManagedUpdate`方法*《覆盖 onManagedUpdate 方法》*

+   在第二章，*处理实体*中*使用修改器和实体修改器*。

+   在第五章，*场景和图层管理*中*自定义管理场景和图层*。

## ManagedMenuScene.java

这个类与第五章，*场景和图层管理*中*创建场景管理器*食谱中呈现的`ManagedMenuScene`类相同。

## ManagedSplashScreen.java

这个类基于第五章*场景和图层管理*中*自定义管理场景和图层*食谱中找到的`ManagedMenuScene`类。它添加了代码，在隐藏启动画面后卸载`Entity`对象。

## SplashScreens.java

`SplashScreen`类使用实体修改器和与分辨率无关的定位来显示游戏的启动画面。每个标志都是可点击的，并启动与标志相关的意图。

这个类基于以下食谱：

+   在第二章，*处理实体*中*使用精灵让场景生动*。

+   在第二章，*处理实体*中*将文本应用到图层*。

+   在第二章，*处理实体*中*使用修改器和实体修改器*。

+   在第五章，*场景和图层管理*中*自定义管理场景和图层*。

+   在第七章，*处理更新处理器*中*更新处理器是什么？*。

## 活动和引擎类

这些类是游戏的核心。

## MagneTankActivity.java

这个活动类基于标准的 AndEngine `BaseGameActivity`类，通过在`onCreateEngineOptions()`方法中添加广告和一些高级分辨率缩放以及共享首选项方法来保存和恢复选项和分数。

这个类基于以下食谱：

+   在第一章，*AndEngine 游戏结构*中*了解生命周期*。

+   在第一章，*AndEngine 游戏结构*中*选择我们的引擎类型*。

+   在第一章，*AndEngine 游戏结构*中*保存和加载游戏数据*。

+   在第五章，*场景和图层管理*中*设置活动以使用场景管理器*。

## MagneTankSmoothCamera.java

这个类扩展了`SmoothCamera`对象，但包括在指定时间内平移到敌方基地以及跟踪`MagneTank`对象的能力。

这个类基于以下食谱：

+   在第四章，*使用相机*中*介绍相机对象*。

+   在第四章的*使用平滑摄像头创建平滑移动*部分，*使用摄像头*

+   在第七章的*什么是更新处理器？*部分，*使用更新处理器*

## ManagedScene.java

这个类与第五章中*创建场景管理器*一节中介绍的是同一个`ManagedScene`类，*场景和图层管理*

## SwitchableFixedStepEngine.java

当调用了`EnableFixedStep()`方法时，这个`Engine`对象的行为与`FixedStepEngine`对象完全一样。

这个类基于以下食谱：

+   在第一章的*选择我们的引擎类型*部分，*AndEngine 游戏结构*

+   在第七章的*什么是更新处理器？*部分，*使用更新处理器*
