["```kt\n# dmesg | grep –i selinux\n<6>SELinux: Initializing.\n<7>SELinux: Starting in permissive mode\n<7>SELinux: Registering netfilter hooks\n<3>SELinux: policydb version 26 does not match my version range 15-23\n...\n\n```", "```kt\nint main(int argc, char *argv[]) {\n...\n  process_kernel_cmdline();\n  unionselinux_callback cb;\n  cb.func_log = klog_write;\n  selinux_set_callback(SELINUX_CB_LOG, cb);\n\n  cb.func_audit = audit_callback;\n  selinux_set_callback(SELINUX_CB_AUDIT, cb);\n\n  INFO(\"loading selinux policy\\n\");\n  if (selinux_enabled) {\n    if (selinux_android_load_policy() < 0) {\n      selinux_enabled = 0;\n      INFO(\"SELinux: Disabled due to failed policy load\\n\");\n    } else {\n      selinux_init_all_handles();\n    }\n  } else {\n    INFO(\"SELinux:  Disabled by command line option\\n\");\n  }\n…\n```", "```kt\n# mount | grep selinuxfs \nselinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0\n\n```", "```kt\nint selinux_android_load_policy(void)\n{\n  char *mnt = SELINUXMNT;\n  int rc;\n  rc = mount(SELINUXFS, mnt, SELINUXFS, 0, NULL);\n  if (rc < 0) {\n    if (errno == ENODEV) {\n      /* SELinux not enabled in kernel */\n      return -1;\n    }\n    if (errno == ENOENT) {\n      /* Fall back to legacy mountpoint. */\n      mnt = OLDSELINUXMNT;\n      rc = mkdir(mnt, 0755);\n      if (rc == -1 && errno != EEXIST) {\n        selinux_log(SELINUX_ERROR,\"SELinux: Could not mkdir:  %s\\n\",\n        strerror(errno));\n        return -1;\n      }\n      rc = mount(SELINUXFS, mnt, SELINUXFS, 0, NULL);\n    }\n  }\n  if (rc < 0) {\n    selinux_log(SELINUX_ERROR,\"SELinux:  Could not mount selinuxfs:  %s\\n\",\n    strerror(errno));\n    return -1;\n  }\n  set_selinuxmnt(mnt);\n\n  return selinux_android_reload_policy();\n}\n```", "```kt\nStatic const char *const sepolicy_file[] = {\n  \"/data/security/current/sepolicy\",\n  \"/sepolicy\",\n  0 };\n```", "```kt\nint selinux_android_reload_policy(void)\n{\n  int fd = -1, rc;\n  struct stat sb;\n  void *map = NULL;\n  int i = 0;\n\n  while (fd < 0 && sepolicy_file[i]) {\n    fd = open(sepolicy_file[i], O_RDONLY | O_NOFOLLOW);\n    i++;\n  }\n  if (fd < 0) {\n    selinux_log(SELINUX_ERROR, \"SELinux:  Could not open sepolicy:  %s\\n\",\n    strerror(errno));\n    return -1;\n  }\n  if (fstat(fd, &sb) < 0) {\n    selinux_log(SELINUX_ERROR, \"SELinux:  Could not stat %s:  %s\\n\",\n    sepolicy_file[i], strerror(errno));\n    close(fd);\n    return -1;\n  }\n  map = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n  if (map == MAP_FAILED) {\n    selinux_log(SELINUX_ERROR, \"SELinux:  Could not map %s:  %s\\n\",\n    sepolicy_file[i], strerror(errno));\n    close(fd);\n    return -1;\n  }\n\n  rc = security_load_policy(map, sb.st_size);\n  if (rc < 0) {\n    selinux_log(SELINUX_ERROR, \"SELinux:  Could not load policy:  %s\\n\",\n    strerror(errno));\n    munmap(map, sb.st_size);\n    close(fd);\n    return -1;\n  }\n\n  munmap(map, sb.st_size);\n  close(fd);\n  selinux_log(SELINUX_INFO, \"SELinux: Loaded policy from %s\\n\", sepolicy_file[i]);\n\n  return 0;\n}\n```", "```kt\nint security_load_policy(void *data, size_t len)\n{\n  char path[PATH_MAX];\n  int fd, ret;\n\n  if (!selinux_mnt) {\n    errno = ENOENT;\n    return -1;\n  }\n\n  snprintf(path, sizeof path, \"%s/load\", selinux_mnt);\n  fd = open(path, O_RDWR);\n  if (fd < 0)\n  return -1;\n\n  ret = write(fd, data, len);\n  close(fd);\n  if (ret < 0)\n  return -1;\n  return 0;\n}\n```", "```kt\n...\n# Must be <= /selinux/policyvers reported by the Android kernel.\n# Must be within the compatibility range reported by checkpolicy -V.\nPOLICYVERS ?= 26\n...\n\n```", "```kt\n...\nBOARD_FLASH_BLOCK_SIZE := 4096\nTARGET_RECOVERY_UI_LIB := librecovery_ui_imx\n# SELinux Settings\nPOLICYVERS := 23\n-include device/google/gapps/gapps_config.mk\n\n```", "```kt\n$ mmm -B external/sepolicy/\n$ make –j4 bootimage 2>&1 | tee logz\n!!!!!!!!! WARNING !!!!!!!!! VERIFY BLOCK DEVICE !!!!!!!!!\n$ sudo chmod 666 /dev/sdd1\n$ dd if=$OUT/boot.img of=/dev/sdd1 bs=8192 conv=fsync\n\n```", "```kt\nout/host/linux-x86/bin/checkpolicy: writing binary representation (version 23) to out/target/product/udoo/obj/ETC/sepolicy_intermediates/sepolicy\n\n```", "```kt\n# dmesg | grep –i selinux\n<6>init: loading selinux policy\n<7>SELinux: 128 avtab hash slots, 490 rules.\n<7>SELinux: 128 avtab hash slots, 490 rules.\n<7>SELinux: 1 users, 2 roles, 274 types, 0 bools, 1 sens, 1024 cats\n<7>SELinux: 84 classes, 490 rules\n<7>SELinux: Completing initialization.\n\n```", "```kt\n# getenforce\nPermissive\n\n```"]