["```kt\n    <manifest \n       package=\"cookbook.chapter5.nativeactivityone\"\n       android:versionCode=\"1\"\n       android:versionName=\"1.0\">\n       <uses-sdk android:minSdkVersion=\"9\"/>\n       <application android:label=\"@string/app_name\"\n           android:icon=\"@drawable/ic_launcher\"\n           android:hasCode=\"true\">        \n      <activity android:name=\"android.app.NativeActivity\"\n          android:label=\"@string/app_name\"\n          android:configChanges=\"orientation|keyboardHidden\">  \n               <meta-data android:name=\"android.app.lib_name\"\n                 android:value=\"NativeActivityOne\" />\n               <intent-filter>\n                 <action android:name=\"android.intent.action.MAIN\" />\n                 <category android:name=\"android.intent.category.LAUNCHER\" />\n               </intent-filter>\n             </activity>   \n       </application>\n    </manifest>\n    ```", "```kt\n    void ANativeActivity_onCreate(ANativeActivity* activity,\n           void* savedState, size_t savedStateSize) {\n      printInfo(activity);\n      activity->callbacks->onStart = onStart;\n      activity->callbacks->onResume = onResume;\n      activity->callbacks->onSaveInstanceState = onSaveInstanceState;\n      activity->callbacks->onPause = onPause;\n      activity->callbacks->onStop = onStop;\n      activity->callbacks->onDestroy = onDestroy;\n      activity->callbacks->onWindowFocusChanged = onWindowFocusChanged;\n      activity->callbacks->onNativeWindowCreated = onNativeWindowCreated;\n      activity->callbacks->onNativeWindowResized = onNativeWindowResized;\n      activity->callbacks->onNativeWindowRedrawNeeded = onNativeWindowRedrawNeeded;\n      activity->callbacks->onNativeWindowDestroyed = onNativeWindowDestroyed;\n      activity->callbacks->onInputQueueCreated = onInputQueueCreated;\n      activity->callbacks->onInputQueueDestroyed = onInputQueueDestroyed;\n      activity->callbacks->onContentRectChanged = onContentRectChanged;\n      activity->callbacks->onConfigurationChanged = onConfigurationChanged;\n      activity->callbacks->onLowMemory = onLowMemory;\n      activity->instance = NULL;\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeActivityOne\n    LOCAL_SRC_FILES := NativeActivityOne.cpp\n    LOCAL_LDLIBS    := -landroid -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeActivityOne:I *:S\n    ```", "```kt\ntypedef struct ANativeActivity {\n   struct ANativeActivityCallbacks* callbacks;\n   JavaVM* vm;\n   JNIEnv* env;\n   jobject clazz;\n   const char* internalDataPath;\n   const char* externalDataPath;\n   int32_t sdkVersion;\n   void* instance;\n   AAssetManager* assetManager;\n} ANativeActivity;\n```", "```kt\n    <manifest \n       package=\"cookbook.chapter5.nativeactivitytwo\"\n       android:versionCode=\"1\"\n       android:versionName=\"1.0\">\n       <uses-sdk android:minSdkVersion=\"9\"/>\n       <application android:label=\"@string/app_name\"\n           android:icon=\"@drawable/ic_launcher\"\n           android:hasCode=\"true\">\n        <activity android:name=\"android.app.NativeActivity\"\n            android:label=\"@string/app_name\"\n            android:configChanges=\"orientation|keyboardHidden\">        \n               <meta-data android:name=\"android.app.lib_name\"\n                 android:value=\"NativeActivityTwo\" />\n               <intent-filter>\n                 <action android:name=\"android.intent.action.MAIN\" />\n                 <category android:name=\"android.intent.category.LAUNCHER\" />\n               </intent-filter>\n           </activity>\n       </application>\n    </manifest>\n    ```", "```kt\n    #include <jni.h>\n    #include <android_native_app_glue.h>\n    #include \"mylog.h\"\n    void handle_activity_lifecycle_events(struct android_app* app, int32_t cmd) {\n      LOGI(2, \"%d: dummy data %d\", cmd, *((int*)(app->userData)));\n    }\n    void android_main(struct android_app* app) {\n      app_dummy();    // Make sure glue isn't stripped.\n      int dummyData = 111;\n      app->userData = &dummyData;\n      app->onAppCmd = handle_activity_lifecycle_events;\n      while (1) {\n        int ident, events;\n        struct android_poll_source* source;\n    if ((ident=ALooper_pollAll(-1, NULL, &events, (void**)&source)) >= 0) {\n          source->process(app, source);\n        }\n      }\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeActivityTwo\n    LOCAL_SRC_FILES := NativeActivityTwo.cpp\n    LOCAL_LDLIBS    := -llog -landroid\n    LOCAL_STATIC_LIBRARIES := android_native_app_glue\n    include $(BUILD_SHARED_LIBRARY)\n    $(call import-module,android/native_app_glue)\n    ```", "```kt\n    adb logcat -v time NativeActivityTwo:I *:S\n    ```", "```kt\nvoid ANativeActivity_onCreate(ANativeActivity* activity,\n        void* savedState, size_t savedStateSize) {\n    LOGV(\"Creating: %p\\n\", activity);\n    activity->callbacks->onDestroy = onDestroy;\n    activity->callbacks->onStart = onStart;\n    activity->callbacks->onResume = onResume;\n    … …\n    activity->callbacks->onNativeWindowCreated = onNativeWindowCreated;\n    activity->callbacks->onNativeWindowDestroyed = onNativeWindowDestroyed;\n    activity->callbacks->onInputQueueCreated = onInputQueueCreated;\n    activity->callbacks->onInputQueueDestroyed = onInputQueueDestroyed;\n    activity->instance = android_app_create(activity, savedState, savedStateSize);\n}\n```", "```kt\nstatic struct android_app* android_app_create(ANativeActivity* activity, void* savedState, size_t savedStateSize) {\n    struct android_app* android_app = (struct android_app*)malloc(sizeof(struct android_app));\n    memset(android_app, 0, sizeof(struct android_app));\n    android_app->activity = activity;\n\n    pthread_mutex_init(&android_app->mutex, NULL);\n    pthread_cond_init(&android_app->cond, NULL);\n  ……\n    int msgpipe[2];\n    if (pipe(msgpipe)) {\n        LOGE(\"could not create pipe: %s\", strerror(errno));\n        return NULL;\n    }\n    android_app->msgread = msgpipe[0];\n    android_app->msgwrite = msgpipe[1];\n\n    pthread_attr_t attr; \n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    pthread_create(&android_app->thread, &attr, android_app_entry, android_app);\n    // Wait for thread to start.\n    pthread_mutex_lock(&android_app->mutex);\n    while (!android_app->running) {\n        pthread_cond_wait(&android_app->cond, &android_app->mutex);\n    }\n    pthread_mutex_unlock(&android_app->mutex);\n    return android_app;\n}\n```", "```kt\nstatic void* android_app_entry(void* param) {\n    struct android_app* android_app = (struct android_app*)param;\n  … …\n  //Attach life cycle event queue with identifier LOOPER_ID_MAIN\n    android_app->cmdPollSource.id = LOOPER_ID_MAIN;\n    android_app->cmdPollSource.app = android_app;\n    android_app->cmdPollSource.process = process_cmd;\n    android_app->inputPollSource.id = LOOPER_ID_INPUT;\n    android_app->inputPollSource.app = android_app;\n    android_app->inputPollSource.process = process_input;\n    ALooper* looper = ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);\n    ALooper_addFd(looper, android_app->msgread, LOOPER_ID_MAIN, ALOOPER_EVENT_INPUT, NULL, &android_app->cmdPollSource);\n    android_app->looper = looper;\n\n    pthread_mutex_lock(&android_app->mutex);\n    android_app->running = 1;\n    pthread_cond_broadcast(&android_app->cond);\n    pthread_mutex_unlock(&android_app->mutex);\n    android_main(android_app);\n    android_app_destroy(android_app);\n    return NULL;\n}\n```", "```kt\n    ALooper* ALooper_prepare(int opts);\n    ```", "```kt\n    int ALooper_addFd(ALooper* looper, int fd, int ident, int events, ALooper_callbackFunc callback, void* data);\n    ```", "```kt\n    int ALooper_pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData);\n    int ALooper_pollAll(int timeoutMillis, int* outFd, int* outEvents, void** outData);\n    ```", "```kt\n    int ALooper_removeFd(ALooper* looper, int fd);\n    ```", "```kt\n    void drawSomething(struct android_app* app) {\n      ANativeWindow_Buffer lWindowBuffer;\n      ANativeWindow* lWindow = app->window;\n      ANativeWindow_setBuffersGeometry(lWindow, 0, 0, WINDOW_FORMAT_RGBA_8888);\n      if (ANativeWindow_lock(lWindow, &lWindowBuffer, NULL) < 0) {\n        return;\n      }\n      memset(lWindowBuffer.bits, 0, lWindowBuffer.stride*lWindowBuffer.height*sizeof(uint32_t));\n      int sqh = 150, sqw = 100;\n      int wst = lWindowBuffer.stride/2 - sqw/2;\n      int wed = wst + sqw;\n      int hst = lWindowBuffer.height/2 - sqh/2;\n      int hed = hst + sqh;\n      for (int i = hst; i < hed; ++i) {\n        for (int j = wst; j < wed; ++j) {\n          ((char*)(lWindowBuffer.bits))[(i*lWindowBuffer.stride + j)*sizeof(uint32_t)] = (char)255;      //R\n          ((char*)(lWindowBuffer.bits))[(i*lWindowBuffer.stride + j)*sizeof(uint32_t) + 1] = (char)0;    //G\n          ((char*)(lWindowBuffer.bits))[(i*lWindowBuffer.stride + j)*sizeof(uint32_t) + 2] = (char)0;    //B\n          ((char*)(lWindowBuffer.bits))[(i*lWindowBuffer.stride + j)*sizeof(uint32_t) + 3] = (char)255;    //A\n        }\n      }\n      ANativeWindow_unlockAndPost(lWindow);\n    }\n\n    void handle_activity_lifecycle_events(struct android_app* app, int32_t cmd) {\n      LOGI(2, \"%d: dummy data %d\", cmd, *((int*)(app->userData)));\n      switch (cmd) {\n      case APP_CMD_INIT_WINDOW:\n        drawSomething(app);\n        break;\n      }\n    }\n    ```", "```kt\n    $ adb logcat -v time NativeWindowManagement:I *:S\n    ```", "```kt\n    int32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window, int32_t width, int32_t height, int32_t format);\n    ```", "```kt\n    int32_t ANativeWindow_lock(ANativeWindow* window, ANativeWindow_Buffer* outBuffer,  ARect* inOutDirtyBounds);\n    ```", "```kt\n    int32_t ANativeWindow_unlockAndPost(ANativeWindow* window);\n    ```", "```kt\n        int mPreviousX = -1;\n        int32_t handle_input_events(struct android_app* app, AInputEvent* event) {\n          int etype = AInputEvent_getType(event);\n          switch (etype) {\n          case AINPUT_EVENT_TYPE_KEY:\n        … ...    \n            break;\n          case AINPUT_EVENT_TYPE_MOTION:\n            int32_t action, posX, pointer_index;\n            action = AMotionEvent_getAction(event);\n            pointer_index = (action&AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n            posX = AMotionEvent_getX(event, pointer_index);\n            if (action == AMOTION_EVENT_ACTION_MOVE) {\n              int xMove = posX - mPreviousX;\n              USERDATA* userData = (USERDATA*)app->userData;\n              userData->xMove = xMove;\n              app->redrawNeeded = 1;\n            }\n            mPreviousX = posX;\n            break;\n          }\n        }\n        ```", "```kt\n        void android_main(struct android_app* app) {\n        … ...\n        while (1) {\n            int ident, events;\n            struct android_poll_source* source;\n            if ((ident=ALooper_pollOnce(app->redrawNeeded?0:-1, NULL, &events, (void**)&source)) >= 0) {\n              if (NULL!=source) {\n                source->process(app, source);\n              }\n              if (app->redrawNeeded) {\n                drawSomething(app);\n              }\n            }\n        }\n        }\n        ```", "```kt\npointer_index = (action&AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n```", "```kt\n        void handle_activity_lifecycle_events(struct android_app* app, int32_t cmd) {\n          USERDATA* userData;\n          switch (cmd) {\n        …...\n          case APP_CMD_SAVE_STATE:\n            // save current state\n            userData = (USERDATA*)(app->userData);\n            app->savedState = malloc(sizeof(SAVED_USERDATA));\n            *((SAVED_USERDATA*)app->savedState) = userData->drawingData;\n            app->savedStateSize = sizeof(SAVED_USERDATA);\n            break;\n          case APP_CMD_GAINED_FOCUS:\n            userData = (USERDATA*)(app->userData);\n            if (NULL != userData->accelerometerSensor) {\n              ASensorEventQueue_enableSensor(userData->sensorEventQueue,\n                  userData->accelerometerSensor);\n              ASensorEventQueue_setEventRate(userData->sensorEventQueue,\n                  userData->accelerometerSensor, (1000L/60)*1000);\n            }\n            break;\n          case APP_CMD_LOST_FOCUS:\n            USERDATA userData = *(USERDATA*) app->userData;\n            if (NULL!=userData.accelerometerSensor) {      ASensorEventQueue_disableSensor(userData.sensorEventQueue, userData.accelerometerSensor);\n            }\n            break;\n          }\n        }\n        ```", "```kt\n        void android_main(struct android_app* app) {\n        … ...\n        while (0==app->destroyRequested) {\n          int ident, events;\n          struct android_poll_source* source;\n          if ((ident=ALooper_pollOnce(-1, NULL, &events, (void**)&source)) >= 0) {\n            if (LOOPER_ID_USER == ident) {\n            ASensorEvent event;\n            while (ASensorEventQueue_getEvents(userData.sensorEventQueue,\n                &event, 1) > 0) {\n              int64_t currentTime = get_time();\n              … ...\n              if ((currentTime - lastTime) > TIME_THRESHOLD) {\n                long diff = currentTime - lastTime;\n                float speedX = (event.acceleration.x - lastX)/diff*10000;\n                float speedY = (event.acceleration.y - lastY)/diff*10000;\n                float speedZ = (event.acceleration.z - lastZ)/diff*10000;\n                float speed = fabs(speedX + speedY + speedZ);\n        …...        \n              }\n            }\n            }\n          }\n        }\n        ```", "```kt\n        ASensorManager_destroyEventQueue(userData.sensorManager, userData.sensorEventQueue);\n        }\n\n        ```", "```kt\n    ASensorManager* ASensorManager_getInstance();\n    ```", "```kt\n    ASensor const* ASensorManager_getDefaultSensor(ASensorManager* manager, int type);\n    int ASensorManager_getSensorList(ASensorManager* manager, ASensorList* list);\n    ```", "```kt\n    ASensorEventQueue* ASensorManager_createEventQueue(ASensorManager* manager, ALooper* looper, int ident, ALooper_callbackFunc callback, void* data);\n    ```", "```kt\n    int ASensorEventQueue_enableSensor(ASensorEventQueue* queue, ASensor const* sensor);\n    int ASensorEventQueue_setEventRate(ASensorEventQueue* queue, ASensor const* sensor, int32_t usec);\n    ```", "```kt\n    ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue, ASensorEvent* events, size_t count);\n    ```", "```kt\n    int ASensorEventQueue_disableSensor(ASensorEventQueue* queue, ASensor const* sensor);\n    ```", "```kt\n    int ASensorManager_destroyEventQueue(ASensorManager* manager, ASensorEventQueue* queue);\n    ```", "```kt\n    private static native void naLoadTexture(AssetManager pAssetManager);\n    ```", "```kt\n    naLoadTexture(mContext.getAssets());\n    ```", "```kt\n        void readPng(png_structp pPngPtr, png_bytep pBuf, png_size_t pCount) {\n          AAsset* assetF = (AAsset*)png_get_io_ptr(pPngPtr);\n          AAsset_read(assetF, pBuf, pCount);\n        }\n        ```", "```kt\n        void naLoadTexture(JNIEnv* env, jclass clazz, jobject pAssetManager) {\n          AAssetManager* assetManager = AAssetManager_fromJava(env, pAssetManager);\n          AAssetDir* texDir = AAssetManager_openDir(assetManager, \"\");\n          const char* texFn;\n          int pId = 0;\n          while (NULL != (texFn = AAssetDir_getNextFileName(texDir))) {\n            AAsset* assetF = AAssetManager_open(assetManager, texFn, AASSET_MODE_UNKNOWN);\n            //read the png header\n            png_byte header[8];\n           png_byte *imageData;\n            …...\n            if (8 != AAsset_read(assetF, header, 8)) {\n              goto FEND;\n            }\n            …...\n            //init png reading by setting a read callback\n            png_set_read_fn(pngPtr, assetF, readPng);\n            …...\n            // Loads image data into OpenGL.\n            glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, type, imageData);\n        FEND:\n            AAsset_close(assetF);\n            pId++;\n          }\n          AAssetDir_close(texDir);\n        }\n        ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(call all-subdir-makefiles)\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_CFLAGS := \n    LOCAL_MODULE    := libpng\n    LOCAL_SRC_FILES :=\\\n      png.c \\\n      pngerror.c \\\n      pngget.c \\\n      pngmem.c \\\n      pngpread.c \\\n      pngread.c \\\n      pngrio.c \\\n      pngrtran.c \\\n      pngrutil.c \\\n      pngset.c \\\n      pngtrans.c \\\n      pngwio.c \\\n      pngwrite.c \\\n      pngwtran.c \\\n      pngwutil.c \n    LOCAL_LDLIBS := -lz\n    include $(BUILD_STATIC_LIBRARY)\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := DiceG1NativeAssets\n    LOCAL_C_INCLUDES := $(LOCAL_PATH)/../libpng-1.5.12/\n    LOCAL_STATIC_LIBRARIES := libpng\n    LOCAL_SRC_FILES := Cube.cpp DiceG1.cpp\n    LOCAL_LDLIBS := -lGLESv1_CM -llog -landroid -lz\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    AAssetDir* AAssetManager_openDir(AAssetManager* mgr, const char* dirName);\n    ```", "```kt\n    const char* AAssetDir_getNextFileName(AAssetDir* assetDir);\n    ```", "```kt\n    AAsset* AAssetManager_open(AAssetManager* mgr, const char* filename, int mode);\n    ```", "```kt\n    int AAsset_read(AAsset* asset, void* buf, size_t count);\n    ```"]