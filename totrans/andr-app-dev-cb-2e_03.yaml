- en: Chapter 3. Views, Widgets, and Styles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 视图、控件和样式
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Inserting a widget into a layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布局中插入小部件
- en: Using graphics to show the button state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形显示按钮状态
- en: Creating a widget at runtime
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建控件
- en: Creating a custom component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义组件
- en: Applying a style to a View
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式应用于视图
- en: Turning a style into a theme
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式转变为主题
- en: Selecting a theme based on the Android OS version
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据Android操作系统版本选择主题
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The term **widgets** can refer to several different concepts in Android. When
    most people talk about widgets, they are referring to **app widgets**, which are
    typically seen on the home screen. App widgets are like mini applications by themselves
    as they usually provide a subset of functionality, based on their main application.
    (Usually, most app widgets are installed along with an application, but that is
    not a requirement. They can be standalone apps in a widget format.) A common app
    widget example is a weather application that offers several different app widgets
    for the home screen. [Chapter 5](ch05.html "Chapter 5. Exploring Fragments, AppWidgets,
    and the System UI"), *Exploring Fragments, AppWidgets, and the System UI*, will
    discuss home screen app widgets and provide recipes to create your own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**控件**一词在 Android 中可以指代几个不同的概念。当大多数人谈论控件时，他们指的是**应用控件**，通常出现在主屏幕上。应用控件本身就像迷你应用程序，因为它们通常提供基于它们主要应用程序的功能子集。（通常，大多数应用控件随应用程序一起安装，但这不是必需的。它们可以是独立的应用，以控件格式存在。）一个常见的应用控件示例是提供多种不同主屏幕控件的风weather应用程序。[第5章](ch05.html
    "第5章. 探索片段、应用控件和系统UI")，*探索片段、应用控件和系统UI*，将讨论主屏幕应用控件并提供创建你自己的食谱。'
- en: When developing for Android, the term widgets generally refers to specialized
    Views placed in the layout files, such as a Button, TextView, CheckBox, and so
    on. In this chapter, we will focus on widgets for app development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Android 开发时，控件一词通常指的是在布局文件中放置的专用视图，如 Button、TextView、CheckBox 等。在本章中，我们将专注于应用开发中的控件。
- en: 'To see the list of widgets provided in the **Android SDK**, open a layout file
    in Android Studio, and click on the **Design** tab. Along the left side of the
    Design view, you will see the **Widget** section below the **Layout** section,
    as in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**Android SDK** 提供的控件列表，请在 Android Studio 中打开一个布局文件，并点击**设计**标签。在设计视图的左侧，你会在**布局**部分下方看到**控件**部分，如下面的屏幕截图所示：
- en: '![Introduction](img/B05057_03_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B05057_03_01.jpg)'
- en: As you can see from the list, the **Android SDK** provides many useful widgets—from
    a simple TextView, Button, or Checkbox to the much more complex widgets such as
    the Clock, DatePicker, and Calendar. As useful as the built-in widgets are, it's
    also very easy to expand on what's provided in the SDK. We can extend an existing
    widget to customize its functionality, or we can create our own widget from scratch
    by extending the base View class. (We will provide an example of this in the *Creating
    a custom component* recipe later.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**Android SDK** 提供了许多有用的控件——从简单的 TextView、Button 或 Checkbox 到更复杂的控件，如 Clock、DatePicker
    和 Calendar。内置控件虽然很有用，但扩展 SDK 提供的内容也非常容易。我们可以扩展现有控件来自定义其功能，或者通过扩展基础的 View 类来从头创建我们自己的控件。（我们将在后面的*创建自定义组件*食谱中提供一个示例。）
- en: The visual look of widgets can also be customized. These settings can be used
    to create **styles**, which in turn can be used to create **themes**. Just like
    with other development environments, creating a theme offers the benefit of easily
    changing the appearance throughout our entire application with minimal effort.
    Lastly, the Android SDK also provides many built-in themes and variations, such
    as the Holo theme from Android 3/4 and the Material theme from Android 5\. (Android
    6.0 did not release a new theme.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 控件的视觉外观也可以自定义。这些设置可以用来创建**样式**，进而用来创建**主题**。就像在其他开发环境中一样，创建主题可以轻松地改变我们整个应用程序的外观，而无需付出太多努力。最后，Android
    SDK 还提供了许多内置主题和变体，如来自 Android 3/4 的 Holo 主题和来自 Android 5 的 Material 主题。（Android
    6.0 没有发布新主题。）
- en: Inserting a widget into a layout
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在布局中插入控件
- en: As you may have seen from previous recipes, **widgets** are declared in a layout
    file, or created in code. For this recipe, we will go step-by-step to add a button
    with the Android Studio Designer. (For later recipes, we will just show the layout
    XML from the TextView.) After creating the button, we will create an `onClickListener()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的食谱中所见，**小部件** 在布局文件中声明，或者在代码中创建。对于这个食谱，我们将逐步使用Android Studio Designer添加一个按钮。（对于后续的食谱，我们只展示从TextView的布局XML。）创建按钮后，我们将创建一个
    `onClickListener()`。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start a new project in Android Studio and call it `InsertWidget`. Use the default
    options for creating a Phone and Tablet project and select **Empty Activity**
    when prompted for the Activity Type. You can delete the default TextView (or leave
    it) as it will not be needed for this recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中开始一个新项目，并将其命名为 `InsertWidget`。为创建电话和平板项目选择默认选项，并在提示Activity类型时选择
    **Empty Activity**。您可以删除默认的TextView（或者保留它），因为对于这个食谱来说不需要。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To insert a widget into a layout, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要将小部件插入到布局中，请按照以下步骤操作：
- en: Open the **activity_main.xml** file in Android Studio and click on the **Design**
    tab.![How to do it...](img/B05057_03_02.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开 `activity_main.xml` 文件并点击 **设计** 选项卡。![如何操作...](img/B05057_03_02.jpg)
- en: Find **Button** in the widget list and drag it to the center of the activity
    screen on the right. Android will automatically set the layout parameters based
    on where the button is dropped. If you center the button as shown in the screenshot,
    Android Studio will set those parameters in the XML.![How to do it...](img/B05057_03_03.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在小部件列表中找到 **Button** 并将其拖到右侧活动屏幕的中央。Android会根据按钮放置的位置自动设置布局参数。如果您像截图那样将按钮居中，Android
    Studio会在XML中设置这些参数。![如何操作...](img/B05057_03_03.jpg)
- en: To view the `xml` created, click on the **Text** tab as shown in the following
    screenshot. See how the button is centered using the `RelativeLayout` parameters.
    Also, take note of the default ID as we will need it for the next step.![How to
    do it...](img/B05057_03_04.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看创建的 `xml`，请点击如下截图所示的 **文本** 选项卡。看看按钮是如何使用 `RelativeLayout` 参数居中的。同时注意默认的ID，因为下一步我们会需要它。![如何操作...](img/B05057_03_04.jpg)
- en: 'Now, open the `MainActivity.java` file to edit the code. Add the following
    code to the `onCreate()` method to set up the `onClickListener()`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainActivity.java` 文件以编辑代码。在 `onCreate()` 方法中添加以下代码以设置 `onClickListener()`：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the application on a device or emulator.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Creating the UI with the Android Studio is as simple as dragging and dropping
    Views. You can also edit the properties of the Views directly in the **Design**
    tab. Switching to the XML code is as simple as hitting the **Text** tab.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android Studio创建UI就像拖放Views一样简单。您还可以直接在 **设计** 选项卡中编辑Views的属性。切换到XML代码只需点击
    **文本** 选项卡。
- en: 'What we did here is very common in Android development—creating the UI in XML,
    then hooking up the UI components (Views) in the Java code. To reference a View
    from code, it must have a resource identifier associated with it. This is done
    using the `id` parameter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们所做的是在Android开发中非常常见的操作——在XML中创建UI，然后在Java代码中将UI组件（Views）连接起来。要从代码中引用一个View，它必须有一个与之关联的资源标识符。这是通过使用
    `id` 参数完成的：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `onClickListener` function displays a pop-up message on the screen called
    **Toast**, when the button is pressed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `onClickListener` 函数会在按钮被按下时在屏幕上显示一个名为 **Toast** 的弹出消息。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a look again at the format of the identifier we created previously, `@+id/button`.
    The `@` specifies this is going to be a resource and the **+** sign indicates
    a new resource. (If we failed to include the plus sign, we would get a compile
    time error stating **No resource matched the indicated name**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看我们之前创建的标识符格式，`@+id/button`。`@` 表示这是一个资源，而 **+** 符号表示新资源。（如果我们忘记包含加号，将会在编译时出现错误，提示
    **No resource matched the indicated name**（没有资源与指定的名称匹配））。
- en: See also
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Butter Knife (Open Source Project)—Field and method binding for Android Views:
    [http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Butter Knife（开源项目）—Android Views的字段和方法绑定：[http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)
- en: Using graphics to show button state
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图形显示按钮状态
- en: 'We''ve talked about the versatility of Android Views and how behavior and visual
    appearance can be customized. In this recipe, we will create a drawable **state
    selector**, which is a resource defined in XML that specifies the drawable to
    use based on the View''s state. The most commonly used states, along with the
    possible values, include:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了 Android 视图的灵活性以及行为和视觉外观如何定制。在本教程中，我们将创建一个可绘制的 **状态选择器**，这是一个在 XML 中定义的资源，它根据视图的状态指定要使用的可绘制资源。最常用的状态以及可能的值包括：
- en: '`state_pressed=["true" | "false"]`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_pressed=["true" | "false"]`'
- en: '`state_focused=["true" | "false"]`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_focused=["true" | "false"]`'
- en: '`state_selected=["true" | "false"]`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_selected=["true" | "false"]`'
- en: '`state_checked=["true" | "false"]`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_checked=["true" | "false"]`'
- en: '`state_enabled=["true" | "false"]`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_enabled=["true" | "false"]`'
- en: 'To define a state selector, create an XML file with the `<selector>` element,
    as shown:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义状态选择器，请创建一个带有 `<selector>` 元素的 XML 文件，如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within the `<selector>` element, we define an `<item>` to identify the drawable
    to be used based on the specified state(s). Here''s an example `<item>` element
    using multiple states:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<selector>` 元素内，我们定义一个 `<item>` 以根据指定的状态确定要使用的可绘制资源。以下是一个使用多个状态的 `<item>`
    元素示例：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's important to remember the file is read from top to bottom so the first
    item that meets the state requirements will be used. A default drawable, one with
    no states included, would need to go last.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住，文件是从上往下读取的，因此第一个符合状态要求的项将被使用。一个默认的可绘制资源，没有包含状态的，应该放在最后。
- en: For this recipe, we will use a state selector to change the background color
    based on the `ToggleButton` state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们将使用状态选择器根据 `ToggleButton` 的状态改变背景颜色。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `StateSelector` using the
    default **Phone & Tablet** options. When prompted for the **Activity Type**, select
    **Empty Activity**. To make it easier to type the code for this recipe, we will
    use a color as the graphic to represent the button state.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个名为 `StateSelector` 的新项目，使用默认的 **手机 & 平板** 选项。当提示选择 **活动类型**
    时，选择 **空活动**。为了便于输入本教程的代码，我们将使用颜色作为表示按钮状态的图形。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start by creating the state selector, which is a resource file defined
    with XML code. We will then set up the button to use our new state selector. Here
    are the steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建状态选择器开始，这是一个用 XML 代码定义的资源文件。然后我们将设置按钮使用新的状态选择器。以下是步骤：
- en: 'Create a new `XML` file in the `res/drawable` folder and call it: `state_selector.xml`.
    The file should consist of the following XML code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/drawable` 文件夹中创建一个名为 `state_selector.xml` 的新 `XML` 文件。该文件应包含以下 XML 代码：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now open the **activity_main.xml** file and drop in a `ToggleButton` as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 **activity_main.xml** 文件，并按以下方式添加一个 `ToggleButton`：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the application on a device or emulator.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main concept to understand here is the Android State Selector. As shown
    in Step 2, we created a resource file which specified a **drawable** (a color
    in this case) based on `state_checked`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要理解的主要概念是 Android 状态选择器。如第二步所示，我们创建了一个资源文件，根据 `state_checked` 指定了一个 **可绘制资源**（在这种情况下是颜色）。
- en: Android supports many other state conditions besides checked. While typing in
    `android:state`, look at the autocomplete dropdown to see the list of other options.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选中状态，Android 还支持许多其他状态条件。在输入 `android:state` 时，查看自动完成下拉列表以查看其他选项。
- en: Once we have the drawable resource created (the XML from step 1), we just have
    to tell the view to use it. Since we wanted the background color to change based
    on the state, we use the `android:background` property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好可绘制资源（第一步的 XML）后，我们只需告诉视图使用它。由于我们希望根据状态改变背景颜色，因此我们使用 `android:background`
    属性。
- en: '`state_selector.xml` is a drawable resource that can be passed to any property
    that accepts a drawable. We could, for example, replace the button in a checkbox
    with the following XML:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`state_selector.xml` 是一个可传递给任何接受可绘制资源的属性的可绘制资源。例如，我们可以使用以下 XML 替换复选框中的按钮：'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What if we wanted actual images for the graphics instead of just a color change?
    This is as easy as changing the drawable referenced in the item state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实际的图片作为图形，而不仅仅是颜色变化呢？这就像更改项状态中引用的可绘制资源一样简单。
- en: 'The source code available for download uses two graphic images, downloaded
    from: [https://pixabay.com/](https://pixabay.com/) (this was chosen because the
    images are free to use and didn''t require a login.)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以下载的源代码使用了两个图形图像，从[https://pixabay.com/](https://pixabay.com/)下载（选择这个网站是因为图像可以免费使用，且不需要登录。）
- en: 'Once you have your desired images, place them in the `res/drawable` folder.
    Then, change the state item line in the XML to reference your images. Here''s
    an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了想要的图像，将它们放在`res/drawable`文件夹中。然后，在XML中更改状态项行以引用你的图像。以下是一个示例：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (Change `check_on` to match your image resource name.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: （将`check_on`更改为与您的图像资源名称匹配。）
- en: Using designated folders for screen-specific resources
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用指定文件夹进行屏幕特定资源
- en: 'When Android encounters a `@drawable` reference, it expects to find the target
    in one of the `res/drawable` folders. These are designed for different screen
    densities: `ldpi` (low dots per inch), `mdpi` (medium), `hdpi` (high), and `xhdpi`
    (extra-high) and they allow us to create resources for specific target devices.
    When an application is running on a specific device, Android will load resources
    from the designated folder that most closely matches the actual screen density.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android遇到`@drawable`引用时，它会期望在`res/drawable`文件夹之一中找到目标。这些是为不同的屏幕密度设计的：`ldpi`（低每英寸点数）、`mdpi`（中等）、`hdpi`（高）和`xhdpi`（超高），它们允许我们为特定目标设备创建资源。当应用程序在特定设备上运行时，Android将从与实际屏幕密度最接近的指定文件夹加载资源。
- en: If it finds this folder empty, it will try the next nearest match and so on
    until it finds the named resource. For tutorial purposes, a separate set of files
    for each possible density is not required, and so placing our images in the `drawable`
    folder is a simple way to run the exercise on any device.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它发现这个文件夹是空的，它会尝试下一个最接近的匹配，以此类推，直到找到命名的资源。出于教程目的，不需要为每种可能的密度创建一组单独的文件，因此将我们的图像放在`drawable`文件夹中是在任何设备上运行练习的简单方法。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a complete list of resource identifiers available, visit [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用的资源标识符的完整列表，请访问[http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html)。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For another example on Android resource selection, see the recipe on *Selecting
    theme based on the OS version later*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Android上选择资源的另一个示例，请参阅关于*根据操作系统版本选择主题*的食谱。
- en: Creating a widget at runtime
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时创建小部件
- en: As mentioned before, generally, the UI is declared in `XML` files and then modified
    during runtime through the Java code. It is possible to create the UI completely
    in Java code, though for a complex layout, it would generally not be considered
    best practice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通常UI是在`XML`文件中声明，然后在运行时通过Java代码进行修改。完全有可能在Java代码中创建UI，但对于复杂的布局，通常认为这不是最佳实践。
- en: The GridView example from the previous chapter was created in code. But unlike
    the GridView recipe, in this recipe, we are going to add a view to the existing
    layout defined in `activity_main.xml`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中的GridView示例是在代码中创建的。但与GridView食谱不同，在这个食谱中，我们将向在`activity_main.xml`中定义的现有布局中添加一个视图。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RuntimeWidget`. Select the
    **Empty Activity** option when prompted for the **Activity type**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为`RuntimeWidget`。在选择**活动类型**时，选择**空活动**选项。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start by adding an ID attribute to the existing layout so we can access
    the layout in code. Once we have a reference to the layout in code, we can add
    new views to the existing layout. Here are the steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从为现有布局添加ID属性开始，这样我们就可以在代码中访问布局。一旦我们在代码中有了对布局的引用，我们就可以向现有布局中添加新视图。以下是步骤：
- en: 'Open the `res/layout/activity_main.xml` and add an ID attribute to the main
    `RelativeLayout`, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout/activity_main.xml`，并为主要的`RelativeLayout`添加ID属性，如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Completely remove the default `<TextView>` element.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全移除默认的`<TextView>`元素。
- en: 'Open the `MainActivity.java` file so we can add code to the `onCreate()` method.
    Add the following code (after `setContentView())` to get a reference to the `RelativeLayout`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件，以便我们可以在`onCreate()`方法中添加代码。在`setContentView()`之后添加以下代码，以获取对`RelativeLayout`的引用：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a DatePicker and add it to the layout with the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个DatePicker并将其添加到布局中：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program on a device or emulator.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This is hopefully very straightforward code. First, we get a reference to the
    parent layout using `findViewById`. We added the ID to the existing RelativeLayout
    (in step 1) to make it easier to reference. We create a DatePicker in code and
    add it to the layout with the `addView()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该非常直观。首先，我们使用`findViewById`获取父布局的引用。我们在第一步中为现有的RelativeLayout添加了ID，以便更容易引用。我们在代码中创建一个DatePicker，并使用`addView()`方法将其添加到布局中。
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if we wanted to create the entire layout from code? Though it may not
    be considered best practice, there are times when it is certainly easier (and
    less complex) to create a layout from code. Let''s see how this example would
    look if we didn''t use the layout from `activity_main.xml`. Here''s how the onCreate()
    would look:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想完全从代码创建整个布局呢？尽管这可能不是最佳实践，但在某些时候，从代码创建布局肯定更容易（也更简单）。让我们看看如果我们不使用`activity_main.xml`中的布局，这个例子会是什么样子。以下是`onCreate()`的样子：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, it's really not that different. If you create a view in code
    and want to reference it later, you either need to keep a reference to the object,
    or assign the view an ID to use `findViewByID()`. To give a view an ID, use the
    **setID()** method by passing in **View.generateViewId()** (to generate a unique
    ID) or define the ID using **<resources>** in xml.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，其实并没有太大区别。如果你在代码中创建了一个视图，并且稍后想要引用它，你需要保留对对象的引用，或者给视图分配一个ID以使用`findViewByID()`。要给视图分配ID，请使用**setID()**方法，传入**View.generateViewId()**（以生成唯一ID）或在xml中使用**<resources>**定义ID。
- en: Creating a custom component
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义组件
- en: As we have seen in previous recipes, the Android SDK provides a wide range of
    components. But what happens when you can't find a prebuilt component that fits
    your unique needs? You can always create your own!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的教程中所看到的，Android SDK提供了广泛的组件。但是当你找不到符合你独特需求的预建组件时会发生什么呢？你可以随时创建自己的组件！
- en: 'In this recipe, we will walk through creating a custom component that derives
    from the View class, just like the built-in widgets. Here''s a high-level overview:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将介绍如何创建一个自定义组件，该组件从View类派生，就像内置小部件一样。以下是一个高级概述：
- en: Create a new class that extends View.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展自View的新类。
- en: Create custom constructor(s).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义构造函数。
- en: Override `onMeasure()`, and the default implementation returns a size of 100
    x 100.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onMeasure()`，默认实现返回100 x 100的大小。
- en: Override `onDraw()`, and the default implementation draws nothing.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onDraw()`，默认实现不绘制任何内容。
- en: Define custom methods and listeners (such as on<*Event*>()).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义自定义方法和监听器（例如on<*Event*>()）。
- en: Implement custom functionality.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现自定义功能。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While overriding `onMeasure()` and `onDraw()` is not strictly required, the
    default behavior is likely not what you would want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重写`onMeasure()`和`onDraw()`不是严格要求的，但默认行为很可能不是你想要的。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Start a new project in Android Studio and call it `CustomView`. Use the default
    wizard options, including the **Phone & Tablet SDK** and select **Empty Activity**
    when prompted for the Activity type. Once the project files are created and open
    in Android Studio, you are ready to begin.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中开始一个新项目，并将其命名为`CustomView`。使用默认的向导选项，包括**Phone & Tablet SDK**，并在提示选择Activity类型时选择**Empty
    Activity**。一旦项目文件在Android Studio中创建并打开，你就可以开始了。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a new class for our custom component to derive from the Android
    View class. Our custom component could be a subclass of an existing class, such
    as the Activity, but we will create it in a separate file to make it easier to
    maintain. Here are the steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为自定义组件创建一个新类，从Android View类派生。我们的自定义组件可以是现有类的子类，比如Activity，但我们将在一个单独的文件中创建它，以便更容易维护。以下是步骤：
- en: Start by creating a new Java class and also call it `CustomView`. This is where
    we will implement our custom component, as described in the introduction.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的Java类，并将其命名为`CustomView`。这里我们将实现自定义组件，如引言中所描述的。
- en: 'Change the class constructor so it extends View. It should look as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类构造函数，使其继承自View。它应该如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define a `Paint` object for the class, which will be used in the onDraw():'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类定义一个`Paint`对象，将在`onDraw()`中使用：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a default constructor, which requires the activity `Context`, so we
    can inflate the view. We will set the paint properties here as well. The constructor
    should look as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个默认构造函数，需要活动`Context`，这样我们就可以加载视图。我们也将在这里设置画笔属性。构造函数应该如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Override the onDraw() method as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式重写`onDraw()`方法：
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, inflate our custom view in `MainActivity.java` by replacing the `setContentView()`
    with our view, as shown:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity.java`中通过将`setContentView()`替换为我们的视图来扩展自定义视图，如下所示：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the application on a device or emulator to see it in action.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序以查看实际效果。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We start by extending the View class, just as the built-in components do. Next,
    we create the default constructor. This is important as we need the context to
    pass down to the super class, which we do with the call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先扩展了View类，正如内置组件所做的。接下来，我们创建默认构造函数。这很重要，因为我们需要将上下文传递给超类，我们通过以下调用实现：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to override `onDraw()`, otherwise, as mentioned in the introduction,
    our custom view won't display anything. When `onDraw()` is called, the system
    passes in a **Canvas** object. The canvas is the area of the screen for our view.
    (Since we didn't override `onMeasure()`, our view would be 100 x 100, but since
    our entire activity consists of just this view, we get the whole screen as our
    canvas.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`onDraw()`，否则，如引言中所述，我们的自定义视图将不会显示任何内容。当调用`onDraw()`时，系统会传递一个**画布**对象。画布是我们视图的屏幕区域。（因为我们没有重写`onMeasure()`，我们的视图将是100
    x 100，但由于我们的整个活动仅包含这个视图，因此我们的整个屏幕都是我们的画布。）
- en: We created the `Paint` object at the class level, and as `final`, to be more
    efficient with memory allocation. (`onDraw()` should be as efficient as possible
    since it can be called multiple times per second.) As you see from running the
    program, our onDraw() implementation just sets the background color to cyan and
    prints text to the screen (using `drawText()`).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类级别创建了`Paint`对象，并作为`final`，以更有效地分配内存。（`onDraw()`应该尽可能高效，因为它每秒可能会被调用多次。）从运行程序中可以看出，我们的onDraw()实现只是将背景色设置为青色，并使用`drawText()`将文本打印到屏幕上。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Actually, there's a lot more. We've just touched the surface of what you can
    do with a custom component. Fortunately, as you see from this example, it doesn't
    take a lot of code to get basic functionality. We could easily spend an entire
    chapter on topics such as passing layout parameters to the view, adding listener
    callbacks, overriding `onMeasure()`, using our view in the IDE, and so on. These
    are all features you can add as your needs dictate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，还有很多内容。我们只是触及了自定义组件能做什么的皮毛。幸运的是，从本例中可以看出，实现基本功能并不需要太多代码。我们可以很容易地用一整章来讨论诸如将布局参数传递给视图、添加监听器回调、重写`onMeasure()`、在IDE中使用我们的视图等主题。这些功能都可以根据你的需求添加。 '
- en: While a custom component should be able to handle any solution, there are other
    options that might require less coding. Extending an existing widget is often
    sufficient without the overhead of a custom component from scratch. If what you
    need is a solution with multiple widgets, there's also the **compound control**.
    A compound control, such as a combo box, is just two or more controls grouped
    together as a single widget.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自定义组件应该能够处理任何解决方案，但可能还有其他编码量更少的选项。扩展现有小部件通常足以满足需求，无需从头开始自定义组件的开销。如果你需要的解决方案包含多个小部件，还有**复合控件**。复合控件（如组合框）只是将两个或多个控件组合在一起作为一个单独的小部件。
- en: A compound control would generally extend from a layout, not a View, since you
    will be adding multiple widgets. You probably wouldn't need to override onDraw()
    and onMeasure(), as each widget would handle the drawing in their respective methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 复合控件通常会从布局扩展而来，而不是从视图，因为你将添加多个小部件。你可能不需要重写onDraw()和onMeasure()，因为每个小部件都会在其各自的方法中处理绘制。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information on drawing, look at *Chapter 9, Graphics and Animation*.
    For full details on the View object, refer to the Android Developer resource at:
    [http://developer.android.com/reference/android/view/View.html](http://developer.android.com/reference/android/view/View.html)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关绘制的更多信息，请查看*第9章，图形和动画*。有关View对象的完整详细信息，请访问Android开发者资源：[http://developer.android.com/reference/android/view/View.html](http://developer.android.com/reference/android/view/View.html)
- en: Applying a style to a View
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式应用于视图
- en: A **style** is a collection of property settings to define the look of a View.
    As you have already seen while defining layouts, a view offers many settings to
    determine how it looks, as well as functions. We have already set a view height,
    width, background color, and padding, plus there are many more settings such as
    text color, font, text size, margin, and so on. Creating a style is as simple
    as pulling these settings from the layout and putting them in a style resource.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式**是一组属性设置的集合，用于定义视图的外观。正如在定义布局时你已经看到的，一个视图提供了许多设置以决定它的外观及功能。我们已经设置了视图的高度、宽度、背景颜色和内边距，还有更多的设置，比如文字颜色、字体、文字大小、边距等等。创建样式就像把这些设置从布局中提取出来，然后放入一个样式资源中一样简单。'
- en: In this recipe, we will go through the steps of creating a style and hooking
    it up to a view.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过创建样式并将其连接到视图的步骤。
- en: Similar to Cascading Style Sheets, Android Styles allow you to specify your
    design settings separate from the UI code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与级联样式表类似，Android样式允许你将设计设置与UI代码分开指定。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Android Studio project and call it `Styles`. Use the default wizard
    options to create a Phone & Tablet project and select Empty Activity when prompted
    for the Activity. By default, the wizard also creates a `styles.xml` file, which
    we will use for this recipe.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Android Studio项目，命名为`Styles`。使用默认的向导选项创建一个Phone & Tablet项目，并在提示选择Activity时选择Empty
    Activity。默认情况下，向导还会创建一个`styles.xml`文件，我们将在这个食谱中使用它。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create our own style resource to change the appearance of a `TextView`.
    We can add our new style to the `styles.xml` resource created by Android Studio
    using the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的样式资源，以改变`TextView`的外观。我们可以按照以下步骤将新的样式添加到Android Studio创建的`styles.xml`资源中：
- en: Open the default `styles.xml` file located in `res/values`, as shown here:![How
    to do it...](img/B05057_03_05.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`res/values`中的默认`styles.xml`文件，如下所示：![如何操作...](img/B05057_03_05.jpg)
- en: 'We will create a new style called `MyStyle` by adding the following XML below
    the existing `AppTheme` style:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过在现有的`AppTheme`样式下方添加以下XML，创建一个名为`MyStyle`的新样式：
- en: '[PRE18]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now tell the view to use this style. Open the `activity_main.xml` file and
    add the following attribute to the existing `<TextView>` element:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在告诉视图使用这个样式。打开`activity_main.xml`文件，并在现有的`<TextView>`元素中添加以下属性：
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Either run the application or view the results in the **Design** tab.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序或在**设计**标签中查看结果。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A **style** is a resource, defined by using the `<style>` element nested in
    a `<resources>` element of an xml file. We used the existing `styles.xml` file,
    but that is not a requirement, as we can use whatever filename we want. As seen
    in this recipe, multiple `<style>` elements can be included in one xml file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式**是一个资源，通过在xml文件的`<resources>`元素中嵌套`<style>`元素来定义。我们使用了现有的`styles.xml`文件，但这不是必须的，因为我们可以使用我们想要的任何文件名。正如这个食谱所示，一个xml文件中可以包含多个`<style>`元素。'
- en: Once the style is created, you can easily apply it to any number of other views
    as well. What if you wanted to have a button with the same style? Just drop a
    button in the layout and assign the same style.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了样式，你可以轻松地将其应用到任意数量的其他视图上。如果你想拥有一个具有相同风格的按钮怎么办？只需在布局中放置一个按钮，并分配相同的样式。
- en: What if we created a new button, but wanted the button to expand the full width
    of the view? How do we override the style for just that view? Simple, specify
    the attribute in the layout as you've always done. The local attribute will take
    priority over the attribute in the **style**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建了一个新的按钮，但希望按钮能扩展到视图的完整宽度怎么办？我们如何只为那个视图覆盖样式？很简单，就像你一直做的那样，在布局中指定属性。局部属性将优先于**样式**中的属性。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is another feature of styles**: inheritance**. By specifying a parent
    when defining the style, we can have styles build on each other, creating a hierarchy
    of styles. If you look at the default style in `styles.xml`: `AppTheme`, you will
    see the following line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 样式还有一个特性：**继承**。在定义样式时指定一个父样式，我们可以让样式相互构建，形成一个样式层次结构。如果你查看`styles.xml`中的默认样式`AppTheme`，你会看到以下这一行：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`AppTheme` inherits from a theme defined in the Android SDK.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppTheme`继承自Android SDK中定义的主题。'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to inherit from a style you have created yourself, there is a shortcut
    method. Instead of using the parent attribute, you can specify the parent name
    first, followed by a period, then the new name, such as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从自己创建的样式中继承，有一个快捷方法。你可以先指定父样式的名称，然后是句点，接着是新名称，例如：
- en: '`<style name="MyParent.MyStyle" >`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`<style name="MyParent.MyStyle" >`'
- en: You saw how to specify a style for a view, but what if we wanted all the TextViews
    in our application to use a specific style? We'd have to go back to each TextView
    and specify the style. But there's another way. We can include a `textViewStyle`
    item in a style to automatically assign a style to all TextViews. (There's a style
    for each of the widget types so you can do this for Buttons, ToggleButtons, TextViews,
    and so on.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何为视图指定样式，但如果我们希望应用中的所有 TextView 都使用特定样式呢？我们不得不回到每个 TextView 并指定样式。但还有另一种方法。我们可以在样式中包含一个`textViewStyle`项，以自动为所有
    TextView 分配样式。（每种小部件类型都有一个样式，因此你可以对按钮、切换按钮、文本视图等进行此操作。）
- en: 'To set the style for all TextViews, add the following line to the `AppTheme`
    style:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要为所有 TextView 设置样式，请在`AppTheme`样式中添加以下行：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the theme for our application already uses `AppThem`, we only have to
    add that single line to `AppTheme` to have all our TextViews styled with our custom
    `MyStyle`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们应用的主题已经使用了`AppTheme`，因此只需在`AppTheme`中添加那一行，我们所有的 TextView 就可以使用自定义的`MyStyle`样式。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The Android Design Support Library at:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设计支持库位于：
- en: '[http://android-developers.blogspot.de/2015/05/android-design-support-library.html](http://android-developers.blogspot.de/2015/05/android-design-support-library.html)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://android-developers.blogspot.de/2015/05/android-design-support-library.html](http://android-developers.blogspot.de/2015/05/android-design-support-library.html)'
- en: Turning a style into a theme
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式转变为主题
- en: A **theme** is a style applied to an Activity or the whole application. To set
    a theme, use the `android:theme` attribute in the `AndroidManifest.xml` file.
    The `theme` attribute applies to the `<Application>` element as well as the `<Activity>`
    elements. All views within that element will be styled with the theme specified.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**主题**是一种应用于活动或整个应用的样式。要设置主题，请在`AndroidManifest.xml`文件中使用`android:theme`属性。`theme`属性适用于`<Application>`元素以及`<Activity>`元素。该元素内的所有视图都将使用指定的主题样式。'
- en: It's common to set the Application theme, but then override a specific Activity
    with a different theme.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常设置应用主题，但随后会用不同的主题覆盖特定的活动。
- en: In the previous recipe, we set the `textViewStyle` using the AppTheme style
    (which the wizard created automatically.) In this recipe, you will learn how to
    set both the Application and Activity themes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用向导自动创建的`AppTheme`样式设置了`textViewStyle`。在本示例中，你将学习如何设置应用和活动的主题。
- en: Along with the style settings we have already explored, there are additional
    style options we didn't discuss because they don't apply to a View, they apply
    to the window as a whole. Settings such as hiding the application title or Action
    Bar and setting the window background, just to name a few, apply to the window
    and therefore must be set as a theme.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经探讨过的样式设置外，还有一些我们没有讨论的样式选项，因为它们不适用于视图，而是适用于整个窗口。例如隐藏应用标题或操作栏以及设置窗口背景等设置，这些适用于窗口，因此必须设置为主题。
- en: For this recipe, we are going to create a new theme based on the auto-generated
    `AppTheme`. Our new theme will modify the window appearance to make it a **dialog**.
    We will also look at the `theme` settings in the `AndroidManifest.xml`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将基于自动生成的`AppTheme`创建一个新主题。我们的新主题将修改窗口外观，使其成为一个**对话框**。我们还将查看`AndroidManifest.xml`中的`theme`设置。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Start a new project in Android Studio and call it `Themes`. Use the default
    wizard options and select the **Empty Activity** when prompted for the Activity
    type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中开始一个新项目，并将其命名为`Themes`。使用默认的向导选项，并在提示活动类型时选择**空活动**。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We start by adding a new theme to the existing `styles.xml` file to make our
    activity look like a dialog. Here are the steps to create the new theme and set
    activity to use the new theme:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在现有的`styles.xml`文件中添加一个新主题，使我们的活动看起来像一个对话框。以下是创建新主题并设置活动使用新主题的步骤：
- en: 'Since **themes** are defined in the same resource as **styles**, open the `styles.xml`
    file located in `res/values` and create a new style. We will create a new style
    based on the AppTheme already provided, and set `windowIsFloating`. The XML will
    be as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于**主题**是在与**样式**相同的资源中定义的，打开位于 `res/values` 目录下的 `styles.xml` 文件，并创建一个新的样式。我们将基于已提供的
    AppTheme 创建一个新样式，并设置 `windowIsFloating`。XML 将如下所示：
- en: '[PRE22]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, set the Activity to use this new dialog theme. Open the `AndroidManifest.xml`
    file and add a `theme` attribute to the Activity element, as shown:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置 Activity 使用这个新的对话框主题。打开 `AndroidManifest.xml` 文件，并在 Activity 元素中添加一个
    `theme` 属性，如下所示：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that both Application and Activity will now have a theme specified.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，现在 Application 和 Activity 都将指定一个主题。
- en: Now run the application on a device or emulator to see the dialog theme in action.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在设备或模拟器上运行应用程序，以查看对话框主题的实际效果。
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our new theme `MyDialog` inherits the base `AppTheme` using the alternative
    parent declaration, since `AppTheme` is defined in our code (and not a system
    theme). As mentioned in the introduction, some settings apply to the window as
    a whole, which is what we see with the `windowIsFloating` setting. Once our new
    theme is declared, we assign our theme to the activity in the `AndroidManifest`
    file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新主题 `MyDialog` 使用替代的父主题声明继承基础的 `AppTheme`，因为 `AppTheme` 是在我们的代码中定义的（而不是系统主题）。如引言所述，某些设置适用于整个窗口，这就是我们看到
    `windowIsFloating` 设置的原因。一旦声明了我们的新主题，我们就在 `AndroidManifest` 文件中将主题分配给活动。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have noticed we could have just added the `windowIsFloating` to the
    existing `AppTheme` and been done. Since this application only has one Activity,
    the end result would be the same, but then, any new activities would also appear
    as a dialog.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们只需将 `windowIsFloating` 添加到现有的 `AppTheme` 中就可以完成。由于此应用只有一个 Activity，最终结果将是相同的，但是，任何新的活动也将显示为对话框。
- en: Selecting theme based on the Android version
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据安卓版本选择主题
- en: Most users prefer to see apps using the latest themes provided by Android. **Now
    supports Material Theme** is common for apps upgrading to Android Lollipop. To
    be competitive with the many other apps in the market, you'll probably want to
    upgrade your app as well, but what about your users who are still running older
    versions of Android? By setting up our resources properly, we can use **resource
    selection** in Android to automatically define the parent theme based on the Android
    OS version the user is running.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户更愿意看到应用使用 Android 提供的最新主题。**现在支持 Material 主题**，对于升级到 Android Lollipop 的应用来说很常见。为了与市场上许多其他应用竞争，你可能也希望升级你的应用，但那些仍在运行较旧版本
    Android 的用户怎么办呢？通过正确设置我们的资源，我们可以使用 Android 中的**资源选择**，根据用户运行的 Android 操作系统版本自动定义父主题。
- en: 'First, let''s explore the three main themes available in Android:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探讨 Android 中可用的三个主要主题：
- en: Theme – Gingerbread and earlier
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题 – Gingerbread 及更早版本
- en: Theme.Holo – Honeycomb (API 11)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Theme.Holo – Honeycomb (API 11)
- en: Theme.Material – Lollipop (API 21)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Theme.Material – Lollipop (API 21)
- en: (As of writing this, there does not appear to be a new theme in Android 6.0.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: （截至目前，Android 6.0 似乎还没有新的主题。）
- en: This recipe will show how to properly set up the resource directories for Android
    to use the most appropriate theme based on the API version the app is running
    on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将展示如何为 Android 正确设置资源目录，以便根据应用运行的 API 版本使用最合适的主题。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start a new project in Android Studio and call it `AutomaticThemeSelector`.
    Use the default wizard option to make a Phone & Tablet project. Select the **Empty
    Activity** when prompted for the Activity Type.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中启动一个新项目，并将其命名为 `AutomaticThemeSelector`。使用默认向导选项创建一个 Phone
    & Tablet 项目。在选择 Activity 类型时，选择**空活动**。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Depending on the API version selected, Android Studio may use the App Compatability
    libraries. We don''t want to use these libraries for this project since we want
    to explicitly set which theme to use. We will start by making sure we are extending
    from the generic Activity class, then we can add our new style resources to select
    the theme based on the API. Here are the steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 根据选择的 API 版本，Android Studio 可能会使用 App 兼容性库。由于我们想要明确设置使用哪个主题，所以在这个项目中我们不希望使用这些库。我们将从确保扩展自通用的
    Activity 类开始，然后我们可以添加新的样式资源，根据 API 选择主题。以下是步骤：
- en: 'We need to make sure `MainActivity` extends from `Activity` and not `AppCompatActivity`.
    Open `ActivityMain.java` and if necessary, change it to read as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保 `MainActivity` 从 `Activity` 而不是 `AppCompatActivity` 扩展。打开 `ActivityMain.java`
    文件，如果需要，将其更改为以下内容：
- en: '[PRE24]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open `activity_main.xml` and drop in two views: a Button and a Checkbox.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`，并添加两个视图：一个 Button 和一个 Checkbox。
- en: 'Open `styles.xml` and remove `AppTheme` as it will not be used. Add our new
    theme so the file reads as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`styles.xml`，移除`AppTheme`，因为它将不再使用。添加我们的新主题，使文件内容如下所示：
- en: '[PRE25]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need to create two new values folders for API 11 and 21\. To do this, we
    need to change Android Studio to use the Project view rather than the Android
    view. (Otherwise, we won't see the new folders in the next step.) At the top of
    the **Project** window, it shows **Android**, change this to **Project** for the
    Project View. See the following screenshot:![How to do it...](img/B05057_03_06.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 API 11 和 21 创建两个新的 values 文件夹。为此，我们需要将 Android Studio 更改为使用项目视图而不是 Android
    视图。（否则，在下一步中我们看不到新文件夹。）在**项目**窗口顶部，显示**Android**，将其更改为**项目**以获取项目视图。请参阅以下截图：![如何操作...](img/B05057_03_06.jpg)
- en: Create a new directory by right-clicking on the `res` folder and navigating
    to **New** | **Directory**, as shown in this screenshot:![How to do it...](img/B05057_03_07.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`res`文件夹上右键并导航到**新建** | **目录**来创建新目录，如下面的截图所示：![如何操作...](img/B05057_03_07.jpg)
- en: 'Use the following name for the first directory: `values-v11`'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为第一个目录使用以下名称：`values-v11`
- en: Repeat this for the second directory using `values-v21`
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对第二个目录重复此操作，使用`values-v21`
- en: 'Now create a `styles.xml` file in each of the new directories. (Right-click
    on the `values-v11` directory and go to the **New** | **File** option.) For `values-v11`,
    use the following style to define the Holo theme:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在每个新目录中创建一个`styles.xml`文件。（在`values-v11`目录上右键，选择**新建** | **文件**选项。）对于`values-v11`，使用以下样式来定义
    Holo 主题：
- en: '[PRE26]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last step is to tell the application to use our new theme. To do this,
    open `AndroidManifest.xml` and change the `android:theme` attribute to `AutomaticTheme`.
    It should read as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是告诉应用使用我们的新主题。为此，请打开`AndroidManifest.xml`，并将`android:theme`属性更改为`AutomaticTheme`。它应如下所示：
- en: '[PRE27]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now run the application on a physical device or emulator. If you want to see
    the three different themes, you will need to have a device or emulator running
    the different versions of Android.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在物理设备或模拟器上运行应用程序。如果你想查看三个不同的主题，你需要有一个运行不同版本 Android 的设备或模拟器。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we are using the Android resource selection process to assign
    the appropriate theme (which is a resource) based on the API version. Since we
    need to choose the theme based on the OS version in which it was released, we
    created two new values folders specifying the API version. This gives us a total
    of three `styles.xml` files: the default style, one in the `values-v11` directory,
    and the last in the `values-v21` directory.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们使用 Android 资源选择过程来根据 API 版本分配适当的主题（主题也是一种资源）。由于我们需要根据其发布的操作系统版本选择主题，因此我们创建了两个指定
    API 版本的新 values 文件夹。这样，我们总共有三个`styles.xml`文件：默认样式，`values-v11`目录中的样式，以及`values-v21`目录中的样式。
- en: Notice the same theme name is defined in all three `styles.xml` files. This
    is how the resource selection works. Android will use the resource from the directory
    that best fits our values. Here we are using the API level, but other criteria
    are available as well. It is very common to define separate resources based on
    other criteria, such as screen size, screen density, and even orientation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，相同的主题名称在所有三个`styles.xml`文件中都有定义。这就是资源选择的工作方式。Android 将使用最适合我们值的目录中的资源。这里我们使用
    API 级别，但也有其他标准可供使用。根据其他标准（如屏幕大小、屏幕密度，甚至是方向）定义单独的资源是非常常见的。
- en: The last step was to specify our new theme as the application theme, which we
    did in the Android Manifest.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上一步是在 Android Manifest 中将我们的新主题指定为应用主题。
- en: There's more…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: For more information on resource selection, see the *Using designated folders
    for screen-specific resources* topic in the previous recipe, *Using graphics to
    show button state*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有关资源选择的更多信息，请参阅前一个食谱“*使用图像显示按钮状态*”中的“*使用针对屏幕特定资源的指定文件夹*”主题。
