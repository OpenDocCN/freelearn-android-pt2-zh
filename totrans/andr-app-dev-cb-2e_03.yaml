- en: Chapter 3. Views, Widgets, and Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a widget into a layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using graphics to show the button state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a widget at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a style to a View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning a style into a theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a theme based on the Android OS version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **widgets** can refer to several different concepts in Android. When
    most people talk about widgets, they are referring to **app widgets**, which are
    typically seen on the home screen. App widgets are like mini applications by themselves
    as they usually provide a subset of functionality, based on their main application.
    (Usually, most app widgets are installed along with an application, but that is
    not a requirement. They can be standalone apps in a widget format.) A common app
    widget example is a weather application that offers several different app widgets
    for the home screen. [Chapter 5](ch05.html "Chapter 5. Exploring Fragments, AppWidgets,
    and the System UI"), *Exploring Fragments, AppWidgets, and the System UI*, will
    discuss home screen app widgets and provide recipes to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: When developing for Android, the term widgets generally refers to specialized
    Views placed in the layout files, such as a Button, TextView, CheckBox, and so
    on. In this chapter, we will focus on widgets for app development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the list of widgets provided in the **Android SDK**, open a layout file
    in Android Studio, and click on the **Design** tab. Along the left side of the
    Design view, you will see the **Widget** section below the **Layout** section,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B05057_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the list, the **Android SDK** provides many useful widgets—from
    a simple TextView, Button, or Checkbox to the much more complex widgets such as
    the Clock, DatePicker, and Calendar. As useful as the built-in widgets are, it's
    also very easy to expand on what's provided in the SDK. We can extend an existing
    widget to customize its functionality, or we can create our own widget from scratch
    by extending the base View class. (We will provide an example of this in the *Creating
    a custom component* recipe later.)
  prefs: []
  type: TYPE_NORMAL
- en: The visual look of widgets can also be customized. These settings can be used
    to create **styles**, which in turn can be used to create **themes**. Just like
    with other development environments, creating a theme offers the benefit of easily
    changing the appearance throughout our entire application with minimal effort.
    Lastly, the Android SDK also provides many built-in themes and variations, such
    as the Holo theme from Android 3/4 and the Material theme from Android 5\. (Android
    6.0 did not release a new theme.)
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a widget into a layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have seen from previous recipes, **widgets** are declared in a layout
    file, or created in code. For this recipe, we will go step-by-step to add a button
    with the Android Studio Designer. (For later recipes, we will just show the layout
    XML from the TextView.) After creating the button, we will create an `onClickListener()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project in Android Studio and call it `InsertWidget`. Use the default
    options for creating a Phone and Tablet project and select **Empty Activity**
    when prompted for the Activity Type. You can delete the default TextView (or leave
    it) as it will not be needed for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To insert a widget into a layout, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **activity_main.xml** file in Android Studio and click on the **Design**
    tab.![How to do it...](img/B05057_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find **Button** in the widget list and drag it to the center of the activity
    screen on the right. Android will automatically set the layout parameters based
    on where the button is dropped. If you center the button as shown in the screenshot,
    Android Studio will set those parameters in the XML.![How to do it...](img/B05057_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To view the `xml` created, click on the **Text** tab as shown in the following
    screenshot. See how the button is centered using the `RelativeLayout` parameters.
    Also, take note of the default ID as we will need it for the next step.![How to
    do it...](img/B05057_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the `MainActivity.java` file to edit the code. Add the following
    code to the `onCreate()` method to set up the `onClickListener()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the UI with the Android Studio is as simple as dragging and dropping
    Views. You can also edit the properties of the Views directly in the **Design**
    tab. Switching to the XML code is as simple as hitting the **Text** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we did here is very common in Android development—creating the UI in XML,
    then hooking up the UI components (Views) in the Java code. To reference a View
    from code, it must have a resource identifier associated with it. This is done
    using the `id` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our `onClickListener` function displays a pop-up message on the screen called
    **Toast**, when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look again at the format of the identifier we created previously, `@+id/button`.
    The `@` specifies this is going to be a resource and the **+** sign indicates
    a new resource. (If we failed to include the plus sign, we would get a compile
    time error stating **No resource matched the indicated name**).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Butter Knife (Open Source Project)—Field and method binding for Android Views:
    [http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using graphics to show button state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve talked about the versatility of Android Views and how behavior and visual
    appearance can be customized. In this recipe, we will create a drawable **state
    selector**, which is a resource defined in XML that specifies the drawable to
    use based on the View''s state. The most commonly used states, along with the
    possible values, include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state_pressed=["true" | "false"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state_focused=["true" | "false"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state_selected=["true" | "false"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state_checked=["true" | "false"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state_enabled=["true" | "false"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To define a state selector, create an XML file with the `<selector>` element,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `<selector>` element, we define an `<item>` to identify the drawable
    to be used based on the specified state(s). Here''s an example `<item>` element
    using multiple states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to remember the file is read from top to bottom so the first
    item that meets the state requirements will be used. A default drawable, one with
    no states included, would need to go last.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will use a state selector to change the background color
    based on the `ToggleButton` state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `StateSelector` using the
    default **Phone & Tablet** options. When prompted for the **Activity Type**, select
    **Empty Activity**. To make it easier to type the code for this recipe, we will
    use a color as the graphic to represent the button state.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating the state selector, which is a resource file defined
    with XML code. We will then set up the button to use our new state selector. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `XML` file in the `res/drawable` folder and call it: `state_selector.xml`.
    The file should consist of the following XML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open the **activity_main.xml** file and drop in a `ToggleButton` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main concept to understand here is the Android State Selector. As shown
    in Step 2, we created a resource file which specified a **drawable** (a color
    in this case) based on `state_checked`.
  prefs: []
  type: TYPE_NORMAL
- en: Android supports many other state conditions besides checked. While typing in
    `android:state`, look at the autocomplete dropdown to see the list of other options.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the drawable resource created (the XML from step 1), we just have
    to tell the view to use it. Since we wanted the background color to change based
    on the state, we use the `android:background` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`state_selector.xml` is a drawable resource that can be passed to any property
    that accepts a drawable. We could, for example, replace the button in a checkbox
    with the following XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we wanted actual images for the graphics instead of just a color change?
    This is as easy as changing the drawable referenced in the item state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code available for download uses two graphic images, downloaded
    from: [https://pixabay.com/](https://pixabay.com/) (this was chosen because the
    images are free to use and didn''t require a login.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your desired images, place them in the `res/drawable` folder.
    Then, change the state item line in the XML to reference your images. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: (Change `check_on` to match your image resource name.)
  prefs: []
  type: TYPE_NORMAL
- en: Using designated folders for screen-specific resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When Android encounters a `@drawable` reference, it expects to find the target
    in one of the `res/drawable` folders. These are designed for different screen
    densities: `ldpi` (low dots per inch), `mdpi` (medium), `hdpi` (high), and `xhdpi`
    (extra-high) and they allow us to create resources for specific target devices.
    When an application is running on a specific device, Android will load resources
    from the designated folder that most closely matches the actual screen density.'
  prefs: []
  type: TYPE_NORMAL
- en: If it finds this folder empty, it will try the next nearest match and so on
    until it finds the named resource. For tutorial purposes, a separate set of files
    for each possible density is not required, and so placing our images in the `drawable`
    folder is a simple way to run the exercise on any device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of resource identifiers available, visit [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For another example on Android resource selection, see the recipe on *Selecting
    theme based on the OS version later*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a widget at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, generally, the UI is declared in `XML` files and then modified
    during runtime through the Java code. It is possible to create the UI completely
    in Java code, though for a complex layout, it would generally not be considered
    best practice.
  prefs: []
  type: TYPE_NORMAL
- en: The GridView example from the previous chapter was created in code. But unlike
    the GridView recipe, in this recipe, we are going to add a view to the existing
    layout defined in `activity_main.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `RuntimeWidget`. Select the
    **Empty Activity** option when prompted for the **Activity type**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by adding an ID attribute to the existing layout so we can access
    the layout in code. Once we have a reference to the layout in code, we can add
    new views to the existing layout. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res/layout/activity_main.xml` and add an ID attribute to the main
    `RelativeLayout`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Completely remove the default `<TextView>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.java` file so we can add code to the `onCreate()` method.
    Add the following code (after `setContentView())` to get a reference to the `RelativeLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a DatePicker and add it to the layout with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is hopefully very straightforward code. First, we get a reference to the
    parent layout using `findViewById`. We added the ID to the existing RelativeLayout
    (in step 1) to make it easier to reference. We create a DatePicker in code and
    add it to the layout with the `addView()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we wanted to create the entire layout from code? Though it may not
    be considered best practice, there are times when it is certainly easier (and
    less complex) to create a layout from code. Let''s see how this example would
    look if we didn''t use the layout from `activity_main.xml`. Here''s how the onCreate()
    would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it's really not that different. If you create a view in code
    and want to reference it later, you either need to keep a reference to the object,
    or assign the view an ID to use `findViewByID()`. To give a view an ID, use the
    **setID()** method by passing in **View.generateViewId()** (to generate a unique
    ID) or define the ID using **<resources>** in xml.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in previous recipes, the Android SDK provides a wide range of
    components. But what happens when you can't find a prebuilt component that fits
    your unique needs? You can always create your own!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will walk through creating a custom component that derives
    from the View class, just like the built-in widgets. Here''s a high-level overview:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class that extends View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create custom constructor(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `onMeasure()`, and the default implementation returns a size of 100
    x 100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `onDraw()`, and the default implementation draws nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define custom methods and listeners (such as on<*Event*>()).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement custom functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While overriding `onMeasure()` and `onDraw()` is not strictly required, the
    default behavior is likely not what you would want.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project in Android Studio and call it `CustomView`. Use the default
    wizard options, including the **Phone & Tablet SDK** and select **Empty Activity**
    when prompted for the Activity type. Once the project files are created and open
    in Android Studio, you are ready to begin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a new class for our custom component to derive from the Android
    View class. Our custom component could be a subclass of an existing class, such
    as the Activity, but we will create it in a separate file to make it easier to
    maintain. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new Java class and also call it `CustomView`. This is where
    we will implement our custom component, as described in the introduction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class constructor so it extends View. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `Paint` object for the class, which will be used in the onDraw():'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a default constructor, which requires the activity `Context`, so we
    can inflate the view. We will set the paint properties here as well. The constructor
    should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the onDraw() method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, inflate our custom view in `MainActivity.java` by replacing the `setContentView()`
    with our view, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application on a device or emulator to see it in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by extending the View class, just as the built-in components do. Next,
    we create the default constructor. This is important as we need the context to
    pass down to the super class, which we do with the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We need to override `onDraw()`, otherwise, as mentioned in the introduction,
    our custom view won't display anything. When `onDraw()` is called, the system
    passes in a **Canvas** object. The canvas is the area of the screen for our view.
    (Since we didn't override `onMeasure()`, our view would be 100 x 100, but since
    our entire activity consists of just this view, we get the whole screen as our
    canvas.)
  prefs: []
  type: TYPE_NORMAL
- en: We created the `Paint` object at the class level, and as `final`, to be more
    efficient with memory allocation. (`onDraw()` should be as efficient as possible
    since it can be called multiple times per second.) As you see from running the
    program, our onDraw() implementation just sets the background color to cyan and
    prints text to the screen (using `drawText()`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, there's a lot more. We've just touched the surface of what you can
    do with a custom component. Fortunately, as you see from this example, it doesn't
    take a lot of code to get basic functionality. We could easily spend an entire
    chapter on topics such as passing layout parameters to the view, adding listener
    callbacks, overriding `onMeasure()`, using our view in the IDE, and so on. These
    are all features you can add as your needs dictate.
  prefs: []
  type: TYPE_NORMAL
- en: While a custom component should be able to handle any solution, there are other
    options that might require less coding. Extending an existing widget is often
    sufficient without the overhead of a custom component from scratch. If what you
    need is a solution with multiple widgets, there's also the **compound control**.
    A compound control, such as a combo box, is just two or more controls grouped
    together as a single widget.
  prefs: []
  type: TYPE_NORMAL
- en: A compound control would generally extend from a layout, not a View, since you
    will be adding multiple widgets. You probably wouldn't need to override onDraw()
    and onMeasure(), as each widget would handle the drawing in their respective methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on drawing, look at *Chapter 9, Graphics and Animation*.
    For full details on the View object, refer to the Android Developer resource at:
    [http://developer.android.com/reference/android/view/View.html](http://developer.android.com/reference/android/view/View.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a style to a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **style** is a collection of property settings to define the look of a View.
    As you have already seen while defining layouts, a view offers many settings to
    determine how it looks, as well as functions. We have already set a view height,
    width, background color, and padding, plus there are many more settings such as
    text color, font, text size, margin, and so on. Creating a style is as simple
    as pulling these settings from the layout and putting them in a style resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will go through the steps of creating a style and hooking
    it up to a view.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Cascading Style Sheets, Android Styles allow you to specify your
    design settings separate from the UI code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Android Studio project and call it `Styles`. Use the default wizard
    options to create a Phone & Tablet project and select Empty Activity when prompted
    for the Activity. By default, the wizard also creates a `styles.xml` file, which
    we will use for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create our own style resource to change the appearance of a `TextView`.
    We can add our new style to the `styles.xml` resource created by Android Studio
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the default `styles.xml` file located in `res/values`, as shown here:![How
    to do it...](img/B05057_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a new style called `MyStyle` by adding the following XML below
    the existing `AppTheme` style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now tell the view to use this style. Open the `activity_main.xml` file and
    add the following attribute to the existing `<TextView>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Either run the application or view the results in the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **style** is a resource, defined by using the `<style>` element nested in
    a `<resources>` element of an xml file. We used the existing `styles.xml` file,
    but that is not a requirement, as we can use whatever filename we want. As seen
    in this recipe, multiple `<style>` elements can be included in one xml file.
  prefs: []
  type: TYPE_NORMAL
- en: Once the style is created, you can easily apply it to any number of other views
    as well. What if you wanted to have a button with the same style? Just drop a
    button in the layout and assign the same style.
  prefs: []
  type: TYPE_NORMAL
- en: What if we created a new button, but wanted the button to expand the full width
    of the view? How do we override the style for just that view? Simple, specify
    the attribute in the layout as you've always done. The local attribute will take
    priority over the attribute in the **style**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another feature of styles**: inheritance**. By specifying a parent
    when defining the style, we can have styles build on each other, creating a hierarchy
    of styles. If you look at the default style in `styles.xml`: `AppTheme`, you will
    see the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`AppTheme` inherits from a theme defined in the Android SDK.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to inherit from a style you have created yourself, there is a shortcut
    method. Instead of using the parent attribute, you can specify the parent name
    first, followed by a period, then the new name, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<style name="MyParent.MyStyle" >`'
  prefs: []
  type: TYPE_NORMAL
- en: You saw how to specify a style for a view, but what if we wanted all the TextViews
    in our application to use a specific style? We'd have to go back to each TextView
    and specify the style. But there's another way. We can include a `textViewStyle`
    item in a style to automatically assign a style to all TextViews. (There's a style
    for each of the widget types so you can do this for Buttons, ToggleButtons, TextViews,
    and so on.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the style for all TextViews, add the following line to the `AppTheme`
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since the theme for our application already uses `AppThem`, we only have to
    add that single line to `AppTheme` to have all our TextViews styled with our custom
    `MyStyle`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android Design Support Library at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://android-developers.blogspot.de/2015/05/android-design-support-library.html](http://android-developers.blogspot.de/2015/05/android-design-support-library.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Turning a style into a theme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **theme** is a style applied to an Activity or the whole application. To set
    a theme, use the `android:theme` attribute in the `AndroidManifest.xml` file.
    The `theme` attribute applies to the `<Application>` element as well as the `<Activity>`
    elements. All views within that element will be styled with the theme specified.
  prefs: []
  type: TYPE_NORMAL
- en: It's common to set the Application theme, but then override a specific Activity
    with a different theme.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we set the `textViewStyle` using the AppTheme style
    (which the wizard created automatically.) In this recipe, you will learn how to
    set both the Application and Activity themes.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the style settings we have already explored, there are additional
    style options we didn't discuss because they don't apply to a View, they apply
    to the window as a whole. Settings such as hiding the application title or Action
    Bar and setting the window background, just to name a few, apply to the window
    and therefore must be set as a theme.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we are going to create a new theme based on the auto-generated
    `AppTheme`. Our new theme will modify the window appearance to make it a **dialog**.
    We will also look at the `theme` settings in the `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project in Android Studio and call it `Themes`. Use the default
    wizard options and select the **Empty Activity** when prompted for the Activity
    type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by adding a new theme to the existing `styles.xml` file to make our
    activity look like a dialog. Here are the steps to create the new theme and set
    activity to use the new theme:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since **themes** are defined in the same resource as **styles**, open the `styles.xml`
    file located in `res/values` and create a new style. We will create a new style
    based on the AppTheme already provided, and set `windowIsFloating`. The XML will
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the Activity to use this new dialog theme. Open the `AndroidManifest.xml`
    file and add a `theme` attribute to the Activity element, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that both Application and Activity will now have a theme specified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now run the application on a device or emulator to see the dialog theme in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our new theme `MyDialog` inherits the base `AppTheme` using the alternative
    parent declaration, since `AppTheme` is defined in our code (and not a system
    theme). As mentioned in the introduction, some settings apply to the window as
    a whole, which is what we see with the `windowIsFloating` setting. Once our new
    theme is declared, we assign our theme to the activity in the `AndroidManifest`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed we could have just added the `windowIsFloating` to the
    existing `AppTheme` and been done. Since this application only has one Activity,
    the end result would be the same, but then, any new activities would also appear
    as a dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting theme based on the Android version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most users prefer to see apps using the latest themes provided by Android. **Now
    supports Material Theme** is common for apps upgrading to Android Lollipop. To
    be competitive with the many other apps in the market, you'll probably want to
    upgrade your app as well, but what about your users who are still running older
    versions of Android? By setting up our resources properly, we can use **resource
    selection** in Android to automatically define the parent theme based on the Android
    OS version the user is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s explore the three main themes available in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: Theme – Gingerbread and earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme.Holo – Honeycomb (API 11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme.Material – Lollipop (API 21)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (As of writing this, there does not appear to be a new theme in Android 6.0.)
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to properly set up the resource directories for Android
    to use the most appropriate theme based on the API version the app is running
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project in Android Studio and call it `AutomaticThemeSelector`.
    Use the default wizard option to make a Phone & Tablet project. Select the **Empty
    Activity** when prompted for the Activity Type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on the API version selected, Android Studio may use the App Compatability
    libraries. We don''t want to use these libraries for this project since we want
    to explicitly set which theme to use. We will start by making sure we are extending
    from the generic Activity class, then we can add our new style resources to select
    the theme based on the API. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make sure `MainActivity` extends from `Activity` and not `AppCompatActivity`.
    Open `ActivityMain.java` and if necessary, change it to read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `activity_main.xml` and drop in two views: a Button and a Checkbox.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `styles.xml` and remove `AppTheme` as it will not be used. Add our new
    theme so the file reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to create two new values folders for API 11 and 21\. To do this, we
    need to change Android Studio to use the Project view rather than the Android
    view. (Otherwise, we won't see the new folders in the next step.) At the top of
    the **Project** window, it shows **Android**, change this to **Project** for the
    Project View. See the following screenshot:![How to do it...](img/B05057_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory by right-clicking on the `res` folder and navigating
    to **New** | **Directory**, as shown in this screenshot:![How to do it...](img/B05057_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following name for the first directory: `values-v11`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Repeat this for the second directory using `values-v21`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create a `styles.xml` file in each of the new directories. (Right-click
    on the `values-v11` directory and go to the **New** | **File** option.) For `values-v11`,
    use the following style to define the Holo theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to tell the application to use our new theme. To do this,
    open `AndroidManifest.xml` and change the `android:theme` attribute to `AutomaticTheme`.
    It should read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the application on a physical device or emulator. If you want to see
    the three different themes, you will need to have a device or emulator running
    the different versions of Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we are using the Android resource selection process to assign
    the appropriate theme (which is a resource) based on the API version. Since we
    need to choose the theme based on the OS version in which it was released, we
    created two new values folders specifying the API version. This gives us a total
    of three `styles.xml` files: the default style, one in the `values-v11` directory,
    and the last in the `values-v21` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the same theme name is defined in all three `styles.xml` files. This
    is how the resource selection works. Android will use the resource from the directory
    that best fits our values. Here we are using the API level, but other criteria
    are available as well. It is very common to define separate resources based on
    other criteria, such as screen size, screen density, and even orientation.
  prefs: []
  type: TYPE_NORMAL
- en: The last step was to specify our new theme as the application theme, which we
    did in the Android Manifest.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on resource selection, see the *Using designated folders
    for screen-specific resources* topic in the previous recipe, *Using graphics to
    show button state*.
  prefs: []
  type: TYPE_NORMAL
