- en: Chapter 1. Turn On the Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any idea should start with a prototype. It doesn't matter whether it's a game,
    a web or mobile application, or a generic software component. Every time we want
    to deliver something to our final users, we have to create a prototype first.
    This is the most important step because it's when we start to face our first difficulties
    and when we may change some important aspects of our project.
  prefs: []
  type: TYPE_NORMAL
- en: If we are writing a software component, the first prototype isn't too expensive
    because what we need is our time and passion. However, this isn't applicable when
    our project has some hardware parts because it could be too expensive to afford
    all the required components. This statement was true until programmers, engineers
    and open source lovers started to release projects such as **Arduino**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fast prototyping boards let people realize projects with cheap or reused old
    components, and this, together with the **Do It Yourself** (**DIY**) philosophy,
    allows the creation of a huge community that spreads all over the world. This
    is where the UDOO board plays an important role in the makers'' community: the
    hardware prototyping ecosystem, together with the traditional way to write software
    applications, represents a powerful combination for interactive projects creation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore more details about the UDOO board, focusing
    on the elements that are important to get started. In particular, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the UDOO platform and its main characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the board with the Android operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the development environment for Arduino and Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping a simple Android application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an Android application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the UDOO platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UDOO board is designed to offer us great flexibility with the tools, the
    programming language, and the environment in which we build the first prototype.
    The main goal of the board is to take part in the era of the *Internet of Things*
    and this is why an embedded Atmel SAM3X8E ARM Cortex-M3 processor is its first
    building block.
  prefs: []
  type: TYPE_NORMAL
- en: This processor is the same that powers the Arduino Due board and it's fully
    compliant to Arduino pinout. The result of this feature is that the board is compatible
    with all Arduino Due shields and most of Arduino Uno shields, so developers can
    convert and reuse their old programs and circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The UDOO I/O pins are 3.3V compliant. For instance, if you're using a sensor
    powered by 5V that outputs the signal to UDOO pins at 3.3V, then you're fine.
    On the other hand, if the sensor outputs the signal to UDOO at 5V, it will damage
    your board. Every time you're using a shield or a sensor, be aware of provided
    output voltage to UDOO pins. This precaution is the same for a traditional Arduino
    Due board.
  prefs: []
  type: TYPE_NORMAL
- en: The second building block is a powerful Freescale i.MX 6 ARM Cortex-A9 processor,
    which is shipped in Dual and Quad core versions. The official supported operating
    system is *UDOObuntu*, which is a *Lubuntu 12.04 LTS armHF* based operating system
    that ships out of the box with many pre-installed tools to be up and running quickly.
    Indeed, after your first boot, you have a fully configured development environment
    to program the onboard Arduino from the board itself.
  prefs: []
  type: TYPE_NORMAL
- en: Despite that, what makes UDOO really different from other boards is the **Android
    support**. With the capability to run smoothly, this operating system is a great
    opportunity for novice or experienced Android developers because they can create
    a new kind of real-world application that is powered by the Android user interface,
    its powerful design patterns, and even by other developers' applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers can choose to write their real-word applications using the Linux
    operating system. In this case, they can write web services or desktop applications
    using many well-known programming languages such as Python, Javascript (Node.js),
    Php, and Java. However, we will focus on application development under Android.
  prefs: []
  type: TYPE_NORMAL
- en: The latest building block is related to all I/O components. UDOO could be purchased
    with an internal Wi-Fi and a Gigabit Ethernet, which are recognized by both Linux
    and Android. It also offers **HDMI** (**High-Definition Multimedia Interface**)
    output connection and is shipped with an integrated **Transistor-Transistor Logic**
    (**TTL**) to **Low-Voltage Differential Signaling** (**LVDS**) expansion slot
    so that developers can connect an external LVDS touch screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the course of this book, it is assumed that you're connecting UDOO to
    an external monitor through the HDMI cable. However, if you own an external LVDS
    panel, you can proceed with the connection just before the *Our first run* section
    in this chapter. To let Android use the external panel, you should follow some
    steps that you can find in the official documentation at [http://www.udoo.org/faq-items/how-do-i-set-up-my-lvds/](http://www.udoo.org/faq-items/how-do-i-set-up-my-lvds/).
  prefs: []
  type: TYPE_NORMAL
- en: Another great component that is officially supported is the camera module that
    is easy to plug in the board and can be used for projects that require computer
    vision or image analysis. The last integrated component is the audio card with
    a fully functional audio playback and recording through an external microphone.
  prefs: []
  type: TYPE_NORMAL
- en: The mix of these building blocks, together with the Internet access and many
    Android APIs, gives us the opportunity to build real-world applications that listen
    to the environment and talk to devices with a board that can take part in the
    *Internet of Things*.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have an idea about a list of UDOO components that we may use to start building
    amazing projects. However, before we continue, we need to configure our board
    to run the Android operating system and also our development environment so that
    we can start writing and deploying our first application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All prototypes you build in this book are based on Android KitKat 4.4.2 that
    is the latest supported version at the time of this writing. During the course
    of this book you will build many projects that make use of the **Android Support
    Library** to ensure compatibility with newer Android versions that the UDOO board
    will support.
  prefs: []
  type: TYPE_NORMAL
- en: The UDOO board doesn't have internal storage or a built-in boot program because
    it relies on external storage, a microSD card, in which you can install a bootloader
    and a compatible operating system. The easiest way to create a bootable microSD
    card, is to download and copy a precompiled image, though it's possible to create
    a clean operating system using released binaries and kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.udoo.org/downloads/](http://www.udoo.org/downloads/) points to
    the official UDOO download page that contains the links for all the available
    precompiled images.'
  prefs: []
  type: TYPE_NORMAL
- en: Among Linux images, we can find and download the latest supported version of
    Android KitKat 4.4.2\. As stated earlier, UDOO comes in two different versions
    with dual and quad processors so we must download the right version, according
    to the owned platform.
  prefs: []
  type: TYPE_NORMAL
- en: Installing from Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the Android image from Windows, you need some extra tools to unpack
    and copy the image into the microSD card. The downloaded `.zip` file is in 7-Zip
    compression format, so you need to install a third-party unarchive program such
    as 7-Zip. When the extracting process is done, we have an uncompressed `.img`
    file ready for copy on an empty card.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write the uncompressed image into our microSD card, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert your microSD card in the built-in slot reader or external card reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Format the card using the `FAT32` filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To write the image on the micsoSD card, we need to use the Win32DiskImager tool.
    Download it from [http://sourceforge.net/projects/win32diskimager/](http://sourceforge.net/projects/win32diskimager/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application, but bear in mind that if we are using Windows 7 or Window
    8.x, we have to right-click on `Win32DiskImager.exe` executable and be sure to
    select the **Run as administrator** option from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Win32DiskImager is a tool that writes raw disk images using low-level instructions.
    This means that you need to exactly follow the next steps and be really sure that
    you correctly select the output device. If this option is wrong, you might lose
    all your data from an unwanted storage memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the application starts, you can see the main window, as illustrated in
    the following screenshot:![Installing from Windows](img/1942OS_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the application's main window, in the **Image File** box, choose the `.img`
    file previously extracted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the microSD drive accurately on the **Device** dropdown and bear in mind
    that if we use the wrong drive, we can destroy all our data on the computer's
    hard disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Write** button and wait for the process to complete in order
    to have a bootable Android operating system in the microSD card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing from Mac OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the Android image from Mac OS X, we need a third-party tool to unpack
    the downloaded `.zip` file, because it's in 7-Zip compression format and we can't
    use the built-in unarchive software. We have to download software such as Keka,
    which is freely available at [http://www.kekaosx.com/](http://www.kekaosx.com/).
  prefs: []
  type: TYPE_NORMAL
- en: If we love the Mac OS X terminal, we can use the Homebrew package manager that
    is available at [http://brew.sh/](http://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, from the command line, we can simply install the `p7zip` package
    and use the `7za` utility to unpack the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To proceed and write the uncompressed image into our microSD card, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the **Terminal** application and enter into the folder in which we have
    downloaded and extracted the Android image. Assuming `Downloads` is the name of
    that folder, we can issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the list of all mounted devices with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list of all systems and internal hard drive partitions will be similar to
    the following screenshot:![Installing from Mac OS X](img/1942OS_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the microSD card using the built-in or external card reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Format the microSD card through the Disk Utility application that is already
    available in our system. Launch it and select the correct disk from the list on
    the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the main panel of the window, choose the **Erase** tab from the upper menu
    and select the **MS-DOS (FAT)** filesystem in the **Format** dropdown. When you
    are ready, click on the **Erase** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Terminal application, launch the previous command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list of mounted partitions has been changed, as we see in the following
    screenshot:![Installing from Mac OS X](img/1942OS_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can assume that the missing device, during the first run, is our microSD
    card, so we have to bear in mind the new value under the **Filesystem** column.
    If you look at the previous screenshot, our partition name is `/dev/disk1s1` while
    it isn't `/dev/disk0s2` because it's our hard disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have found the correct partition, we have to unmount it using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To write the image into the microSD card, we must find the raw disk device so
    that we can erase and write the Android image into the card. Assuming that the
    partition name found before was `/dev/disk1s1`, the related raw disk will be `/dev/rdisk1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to use the `dd` tool. This command writes raw disk images using
    low-level instructions. This means that you need to exactly follow the next steps
    and be really sure that you choose the correct disk device, because if it is wrong,
    you can lose all your data from an unwanted storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the image previously extracted into the microSD card using `dd` with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A full example of the previous command is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we launch the command nothing seems to happen, but actually, `dd` is writing
    the Android image in the background. Once the process is complete, it outputs
    the transferred bytes report, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have our bootable Android operating system and we can eject the microSD
    card with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing from Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the Android image from Linux, we need a third-party tool to unpack
    the downloaded `.zip` file. Because the file is in 7-Zip compression format, we
    need to install the `p7zip` package porting from the command line using the package
    manager of our distribution. Then we can use the `7za` utility to unpack the file
    or any other graphical unarchiver that makes you comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can proceed to write the uncompressed image into our microSD card using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Linux Terminal and enter into the folder where we have downloaded
    and extracted the Android image. Assuming the file is in our `Downloads` folder,
    we can issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Attach the microSD card using the built-in or external card reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the correct device name through the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is a filtered list of all the devices found, and it contains, among
    others output lines, something like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, `/dev/sda` is our hard disk while `/dev/sdb` is our microSD card.
    If this is not your case and you are using an internal card reader, it's possible
    that the device is named `/dev/mmcblk0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you've found the right device name, keep it in mind so that we can use
    it later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Find all the mounted partitions of the above device through the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the previous command generates an output, find the partition name available
    in the first column of the output and unmount any listed partitions through the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`dd` is a tool that writes raw disk images using low-level instructions. This
    means that you need to exactly follow the next steps and be really sure that you
    choose the correct disk device because, if it is wrong, you can lose all your
    data from an unwanted storage memory.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the image previously extracted to the above device name using the `dd`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assuming `/dev/sdb` is our microSD card, the following is a full example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we launch the command nothing seems to happen, but actually, `dd` is writing
    the image in the background. Once the process is complete, it outputs the transferred
    bytes report, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have our bootable Android operating system and we can eject the microSD
    card with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our first run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a bootable microSD card, we can insert it into our UDOO board,
    use our external monitor or LVDS panel and connect a mouse and a keyboard. After
    the power is switched on, the Android logo shows up and when the loading process
    is finished, we can finally see the Android home interface.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Android in our UDOO board is fully functional, it''s time to configure
    the development environment. Every project we''re going to build is composed of
    two different running applications: the first is the physical application composed
    of an Arduino program capable of controlling an external circuit through UDOO
    I/O pins; the second one, is an Android application that will run on the board
    and that deals with the user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we have to write two different applications that interact with each
    other, we need to configure our development environment with two different IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Arduino IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can start to upload our programs, we need to install the *microUSB
    serial port driver* so that we can correctly communicate with onboard Arduino.
    The USB to the **Universal Asynchronous Receiver/Transmitter** (**UART**) driver,
    compatible with the CP210x converter available on the board, can be downloaded
    from
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx](http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: Here we have to choose the correct version according to our operating system.
    Once the download is complete, we can extract the archive and double-click on
    the executable to proceed with the installation. When the installation process
    is complete, we may need to restart the system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the microUSB bridge driver is working, from the Arduino website, we
    have to download the IDE 1.5x beta because, at the moment, the beta version is
    the only one that supports Arduino Due boards. The link [http://arduino.cc/en/Main/Software#toc3](http://arduino.cc/en/Main/Software#toc3)
    points directly to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To upload a new program, UDOO needs to receive the signals ERASE and RESET from
    the serial port before and after the upload, respectively. On the official Arduino
    Due board, this action is performed by the integrated ATmega16U2 microcontroller,
    which is missing in the UDOO board. The Arduino IDE will take care of this process,
    but if in the future you prefer to use another IDE, you will have to take care
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Installing in Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install in Windows, we have two different options: use the provided installer
    or use the archive file for nonadministrator installation. If we choose to use
    the installer, we can double-click on the executable. When the installer asks
    us which components we want to install, be sure to select all the checkboxes.
    If we choose to use the archive file instead of the installer, extract the file
    and put the result directory into your users folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing in Mac OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install in Mac OS X, we need to download the archive version. If we run an
    OS X version greater than 10.7, we can download the Java 7 version. In any other
    cases, or if you are not sure, download the Java 6 version.
  prefs: []
  type: TYPE_NORMAL
- en: When we finish the download, we have to double-click on the archive to proceed
    with the extraction and then drag-and-drop the Arduino application icon inside
    our `Applications` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Installing in Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install in Linux, we need to download the archive version supported by our
    32 or 64 bit architecture. Once the download has finished, we can extract the
    IDE and put it inside our `home` folder or in any other folder of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: First launch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have finished configuring the communication driver and the IDE
    with the correct patch, we can launch and see the Arduino IDE, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First launch](img/1942OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing and using Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'UDOO with an Android operating system acts like any other traditional Android
    device. This means we can use the standard toolchain, build system, and IDE used
    for the development of smartphones or tablets applications. At the moment, the
    available toolchains are related to two main IDEs: Eclipse and Android Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse is an open source IDE with an advanced plugin system that allows you
    to easily extend many of its core capabilities. This brought Google to develop
    an **Android Development Tool** (**ADT**) plugin to create an integrated development
    environment in which developers can write, debug, and package their Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio is a more recent project whose first beta was released in May
    2013 while the first stable release was in December 2014\. Based on IntelliJ IDEA,
    a well-known Java IDE, it's powered by the **Gradle** build system that combines
    the flexibility of **Ant** with the dependency management of **Maven**. All these
    characteristics, together with the increasing number of plugins, best practices,
    **Google Cloud Platform** integration, and third-party services integration such
    as **Travis CI**, make Android Studio a great choice for the development of future
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: All Android projects covered in this book are built using Android Studio, and
    if you are a novice or an experienced Android developer and Eclipse is your usual
    IDE, this could be a great opportunity to try the new Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to download the latest version of Android Studio for
    your operating system from [https://developer.android.com/sdk/](https://developer.android.com/sdk/).
  prefs: []
  type: TYPE_NORMAL
- en: When the download starts, we'll be redirected to the installation instructions
    related to our operating system, and when we finish the installation, we can start
    the IDE. During the first run, the IDE will make all the required checks to retrieve
    and install the latest available SDK, virtual device, and build system to let
    you start developing the first application. In the **Setup Wizard - SDK Settings**
    page, be sure to select the **Android SDK** and **Android Virtual Device** components
    and then click on **Next**. In the next page, you should accept all Android licenses
    and then click on **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the IDE is installed, we can start Android Studio. The following screenshot
    shows the main window when a project is not opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and using Android Studio](img/1942OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running your first Android application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Android is installed in our UDOO board and that all development environments
    are configured, we can start to write and deploy our first Android application.
    The following is the default pattern of other developers when they start to dive
    into a new technology. We are going to write and deploy a simple Android application
    that prints Hello World!.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bootstrap our first project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the main window of Android Studio, click on **Start a new Android Studio
    project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Application name** field, type `HelloWorld`; in **Company domain**,
    write your domain or `example.com` if you don't have any at the moment. Then,
    click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the form factors selection window, select **Phone and Tablet** and choose
    **API 19: Android 4.4 (KitKat)** in the **Minimum SDK**. Then, click on **Next**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the add activity page, for the purpose of this hello world application, select
    a **Blank Activity** option and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Activity Options** page, write *HelloWorld* in **Activity Name** and
    click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In next chapters, we will create applications from scratch, so we have to bear
    in mind the previous steps because we are going to repeat the process multiple
    times in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now Android Studio will start to download all Gradle requirements to prepare
    our build system. When the process is completed, we get our first HelloWorld application.
  prefs: []
  type: TYPE_NORMAL
- en: Without writing any lines of code, we have already created a deployable application.
    Now we have to connect our UDOO board using a microUSB to the USB cable. If we
    take a look at the board, we see two different microUSB ports. The first one on
    the left, that we will use in the next chapters, connects our computer to the
    serial port of both processors, so we can use it to upload the Arduino program
    to the UDOO microcontroller or we can use it to access to the Android system shell.
    The activated communication for the serial port depends on the state of J18 jumper,
    whether it's plugged or not. Instead, the microUSB port on the right connects
    our computer to the i.MX 6 processor that runs Android and that we will use to
    upload our Android applications. You can find more information about the processor
    communication at the official UDOO website [http://www.udoo.org/features/processors-communication/](http://www.udoo.org/features/processors-communication/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect our computer to the Android operating system for the application
    upload process, we need to use the right microUSB port colored in black in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running your first Android application](img/1942OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like we do in a traditional Android application, we can click from the top menu
    on **Run** and then on **Run app**. At this point, we need to choose a running
    device, but unfortunately, our list of available devices is empty. This problem
    occurs because of how the internal communication between processors works.
  prefs: []
  type: TYPE_NORMAL
- en: After the boot time, the connection is enabled between the two processors and
    plugging the microUSB cable will produce no effect. This happens because Android
    doesn't use the internal UART serial port during the communication with Arduino.
    It uses the **USB On-The-Go** (**OTG**) bus that allows devices to act as host
    and let other components such as flash drive, mouse, keyboard, or Arduino, in
    this case, to connect through it.
  prefs: []
  type: TYPE_NORMAL
- en: The i.MX 6 processor is physically connected to the OTG bus while the other
    side of the bus is connected both to Arduino and to the external microUSB connector.
    The current active connection can be changed using a software piloted switch.
    When the external OTG port is enabled, Android can communicate with an external
    computer via microUSB port but it can't send back any data to onboard Arduino.
    On the contrary, when the external OTG port is disabled, Android can communicate
    with Arduino but the connection with the computer is interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: The latter is our actual configuration and we need to switch the OTG port in
    order to enable the external communication with our computer to complete the application
    deployment. From Android, we have to go to the **Settings menu** and choose **Developer
    options**. There we need to select the **External OTG port enabled** checkbox.
    If the USB cable is connected, a popup will ask us to allow USB debugging. If
    this is our main computer, we may want to select **Always allow from this computer**
    and then click on **OK**. If this option is not checked, the popup will be shown
    every time we connect UDOO to our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bear in mind that every time we need to deploy our Android application, we need
    to enable the external OTG port. On the contrary, when our application is deployed
    and we need Android to communicate with Arduino, we need to disable the external
    OTG port.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our computer can see the UDOO board as a traditional Android device,
    we can try to deploy our application again. This time, in the **Choose Device**
    dialog, we can find a Freescale UDOO Android device. Select it and click on **OK**.
    Our first deployment is complete and now we can see the HelloWorld application
    on the connected monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some UDOO characteristics that distinguish this
    board from the others. One of the greatest differences is related to the full
    support of the Android platform that led us to install and configure the latest
    supported version on the board.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the necessary tools to start developing real-world applications
    and we configured our development environment to write Android applications and
    Arduino programs.
  prefs: []
  type: TYPE_NORMAL
- en: We had a brief introduction about how the communication between the two processors
    works and how we can switch the OTG port to enable external access for our first
    deployment. In the next chapter, we will start a new Android application from
    scratch that is capable of using and controlling a physical device built through
    a set of prototyping tools.
  prefs: []
  type: TYPE_NORMAL
