- en: Chapter 8. Designing Content-centric Activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*When you have a lot of data to display to the user, and you need a content
    presentation `Activity`. Generally, such types of Activities turn out to be content-centric.
    The main purpose of a content-centric `Activity` is to give the user as much of
    the information as possible while not overwhelming them. This is a common requirement
    of applications that perform some sort of search, or present any type of specialized
    information.*'
  prefs: []
  type: TYPE_NORMAL
- en: Shopping and related e-commerce applications are an ideal example of a content-centric
    application. Much of the effort in the design is dedicated to displaying information
    about the products on sale. If the users can't find the information about a product
    they are looking for, they will look somewhere else. For this reason, the product
    display must not only be attractive and easy to use, but also provide as much
    information as possible, without being cryptic or cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a content-centric layout is a user's profile page in a social-networking
    application. People generally have a lot to say about themselves, and if they
    don't, other people will often say a lot about them. These applications not only
    have a lot of information to present to the user, but the information varies widely
    in terms of quality and relevance. Just because one user thinks something is important,
    doesn't mean the next person will. In cases like these, it's also very important
    to have an interface that can be customized to the user's preferences (often just
    by re-organizing the order in which information is displayed), and is also able
    to draw the user's attention to new information or areas they may find interesting.
  prefs: []
  type: TYPE_NORMAL
- en: A great example of a good way to draw a user's attention is seen in a chat application.
    If the user has scrolled up, he/she is probably reading something that was said
    a few minutes ago. If a new message arrives, it's very rude to just scroll them
    to the new message, since they may well still be reading it. An audio tone to
    notify them of a new message is a common option, but will also draw others' attention
    to the user (this is a mobile device after all). The best option is a small animated
    icon at the bottom of the screen, possibly color-coded to tell the user the relevance
    of the message (if that is available). Such an icon could also be an interactive
    element, allowing the user to touch it in order to automatically scroll to the
    most recently posted message. This type of thinking is important when designing
    any application, but when building a content-centric `Activity,` putting some
    extra thought into your design is even more critical.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be exploring the different aspects to consider when
    displaying content to the user, as well as different ways in which content screens
    can be developed. Specifically, we''ll be exploring:'
  prefs: []
  type: TYPE_NORMAL
- en: Thought process when designing content displays on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How users use and view content screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `WebView` class to display content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building native layouts for displaying content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and styling text in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing attention to specific areas of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering design options when displaying content on an Android device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A content-centric `Activity` bears a strong resemblance to a web page, but has
    some key design considerations that people don't have in mind when creating a
    web page. For example, a touchscreen device generally doesn't have a software
    pointer, and so doesn't have any concept of a "roll over". However, many web pages
    are built using cursor roll over to drive everything from link highlighting to
    menus.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a content-centric `Activity`, you'll want to consider carefully
    the aesthetics of your design. The screen should avoid clutter since many elements
    may be interactive, presenting the user with additional information when touched.
    At the same time, you should attempt to minimize the need to scroll, especially
    horizontal scrolling. The need to keep information concise is often the motivator
    to make more of the elements interactive. As mentioned in previous chapters, it's
    a good idea to consider using icons instead of text where you can, and to organize
    the information in order of importance to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Also bear in mind that screen-sizes change. Some devices have a large number
    of pixels (such as the various Android Tablets), while others have tiny 3.5 inch
    screens. For this reason it's important to consider that while some people will
    be able to see all of the presented information on a single screen, others will
    be presented with three or four screens worth of content for the same amount of
    information.
  prefs: []
  type: TYPE_NORMAL
- en: A web page is a great way to quickly and easily put together a content-centric
    layout when working on an Android application. It has the advantage of having
    great HTML and CSS support from WebKit, and easy integration with the rest of
    your application. It can also be handled by an existing web-designer, or even
    just display a web page if your application is connected to a web-based system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A web page is however constrained (to some degree) to the layout structures
    dictated in HTML and CSS. While these are extremely flexible at one level, HTML
    and CSS layout development can also be a tedious and frustrating process even
    when only targeting a single rendering engine (in Android''s case: WebKit), if
    you are not used to building web-based systems. When it comes to animations and
    similar structures, you are further constrained by the performance of the HTML
    rendering engine, whether using JavaScript or CSS3 animations.'
  prefs: []
  type: TYPE_NORMAL
- en: Considering user behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any type of user interface, it's important to understand your user behavior
    and how they will interact with the screens you provide them with. In the context
    of large amount of content information, it's important to understand both what
    information is important, and how users will read and absorb that information.
  prefs: []
  type: TYPE_NORMAL
- en: While you may want to draw attention to a selected piece of information (such
    as price), running a looping animation to change the color of that element will
    distract the user from the other information on the screen. However, simply changing
    the font, placing the data in a box, or changing the text color can also have
    the desired effect. It's also important to consider how a user will interact with
    the screen. On a touchscreen device, users can and will touch almost every part
    of the screen. They'll also drag items that look movable, and use scroll gestures
    if the content appears to run over the screen length.
  prefs: []
  type: TYPE_NORMAL
- en: Most people scan information in the same way. When a user is presented with
    a screen for the first time, or with lots of information on it, their minds approach
    reading the information in more-or-less the same way. The following are illustrations
    of the various movement patterns a user's eyes will follow when scanning for important
    information on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Considering user behavior](img/4484OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll generally want to make sure that important information is in the areas
    where one arrow meets another. The most important area is the corner in which
    your user normally starts reading. For most Western users, this is the top-left
    corner of the screen, while Asian and Arab users will often start at the top-right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When designing a content screen, consider making the information in these areas
    stand out a little more than normal. This will create a "linger" time where the
    users' eyes will generally focus on that area a little longer than normal. This
    is why we normally put a logo on the top-left of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing user attention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost always, some information is more important than other information. You
    want your user to be able to pick-out the important information as quickly as
    possible, and get on with what they are doing. Once a person is familiar with
    your application, they may well stop reading the fine print altogether. This is
    a good thing, you're helping your users make better use of your application by
    letting them get on with their lives.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to draw attention to specific information, such as a product's
    name or price, it's a good idea to make use of the extensive options provided
    by the `TextView` class. Simply changing an item's color can make it stand out
    for the user. If you need to go further, consider adding a shadow, or placing
    the content in a "highlight box". As we've already discussed in [Chapter 7](ch07.html
    "Chapter 7. Animating Widgets and Layouts"), *Animating Widgets and Layouts*,
    animations can also be used to draw attention to specific areas of the user interface.
    A simple "blink" animation (consisting of a fade-out followed by a fade-in animation)
    can be used to draw the users' attention to a change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A more specific example: money**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are selling something to your user, and allowing them to choose between
    different shipping methods and packaging options, the total price will change
    based on their selections. Make sure that the total amount stands out by rendering
    it in a bold font. When the price is updated, cycle through a series of "intermediate"
    prices so that the total is graphically "counted up" or "counted down" to its
    new value.
  prefs: []
  type: TYPE_NORMAL
- en: Think carefully about the widgets that you'll want to make use of in your user
    interface. Instead of using the normal `TextView`, you may well want to place
    a piece of what would normally be a single field in a `TextSwitcher` (or something
    similar) to allow you to animate a single word or value.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying content with the WebView class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WebView` class (in the `android.webkit` package) is often a logical choice
    for content-centric designs and holds some very serious advantages over building
    the user interface and a normal Android XML layout resource. The `WebView` class
    offers you a single point at which you can place all of the content for a screen,
    and it handles all of its own history and scrolling, making your code very simple
    to write.
  prefs: []
  type: TYPE_NORMAL
- en: When displaying content that requires complex layout and/or lots of text content
    (which may require markup), the `WebView` class is a highly favorable option.
    Having built-in support for HTML and CSS mark up, it reduces the number of widgets
    that you'll need on the screen. Given that Android makes use of Web-Kit as a rendering
    engine, you also have many CSS3 structures available (such as CSS animations).
    Although the `WebView` is generally used for browser like networked applications
    where hyperlinks are very important, you can just as easily supply it with local
    content containing no links. You can also intercept link requests to allow navigation
    to other parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Generally when working with a `WebView` structure, you'll need some method by
    which you can generate the content that you will be displaying. In contrast to
    building the user interface in a layout resource, where you can simply ID the
    various `View` objects that you need to inject dynamic content into. That said,
    a full template engine is often much easier to work with than a hybrid of XML
    layout and Java code, although the ease of implementation is strongly dependant
    on both the skills available to you and the type of information you need to display
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Using a WebView object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work a bit with the `WebView` and give a more specific example on how it
    can be used to present large amounts of content, we'll be building an `Activity`
    to display a food recipe on the screen. For this example we'll be hard coding
    the actual recipe and the layout code to generate the HTML. In practice, you would
    want to make use of a template engine such as Velocity/FreeMarker or XSLT to generate
    the HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a recipe viewer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll notice that the following example doesn't use an XML layout resource,
    but rather creates the entire `Activity` in Java. In this example we use a `Recipe`
    object to generate HTML code into a `StringBuilder` for display. It's a simple
    but effective implementation. However, it requires that the Java code be modified
    if a change to the look and feel of the recipe is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project to contain the recipe reader application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new `Ingredient.java` source file in the root package of the new application
    to hold information for a single required ingredient, and open this new file in
    your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare fields for the `name`, `amount`, and `unit` required for a recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a constructor to take the parameters and assign them to the fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a getter method for each of fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the root package of the project, create a new source file named `Recipe.java`
    to contain a single recipe, and open it in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a field for the name of the `Recipe` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare another field to contain the list of ingredients required for this
    `Recipe`. We store these as an array of `Ingredient` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then declare an array of `String` objects that will contain the list of instructions
    that need to be followed for the `Recipe`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a constructor to accept the field data and assign it for storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a getter method for each of the three fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example the `Recipe` class is responsible for generating the HTML.
    Declare a new method named `toHtml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `DecimalFormat` object to handle the formatting of the volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `StringBuilder` object to build the HTML into:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the HTML headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append a first-level header element with the name of the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append a second-level header element to open the `ingredients` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open an unordered list to list the ingredients required for the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each `Ingredient` object open a list item for the new ingredient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the amount of the ingredient to the `StringBuilder` after formatting
    it with the `DecimalFormat` declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then append the measurement unit for the ingredient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now append the name of the ingredient to the `StringBuilder`, and close the
    `ingredient` list item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After closing the for loop, close the unordered list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a second-lever header opening the `Instructions` section of the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open another unordered list to render the recipe instructions into:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a for-each loop over the array of instructions to render them into the
    unordered list structure in the `StringBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the unordered list, and HTML headers, returning the `String` contents
    of the `StringBuilder` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `ViewRecipeActivity` Java source code in your editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate` method, directly after invoking `super.onCreate`, create
    a new `WebView` object passing `this` to it as its `Context`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `WebView LayoutParams` to take up all available screen space, since
    the `WebView` (much like a `ListView`) has built-in scrolling capabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Recipe` object to display in the `WebView`, the full recipe is at
    the end of this example section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the HTML content generated by the `Recipe` object into the `WebView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the content view of the `Activity` to the `WebView` object we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe viewer example shows a simple structure which can be extended in
    many different ways to present large amounts of information to the user in an
    easy-to-use format. Thanks to the fact that `WebView` works with HTML, it makes
    presenting non-interactive lists of information more appealing than working with
    a `ListView` or similar structures.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadData` method used previously is limited in that it doesn't allow for
    your page to easily reference external structures such as style sheets or images.
    You can work around this limitation by using the `loadDataWithBaseURL` method
    which works in much the same way, but renders the page relative to a specified
    URL, which may be online or local on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Recipe` object is considered responsible for rendering its HTML, which
    works well in a pure Java situation. You could also pass the `Recipe` to a template
    engine, or use something like a visitor pattern to render the `Recipe` object
    as HTML code. The full code for the `Recipe` object in the previous example is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An unfortunate side effect of using the `WebView` object is that it doesn''t
    conform to the look and feel of other widgets. It is for this reason it doesn''t
    work well when you place it with other widgets on the same screen. The end effect
    of the previous example is effectively a non-interactive web page which looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero – improving the look of the recipe viewer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example generates a very simple HTML page and doesn''t include
    any styling. Including an inline CSS is a very simple operation, and could even
    be done by reading the styling content from an application resource. Create a
    CSS, include it inline in the HTML page, with rules such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Color the background of first-level header and second-level header elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the font-color of the first and second-level headers to white
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Round the corners of the header elements by five pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the list bullet to a square instead of a circle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking WebView further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WebView` class has significant functionality that can be very useful when
    dealing with content screens, for example, using hyperlinks to provide a **show**/**hide**
    disclosure section for less important content. This requires the use of JavaScript
    in the HTML page, at which point it's strongly advisable that your application
    use a template engine to produce the HTML pages instead of generating them in
    Java code (as the Java code will quickly become difficult to maintain).
  prefs: []
  type: TYPE_NORMAL
- en: The `WebView` class also allows your application to interact with the JavaScript
    code on the page using a very simple mechanism by which you can expose Java objects
    to the JavaScript code. This is done with the `addJavascriptInterface` method.
    This allows the HTML page to invoke actions on a Java object that you provide,
    effectively allowing the page to take control of a part of your application. If
    your content screen needs to take a business action, such as **Buy** or **Cancel**,
    the required functionality can be exposed in a JavaScript interface object. When
    the **Book** HTML element is selected by the user, the JavaScript in the page
    can invoke the `appInterface.buy();` method which you defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important feature to consider with the `WebView` class is the "zoom"
    controls. When presenting your user with lots of information, it may be useful
    for the user to be able to zoom in or out in order to make some elements easier
    to read. To enable the built-in zoom controls of the `WebView`, you''ll need to
    access the `WebSettings` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `WebSettings` object can be used to enable and disable a large number of
    other features that are available in the WebKit browser component, and it's well
    worth reading through the available documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The primary problem with the `WebView` class is its look and feel. Where an
    Android application with the default theme is light grey on a black background,
    the `WebView` class is black on a white background, which makes the screens driven
    by a `WebView` stand out to the user as though they are a separate application.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way around the styling problem would appear to be to style the
    HTML pages to look just like the rest of the application. The problem is that
    some device manufacturers have their own Android application styling, so you can't
    really be sure what the rest of your application is going to look like. Changing
    the background and foreground of the HTML page to be in line with the standard
    Android theme could well make it stand out against the rest of your application
    when run on manufacturer-themed devices.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the best way to render large object graphs to HTML for rendering in
    a `WebView`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert them to XML and run them through XSLT
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Send them to an external web service to be rendered
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hard code the HTML generation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With a simple template engine
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you access external CSS and images with a `WebView`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `loadDataWithBaseURL` method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the full URL path in the HTML page
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate HTML code that includes the in line data
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What rendering engine does Android use for `WebView`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gecko
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: MSIE/Trident
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: KHTML
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: WebKit
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating relative layouts for content display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WebView` offers an easy way by which large amount of content can be displayed
    to the user in an easy-to-read format. It also has many built-in features designed
    specifically for viewing content. However, it doesn't always offer the easy way
    out and often doesn't allow for functionality that other widgets provide out-of-the-box.
    The `RelativeLayout` class provides much of the same layout functionality that
    the `WebView` class provides you with.
  prefs: []
  type: TYPE_NORMAL
- en: As we just discussed, the `WebView` stands out almost as though it were a separate
    application. Working with a `RelativeLayout`, you'll be populating your screen
    with standard Android widgets, which in turn means that there will be no change
    in the look and feel from one screen to the next. While `WebView` requires some
    form of template engine (whether it be in an API or simply a `StringBuilder` as
    in the example), a `RelativeLayout` can be declared in an application resource
    as an XML file. Using a layout file also means that the screen layout will be
    selected through the resource selection process, allowing for sophisticated customizations
    that are difficult to achieve with the `WebView` class and HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Using a `RelativeLayout` in a way provides a form of template engine. By only
    giving IDs to `View` objects that you will need to populate with data, you can
    populate the screen by injecting the relevant content into these exposed objects.
    When we built the HTML-based view, we needed to create header elements for the
    ingredients list and list of instructions, with a coded layout structure those
    headers would be loaded from within the layout file, or from a string bundle resource.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with lists of information, which is a common requirement of a content
    layout, you can provide the data in several different ways. You could use a `ListView`
    object, or you could use an embedded `LinearLayout` to act as a list. When working
    with either of them, it's advisable to have a layout resource that can be reused
    for each of the items in the list. Making use of a `ListView` means you have an
    `Adapter` through which you can convert your data objects into `View` objects
    that can be displayed on the screen. However, `ListView` objects have various
    other constraints (such as the size of the contained items) and are best used
    when the items they display are interactive in some way. If you need a non-interactive
    list (or grid) of items, it's a good idea to follow the `Adapter` mechanism by
    creating a separate class that is responsible for creating `View` objects based
    on your data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Taking full advantage of RelativeLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RelativeLayout` structures have the major advantage that they offer direct
    integration with the rest of your application. They can also be more easily localized
    than an HTML page. The event structures provided by a direct `ViewGroup` structure
    are more versatile than those provided by a `WebView` object via its specialized
    event listeners and JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: The XML layout structures also provide much the same effect as a template engine,
    avoiding the need to import an external API such as an XSLT engine, a Java template
    engine, or hard coding the HTML generation. Standard Android `Activity` classes
    also have the built-in Android animation structures to work with. While the `WebView`
    class allows for CSS animations or could run JavaScript animations, this requires
    re-layout of the HTML structure for each frame in the animation.
  prefs: []
  type: TYPE_NORMAL
- en: An Android `Activity` class implementing the entire content screen also has
    the advantage that it can load its external resources from the application resource
    structure. This not only allows you to do things such as localize your images
    more easily, but also means that all of the resources are run through the resource
    compiler and as such can be optimized by the Android tool chain. With a `WebView`
    you would need a base URL to load such resources from, or be able to encode them
    inline in the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Android layout constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some drawbacks to developing the entire content view as an Android
    layout. From a skills point-of-view, only a developer can build and maintain the
    user interface. It also means that any styling done to individual widgets must
    be managed by a developer. With a `WebView` based layout, much of the creation
    work on the layout could be handled by a web developer and graphic designer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding more widgets to your screen comes with another problem—performance. Not
    only can larger, more complex layouts lead to a very slow user experience, it
    can cause your `Activity` to crash entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping fewer widgets on the screen means that the interface will have less
    information for the user to absorb in one hit, and will be easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts with either too much length, or too much depth will cause an application
    to crash. If you need to animate a single word in the middle of a sentence, you'll
    have to define two additional `TextView` widgets that will display the non-animated
    text on either side of the animated word. This increases the length of your layout.
    If you also needed a horizontal `LinearLayout` in which to place these three `TextView`
    objects, you would be increasing the depth of your layout structure. By factoring
    in both of these constraints, you can imagine how quickly you can run out of memory
    or processing power when it comes to layout rendering. Each of the widgets must
    be measured for layout before being rendered. Each measurement, layout step, or
    rendering step makes use of the language stack (by recursively invoking methods)
    in order to make sure all of the widgets are correctly rendered at the correct
    point on the screen (or not rendered if they are off screen). The software stack
    size in Android is limited, and each method call requires each of its parameters
    to be pushed onto the stack for the invocation. On top of that, all of the measurement
    information needs to be stored in the heap space, which is another seriously limited
    resource on the Android platform (by default the Dalvik VM only allocates 8 MB
    of heap space to begin with).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the difference between the length and depth
    of a layout structure. The left screen illustrates a long layout, while the right
    screen illustrates a deep layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Considering Android layout constraints](img/4484OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Styling TextView objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point it's rather concerning to think about how you might make a single
    word in a sentence bold, or give it a shadow. In the `WebView` it's as easy as
    adding a `<span>` element with some special styling on it, but in a native layout,
    wouldn't you need to add separate `TextView` objects for each section of the text?
    If this were so, you would be dramatically limited in the amount of text you would
    be able to display to the user, since you would be creating thousands of almost
    useless objects.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Android makes it very easy to mark up the text in all of its default
    widgets. Any class that extends from `TextView` can handle text with style information
    or even images. Generally the classes available in the `android.text.style` package
    can be used to style sub-segments of the text strings you want to display.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use these different styling structures, you will need to use a `SpannableString`
    object. A `SpannableString` is a specialized type of Android string that keeps
    track of styling information in relation to a normal `CharSequence` of text that
    needs to be displayed. There are several other similar classes (such as `SpannableStringBuilder`)
    which handle easy modification of the text, and are thus suited to text that will
    be edited. For our current purposes, a `SpannableString` is perfect, and much
    simpler to work with. A `SpannableString` has a method that it's required to implement,
    based on the `Spannable` interface—`setSpan`. The `setSpan` method allows you
    to add markup structures to the `SpannableString`, which affect how a specific
    part of the text is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply wanted to write the text **There is nothing to fear!** on the
    screen, you would normally just use a `TextView` object with the specified string.
    What if we wanted to strike the **nothing** out of that string? The way forward
    now is to use a `StrikethroughSpan` object for characters 9 through 16\. In this
    case, the string can''t just be defined in the layout file anymore, a `SpannableString`
    needs to be created in the Java code. The following is a simple example of how
    this can be done, and what the resulting `TextView` would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this little snippet of Java code is a `TextView` widget displaying
    styled content instead of a plain `String`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling TextView objects](img/4484_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, using this type of markup is brilliantly effective, and really
    quite easy to work with. This sample is also very quick to execute when compared
    to the `WebView` rendering, since it doesn't include any form of parsing.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few problems with the mechanism though. The most important one being
    the index handling. In order to know when to start or stop a `Span` of markup
    rendering, you need to specify the first and last character that needs to be rendered
    with the given `Span`. Not a problem unless you plan on changing your text, or
    even worse—internationalizing it.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, once again Android already has a built-in solution, although it
    comes at the expense of performance. You can convert almost any HTML text into
    a `Spannable` object which can in turn be passed directly to any `TextView` object
    for rendering. The class to use is the `android.text.Html` class, which includes
    utility methods for parsing HTML code into a `Spannable` object, and also for
    converting a `Spannable` object into a HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to internationalize strings that you plan on rendering with additional
    style attributes, the `Html` class is probably the only sensible way to do it.
    It also has the added advantage that the loading of images can be handled by your
    application (through use of the `Html.ImageGetter` interface). Additionally, the
    `TextView` will still look and feel like a normal Android widget, which enhances
    the users' experience.
  prefs: []
  type: TYPE_NORMAL
- en: Most HTML tags are handled by the `Html` class, but not quite all of them. For
    one thing—CSS styles are ignored, so colors and borders are out of the question.
    However, great styling is still possible, and at least you don't need to record
    the character index values somewhere in an application resource so that all of
    the styling lines up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to format some text in a `Button` label as bold, it''s really
    easy to do with the `Html` class. It''s much quicker to just pass the result of
    the `fromHtml` method directly to the `TextView` object. For example, the following
    code snippet would yield a `Button` object with the word **Hello** in italic script,
    while the word **World** would have a bold weight to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify HTML content in a layout resource XML file, and it will
    be parsed with the `Html` class before being passed into the `TextView` object's
    `setText` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above Java snippet creates a `Button` widget that would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling TextView objects](img/4484_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'HTML tags can also be used to render mini-documents into a `TextView` object,
    and while they carry their own styling, they also adhere to the styling of the
    `TextView` object. This means that if you''re looking for a solution that''s quicker
    to work with than a `WebView` for carrying some static text (and no hyperlinks),
    then a `TextView` can actually serve as a good alternative. For example, consider
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the `TextView` with a first-level header and a single-lined
    paragraph element. Both of which will include some padding in order to space them
    apart from the other elements on the screen. The resulting image should look quite
    familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling TextView objects](img/4484_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a correctly styled `TextView` makes a great alternative to a
    `WebView`, especially if you are fitting it inline with a series of native widgets.
    However, the black-on-white styling does bring back the inconsistency problem.
    So unless you entire application follows this model, it's a better idea to leave
    the styling as default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are planning on using a `TextView` for longer content, it''s important
    to consider some additional factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the user will be able to scroll if the text runs longer than
    the size of their screen. This is easily done by placing the `TextView` in a `ScrollView`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your text is very long, consider styling the content, either making the text
    brighter white or working with a black on white background. While it is very inconsistent
    with other Android applications, and other screens in your own application, it
    is much easier on the eyes and your users will thank you for that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider allowing the user to change the font size with a long touch or a menu.
    If their screen is low density, or they don't have perfect vision, you may be
    making their lives a little easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to display a non-interactive bullet point list, which of these is
    preferable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `WebView` with an unordered list
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A specially styled `ListView` object
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `TextView` object with HTML content
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With regards to hyperlinks, you might use a `WebView` instead of a `TextView`
    because:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TextView` cannot handle hyper links'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They look better in a `WebView`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `WebView` has built-in history management
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A native interface works better for animation intensive applications because:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use Android animation resource files
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `WebView` class doesn't handle animations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: HTML animations are more expensive to run
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Time for action – developing specialized content views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many situations, you'll need a specific type of interactive logic that you
    would want to reuse in many parts of your application. On a content screen, some
    parts of the display will need to be updated, driven by changes that are made
    to other parts of the display. This is often because while some area of the screen
    is giving the user information, the other parts are capturing new data from them.
    Next, we'll build a simple widget responsible for displaying an amount of money
    to the user. Its main reason for its existence is the fact that it not only animates
    between changes, but also feeds back to the user whether the amount has gone up
    or down by changing its color.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java source file named `AmountBox.java` for the new class, and
    open the new file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new class should extend the `TextSwitcher` class and implement the `ViewSwitcher.ViewFactory`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a field for the `DecimalFormat` to be used to render the amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also declare a field to store the current numeric value displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Declare copies of the two constructors made available from the `TextSwitcher`
    class in order to allow the `LayoutInflator` class to instantiate the `AmountBox`
    class from resource files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `init()` method to take care of "common constructor" requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the "in" and "out" animations to the fade animations provided by Android:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the `ViewFactory` to the `AmountBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, invoke `setAmount(0)` to ensure the displayed amount is specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a setter method to allow overriding of the default `DecimalFormat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a getter method to allow easy access to the current numeric value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `makeView()` method from `ViewFactory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `TextView` object with the context given to this `AmountBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify a large text size since the amount will represent money, and then return
    the `TextView` object for display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now declare a setter method to allow the amount value to be changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method will change the color of the text, so declare a variable for the
    new text `color` that will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First check to see what `color` we should change the text to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the off screen `TextView` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the font color based on the change to the numeric value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render a shadow around the text in order to create a "halo" effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the text of the `TextView` to the new value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the off screen `TextView` and remember the new value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AmountBox` class is a great example of a small unit of content that needs
    to be updated. This class provides information to the user, but also provides
    a form of feedback. When the user does something which affects the amount displayed,
    the `AmountBox` reacts by updating the font color to reflect the direction of
    the change—green for the amount going down, and red for an amount going up.
  prefs: []
  type: TYPE_NORMAL
- en: The example makes use of the standard Android fade through animations as discussed
    in [Chapter 7](ch07.html "Chapter 7. Animating Widgets and Layouts"), A*nim*ating
    *Widgets and Layouts*. The speed of the animations provides a great cross fade
    effect between the two amounts. Notice that in the `setAmount` method, the updating
    of the text content and switching the `View` objects is handled manually.
  prefs: []
  type: TYPE_NORMAL
- en: You could potentially replace the `offscreen.setText` and `showNext` method
    calls with a call to `setText`, but it's nice to see how it works under the hood.
    This method is also not subject to future implementation changes that may occur.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Developing an online music store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great example of a content-centric layout is a music store built into a media
    player application. The ability to buy music directly from the media player is
    a massively user-friendly feature, and also fits nicely with the way Android applications
    behave as "connected" applications instead of purely offline systems. Android
    also makes it very easy to truly include the shop as part of the application instead
    of simply providing a link to an appropriate website. Generally, users are more
    inclined to feel a sense of trust if they pick the **Buy Music** button and are
    not suddenly whisked off to their web browser. Having both online and offline
    parts of your application properly integrated can also go a long way for your
    sales statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Buying music online is very different to purchasing it in a store. The availability
    of additional information about the songs, artists, or albums the user is looking
    at is part of the appeal. For this reason, an online music store for a mobile
    device must be carefully designed to provide as much information as possible without
    either cluttering the screen, or detracting from the fact that the user is there
    to purchase music. The feeling of integration with the application also helps
    build trust with the user, so the look and feel is very important. Another advantage
    of buying music online is you pay only for what you want to purchase. For this
    the user interface needs to allow the user to select which tracks from an album
    the users would like to purchase, and which they either don't want or plan to
    buy later. Also, how do they know which ones they like? They also need to be able
    to play a sample (whether it be time limited, or just a lower quality) of each
    track.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the music store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To really illustrate how a content-centric design fits together, you need to
    build one. For this example we'll be working through the design process, and then
    the implementation of that design. Since the design and its implementation are
    the important parts here, we won't go into building a functional example. It'll
    really just be a pretty screen.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to have a basic user interface design. I find it best
    to start with a whiteboard or a piece of paper and a pen. While there are plenty
    of tools for drawing mock screens out there, none of them really approach the
    user interface of a paper and pen. To start off, we draw a high level wireframe
    of the overall screen design. This is simply a series of boxes that will tell
    us what type of information to show in what parts of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the music store](img/4484OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the diagram, we''ve divided the user interface into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Album and Artist Information area: This area displays the name and cover art
    of the album the user is looking to buy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Track List area: In this area, users can listen to samples and select which
    tracks they want to purchase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Purchasing Area: This area displays the total amount users will be paying,
    and also a button to buy their selected tracks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous diagram, I've stuck to the size of the screen, but depending
    on the screen size and number of tracks available, the user interface may need
    a scrollbar to be fully accessible.
  prefs: []
  type: TYPE_NORMAL
- en: The next bit of work is to look at each of the sections of the user interface
    that we've defined and decide what widgets will go into each of them. Firstly
    we'll need to look at the album and artist information. The album information
    will be displayed as the album cover artwork and the album name. We'll include
    an image area for an artist logo, and also include a text block with the name
    of the recording label.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the music store](img/4484OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple block diagram like this lets you visually consider the various elements.
    It also allows you to start thinking about things such as font size, borders,
    and spacing. In the previous diagram, we want the three elements on the right
    to be roughly the same size as the cover art on the left. Unfortunately the Android
    `RelativeLayout` class doesn't currently allow us to directly stipulate this as
    a contract. The next element of the design we need to consider is the track listing
    box. For this, instead of drawing everything in the box, we'll focus on what a
    single line will look like and what information it will contain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the music store](img/4484OS_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding structure is a very simple one line structure for displaying the
    details of a single track. The `CheckBox` on the left can be used to select those
    tracks that the user wants to purchase, while the button on the right side can
    be used to play a sample of the given track. The two button-like elements on either
    side create a kind of framing for the plain text elements in the middle of the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to consider how we plan on asking the user to send their money.
    This is a very important part of the user interface, it needs to be obvious—the
    amount of money they will be expected to pay. We also need to make it really easy
    for the user to actually make the transaction, so a single **Purchase** or **Buy
    Selected Tracks** button is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the music store](img/4484OS_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final section of the user interface simply has two widgets in it, one on
    the left for purchasing, and the total amount the user is expected to pay on the
    right. For the left side button, we'll work with a simple Android `Button` widget,
    while on the right side we'll make use of the new `AmountBox` written in the previous
    part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the music store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with the new example by building a new series of model classes,
    but first you''ll need to create a new project for our conceptual media player.
    To do this, run the following command on a command line or console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: After creating the new project, copy the `AmountBox` source code into the root
    package of the new project. You then need to create a class to contain the data
    for a single track. This simply needs to have the name of the track and the duration
    of the track stored as the number of seconds. We'll also include utility methods
    to calculate the minutes:seconds values that we can use to display the duration
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Track` class is a very simple structure which could easily be parsed from
    XML or deserialized from a binary stream. We also need another class to hold the
    information about a single artist. While the following class is really nothing
    more than a form of data store, it could easily be extended to store things like
    biography information if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on the data class front, we''ll need a class for linking the two previous
    classes to a single album. This class will be used as a single point which can
    be handed to an `Activity`. Copy the following code into a new file named `Album.java`
    in the root package of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – building a track item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get working on the new user interface, you'll need a few images. For this
    next section, you'll need an image for the play buttons. The play image should
    be a simple "play" arrow, the button we place it in will provide a background
    and border. The lines in the list structure will be placed into a `TableLayout`
    in order to align all of the sub-structures.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layout resource file in the `res/layouts` directory of the project,
    and name the new file `track.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the root element of the new file as a `TableRow` element consuming
    all of the available width and only the required height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the first element of the `TableRow`, create a `CheckBox` the user can use
    to select and unselect the tracks they want to buy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `TextView` element to display the name of the track with a larger-than-usual
    font, and a pure-white font color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Follow the track name `TextView` with another right-aligned `TextView` object
    to be used to display the duration of the track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'End the `TableRow` element with an `ImageButton` element, which can be used
    by the user to sample the track before buying it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above layout resource file will handle the layout of the track list items
    for the second part of the user interface. We need to be able to create several
    of these structures to handle all of the tracks available in an album. We wrap
    them in a `TableRow` element which when placed in a `TableLayout` object, will
    automatically align each of its sub-elements with those in the other rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, in the Java code we''ll use the `LayoutInflator` to load this resource,
    populate it with the name and duration of a track, and then add it to a `TableLayout`
    object that we will declare as part of the main user interface. Once this new
    item has been populated with some data, it''ll look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened](img/4484_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – developing the main user interface layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having built the layout resource file that will become track items in a list
    later, we now need to define the remaining elements of this user interface. While
    this structure is relatively simple, it's also very easily extended and has a
    few minor details that keep it looking really good. It also needs some Java code
    in order to be correctly populated, but we'll get into that after we've finished
    with the resource file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – developing the main user interface layout](img/4484OS_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create or open the `res/layout/main.xml` file in the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The root element of the main layout needs to be a `ScrollView` in order to
    handle the possibility that the interface runs longer than the available screen
    space. The `ScrollView` should take up all available screen space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the only element to the `ScrollView`, declare a `RelativeLayout` which consumes
    the available width, but only the required height. The `RelativeLayout` should
    include some padding at the top and bottom to provide a little "breathing room"
    so that its contents don''t look to cramped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first element of the `RelativeLayout` is the album art, a fixed size `ImageView`
    object that will fit the album cover art in the available space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second element after the album art is the artist''s logo image, also an
    `ImageView`. This element is required to center the logo in the available space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the artist''s logo, we need a plain `TextView` object with some font
    styling to hold the name of the album we''re trying to sell. We''ll place this
    below the artist''s logo in the user interface as per the image we saw earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `TextView` with the album name, we have a small non-styled `TextView`
    to hold the name of the record label under which the album is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As promised, we follow these elements with a `TableLayout` which will hold
    the available track information. We layout the `TableLayout` element against the
    album art rather than the record label `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Underneath the track list, we start by placing the **Buy Selected Tracks**
    button element on the left side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, on the right side of the screen, we add our custom `AmountBox` widget
    where we will tell the user how much they will be paying:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding layout, each of the specified widgets has an important part
    to play by either providing the user with information, or gathering new information
    from them. As far as possible, we have given the user only the information that
    is important to them. The cover art and artist's logo are often the first way
    people recognize a specific album, while the name may well be a secondary recognition.
    The colors and shapes in the album cover art are generally recognized faster by
    a person's brain than the text indicating the album's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the top elements: Cover art, artist logo, album name, and record label,
    could be made into interactive elements, taking the user to screens with more
    information about the selected element. The linked information could include reviews,
    discussion forums, and rating widgets. Another great addition would be linking
    to music videos from the selected album or artist (if there are some available).'
  prefs: []
  type: TYPE_NORMAL
- en: Also notice at the bottom in our purchasing area. The `AmountBox` has been aligned
    with the "baseline" of the `purchase Button` widget. In this case, it aligns the
    baseline of the text in these two widgets, making them looked centered in relation
    to each other, although it's an aesthetic centering rather than an exact computation.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – developing the main user interface Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to put this example together entirely and have a working content-centric
    screen (although only in the example sense), we need some Java code. This code
    will handle populating the user interface layout with an `Album` object. For this
    next piece of code, you'll need images for the cover art and for the artist's
    logo.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ShopActivity` Java source file in an editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate` method, ensure that the `main.xml` layout resource is being
    set as the content view for the `ShopActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the application resources and invoke a new `setAlbum` method with the
    contents of your favorite music album:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `setAlbum` method to accept an `Album` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the `track_listing` part of the user interface and use a new `addTrackView`
    method to add each of the tracks to the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the album cover art widget and set its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the artist''s logo widget and set its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the album name widget and set its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the record label widget and set its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the `AmountBox` widget and set its format to a money format before setting
    its value to `1.99` multiplied by the number of tracks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `addTrackView` method and use it as it was used previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `LayoutInflator` to inflate the `track` layout resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the track name widget from the new `ViewGroup` and set its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the track duration widget from the new `ViewGroup`, and create a `StringBuilder`
    with which to display the track duration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the minutes and a separator to the `StringBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the number of seconds is less than `10`, we need a prefix `''0''` character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the number of seconds in the duration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the text of the duration widget and add the new line to the "tracks" list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding Java code is enough to copy the data given in the `Album` object
    into the user interface. Once on the screen, it looks like a simple music store
    page, but themed as an Android application. This provides much of the benefit
    of a web page in terms of layout structures and the easy maintenance that comes
    with an XML layout and at the same time integrates entirely with whatever branding
    and styling may exist on the end user''s device. Once on the screen, the previous
    example will present you with something looking like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/4484_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero – updating the total price
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To really make the previous example feel more real, it needs to update the total
    amount at the bottom of the screen when the user selects or unselects tracks from
    the album listing. It should also disable the **Buy Selected Tracks** button if
    there are no tracks selected.
  prefs: []
  type: TYPE_NORMAL
- en: Try adding an event listener to each of the `CheckBox` elements in the track
    layouts, and keep a track of which are selected. For the total amount to display,
    multiply `1.99` with the number of selected tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've delved into many important areas and techniques used
    when presenting the user with lots of information or content. It's important to
    think through your interfaces carefully before you start building them, but also
    try not to take up too much time before you put fingers to the keyboard and start
    coding. Sometimes having a simple user interface up and running can tell you far
    more than your diagrams and mock-ups ever will about how users will work with
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We've completed an example of displaying recipes to the user with the `WebView`
    class, demonstrating how easy it is to use HTML on the Android platform. We've
    also looked at the native alternative to an HTML view by building an online music
    store using a `RelativeLayout` to display the content. With these two examples,
    we've compared the differences between the two mechanisms giving insight into
    where each can best be used.
  prefs: []
  type: TYPE_NORMAL
- en: Always consider your performance and user experience when deciding on how to
    display your content. While a `WebView` may be more flexible in some regards,
    allowing you to change the content view depending on what content you are displaying,
    it may also lead to inconsistencies and an irritated user. A `RelativeLayout`
    provides a more rigid structure, and will also ensure a more consistent code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be looking in more detail at how you can go about
    adding more style to your Android application. We'll also look at how best to
    go about handling changes to the device and configuration (such as the changing
    language or a change from portrait to landscape mode).
  prefs: []
  type: TYPE_NORMAL
