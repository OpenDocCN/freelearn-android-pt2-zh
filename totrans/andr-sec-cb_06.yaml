- en: Chapter 6. Reverse Engineering Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling from Java to DEX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling DEX files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting the Dalvik bytecode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling DEX to Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling the application's native libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the Android processes using the GDB server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter discussed the flaws in the applications; they can be exploited
    and discovered without the need to know exactly how they have been developed.
    Though there were detailed explanations on some common source code that caused
    this specific issue, we didn't need to read the source code to know that a SQL
    injection was possible. Largely, our first step in the direction of a successful
    exploit was to analyze the behavior of an application from a context that is ignorant
    of the actual details surrounding its behavior. The reverse engineering discussed
    in this chapter aims to uncover every single detail of an application's inner
    workings in order to exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering, when applied to computer software, is the process of learning
    how something works and developing ways to make use of, or abuse, this information.
    For example, reading the source code of a kernel driver may lead to finding a
    potential memory-corruption flaw, such as improper bounds checking for buffers.
    Knowing this may allow you to develop an exploit, given the context in which this
    vulnerability exists. Reverse engineering is the most essential skill of any security
    specialist and is at the heart of all true development exploits. When exploits
    and vulnerabilities are developed somewhere in the chain of events that lead to
    successful exploitation, reverse engineering has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Android applications are not different from other computer software types, and
    thus, they can be reverse engineered, too. In order to reverse engineer an application,
    one needs to understand how they are built, what goes where, and why. Not having
    this information leads to endless, sleepless nights of fuzz testing and brute
    forcing, which in most cases, will ultimately end in frustration. This chapter
    discusses a few recipes that you can use for extracting information about the
    inner workings of an application, and discusses some novel tricks that malware
    developers and security auditors use to abuse and reverse engineer applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get cooking with the recipes, there's just one question that begs
    to be asked; why would you reverse engineer an Android application?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few ways to answer that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To read the source code**: Often, many vulnerabilities stay hidden from attackers,
    simply because they don''t manifest themselves during the "black-box" assessment
    of an application. This does not mean they are not vulnerable to exploitation;
    to quote, "the absence of evidence is not the evidence of absence!" Reading the
    source code of an application is the most effective way to learn its weaknesses
    and will, more often than not, result in the discovery of more vulnerabilities
    than a pure black-box analysis. Reading the source code is still the only concrete
    way to understand an application; you cannot trust anything but the source code;
    in other words, documentation is a lie until the source code proves otherwise!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To leak information**: Some vulnerabilities in applications don''t stem directly
    from the behavior of the code but from the kind of information stored in the application,
    for example, static private keys and passwords, e-mail addresses, sign-on tokens,
    URIs, and other sensitive content. Cracking open an application grants you access
    to all of its secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To analyze defense mechanisms**: Often, the common vulnerabilities in applications
    are protected in the most ridiculous ways. Though mitigating common attack paths,
    whether or not an application is protected from certain attacks depends purely
    on its source code and configuration. Often, without the source code and internal
    configuration, it may be extremely difficult, or at times impossible, to uncover
    how it protects itself. Reading the source code of a large number of apps in the
    same category can give you quite in-depth and knowledgeable insight into the best
    and worst ways to protect applications, for example, login apps. Reading a lot
    of source code from these may teach you how developers create defenses against
    authentication brute-force attacks, credential sniffing attacks, and other login
    app-specific defenses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To analyze attack techniques**: You may be interested in finding out which
    application and system level exploits the latest and greatest Android malware.
    The only way to truly find this out, and put yourself on the cutting edge of Android
    security research, is to reverse engineer Android applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these goals in mind, let's get going with the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling from Java to DEX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe following this one breaks down the DEX file format; but before delving
    into the DEX file, it would be useful to first get to know the process of interpreting/compiling
    a Java program into a DEX program. One of the key reasons for demonstrating compilation
    from Java to DEX is because the file used in the example here will be used to
    explain the DEX file format in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get going, there are a couple of things you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit**: We need this to be able to compile Java code into
    the class files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK**: We need some of the tools in this package to be able to transform
    Java class files into DEX files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text editor**: We need a text editor so that we can write a sample Java program
    to convert to a DEX program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've got all of these things, we can begin preparing a sample DEX file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile a Java program into a DEX program, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your text editor and create a file using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the previous file as `Example.java` and then compile the code by typing
    the following into your terminal or command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you''ve got your `CLASS` file ready, you can now whip out a tool called
    `dx`, found under:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you''ve got Version 4.4 of the SDK, you can find it under:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00118.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To prepare a DEX file, you need to execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00119.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once this is done, you should have a file called `Example.dex` in your current
    directory; this is the DEX version of `Example.class`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we did what Java developers do every day and what describes Java
    objects; our object was called `Example`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we compiled `Example.java` into a class file. What happens here is
    that the Java compiler grabs the nice semantic code we've written and parses it
    into a bunch of stack-based instructions for the Java Virtual Machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 3, we took the `CLASS` file, with its Java metadata and stack-based
    instructions, and prepared a collection of resources, data structures, and register-based
    instructions that the Dalvik VM understands as a DEX file. Here''s a breakdown
    of the `dx` commands we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-dex`: This command tells `dx` that you''d like to create a DEX file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-output=Example.dex`: This directive lets `dx` know that we want the output
    of the proceedings to go into a file named `Example.dex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Example.class`: This is the input file, namely, the `class` file we compiled
    in step 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling DEX files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DEX files, or Dalvik Executable files, are the Android equivalent of Java's
    `CLASS` files. They include the compiled format of the Java code that defines
    an Android application's behavior, and as an Android security specialist to be,
    you would naturally be interested in knowing how these files work and what exactly
    they are for. Decompiling the DEX files is an essential part of the security assessments
    for many applications; they provide a good source of information on the behavior
    of an Android application and can often glean details of an application's development
    that a pure source code perspective cannot. A good understanding of the DEX file
    format and how to interpret it may lead to the identification of new vulnerabilities
    or development and improvement of exploits against the Android platform and Dalvik
    VM. Malware may soon start exploiting the way DEX files are interpreted, to hide
    details pertaining to its behavior. And the only security enthusiast that will
    be privy to the new Android malware obfuscation techniques, and have the necessary
    skills to thwart them, will be the enlightened few who truly know how DEX files
    work. This recipe includes a detailed breakdown of the DEX file format and describes
    how each field in the DEX file is used and interpreted. It then moves on to discuss
    how to decompile a DEX file back into the Java source code for easy reading and
    reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DEX file format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is dedicated to breaking down and describing each important section
    of the DEX file. It walks through each field, and works straight from the Dalvik
    source code used to interpret the DEX files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few paragraphs provide information about where the different sections
    of the DEX file occur, such as where to find references to printable strings and
    where the actual DEX code for each compiled class are to be found. DEX files have
    a fairly simple and easy-to-understand format. The structure of the DEX files
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code is available at [https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h](https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h).
  prefs: []
  type: TYPE_NORMAL
- en: The DEX file header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The very first section of a DEX file is called the the DEX file header. The
    following is the definition of the DEX file header according to `libdex` in the
    Dalvik VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The data types `u1` and `u4` are merely aliases for unsigned integer types.
    Here are the type definitions in the `Common.h` header file of the Dalvik VM itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code is available at [https://github.com/android/platform_dalvik/blob/master/vm/Common.h](https://github.com/android/platform_dalvik/blob/master/vm/Common.h).
  prefs: []
  type: TYPE_NORMAL
- en: So, that gets the preliminaries out of the way. You now have a basic idea of
    what a DEX file looks like, and a basic grasp of where everything goes. The next
    few paragraphs break down exactly what each of the sections are for and how the
    Dalvik VM makes use of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, the first field in a DEX file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`magic[8]` holds a "marker", commonly referred to as a magic number, which
    holds a collection of characters unique to the DEX files. The magic number for
    the DEX files is `dex\n035`, or in hexadecimals, `64 65 78 0a 30 33 35 00`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of `classes.dex` showing the magic number in hexadecimals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DEX file header](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next field is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the Adler32 checksum as it would appear in the
    DEX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DEX file header](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This 4-byte field is a checksum of the entire header. A checksum is the result
    of a collection of **exclusive ORs** (**XORs** ) and addition operations performed
    on the bits that make up the header. It is checked to make sure no corruption
    or erroneous change occurred to the contents of the `DexHeader` file. It's so
    important to make sure that nothing has corrupted this header because it determines
    how the rest of the DEX file is interpreted and acts as a roadmap for the rest
    of interpretation. Due to this, Dalvik uses the `DexHeader` file to locate the
    rest of the components of the DEX file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next field is a 21-byte **Secure Hashing Algorithm** (**SHA**) signature,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the SHA digest as it would appear in the DEX
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DEX file header](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`kSHA1DigestLen` is defined as `20`, if you haven''t already guessed. This
    is because the block length of SHA1 is standardized as `20`. This digest, according
    to a small comment in the Dalvik code, is used to uniquely identify the DEX file
    and is computed in the section of the DEX file after the signature. The section
    of the DEX file on which this SHA digest is computed is where all the address
    offsets and other size parameters are specified and what they refer to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the SHA digest field is the `fileSize` field, which is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `fileSize` field as it would appear in the
    DEX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DEX file header](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `fileSize` field is a 4-byte field which holds the length of the entire
    DEX file. This field is used to help calculate offsets and locate certain sections
    easily. It also helps to uniquely identify the DEX file because it forms part
    of the section of the DEX file that is fed into the secure hashing operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `headerSize` field as it would appear in
    the DEX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DEX file header](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`headerSize` holds the length of the entire `DexHeader` structure in bytes
    and as the comment suggests, it''s used to help calculate its position in the
    file that marks the start of the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following field in the DEX file is the endianness tag, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `endianTag` field of a sample `classes.dex`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DEX file header](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `endianTag` field holds a static value that is the same across all DEX files.
    The value of this field, `12345678`, is used to make sure the file is being interpreted
    with the right "endianness" or bit order. Some architectures prefer their most
    significant bit to the left and others prefer it to the right; this is referred
    to as the endianness of an architecture. This field helps identify which one the
    architecture uses, by allowing the Dalvik VM to read the value and check which
    order the numbers in the field appear in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linkSize` and `linkOff` fields are next; they are used when multiple class
    files are compiled into one DEX File:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The map section offset is next and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next field, `stringIdsSize`, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![The DEX file header](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `stringIdsSize` field holds the size of the `StringIds` section and is used
    in the same style as the other size fields to help calculate the starting position
    of the `StringIds` section, with respect to the start of the DEX file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next field, `stringIdsOff`, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This field holds the offset in bytes to the actual `stringIds` section. It
    helps the Dalvik compiler and the virtual machine to jump into this section without
    doing any rigorous computation or having to re-read the file over and over again
    to find the `stringIds` section. Following the `StringIdsOff` field are the same
    offset and size fields for the type, prototype, method, class, and data ID sections—each
    of these attributes has size and offset fields exactly like the `stringIds` and
    `stringIdsOff` fields. These serve the same purpose as the `stringIdsOff` and
    `stringIdsSize` field, except that they aim and facilitate efficient and simple
    mechanisms to access the related sections. As mentioned earlier, this means it
    would come down to either re-reading the file multiple times or doing a few simple
    additions and subtractions on a relative starting address. Here are the definitions
    for the size and offset fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All of these size and offset fields hold values that are to be interpreted as,
    or hold values that need to form a part of, the computation on addresses that
    defer positions inside a DEX file. This is the primary reason why all of them
    have the same type definition, namely, an unsigned 4-byte integer field.
  prefs: []
  type: TYPE_NORMAL
- en: The StringIds section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `StringIds` section is purely composed out of a collection of addresses—or
    identification numbers with respect to the Dalvik nomenclature—relative to the
    start of the DEX file to be used for finding the starting positions of the actual
    static strings defined in the `Data` section. According to `libdex` in the Dalvik
    VM, the fields in the `StringIds` section are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these definitions say that every string ID is simply an unsigned 4-byte
    field, which is no surprise since they are all offset values like those found
    in the `DexHeader` section. Here''s a screenshot of the `StringIds` section from
    a sample `classes.dex` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The StringIds section](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, the values that are highlighted are the addresses
    previously referred to, or values from the `StringIDs` section. If you were to
    grab one of the values, read them with the correct endianness, and skip down the
    DEX file to the section with the offset of this value, you would end up in a section
    that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The StringIds section](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the sampled value that reads `00 00 01 8a`, because of the
    endianness of the file format, actually points to a string in the DEX file. The
    following screenshot shows us what''s at offset `0x018a` in the DEX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The StringIds section](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, location `0x018a` contains the value `3c 69 6e 69 74 3e 00`,
    which is actually the hexadecimal equivalent of `<init>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is basically the same process the compilers, decompilers, and the Dalvik
    VM go through when they look up string values. Here''s an extract of the code
    from `libdex` that does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code is available at [https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.cpp](https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.cpp)
    (lines 269-274).
  prefs: []
  type: TYPE_NORMAL
- en: The character array dereferenced by the pointer called `data` is the actual
    content of the DEX file. The preceding code snippets should demonstrate quite
    effectively how each of the `DexHeader` fields are used to find different positions
    in the DEX file; certain parts of the code are highlighted to show this.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeIds section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next is the `TypeIds` section. This section holds information about how to
    find the string labels for each type. Before we get into how this works, let''s
    look at how `TypeIds` are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code is available at [https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h](https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h)
    (lines 270-272).
  prefs: []
  type: TYPE_NORMAL
- en: 'As described by the comment, this value holds an ID, or rather, an index of
    something in the `StringIds` section, which is the string label of the type being
    described. Here''s an example that takes a sample value—the first one defined—from
    the `TypeIds` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TypeIds section](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The value, as before, is read as `03`. As done earlier, we need to respect
    the file''s endianness, which is an index to a value in the `StringIds` section,
    specifically, the fourth defined string ID in the `StringIds` section. It is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TypeIds section](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The fourth defined value is `0x01af`, which in turn dereferences this offset
    in the data section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TypeIds section](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, we can see the value `LExample`, which may seem
    a little strange since we clearly defined our class as `Example`. What does `L`
    mean? Well, this string is actually a description of the type as per the Dalvik
    type descriptor language, which is quite similar to Java's method, type, and class
    signatures. In fact, it works exactly the same way. A full breakdown of the type,
    method, and other descriptions or signatures for Dalvik can be found at [http://source.android.com/devices/tech/dalvik/dex-format.html](http://source.android.com/devices/tech/dalvik/dex-format.html).
    In our case, the `L` value preceding the class name indicates that `Example` is
    a class or the description name of an object. When the Dalvik compilers and VM
    lookup and build types, they follow the same basic procedure. Now that we understand
    how this section works, we can move on to the next section, namely, the `ProtoIds`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The ProtoIds section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ProtoIds` section holds a collection of prototype IDs that are used to
    describe methods; they contain information about the return types and parameters
    for each method. The following is the command that you see in the `libdex` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure is pretty easy to understand. The unsigned 4-byte field called
    `shortyIdx` holds an index to a string ID defined in the `StringIds` section that
    gives a short description of the prototype; this description works almost the
    same way type descriptions do for Dalvik. `returnTypeIdx`, if you haven''t guessed,
    holds an index which dereferences a value in the `TypeIds` section. This is the
    description of the return type. Lastly, `parametersOff` holds the address offset
    of the list of parameters for the method. Here''s a sample `ProtoIds` section
    from `Example.dex`. This is what the `ProtoIds` section looks like in our example
    DEX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ProtoIds section](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The FieldIds section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FieldIds` section, much like the others, is composed of a collection of
    fields that reference `StringIds` and `TypeIds`, but is specifically targeted
    at describing the fields in a class. Here''s the official definition of a DEX
    file''s `FieldIds` from `libdex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code is available at [https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h#L277](https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h#L277).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see three fields that make up the description of a type here, namely,
    the class it belongs to (identified by the class ID in the `classIdx` field),
    the type of the field (`string`, `int`, `bool`, and so on, detailed in the `TypeId`
    and dereferenced from the value saved in the `typeIdx` variable), and the name
    of the type, namely, the definition according to the specification we discussed
    earlier. This value is, as with all of the string values, stored in the data section
    and dereferenced from the `StringIds` section with the value stored in `nameIdx`.
    Here''s a screenshot of our `FieldIds` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The FieldIds section](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's move on to the next section, that is, the `MethodIds` section.
  prefs: []
  type: TYPE_NORMAL
- en: The MethodIds section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fields for each method ID are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code is available at [https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h#L286](https://github.com/android/platform_dalvik/blob/master/libdex/DexFile.h#L286).
  prefs: []
  type: TYPE_NORMAL
- en: 'The class to which the method belongs is dereferenced by the value stored in
    the `classIdx` field. This works exactly in the same way as the `TypeIds` section.
    Also, each method has a prototype reference attached to it. This is stored in
    the `protoIdx` variable. And lastly, the `nameIdx` variable stores a reference
    to the characters that make up the definition of the method. Here''s an example
    definition of a method from our `Example.dex` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to understand the previous definition is to read it from right
    to left. Breaking the definition down, it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V`: This indicates a void type, which is the return type of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()`: This denotes which type specification for the method parameters will
    follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java/lang/String;`: This is the identifier for the `String` class. Here, the
    first and only argument is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L`: This indicates that the type following this character is a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[`: This indicates that the type following this character is an array of the
    specified type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So,putting this information together, the method returns a void and accepts
    an array of objects from the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the `MethodIds` section from our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MethodIds section](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The ClassDefs section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ClassDefs` section is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These fields are pretty straightforward to understand, starting with the `classIdx`
    field, which, as the comment suggests, holds an index in the `TypeIds` section
    indicating the type of file. The `AccessFlags` field holds a number indicating
    how other objects are to access this class and also describes some of its purpose.
    Here''s how the flags are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `superClassIDx` field also holds an index to a type in the `TypeIds` section
    and is used to describe the type of the super class. The `SourceFileIDx` field
    points into the `StringIds` section and allows the Dalvik to look up the actual
    source for this class. Another important field for the `classDef` structure is
    the `classdataOff` field, which points to an offset inside the Dalvik file that
    describes some more very important properties of the class, namely, where the
    code is found and how much code there is. The `classDataOff` field points to an
    offset holding one of these structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DexClassDataHeader` file holds some metadata about the class, namely,
    the size of the static fields, instance fields, the direct methods, and the virtual
    methods. Dalvik uses this information to calculate important parameters that determine
    the size of the memory each method has access to, and also forms part of the information
    needed to check the bytecode. An interesting group of fields here is `DexMethod`
    , which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This group holds the actual references to the code that makes up the classes.
    The code offsets are saved in the `codeOff` field; the `methodId` and `accessFlags`
    fields also form part of the structure along with this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed how most things fit together in an average DEX file,
    we can move on to decompiling them with some automated tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to make sure you have a couple of tools set up before we begin with
    the decompilation, namely, the Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you understand the DEX file format and structure, you can decompile
    it using the `dexdump` utility by following the ensuing steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android SDK includes a tool called `dexdump` and it''s saved under the
    `sdk/build-tools/android-[version]/dexdump` folder of the SDK. To decompile a
    DEX file, all you need to do is pass it as an argument to `dexdump`. Here''s how
    you do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `[SDK-path]` would be the path to your SDK, and `classes.dex` would be
    the DEX file you want to parse. For our example, you would execute the following
    command to the file we compiled into Java code in one of the previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for our example, would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android SDK has another tool called `dx` that is capable of breaking down
    the DEX file in a way more native to the DEX file format. You''ll see why soon
    enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, `dx` only operates on the `CLASS` files and works by compiling
    them into DEX files and then performing the specified operations. So, if you have
    a `CLASS` file you''d like to work on, you can execute the following command to
    see the semantic structure and contents of the corresponding DEX file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`dx` can be found under the `sdk/build-tools/android-[version]/` path of the
    Android SDK package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our example, namely, `Example.class`, the output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The column to the left of the output details the file offsets and their contents
    in hexadecimal. The column to the right holds the semantic value and a breakdown
    of how each offset and value are interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that some of the output has been omitted for the sake of brevity;
    only the section containing everything from the `DexHeader` file has been included.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Dex File Format – RetroDev* webpage at [http://www.retrodev.com/android/dexformat.html](http://www.retrodev.com/android/dexformat.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Smali Decompiler – Google Code* webpage at [https://code.google.com/p/smali/](https://code.google.com/p/smali/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decompiling Android* by *Godfrey Nolan*, Apress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Practicing Safe Dex* document at [http://www.strazzere.com/papers/DexEducation-PracticingSafeDex.pdf](http://www.strazzere.com/papers/DexEducation-PracticingSafeDex.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android Dalvik Kernel Source Code Repository webpage at [https://github.com/android/platform_dalvik/tree/master/libdex](https://github.com/android/platform_dalvik/tree/master/libdex)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Dalvik Executable Format – Android Open Source Project* document at [http://source.android.com/devices/tech/dalvik/dex-format.html](http://source.android.com/devices/tech/dalvik/dex-format.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting the Dalvik bytecode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may know by now that the Dalvik VM is slightly different in structure and
    operation as compared to the Java VM; its file and instruction formats are different.
    The Java VM is stack-based, meaning bytecode (the code format is named this way
    because instructions are each a byte long) works by push and popping instruction
    on and off a stack. The Dalvik bytecode is designed to resemble the x86 instructions
    sets; it also uses a somewhat C-style calling convention. You'll see in a moment
    how each calling method is responsible for setting up the arguments before making
    calls to another method. For more details on the design and general caveats of
    the Dalvik code format, refer to the entry named *General Design—Bytecode for
    the Dalvik VM, Android Open Source project* in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting bytecode means actually being able to understand how the instruction
    format works. This section is dedicated to provide you with the references and
    tools you need to understand the Dalvik bytecode. Let's dig into the bytecode
    format and find out how it works and what it all means.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Dalvik bytecode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before jumping into bytecode specifics, it's important to establish some context.
    We need to understand a little about how a bytecode is executed. This will help
    you understand the attributes of the Dalvik bytecode and determine the difference
    between knowing what a piece bytecode is and what a piece of bytecode means in
    a given context of execution, which is a very valuable skill.
  prefs: []
  type: TYPE_NORMAL
- en: The Dalvik machine executes methods one-by-one, branching between methods where
    necessary, for instance, when one method invokes another. Each method can then
    be thought of as an independent instance of the Dalvik VM's execution. Each of
    the methods have a private space of memory called a **frame** that holds just
    enough space to accommodate the data needed for the method's execution. Each frame
    also holds a reference to the DEX file; naturally, the method needs this reference
    in order to reference TypeIds and object definitions. It also holds reference
    to an instance of the program counter, which is a register that controls the flow
    of execution and can be used to branch off into other execution flows. For instance,
    while executing an "if" statement, the method may need to jump in and out of different
    portions of code, depending on the result of a comparison. Frames also hold areas
    called **registers**, which are used to perform operations such as adding, multiplying,
    and moving values around, which may sometimes mean passing arguments to other
    methods, such as object constructors.
  prefs: []
  type: TYPE_NORMAL
- en: A bytecode consists of a collection of operators and operands, with each operator
    performing a specific action on the operands supplied to it. Some of the operators
    also summarize complex operations, such as invoking methods. The simple and atomic
    nature of these operators is the reason they are so robust, easy to read and understand,
    and supportive of a complex high-level language such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to note about Dalvik, as with all intermediate code representations,
    is the order of the operands for the Dalvik bytecode. The destination of the operation
    always appears before the source for the relevant operators, for instance, take
    an operation such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This means that the contents of register B will be placed in register A. A popular
    jargon for this order is "Destination-then-Source"; this means the destination
    of the result of the operation appears first, followed by the operand that specifies
    the source.
  prefs: []
  type: TYPE_NORMAL
- en: Operands can be registers, of which each method, an instance of independent
    execution, has a collection of registers. Operands may also be literal values
    (signed/unsigned integers of a specified size) or instances of a given type. For
    non-primitive types such as strings, the bytecode dereferences a type defined
    in the `TypeIds` section.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of instruction formats that dictate how many registers and
    number of type instances can be used as arguments for given opcodes. You can find
    these specifics at [http://source.android.com/devices/tech/dalvik/instruction-formats.html](http://source.android.com/devices/tech/dalvik/instruction-formats.html).
    It's well worth your time to read through these definitions, because each opcode
    in the Dalvik instruction set and its specifics is merely an implementation of
    one of the opcode formats. Try to understand the format IDs because they make
    for very useful short-hand while reading the instruction formats.
  prefs: []
  type: TYPE_NORMAL
- en: After covering some of the basics, and trusting that you've at least skimmed
    the opcodes and opcode formats, we can move on to dumping some bytecode in a way
    that makes it semantic to read.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start, you will need the Smali decompiler, which is called baksmali.
    As an added convenience, we will now go over how to set up your path variable
    so that you can use the baksmali scripts and a JAR file from anywhere on your
    machine without referencing it canonically every single time. Here''s how you
    set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab a copy of the baksmali JAR file at [https://code.google.com/p/smali/downloads/list](https://code.google.com/p/smali/downloads/list),
    or from the newer repository at [https://bitbucket.org/JesusFreke/smali/download](https://bitbucket.org/JesusFreke/smali/download).
    Look specifically for the `baksmali[version].jar` file—where `[version]` is the
    latest available version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save it in some conveniently-named directory, because to have the two files
    you need to download will need to be in the same directory makes things a whole
    lot easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the baksmali wrapper script; it allows you to avoid invoking the `java
    –jar` command explicitly every time you need to run the baksmali JAR. You can
    grab a copy of the script at [https://code.google.com/p/smali/downloads/list](https://code.google.com/p/smali/downloads/list),
    or from the newer repository at [https://bitbucket.org/JesusFreke/smali/downloads](https://bitbucket.org/JesusFreke/smali/downloads).
    Save it in the same directory as the baksmali JAR file. This step does not apply
    to Windows users, since it's a bash script file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the name of the baksmali jar file to `baksmali.jar`, omitting the version
    number so that the wrapper script you''ve downloaded in step 2 will be able to
    find it. You can change the name using the following command on a Linux or Unix
    machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also do this using whatever window manager your operating system uses;
    as long as you change the name to `baksmali.jar`, you're doing it right!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You then need to make sure that the baksmali script is executable. You can
    do this by issuing it the following command if you''re using a Unix or Linux operating
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add, the current folder to your default `PATH` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And you're all done! You can now decompile the DEX files! See the following
    section to find out how.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, you've got baksmali all downloaded and set up, and you'd like to decompile
    some DEX files into the nice semantic syntax of smali; here's how you do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command from your terminal or command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This command will output the contents for the DEX file as though it''s an inflated
    JAR file, but instead of class files, all of the source files will be `.smali`
    files containing a slight translation or dialect of the semantic Dalvik bytecode
    called smali:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the smali file generated by baksmali and walk through
    what each bytecode instruction means. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that because baksmali, the Android Dalvik VM, and the Java language
    are constantly being improved, you may see slightly different results to the previous
    code sample. Don''t panic if you do; the preceding sample code is intended to
    merely be an example for you to learn from. You will still be able to apply the
    information in this chapter to the code your baksmali generates, whose first few
    lines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'These are merely some metadata on the actual class being decompiled; they mention
    the class name, the source file, and the super class (the class that this method
    inherits from). You may notice from the code of `Example.java` that we never explicitly
    inherit from another class, though when decompiled, `Example.java` seems to have
    a parent: how is this possible? Well, because all Java classes inherit from `java.lang.Object`
    implicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the next bunch of lines are a little more interesting. They are
    the smali code for the constructor of `Example.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `.method public constructor <init>()V`, is a declaration of
    the method to follow. It says that the method called `init` returns a void type
    and has public access flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line that contains the piece of code, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Says that this method only makes use of one register. The method will know
    this because the number of registers it needs are decided before it is run. I''ll
    shortly mention the one register it needs. Following this is a line that looks
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This declares that the method `prologue` follows, which is something every
    Java method has. It makes sure to call the inherited forms of the method, if there
    are any. This explains why the next line, containing the following code, seems
    to invoke another method called `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'But this time it dereferences it from the `java.lang.Object` class. The `invoke-direct`
    method here accepts two arguments: the `p0` register and a reference to the method
    that needs to be called here. This is indicated by the `Ljava/lang/Object;-><init>()V`
    label. The description of the `invoke-direct` opcode is stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"`invoke-direct` is used to invoke a non-static direct method (an instance
    method that is non-overridable by nature and is either a `private` instance method
    or a constructor)."'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An extract is available at [http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html](http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html).
  prefs: []
  type: TYPE_NORMAL
- en: So in summary, all it's doing is calling a non-static direct method that is
    the constructor of the `java.lang.Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the next line of the smali code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It does exactly what it seems to, and that is, return a `void` type and exit
    the current method to return the flow of execution to whichever method invoked
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of this opcode as per the official website is "Return from a
    void method."
  prefs: []
  type: TYPE_NORMAL
- en: Nothing really complex about that. The next line, as with other lines beginning
    with the period (".") character, is a piece of metadata, or a footnote added by
    the smali decompiler, to help add some semantic information about the code. The
    `.end` method line marks the end of this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the main method follows. Here, you will see some code forms that
    will appear over and over again, namely, the code generated when arguments are
    passed to the methods and when they are invoked. Since Java is object-oriented,
    a lot of what you''re doing when your code is calling another object''s methods
    is passing arguments and converting from one object type to another. So, a good
    idea would be to learn to identify when this is happening by decompiling some
    Java code that does this to the smali code. The code for the main method is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the first line `.method public static main([Ljava/lang/String;)V`,
    the method accepts an array of the type `java.lang.String` and returns a void,
    indicated by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Proceeding to the method name, it also says that the main method is static and
    has public access flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the method header, we see the following piece of code, which shows that
    an `sget-object` operation is being formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The description of this opcode as per the official website is "Perform the identified
    object static field operation with the identified static field, loading or storing
    into the value register."
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the official documentation, the `sget-object` operation accepts
    two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A register that Dalvik will use to store the result of the operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object reference to store in the mentioned register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, what this really does is fetch an instance of an object and store it in
    a register. Here, this register is the first register called `v0`. The next line
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The previous code shows the `const-string` instruction in action. What it does
    is fetch a string and save it in the register indicated by the first argument.
    This register is the second register in the main method's frame called `v1`. The
    definition of the `const-string` opcode as per the official website is "Move a
    reference to the string specified by the given index into the specified register."
  prefs: []
  type: TYPE_NORMAL
- en: If it's not obvious enough, the string being fetched here is "Hello World\n".
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the next line is also part of the `const` opcode family and is being
    used here to move a `0` value into the third register named `v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem a little random, but in the next line you''ll see why it needs
    the `0` value in the `v2` register. The code for the next line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What the new array does is construct an array of a given type and size and save
    it in the first register from the left. Here this register is `v2`, so after this
    opcode has been executed, `v2` will hold an array of type `java.lang.Object` which
    has a size of `0`; this is the value of the `v2` register in the second argument
    of the opcode. This also makes the previous operation, of moving a `0` value in
    to `v2` before the execution of this opcode, clear. The definition of this opcode,
    as per the official website is "Construct a new array of the indicated type and
    size. The type must be an array type."
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line contains a very common opcode; make sure you know how this family
    of opcodes works because you''re going to see a lot of it. Moving on, the next
    line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The definition of the `invoke-virtual` opcode as per the official website is
    "`invoke-virtual` is used to invoke a normal virtual method (a method that is
    not `private`, `static`, or `final`, and is also not a constructor)."
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments for the `invoke-virtual` method work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Where `vC`, `vD`, `vE`, `vF`, and `vG` are the argument registers used to pass
    arguments to the method being invoked, which is dereferenced by the last argument
    `meth@BBBB`. This means it accepts a 16-bit method reference since each `B` field
    indicates a field of size 4 bits. In summary, what this opcode does in terms of
    our code for `Example.smali` is it invokes a method called `java.io.PrintStream.printf`,
    which accepts an array of the type `java.lang.Object` and a `java.lang.String`
    object and returns an object of the type `java.io.PrintStream`.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! You've just interpreted some smali code. It takes a bit of practice
    to get used to reading smali code. If you'd like to know more, check out the references
    in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *General Design—Bytecode for the Dalvik VM* Android Open Source Project
    at [http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html](http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Introduction and Overview—Dalvik Instruction Formats* Android Open Source
    Project at [http://source.android.com/devices/tech/dalvik/instruction-formats.html](http://source.android.com/devices/tech/dalvik/instruction-formats.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Analysis of Dalvik Virtual Machine and Class Path Library* document at
    [http://imsciences.edu.pk/serg/wp-content/uploads/2009/07/Analysis-of-Dalvik-VM.pdf](http://imsciences.edu.pk/serg/wp-content/uploads/2009/07/Analysis-of-Dalvik-VM.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling DEX to Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DEX code, as we know, is compiled from Java, which is a pretty semantic,
    easy-to-read language, and I'm sure some of you are wondering by now whether it's
    possible to decompile the DEX code back into Java? Well, the good news is that
    this is possible, of course, depending on the quality of the decompiler you are
    using and the complexity of the DEX code. This is because unless you understand
    how the DEX code actually works, you will always be at the mercy of your DEX decompiler.
    There are many ways to thwart the popular decompilers such as reflection and non-standard
    DEX opcode variants, so if you're hoping that this recipe means you can call yourself
    an Android reverse engineer even though you are unable to read the DEX code, you
    are mistaken!
  prefs: []
  type: TYPE_NORMAL
- en: With that said, most DEX code in Android applications are pretty stock standard,
    and decompilers, such as the one we are about to use, can handle an average DEX
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, you will need to grab a few tools from the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dex2Jar**: This is a tool that grabs the DEX files from the APK files and
    outputs a JAR containing the corresponding class files; you can get this at [http://code.google.com/p/dex2jar/](http://code.google.com/p/dex2jar/).
    Visit this URL and download the version appropriate for your operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JD-GUI**: This is a Java class file decompiler; you can get this at [http://jd.benow.ca/](http://jd.benow.ca/).
    It has support for Linux, Mac, and Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To decompile a sample DEX file into some Java code, you will need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we are starting from either an APK or DEX file. In that case,
    you would start out by interpreting the DEX files into the Java `CLASS` files.
    Here''s how you do that with `Dex2jar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or for our running example, you would execute the following statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look something like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00141.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If you''ve executed this correctly, you should have a file called `Example_dex2jar.jar`
    in your working or current directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00142.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'So now that we have our class files, we need to work them back into the Java
    code. `JD-GUI` is the tool that we will be using to sort this out. To launch `JD-GUI`,
    all you need to do is execute the `JD-GUI` executable that comes with the `JD-GUI`
    tool. Here''s how you do it from Linux; execute the following command from your
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should spawn a window that looks like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00143.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once this window shows up, you can open a class file by clicking on the folder
    icon; the following file selection dialog box should show up:![How to do it...](img/00144.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this dialog box is open, you should navigate to the path with the `Example.class`
    file we parsed from the `Example.dex` file. If you manage to find it, `JD-GUI`
    will display the code as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00145.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can use `JD-GUI` to save the source files; all you need to do is click on
    the **File** menu on the toolbar, select **Save All Sources**, and then provide
    a directory to save it in:![How to do it...](img/00146.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompiling the application's native libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android native libraries are pretty easy to decompile; they are, after all,
    just C/C++ object files and binaries compiled from the ARM platform. So decompiling
    them is as simple as finding a decompiler like the "ever-popular" `objdump` decompiler
    for Linux that accommodates ARM binaries, and, as it turns out, this problem has
    been solved for us by the Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details of this process, you need to make sure you have
    the right tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting ready for this recipe is as easy as making sure you have a fresh copy
    of the Android NDK package; you can grab a copy at [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decompiling a native library is as simple as invoking one of the tools provided
    with the Android NDK toolchain known as `objdump`; it has been prebuilt to include
    all of the plugins that allow `objdump` to interpret the endianness and code structures
    specific to the ARM binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decompile an Android native library, you need to execute the following command
    from your terminal or command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Where `arm-linux-androideabi-objdump` is located under the `toolchains/arm-linux-androideabi-[version]/prebuilt/[arch]/bin/`
    folder of the Android NDK, where `[arch]` would be the architecture or build version
    relevant to your machine. I'm using a Linux x86_64 machine in this example.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of the information in the output of `objdump`, you need to understand
    the opcode formats and instructions for the ARM platform and a little about the
    ELF format. I've included some good references to follow up in the *See also*
    section, including a link to an Android application called Sieve, which is used
    to demonstrate some of the commands used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *ELF for the ARM Architecture* document at [http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E_aaelf.pdf](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E_aaelf.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ARM7TDMI Technical Reference Manual* document at [http://www.atmel.com/Images/DDI0029G_7TDMI_R3_trm.pdf](http://www.atmel.com/Images/DDI0029G_7TDMI_R3_trm.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ARM Processor Architecture* webpage at [http://www.arm.com/products/processors/instruction-set-architectures/index.php](http://www.arm.com/products/processors/instruction-set-architectures/index.php)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Tool Interface Standard (TIS) Executable and Linking Format (ELF) Specification
    Version 1.2* document available at [http://refspecs.linuxbase.org/elf/elf.pdf](http://refspecs.linuxbase.org/elf/elf.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sieve* – A password manager app, showcasing some common Android vulnerabilities
    at [https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk](https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the Android processes using the GDB server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging processes via some GDB-like tool is what most memory corruption, buffer
    overflow, and malware analysis jockeys do every day. Inspecting memory and performing
    dynamic analysis of an application process is something fundamental to any reverse
    engineer no matter what platform you're focused on; this, of course, includes
    Android. The following recipe shows you how to debug a process running on an Android
    device using GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to pull off this recipe, you''ll need to grab the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android NDK package available at [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android SDK package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To debug a live Android process using `gdbserver`, you will need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make sure that you either have a rooted Android device
    or an up-and-running emulator. I''m not going to detail the entire process of
    setting up an emulator here, but if you''re not clear on the details of getting
    an emulated Android device up and running, refer to the *Inspecting application
    certificates and signatures* recipe in [Chapter 2](part0025_split_000.html#page
    "Chapter 2. Engaging with Application Security"), *Engaging with Application Security*.
    If you''re already aware of how to create an emulated Android device, you can
    launch it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00148.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once the emulator or target device is up and running, you should access the
    device using an ADB shell. You can do this by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You also need to make sure that you have root permissions. Emulators grant root
    permissions by default, though, if you're doing this on an actual device, you
    may need to execute the `su` substitute user command first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You then need to mount the system directory as read-write so that we can pop
    a copy of `gdbserver` into it. Here''s how you remount the directory, while in
    your adb shell, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00149.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This should output some information about where each block device is mounted;
    we are interested in the `/system` directory. Take note of the `/dev/` path printed
    in the line mentioning `/system`. In the previous example, the device called `/dev/block/mtdblock0`
    is mounted at `/system`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remount the directory using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00150.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You''re now ready to pop a copy of the `gdbserver` into the device. Here''s
    how you do this from your non-Android machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/00151.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once `gdbserver` is on the target device, you can launch it by attaching it
    to a running process; but before you can do that, you''ll need to grab a sample
    **Process ID** (**PID**). You can do that by launching the `ps` command on the
    target device in the following manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ps` command will list a summary of information of the current running
    processes; we are interested in the PID of one of the current running processes.
    Here''s an example of the `ps` command output from the emulator we are running:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00152.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see that the second column is titled `PID`;
    this is the information you''re looking for. The calendar, which was used as an
    example here, has a PID of `766`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00153.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once you have a valid PID, you can use `gdbserver` to attach to it by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Where `[tcp-port number]` is the number of a TCP port you''d like to allow
    connections from, and PID is, of course, the PID number you grabbed in the previous
    step. If this is done correctly, `gdbserver` should produce the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00154.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once `gdbserver` is up and running, you need to ensure that you forward the
    TCP port number from the target Android device so that you can connect to it from
    your machine. You can do this by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the `adb` port forward from the example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00155.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You should then launch the prebuild `gdb`, which is found under the path `android-ndk-r8e/toolchains/arm-linux-androideabi-[version]/prebuilt/linux-x86_64/bin/`,
    on your Linux machine. You launch it by running the following command once inside
    the aforementioned NDK path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a screenshot of how it''s being launched:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00156.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once `gdb` is up and running, you should try to connect it to the `gdb` instance
    running the target device by issuing the following command from within the `gdb`
    command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Where `[PID]` is the local TCP port number you forwarded using `adb` in step
    8\. Here''s a screenshot of this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00157.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: And that's it! You have an interaction with the memory segments and registers
    of the processes running on the Android device!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
