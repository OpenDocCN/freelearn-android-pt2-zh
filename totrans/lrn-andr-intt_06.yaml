- en: Chapter 6. Accessing Android Features Using Intents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed data transfer using components. We saw how
    to transfer data from one activity to the other, and why we should transfer data
    between different components. We also discussed the various methods of data transfer
    using intents. Android has a lot of components in the system, and intent provides
    an easy interface to make those components communicate with each other. In [Chapter
    4](ch04.html "Chapter 4. Intents for Mobile Components"), *Intents for Mobile
    Components*, we discussed the different Android components that use system hardware
    such as Wi-Fi, Bluetooth, camera, microphone, and so on. We also discussed how
    these components can be utilized using intents and how we can make many different
    applications using Android hardware with no more than few lines of code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have only discussed hardware components and the role of intents
    with those components. This chapter is all about Android software features and
    how we can use those features in our applications using intents as the primary
    interface. Android contains a vast collection of libraries and APIs, by which
    a developer can use different Android features very easily. This chapter will
    walk us through the common Android features, and we will also develop some example
    applications that will show us the use of intents with those features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Features of Android OS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android features versus components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Android OS features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android features and intents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<uses-feature>` and `<uses-permission>` tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing using the SEND action
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending SMS/MMS using intents
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data messages using intents
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirming message delivery
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving SMS
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telephony and making calls using intents
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications using intents
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other Android features
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The concepts and structure of intents, as discussed in previous chapters, are
    the prerequisites for understanding this and the following chapters. If you don't
    have the basic concept of these things, we would recommend you to read [Chapter
    3](ch03.html "Chapter 3. Intent and Its Categorization"), *Intents and Its Categorization*
    and [Chapter 4](ch04.html "Chapter 4. Intents for Mobile Components"), *Intents
    for Mobile Components* in order to move forward.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Features of Android OS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is an open source operating system and middleware framework for smart
    devices such as phones and tablets. The devices contain lots of features and functionalities
    that provide users with a way for an easy lifestyle. These features include hardware
    features such as audio, Bluetooth, camera, network, microphone, GSM, NFC, and
    sensors such as accelerometer, barometer, compass, gyroscope, and Wi-Fi.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Not only does it include hardware components, it also includes software features
    such as app widgets, home screen, input methods, live wallpapers, layouts, storage,
    messaging, multi-language support, browsers, Java support, media support, multi-touch,
    calls, messaging, multitasking, accessibility, external storage, and so on. We
    have already referred to the hardware features as mobile components and discussed
    them in the previous chapters. We will discuss the software features in this chapter
    with practical examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅包括硬件组件，还包括软件特性，如应用小部件、主屏幕、输入法、动态壁纸、布局、存储、消息传递、多语言支持、浏览器、Java支持、媒体支持、多点触控、通话、消息传递、多任务处理、可访问性、外部存储等。我们之前已经将硬件特性称为移动组件，并在前面的章节中进行了讨论。我们将在本章中通过实际示例讨论软件特性。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'We are using two key terms here: components and features. Components such as
    camera, Bluetooth, and so on are the hardware parts of an android phone . The
    feature is the software part of an Android phone, such as an SMS feature, e-mail
    feature, and so on. This chapter is all about software features, their access,
    and their use through intents.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用两个关键词：组件和特性。摄像头、蓝牙等组件是安卓手机的硬件部分。特性是安卓手机的软件部分，如短信特性、电子邮件特性等。本章将介绍软件特性、它们的访问方式以及通过意图使用它们的方式。
- en: Android features versus components
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓特性与组件
- en: Generally, the terms "Android features" and "components" are used interchangeably.
    But for the sake of clarification, we are referring to the keyword *components*
    as a feature that uses hardware and the keyword *features* as an Android feature
    that uses software in its backend. As we discussed in the previous section, Android
    contains lots of components and features that, when ported to any phone, makes
    it a smart phone. Not all the components and features can be used via intents.
    So, we will discuss only those features in detail that can be used by intents.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，“安卓特性”和“组件”这两个词可以互换使用。但为了明确起见，我们将关键词*组件*定义为使用硬件的特性，而将关键词*特性*定义为在后台使用软件的安卓特性。正如我们在上一节中讨论的，安卓包含许多组件和特性，当这些组件和特性被移植到任何手机上时，就使其成为智能手机。并非所有的组件和特性都可以通过意图使用。因此，我们将详细讨论那些可以通过意图使用的特性。
- en: It should be noted that features that use hardware directly or indirectly require
    users to provide permissions to access it. These permissions are provided during
    the application's installation. If the user doesn't provide permissions to the
    application, the application can't access hardware; thus, it can't use that feature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，直接或间接使用硬件的特性需要用户提供访问权限。这些权限在应用程序安装过程中提供。如果用户没有向应用程序提供权限，应用程序将无法访问硬件；因此，它无法使用该特性。
- en: In this chapter, we will learn about those features that use software as backend
    but also require some permissions. We will provide more details about the permissions
    in the following sections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解那些在后台使用软件但还需要一些权限的特性。我们将在以下部分提供有关权限的更多详细信息。
- en: Common Android features
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见安卓特性
- en: Until now, we are only talking about Android features in a general way. In this
    section, we will discuss some of the most common Android features found in Android
    phones and tablets. Each Android device is unique in some way or the other and
    possesses many unique features and components different from other brands and
    phones. But there are some features that are found to be common in all the Android
    phones. Many of these features can be used in our apps irrespective of any specific
    model or phone, and intent is, without any doubt, the most asynchronous and easy
    way to use these features in our applications. Now let's see the Android features
    that are common among many devices and their functionality in a phone.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是以一般方式讨论了安卓特性。在本节中，我们将讨论在安卓手机和平板电脑中常见的一些最常用的安卓特性。每个安卓设备在某些方面都是独一无二的，并且拥有许多与其他品牌和手机不同的独特特性和组件。但是在所有安卓手机中都能找到一些共同的特性。这些特性中的许多可以用于我们的应用程序，无论具体的型号或手机如何，意图无疑是最异步且简单的方式来在应用程序中使用这些特性。现在，让我们看看在许多设备中常见的安卓特性及其在手机中的功能。
- en: Layouts and display
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局和显示
- en: 'Today, smartphones are getting bigger in size, and there are new sets of Android
    devices called tablets that are available. Bigger screens and higher-resolution
    displays have transformed mobiles into multimedia devices. These devices contain
    layout sizes from 240 x 320 to 1268 x 800 pixels and screen sizes from 3 to 11
    inches. These are found in varying device screen densities such as low, medium,
    high, large, extra large, and so on. The following image shows three different
    devices with different resolutions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts and display](img/9639_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Android devices with different screen sizes
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: To display high graphics, Android provides graphic libraries for 2D canvas drawings
    and 3D graphics with OpenGL using OpenGL-ES. A new rendering graphics library
    called RenderScript was introduced after Android Version 3.0\. RenderScript is
    a scripting language for Android OS that allows developers to write high-performance
    graphic rendering and raw computational code. It has been primarily oriented for
    use with parallel data computations like dividing processing across multi-core
    processors such as CPUs, GPUs, or DSPs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Android Version 3.0, which was developed for Android tablets, Android
    rendered its layouts, home screen, and mobile UI using 2D canvas. After RenderScript
    in Android 3.0, Android renders its layouts, home screens, and mobile UI with
    more beautiful and optimized graphics using RenderScript.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Data storage and retrieval
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no Android device that doesn't use any kind of storage for running.
    For better performance, the device not only needs a volatile memory like RAM for
    the sake of processing and faster access, but it is also going to need a permanent
    storage such as an external SD Card in it. Android devices support data storage
    and retrieval in multiple ways that vary according to the developers and applications
    to be used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: If our applications use large data, the developers can use lightweight relational
    database features for each of their applications using SQLite. Developers can
    use the SQLite database to manage data with secret and efficient storage capability.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Not only databases, Android devices also provide features for file storage.
    As saving and loading data is essential for almost every application, Android
    provides many different methods to store and retrieve data to make our application
    persistent. File storage is not a good option, but sometimes, developers don't
    have any option other than reading and writing files to handle their application's
    persistent data. And fortunately, Android provides features that let developers
    create, save, and load files on a device's internal or external media, such as
    an SD card. These microSD cards are formatted with the FAT32, Ext3, or Ext4 file
    systems. Not only these file systems, but also some Android devices, mostly tablets,
    support high-capacity storage media such as USB flash drives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Apart from storing large or heavy data in databases or disk files, Android provides
    a feature for storing simple application data such as UI state, game scroes, and
    so on. This is achieved using the `SharedPreferences` method. The `SharedPreferences`
    method uses the name/value pair (NVP) mechanism to store the application's lightweight
    data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在数据库或磁盘文件中存储大量或重型数据外，安卓还提供了一个用于存储简单应用程序数据的功能，如UI状态、游戏得分等。这是通过使用`SharedPreferences`方法实现的。`SharedPreferences`方法使用名称/值对（NVP）机制来存储应用程序的轻量级数据。
- en: Connectivity and communication
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和通信
- en: We can't call an Android device a smart phone until there is a connectivity
    feature in it. The technologies supported for connectivity, communication, and
    data transfer include GSM/Edge, IDEN, CDMA, EV-DO, Bluetooth, Wi-Fi, LTE, Near-Field
    Communication (NFC), WiMAX, and so on. Android provides a complete set of libraries
    for communication and connectivity. This allows developers to easily utilize and
    use these features in their applications. For example, through Bluetooth support,
    users can send files, access phone book and voice dialing, and exchange contacts
    between phones.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备连接功能之前，我们不能将一个安卓设备称为智能手机。支持连接、通信和数据传输的技术包括GSM/Edge、IDEN、CDMA、EV-DO、蓝牙、Wi-Fi、LTE、近场通信（NFC）、WiMAX等。安卓提供了一套完整的通信和连接库。这使得开发者可以轻松地在他们的应用程序中使用这些功能。例如，通过蓝牙支持，用户可以发送文件，访问电话簿和语音拨号，以及在不同手机间交换联系人。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Android 3.1 and the later versions, Android contains the native feature of
    connecting keyboard, mouse, and joystick devices with Android phones via Bluetooth
    communication. Before Android 3.1, some third-party applications provided a customized
    way for this purpose.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓3.1及其之后的版本中，安卓包含了通过蓝牙通信将键盘、鼠标和游戏手柄设备与安卓手机连接的原生功能。在安卓3.1之前，一些第三方应用程序为此提供了定制的方法。
- en: Android phones have communication support not only for data transfer but also
    for telephony and messaging. Android contains SMS and MMS for messaging along
    with threaded text messaging and **Android Cloud to Device Messaging** (**C2DM**),
    and the new **Google Cloud Messaging** (**GCM**) is also part of Android Push
    Messaging services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓手机不仅支持数据传输，还支持电话和短信通信。安卓包含了用于短信通信的SMS和MMS，以及线程化文本消息和**安卓云到设备消息传递**（**C2DM**），新的**谷歌云消息传递**（**GCM**）也是安卓推送消息服务的一部分。
- en: For telephony, Android supports calls, but it doesn't have native support for
    video calling (at the time of writing this book); however, some Android devices
    have customized versions of operating systems that allow developers and users
    to make video calls either via UMTS networks (as in Samsung Galaxy S) or over
    IP. Also, Google Hangout, the replacement of Google Talk, is available in Android
    2.3.4 and higher versions. This allows users to make video calls using an Internet
    connection. To use Google Hangout video calling, users need a Google+ account.
    Skype, a third-party tool of Microsoft Corporation, is also used to make video
    calls in Android 2.3 and later versions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电话功能，安卓支持通话，但在撰写本书时并不支持原生视频通话；然而，一些安卓设备定制的操作系统版本允许开发者和用户通过UMTS网络（如三星Galaxy
    S）或IP进行视频通话。此外，谷歌环聊（Google Hangout），取代了谷歌Talk，在安卓2.3.4及更高版本中可用。这允许用户使用互联网连接进行视频通话。要使用谷歌环聊视频通话，用户需要一个谷歌+账户。微软公司的第三方工具Skype也用于在安卓2.3及以后版本中进行视频通话。
- en: Accessibility and multitouch
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性和多点触控
- en: An Android device runs on a fully touch-based interface and contains few hard-
    or soft-touch buttons that vary according to the device. Android devices have
    native support for multi-touch. Multi-touch technology allows developers and users
    to use single touch, tap, double tap, long touch, pinch-zoom gesture, rotate gestures,
    swipe gestures in all directions, and much more. Android's latest version (which
    is Android 4.4 KitKat at the time of writing this book) contains some new touch
    gestures such as tap and long touch gesture, scroll gesture, and so on. Also,
    Samsung introduced touchless gestures that make use of their specific APIs called
    Look API. Through Look API, users can use their phones without touching the screen
    and moving their hands or head in air, and Android will perform the desired functionality.
    For example, moving the head up will scroll the page up, and moving the head down
    will scroll the page down on their phones. Also, many Android device manufacturers,
    such as Samsung, introduced pen features to allow the users to write on their
    phones and use them with pens more easily and accurately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The multi-touch feature was first introduced in the HTC Hero Android phone.
    Before that, the feature was originally disabled at the Linux kernel level due
    to Apple's patents on touch-screen technology at that time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Along with touch, users can access their phones with a voice or speech recognition
    engine natively introduced in Android phones. Also, Android contains a feature
    called Talkback that allows people with no or low vision to hear what their Android
    phone is doing at a particular time. These people can access their phones using
    voice actions such as calling, texting, navigation, and so on. These voice actions
    were introduced from Android 2.2 onwards. The ability to control hardware is not
    yet (at time of writing this book) available through voice actions in Android.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android 4.1 and the later versions provide enhancement over voice actions to
    read answers from Google Knowledge Graph when queried with specific commands only.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Extensive content and media support
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Android device is not less than any computer with high-definition media support.
    Android offers comprehensive APIs for managing images, videos, and audio. The
    formats supported in Android devices include WebM, H.263, H.264, 3GP, MP4, MPEG-4,
    AMR, MP3, MIDI, OGG, WAV, JPEG, PNG, GIF, BMP, and WebP. Not only this, Android
    also provides features for streaming online media using RTP/RTSP protocols, HTML
    progressive downloads such as the HTML5 `<video>` tag, HTTP dynamic streaming
    protocol, and the Adobe Flash Streaming (RTMP) protocol provided by Flash plugins.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New Android devices support 3D-image capturing. and 3D Video Support as their
    native features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Along with extensive media support, Android also provides playback features,
    controls, players, hard buttons for sound control as with other mobile phones,
    fullscreen playback, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Android not only has media support but also has content support such as text
    files, word documents, HTML, and so on. The web browsers available in Android
    are based on the open source WebKit layout engine that was first developed by
    Apple Inc. This is coupled with Chrome's V8 JavaScript engine in Android.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓不仅支持多媒体，还支持内容格式，如文本文件、Word文档、HTML等。安卓中可用的网页浏览器基于开源的WebKit布局引擎，该引擎最初由苹果公司开发。这与Chrome的V8
    JavaScript引擎相结合，在安卓系统中使用。
- en: While most Android applications are written in Java natively, Android doesn't
    support Java byte code due to the unavailability of the Java Virtual Machine in
    Android. This Java code is instead compiled in the Dalvik executable and run on
    the Dalvik Virtual Machine, a specialized virtual machine for Android systems.
    The most important thing in Dalvik, which separates it from the Java Virtual Machine,
    is that it is optimized for a low-battery life with limited memory and CPU.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数安卓应用程序原生是用Java编写的，但由于安卓系统中没有Java虚拟机，因此不支持Java字节码。这个Java代码反而被编译成Dalvik可执行文件，在专为安卓系统设计的Dalvik虚拟机上运行。Dalvik最重要的特点是，它与Java虚拟机相比，针对低电量、有限内存和CPU进行了优化。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android browser has got a 100/100 score on Acid3 test in Android 4.0 Version.
    The Acid3 test is a web test page from Web Standards Project that checks a web
    browser's compliance with elements of various web standards such as Document Object
    Model (DOM), JavaScript, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓浏览器在安卓4.0版本中 Acid3 测试得到了100/100的分数。 Acid3 测试是由Web Standards Project提供的网页测试页，用于检查网页浏览器对各种网页标准元素（如文档对象模型（DOM）、JavaScript等）的符合性。
- en: Hardware support
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件支持
- en: An Android device not only provides features of telephony, such as making phone
    calls, sending messages, and so on, but it also has lots of features with new
    hardware components that are used for many different purposes. Android has features
    of video cameras, touchscreens, Global Positioning System (GPS) for location-based
    applications, accelerometers, gyroscopes, barometers, magnetometers, proximity
    sensors, pressure sensors, thermometers, Wi-Fi, Bluetooth, and dedicated gaming
    controls.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备不仅提供了电话功能，如拨打电话、发送短信等，而且还具有许多新硬件组件的多种功能。安卓具有视频摄像头、触摸屏、全球定位系统（GPS）用于基于位置的应用程序、加速度计、陀螺仪、气压计、磁力计、接近传感器、压力传感器、温度计、Wi-Fi、蓝牙和专用的游戏控制功能。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some new Android phones, such as Samsung Galaxy S4, provide new sensors such
    as light and color sensors used to capture touchless gestures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些新的安卓手机，例如三星Galaxy S4，提供了新的传感器，如光和颜色传感器，用于捕捉无需触摸的手势。
- en: With GPS and location-based technology included in Android phones, Android systems
    have got native support for Google Maps, Google's GSM cell-based location technology
    used to determine a device's current position. To make maps more useful for developers
    and users, Android also provides native APIs for forward and reverse geocoding
    support that helps to translate coordinates into address and vice-versa.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓手机包含了GPS和基于位置的技术，因此安卓系统本地支持谷歌地图，以及谷歌基于GSM小区的位置技术，用于确定设备的当前位置。为了使地图对开发者和用户更有用，安卓还提供了本地API，支持正向和反向地理编码，帮助将坐标转换为地址，反之亦然。
- en: Background services and multitasking
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后台服务和多任务处理
- en: Due to limited screen dimensions in Android smart phones, only one application
    becomes visible on the user interface screen. But Android supports applications
    and services running in the background with its multitasking feature. Using background
    services, developers can perform automatic processing that doesn't require any
    user interaction. Some example applications for this feature include generating
    alerts; monitoring messages, statistics, and weather reports; downloading data
    from the Internet; or playing audio files in the background.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安卓智能手机的屏幕尺寸有限，用户界面屏幕上只能显示一个应用程序。但安卓支持多任务功能，可以让应用程序和服务在后台运行。开发者可以利用后台服务执行不需要用户交互的自动处理。这一特性的应用示例包括生成提醒；监控消息、统计和天气预报；从互联网下载数据；或者在后台播放音频文件。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When an Android device gets low on memory, it stops applications with low priority
    in the background. Developers should store the necessary data and state of application
    before going in the background so that on getting stopped, an application can
    restore its state from the saved one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当安卓设备内存不足时，它会停止后台中优先级较低的应用程序。开发者应该在应用程序进入后台之前存储必要的数据和应用程序状态，这样在被停止时，应用程序可以从保存的状态中恢复其状态。
- en: Android also supports the notification feature, a standard traditional approach
    to alert users in their phones. Using Android libraries for notifications, developers
    can make notification alerts that can be audible, vibration supported, or maybe
    LED active. In addition to this, Android also allows developers to set notification
    UI icons, layouts, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓同样支持通知功能，这是一种传统的标准方式，用于在手机中提醒用户。开发者可以使用安卓的通知库来创建可以发出声音、支持震动或者激活LED灯的通知提醒。此外，安卓还允许开发者设置通知界面图标、布局等。
- en: These background applications can be standalone as well as dependent on other
    applications. Android provides features such as intents and content providers
    for inter-application communication methods and mechanisms.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些后台应用程序可以是独立的，也可以依赖于其他应用程序。安卓提供了如意图和内容提供者等特性，用于应用程序间的通信方法和机制。
- en: Enhanced home screen
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的主屏幕
- en: The home screen is like a desktop screen of a computer or laptop. Android users
    get quick links, app shortcuts, and information on their home screen. Android
    provides customizable features for the home screen. Widgets, live folders, and
    live wallpapers make the home screen more interactive and beautiful for users.
    These apps let Android developers create dynamic application components that provide
    a window into your applications or offer useful and timely information directly
    on the home screen. Developers can also provide users with an option to add shortcuts
    on their home screens. These shortcuts will provide users with the necessary information,
    and they won't need to open their apps. For example, we have an app that tells
    us the current time and weather of the day. Now, whenever users want to check
    the time and weather, they have to open the app. So, instead of creating an app
    for this purpose, creating a home screen widget would be much better idea. This
    widget will show the weather and time on the home screen, and users wouldn't have
    to open the app then.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕就像电脑或笔记本电脑的桌面屏幕。安卓用户可以在主屏幕上获得快速链接、应用快捷方式和信息。安卓为主屏幕提供了可定制功能。小部件、活动文件夹和动态壁纸使主屏幕对用户来说更加互动和美观。这些应用程序允许安卓开发者创建动态的应用程序组件，它们可以直接在主屏幕上提供应用程序的窗口或提供有用及时的信息。开发者还可以为用户提供在主屏幕上添加快捷方式的选项。这些快捷方式为用户提供必要的信息，他们无需打开应用程序。例如，我们有一个显示当前时间和天气的应用程序。现在，每当用户想要查看时间和天气时，都需要打开应用。因此，与其为此目的创建应用程序，不如创建一个主屏幕小部件会是一个更好的主意。这个小部件会在主屏幕上显示天气和时间，用户就不需要打开应用程序了。
- en: Other Android features
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓的其他功能
- en: Android developers can develop applications in multiple languages, offering
    the local version of the application to the users. Android provides the feature
    of multilanguage applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发者可以用多种语言开发应用程序，为用户提供应用程序的本地版本。安卓提供了多语言应用程序的特性。
- en: Also, Android supports tethering that allows users to share the network connection
    of a device with other mobile phones and computers. This sharing can be achieved
    via Wi-Fi hot spot or USB tethering.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，安卓支持网络共享功能，允许用户将设备的网络连接分享给其他手机和电脑。这种共享可以通过Wi-Fi热点或USB网络共享来实现。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tethering was introduced in Android 2.2 Version; so, the earlier versions had
    tethering support through third-party applications and manufacturers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 网络共享功能在安卓2.2版本中引入；因此，早期版本通过第三方应用程序和制造商支持网络共享。
- en: Pressing the power and volume-down hard buttons at the same time allows users
    to capture a screenshot of the device. This feature was first introduced in Android
    4.0\. The earlier versions are using third-party applications, but these applications
    need a rooted device as a prerequisite. Developers can also take screenshots using
    the DDMS tool via a PC connection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同时按下电源键和音量减键可以让用户捕获设备的屏幕截图。这个功能最早是在安卓4.0中引入的。早期版本使用第三方应用程序，但这些应用程序需要设备已获得根权限作为前提条件。开发者也可以通过PC连接使用DDMS工具来截图。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rooting any Android device is not allowed, and it breaks all the warranty and
    guarantee deals and can sometimes be a risky procedure for mobiles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任何安卓设备的root操作都是被禁止的，这样做会违反所有的保修和保证协议，有时也可能对手机造成风险操作。
- en: Android features and intents
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓功能和意图
- en: Until now, we have discussed the different features commonly found in Android
    phones and tablets, but we are still unaware of the connection between intents
    and these features. There are some features that can be used via intents and some
    cannot. Simply to remind you, intents are asynchronous messages between different
    applications and the Android system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经讨论了安卓手机和平板电脑中常见的不同功能，但我们仍然不知道意图（intents）与这些功能之间的联系。有些功能可以通过意图使用，而有些则不能。简单提醒一下，意图是不同应用程序与安卓系统之间的异步消息。
- en: 'In this chapter, we will discuss a few features that can be used through intents,
    and see how intents perform various actions. We have divided the features into
    four sections: messaging, telephony, notifications, and alarms. We will develop
    some examples that will use intents and access these features, and we will discuss
    how these features are accessed and the role of intents in them.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些可以通过意图使用的功能，并了解意图是如何执行各种动作的。我们将功能分为四个部分：消息传递、电话、通知和闹钟。我们将开发一些使用意图并访问这些功能的示例，并讨论如何访问这些功能以及意图在其中的作用。
- en: Before we start discussing these example applications, we are going to discuss
    some basic terminology used in Android for the clarification of concepts between
    intents and features. In the next section, we will discuss two different tags,
    `uses-feature` and `uses-permission`, from the `AndroidManifest` file. These tags
    are used to declare some permissions and settings for any Android application.
    Let's see what they are for in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始讨论这些示例应用程序之前，我们将讨论一些在安卓中用于澄清意图和功能之间概念的基本术语。在下一节中，我们将讨论 `AndroidManifest`
    文件中的两个不同标签，`uses-feature` 和 `uses-permission`。这些标签用于声明任何安卓应用程序的一些权限和设置。让我们在下一节中看看它们的作用。
- en: The <uses-feature> and <uses-permission> tags
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<uses-feature>` 和 `<uses-permission>` 标签'
- en: Any Android application, by default, doesn't have the permission to perform
    any operations that impact any other application, system, or the user directly
    or indirectly. This includes reading or writing the user's private data such as
    contacts and messages, reading or writing other applications' files, or any other
    activity. The Android system allows applications to be standalone and sandboxed,
    but in case of sharing data, the applications must explicitly share it with each
    other. To achieve this objective of sharing more easily, Android allows developers
    to declare permissions in their applications for the activities that the app wants
    to perform. Users will be informed about the permissions that allow them to install
    the application on their devices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何安卓应用程序默认情况下都没有权限执行可能直接影响其他应用程序、系统或用户的行为。这包括读取或写入用户的私人数据，如联系人和短信，读取或写入其他应用程序的文件，或任何其他活动。安卓系统允许应用程序独立运行并被沙盒化，但在共享数据的情况下，应用程序必须明确地相互共享。为了更轻松地实现这一共享目标，安卓允许开发者在他们的应用程序中声明所需执行活动的权限。用户将被通知有关允许他们在设备上安装应用程序的权限。
- en: 'Developers need to bear two things in mind regarding permissions: the permissions
    for device capabilities such as accessing camera or hardware and defining custom
    permissions. We will be discussing the first option of accessing device features
    and hardware and granting permissions to the application in this topic. This can
    be achieved using two tags in the manifest file: the `uses-feature` tag and the
    `uses-permission` tag.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要记住关于权限的两件事：设备功能的权限，如访问相机或硬件，以及定义自定义权限。在本主题中，我们将讨论第一种选择，即访问设备功能和硬件，并授予应用程序权限。这可以通过在清单文件中使用两个标签来实现：`uses-feature`
    标签和 `uses-permission` 标签。
- en: 'Firstly, we will talk about the `<uses-feature>` tag. The `<uses-feature>`
    tag lets the developers declare any single hardware or software feature to be
    used by the application. This is declared in the `AndroidManifest` file in the
    `<manifest>` tag of the application, and as the name of tag suggests, this informs
    the application about the dependent entities to be accessed. The following code
    snippet shows the general declaration of the `<uses-feature>` tag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论`<uses-feature>`标签。`<uses-feature>`标签允许开发者声明应用程序将使用的任何单一硬件或软件特性。这将在应用程序的`AndroidManifest`文件的`<manifest>`标签中声明，正如标签名称所暗示的，这会通知应用程序有关要访问的依赖实体。以下代码段展示了`<uses-feature>`标签的一般声明方式：
- en: '![The <uses-feature> and <uses-permission> tags](img/9639_06_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![`<uses-feature>`和`<uses-permission>`标签](img/9639_06_02.jpg)'
- en: 'You can see that there are three attributes in the `<uses-feature>` tag: `name`,
    `required`, and `glEsVersion`. The `android:name` attribute specifies any single
    hardware or software feature used by the application in the form of a string descriptor.
    The `android:required` attribute is quite an important attribute in the `<uses-feature>`
    tag. It is a Boolean value indicating if an application needs the feature that
    is specified in the `android:name` attribute. If the developer declares `android:required="true"`
    for any feature, it means that the application won''t run without the specified
    feature available on the device. If the developer declares `android:required="false"`
    for the feature, it means that the application prefers the feature to be available
    on the device. If the feature is not available, the application won''t work properly
    or may crash when using the feature due to its unavailability. The default for
    this attribute is true. The final attribute in the `<uses-feature>` tag is `android:glEsVersion`.
    This is a version number represented in 16 bits. This attribute specifies the
    OpenGL ES version that the application will use. For example, we are using a camera
    in our application. The following code snippet shows how to declare the permissions
    for a camera in the manifest file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`<uses-feature>`标签中有三个属性：`name`、`required`和`glEsVersion`。`android:name`属性以字符串描述符的形式指定应用程序使用的任何单一硬件或软件特性。`<uses-feature>`标签中的`android:required`属性相当重要。它是一个布尔值，表示应用程序是否需要`android:name`属性中指定的特性。如果开发者对任何特性声明`android:required="true"`，这意味着没有指定特性在设备上可用时，应用程序将无法运行。如果开发者对特性声明`android:required="false"`，这意味着应用程序希望设备上有该特性。如果该特性不可用，应用程序可能无法正常工作，或者在尝试使用不可用的特性时可能会崩溃。此属性的默认值为true。`<uses-feature>`标签中的最后一个属性是`android:glEsVersion`。这是一个16位表示的版本号。此属性指定应用程序将使用的OpenGL
    ES版本。例如，我们的应用程序中使用了摄像头。以下代码段展示了如何在清单文件中为摄像头声明权限：
- en: '![The <uses-feature> and <uses-permission> tags](img/9639_06_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![`<uses-feature>`和`<uses-permission>`标签](img/9639_06_03.jpg)'
- en: You can see in the code that we have used the `android.hardware.camera` string
    for the `android:name` attribute. This string declares the camera feature of Android,
    and other attributes declare that the application requires the camera feature
    and supports the OpenGL ES 1.0 Version for it to work properly. The developer
    must specify each feature used in the application in a separate `<uses-feature>`
    tag; so, if the application requires multiple features, multiple tags should be
    declared in the manifest file. It is a good practice to declare all the features
    used in an application. These declared tags of `<uses-feature>` only provide information,
    and the Android system doesn't check for matching features before the installation
    of the application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中看到，我们使用了`android.hardware.camera`字符串作为`android:name`属性。这个字符串声明了Android的摄像头特性，其他属性声明应用程序需要摄像头特性，并支持OpenGL
    ES 1.0版本以便它能正常工作。开发者必须在应用程序中为每个使用的特性在单独的`<uses-feature>`标签中指定；因此，如果应用程序需要多个特性，应在清单文件中声明多个标签。声明应用程序中使用的所有特性是一个好习惯。这些声明的`<uses-feature>`标签只提供信息，Android系统在应用程序安装前不会检查匹配的特性。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Google Play uses the `<uses-feature>` tag declared in the manifest file to filter
    the application from devices that do not meet its software and hardware requirements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play使用在清单文件中声明的`<uses-feature>`标签，来过滤掉不符合其软件和硬件要求的设备上的应用程序。
- en: The `<uses-feature>` tag was first introduced in API Level 4\. The earlier versions
    simply ignore this tag if an application containing the `<uses-feature>` tag is
    running on lower-version devices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tables show a list of a few feature types and name strings for
    hardware and software features respectively. They can be used in the `<uses-feature>`
    tag''s `android:name` attribute:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Hardware features
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Feature type | Feature descriptor (Android name) | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| Bluetooth | `android.hardware.bluetooth` | This feature allows the application
    to use Bluetooth of the device. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| Camera | `android.hardware.camera` | This feature allows the application
    to use the camera component of the device. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.camera.flash` | This is subfeature that allows the application
    to use the device''s camera''s flash. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| Location | `android.hardware.location.gps` | This subfeature allows the application
    to use the precise location coordinates obtained from the Global Position System
    (GPS) receiver of the device. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| Sensors | `android.hardware.sensor.accelerometer` | This feature allows the
    application to use motion reading from the accelerometer sensor of the device.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.sensor.compass` | This feature allows the application to
    use directional readings from a compass of the device. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.sensor.proximity` | This feature allows the application
    to use the proximity sensor of the device. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| Screen | `android.hardware.screen.landscape` | This feature sets the application''s
    screen orientation to landscape. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.screen.portrait` | This feature sets the application''s
    screen orientation to portrait. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| Touchscreen | `android.hardware.touchscreen.multitouch` | This subfeature
    allows the application to use two-point multi-touch capabilities such as Pinch.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi | `android.hardware.wifi` | This feature allows the application to
    use the Wi-Fi component of the device. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: Software features
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Feature Type | Feature Descriptor (Android name) | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| App Widgets | `android.software.app_widgets` | The feature allows the application
    to include app widgets and can be installed on devices having a home screen. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| Home Screen | `android.software.home_screen` | The feature allows the application
    to behave as a home screen replacement of the device. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| Input Method | `android.software.input_methods` | This feature allows the
    application to provide custom input methods. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| Live Wallpaper | `android.software.live_wallpaper` | This feature allows
    the application to provide live wallpapers. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: We haven't shown all the features and descriptors in the preceding tables. We
    have only presented some of the most commonly used features. The table shows the
    feature type of each feature, its feature name descriptor to be used in the `android:name`
    tag, and a short description of what the feature will do and how it will affect
    the application in the device.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Some features are categorized as hardware features and some as software features.
    Hardware features are the features that use hardware components on the backend.
    To access these hardware components, our application should have the permission
    to access the hardware. It should be noted that the `<uses-feature>` tag is just
    informative, and it only tells the user that the application is using some specific
    feature in the app. It doesn't allow access to the application for using any specific
    feature or component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特性被归类为硬件特性，一些则为软件特性。硬件特性是使用后端硬件组件的特性。为了访问这些硬件组件，我们的应用程序应具有访问硬件的权限。需要注意的是`<uses-feature>`标签只是提供信息，它只告诉用户应用程序正在使用某些特定功能。它并不允许应用程序使用任何特定功能或组件的访问权限。
- en: 'To allow the application to use any specific component, Android provides another
    tag, `<uses-permission>`. This tag provides access of a component to the application
    if the user allows it at the time of installation. The following code snippet
    shows the syntax for writing the `<uses-permission>` tag in the manifest file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序使用任何特定的组件，安卓提供了另一个标签`<uses-permission>`。如果用户在安装时允许，此标签将提供应用程序访问组件的权限。以下代码片段展示了在清单文件中编写`<uses-permission>`标签的语法：
- en: '![Software features](img/9639_06_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![软件特性](img/9639_06_04.jpg)'
- en: 'The `<uses-permission>` tag requests any specific permission that the application
    must be granted for it to operate properly. Permissions are only granted by the
    user at the time of the installation of the application. Unlike the `<uses-feature>`
    tag, the `<uses-permission>` tag only has a single `android:name` attribute. The
    only attribute of the tag specifies the name of the permission. The name of the
    permission can be defined using the `<permission>` tag (this is beyond the scope
    of the book, and we will not discuss it) or using standard permission names provided
    by the Android system. For example, to allow application to read phone contacts,
    we can write a code snippet like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`<uses-permission>`标签请求应用程序必须获得的任何特定权限，以便它能正常运作。权限仅在应用程序安装时由用户授予。与`<uses-feature>`标签不同，`<uses-permission>`标签只有一个`android:name`属性。该标签的唯一属性指定了权限的名称。权限名称可以使用`<permission>`标签定义（这超出了本书的范围，我们不会讨论），或者使用安卓系统提供的标准权限名称。例如，为了允许应用程序读取电话联系人，我们可以编写如下代码片段：'
- en: '![Software features](img/9639_06_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![软件特性](img/9639_06_05.jpg)'
- en: You can see how we provided a standard permission name from the `android.permission`
    package for reading the contacts of the phone.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们是如何从`android.permission`包提供了一个标准的权限名称，以便读取手机的联系人。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The features declared through the `<uses-feature>` tag are used by Google Play
    to filter the application, and the permissions declared through the `<uses-permission>`
    tag are presented to the user at the time of installation for granting access.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`<uses-feature>`标签声明的特性被谷歌应用市场用来筛选应用程序，而通过`<uses-permission>`标签声明的权限将在安装时向用户展示，以获取访问权限。'
- en: 'Some of the `<uses-feature>` tag name descriptors were added in the API after
    the `<uses-permission>` tag descriptors. Due to this, some applications using
    the `<uses-permission>` tag were able to use specific hardware without the need
    of declaring the `<uses-feature>` tag in the manifest file. To prevent the applications
    from any unexpected issues regarding this mismatch, some permissions are implied
    with some features. Google Play assumes that certain hardware-related permissions
    indicate that the underlying hardware features are required by default. The `<uses-feature>`
    tag allows Google Play to filter the applications in the market and show only
    those applications that the device is capable of running to the user. However,
    the `<uses-permission>` tag performs its duty when a user downloads the application
    and installs it. Before installation, the user is asked to grant access of all
    the permissions specified in the application. The application will only be installed
    when the user grants access. So, for those features that have both the `<uses-feature>`
    and `<uses-permission>` tag name descriptors, it is a good practice to declare
    both in the manifest of the application for it to work properly. The following
    table shows some of the features that are implied by the permissions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | <uses-permission> descriptor | <uses-feature> descriptor |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| Bluetooth | `android.permission.BLUETOOTH` | `android.hardware.bluetooth`
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| Camera | `android.permission.CAMERA` | `android.hardware.camera` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| Location | `android.permission.ACCESS_COARSE_LOCATION` | `android.hardware.location``android.hardware.location.network`
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.ACCESS_FINE_LOCATION` | `android.hardware.location.gps``android.hardware.location`
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| Microphone | `android.permission.RECORD_AUDIO` | `android.hardware.microphone`
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| Telephony | `android.permission.CALL_PHONE` | `android.hardware.telephony`
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.PROCESS_OUTGOING_CALLS` | `android.hardware.telephony`
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.READ_SMS` | `android.hardware.telephony` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.RECIEVE_SMS` | `android.hardware.telephony` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.SEND_SMS` | `android.hardware.telephony` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.WRITE_SMS` | `android.hardware.telephony` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi | `android.permission.ACCESS_WIFI_STATE` | `android.hardware.wifi`
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: You can see in the table that all the features that are implied by permissions
    are hardware features and require hardware components to run the application properly.
    So, it has already been made clear that developer should declare both the `<uses-feature>`
    and `<uses-permission>` tags to filter in Google Play and properly install it
    on the device without creating any hassle for the user and developer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Sharing using the SEND action
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any cell phone's primary purpose is to provide an easy way of communication.
    And like all cell phones, Android smartphones provide an easier way of communication.
    In this era of the Internet and social networking, Android phones have proved
    to be quite productive in sharing and social networks. Android provides features
    such as sharing pictures, status, sending e-mails, social networking such as Facebook,
    Twitter, and so on. Fortunately for developers, all these sharing features can
    be used very easily using a few lines of intents. Intent has proved to be a very
    good way of performing asynchronous communication within Android's components
    and apps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 任何手机的主要目的都是提供一种简单的通信方式。像所有手机一样，Android智能手机提供了一种更简单的通信方式。在这个互联网和社交网络的时代，Android手机在共享和社交网络方面被证明是非常高效的。Android提供了诸如共享图片、状态、发送电子邮件、社交网络（如Facebook、Twitter等）的功能。幸运的是，对于开发者来说，所有这些共享功能都可以通过几行意图代码非常容易地实现。意图被证明是在Android组件和应用程序内部执行异步通信的一个非常好的方式。
- en: In [Chapter 3](ch03.html "Chapter 3. Intent and Its Categorization"), *Intents
    and Its Categorization*, we discussed an example of sharing status using intents.
    We will explain the same `SEND` intent in more detail in this chapter, and see
    how we can share images and text via any medium on the user's choice. When it
    comes to sharing anything on Android phones, the intents with the `SEND` action
    are used a lot. In this section, we will discuss intents with the `SEND` action
    to see what is possible with it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 意图及其分类")中，我们讨论了使用意图共享状态的示例。在本章中，我们将更详细地解释同样的`SEND`意图，并查看如何通过用户选择的任何媒介共享图像和文本。当涉及到在Android手机上共享任何东西时，带有`SEND`动作的意图被广泛使用。在本节中，我们将讨论带有`SEND`动作的意图，以了解它能够实现的功能。
- en: 'To define the intent with the `SEND` action, the following code snippet shows
    the declaration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`SEND`动作定义意图，以下代码段展示了其声明：
- en: '![Sharing using the SEND action](img/9639_06_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_06.jpg)'
- en: 'You can see that we have passed a string constant of `Intent.ACTION_SEND` in
    the constructor of the intent. This string constant tells the Android system that
    the intent is meant to send anything on a device. We can execute the following
    intent by calling the `startActivity()` method as shown in the following code
    snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在意图的构造函数中传递了`Intent.ACTION_SEND`的字符串常量。这个字符串常量告诉Android系统，意图是用来在设备上发送任何东西的。我们可以通过调用以下代码段中显示的`startActivity()`方法来执行以下意图：
- en: '![Sharing using the SEND action](img/9639_06_07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_07.jpg)'
- en: 'Passing the `SEND` intent in the `startActivity()` method will allow the user
    to choose his favorite way of sending by providing a dialog of all the possible
    sharing applications. But if we pass the `SEND` intent in the `startActivity()`
    method without setting the intent type, it will throw a runtime exception. The
    following log shows some lines of the exception thrown at runtime:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startActivity()`方法中传递`SEND`意图将允许用户通过提供所有可能的共享应用程序的对话框，选择他喜欢的发送方式。但是，如果我们没有设置意图类型就在`startActivity()`方法中传递`SEND`意图，它将抛出一个运行时异常。以下日志显示了运行时抛出的一些异常行：
- en: '![Sharing using the SEND action](img/9639_06_08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_08.jpg)'
- en: 'In the log, you can see `"Unable to start activity"` and then `android.content.ActivityNotFoundException`
    is thrown. This exception is thrown when a call to the `startActivity(intent)`
    method or one of its variants fails because an activity cannot be found to execute
    the given intent. Not only the type of exception, but also the log shows the reason
    behind the failure of the activity. It says `"No activity is found to handle the
    intent"`. You might be wondering why Android couldn''t find the suitable activity
    to receive the intent. Recall implicit intents from earlier chapters, Android
    looks for all the possible activities matching the intent type and shows all those
    apps in a dialog. In our case, we haven''t defined any type for the intent except
    its `Intent.ACTION_SEND` action; that''s why we are getting a runtime exception
    of `ActivityNotFoundException`. Let''s set the type of action and see the dialog
    that shows all the possible apps to receive the intent:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: You can see that we have called the `setType()` method and passed a string of
    the `text/html` type. This method sets an explicit MIME data type of the intent.
    This is used to create intents that only specify type and not the data. These
    are the commonly used implicit intents in Android systems. This method clears
    any data of the intent that was set previously.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MIME type matching in the Android framework is case sensitive. So, you should
    always write your MIME type with lowercase letters. You can also use `normalizeMimeType(String)`
    method to ensure that it is converted to lowercase.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We have passed `text/html` as the MIME type in method argument. This type tells
    the Android system that all those applications that support the HTML type of data
    and process it can receive this intent. So, in a result, Android pushes all those
    applications in a dialog to let the user choose his/her favorite application.
    The following image shows the dialog for the `text/html` type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: You can see that all the apps supporting HTML type content are shown in the
    image, such as **Email**, **Imo Messenger**, and **Skype**. You can see how easy
    it is to share content using the `SEND` intent in Android phones, and the job
    of choosing apps and launching them is left to Android.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that there is no SMS/MMS-sending application shown in the
    dialog because SMS/MMS are just plain text applications and they support only
    that type of content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'On choosing any option from the list, the app will start. As we haven''t set
    any content to be shared, the application will be mostly empty. To set the content
    in the intent, we have to use extras. We will put extras for some information
    such as title, subject, or text. The following code snippet shows how to put some
    extras in the `SEND` intent:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'You can see in the code that after setting the MIME type of intent, we have
    called the `putExtra()` method few times. This method adds extended data to the
    intent. There are two parameters of the function: `name` and `value`. The `name`
    parameter must include a package prefix; for example, the app `com.android.contacts`
    would use names like `com.android.contacts.ShowAll`. We have passed three strings
    for subject, title, and text content of the intent. The names such as `Intent.EXTRA_SUBJECT`,
    `Intent.EXTRA_TITLE`, and `Intent.EXTRA_TEXT` for these types of data are already
    declared in the `Intent` class, and we can access those in a static manner. You
    might be thinking why we have passed the subject if we have passed the title string
    as well. Well, the `SEND` intent is an implicit intent, and Android shows all
    the apps supporting the intent. The user can choose any app as different apps
    are interested in different data. For example, any e-mail application will be
    interested in the Subject, To, and Body strings. And any SMS application will
    only be interested in the To and Body strings. So, for efficient usage of the
    `SEND` intent, you should add all the possible content to share it with every
    application effectively. Let''s take an example of sending an e-mail using the
    `SEND` intent. The following code snippet shows how we can use the `SEND` intent
    to send an e-mail:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中看到，在设置意图的MIME类型之后，我们多次调用了`putExtra()`方法。这个方法向意图中添加扩展数据。该函数有两个参数：`name`和`value`。`name`参数必须包含一个包前缀；例如，应用`com.android.contacts`会使用像`com.android.contacts.ShowAll`这样的名称。我们为意图的主题、标题和文本内容传递了三个字符串。这类数据的名称，如`Intent.EXTRA_SUBJECT`、`Intent.EXTRA_TITLE`和`Intent.EXTRA_TEXT`在`Intent`类中已经声明，我们可以以静态方式访问它们。你可能会想，既然我们已经传递了标题字符串，为什么还要传递主题呢？嗯，`SEND`意图是一个隐式意图，Android显示了所有支持该意图的应用。用户可以选择任何应用，因为不同的应用对不同的数据感兴趣。例如，任何电子邮件应用都会对主题、收件人和正文字符串感兴趣。而任何短信应用只会对收件人和正文字符串感兴趣。因此，为了有效地使用`SEND`意图，你应该添加所有可能的内容，以便有效地与每个应用共享。以下是一个使用`SEND`意图发送电子邮件的示例。以下代码段展示了我们如何使用`SEND`意图来发送电子邮件：
- en: '![Sharing using the SEND action](img/9639_06_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_12.jpg)'
- en: 'Firstly, we have declared our `SEND` intent by passing the `Intent.ACTION_SEND`
    parameter of constructor. Then, we have set the type of intent by the `calling
    setType()` method to the `"text/html"` MIME type. We then add the extra content
    for the e-mail app as shown in the following list:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过传递`Intent.ACTION_SEND`参数给构造函数来声明我们的`SEND`意图。然后，我们通过调用`setType()`方法将意图的类型设置为`"text/html"`
    MIME类型。接下来，我们为电子邮件应用添加额外的内容，如下列表所示：
- en: '`Intent.EXTRA_SUBJECT`: This name constant is used to add the Subject.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_SUBJECT`：此名称常量用于添加主题。'
- en: '`Intent.EXTRA_EMAIL`: This name constant is used to fill an e-mail address
    in the To field.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_EMAIL`：此名称常量用于填充收件人字段中的电子邮件地址。'
- en: '`Intent.EXTRA_CC`: This name constant is used to fill the e-mail address in
    the Cc field.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_CC`：此名称常量用于填充Cc字段的电子邮件地址。'
- en: '`Intent.EXTRA_BCC`: This name constant is used to fill the e-mail address in
    the Bcc field.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_BCC`：此常量用于填充Bcc字段的电子邮件地址。'
- en: 'Finally, before calling the `startActivity()` method, we put body of the e-mail
    by the `Intent.EXTRA_TEXT` name constant and pass our text in the value parameter
    of the `putExtra()` method. The `startActivity()` method will show the same dialog
    as shown in the previous image, and on choosing an e-mail application, it will
    show the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`startActivity()`方法之前，我们通过`Intent.EXTRA_TEXT`这个名称常量来设置电子邮件的正文，并在`putExtra()`方法的值参数中传递我们的文本。`startActivity()`方法将显示与之前图像相同的对话框，并在选择电子邮件应用后，显示以下截图：
- en: '![Sharing using the SEND action](img/9639_06_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_14.jpg)'
- en: An e-mail application already filled with content put in intent
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已经使用意图中的内容填充的电子邮件应用
- en: You can see from the image that all the data we put into extras is already filled
    in the e-mail application such as subject, e-mail, text etc. Now, all that the
    users have to do is to tap the **Send** button and the e-mail will be sent. In
    this example application, we have sent an e-mail to one address directly using
    the To field and indirectly by Cc and Bcc to two other addresses. Android allows
    us to add multiple e-mail addresses as well. The name constant `Intent.EXTRA_EMAIL`
    is used for this purpose. We have passed an address in the code; we can also pass
    arrays of strings consisting of e-mail addresses to send the e-mails to.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从图片中可以看出，我们放入extras的所有数据都已自动填充到电子邮件应用中，如主题、电子邮件、文本等。现在，用户只需轻触**发送**按钮，电子邮件就会被发送。在这个示例应用中，我们直接通过To字段向一个地址发送了电子邮件，并通过Cc和Bcc间接向另外两个地址发送。安卓允许我们添加多个电子邮件地址。为此，使用了名称常量`Intent.EXTRA_EMAIL`。我们在代码中传递了一个地址；我们还可以传递包含电子邮件地址的字符串数组，以发送电子邮件。
- en: From this section, we have mostly learned about how the `ACTION_SEND` intent
    is used and how much work we can do with just a few lines of code using this intent.
    If we choose Facebook, Twitter, or any other application from the dialog, we will
    see the same result of sharing data via that app. This is the power of using implicit
    intents to make it general in almost every possible way without doing any hard
    development work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节内容中，我们主要了解到`ACTION_SEND`意图是如何被使用的，以及仅用几行代码就能通过此意图完成多少工作。如果我们从对话框中选择Facebook、Twitter或任何其他应用，我们会看到通过该应用分享数据的相同结果。这就是使用隐式意图的强大之处，几乎在每种可能的情况下都能使其通用，而无需进行任何复杂开发工作。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`ACTION_SEND` is an action of the intent. Like this action, there are other
    actions such as `ACTION_VIEW`, `ACTION_SEARCH` that can be used by passing in
    intents for other purposes in Android.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACTION_SEND`是意图的一个动作。像这个动作一样，还有其他动作，如`ACTION_VIEW`、`ACTION_SEARCH`，可以通过传递意图用于安卓中的其他目的。'
- en: Telephony and making calls using intents
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图进行电话通讯和拨打电话
- en: Not only Android phones, but any phone's primary purpose from the day of invention
    is to provide a way to communicate long-distance conversations. And like all other
    phones, Android phones also provide features for making and receiving calls, checking
    call logs such as missed calls and dialed numbers, storing contacts, editing/modifying/deleting
    contacts, and a lot more. As Android phones lie in the frame of smart phones,
    there is a lot to the call feature. Users can make video calls, record calls,
    conference calls, mobile to computer calls and vice versa, and much more. All
    these features provide a very effective product to users and let the developers
    use these features for more flexibility and productivity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅安卓手机，从发明之日起，所有电话的主要目的都是提供一种远距离交流的方式。与其他所有电话一样，安卓手机也提供了拨打电话和接收电话、检查通话记录（如未接电话和已拨号码）、存储联系人、编辑/修改/删除联系人等功能。由于安卓手机属于智能手机范畴，其通话功能更为丰富。用户可以进行视频通话、录音通话、电话会议、手机与电脑之间的通话等。所有这些功能为用户提供了非常有效的产品，并让开发者能够利用这些功能实现更大的灵活性和生产力。
- en: Android provides many APIs for telephony features for developers. These telephony
    APIs let your applications and developers access the underlying telephony hardware,
    thus making it possible to create custom dialers, integrate call handling or phone
    state monitoring, and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓为开发者提供了许多电话功能的API。这些电话API让你的应用程序和开发者能够访问底层的电话硬件，从而可以创建自定义拨号器，集成呼叫处理或电话状态监控等功能。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Developers cannot customize the in-call screen of the phone due to security
    reasons. The in-call screen is shown when users make any calls or receive any
    incoming calls.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，开发者无法自定义手机的通话界面。当用户拨打电话或接听来电时，会显示通话界面。
- en: As this book is focused on intents, we will only discuss those telephony features
    that can be utilized using intents. From many features like making calls, receiving
    calls, checking the call log, accepting/rejecting calls, and so on, there are
    very few that can be utilized directly and only using intents. Fortunately, making
    calls is one of them. Let's discuss how we can make calls using intents in the
    next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书专注于意图，我们只讨论那些可以使用意图利用的电话功能。在许多功能中，如拨打电话、接收电话、检查通话记录、接听/拒绝电话等，只有少数可以直接且仅通过意图利用。幸运的是，拨打电话就是其中之一。让我们在下一节讨论如何使用意图拨打电话。
- en: Making phone calls using intents
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图拨打电话
- en: There are two methods of making phone calls in Android. Developers can either
    use the APIs provided by Android to make phone calls, or they can only initiate
    phone calls by sending the intent with the necessary information such as the phone
    number. We will explore the method of initiating phone calls later in this section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding section, we saw how we can use actions in intents to tell
    the Android system about our intentions. We will be doing the same to make phone
    calls by telling Android about our intentions and the rest of the work is left
    to the system. The following code snippet allows the application to launch the
    dialer with the specified number already dialed, and the user can explicitly make
    a call by pressing the call button in it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'You can see that we have done very few changes in the code. We have declared
    a `phoneNumber` string that stores the number we want to dial. You might be wondering
    why we have concatenated a `tel:` prefix in the string. Well, that prefix is used
    in getting the **Universal Resource Identifier** (**URI**), of the number. We
    get this URI by calling the static method `Uri.parse()` of the `Uri` class. This
    method returns the URI, which we pass in turn in the constructor''s other parameter.
    We provide the `DIAL` action by passing `Intent.ACTION_DIAL` in the declaration
    of the intent, and finally, we call the `startActivity(intent)` method as always
    to execute the intent and tell the Android system to process our intentions. The
    following screenshot shows a dialer result of the previously mentioned code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_15.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: A dialler screen with a dialled number initiated by starting the DIAL intent
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: When we run the previous code, the application will start the default dialer
    of the Android phone and will dial the number provided in code in it. It will
    not call the number; it will just dial the number because we used `Intent.ACTION_DIAL`.
    The user can explicitly press the call button of the dialer and make a call.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user doesn''t want to dial the number, it is also possible to directly
    call the number without going to the dialer first. Android provides the `Intent.ACTION_CALL`
    action for this purpose. The following code snippet shows how to make calls directly:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_16.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'You can see from the code that everything is the same except the action passed
    in the constructor of the intent. In the last example, we passed `Intent.ACTION_DIAL`
    and in this example we have passed `Intent.ACTION_CALL` to directly make the call.
    When we run this code snippet, the application will start making a call on an
    Android phone. The following screenshot shows the call:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_17.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: An in-call screen shown by starting the `CALL` intent
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'This action of `ACTION_CALL` to directly make a phone call requires the user
    to grant permission to the application. The following code snippet shows the permission
    to be placed in the `AndroidManifest` file to enable the app to work perfectly:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_18.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'It should be noted that `ACTION_CALL` cannot make calls to emergency numbers
    using intents; however, using `ACTION_DIAL` it is possible to dial emergency numbers.
    If the user has multiple dialers installed on the phone, the `ACTION_DIAL` action
    will present the list of dialers from which the users can choose a favorite dialer.
    The following screenshot shows the scenario of multiple dialers:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_20.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Multiple dialers to choose from the dialog
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: There is very little difference between the `ACTION_DIAL` and `ACTION_CALL`
    intents. The `ACTION_DIAL` intent only dials the number, and the user can explicitly
    call by pressing the call button, but `ACTION_CALL` directly makes the call without
    showing the dialer to the user.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be restrictions on applications on making phone calls directly. So,
    it is a good practice to use `ACTION_DIAL` in the apps unless `ACTION_CALL` is
    required.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: This is how we use intents to easily make phone calls and use the telephony
    features of Android. In the next section, we will see how we can send SMS, MMS,
    and data messages using intents. Along with sending, we can also confirm the message
    delivery as well as receive messages. Let's now discuss these in detail in the
    next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: SMS/MMS using intents
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the features of making calls, mobile phones support messaging
    services such as Short Messaging Services (SMS), Multimedia Messaging Services
    (MMS), and lately the data messages. The SMS/MMS features are most widely used
    in phones, and many people prefer it over making calls. Android provides APIs
    and framework that let developers send and receive messages from within their
    applications. Developers can even replace the native SMS application to send and
    receive text messages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, there is no API or library for sending MMS
    messages from within your applications, but you can send them using the `ACTION_SEND`
    or `ACTION_SENDTO` intents.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This section will walk you through the various actions such as sending SMS,
    sending MMS, sending data messages, confirming message delivery, and receiving
    SMS using intents. We will then brief you about how all these actions are performed
    without using intents and how APIs of Android can be beneficial to us. Let's look
    at our first task of sending SMS messages using intents in the next subsection.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Sending SMS using intents
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best thing about using intents is that it passes the responsibility of our
    requirements to the Android system rather than we creating the full functionality
    from the core. If we use intents in our current case, which is to send an SMS
    to someone, we just have to provide the number to send the message to and the
    message to be sent. The rest is done by Android itself.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already had plenty of discussions over the same topic of sending something
    or sharing something using intents, and fortunately, there is nothing different
    that we have to absorb here. It''s the same old method of creating an `ACTION_SEND`
    intent and executing it by calling the `startActivity(intent)` method. The following
    code snippet shows the `ACTION_SEND` intent example that we used previously:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_19.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we use this code, it is not useful to us because it doesn''t perform
    our action of sending an SMS. Neither does it show the SMS-supporting applications
    in the chooser dialog, nor does it send any SMS with the data passed in the `EXTRA_TEXT`
    extra. To make use of `ACTION_SEND` for the purpose of sending an SMS, we have
    to take care of some extra things. There are two ways of sending an SMS using
    intents: by the `ACTION_SEND` intent and by the `ACTION_SENDTO` intent. Let''s
    see how we can send an SMS using the `ACTION_SEND` intent.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create intent with the `ACTION_SEND` action and then put an extra
    `"sms_body"` with the message embedded in it. Android will ask the user for the
    phone number of the recipient itself. But it still won''t show any SMS support
    applications in the chooser-list dialog because we are still missing the type
    of intent. As SMSes are short text messages, we should set the intent type to
    `"text/html"`, but most SMS applications look for `"image/jpg"` or `"image/png"`
    as the intent type due to no native support for MMS messages. So, after setting
    the intent type to `"image/png"`, we will have the following code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_21.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'When we execute this code, we will see the chooser dialog of various apps including
    SMS support applications, e-mail applications, and so on. When we select any SMS
    application, we will see something similar to following image:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_22.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Default SMS application shown after sending the SMS intent
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: You may have already noticed that the text part of the SMS application is already
    filled in with the content we added in the `"sms_body"` extra, and the user is
    typing the number of recipients of the message.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous image shows a default SMS application of the QMobile Noir A10 smartphone.
    Your device will show the SMS application that you have set as default on your
    phone, and it won't be the same as this application for sure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can send an SMS using intents. Now, let''s take our other case
    in which we want to set the number of recipients using coding. For that purpose,
    we have to use the `ACTION_SENDTO` intent instead of the `ACTION_SEND` intent.
    The following code snippet shows the use of the `ACTION_SENDTO` intent:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_23.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, you can see that we have made a few changes in the code
    that we discussed previously before sending the SMS messages. We have set the
    action to `ACTION_SENDTO` instead of `ACTION_SEND`. Also, we have passed another
    argument of the phone number URI in the constructor of the intent. We have created
    a string for the phone number and concatenated the `"sms:"` tag before the number.
    This tag lets the `Uri` class understand that the string is representing the phone
    number to send the message to and parse it accordingly. You may remember from
    the previous section, we used the `"tel"` tag for making calls to any number using
    intents. When you execute the code, it will ask the application to choose SMS.
    On selecting any SMS supported application, it will send the SMS directly to the
    phone number provided instead of asking the phone number as in the previous example.
    You may have noticed that we haven't set the type of intent in this code snippet.
    It is because when we are using the `ACTION_SENDTO` intent, we don't have to explicitly
    set the type of intent. Android will understand what the developer is trying to
    do from the tags such as `"sms"` or `"tel"` and from actions such as `ACTION_SENDTO`
    or `ACTION_CALL`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use `ACTION_SEND` and set the recipient number explicitly using
    code, Android provides the `"address"` extra to put the string of the number in
    it without having to use any tags such as `"tel"` or `"sms"`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have talked about using `ACTION_SEND` and `ACTION_SENDTO` to send
    SMS text messages. In the next section, we will see how we can send multimedia
    messages with pictures embedded in them using intents.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Sending MMS using intents
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only thing that differs in a text message and multimedia message is the
    rich media embedded in it. MMS messages contain rich media content such as photos,
    videos, and cards, and some text as message for the content. Currently, there
    is no library provided by Android that lets developers send MMS natively, unlike
    SMS. But fortunately, intents make a clear way out for us in order to send an
    MMS. As the real difference defines, we have to add some media in the text message
    intent with its type set to multimedia, such as `"image/png"`, and we have then
    finished sending MMS messages. The following code snippet shows how to send any
    MMS message using intents used for SMS messages:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending MMS using intents](img/9639_06_24.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: You can see that there are two parts of the code. In the first part, we are
    getting the URI of our required image stored in external storage in the `images`
    folder. In the second part, we are creating intent with `ACTION_SEND`. Then, we
    add our text by using an`"sms_body"` extra and set the type to `"image/png"` to
    make it meaningful for a multimedia message. After that, we attach our media using
    the `Intent.EXTRA_STREAM` extra and pass our image URI as value in it. Finally,
    we execute the intent by calling the `startActivity(intent)` method. The only
    difference was to attach the media URI using the `EXTRA_STREAM` extra, and the
    rest was the same as in the SMS messages. You should also note that we can use
    `ACTION_SENDTO` to specify the recipient number, or we can also add the `"address"`
    extra with the value of the phone number.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have set the type of `"image/png"` in the previous example. This can only
    send PNG images. For other image formats, we can specify `"images/*"`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have only discussed sending SMS and MMS messages. But are we sure
    that those messages have been delivered successfully? Well, the next section is
    about confirming message delivery and understanding the role of intents in it.
    Let's see how we can confirm the message delivery using intents in the following
    section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Confirming message delivery using intents
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use intents to send messages, whether they are SMS or MMS, we just
    can''t track those messages for actions, such as, confirming delivery. The reason
    behind this is the implicit use of intents and relying on the default action of
    the Android system. If we use intents to send messages, it means that we are passing
    our responsibility of sending messages to the Android system. Now, if we want
    to confirm the delivery status of the message, it means that we are asking Android
    about our message. Unfortunately, we lack two things to make it possible: one
    is to tell the Android system about our confirmation of some message and the other
    is that the Android system may not remember what message we are talking about.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In order to make it possible to confirm the delivery, we have to use the native
    API for sending messages manually. It is the job of this API to keep track of
    both the delivery status and the message we are talking about. Also, using this
    API, we can easily send our query, asking the Android system about the delivery
    confirmation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we are using native APIs for sending messages, we have to think about
    MMS messages. As mentioned earlier, there is still no native support for MMS messages;
    so, we won't be able to track and confirm the delivery of MMS messages, but yes,
    we can confirm the delivery status of SMS messages. In this section, we will talk
    about how we can check the SMS delivery status using the native SMS API and how
    intents are used to achieve our goal.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Intents are an asynchronous way of communication in Android, and they are used
    everywhere. The only change is that they are used to achieve our goals and finish
    the requirements. In a short explanation about confirming the message delivery
    status, we will use the native SMS API called `SmsManager` to send the text message
    using the `SmsManager.sendTextMessage()` method. But to keep track of the message,
    we will use two intents: one for the sent action and one for the delivery action.
    Along with these two intents, we will also create two pending intents: one for
    the sent action and one for the delivery action. Finally, to put all four intents
    in action, we will create two broadcast receivers: one to check the sent action
    and the other to check the delivery action. It may seem quite complex here, but
    it is as easy as a charm. Let''s have a look at the code snippet that declares
    our four intents: two intents and two pending intents:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_25.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: You can see that we have declared our intents in the usual way in the code.
    The only difference here is that we have used our own custom actions represented
    in strings such as `"sent_sms_action"` or `"delivered_sms_action"`. Then, we have
    created two pending intents using the `getBroadcast()` factory method of the `PendingIntent`
    class. The `getBroadcast()` method will retrieve `PendingIntent` that will perform
    any broadcast, such as calling the `Context.sendBroadcast()` method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after creating all four intents, we will now have to create and register
    the broadcast receivers that will put the pending intents in action. The following
    code snippet shows both receivers being implemented:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_26.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous code, we have registered two broadcast receivers using
    the `Activity.registerReceiver()` method and passed anonymous objects. The overridden
    method `onReceive()` serves our purpose. One `onReceive()` method is called when
    any message is sent, and the other `onReceive()` method is called when any message
    is delivered. We have put comments to show you where you can use your custom functionality
    in the code. You might be wondering how Android will know that these are the broadcast
    receivers for sent and delivery status. Android will know about it by checking
    the intent filters. You can see that we have passed our custom actions passed
    in intents in the constructors of intent filters, and these filters will filter
    the broadcasts, and the receiver will only receive those broadcasts for which
    it was registered. We have done our core work for confirming the message delivery
    until now. All that''s left now is to put it in action, and here, the `SmsManager`
    API comes handy. We will create an instance of `SmsManager` and call its `sendTextMessage()`
    method to send the message and put all the intents in it, and then we are done.
    The following code snippet shows the `SmsManager` usage code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_27.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Remember, the `SmsManager` API uses the `android.permission.SEND_SMS` permission;
    so, don''t forget to add it in your manifest file, as shown in the following code
    snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_28.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: So, this is how we can confirm the message delivery. We can only confirm the
    delivery status of text messages, and we have to ask the user to grant a `SEND_SMS`
    permission for the purpose. But, if we are using intents, we can only send messages
    and we won't be requiring any permission from the users.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android emulator supports sending and receiving SMS messages. This can be accomplished
    by creating multiple instances of emulators and sending text messages to port
    the number of emulators.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the role of intents in confirming the message delivery, intents
    are not performing the core action of confirming message delivery here. They are
    just providing a way of communication by carrying the necessary information such
    as which message's delivery is to be checked and so on. Then, these intents are
    used by broadcast receivers that constantly check for the delivery and sent status.
    Once it is done, they pass the status in our intents and then those intents provide
    us with an update of whether the message has been sent or delivered or not.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be doing almost the same kind of stuff and coding,
    but this time, we will do it to receive messages. After using all these code snippets,
    we can develop our SMS application that can send and receive messages. Let's see
    how we can receive messages and the role of intents behind it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Receiving SMS messages using intents
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have talked about sending SMS/MMS messages and the importance
    of intents in these applications. In this section, we will talk about how we can
    listen for incoming messages so that we can use them in our applications. Using
    this feature, we can develop messaging applications. Intents can send messages
    using the `ACTION_SEND` or `ACTION_SENDTO` intents directly, but these don't play
    a direct role in listening for incoming messages and receiving messages. Intents
    are used in the same way as `Broadcast Receiver`, and are used to get the data
    such as sender number, message, message time, and so on. Before we discuss how
    to listen for incoming messages, we have to learn about some classes that are
    used in the following application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The SmsManager class
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already used the `SmsManager` class in the previous subsections for
    confirming message delivery. This class is used to manage SMS operations such
    as sending data, SMS, and PDU messages. We can't instantiate this object using
    a constructor; we can get its instance by calling the static method of `SmsManager.getDefault()`.
    We can use this class to send messages.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two different classes with the name `SmsManager`: `android.telephony.SmsManager`
    and `android.telephony.gsm.SmsManager`. The later class in the GSM package is
    deprecated in API Level 4 and later versions.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The SmsMessage object
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class represents a simple SMS message object. On receiving the incoming
    messages, we will get an array of `SmsMessage` objects. This class is used to
    get information such as the message body, message time, and sender number.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Data Unit (PDU)
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PDU is the industry format for an SMS message. Developers shouldn't worry
    about reading a PDU in detail or understanding the format, because the `SmsManager`
    class of Android reads and writes PDUs and provides methods for the developer
    to use PDUs.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'These classes and concepts will be used in receiving the incoming messages''
    app. Now, let''s discuss how messages are received in Android. When any new SMS
    message is received by any device, a new broadcast intent is fired. The action
    of this intent is `android.provider.telephony.SMS_RECEIVED`. We have to create
    a custom broadcast receiver that will look for this broadcast intent. Whenever
    we get any message, the `onReceive()` method of the broadcast receiver will be
    called. The following code snippet shows the implementation of our custom broadcast
    receiver for incoming messages:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As always, we have extended our class from `BroadcastReceiver` and overridden
    the `onReceive()` method. This method is called when any incoming message is received
    by the device. We first check whether this intent contains any received messages
    or not. If the intent action is the same as our `SMS_RECEIVED` string literal,
    this means that we have received our message.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SMS received action `android.provider.Telephony.SMS_RECEIVED` is unsupported
    in Android and is subject to change in any future platform releases. The developer
    should be cautious when using these unsupported hidden methods and attributes
    of Android.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the action is verified after checking and comparing, we have to get the
    message data from the intent and perform our custom actions of the application.
    We first get the extras bundle from the intent by calling the `getExtras()` method
    and then we have passed that bundle in our method called `getMessageData()`. This
    is our custom method, and in this method, we will see how we can get the message
    data from the bundle. The following code implementation shows the method definition:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_30.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: We first checked that our bundle is not a null object. Then we extracted the
    PDUs from the bundle by calling the `get()` method and passing the `"pdus"` key.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't know which key to pass in the `get()` method, you can call the
    `Set<String> Bundle.keySet()` method to get all the keys used in the bundle.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Recalling PDUs, PDU is the industry format for an SMS message. Once we have
    all the PDU objects in an array, we create an SMS message from those PDUs using
    the `SmsMessage.createFromPdu()` method. After creating all the messages, we are
    traversing through the array and getting the message data such as the message
    body text, message sender number, and message time from it using the `SmsMessage.getMessageBody()`,
    `SmsMessage.getOriginatingAddress()`, and `SmsMessage.getTimestampMillis()` methods.
    Now, we can use these data strings in our applications. It must be noted that
    any large message is broken into many small messages, which is why we are getting
    an array of objects.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'This broadcast won''t work until we register it in our application. To register
    it in our application, we have to write the following code in our main activity:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_31.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'There is nothing new to discuss here. We are creating an intent filter with
    the `SMS_RECEIVED` action and an instance of our broadcast receiver. Then, we
    are passing both in the `registerReceiver()` method of our activity. The message
    receiver requires the `android.permission.RECEIVE_SMS` permission; so, don''t
    forget to add this line in your manifest file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_32.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: This is how we can receive the incoming messages in our application and use
    them in many different ways. You might be wondering about the role of intents
    in this application. As mentioned earlier, intents are not used in this application
    directly. When any message is received by the device, a broadcast intent is fired.
    We are using that intent to extract data and messages from it, and those messages
    are used in our application. Intents play the role of providing the data about
    messages, after receiving them, in Android devices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Android debug tools of the **Dalvik Debug Monitor Server** (**DDMS**)
    panel to simulate incoming messages on our Android emulators. The following screenshot
    shows the **Emulator Control** panel in the DDMS view for simulating messages:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_33.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Emulator Control panel in the DDMS view for simulating messages
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about sending SMS, MMS, confirming message delivery,
    and receiving incoming messages. We also discussed the importance and use of intents
    in all these applications. In the next section, we will learn about notifications
    and how intents are used in making interactive notifications.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Notification using intents
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From traditional phones to smart phones, every mobile phone uses some method
    to notify and alert the users about some event such as receiving messages or calls.
    Like these phones, an Android phone uses a notification system to alert the users.
    A notification is a message displayed out of the application''s normal UI. When
    any new notification is triggered, it is shown in the notification area. The users
    can see notifications from the notification drawer and notification area at any
    time by pulling the drawer downward using the down gesture. The following screenshot
    shows two different examples of notifications in Android:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Notification using intents](img/9639_06_34.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Notifications in Android phones
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Notifications are like channels that alert the users about important events
    as they occur when the user is busy in some other mobile activity such as playing
    a game.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: For any developer, a notification is a user interface (UI) element that the
    developer displays outside of the app's normal UI to indicate and notify the user
    that an event has occurred. Then, users can choose to view the notification while
    using other apps and respond to them when they wish. Using a notification is the
    preferred way for invisible application components, such as broadcast receivers
    and services, to alert the user about the occurrence of any event.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss notifications, their layouts, displaying additional
    information in notification layouts, and launching intents. We will learn the
    role of intents and create an example application with a custom notification layout
    and how intents are important in these types of applications. Before we start
    developing our example application, let's discuss some basic concepts used in
    notifications.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Notification forms
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notifications can take different forms like any persistent icon that goes into
    the status bar and can be accessed through the launcher. When this notification
    is selected by the user, any specified intent is triggered when some activity
    or service occurs. Notifications can also be used to turn on the flashing LEDs
    of the device. Also, devices can vibrate or play ringtones on receiving notifications.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The NotificationManager class
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NotificationManager` class represents a system service that is used to
    handle the notifications'' system in Android. We can''t instantiate this class,
    but we can get its instance object by calling the `getSystemService()` method
    and passing `Context.NOTIFICATION_SERVICE`. The following code snippet shows how
    to get an instance of the `NotificationManager` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![The NotificationManager class](img/9639_06_35.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: The Notification class
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Notification` class represents any notification in Android. It provides
    APIs that allow developers to set the icon, title, time of notifications, and
    so on. The following code snippet shows us how to create a notification in Android:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification class](img/9639_06_36.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: The Notification layout
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each notification has an icon and ticker text, which is sometimes called status
    text. An icon is displayed when a notification has been launched and the notification
    drawer is closed. The ticker text scrolls along the status bar when a notification
    is fired and then it is set to the notification message text when the notification
    drawer is opened. The following screenshot gives an overview of the different
    aspects of a notification area:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_37.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: Notification and notification area
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the preceding screenshot that when any notification is fired,
    its ticker text is scrolled through the status bar. After scrolling through the
    entire text, its icon is displayed on the status bar. When a user opens the notification
    drawer by pulling it down, the notification's big icon along with the notification
    title, content text, and timestamp is shown. This is how any notification is fired
    in Android.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will discuss how notifications are triggered and how intents are used
    in notification applications. We will create a notification, which is shown in
    the following screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_38.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: A simple notification
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before moving forward to create a notification, we need the layout for
    our notification. The following code implementation shows our layout for the notification:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_39.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'We have placed four views in `RelativeLayout`: an `ImageView` for the icon,
    a large `TextView` for the title, and two small `TextViews` for description and
    timestamp respectively. We have used the aligning of `RelativeLayouts` to place
    the views below, above, to the right of, and to the left of other views so that
    it can be displayed in the same way on every resolution of different smartphones.
    We have saved this file as `notification_layout.xml` in the layout folder of the
    resources directory. This was our layout for the notification. Now, let''s learn
    how to create any notification that will use this layout.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: To create a notification with custom layouts, we have two different methods
    in Android. The first method is to use the `setLatestEventInfo` method to update
    the details displayed in the standard extended status-notification display. This
    method is the easiest method and is used in more applications. The other method
    is to set the `contentView` and `contentIntent` properties of the notification
    to assign the custom UI layout for the extended display status using the `RemoteView`
    class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RemoteView` is a mechanism that allows developers to embed and control a layout
    embedded within any separate application. This is most commonly used in creating
    home screen widgets.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a difficult method in this section to create the notification
    as this method uses intents in its code. We will first create a `RemoteView` object
    and assign it to the `contentView` property of the notification object. The `contentView`
    View represents the notification in the expanded status bar. Notifications often
    represent a request for action, and this action is performed when a user clicks
    on the notification in the notification drawer area or expanded status bar. We
    can specify `PendingIntent` that will be fired when the user clicks on the notification
    item. Mostly, this intent opens our application and provides more information
    about our notifications. Along with setting `contentView`, we also need to set
    `contentIntent` to our created object of `PendingIntent` in which a custom content
    view is assigned to our notification. The `contentIntent` intent is the intent
    that must be executed when the expanded status entry is clicked on. If this is
    the intent of the activity, we must include `FLAG_ACTIVITY_NEW_TASK` that will
    start our activity in a new task.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you manually set the `contentView` property, you must also set the `contentIntent`
    property; otherwise, an exception will be thrown when a notification is triggered
    causing any runtime crash of your application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `contentView` property is set to our custom remote view, we can''t
    set our required views in a normal way. We have to use the set methods on the
    `RemoteView` object that modifies each of the views used in the layout defined.
    This is how any notification with a custom layout is developed. The following
    code shows the implementation of the notification with custom layout, and this
    can be added in any activity:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_40.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: 'You can see from the code that we have first created an object of `Notification`
    with the initial icon, ticker text, and time of triggering the notification. Then,
    we create intent objects, `Intent` and `PendingIntent`, for specifying the action
    of our notification when it is clicked on. Then, we set `contentIntent` and `contentView`
    of the notification object. We create a new `RemoteView` object for `contentView`
    and pass our `notification_layout.xml` reference in it. This is how the notification
    layout is set to our custom layout passed in a `RemoteView` constructor. Then,
    we set our pending intent to `contentIntent`. And finally, we update the values
    of our layout using the set methods such as `setImageViewResource()` and `setTextViewText()`.
    Until now, we have developed our notification with a custom layout. Now, we will
    see how to trigger the notification. The following code snippet shows how to trigger
    the notification:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_41.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: 'We are getting an instance of the `NotificationManager` class by calling the
    `getSystemService()` method. To trigger the notification, we are calling the `NotificationManager.notify()`
    method that receives two parameters: the first is the ID of the notification and
    the second is the notification object itself. The following screenshot shows an
    output of the application:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_42.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Notification fired from our application
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to create notifications and set custom layouts for
    their view. You might be thinking about the importance and use of intents in this
    application. In this application, intent was used only for one purpose and that
    is to navigate the user to our required application or activity when the user
    clicks on the notification. We created an `Intent` object, and from that, we created
    a `PendingIntent` object that was used in the notification as `contentIntent`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed Android features. We learned about common Android
    features such as layouts, display, connectivity, communication, accessibility,
    touch, and hardware support and their comparison with Android mobile components.
    We then saw how the two most important tags, `<uses-feature>` and `<uses-permission>`,
    are used in the `AndroidManifest` file and for what purpose.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the relation between hardware and software features and Android
    mobile components and their relationship with these manifest tags. Then, we saw
    the most common intent action `ACTION_SEND` that is used to send or share anything
    with other applications using the implicit intents' approach. Then, we expanded
    our knowledge of intents to more specific features of phones including making
    calls, sending SMS/MMS messages, confirming the delivery of messages, and receiving
    messages. We used intents as well as native Android APIs to perform these actions.
    We then discussed notifications and alerts, and learned how we can set custom
    layouts in notifications. We learned two different ways, and used one way in our
    example application. We learned how intents are used in these types of applications
    and also learned about their role with those classes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss intent filters and see how Android recognizes
    different intents and filters them according to the calls and applications.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
