- en: Chapter 6. Accessing Android Features Using Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed data transfer using components. We saw how
    to transfer data from one activity to the other, and why we should transfer data
    between different components. We also discussed the various methods of data transfer
    using intents. Android has a lot of components in the system, and intent provides
    an easy interface to make those components communicate with each other. In [Chapter
    4](ch04.html "Chapter 4. Intents for Mobile Components"), *Intents for Mobile
    Components*, we discussed the different Android components that use system hardware
    such as Wi-Fi, Bluetooth, camera, microphone, and so on. We also discussed how
    these components can be utilized using intents and how we can make many different
    applications using Android hardware with no more than few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have only discussed hardware components and the role of intents
    with those components. This chapter is all about Android software features and
    how we can use those features in our applications using intents as the primary
    interface. Android contains a vast collection of libraries and APIs, by which
    a developer can use different Android features very easily. This chapter will
    walk us through the common Android features, and we will also develop some example
    applications that will show us the use of intents with those features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Features of Android OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android features versus components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Android OS features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android features and intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<uses-feature>` and `<uses-permission>` tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing using the SEND action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending SMS/MMS using intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data messages using intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirming message delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telephony and making calls using intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications using intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other Android features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The concepts and structure of intents, as discussed in previous chapters, are
    the prerequisites for understanding this and the following chapters. If you don't
    have the basic concept of these things, we would recommend you to read [Chapter
    3](ch03.html "Chapter 3. Intent and Its Categorization"), *Intents and Its Categorization*
    and [Chapter 4](ch04.html "Chapter 4. Intents for Mobile Components"), *Intents
    for Mobile Components* in order to move forward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Features of Android OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is an open source operating system and middleware framework for smart
    devices such as phones and tablets. The devices contain lots of features and functionalities
    that provide users with a way for an easy lifestyle. These features include hardware
    features such as audio, Bluetooth, camera, network, microphone, GSM, NFC, and
    sensors such as accelerometer, barometer, compass, gyroscope, and Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does it include hardware components, it also includes software features
    such as app widgets, home screen, input methods, live wallpapers, layouts, storage,
    messaging, multi-language support, browsers, Java support, media support, multi-touch,
    calls, messaging, multitasking, accessibility, external storage, and so on. We
    have already referred to the hardware features as mobile components and discussed
    them in the previous chapters. We will discuss the software features in this chapter
    with practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are using two key terms here: components and features. Components such as
    camera, Bluetooth, and so on are the hardware parts of an android phone . The
    feature is the software part of an Android phone, such as an SMS feature, e-mail
    feature, and so on. This chapter is all about software features, their access,
    and their use through intents.'
  prefs: []
  type: TYPE_NORMAL
- en: Android features versus components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, the terms "Android features" and "components" are used interchangeably.
    But for the sake of clarification, we are referring to the keyword *components*
    as a feature that uses hardware and the keyword *features* as an Android feature
    that uses software in its backend. As we discussed in the previous section, Android
    contains lots of components and features that, when ported to any phone, makes
    it a smart phone. Not all the components and features can be used via intents.
    So, we will discuss only those features in detail that can be used by intents.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that features that use hardware directly or indirectly require
    users to provide permissions to access it. These permissions are provided during
    the application's installation. If the user doesn't provide permissions to the
    application, the application can't access hardware; thus, it can't use that feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about those features that use software as backend
    but also require some permissions. We will provide more details about the permissions
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Common Android features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we are only talking about Android features in a general way. In this
    section, we will discuss some of the most common Android features found in Android
    phones and tablets. Each Android device is unique in some way or the other and
    possesses many unique features and components different from other brands and
    phones. But there are some features that are found to be common in all the Android
    phones. Many of these features can be used in our apps irrespective of any specific
    model or phone, and intent is, without any doubt, the most asynchronous and easy
    way to use these features in our applications. Now let's see the Android features
    that are common among many devices and their functionality in a phone.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts and display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Today, smartphones are getting bigger in size, and there are new sets of Android
    devices called tablets that are available. Bigger screens and higher-resolution
    displays have transformed mobiles into multimedia devices. These devices contain
    layout sizes from 240 x 320 to 1268 x 800 pixels and screen sizes from 3 to 11
    inches. These are found in varying device screen densities such as low, medium,
    high, large, extra large, and so on. The following image shows three different
    devices with different resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts and display](img/9639_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android devices with different screen sizes
  prefs: []
  type: TYPE_NORMAL
- en: To display high graphics, Android provides graphic libraries for 2D canvas drawings
    and 3D graphics with OpenGL using OpenGL-ES. A new rendering graphics library
    called RenderScript was introduced after Android Version 3.0\. RenderScript is
    a scripting language for Android OS that allows developers to write high-performance
    graphic rendering and raw computational code. It has been primarily oriented for
    use with parallel data computations like dividing processing across multi-core
    processors such as CPUs, GPUs, or DSPs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Android Version 3.0, which was developed for Android tablets, Android
    rendered its layouts, home screen, and mobile UI using 2D canvas. After RenderScript
    in Android 3.0, Android renders its layouts, home screens, and mobile UI with
    more beautiful and optimized graphics using RenderScript.
  prefs: []
  type: TYPE_NORMAL
- en: Data storage and retrieval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no Android device that doesn't use any kind of storage for running.
    For better performance, the device not only needs a volatile memory like RAM for
    the sake of processing and faster access, but it is also going to need a permanent
    storage such as an external SD Card in it. Android devices support data storage
    and retrieval in multiple ways that vary according to the developers and applications
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: If our applications use large data, the developers can use lightweight relational
    database features for each of their applications using SQLite. Developers can
    use the SQLite database to manage data with secret and efficient storage capability.
  prefs: []
  type: TYPE_NORMAL
- en: Not only databases, Android devices also provide features for file storage.
    As saving and loading data is essential for almost every application, Android
    provides many different methods to store and retrieve data to make our application
    persistent. File storage is not a good option, but sometimes, developers don't
    have any option other than reading and writing files to handle their application's
    persistent data. And fortunately, Android provides features that let developers
    create, save, and load files on a device's internal or external media, such as
    an SD card. These microSD cards are formatted with the FAT32, Ext3, or Ext4 file
    systems. Not only these file systems, but also some Android devices, mostly tablets,
    support high-capacity storage media such as USB flash drives.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from storing large or heavy data in databases or disk files, Android provides
    a feature for storing simple application data such as UI state, game scroes, and
    so on. This is achieved using the `SharedPreferences` method. The `SharedPreferences`
    method uses the name/value pair (NVP) mechanism to store the application's lightweight
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Connectivity and communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can't call an Android device a smart phone until there is a connectivity
    feature in it. The technologies supported for connectivity, communication, and
    data transfer include GSM/Edge, IDEN, CDMA, EV-DO, Bluetooth, Wi-Fi, LTE, Near-Field
    Communication (NFC), WiMAX, and so on. Android provides a complete set of libraries
    for communication and connectivity. This allows developers to easily utilize and
    use these features in their applications. For example, through Bluetooth support,
    users can send files, access phone book and voice dialing, and exchange contacts
    between phones.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Android 3.1 and the later versions, Android contains the native feature of
    connecting keyboard, mouse, and joystick devices with Android phones via Bluetooth
    communication. Before Android 3.1, some third-party applications provided a customized
    way for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Android phones have communication support not only for data transfer but also
    for telephony and messaging. Android contains SMS and MMS for messaging along
    with threaded text messaging and **Android Cloud to Device Messaging** (**C2DM**),
    and the new **Google Cloud Messaging** (**GCM**) is also part of Android Push
    Messaging services.
  prefs: []
  type: TYPE_NORMAL
- en: For telephony, Android supports calls, but it doesn't have native support for
    video calling (at the time of writing this book); however, some Android devices
    have customized versions of operating systems that allow developers and users
    to make video calls either via UMTS networks (as in Samsung Galaxy S) or over
    IP. Also, Google Hangout, the replacement of Google Talk, is available in Android
    2.3.4 and higher versions. This allows users to make video calls using an Internet
    connection. To use Google Hangout video calling, users need a Google+ account.
    Skype, a third-party tool of Microsoft Corporation, is also used to make video
    calls in Android 2.3 and later versions.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility and multitouch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Android device runs on a fully touch-based interface and contains few hard-
    or soft-touch buttons that vary according to the device. Android devices have
    native support for multi-touch. Multi-touch technology allows developers and users
    to use single touch, tap, double tap, long touch, pinch-zoom gesture, rotate gestures,
    swipe gestures in all directions, and much more. Android's latest version (which
    is Android 4.4 KitKat at the time of writing this book) contains some new touch
    gestures such as tap and long touch gesture, scroll gesture, and so on. Also,
    Samsung introduced touchless gestures that make use of their specific APIs called
    Look API. Through Look API, users can use their phones without touching the screen
    and moving their hands or head in air, and Android will perform the desired functionality.
    For example, moving the head up will scroll the page up, and moving the head down
    will scroll the page down on their phones. Also, many Android device manufacturers,
    such as Samsung, introduced pen features to allow the users to write on their
    phones and use them with pens more easily and accurately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The multi-touch feature was first introduced in the HTC Hero Android phone.
    Before that, the feature was originally disabled at the Linux kernel level due
    to Apple's patents on touch-screen technology at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Along with touch, users can access their phones with a voice or speech recognition
    engine natively introduced in Android phones. Also, Android contains a feature
    called Talkback that allows people with no or low vision to hear what their Android
    phone is doing at a particular time. These people can access their phones using
    voice actions such as calling, texting, navigation, and so on. These voice actions
    were introduced from Android 2.2 onwards. The ability to control hardware is not
    yet (at time of writing this book) available through voice actions in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android 4.1 and the later versions provide enhancement over voice actions to
    read answers from Google Knowledge Graph when queried with specific commands only.
  prefs: []
  type: TYPE_NORMAL
- en: Extensive content and media support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Android device is not less than any computer with high-definition media support.
    Android offers comprehensive APIs for managing images, videos, and audio. The
    formats supported in Android devices include WebM, H.263, H.264, 3GP, MP4, MPEG-4,
    AMR, MP3, MIDI, OGG, WAV, JPEG, PNG, GIF, BMP, and WebP. Not only this, Android
    also provides features for streaming online media using RTP/RTSP protocols, HTML
    progressive downloads such as the HTML5 `<video>` tag, HTTP dynamic streaming
    protocol, and the Adobe Flash Streaming (RTMP) protocol provided by Flash plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New Android devices support 3D-image capturing. and 3D Video Support as their
    native features.
  prefs: []
  type: TYPE_NORMAL
- en: Along with extensive media support, Android also provides playback features,
    controls, players, hard buttons for sound control as with other mobile phones,
    fullscreen playback, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Android not only has media support but also has content support such as text
    files, word documents, HTML, and so on. The web browsers available in Android
    are based on the open source WebKit layout engine that was first developed by
    Apple Inc. This is coupled with Chrome's V8 JavaScript engine in Android.
  prefs: []
  type: TYPE_NORMAL
- en: While most Android applications are written in Java natively, Android doesn't
    support Java byte code due to the unavailability of the Java Virtual Machine in
    Android. This Java code is instead compiled in the Dalvik executable and run on
    the Dalvik Virtual Machine, a specialized virtual machine for Android systems.
    The most important thing in Dalvik, which separates it from the Java Virtual Machine,
    is that it is optimized for a low-battery life with limited memory and CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android browser has got a 100/100 score on Acid3 test in Android 4.0 Version.
    The Acid3 test is a web test page from Web Standards Project that checks a web
    browser's compliance with elements of various web standards such as Document Object
    Model (DOM), JavaScript, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Android device not only provides features of telephony, such as making phone
    calls, sending messages, and so on, but it also has lots of features with new
    hardware components that are used for many different purposes. Android has features
    of video cameras, touchscreens, Global Positioning System (GPS) for location-based
    applications, accelerometers, gyroscopes, barometers, magnetometers, proximity
    sensors, pressure sensors, thermometers, Wi-Fi, Bluetooth, and dedicated gaming
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some new Android phones, such as Samsung Galaxy S4, provide new sensors such
    as light and color sensors used to capture touchless gestures.
  prefs: []
  type: TYPE_NORMAL
- en: With GPS and location-based technology included in Android phones, Android systems
    have got native support for Google Maps, Google's GSM cell-based location technology
    used to determine a device's current position. To make maps more useful for developers
    and users, Android also provides native APIs for forward and reverse geocoding
    support that helps to translate coordinates into address and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: Background services and multitasking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to limited screen dimensions in Android smart phones, only one application
    becomes visible on the user interface screen. But Android supports applications
    and services running in the background with its multitasking feature. Using background
    services, developers can perform automatic processing that doesn't require any
    user interaction. Some example applications for this feature include generating
    alerts; monitoring messages, statistics, and weather reports; downloading data
    from the Internet; or playing audio files in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an Android device gets low on memory, it stops applications with low priority
    in the background. Developers should store the necessary data and state of application
    before going in the background so that on getting stopped, an application can
    restore its state from the saved one.
  prefs: []
  type: TYPE_NORMAL
- en: Android also supports the notification feature, a standard traditional approach
    to alert users in their phones. Using Android libraries for notifications, developers
    can make notification alerts that can be audible, vibration supported, or maybe
    LED active. In addition to this, Android also allows developers to set notification
    UI icons, layouts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These background applications can be standalone as well as dependent on other
    applications. Android provides features such as intents and content providers
    for inter-application communication methods and mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced home screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The home screen is like a desktop screen of a computer or laptop. Android users
    get quick links, app shortcuts, and information on their home screen. Android
    provides customizable features for the home screen. Widgets, live folders, and
    live wallpapers make the home screen more interactive and beautiful for users.
    These apps let Android developers create dynamic application components that provide
    a window into your applications or offer useful and timely information directly
    on the home screen. Developers can also provide users with an option to add shortcuts
    on their home screens. These shortcuts will provide users with the necessary information,
    and they won't need to open their apps. For example, we have an app that tells
    us the current time and weather of the day. Now, whenever users want to check
    the time and weather, they have to open the app. So, instead of creating an app
    for this purpose, creating a home screen widget would be much better idea. This
    widget will show the weather and time on the home screen, and users wouldn't have
    to open the app then.
  prefs: []
  type: TYPE_NORMAL
- en: Other Android features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android developers can develop applications in multiple languages, offering
    the local version of the application to the users. Android provides the feature
    of multilanguage applications.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Android supports tethering that allows users to share the network connection
    of a device with other mobile phones and computers. This sharing can be achieved
    via Wi-Fi hot spot or USB tethering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tethering was introduced in Android 2.2 Version; so, the earlier versions had
    tethering support through third-party applications and manufacturers.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the power and volume-down hard buttons at the same time allows users
    to capture a screenshot of the device. This feature was first introduced in Android
    4.0\. The earlier versions are using third-party applications, but these applications
    need a rooted device as a prerequisite. Developers can also take screenshots using
    the DDMS tool via a PC connection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rooting any Android device is not allowed, and it breaks all the warranty and
    guarantee deals and can sometimes be a risky procedure for mobiles.
  prefs: []
  type: TYPE_NORMAL
- en: Android features and intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have discussed the different features commonly found in Android
    phones and tablets, but we are still unaware of the connection between intents
    and these features. There are some features that can be used via intents and some
    cannot. Simply to remind you, intents are asynchronous messages between different
    applications and the Android system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss a few features that can be used through intents,
    and see how intents perform various actions. We have divided the features into
    four sections: messaging, telephony, notifications, and alarms. We will develop
    some examples that will use intents and access these features, and we will discuss
    how these features are accessed and the role of intents in them.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start discussing these example applications, we are going to discuss
    some basic terminology used in Android for the clarification of concepts between
    intents and features. In the next section, we will discuss two different tags,
    `uses-feature` and `uses-permission`, from the `AndroidManifest` file. These tags
    are used to declare some permissions and settings for any Android application.
    Let's see what they are for in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The <uses-feature> and <uses-permission> tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any Android application, by default, doesn't have the permission to perform
    any operations that impact any other application, system, or the user directly
    or indirectly. This includes reading or writing the user's private data such as
    contacts and messages, reading or writing other applications' files, or any other
    activity. The Android system allows applications to be standalone and sandboxed,
    but in case of sharing data, the applications must explicitly share it with each
    other. To achieve this objective of sharing more easily, Android allows developers
    to declare permissions in their applications for the activities that the app wants
    to perform. Users will be informed about the permissions that allow them to install
    the application on their devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers need to bear two things in mind regarding permissions: the permissions
    for device capabilities such as accessing camera or hardware and defining custom
    permissions. We will be discussing the first option of accessing device features
    and hardware and granting permissions to the application in this topic. This can
    be achieved using two tags in the manifest file: the `uses-feature` tag and the
    `uses-permission` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will talk about the `<uses-feature>` tag. The `<uses-feature>`
    tag lets the developers declare any single hardware or software feature to be
    used by the application. This is declared in the `AndroidManifest` file in the
    `<manifest>` tag of the application, and as the name of tag suggests, this informs
    the application about the dependent entities to be accessed. The following code
    snippet shows the general declaration of the `<uses-feature>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The <uses-feature> and <uses-permission> tags](img/9639_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that there are three attributes in the `<uses-feature>` tag: `name`,
    `required`, and `glEsVersion`. The `android:name` attribute specifies any single
    hardware or software feature used by the application in the form of a string descriptor.
    The `android:required` attribute is quite an important attribute in the `<uses-feature>`
    tag. It is a Boolean value indicating if an application needs the feature that
    is specified in the `android:name` attribute. If the developer declares `android:required="true"`
    for any feature, it means that the application won''t run without the specified
    feature available on the device. If the developer declares `android:required="false"`
    for the feature, it means that the application prefers the feature to be available
    on the device. If the feature is not available, the application won''t work properly
    or may crash when using the feature due to its unavailability. The default for
    this attribute is true. The final attribute in the `<uses-feature>` tag is `android:glEsVersion`.
    This is a version number represented in 16 bits. This attribute specifies the
    OpenGL ES version that the application will use. For example, we are using a camera
    in our application. The following code snippet shows how to declare the permissions
    for a camera in the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The <uses-feature> and <uses-permission> tags](img/9639_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the code that we have used the `android.hardware.camera` string
    for the `android:name` attribute. This string declares the camera feature of Android,
    and other attributes declare that the application requires the camera feature
    and supports the OpenGL ES 1.0 Version for it to work properly. The developer
    must specify each feature used in the application in a separate `<uses-feature>`
    tag; so, if the application requires multiple features, multiple tags should be
    declared in the manifest file. It is a good practice to declare all the features
    used in an application. These declared tags of `<uses-feature>` only provide information,
    and the Android system doesn't check for matching features before the installation
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google Play uses the `<uses-feature>` tag declared in the manifest file to filter
    the application from devices that do not meet its software and hardware requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The `<uses-feature>` tag was first introduced in API Level 4\. The earlier versions
    simply ignore this tag if an application containing the `<uses-feature>` tag is
    running on lower-version devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tables show a list of a few feature types and name strings for
    hardware and software features respectively. They can be used in the `<uses-feature>`
    tag''s `android:name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Feature type | Feature descriptor (Android name) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bluetooth | `android.hardware.bluetooth` | This feature allows the application
    to use Bluetooth of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| Camera | `android.hardware.camera` | This feature allows the application
    to use the camera component of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.camera.flash` | This is subfeature that allows the application
    to use the device''s camera''s flash. |'
  prefs: []
  type: TYPE_TB
- en: '| Location | `android.hardware.location.gps` | This subfeature allows the application
    to use the precise location coordinates obtained from the Global Position System
    (GPS) receiver of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| Sensors | `android.hardware.sensor.accelerometer` | This feature allows the
    application to use motion reading from the accelerometer sensor of the device.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.sensor.compass` | This feature allows the application to
    use directional readings from a compass of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.sensor.proximity` | This feature allows the application
    to use the proximity sensor of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| Screen | `android.hardware.screen.landscape` | This feature sets the application''s
    screen orientation to landscape. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.hardware.screen.portrait` | This feature sets the application''s
    screen orientation to portrait. |'
  prefs: []
  type: TYPE_TB
- en: '| Touchscreen | `android.hardware.touchscreen.multitouch` | This subfeature
    allows the application to use two-point multi-touch capabilities such as Pinch.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi | `android.hardware.wifi` | This feature allows the application to
    use the Wi-Fi component of the device. |'
  prefs: []
  type: TYPE_TB
- en: Software features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Feature Type | Feature Descriptor (Android name) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| App Widgets | `android.software.app_widgets` | The feature allows the application
    to include app widgets and can be installed on devices having a home screen. |'
  prefs: []
  type: TYPE_TB
- en: '| Home Screen | `android.software.home_screen` | The feature allows the application
    to behave as a home screen replacement of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| Input Method | `android.software.input_methods` | This feature allows the
    application to provide custom input methods. |'
  prefs: []
  type: TYPE_TB
- en: '| Live Wallpaper | `android.software.live_wallpaper` | This feature allows
    the application to provide live wallpapers. |'
  prefs: []
  type: TYPE_TB
- en: We haven't shown all the features and descriptors in the preceding tables. We
    have only presented some of the most commonly used features. The table shows the
    feature type of each feature, its feature name descriptor to be used in the `android:name`
    tag, and a short description of what the feature will do and how it will affect
    the application in the device.
  prefs: []
  type: TYPE_NORMAL
- en: Some features are categorized as hardware features and some as software features.
    Hardware features are the features that use hardware components on the backend.
    To access these hardware components, our application should have the permission
    to access the hardware. It should be noted that the `<uses-feature>` tag is just
    informative, and it only tells the user that the application is using some specific
    feature in the app. It doesn't allow access to the application for using any specific
    feature or component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the application to use any specific component, Android provides another
    tag, `<uses-permission>`. This tag provides access of a component to the application
    if the user allows it at the time of installation. The following code snippet
    shows the syntax for writing the `<uses-permission>` tag in the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software features](img/9639_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `<uses-permission>` tag requests any specific permission that the application
    must be granted for it to operate properly. Permissions are only granted by the
    user at the time of the installation of the application. Unlike the `<uses-feature>`
    tag, the `<uses-permission>` tag only has a single `android:name` attribute. The
    only attribute of the tag specifies the name of the permission. The name of the
    permission can be defined using the `<permission>` tag (this is beyond the scope
    of the book, and we will not discuss it) or using standard permission names provided
    by the Android system. For example, to allow application to read phone contacts,
    we can write a code snippet like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software features](img/9639_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how we provided a standard permission name from the `android.permission`
    package for reading the contacts of the phone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The features declared through the `<uses-feature>` tag are used by Google Play
    to filter the application, and the permissions declared through the `<uses-permission>`
    tag are presented to the user at the time of installation for granting access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the `<uses-feature>` tag name descriptors were added in the API after
    the `<uses-permission>` tag descriptors. Due to this, some applications using
    the `<uses-permission>` tag were able to use specific hardware without the need
    of declaring the `<uses-feature>` tag in the manifest file. To prevent the applications
    from any unexpected issues regarding this mismatch, some permissions are implied
    with some features. Google Play assumes that certain hardware-related permissions
    indicate that the underlying hardware features are required by default. The `<uses-feature>`
    tag allows Google Play to filter the applications in the market and show only
    those applications that the device is capable of running to the user. However,
    the `<uses-permission>` tag performs its duty when a user downloads the application
    and installs it. Before installation, the user is asked to grant access of all
    the permissions specified in the application. The application will only be installed
    when the user grants access. So, for those features that have both the `<uses-feature>`
    and `<uses-permission>` tag name descriptors, it is a good practice to declare
    both in the manifest of the application for it to work properly. The following
    table shows some of the features that are implied by the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | <uses-permission> descriptor | <uses-feature> descriptor |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bluetooth | `android.permission.BLUETOOTH` | `android.hardware.bluetooth`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Camera | `android.permission.CAMERA` | `android.hardware.camera` |'
  prefs: []
  type: TYPE_TB
- en: '| Location | `android.permission.ACCESS_COARSE_LOCATION` | `android.hardware.location``android.hardware.location.network`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.ACCESS_FINE_LOCATION` | `android.hardware.location.gps``android.hardware.location`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Microphone | `android.permission.RECORD_AUDIO` | `android.hardware.microphone`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Telephony | `android.permission.CALL_PHONE` | `android.hardware.telephony`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.PROCESS_OUTGOING_CALLS` | `android.hardware.telephony`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.READ_SMS` | `android.hardware.telephony` |'
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.RECIEVE_SMS` | `android.hardware.telephony` |'
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.SEND_SMS` | `android.hardware.telephony` |'
  prefs: []
  type: TYPE_TB
- en: '| `android.permission.WRITE_SMS` | `android.hardware.telephony` |'
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi | `android.permission.ACCESS_WIFI_STATE` | `android.hardware.wifi`
    |'
  prefs: []
  type: TYPE_TB
- en: You can see in the table that all the features that are implied by permissions
    are hardware features and require hardware components to run the application properly.
    So, it has already been made clear that developer should declare both the `<uses-feature>`
    and `<uses-permission>` tags to filter in Google Play and properly install it
    on the device without creating any hassle for the user and developer.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing using the SEND action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any cell phone's primary purpose is to provide an easy way of communication.
    And like all cell phones, Android smartphones provide an easier way of communication.
    In this era of the Internet and social networking, Android phones have proved
    to be quite productive in sharing and social networks. Android provides features
    such as sharing pictures, status, sending e-mails, social networking such as Facebook,
    Twitter, and so on. Fortunately for developers, all these sharing features can
    be used very easily using a few lines of intents. Intent has proved to be a very
    good way of performing asynchronous communication within Android's components
    and apps.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Intent and Its Categorization"), *Intents
    and Its Categorization*, we discussed an example of sharing status using intents.
    We will explain the same `SEND` intent in more detail in this chapter, and see
    how we can share images and text via any medium on the user's choice. When it
    comes to sharing anything on Android phones, the intents with the `SEND` action
    are used a lot. In this section, we will discuss intents with the `SEND` action
    to see what is possible with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the intent with the `SEND` action, the following code snippet shows
    the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that we have passed a string constant of `Intent.ACTION_SEND` in
    the constructor of the intent. This string constant tells the Android system that
    the intent is meant to send anything on a device. We can execute the following
    intent by calling the `startActivity()` method as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Passing the `SEND` intent in the `startActivity()` method will allow the user
    to choose his favorite way of sending by providing a dialog of all the possible
    sharing applications. But if we pass the `SEND` intent in the `startActivity()`
    method without setting the intent type, it will throw a runtime exception. The
    following log shows some lines of the exception thrown at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the log, you can see `"Unable to start activity"` and then `android.content.ActivityNotFoundException`
    is thrown. This exception is thrown when a call to the `startActivity(intent)`
    method or one of its variants fails because an activity cannot be found to execute
    the given intent. Not only the type of exception, but also the log shows the reason
    behind the failure of the activity. It says `"No activity is found to handle the
    intent"`. You might be wondering why Android couldn''t find the suitable activity
    to receive the intent. Recall implicit intents from earlier chapters, Android
    looks for all the possible activities matching the intent type and shows all those
    apps in a dialog. In our case, we haven''t defined any type for the intent except
    its `Intent.ACTION_SEND` action; that''s why we are getting a runtime exception
    of `ActivityNotFoundException`. Let''s set the type of action and see the dialog
    that shows all the possible apps to receive the intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we have called the `setType()` method and passed a string of
    the `text/html` type. This method sets an explicit MIME data type of the intent.
    This is used to create intents that only specify type and not the data. These
    are the commonly used implicit intents in Android systems. This method clears
    any data of the intent that was set previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MIME type matching in the Android framework is case sensitive. So, you should
    always write your MIME type with lowercase letters. You can also use `normalizeMimeType(String)`
    method to ensure that it is converted to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have passed `text/html` as the MIME type in method argument. This type tells
    the Android system that all those applications that support the HTML type of data
    and process it can receive this intent. So, in a result, Android pushes all those
    applications in a dialog to let the user choose his/her favorite application.
    The following image shows the dialog for the `text/html` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that all the apps supporting HTML type content are shown in the
    image, such as **Email**, **Imo Messenger**, and **Skype**. You can see how easy
    it is to share content using the `SEND` intent in Android phones, and the job
    of choosing apps and launching them is left to Android.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that there is no SMS/MMS-sending application shown in the
    dialog because SMS/MMS are just plain text applications and they support only
    that type of content.
  prefs: []
  type: TYPE_NORMAL
- en: 'On choosing any option from the list, the app will start. As we haven''t set
    any content to be shared, the application will be mostly empty. To set the content
    in the intent, we have to use extras. We will put extras for some information
    such as title, subject, or text. The following code snippet shows how to put some
    extras in the `SEND` intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see in the code that after setting the MIME type of intent, we have
    called the `putExtra()` method few times. This method adds extended data to the
    intent. There are two parameters of the function: `name` and `value`. The `name`
    parameter must include a package prefix; for example, the app `com.android.contacts`
    would use names like `com.android.contacts.ShowAll`. We have passed three strings
    for subject, title, and text content of the intent. The names such as `Intent.EXTRA_SUBJECT`,
    `Intent.EXTRA_TITLE`, and `Intent.EXTRA_TEXT` for these types of data are already
    declared in the `Intent` class, and we can access those in a static manner. You
    might be thinking why we have passed the subject if we have passed the title string
    as well. Well, the `SEND` intent is an implicit intent, and Android shows all
    the apps supporting the intent. The user can choose any app as different apps
    are interested in different data. For example, any e-mail application will be
    interested in the Subject, To, and Body strings. And any SMS application will
    only be interested in the To and Body strings. So, for efficient usage of the
    `SEND` intent, you should add all the possible content to share it with every
    application effectively. Let''s take an example of sending an e-mail using the
    `SEND` intent. The following code snippet shows how we can use the `SEND` intent
    to send an e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Firstly, we have declared our `SEND` intent by passing the `Intent.ACTION_SEND`
    parameter of constructor. Then, we have set the type of intent by the `calling
    setType()` method to the `"text/html"` MIME type. We then add the extra content
    for the e-mail app as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Intent.EXTRA_SUBJECT`: This name constant is used to add the Subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Intent.EXTRA_EMAIL`: This name constant is used to fill an e-mail address
    in the To field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Intent.EXTRA_CC`: This name constant is used to fill the e-mail address in
    the Cc field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Intent.EXTRA_BCC`: This name constant is used to fill the e-mail address in
    the Bcc field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, before calling the `startActivity()` method, we put body of the e-mail
    by the `Intent.EXTRA_TEXT` name constant and pass our text in the value parameter
    of the `putExtra()` method. The `startActivity()` method will show the same dialog
    as shown in the previous image, and on choosing an e-mail application, it will
    show the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing using the SEND action](img/9639_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An e-mail application already filled with content put in intent
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the image that all the data we put into extras is already filled
    in the e-mail application such as subject, e-mail, text etc. Now, all that the
    users have to do is to tap the **Send** button and the e-mail will be sent. In
    this example application, we have sent an e-mail to one address directly using
    the To field and indirectly by Cc and Bcc to two other addresses. Android allows
    us to add multiple e-mail addresses as well. The name constant `Intent.EXTRA_EMAIL`
    is used for this purpose. We have passed an address in the code; we can also pass
    arrays of strings consisting of e-mail addresses to send the e-mails to.
  prefs: []
  type: TYPE_NORMAL
- en: From this section, we have mostly learned about how the `ACTION_SEND` intent
    is used and how much work we can do with just a few lines of code using this intent.
    If we choose Facebook, Twitter, or any other application from the dialog, we will
    see the same result of sharing data via that app. This is the power of using implicit
    intents to make it general in almost every possible way without doing any hard
    development work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ACTION_SEND` is an action of the intent. Like this action, there are other
    actions such as `ACTION_VIEW`, `ACTION_SEARCH` that can be used by passing in
    intents for other purposes in Android.'
  prefs: []
  type: TYPE_NORMAL
- en: Telephony and making calls using intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only Android phones, but any phone's primary purpose from the day of invention
    is to provide a way to communicate long-distance conversations. And like all other
    phones, Android phones also provide features for making and receiving calls, checking
    call logs such as missed calls and dialed numbers, storing contacts, editing/modifying/deleting
    contacts, and a lot more. As Android phones lie in the frame of smart phones,
    there is a lot to the call feature. Users can make video calls, record calls,
    conference calls, mobile to computer calls and vice versa, and much more. All
    these features provide a very effective product to users and let the developers
    use these features for more flexibility and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides many APIs for telephony features for developers. These telephony
    APIs let your applications and developers access the underlying telephony hardware,
    thus making it possible to create custom dialers, integrate call handling or phone
    state monitoring, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers cannot customize the in-call screen of the phone due to security
    reasons. The in-call screen is shown when users make any calls or receive any
    incoming calls.
  prefs: []
  type: TYPE_NORMAL
- en: As this book is focused on intents, we will only discuss those telephony features
    that can be utilized using intents. From many features like making calls, receiving
    calls, checking the call log, accepting/rejecting calls, and so on, there are
    very few that can be utilized directly and only using intents. Fortunately, making
    calls is one of them. Let's discuss how we can make calls using intents in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making phone calls using intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two methods of making phone calls in Android. Developers can either
    use the APIs provided by Android to make phone calls, or they can only initiate
    phone calls by sending the intent with the necessary information such as the phone
    number. We will explore the method of initiating phone calls later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding section, we saw how we can use actions in intents to tell
    the Android system about our intentions. We will be doing the same to make phone
    calls by telling Android about our intentions and the rest of the work is left
    to the system. The following code snippet allows the application to launch the
    dialer with the specified number already dialed, and the user can explicitly make
    a call by pressing the call button in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that we have done very few changes in the code. We have declared
    a `phoneNumber` string that stores the number we want to dial. You might be wondering
    why we have concatenated a `tel:` prefix in the string. Well, that prefix is used
    in getting the **Universal Resource Identifier** (**URI**), of the number. We
    get this URI by calling the static method `Uri.parse()` of the `Uri` class. This
    method returns the URI, which we pass in turn in the constructor''s other parameter.
    We provide the `DIAL` action by passing `Intent.ACTION_DIAL` in the declaration
    of the intent, and finally, we call the `startActivity(intent)` method as always
    to execute the intent and tell the Android system to process our intentions. The
    following screenshot shows a dialer result of the previously mentioned code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A dialler screen with a dialled number initiated by starting the DIAL intent
  prefs: []
  type: TYPE_NORMAL
- en: When we run the previous code, the application will start the default dialer
    of the Android phone and will dial the number provided in code in it. It will
    not call the number; it will just dial the number because we used `Intent.ACTION_DIAL`.
    The user can explicitly press the call button of the dialer and make a call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user doesn''t want to dial the number, it is also possible to directly
    call the number without going to the dialer first. Android provides the `Intent.ACTION_CALL`
    action for this purpose. The following code snippet shows how to make calls directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see from the code that everything is the same except the action passed
    in the constructor of the intent. In the last example, we passed `Intent.ACTION_DIAL`
    and in this example we have passed `Intent.ACTION_CALL` to directly make the call.
    When we run this code snippet, the application will start making a call on an
    Android phone. The following screenshot shows the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An in-call screen shown by starting the `CALL` intent
  prefs: []
  type: TYPE_NORMAL
- en: 'This action of `ACTION_CALL` to directly make a phone call requires the user
    to grant permission to the application. The following code snippet shows the permission
    to be placed in the `AndroidManifest` file to enable the app to work perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It should be noted that `ACTION_CALL` cannot make calls to emergency numbers
    using intents; however, using `ACTION_DIAL` it is possible to dial emergency numbers.
    If the user has multiple dialers installed on the phone, the `ACTION_DIAL` action
    will present the list of dialers from which the users can choose a favorite dialer.
    The following screenshot shows the scenario of multiple dialers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making phone calls using intents](img/9639_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiple dialers to choose from the dialog
  prefs: []
  type: TYPE_NORMAL
- en: There is very little difference between the `ACTION_DIAL` and `ACTION_CALL`
    intents. The `ACTION_DIAL` intent only dials the number, and the user can explicitly
    call by pressing the call button, but `ACTION_CALL` directly makes the call without
    showing the dialer to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be restrictions on applications on making phone calls directly. So,
    it is a good practice to use `ACTION_DIAL` in the apps unless `ACTION_CALL` is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we use intents to easily make phone calls and use the telephony
    features of Android. In the next section, we will see how we can send SMS, MMS,
    and data messages using intents. Along with sending, we can also confirm the message
    delivery as well as receive messages. Let's now discuss these in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: SMS/MMS using intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the features of making calls, mobile phones support messaging
    services such as Short Messaging Services (SMS), Multimedia Messaging Services
    (MMS), and lately the data messages. The SMS/MMS features are most widely used
    in phones, and many people prefer it over making calls. Android provides APIs
    and framework that let developers send and receive messages from within their
    applications. Developers can even replace the native SMS application to send and
    receive text messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, there is no API or library for sending MMS
    messages from within your applications, but you can send them using the `ACTION_SEND`
    or `ACTION_SENDTO` intents.
  prefs: []
  type: TYPE_NORMAL
- en: This section will walk you through the various actions such as sending SMS,
    sending MMS, sending data messages, confirming message delivery, and receiving
    SMS using intents. We will then brief you about how all these actions are performed
    without using intents and how APIs of Android can be beneficial to us. Let's look
    at our first task of sending SMS messages using intents in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Sending SMS using intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best thing about using intents is that it passes the responsibility of our
    requirements to the Android system rather than we creating the full functionality
    from the core. If we use intents in our current case, which is to send an SMS
    to someone, we just have to provide the number to send the message to and the
    message to be sent. The rest is done by Android itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already had plenty of discussions over the same topic of sending something
    or sharing something using intents, and fortunately, there is nothing different
    that we have to absorb here. It''s the same old method of creating an `ACTION_SEND`
    intent and executing it by calling the `startActivity(intent)` method. The following
    code snippet shows the `ACTION_SEND` intent example that we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we use this code, it is not useful to us because it doesn''t perform
    our action of sending an SMS. Neither does it show the SMS-supporting applications
    in the chooser dialog, nor does it send any SMS with the data passed in the `EXTRA_TEXT`
    extra. To make use of `ACTION_SEND` for the purpose of sending an SMS, we have
    to take care of some extra things. There are two ways of sending an SMS using
    intents: by the `ACTION_SEND` intent and by the `ACTION_SENDTO` intent. Let''s
    see how we can send an SMS using the `ACTION_SEND` intent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create intent with the `ACTION_SEND` action and then put an extra
    `"sms_body"` with the message embedded in it. Android will ask the user for the
    phone number of the recipient itself. But it still won''t show any SMS support
    applications in the chooser-list dialog because we are still missing the type
    of intent. As SMSes are short text messages, we should set the intent type to
    `"text/html"`, but most SMS applications look for `"image/jpg"` or `"image/png"`
    as the intent type due to no native support for MMS messages. So, after setting
    the intent type to `"image/png"`, we will have the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we execute this code, we will see the chooser dialog of various apps including
    SMS support applications, e-mail applications, and so on. When we select any SMS
    application, we will see something similar to following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default SMS application shown after sending the SMS intent
  prefs: []
  type: TYPE_NORMAL
- en: You may have already noticed that the text part of the SMS application is already
    filled in with the content we added in the `"sms_body"` extra, and the user is
    typing the number of recipients of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous image shows a default SMS application of the QMobile Noir A10 smartphone.
    Your device will show the SMS application that you have set as default on your
    phone, and it won't be the same as this application for sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can send an SMS using intents. Now, let''s take our other case
    in which we want to set the number of recipients using coding. For that purpose,
    we have to use the `ACTION_SENDTO` intent instead of the `ACTION_SEND` intent.
    The following code snippet shows the use of the `ACTION_SENDTO` intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending SMS using intents](img/9639_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, you can see that we have made a few changes in the code
    that we discussed previously before sending the SMS messages. We have set the
    action to `ACTION_SENDTO` instead of `ACTION_SEND`. Also, we have passed another
    argument of the phone number URI in the constructor of the intent. We have created
    a string for the phone number and concatenated the `"sms:"` tag before the number.
    This tag lets the `Uri` class understand that the string is representing the phone
    number to send the message to and parse it accordingly. You may remember from
    the previous section, we used the `"tel"` tag for making calls to any number using
    intents. When you execute the code, it will ask the application to choose SMS.
    On selecting any SMS supported application, it will send the SMS directly to the
    phone number provided instead of asking the phone number as in the previous example.
    You may have noticed that we haven't set the type of intent in this code snippet.
    It is because when we are using the `ACTION_SENDTO` intent, we don't have to explicitly
    set the type of intent. Android will understand what the developer is trying to
    do from the tags such as `"sms"` or `"tel"` and from actions such as `ACTION_SENDTO`
    or `ACTION_CALL`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use `ACTION_SEND` and set the recipient number explicitly using
    code, Android provides the `"address"` extra to put the string of the number in
    it without having to use any tags such as `"tel"` or `"sms"`.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have talked about using `ACTION_SEND` and `ACTION_SENDTO` to send
    SMS text messages. In the next section, we will see how we can send multimedia
    messages with pictures embedded in them using intents.
  prefs: []
  type: TYPE_NORMAL
- en: Sending MMS using intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only thing that differs in a text message and multimedia message is the
    rich media embedded in it. MMS messages contain rich media content such as photos,
    videos, and cards, and some text as message for the content. Currently, there
    is no library provided by Android that lets developers send MMS natively, unlike
    SMS. But fortunately, intents make a clear way out for us in order to send an
    MMS. As the real difference defines, we have to add some media in the text message
    intent with its type set to multimedia, such as `"image/png"`, and we have then
    finished sending MMS messages. The following code snippet shows how to send any
    MMS message using intents used for SMS messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending MMS using intents](img/9639_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that there are two parts of the code. In the first part, we are
    getting the URI of our required image stored in external storage in the `images`
    folder. In the second part, we are creating intent with `ACTION_SEND`. Then, we
    add our text by using an`"sms_body"` extra and set the type to `"image/png"` to
    make it meaningful for a multimedia message. After that, we attach our media using
    the `Intent.EXTRA_STREAM` extra and pass our image URI as value in it. Finally,
    we execute the intent by calling the `startActivity(intent)` method. The only
    difference was to attach the media URI using the `EXTRA_STREAM` extra, and the
    rest was the same as in the SMS messages. You should also note that we can use
    `ACTION_SENDTO` to specify the recipient number, or we can also add the `"address"`
    extra with the value of the phone number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have set the type of `"image/png"` in the previous example. This can only
    send PNG images. For other image formats, we can specify `"images/*"`.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have only discussed sending SMS and MMS messages. But are we sure
    that those messages have been delivered successfully? Well, the next section is
    about confirming message delivery and understanding the role of intents in it.
    Let's see how we can confirm the message delivery using intents in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming message delivery using intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use intents to send messages, whether they are SMS or MMS, we just
    can''t track those messages for actions, such as, confirming delivery. The reason
    behind this is the implicit use of intents and relying on the default action of
    the Android system. If we use intents to send messages, it means that we are passing
    our responsibility of sending messages to the Android system. Now, if we want
    to confirm the delivery status of the message, it means that we are asking Android
    about our message. Unfortunately, we lack two things to make it possible: one
    is to tell the Android system about our confirmation of some message and the other
    is that the Android system may not remember what message we are talking about.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to make it possible to confirm the delivery, we have to use the native
    API for sending messages manually. It is the job of this API to keep track of
    both the delivery status and the message we are talking about. Also, using this
    API, we can easily send our query, asking the Android system about the delivery
    confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we are using native APIs for sending messages, we have to think about
    MMS messages. As mentioned earlier, there is still no native support for MMS messages;
    so, we won't be able to track and confirm the delivery of MMS messages, but yes,
    we can confirm the delivery status of SMS messages. In this section, we will talk
    about how we can check the SMS delivery status using the native SMS API and how
    intents are used to achieve our goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intents are an asynchronous way of communication in Android, and they are used
    everywhere. The only change is that they are used to achieve our goals and finish
    the requirements. In a short explanation about confirming the message delivery
    status, we will use the native SMS API called `SmsManager` to send the text message
    using the `SmsManager.sendTextMessage()` method. But to keep track of the message,
    we will use two intents: one for the sent action and one for the delivery action.
    Along with these two intents, we will also create two pending intents: one for
    the sent action and one for the delivery action. Finally, to put all four intents
    in action, we will create two broadcast receivers: one to check the sent action
    and the other to check the delivery action. It may seem quite complex here, but
    it is as easy as a charm. Let''s have a look at the code snippet that declares
    our four intents: two intents and two pending intents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we have declared our intents in the usual way in the code.
    The only difference here is that we have used our own custom actions represented
    in strings such as `"sent_sms_action"` or `"delivered_sms_action"`. Then, we have
    created two pending intents using the `getBroadcast()` factory method of the `PendingIntent`
    class. The `getBroadcast()` method will retrieve `PendingIntent` that will perform
    any broadcast, such as calling the `Context.sendBroadcast()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after creating all four intents, we will now have to create and register
    the broadcast receivers that will put the pending intents in action. The following
    code snippet shows both receivers being implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous code, we have registered two broadcast receivers using
    the `Activity.registerReceiver()` method and passed anonymous objects. The overridden
    method `onReceive()` serves our purpose. One `onReceive()` method is called when
    any message is sent, and the other `onReceive()` method is called when any message
    is delivered. We have put comments to show you where you can use your custom functionality
    in the code. You might be wondering how Android will know that these are the broadcast
    receivers for sent and delivery status. Android will know about it by checking
    the intent filters. You can see that we have passed our custom actions passed
    in intents in the constructors of intent filters, and these filters will filter
    the broadcasts, and the receiver will only receive those broadcasts for which
    it was registered. We have done our core work for confirming the message delivery
    until now. All that''s left now is to put it in action, and here, the `SmsManager`
    API comes handy. We will create an instance of `SmsManager` and call its `sendTextMessage()`
    method to send the message and put all the intents in it, and then we are done.
    The following code snippet shows the `SmsManager` usage code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember, the `SmsManager` API uses the `android.permission.SEND_SMS` permission;
    so, don''t forget to add it in your manifest file, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirming message delivery using intents](img/9639_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, this is how we can confirm the message delivery. We can only confirm the
    delivery status of text messages, and we have to ask the user to grant a `SEND_SMS`
    permission for the purpose. But, if we are using intents, we can only send messages
    and we won't be requiring any permission from the users.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android emulator supports sending and receiving SMS messages. This can be accomplished
    by creating multiple instances of emulators and sending text messages to port
    the number of emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the role of intents in confirming the message delivery, intents
    are not performing the core action of confirming message delivery here. They are
    just providing a way of communication by carrying the necessary information such
    as which message's delivery is to be checked and so on. Then, these intents are
    used by broadcast receivers that constantly check for the delivery and sent status.
    Once it is done, they pass the status in our intents and then those intents provide
    us with an update of whether the message has been sent or delivered or not.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be doing almost the same kind of stuff and coding,
    but this time, we will do it to receive messages. After using all these code snippets,
    we can develop our SMS application that can send and receive messages. Let's see
    how we can receive messages and the role of intents behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving SMS messages using intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have talked about sending SMS/MMS messages and the importance
    of intents in these applications. In this section, we will talk about how we can
    listen for incoming messages so that we can use them in our applications. Using
    this feature, we can develop messaging applications. Intents can send messages
    using the `ACTION_SEND` or `ACTION_SENDTO` intents directly, but these don't play
    a direct role in listening for incoming messages and receiving messages. Intents
    are used in the same way as `Broadcast Receiver`, and are used to get the data
    such as sender number, message, message time, and so on. Before we discuss how
    to listen for incoming messages, we have to learn about some classes that are
    used in the following application.
  prefs: []
  type: TYPE_NORMAL
- en: The SmsManager class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already used the `SmsManager` class in the previous subsections for
    confirming message delivery. This class is used to manage SMS operations such
    as sending data, SMS, and PDU messages. We can't instantiate this object using
    a constructor; we can get its instance by calling the static method of `SmsManager.getDefault()`.
    We can use this class to send messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two different classes with the name `SmsManager`: `android.telephony.SmsManager`
    and `android.telephony.gsm.SmsManager`. The later class in the GSM package is
    deprecated in API Level 4 and later versions.'
  prefs: []
  type: TYPE_NORMAL
- en: The SmsMessage object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class represents a simple SMS message object. On receiving the incoming
    messages, we will get an array of `SmsMessage` objects. This class is used to
    get information such as the message body, message time, and sender number.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Data Unit (PDU)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PDU is the industry format for an SMS message. Developers shouldn't worry
    about reading a PDU in detail or understanding the format, because the `SmsManager`
    class of Android reads and writes PDUs and provides methods for the developer
    to use PDUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'These classes and concepts will be used in receiving the incoming messages''
    app. Now, let''s discuss how messages are received in Android. When any new SMS
    message is received by any device, a new broadcast intent is fired. The action
    of this intent is `android.provider.telephony.SMS_RECEIVED`. We have to create
    a custom broadcast receiver that will look for this broadcast intent. Whenever
    we get any message, the `onReceive()` method of the broadcast receiver will be
    called. The following code snippet shows the implementation of our custom broadcast
    receiver for incoming messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As always, we have extended our class from `BroadcastReceiver` and overridden
    the `onReceive()` method. This method is called when any incoming message is received
    by the device. We first check whether this intent contains any received messages
    or not. If the intent action is the same as our `SMS_RECEIVED` string literal,
    this means that we have received our message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SMS received action `android.provider.Telephony.SMS_RECEIVED` is unsupported
    in Android and is subject to change in any future platform releases. The developer
    should be cautious when using these unsupported hidden methods and attributes
    of Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the action is verified after checking and comparing, we have to get the
    message data from the intent and perform our custom actions of the application.
    We first get the extras bundle from the intent by calling the `getExtras()` method
    and then we have passed that bundle in our method called `getMessageData()`. This
    is our custom method, and in this method, we will see how we can get the message
    data from the bundle. The following code implementation shows the method definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We first checked that our bundle is not a null object. Then we extracted the
    PDUs from the bundle by calling the `get()` method and passing the `"pdus"` key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't know which key to pass in the `get()` method, you can call the
    `Set<String> Bundle.keySet()` method to get all the keys used in the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Recalling PDUs, PDU is the industry format for an SMS message. Once we have
    all the PDU objects in an array, we create an SMS message from those PDUs using
    the `SmsMessage.createFromPdu()` method. After creating all the messages, we are
    traversing through the array and getting the message data such as the message
    body text, message sender number, and message time from it using the `SmsMessage.getMessageBody()`,
    `SmsMessage.getOriginatingAddress()`, and `SmsMessage.getTimestampMillis()` methods.
    Now, we can use these data strings in our applications. It must be noted that
    any large message is broken into many small messages, which is why we are getting
    an array of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This broadcast won''t work until we register it in our application. To register
    it in our application, we have to write the following code in our main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is nothing new to discuss here. We are creating an intent filter with
    the `SMS_RECEIVED` action and an instance of our broadcast receiver. Then, we
    are passing both in the `registerReceiver()` method of our activity. The message
    receiver requires the `android.permission.RECEIVE_SMS` permission; so, don''t
    forget to add this line in your manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how we can receive the incoming messages in our application and use
    them in many different ways. You might be wondering about the role of intents
    in this application. As mentioned earlier, intents are not used in this application
    directly. When any message is received by the device, a broadcast intent is fired.
    We are using that intent to extract data and messages from it, and those messages
    are used in our application. Intents play the role of providing the data about
    messages, after receiving them, in Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Android debug tools of the **Dalvik Debug Monitor Server** (**DDMS**)
    panel to simulate incoming messages on our Android emulators. The following screenshot
    shows the **Emulator Control** panel in the DDMS view for simulating messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol Data Unit (PDU)](img/9639_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Emulator Control panel in the DDMS view for simulating messages
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about sending SMS, MMS, confirming message delivery,
    and receiving incoming messages. We also discussed the importance and use of intents
    in all these applications. In the next section, we will learn about notifications
    and how intents are used in making interactive notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Notification using intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From traditional phones to smart phones, every mobile phone uses some method
    to notify and alert the users about some event such as receiving messages or calls.
    Like these phones, an Android phone uses a notification system to alert the users.
    A notification is a message displayed out of the application''s normal UI. When
    any new notification is triggered, it is shown in the notification area. The users
    can see notifications from the notification drawer and notification area at any
    time by pulling the drawer downward using the down gesture. The following screenshot
    shows two different examples of notifications in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Notification using intents](img/9639_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notifications in Android phones
  prefs: []
  type: TYPE_NORMAL
- en: Notifications are like channels that alert the users about important events
    as they occur when the user is busy in some other mobile activity such as playing
    a game.
  prefs: []
  type: TYPE_NORMAL
- en: For any developer, a notification is a user interface (UI) element that the
    developer displays outside of the app's normal UI to indicate and notify the user
    that an event has occurred. Then, users can choose to view the notification while
    using other apps and respond to them when they wish. Using a notification is the
    preferred way for invisible application components, such as broadcast receivers
    and services, to alert the user about the occurrence of any event.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss notifications, their layouts, displaying additional
    information in notification layouts, and launching intents. We will learn the
    role of intents and create an example application with a custom notification layout
    and how intents are important in these types of applications. Before we start
    developing our example application, let's discuss some basic concepts used in
    notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Notification forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notifications can take different forms like any persistent icon that goes into
    the status bar and can be accessed through the launcher. When this notification
    is selected by the user, any specified intent is triggered when some activity
    or service occurs. Notifications can also be used to turn on the flashing LEDs
    of the device. Also, devices can vibrate or play ringtones on receiving notifications.
  prefs: []
  type: TYPE_NORMAL
- en: The NotificationManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NotificationManager` class represents a system service that is used to
    handle the notifications'' system in Android. We can''t instantiate this class,
    but we can get its instance object by calling the `getSystemService()` method
    and passing `Context.NOTIFICATION_SERVICE`. The following code snippet shows how
    to get an instance of the `NotificationManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The NotificationManager class](img/9639_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Notification class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Notification` class represents any notification in Android. It provides
    APIs that allow developers to set the icon, title, time of notifications, and
    so on. The following code snippet shows us how to create a notification in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification class](img/9639_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Notification layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each notification has an icon and ticker text, which is sometimes called status
    text. An icon is displayed when a notification has been launched and the notification
    drawer is closed. The ticker text scrolls along the status bar when a notification
    is fired and then it is set to the notification message text when the notification
    drawer is opened. The following screenshot gives an overview of the different
    aspects of a notification area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notification and notification area
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the preceding screenshot that when any notification is fired,
    its ticker text is scrolled through the status bar. After scrolling through the
    entire text, its icon is displayed on the status bar. When a user opens the notification
    drawer by pulling it down, the notification's big icon along with the notification
    title, content text, and timestamp is shown. This is how any notification is fired
    in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will discuss how notifications are triggered and how intents are used
    in notification applications. We will create a notification, which is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple notification
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before moving forward to create a notification, we need the layout for
    our notification. The following code implementation shows our layout for the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have placed four views in `RelativeLayout`: an `ImageView` for the icon,
    a large `TextView` for the title, and two small `TextViews` for description and
    timestamp respectively. We have used the aligning of `RelativeLayouts` to place
    the views below, above, to the right of, and to the left of other views so that
    it can be displayed in the same way on every resolution of different smartphones.
    We have saved this file as `notification_layout.xml` in the layout folder of the
    resources directory. This was our layout for the notification. Now, let''s learn
    how to create any notification that will use this layout.'
  prefs: []
  type: TYPE_NORMAL
- en: To create a notification with custom layouts, we have two different methods
    in Android. The first method is to use the `setLatestEventInfo` method to update
    the details displayed in the standard extended status-notification display. This
    method is the easiest method and is used in more applications. The other method
    is to set the `contentView` and `contentIntent` properties of the notification
    to assign the custom UI layout for the extended display status using the `RemoteView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RemoteView` is a mechanism that allows developers to embed and control a layout
    embedded within any separate application. This is most commonly used in creating
    home screen widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a difficult method in this section to create the notification
    as this method uses intents in its code. We will first create a `RemoteView` object
    and assign it to the `contentView` property of the notification object. The `contentView`
    View represents the notification in the expanded status bar. Notifications often
    represent a request for action, and this action is performed when a user clicks
    on the notification in the notification drawer area or expanded status bar. We
    can specify `PendingIntent` that will be fired when the user clicks on the notification
    item. Mostly, this intent opens our application and provides more information
    about our notifications. Along with setting `contentView`, we also need to set
    `contentIntent` to our created object of `PendingIntent` in which a custom content
    view is assigned to our notification. The `contentIntent` intent is the intent
    that must be executed when the expanded status entry is clicked on. If this is
    the intent of the activity, we must include `FLAG_ACTIVITY_NEW_TASK` that will
    start our activity in a new task.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you manually set the `contentView` property, you must also set the `contentIntent`
    property; otherwise, an exception will be thrown when a notification is triggered
    causing any runtime crash of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `contentView` property is set to our custom remote view, we can''t
    set our required views in a normal way. We have to use the set methods on the
    `RemoteView` object that modifies each of the views used in the layout defined.
    This is how any notification with a custom layout is developed. The following
    code shows the implementation of the notification with custom layout, and this
    can be added in any activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see from the code that we have first created an object of `Notification`
    with the initial icon, ticker text, and time of triggering the notification. Then,
    we create intent objects, `Intent` and `PendingIntent`, for specifying the action
    of our notification when it is clicked on. Then, we set `contentIntent` and `contentView`
    of the notification object. We create a new `RemoteView` object for `contentView`
    and pass our `notification_layout.xml` reference in it. This is how the notification
    layout is set to our custom layout passed in a `RemoteView` constructor. Then,
    we set our pending intent to `contentIntent`. And finally, we update the values
    of our layout using the set methods such as `setImageViewResource()` and `setTextViewText()`.
    Until now, we have developed our notification with a custom layout. Now, we will
    see how to trigger the notification. The following code snippet shows how to trigger
    the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are getting an instance of the `NotificationManager` class by calling the
    `getSystemService()` method. To trigger the notification, we are calling the `NotificationManager.notify()`
    method that receives two parameters: the first is the ID of the notification and
    the second is the notification object itself. The following screenshot shows an
    output of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notification layout](img/9639_06_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notification fired from our application
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to create notifications and set custom layouts for
    their view. You might be thinking about the importance and use of intents in this
    application. In this application, intent was used only for one purpose and that
    is to navigate the user to our required application or activity when the user
    clicks on the notification. We created an `Intent` object, and from that, we created
    a `PendingIntent` object that was used in the notification as `contentIntent`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed Android features. We learned about common Android
    features such as layouts, display, connectivity, communication, accessibility,
    touch, and hardware support and their comparison with Android mobile components.
    We then saw how the two most important tags, `<uses-feature>` and `<uses-permission>`,
    are used in the `AndroidManifest` file and for what purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the relation between hardware and software features and Android
    mobile components and their relationship with these manifest tags. Then, we saw
    the most common intent action `ACTION_SEND` that is used to send or share anything
    with other applications using the implicit intents' approach. Then, we expanded
    our knowledge of intents to more specific features of phones including making
    calls, sending SMS/MMS messages, confirming the delivery of messages, and receiving
    messages. We used intents as well as native Android APIs to perform these actions.
    We then discussed notifications and alerts, and learned how we can set custom
    layouts in notifications. We learned two different ways, and used one way in our
    example application. We learned how intents are used in these types of applications
    and also learned about their role with those classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss intent filters and see how Android recognizes
    different intents and filters them according to the calls and applications.
  prefs: []
  type: TYPE_NORMAL
