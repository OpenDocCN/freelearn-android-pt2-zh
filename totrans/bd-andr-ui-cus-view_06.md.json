["```kt\nprivate static final int BACKGROUND_COLOR = 0xff205020; \nprivate static final int FOREGROUND_COLOR = 0xffffffff; \nprivate static final int QUAD_SIZE = 50; \n\nprivate float[] angle; \nprivate Paint paint; \n\npublic AnimationExampleView(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n\n    paint = new Paint(); \n    paint.setStyle(Paint.Style.FILL); \n    paint.setAntiAlias(true); \n    paint.setColor(FOREGROUND_COLOR); \n    paint.setTextSize(48.f); \n\n    angle = new float[4]; \n    for (int i = 0; i < 4; i++) { \n        angle[i] = 0.f; \n    } \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    canvas.drawColor(BACKGROUND_COLOR); \n\n    int width = getWidth(); \n    int height = getHeight(); \n\n    // draw 4 quads on the screen: \n    int wh = width / 2; \n    int hh = height / 2; \n\n    int qs = (wh * QUAD_SIZE) / 100; \n\n    // top left \n    canvas.save(); \n    canvas.translate( \n        wh / 2 - qs / 2, \n        hh / 2 - qs / 2); \n\n    canvas.rotate(angle[0], qs / 2.f, qs / 2.f); \n    canvas.drawRect(0, 0, qs, qs, paint); \n    canvas.restore(); \n\n    // top right \n    canvas.save(); \n    canvas.translate( \n        wh + wh / 2 - qs / 2, \n        hh / 2 - qs / 2); \n\n    canvas.rotate(angle[1], qs / 2.f, qs / 2.f); \n    canvas.drawRect(0, 0, qs, qs, paint); \n    canvas.restore(); \n\n    // bottom left \n    canvas.save(); \n    canvas.translate( \n        wh / 2 - qs / 2, \n        hh + hh / 2 - qs / 2); \n\n    canvas.rotate(angle[2], qs / 2.f, qs / 2.f); \n    canvas.drawRect(0, 0, qs, qs, paint); \n    canvas.restore(); \n\n    // bottom right \n    canvas.save(); \n    canvas.translate( \n        wh + wh / 2 - qs / 2, \n        hh + hh / 2 - qs / 2); \n\n    canvas.rotate(angle[3], qs / 2.f, qs / 2.f); \n    canvas.drawRect(0, 0, qs, qs, paint); \n    canvas.restore(); \n\n    canvas.drawText(\"a: \" + angle[0], 16, hh - 16, paint); \n    canvas.drawText(\"a: \" + angle[1], wh + 16, hh - 16, paint); \n    canvas.drawText(\"a: \" + angle[2], 16, height - 16, paint); \n    canvas.drawText(\"a: \" + angle[3], wh + 16, height - 16, paint); \n\n    postInvalidateDelayed(10); \n} \n```", "```kt\nprivate long timeStartMillis; \nprivate long timeStartNanos; \nprivate long timeStartElapsed; \n```", "```kt\nif (timeStartMillis == -1)  \n    timeStartMillis = System.currentTimeMillis(); \n\nif (timeStartNanos == -1)  \n    timeStartNanos = System.nanoTime(); \n\nif (timeStartElapsed == -1)  \n    timeStartElapsed = SystemClock.elapsedRealtime(); \n\nangle[0] += 0.2f; \nangle[1] = (System.currentTimeMillis() - timeStartMillis) * 0.02f; \nangle[2] = (System.nanoTime() - timeStartNanos) * 0.02f * 0.000001f; \nangle[3] = (SystemClock.elapsedRealtime() - timeStartElapsed) * 0.02f; \n```", "```kt\n@Override \nprotected void onVisibilityChanged(@NonNull View changedView, int visibility) { \n    super.onVisibilityChanged(changedView, visibility); \n\n    // avoid doing this check before View is even visible \n    if ((visibility == View.INVISIBLE || visibility == View.GONE) &&  \n          previousVisibility == View.VISIBLE) { \n\n        invisibleTimeStart = SystemClock.elapsedRealtime(); \n    } \n\n    if ((previousVisibility == View.INVISIBLE || previousVisibility ==\n        View.GONE) && \n        visibility == View.VISIBLE) { \n\n        timeStartElapsed += SystemClock.elapsedRealtime() -\n        invisibleTimeStart; \n    } \n    previousVisibility = visibility; \n} \n```", "```kt\n@Override \nprotected void onVisibilityChanged(@NonNull View changedView, int visibility) { \n    super.onVisibilityChanged(changedView, visibility); \n\n    // avoid doing this check before View is even visible \n    if (timeStartElapsed != -1) { \n        if ((visibility == View.INVISIBLE || visibility == View.GONE)\n            && \n            previousVisibility == View.VISIBLE) { \n\n            invisibleTimeStart = SystemClock.elapsedRealtime(); \n        } \n\n        if ((previousVisibility == View.INVISIBLE || previousVisibility\n            == View.GONE) && \n            visibility == View.VISIBLE) { \n\n            timeStartElapsed += SystemClock.elapsedRealtime() -\n            invisibleTimeStart; \n        } \n    } else {\n        timeStartMillis = System.currentTimeMillis();\n        timeStartNanos = System.nanoTime();\n        timeStartElapsed = SystemClock.elapsedRealtime();\n    }\n    previousVisibility = visibility;\n}\n```", "```kt\nprivate static final int BACKGROUND_COLOR = 0xff404060; \nprivate static final int FOREGROUND_COLOR = 0xffffffff; \nprivate static final int N_PARTICLES = 800; \n\nprivate Paint paint; \nprivate Particle[] particles; \nprivate long timeStart; \nprivate long accTime; \nprivate int previousVisibility; \nprivate long invisibleTimeStart; \n\npublic FixedTimestepExample(Context context, AttributeSet attributeSet) { \n    super(context, attributeSet); \n\n    paint = new Paint(); \n    paint.setStyle(Paint.Style.FILL); \n    paint.setAntiAlias(true); \n    paint.setColor(FOREGROUND_COLOR); \n\n    particles = new Particle[N_PARTICLES]; \n    for (int i = 0; i < N_PARTICLES; i++) { \n        particles[i] = new Particle(); \n    } \n\n    particleIndex = 0; \n    timeStart = -1; \n    accTime = 0; \n    previousVisibility = View.GONE; \n} \n```", "```kt\n@Override \nprotected void onVisibilityChanged(@NonNull View changedView, int visibility) { \n    super.onVisibilityChanged(changedView, visibility); \n    if (timeStartElapsed != -1) { \n        // avoid doing this check before View is even visible \n        if ((visibility == View.INVISIBLE ||  visibility == View.GONE)\n            && \n            previousVisibility == View.VISIBLE) { \n\n            invisibleTimeStart = SystemClock.elapsedRealtime(); \n        } \n\n        if ((previousVisibility == View.INVISIBLE || previousVisibility \n            == View.GONE) && \n            visibility == View.VISIBLE) { \n\n            timeStart += SystemClock.elapsedRealtime() -\n            invisibleTimeStart; \n        } \n    } else { \n        timeStart = SystemClock.elapsedRealtime(); \n    } \n    previousVisibility = visibility; \n} \n```", "```kt\nclass Particle { \n    float x; \n    float y; \n    float vx; \n    float vy; \n    float ttl; \n\n    Particle() { \n        ttl = 0.f; \n    } \n} \n```", "```kt\n@Override \nprotected void onDraw(Canvas canvas) { \n    animateParticles(getWidth(), getHeight()); \n\n    canvas.drawColor(BACKGROUND_COLOR); \n\n    for(int i = 0; i < N_PARTICLES; i++) { \n        float px = particles[i].x; \n        float py = particles[i].y; \n        float ttl = particles[i].ttl; \n\n        if (ttl > 0) { \n            canvas.drawRect( \n                px - PARTICLE_SIZE, \n                py - PARTICLE_SIZE, \n                px + PARTICLE_SIZE, \n                py + PARTICLE_SIZE, paint); \n        } \n    } \n    postInvalidateDelayed(10); \n} \n```", "```kt\nprivate static final int TIME_THRESHOLD = 16; \nprivate void animateParticles(int width, int height) { \n    long currentTime = SystemClock.elapsedRealtime(); \n    accTime += currentTime - timeStart; \n    timeStart = currentTime; \n\n    while(accTime > TIME_THRESHOLD) { \n        for (int i = 0; i < N_PARTICLES; i++) { \n            particles[i].logicTick(width, height); \n        } \n\n        accTime -= TIME_THRESHOLD; \n    } \n} \n```", "```kt\nvoid logicTick(int width, int height) { \n    ttl--; \n\n    if (ttl > 0) { \n        vx = vx * 0.95f; \n        vy = vy + 0.2f; \n\n        x += vx; \n        y += vy; \n\n        if (y < 0) { \n            y = 0; \n            vy = -vy * 0.8f; \n        } \n\n        if (x < 0) { \n            x = 0; \n            vx = -vx * 0.8f; \n        } \n\n        if (x >= width) { \n            x = width - 1; \n            vx = -vx * 0.8f; \n        } \n    } \n} \n```", "```kt\n@Override \npublic boolean onTouchEvent(MotionEvent event) { \n    switch (event.getAction()) { \n        case MotionEvent.ACTION_DOWN: \n        case MotionEvent.ACTION_MOVE: \n            spawnParticle(event.getX(), event.getY()); \n            return true; \n    } \n    return super.onTouchEvent(event); \n} \n```", "```kt\nprivate static final int SPAWN_RATE = 8; \nprivate int particleIndex; \n\nprivate void spawnParticle(float x, float y) { \n    for (int i = 0; i < SPAWN_RATE; i++) { \n        particles[particleIndex].x = x; \n        particles[particleIndex].y = y; \n        particles[particleIndex].vx = (float) (Math.random() * 40.f) -\n        20.f; \n        particles[particleIndex].vy = (float) (Math.random() * 20.f) -\n        10.f; \n        particles[particleIndex].ttl = (float) (Math.random() * 100.f)\n        + 150.f; \n        particleIndex++; \n        if (particleIndex == N_PARTICLES) particleIndex = 0; \n    } \n} \n```", "```kt\nprivate void animateParticles(int width, int height) {\n    long currentTime = SystemClock.elapsedRealtime();\n    accTime += currentTime - timeStart;\n    timeStart = currentTime;\n\n     while(accTime > TIME_THRESHOLD) {\n        for (int i = 0; i < N_PARTICLES; i++) {\n            particles[i].logicTick(width, height);\n        }\n\n         accTime -= TIME_THRESHOLD;\n    }\n\n     float factor = ((float) accTime) / TIME_THRESHOLD;\n     for (int i = 0; i < N_PARTICLES; i++) {\n        particles[i].adjustLogicStep(factor);\n    }\n}\n```", "```kt\nfloat nextX; \nfloat nextY; \nfloat nextVX; \nfloat nextVY; \n\nvoid logicTick(int width, int height) { \n    ttl--; \n\n    if (ttl > 0) { \n        x = nextX; \n        y = nextY; \n        vx = nextVX; \n        vy = nextVY; \n\n        nextVX = nextVX * 0.95f; \n        nextVY = nextVY + 0.2f; \n\n        nextX += nextVX; \n        nextY += nextVY; \n\n        if (nextY < 0) { \n            nextY = 0; \n            nextVY = -nextVY * 0.8f; \n        } \n\n        if (nextX < 0) { \n            nextX = 0; \n            nextVX = -nextVX * 0.8f; \n        } \n\n        if (nextX >= width) { \n            nextX = width - 1; \n            nextVX = -nextVX * 0.8f; \n        } \n    } \n} \n```", "```kt\nfloat drawX; \nfloat drawY; \n\nvoid adjustLogicStep(float factor) { \n    drawX = x * (1.f - factor) + nextX * factor; \n    drawY = y * (1.f - factor) + nextY * factor; \n} \n```", "```kt\nValueAnimator angleAnimator = ValueAnimator.ofFloat(0, 360.f); \nangleAnimator.setDuration(1500); \nangleAnimator.start(); \n```", "```kt\nfinal ValueAnimator angleAnimator = ValueAnimator.ofFloat(0, 360.f); \nangleAnimator.setDuration(1500); \nangleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { \n    @Override \n    public void onAnimationUpdate(ValueAnimator animation) { \n        angle = (float) angleAnimator.getAnimatedValue(); \n        invalidate(); \n    } \n}); \nangleAnimator.start(); \n```", "```kt\n//top left \nfinal ValueAnimator angleAnimatorTL = ValueAnimator.ofFloat(0, 360.f); \nangleAnimatorTL.setRepeatMode(ValueAnimator.REVERSE); \nangleAnimatorTL.setRepeatCount(ValueAnimator.INFINITE); \nangleAnimatorTL.setDuration(1500); \nangleAnimatorTL.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { \n    @Override \n    public void onAnimationUpdate(ValueAnimator animation) { \n        angle[0] = (float) angleAnimatorTL.getAnimatedValue(); \n        invalidate(); \n    } \n}); \n\n//top right \nfinal ValueAnimator angleAnimatorTR = ValueAnimator.ofFloat(0, 360.f); \nangleAnimatorTR.setInterpolator(new DecelerateInterpolator()); \nangleAnimatorTR.setRepeatMode(ValueAnimator.RESTART); \nangleAnimatorTR.setRepeatCount(ValueAnimator.INFINITE); \nangleAnimatorTR.setDuration(1500); \nangleAnimatorTR.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { \n    @Override \n    public void onAnimationUpdate(ValueAnimator animation) { \n        angle[1] = (float) angleAnimatorTR.getAnimatedValue(); \n        invalidate(); \n    } \n}); \n\n//bottom left \nfinal ValueAnimator angleAnimatorBL = ValueAnimator.ofFloat(0, 360.f); \nangleAnimatorBL.setInterpolator(new AccelerateDecelerateInterpolator()); \nangleAnimatorBL.setRepeatMode(ValueAnimator.RESTART); \nangleAnimatorBL.setRepeatCount(ValueAnimator.INFINITE); \nangleAnimatorBL.setDuration(1500); \nangleAnimatorBL.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { \n    @Override \n    public void onAnimationUpdate(ValueAnimator animation) { \n        angle[2] = (float) angleAnimatorBL.getAnimatedValue(); \n        invalidate(); \n    } \n}); \n\n//bottom right \nfinal ValueAnimator angleAnimatorBR = ValueAnimator.ofFloat(0, 360.f); \nangleAnimatorBR.setInterpolator(new OvershootInterpolator()); \nangleAnimatorBR.setRepeatMode(ValueAnimator.REVERSE); \nangleAnimatorBR.setRepeatCount(ValueAnimator.INFINITE); \nangleAnimatorBR.setDuration(1500); \nangleAnimatorBR.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { \n    @Override \n    public void onAnimationUpdate(ValueAnimator animation) { \n        angle[3] = (float) angleAnimatorBR.getAnimatedValue(); \n        invalidate(); \n    } \n}); \n\nangleAnimatorTL.start(); \nangleAnimatorTR.start(); \nangleAnimatorBL.start(); \nangleAnimatorBR.start(); \n```", "```kt\nfloat canvasAngle; \n\n@Override \nprotected void onDraw(Canvas canvas) { \n    canvas.save(); \n    canvas.rotate(canvasAngle, getWidth() / 2, getHeight() / 2); \n\n    ... \n\n    canvas.restore(); \n} \n```", "```kt\npublic void setCanvasAngle(float canvasAngle) { \n    this.canvasAngle = canvasAngle; \n} \n\npublic float getCanvasAngle() { \n    return canvasAngle; \n} \n```", "```kt\nObjectAnimator canvasAngleAnimator = ObjectAnimator.ofFloat(this, \"canvasAngle\", -10.f, 10.f); \ncanvasAngleAnimator.setDuration(3000); \ncanvasAngleAnimator.setRepeatCount(ValueAnimator.INFINITE); \ncanvasAngleAnimator.setRepeatMode(ValueAnimator.REVERSE); \ncanvasAngleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { \n    @Override \n    public void onAnimationUpdate(ValueAnimator animation) { \n        invalidate(); \n    } \n}); \n```"]