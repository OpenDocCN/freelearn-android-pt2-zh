- en: Chapter 2. Lua Crash Course and the Corona Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Lua 快速入门与 Corona 框架
- en: '*Lua is the programming language used to develop on the Corona SDK. So far,
    you have learned how to use the major resources to run the SDK and other development
    tools to create an application on your mobile devices. Now that we have dabbled
    into creating a couple of lines of code that make a program work, let''s jump
    into the fundamentals that will give you a better understanding of what Lua is
    capable of.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Lua 是用于在 Corona SDK 上进行开发的编程语言。到目前为止，你已经学会了如何使用主要资源来运行 SDK 和其他开发工具，在移动设备上创建应用程序。现在我们已经涉足编写几行代码让程序运行，让我们深入到基础中，这将使你更好地了解
    Lua 的能力。*'
- en: 'In this chapter, you will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Apply variables to a script
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本中应用变量
- en: Use data structures to form tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据结构来构建表
- en: Work with display objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显示对象进行操作
- en: Implement functions using object methods and arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象方法和参数实现函数
- en: Optimize your workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化你的工作流程
- en: So, let's get to it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧。
- en: Lua to the rescue
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua 来拯救
- en: Lua is the industry standard for game programming. It is similar to JavaScript
    and Flash's ActionScript. Anyone who's done any scripting in these languages will
    make the transition to Lua almost immediately.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是游戏编程的行业标准。它类似于 JavaScript 和 Flash 的 ActionScript。任何在这些语言中做过脚本编写的人几乎可以立即过渡到
    Lua。
- en: Lua has been useful in creating various applications and games. Many game programmers
    have found Lua to be a convenient scripting language due to how easy it is to
    embed, its fast execution, and its small learning curve. It is ubiquitous in *World
    of Warcraft*. It is also used by Electronic Arts, Rovio, ngmoco, and Tapulous
    in games such as *Angry Birds*, *Tap Tap Revenge*, *Diner Dash*, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 在创建各种应用程序和游戏中都很有用。由于它易于嵌入、执行速度快和学习曲线平缓，许多游戏程序员发现 Lua 是一种方便的脚本语言。《魔兽世界》中到处都在使用它。它还被
    Electronic Arts、Rovio、ngmoco 和 Tapulous 在如《愤怒的小鸟》、《敲击复仇》、《餐厅大亨》等游戏中使用。
- en: For more information on Lua, refer to [http://www.lua.org](http://www.lua.org).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Lua 的更多信息，请参考[http://www.lua.org](http://www.lua.org)。
- en: Valuable variables
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有价值的变量
- en: Like in many scripting languages, Lua has variables. You can think of a variable
    as something that stores values. When you apply a value to a variable, you can
    refer to it using the same variable name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多脚本语言一样，Lua 也有变量。你可以将变量视为存储值的东西。当你在变量中应用一个值时，你可以使用相同的变量名来引用它。
- en: An application consists of comments, blocks, statements, and variables. A **comment**
    is never processed, but it is included to explain the purpose of a statement or
    block. A **block** is a group of statements. **Statements** provide instructions
    on what operations and computations need to be done; **variables** store the values
    of these computations. Setting a value in a variable is called **assignment**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序由注释、块、语句和变量组成。**注释**永远不会被处理，但它被包含在内是为了解释一个语句或块的目的。**块**是一组语句的集合。**语句**提供关于需要执行哪些操作和计算的指令；**变量**存储这些计算的结果。在变量中设置值称为**赋值**。
- en: 'Lua uses three kinds of variables, which are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 使用三种类型的变量，如下所示：
- en: Global variables
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量
- en: Local variables
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量
- en: Table fields (properties)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表字段（属性）
- en: Variables take up memory space, which can be limited on various mobile devices.
    When a variable is no longer required, it is best to set its value to nil so that
    it can be cleaned quickly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 变量占用内存空间，这在各种移动设备上可能是有限的。当一个变量不再需要时，最好将其值设置为 nil，这样它可以被快速清理。
- en: Global variables
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'A global variable can be accessed in every scope and can be modified from anywhere.
    The term "scope" is used to describe the area in which a set of variables is accessible.
    You don''t have to declare a global variable. It is created as soon as you assign
    a value to it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量可以在每个作用域中访问，并且可以从任何地方修改。术语“作用域”用于描述一组变量可访问的区域。你不需要声明全局变量。在你为其赋值时它就会被创建：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Local variables
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'A local variable is accessed from a local scope and usually called from a function
    or block of code. When we create a block, we are creating a scope in which variables
    can live or a list of statements, which are executed sequentially. When referencing
    a variable, Lua must find the variable. Localizing variables helps speed up the
    look-up process and improves the performance of your code. Using the local statement,
    it declares a local variable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量从局部作用域访问，通常从函数或代码块中调用。当我们创建一个块时，我们正在创建一个变量可以存在的作用域或一系列按顺序执行的语句。当引用一个变量时，Lua
    必须找到该变量。局部化变量有助于加快查找过程，提高代码性能。使用 local 语句，它声明了一个局部变量：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines of code show how to declare a local variable in a block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行展示了如何在块中声明一个局部变量：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Table fields (properties)
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表字段（属性）
- en: 'Table fields are groups of variables uniquely accessed by an index. Arrays
    can be indexed with numbers and strings or any value pertaining to Lua, except
    `nil`. You index into the array to assign the values to a field using integers
    or strings. When the index is a string, the field is known as a property. All
    properties can be accessed using the dot operator (`x.y`) or a string (`x["y"]`)
    to index into a table. The result is the same:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表字段是通过索引唯一访问的一组变量。数组可以用数字和字符串索引，或者任何属于 Lua 的值，除了 `nil`。你使用整数或字符串索引到数组来为字段赋值。当索引是字符串时，该字段称为属性。所有属性都可以使用点操作符（`x.y`）或字符串（`x["y"]`）来索引表。结果是一样的：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: More information relating to tables will be discussed later in the section called
    *Tables*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于表的更多信息将在后面的*表*一节中讨论。
- en: You may have noticed additional text in certain lines of code in the preceding
    examples. These are what you call comments. Comments begin with a double hyphen,
    `--` , anywhere except inside a string. They run until the end of the line. Block
    comments are available as well. A common trick to comment out a block is to surround
    it with `--[[`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前面的示例代码中的某些行中有额外的文本。这些就是你所称的注释。注释以双连字符 `--` 开头，但不能放在字符串内部。它们一直持续到行尾。块注释也是可用的。注释掉一个块的一个常见技巧是用
    `--[[` 和 `]]` 包围它。
- en: 'Here is an example of how to comment one line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何注释一行代码的示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an example of a block comment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个块注释的示例：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Assignment conventions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值约定
- en: 'There are rules for variable names. A variable starts with a letter or an underscore.
    It can''t contain anything other than letters, underscores, or digits. It also
    can''t be one of the following reserved words of Lua:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名有规则。变量以字母或下划线开头，除了字母、下划线或数字外不能包含其他任何字符。变量名还不能是 Lua 的以下保留字：
- en: '`and`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`break`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`do`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do`'
- en: '`else`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else`'
- en: '`elseif`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elseif`'
- en: '`end`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`'
- en: '`false`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`for`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`function`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`if`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`'
- en: '`in`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`'
- en: '`local`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`'
- en: '`nil`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil`'
- en: '`not`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`or`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`repeat`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`'
- en: '`return`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`then`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then`'
- en: '`true`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`until`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until`'
- en: '`while`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`'
- en: 'The following are valid variables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有效的变量：
- en: x
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x
- en: X
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X
- en: ABC
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABC
- en: _abc
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _abc
- en: test_01
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: test_01
- en: myGroup
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: myGroup
- en: 'The following are invalid variables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不合法的变量：
- en: function
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`'
- en: my-variable
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: my-variable
- en: '123'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '123'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lua is also a case-sensitive language. For example, `else` is a reserved word,
    but Else and ELSE are two different, valid names.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 也是一个大小写敏感的语言。例如，`else` 是一个保留字，但 Else 和 ELSE 是两个不同的有效名称。
- en: Types of values
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值的类型
- en: Lua is a dynamically typed language. There is no defined variable type in the
    language. This allows each value to carry its own type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是一种动态类型的语言。在 Lua 语言中没有定义变量类型。这使得每个值都可以携带自己的类型。
- en: As you have noticed, values can be stored in variables. They can be manipulated
    to give a value of any type. This also allows you to pass arguments to other functions
    and have them returned as results.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，值可以存储在变量中。它们可以操作以生成任何类型的值。这也允许你将参数传递给其他函数，并将它们作为结果返回。
- en: 'The basic types of values that you''ll deal with are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你将处理的值的基本类型如下：
- en: '**Nil**: This is the only type whose value is `nil`. Any uninitialized variable
    has `nil` as its value. Like global variables, it is `nil` by default and can
    be assigned `nil` to delete it.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nil**：这是唯一一个值为 `nil` 的类型。任何未初始化的变量都有 `nil` 作为其值。像全局变量一样，默认是 `nil`，可以被赋值为
    `nil` 以删除它。'
- en: '**Boolean**: This type has two values: `false` and `true`. You will notice
    that conditional expressions consider `false` and `nil` as false and anything
    else as `true`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：这种类型有两个值：`false` 和 `true`。你会注意到，条件表达式将 `false` 和 `nil` 视为假，其他任何值视为
    `true`。'
- en: '**Numbers**: These represent real (double-precision, floating-point) numbers.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：这些代表实数（双精度浮点数）。'
- en: '**String**: This is a sequence of characters. 8-bit characters and embedded
    zeroes are allowed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这是一系列字符。允许8位字符和嵌入的零。'
- en: '**Tables**: These are data structures in Lua. They are implemented by an associative
    array, which is an array that can be indexed not only with numbers, but also with
    strings or any other value, except `nil` (more information on this later in this
    chapter called *Tables*).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表**：这些是Lua中的数据结构。它们通过关联数组实现，这是一个不仅可以使用数字索引，还可以使用字符串或其他任何值（除了`nil`）索引的数组（关于这一点，本章后面会详细介绍）。'
- en: '**Functions**: These are known as first-class values of Lua. Typically, functions
    can be stored in variables, passed as arguments to other functions, and returned
    as results.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：这些被称为Lua中的一等值。通常，函数可以存储在变量中，作为参数传递给其他函数，并作为结果返回。'
- en: Time for action – printing values using blocks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用代码块打印值
- en: 'Let''s give it a shot and see how powerful a language Lua is. We''re starting
    to get an idea of how variables work and what happens when you assign values to
    them. What if you have a variable that has multiple values attached to it? How
    does Lua differentiate them? We''ll use the Corona terminal so that we can see
    the values outputted in the terminal box. Along the way, you''ll pick up other
    programming techniques as you progress through this section. We will also refer
    to chunks in this exercise. The unit of execution in Lua is called a **chunk**.
    A chunk is a block that is executed sequentially. Follow these steps on getting
    started with Lua:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试，看看Lua语言有多强大。我们开始了解变量是如何工作的，以及当你给它们赋值时会发生什么。如果你有一个带有多个值的变量会怎样？Lua如何区分它们？我们将使用Corona终端，这样我们就可以在终端框中看到输出的值。在这个过程中，你还会学习到其他编程技术。我们在这项练习中也会提到代码块。Lua中执行单元被称为**代码块**。代码块是按顺序执行的一块代码。按照以下步骤开始学习Lua：
- en: If you remember, in the previous chapter, you learned how to create your own
    project folder and `main.lua` file for the Hello World application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在前面的章节中，你学习了如何为Hello World应用程序创建自己的项目文件夹和`main.lua`文件。
- en: Create a new project folder on your desktop and name it `Variables`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的桌面上创建一个新的项目文件夹，并将其命名为`Variables`。
- en: Open up your preferred text editor and save it as `main.lua` in your `Variables`
    project folder.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的文本编辑器，并将其保存为`Variables`项目文件夹中的`main.lua`。
- en: 'Create the following variables:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下变量：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add in the `while` loop:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环中加入以下内容：
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an `if` statement that will represent another local body:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示另一个局部体的`if`语句：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save your script.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本。
- en: Launch the Corona terminal. Make sure that you see the Corona SDK screen and
    a terminal window pop up.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Corona终端。确保你看到Corona SDK屏幕和终端窗口弹出。
- en: 'Navigate to your `Variables` project folder and open your `main.lua` file in
    the simulator. You will notice that the device in the simulator is blank, but
    if you look at your terminal window, there are some results from the code printed
    out as shown here:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Variables`项目文件夹，并在模拟器中打开你的`main.lua`文件。你会注意到模拟器中的设备是空白的，但如果你查看终端窗口，会看到代码输出的结果，如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*What just happened?*'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The first two variables that were created are local ones outside of each block
    of code. Notice that at the beginning of the `while` loop, `i <= x` refers to
    the variables in lines 1 and 2\. The `local x = i` statement inside the `while`
    loop is only local to the `do` body and is not the same as `local x = 10`. The
    `while` loop runs 10 times and prints out a value that is incremented by one each
    time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的前两个变量是每个代码块外的局部变量。注意在`while`循环的开始部分，`i <= x`指的是第1行和第2行的变量。`while`循环内的`local
    x = i`语句只对`do`体局部有效，并不等同于`local x = 10`。`while`循环运行10次，每次递增一并输出值。
- en: The `if` statement compares `i < 20`, where `i` equals 11 at this point and
    uses another `local x` variable that is local to the `then` body. Since the statement
    is true, `x` equals 20 and prints out the value of `x + 5`, which is `25`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句会对比`i < 20`，此时`i`等于11，并使用另一个在`then`体内的局部变量`local x`。因为语句为真，`x`等于20并输出`x
    + 5`的值，即`25`。'
- en: The very last line, `print(x)`, is not attached to any of the blocks of code
    in the `while` loop or the `if` statement. Therefore, it refers to `local x =
    10` and prints out the value of 10 in the terminal window. This may seem confusing,
    but it's important to understand how local and global variables work in Lua.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码 `print(x)` 没有附加到 `while` 循环或 `if` 语句中的任何代码块。因此，它指的是 `local x = 10` 并在终端窗口输出
    10 的值。这可能看起来有些混淆，但理解 Lua 中局部变量和全局变量如何工作是很重要的。
- en: Expressions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: An **expression** is something that represents a value. It can include numeric
    constants, quoted strings, variable names, unary and binary operations, and function
    calls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**是代表值的实体。它可以包括数字常量、字符串、变量名、一元和二元运算以及函数调用。'
- en: Arithmetic operators
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: '`+`, `-`, `*`, `/`, `%`, and `^` are called arithmetic operators.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`、`-`、`*`、`/`、`%` 和 `^` 被称为算术运算符。'
- en: 'Here is an example of binary arithmetic operators:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二元算术运算符的例子：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An example of the modulo (division remainder) operator is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模运算（除法余数）运算符的例子：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An example of the power of operator is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符强大之处的一个例子如下：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Relational operators
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: Relational operators always result in false or true and ask yes or no questions.
    The relational operators are `<`, `>`, `<=`, `>=`, `==`, `~=`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符总是返回 false 或 true，并询问是或否的问题。关系运算符有 `<`、`>`、`<=`、`>=`、`==`、`~=`。
- en: The `==` operator tests for equality, and the `~=` operator tests for inequality.
    If the value types are different, then the result is false. Otherwise, Lua compares
    the values to their types. Numbers and strings are compared in the usual way.
    Tables and functions are compared by reference as long as two such values are
    considered equal, only if they are the same object. When a new object is created,
    the new object is different from the previously existing one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 运算符用于测试相等性，而 `~=` 运算符用于测试不等性。如果值类型不同，结果为假。否则，Lua 根据类型比较值。数字和字符串以常规方式比较。只要两个这样的值被认为是相等的，表和函数就通过引用比较，只有当它们是同一个对象时才相等。当创建新对象时，新对象与之前存在的对象是不同的。'
- en: 'Here are examples of relational operators. They will display Boolean results
    and can''t be concatenated with strings:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关系运算符的例子。它们将显示布尔结果，不能与字符串拼接：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Logical operators
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: The logical operators in Lua are `and`, `or`, and `not`. All logical operators
    consider both `false` and `nil` as false and anything else as true.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的逻辑运算符有 `and`、`or` 和 `not`。所有逻辑运算符将 `false` 和 `nil` 视为假，其他任何值视为真。
- en: 'The `and` operator returns its first argument if the value is `false` or `nil`;
    otherwise, it returns its second argument. The `or` operator returns its first
    argument if the value is different from `nil` and `false`; otherwise, it returns
    its second argument. Both `and` and `or` use a shortcut evaluation; this means
    the second operand is evaluated only when necessary. Here are some examples of
    logical operators:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 运算符如果其值为 `false` 或 `nil`，则返回第一个参数；否则，返回第二个参数。`or` 运算符如果其值不是 `nil` 和 `false`，则返回第一个参数；否则，返回第二个参数。`and`
    和 `or` 都使用短路评估；这意味着只有必要时才会评估第二个操作数。以下是一些逻辑运算符的例子：'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `not` operator always returns true or false:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 运算符总是返回 true 或 false：'
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Concatenation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: 'The string concatenation operator in Lua is denoted by two dots, "`..`". It
    takes two values as operands and splices them together. If any of its operands
    is a number, then it is also converted to a string. Some examples of the concatenation
    operator are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的字符串连接运算符由两个点表示，即"`..`"。它将两个值作为操作数并将它们拼接在一起。如果其操作数中的任何一个为数字，则也会被转换成字符串。以下是一些连接运算符的例子：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The length operator
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度运算符
- en: 'The `#` length operator measures the length of a string or size of a table.
    The length of a string is simply the number of characters in it. A character is
    considered one byte. Examples of the length operator are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 长度运算符用于测量字符串的长度或表的大小。字符串的长度就是它包含的字符数。一个字符被认为是一个字节。以下是一些长度运算符的例子：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Precedence
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级
- en: 'The following list shows the operator precedence in Lua displayed from the
    highest to the lowest priority:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 Lua 中的运算符优先级，从最高到最低优先级：
- en: '`^`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`'
- en: '`not`, `#`, `-` (unary)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`、`#`、`-`（一元）'
- en: '`*`, `/`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`、`/`'
- en: '`+`, `-`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`、`-`'
- en: '`..`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`..`'
- en: '`<`, `>`, `<=`, `>=`, `~=`, `==`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`、`>`、`<=`、`>=`、`~=`、`==`'
- en: '`and`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`or`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`'
- en: All binary operators are left associative, except for the `^` exponentiation
    and the`..` concatenation, which are right associative. You can use parentheses
    to change the precedence of an expression.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的二元运算符都是左结合的，除了`^`指数和`..`连接运算符，它们是右结合的。你可以使用括号来改变表达式的优先级。
- en: 'In cases where two operands of the same precedence compete for operands, the
    operand belongs to the operator on the left-hand side:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个相同优先级的操作数争夺操作数的情况下，操作数属于左侧的操作符：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding expression shows both the addition and subtraction operators,
    which have equal precedence. The second element (the number `4`) belongs to the
    addition operator, so the expression is evaluated mathematically as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个表达式显示了加法和减法运算符，它们的优先级相等。第二个元素（数字`4`）属于加法运算符，因此表达式从数学上评估如下：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s focus on the rules of precedence based on priority. Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注基于优先级的优先规则。以下是一个示例：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An inexperienced programmer may think that the value of the preceding example
    is 90 if it were evaluated from left to right. The correct value is 34 because
    multiplication has a higher precedence than addition, so it is performed first.
    Adding parentheses to the same expression will make it easier to read:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有经验的程序员可能会认为，如果从前到后评估，前一个示例的值是90。正确的值是34，因为乘法比加法的优先级高，所以它首先执行。为同一表达式添加括号将使其更容易阅读：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Strings
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Earlier in this chapter, you saw some code examples using sequences of characters.
    Those sequences of characters are called **strings**. Strings may consist of any
    character, including numeric values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你看到了一些使用字符序列的代码示例。这些字符序列称为**字符串**。字符串可以包含任何字符，包括数值。
- en: Quoting strings
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用字符串
- en: 'There are three ways to quote strings: with double quotes, with single quotes,
    and with square brackets.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式来引用字符串：使用双引号、使用单引号以及使用方括号。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When quoting strings, make sure that only straight quotes are used in your code
    and not curly quotes; or else, it will not compile.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用字符串时，请确保代码中只使用直引号，而不是弯引号；否则，它将无法编译。
- en: 'Double quote characters `"` mark the beginning and end of the string. Here
    is an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符`"`标记字符串的开始和结束。以下是一个示例：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also quote strings using the single quote character `''`. Single quotes
    work the same as double quotes, except that single-quoted strings can contain
    a double quote. Here is an example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用单引号字符`'`来引用字符串。单引号与双引号的作用相同，不同之处在于单引号字符串可以包含双引号。以下是一个示例：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, using a pair of square brackets will also quote strings. They are
    used mainly for strings when double or single quotes cannot be used. There are
    not many cases where this occurs, but they will do the job:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用一对方括号也可以引用字符串。它们主要用于当双引号或单引号不能使用时的字符串。没有很多这样的情况，但它们可以完成任务：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Time for action – getting our hands full of strings
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——让我们充分使用字符串
- en: 'We''re starting to familiarize ourselves with several blocks of code and how
    they interact with each other. Let''s see what happens when we add in some expressions
    using strings and how different they are from just regular strings that you print
    out in the terminal:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始熟悉几段代码以及它们之间的相互作用。让我们看看当我们添加一些使用字符串的表达式时会发生什么，以及它们与在终端中打印的普通字符串有何不同：
- en: Create a new project folder on your desktop and name it `Working With Strings`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的桌面上创建一个新的项目文件夹，并将其命名为`Working With Strings`。
- en: Make a new `main.lua` file in your text editor and save it to your folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中创建一个新的`main.lua`文件，并将其保存到你的文件夹中。
- en: 'Type out the following lines (do not include the line numbers in the code,
    they are only used for line reference):'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下几行（代码中不要包含行号，它们仅用于行参考）：
- en: '[PRE25]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add in the following variables. Notice that it uses the same variable name:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下变量。注意它使用了相同的变量名：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s add in more variables with some string values and compare them using
    different operators:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些带有字符串值的变量，并使用不同的运算符进行比较：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save your script and launch your project in Corona. Observe the results in
    the terminal window:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并在Corona中启动你的项目。在终端窗口中观察结果：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*What just happened?*'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You can see that line 1 is just a plain string with characters printed out.
    In line 2, notice that number `15` is inside the string and then added to the
    number `1`, which is outside of the string. Lua provides automatic conversions
    between numbers and strings at runtime. Numeric operations applied to a string
    will try to convert the string to a number.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第1行只是一个普通的字符串，字符被打印出来。在第2行，注意数字 `15` 在字符串中，然后与字符串外的数字 `1` 相加。Lua 在运行时提供数字和字符串之间的自动转换。对字符串应用数值运算会尝试将字符串转换为数字。
- en: When working with variables, you can use the same one and have them contain
    a string and a number at different times, like in lines 3 and 5 (`myVar = 28`
    and `myVar = "twenty-eight"`).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用变量时，你可以使用同一个变量，并让它们在不同时间包含字符串和数字，如第3行和第5行（`myVar = 28` 和 `myVar = "twenty-eight"`）。
- en: In the last chunk of code (lines 7-12), we compared different variable names
    using relational operators. First, we printed the strings of `Name1` and `Phone`.
    The next lines that follow compared `Name1`, `Name2`, and `Phone`. When two strings
    have the same characters in the exact order, then they are considered the same
    string and are equal to each other. When you look at `print(Name1 == Phone)` and
    `print(Name1 <= Phone)`, the statement returns `false` because of the ASCII order.
    Digits are before alphabets, which are smaller when you compare them. In `print(Name1
    == Name2)`, both variables contain the same characters, and therefore, it returns
    `true`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段代码（第7-12行）中，我们使用关系运算符比较了不同的变量名。首先，我们打印了 `Name1` 和 `Phone` 的字符串。接下来的行比较了
    `Name1`、`Name2` 和 `Phone`。当两个字符串具有完全相同的字符顺序时，它们被认为是相同的字符串并且相等。当你查看 `print(Name1
    == Phone)` 和 `print(Name1 <= Phone)` 时，这些语句返回 `false`，因为它们是根据 ASCII 顺序。数字在字母之前，比较时被视为较小。在
    `print(Name1 == Name2)` 中，两个变量包含相同的字符，因此它返回 `true`。
- en: Have a go hero – pulling some more strings
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手实践——进一步操作字符串
- en: 'Strings are pretty simple to work with since they are just sequences of characters.
    Try making your own expressions similar to the preceding example with the following
    modifications:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串很容易处理，因为它们只是字符序列。尝试根据前面的示例进行修改，创建你自己的表达式。
- en: Create some variables with numerical values and another set of variables with
    numerical string values. Use relational operators to compare the values and then
    print out the results.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些带有数值的变量，再创建一组带有数值字符串的变量。使用关系运算符比较这些值，然后将结果打印出来。
- en: Use the concatenation operator, combine several strings or numbers together,
    and space them out equally. Print out the result in the terminal window.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用连接运算符，将几个字符串或数字组合在一起，并使它们均匀地分隔开。在终端窗口中打印结果。
- en: Tables
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表
- en: Tables are the proprietary data structure in Lua. They represent arrays, lists,
    sets, records, graphs, and so on. A table in Lua is similar to an associative
    array. Associative arrays can be indexed with values of any type, not just numbers.
    Tables implement all these structures efficiently. For example, arrays can be
    implemented by indexing tables with integers. Arrays do not have a fixed size,
    but grow as needed. When initializing an array, its size is defined indirectly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表是 Lua 中特有的数据结构。它们可以表示数组、列表、集合、记录、图等。Lua 中的表类似于关联数组。关联数组可以使用任何类型的值进行索引，不仅仅是数字。表高效地实现所有这些结构。例如，可以通过使用整数索引表来实现数组。数组没有固定的大小，但会根据需要增长。初始化数组时，其大小是间接定义的。
- en: 'Here is an example of how tables can be constructed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何构建表的例子：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will notice that in line 5, `a["y"]` is indexing the value from line 3\.
    In line 7, `a[b]` uses a new value of variable `b` and indexes the value of `20`
    to the string, `"Monday"`. The last line, `c`, is separate from the previous variables,
    and its only value is the string, `"hello"`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到第5行中的 `a["y"]` 正在从第3行索引值。在第7行，`a[b]` 使用变量 `b` 的新值并将数值 `20` 索引到字符串 `"Monday"`
    上。最后一行 `c` 与之前的变量无关，其唯一的值是字符串 `"hello"`。
- en: Passing a table as an array
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将表作为数组传递
- en: 'Keys of a table can be consecutive integers, starting at 1\. They can be made
    into an array (or a list):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表的键可以是连续的整数，从1开始。它们可以被制作成数组（或列表）：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another way of writing table constructors to build arrays in a faster and more
    convenient way that doesn''t require writing out each integer key is shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了一种更快、更方便的编写表构造函数来构建数组的方法，该方法不需要写出每个整数键：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Altering contents in a table
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改表中的内容
- en: 'While working with tables, you can modify or remove the values already in it
    and also add new values to it. This can be accomplished using the assignment statement.
    The following example creates a table with three people and their favorite types
    of drink. You can make an assignment to change one person''s drink, add a new
    person-drink pair to the table, and remove an existing person-drink pair:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表时，你可以修改或删除表中已有的值，也可以添加新值。这可以通过赋值语句完成。以下示例创建了一个包含三个人及其最喜欢的饮料类型的表。你可以进行赋值以更改一个人的饮料，向表中添加新的人员-饮料配对，以及移除现有的人员-饮料配对：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`drinks.Jackie = "lemonade"` overwrites the original value of `drinks.Jackie
    = "milk".`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Jackie = "lemonade"`覆盖了`drinks.Jackie = "milk"`的原始值。'
- en: '`drinks.Anne = "water"` adds a new key and value to the table. The value of
    `drinks.Anne` before this line would have been nil.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Anne = "water"`这行代码为表格添加了一个新的键值对。在这行代码之前，`drinks.Anne`的值是nil。'
- en: The value of `drinks.Matt = "soda"` stays the same since there were no alterations
    to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有对其进行修改，`drinks.Matt = "soda"`的值保持不变。
- en: '`drinks.Jim = nil` overwrites the original value of `drinks.Jim = "orange juice"`
    with `nil`. It removes the `Jim` key from the table.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`drinks.Jim = nil`用`nil`覆盖了`drinks.Jim = "orange juice"`的原始值。它从表格中移除了`Jim`键。'
- en: Populating a table
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充表
- en: 'Ways to populate a table is to start with an empty table and add things to
    it one at a time. We''ll use constructors, which are expressions that create and
    initialize tables. The simplest constructor is the empty constructor, `{}`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 填充表的方法是从一个空表开始，逐一添加内容。我们将使用构造函数，这些是创建和初始化表的表达式。最简单的构造函数是空构造函数，`{}`：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following are the results from the terminal:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是终端的输出结果：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example shows that `myNumbers = {}` is an empty table constructor.
    A `for` loop is created and calls `myNumbers[i]` 5 times, starting from number
    1\. Each time it is called, it is incremented by 1 and then printed out.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明`myNumbers = {}`是一个空表构造器。创建了一个`for`循环，并调用`myNumbers[i]`五次，从数字1开始。每次调用时，它都会增加1，然后被打印出来。
- en: Objects
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: Tables and functions are objects; variables do not actually contain these values,
    only references to them. Tables are also used in what is known as object-oriented
    programming. Variables and methods that manipulate those variables can be collected
    together into objects. Such a value is called an **object**, and its functions
    are called **methods**. In Corona, we'll focus more on display objects since they
    are essential for game development.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表和函数是对象；变量实际上并不包含这些值，只包含对它们的引用。表也用于所谓的面向对象编程。可以收集变量和操作这些变量的方法到对象中。这样的值称为**对象**，其函数称为**方法**。在Corona中，我们将更多地关注显示对象，因为它们对游戏开发至关重要。
- en: Display objects
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示对象
- en: Anything drawn on the screen is made by display objects. In Corona, the assets
    you see displayed in the simulator are instances of display objects. You have
    probably seen shapes, images, and text, which are all forms of display objects.
    When you create these objects, you'll be able to animate them, turn them into
    backgrounds, interact with them using touch events, and so on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示的任何内容都是由显示对象制成的。在Corona中，你在模拟器中看到的资源都是显示对象的实例。你可能已经看到过形状、图像和文本，这些都是显示对象的形式。当你创建这些对象时，你将能够对它们进行动画处理，将它们变成背景，使用触摸事件与它们互动，等等。
- en: Display objects are created by calling a function known as a factory function.
    There is a specific kind of factory function for each type of display object.
    For example, `display.newCircle()` creates a vector object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象是通过调用一个称为工厂函数的函数来创建的。每种类型的显示对象都有一个特定的工厂函数。例如，`display.newCircle()`创建一个矢量对象。
- en: Instances of display objects behave in a manner similar to Lua tables. This
    enables you to add your own properties to an object as long as they do not conflict
    with the system-assigned properties and method names.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象的实例行为类似于Lua表。这使得你可以在不与系统分配的属性和方法名称发生冲突的情况下，向对象添加自己的属性。
- en: Display properties
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示属性
- en: 'The dot operator is used to access properties. Display objects share the following
    properties:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 点运算符用于访问属性。显示对象共享以下属性：
- en: '`object.alpha`: This is the object''s opacity. A value of 0 is transparent
    and 1.0 is opaque. The default value is 1.0.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.alpha`：这是对象的透明度。0表示完全透明，1.0表示不透明。默认值为1.0。'
- en: '`object.height`: This is in the local coordinates.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.height`：这是在本地坐标系中的高度。'
- en: '`object.isVisible`: This controls whether the object is visible on the screen.
    True is visible and false is not. The default is true.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.isVisible`：这个属性控制对象是否在屏幕上可见。True表示可见，false表示不可见。默认值为true。'
- en: '`object.isHitTestable` This allows an object to continue to receive hit events
    even if it is not visible. If true, objects will receive hit events regardless
    of visibility; if false, events are only sent to visible objects. It defaults
    to false.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.isHitTestable`：即使对象不可见，这也允许对象继续接收击中事件。如果为true，无论可见性如何，对象都会接收击中事件；如果为false，则只有可见对象会发送事件。默认为false。'
- en: '`object.parent`: This is a read-only property that returns the object''s parent.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.parent`：这是一个只读属性，返回对象的父对象。'
- en: '`object.rotation`: This is the current rotation angle (in degrees). It can
    be a negative or positive number. The default is 0.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.rotation`：这是当前的旋转角度（以度为单位）。可以是负数或正数。默认值为0。'
- en: '`object.contentBounds`: This is a table with the `xMin`, `xMax`, `yMin`, and
    `yMax` properties in screen coordinates. It is generally used to map the object
    in a group to the screen coordinates.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.contentBounds`：这是一个表格，包含屏幕坐标中的`xMin`、`xMax`、`yMin`和`yMax`属性。它通常用于将组中的对象映射到屏幕坐标。'
- en: '`object.contentHeight`: This is the height in screen coordinates.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.contentHeight`：这是屏幕坐标中的高度。'
- en: '`object.contentWidth`: This is the width in screen coordinates.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.contentWidth`：这是屏幕坐标中的宽度。'
- en: '`object.width`: This is in local coordinates.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.width`：这是局部坐标中的宽度。'
- en: '`object.x`: This specifies the *x* position (in local coordinates) of the object
    relative to the parent—the parent''s origin to be precise. It provides the *x*
    position of the object''s reference point relative to the parent. Changing the
    value of this will move the object in the *x* direction.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.x`：这指定了对象相对于父对象的*x*位置（在局部坐标中）——确切地说是相对于父对象的原点。它提供了对象的参考点相对于父对象的*x*位置。改变这个值将会在*x*方向移动对象。'
- en: '`object.anchorX`: This specifies the *x* position of the object''s alignment
    to the parent''s origin. Anchors range from 0.0 to 1.0\. By default, new objects
    have their anchor set to 0.5.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.anchorX`：这指定了对象的对齐位置相对于父对象原点的*x*位置。锚点范围从0.0到1.0。默认情况下，新对象的锚点设置为0.5。'
- en: '`object.xScale`: This gets or sets the *x* scaling factor. A value of 0.5 will
    scale the object to 50 percent in the *x* direction. The scaling occurs around
    the object''s reference point. The default reference point for most display objects
    is center.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.xScale`：获取或设置*x*缩放因子。值为0.5会将对象在*x*方向缩放到50%。缩放围绕对象的参考点进行。大多数显示对象的默认参考点是中心。'
- en: '`object.y`: This specifies the *y* position (in local coordinates) of the object
    relative to the parent—the parent''s origin to be precise.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.y`：这指定了对象相对于父对象的*y*位置（在局部坐标中）——确切地说是相对于父对象的原点。'
- en: '`object.anchorY`: This specifies the *y* position of the object''s alignment
    to the parent''s origin. Anchors range from 0.0 to 1.0\. By default, new objects
    have their anchor set to 0.5.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.anchorY`：这指定了对象的对齐位置相对于父对象原点的*y*位置。锚点范围从0.0到1.0。默认情况下，新对象的锚点设置为0.5。'
- en: '`object.yScale`: This gets or sets the *y* scaling factor. A value of 0.5 will
    scale the object to 50 percent in the *y* direction. The scaling occurs around
    the object''s anchor point. The default reference point for most display objects
    is center.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.yScale`：获取或设置*y*缩放因子。值为0.5会将对象在*y*方向缩放到50%。缩放围绕对象的锚点进行。大多数显示对象的默认参考点是中心。'
- en: Object methods
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象方法
- en: 'Corona can create display objects to store object methods as properties. There
    are two ways this can be done: using the dot operator ("`.`") or using the colon
    operator ("`:`"). Both are valid ways to create object methods.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Corona可以创建显示对象，将对象方法作为属性存储。有两种方法可以实现：使用点操作符（"."）或使用冒号操作符（":"）。这两种方式都是创建对象方法的有效方式。
- en: 'This is an example of the dot operator:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点操作符的一个例子：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is an example of the colon operator:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是冒号操作符的一个例子：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The call to an object method using the dot operator is passed to the object
    if it's the first argument. The colon operator method is merely a shortcut with
    less typing involved to create the function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点操作符调用对象方法的第一个参数会传递给对象。冒号操作符方法只是创建函数的快捷方式，涉及到的输入更少。
- en: 'Display objects share the following methods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象共享以下方法：
- en: '`object:rotate(deltaAngle)` or `object.rotate(object, deltaAngle)`: This effectively
    adds `deltaAngle` (in degrees) to the current rotation property.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:rotate(deltaAngle)`或`object.rotate(object, deltaAngle)`：这实际上将`deltaAngle`（以度为单位）添加到当前的旋转属性中。'
- en: '`object:scale(sx, sy)` or `object.scale(object, sx, sy)`: This effectively
    multiplies the `xScale` and `yScale` properties using `sx` and `sy`, respectively.
    If the current `xScale` and `yScale` values are 0.5 and `sx` and `sy` are also
    0.5, the resulting scale will be 0.25 for `xScale` and `yScale`. This scales the
    object from 50 percent of its original size to 25 percent.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:scale(sx, sy)` 或 `object.scale(object, sx, sy)`：这有效地使用 `sx` 和 `sy`
    分别乘以 `xScale` 和 `yScale` 属性。如果当前的 `xScale` 和 `yScale` 值为0.5，而 `sx` 和 `sy` 也是0.5，那么结果的比例将是
    `xScale` 和 `yScale` 的0.25。这将对象从原始大小的50%缩放到25%。'
- en: '`object:translate(deltaX, deltaY)` or `object.translate(object, deltaX, deltaY)`:
    This effectively adds `deltaX` and `deltaY` to the `x` and `y` properties respectively.
    This will move the object from its current position.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:translate(deltaX, deltaY)` 或 `object.translate(object, deltaX, deltaY)`：这将有效地将
    `deltaX` 和 `deltaY` 分别加到 `x` 和 `y` 属性上。这将把对象从当前位置移动。'
- en: '`object:removeSelf()` or `object.removeSelf(object)`: This removes the display
    object and frees its memory, assuming that there are no other references to it.
    This is equivalent to calling `group:remove(IndexOrChild)` on the same display
    object, but is syntactically simpler. The `removeSelf()` syntax is also supported
    in other cases, such as removing physics joints in physics.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:removeSelf()` 或 `object.removeSelf(object)`：这移除了显示对象并释放其内存，假设没有其他引用它。这相当于在同一个显示对象上调用
    `group:remove(IndexOrChild)`，但语法更简单。`removeSelf()` 语法也支持在其他情况下使用，例如在物理中移除物理关节。'
- en: Images
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像
- en: Many art assets are used in Corona applications images. You will notice that
    bitmap image objects are a type of display objects.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Corona应用程序中使用了许多艺术资源图像。你会注意到，位图图像对象是一种显示对象类型。
- en: Loading an image
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载图像
- en: Using `display.newImage(filename [, baseDirectory] [, left, top])`, an image
    object is returned. The image data is loaded from a filename you specified for
    your image and looks in `system.ResourceDirectory` for that file. The acceptable
    types of image files that are supported are `.png` (PNG-24 or higher only) and
    `.jpg` files. Avoid high `.jpg` compression as it may take longer to load on a
    device. The`.png` files have better quality than the `.jpg` files and are used
    to display transparent images. The `.jpg` files do not save transparent images.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `display.newImage(filename [, baseDirectory] [, left, top])`，将返回一个图像对象。图像数据是从你为图像指定的文件名中加载的，并在
    `system.ResourceDirectory` 中查找该文件。支持的图像文件类型有 `.png`（仅限PNG-24或更高）和 `.jpg` 文件。避免高
    `.jpg` 压缩，因为它可能会在设备上加载时间更长。`.png` 文件的质量比 `.jpg` 文件好，用于显示透明图像。`.jpg` 文件不能保存透明图像。
- en: Image autoscaling
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像自动缩放
- en: The default behavior of `display.newImage()` is to autoscale large images. This
    is to conserve texture memory. However, there are times when you do not want to
    have images autoscaled, and there is an optional Boolean flag in the parameter
    list to control this manually.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`display.newImage()` 的默认行为是自动缩放大图像。这是为了节省纹理内存。然而，有时你可能不希望图像自动缩放，参数列表中有一个可选的布尔标志可以手动控制这一点。'
- en: 'To override autoscaling and show the image at its full resolution, use the
    optional `isFullResolution` parameter. By default, it is false, but if you specify
    true, then the new image is loaded at its full resolution:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖自动缩放并在其全分辨率下显示图像，请使用可选的 `isFullResolution` 参数。默认情况下，它是false，但如果你指定为true，则新图像以其全分辨率加载：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The limitations and known issues are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 限制和已知问题如下：
- en: Indexed PNG image files are not supported.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持索引PNG图像文件。
- en: Grayscale images are currently not supported; images must be RGB.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前不支持灰度图像；图像必须是RGB格式。
- en: Images will still be autoscaled if they are larger than the maximum possible
    texture dimensions of the device. This is usually 2048 x 2048 px (iPad) and bigger
    for the newer, faster devices.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图像大于设备可能的最大纹理尺寸，图像仍将被自动缩放。这通常是2048 x 2048像素（iPad）对于较新、速度更快的设备来说会更大。
- en: If you reload the same image multiple times, the subsequent calls to `display.newImage`
    ignore the `isFullResolution` parameter and take on the value passed the first
    time. In other words, the way you load an image file the first time affects the
    autoscaling setting the next time you load that same file. This is because Corona
    conserves texture memory by automatically reusing a texture that has already been
    loaded. As a result, you can use the same images as many times as you want without
    consuming additional texture memory.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你多次重新加载同一图像，后续调用 `display.newImage` 会忽略 `isFullResolution` 参数，并采用第一次传递的值。换句话说，你第一次加载图像文件的方式会影响下一次加载同一文件时的自动缩放设置。这是因为
    Corona 通过自动复用已经加载的纹理来节省纹理内存。因此，你可以多次使用相同的图像，而不会消耗额外的纹理内存。
- en: More information on Corona SDK's documentation is located on Corona's website
    at [http://coronalabs.com](http://coronalabs.com).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Corona SDK 文档的更多信息可以在 Corona 的官方网站上找到，网址为 [http://coronalabs.com](http://coronalabs.com)。
- en: Time for action – placing images on screen
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间——在屏幕上放置图像
- en: 'We''re finally getting into the visually appealing part of this chapter by
    starting to add in display objects using images. We don''t have to refer to the
    terminal window for now. So, let''s focus on the simulator screen. We''ll begin
    by creating a background image and some art assets by performing the following
    steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于要进入本章的视觉吸引部分，开始通过图像添加显示对象。现在我们不需要参考终端窗口。因此，让我们专注于模拟器屏幕。我们将通过执行以下步骤来创建一个背景图像和一些美术资源：
- en: First off, create a new project folder on your desktop and name it `Display
    Objects`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在桌面上创建一个新的项目文件夹，并将其命名为 `Display Objects`。
- en: In the `Chapter 2 Resources` folder, copy the `glassbg.png` and `moon.png` image
    files and the `config.lua` file into your `Display Objects` project folder.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter 2 Resources` 文件夹中，将 `glassbg.png` 和 `moon.png` 图像文件以及 `config.lua`
    文件复制到你的 `Display Objects` 项目文件夹中。
- en: Launch your text editor and create a new `main.lua` file for your current project.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的文本编辑器，为当前项目创建一个新的 `main.lua` 文件。
- en: 'Write out the following lines of code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下几行代码：
- en: '[PRE38]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The background display object should contain the filename of the background
    image in your project folder. For example, if the background image filename is
    called `glassbg.png`, then you would display the image like so:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 背景显示对象应该包含项目文件夹中背景图像的文件名。例如，如果背景图像文件名为 `glassbg.png`，那么你可以像这样显示图像：
- en: '[PRE39]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using `image02.x = 160; image02.y = 200` is the same as the following lines
    of code:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `image02.x = 160; image02.y = 200` 与以下几行代码是等效的：
- en: '[PRE40]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The semicolon (`;`) indicates the end of a statement and is optional. It makes
    it easier to separate two or more statements in one line and saves adding extra
    lines in your code.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分号（`;`）表示语句的结束，是可选的。它使得在单行中分隔两个或多个语句变得更加容易，也避免了在代码中添加多余的行。
- en: Save your script and launch your project in the simulator.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并在模拟器中启动你的项目。
- en: Note
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're using Corona SDK on a Mac OS X, the default device is the iPhone.
    If you're using Windows, the default device is the Droid.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你是在 Mac OS X 上使用 Corona SDK，默认设备是 iPhone。如果你是在 Windows 上使用，默认设备是 Droid。
- en: You should see a background image and three other display objects of the same
    image, as shown in the following screen. The display results will vary depending
    on which device you use to simulate.![Time for action – placing images on screen](img/9343OT_02_01.jpg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到一个背景图像和三个相同的图像显示对象，如下屏幕所示。显示结果将根据你用于模拟的设备而有所不同。![动手操作时间——在屏幕上放置图像](img/9343OT_02_01.jpg)
- en: The display objects for the `image01`, `image02`, and `image03` variables should
    contain the `moon.png` filename. The filenames in your code are case sensitive,
    so make sure that you write it exactly how it displays in your project folder.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`image01`、`image02` 和 `image03` 变量的显示对象应包含 `moon.png` 文件名。代码中的文件名区分大小写，因此请确保你按照项目文件夹中显示的格式准确书写。'
- en: '*What just happened?*'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Currently, `background` is scaled to fit within the device screen height and
    width using `contentCenterX` and `contentCenterY`. The image centered at its local
    origin since no top or left (*x* or *y*) coordinates were applied. It is also
    set to full resolution because we specified `true` in the display object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，`background` 使用 `contentCenterX` 和 `contentCenterY` 被缩放以适应设备屏幕的高度和宽度。由于没有应用顶部或左侧（*x*
    或 *y*）坐标，图像在其本地原点居中。由于我们在显示对象中指定了 `true`，它也被设置为全分辨率。
- en: When you observe the placement of `image01`, `image02`, and `image03` in the
    simulator, they're practically in line with each other vertically, though the
    script styles for `image01` versus `image02`/`image03` are written differently.
    This is because the coordinates for `image01` are based on the (left, top) coordinates
    of the display object. You can optionally specify that the image's top-left corner
    be located at the coordinate (left, top); if you don't supply both coordinates,
    the image will be centered about its local origin.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器中观察`image01`、`image02`和`image03`的位置时，它们实际上是垂直对齐的，尽管`image01`与`image02`/`image03`的脚本样式编写不同。这是因为`image01`的坐标基于显示对象的（左，上）坐标。你可以选择性地指定图像的左上角位于坐标（左，上）；如果你没有提供两个坐标，图像将围绕其本地原点居中。
- en: The placement of `image02` and `image03` are specified from the local origin
    of the display object and positioned by the local values of the *x* and *y* properties
    of the device screen. The local origin is at the center of the image; the reference
    point is initialized to this point. Since we didn't apply (left, top) values to
    `image02` and `image03`, further access to *x* or *y* properties are referred
    to the center of the image.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`image02`和`image03`的位置是从显示对象的本地原点指定的，并通过设备屏幕的*x*和*y*属性的本地值定位。本地原点位于图像的中心；参考点初始化为此点。由于我们没有为`image02`和`image03`应用（左，上）值，因此进一步访问*x*或*y*属性将参考图像的中心。'
- en: Now, you've probably noticed that the output from the iPhone 4 looks fine and
    dandy, but the output from the Droid shows that the background image displays
    at full resolution, while the other objects are lower down the screen. We see
    that all the objects we specified are there, but the scaling is off. That is because
    each iOS and Android device has a different screen resolution. The iPhone 4 has
    a screen resolution of 640 x 960 pixels, and the Droid has a screen resolution
    of 480 x 854 pixels. What may look fine on one type of device may not look exactly
    the same on a different one. Don't worry; there is a simple solution to fix all
    this using a `config.lua` file that will be discussed in the next couple of sections.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到iPhone 4的输出看起来很好，但Droid的输出显示背景图像以全分辨率显示，而其他对象则位于屏幕下方。我们可以看到我们指定的所有对象都在那里，但缩放比例不对。这是因为每个iOS和Android设备的屏幕分辨率都不同。iPhone
    4的屏幕分辨率为640 x 960像素，而Droid的屏幕分辨率为480 x 854像素。在一个类型的设备上看起来可能很好，但在另一个设备上可能不会完全相同。别担心，在接下来的几节中，我们将讨论使用一个`config.lua`文件来解决这个问题。
- en: Have a go hero – adjusting display object properties
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——调整显示对象属性
- en: 'Now that you know how to add images to the device screen, try testing out the
    other display properties. Try doing any of the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道如何将图像添加到设备屏幕，尝试测试其他显示属性。尝试以下任何一项：
- en: Changing all the *x* and *y* coordinates of the `image01`, `image02`, and `image03`
    display objects
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`image01`、`image02`和`image03`显示对象的所有*x*和*y*坐标
- en: Choosing any display object and changing its rotation
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择任何显示对象并更改其旋转
- en: Changing the visibility of a single display object
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改单个显示对象的可视性
- en: Reference the display properties mentioned earlier in this chapter if you're
    unsure how to do any of the preceding adjustments.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定如何进行上述调整，请参考本章前面提到的显示属性。
- en: Runtime configuration
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时配置
- en: All project files not only contain a `main.lua` file, but other `.lua` and related
    assets as needed for your project. Some Corona projects are configured using a
    `config.lua` file that is compiled into your project and accessed at runtime.
    This allows you to specify dynamic content scaling, dynamic content alignment,
    dynamic image resolution, frame rate control, and antialiasing, all at the same
    time, so that the output on every type of device is displayed similarly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有项目文件不仅包含一个`main.lua`文件，还包含根据项目需要而定的其他`.lua`和相关资源。一些Corona项目使用`config.lua`文件配置，该文件编译到你的项目中，并在运行时访问。这使得你可以同时指定动态内容缩放、动态内容对齐、动态图像分辨率、帧率控制和抗锯齿，以便在每种类型的设备上显示类似的输出。
- en: Dynamic content scaling
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内容缩放
- en: Corona allows you to specify the screen size you plan to aim your content for.
    This is done using a file called `config.lua`. You'll be able to scale the assets
    for your app to run on a device whose screen size is smaller or bigger.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Corona允许你指定你打算针对的屏幕尺寸。这是通过一个叫做`config.lua`的文件来完成的。你将能够根据设备屏幕尺寸的大小，为你的应用程序缩放资源。
- en: 'The following values should be used to scale content:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用以下值来缩放内容：
- en: '`width` (number): This is the screen resolution width of the original target
    device (in portrait orientation)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`（数字）：这是原始目标设备在纵向模式下的屏幕分辨率宽度'
- en: '`height` (number): This is the screen resolution height of the original target
    device (in portrait orientation).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`（数字）：这是原始目标设备在纵向模式下的屏幕分辨率高度。'
- en: '`scale` (string): This is a type of autoscaling from the following values:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`（字符串）：这是以下值的自动缩放类型：'
- en: '`letterbox`: This scales up content uniformly as much as possible'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`letterbox`：这种缩放方式尽可能均匀地放大内容。'
- en: '`zoomEven`: This scales up content to uniformly to fill the screen, while keeping
    the aspect ratio'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoomEven`：这种缩放方式均匀地放大内容以填满屏幕，同时保持宽高比。'
- en: '`zoomStretch`: This scales up content nonuniformly to fill the screen and will
    stretch it vertically or horizontally'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoomStretch`：这种缩放方式非均匀地放大内容以填满屏幕，并会垂直或水平拉伸。'
- en: Note
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `zoomStretch` value works well with Android device scaling, since many of
    them have different screen resolutions.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`zoomStretch`值在处理Android设备缩放时效果很好，因为它们有许多不同的屏幕分辨率。'
- en: Dynamic content alignment
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内容对齐
- en: 'Content that is dynamically scaled is already centered by default. You may
    find cases where you don''t want the content to be centered. Devices such as the
    iPhone 3G and the Droid have completely different screen resolutions. In order
    for the content displayed on the Droid to be similar to iPhone 3G, the alignment
    needs to be adjusted so that the content fills the entire screen without leaving
    any empty black screen space. The alignment is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，动态缩放的内容已经居中。你可能会遇到不希望内容居中的情况。例如iPhone 3G和Droid具有完全不同的屏幕分辨率。为了使Droid上显示的内容与iPhone
    3G相似，需要调整对齐方式，使内容填满整个屏幕，而不留下任何空白的黑色屏幕空间。对齐方式如下：
- en: '`xAlign`: This is a string that specifies the alignment in the *x* direction.
    The following values can be used:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xAlign`：这是一个指定*x*方向对齐的字符串。可以使用以下值：'
- en: '`left`'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: '`center` (default)'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`（默认）'
- en: '`right`'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: '`yAlign`: This is a string that specifies the alignment in the *y* direction.
    The following values can be used:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yAlign`：这是一个指定*y*方向对齐的字符串。可以使用以下值：'
- en: '`top`'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`center` (default)'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`（默认）'
- en: '`bottom`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: Dynamic image resolution
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态图像分辨率
- en: Corona allows you to swap in higher resolution versions of your images to higher
    resolution devices, without having to change your layout code. This is a case
    to consider if building for multiple devices with different screen resolutions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Corona允许你为更高分辨率的设备替换更高分辨率的图片版本，而无需更改布局代码。如果要在具有不同屏幕分辨率的多个设备上构建，这是一个需要考虑的情况。
- en: An example where you want to display hi-res images is on an iPhone 4 where the
    resolution is 640 x 960 pixels. It is double the resolution of the earlier iOS
    devices, such as iPhone 3GS, which is 320 x 480 pixels. Scaling up the content
    from the iPhone 3GS to fit the iPhone 4 screen works, but the images will not
    be as crisp and will look a little fuzzy on the device.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要显示高分辨率图片的一个例子是在iPhone 4上，其分辨率为640 x 960像素。它是早期iOS设备（如iPhone 3GS，分辨率为320 x
    480像素）分辨率的的两倍。将iPhone 3GS的内容放大以适应iPhone 4屏幕是可行的，但图片不会那么清晰，在设备上看起来会有些模糊。
- en: Images of higher resolution can be swapped in for the iPhone 4 by adding a `@2x`
    suffix to the end of the filename (but before the period and file extension).
    For example, if your image filename is `myImage.png`, then your higher resolution
    filename should be `myImage@2x.png`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在文件名末尾（但在句号和文件扩展名之前）添加`@2x`后缀，可以为iPhone 4替换更高分辨率的图片。例如，如果你的图片文件名是`myImage.png`，那么更高分辨率的文件名应该是`myImage@2x.png`。
- en: 'In your `config.lua` file, a table named `imageSuffix` needs to be added for
    the image naming convention and image resolutions to take effect. The `config.lua`
    file resides in your project folder where all your other `.lua` files and image
    files are stored. Look at the following example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`config.lua`文件中，需要添加一个名为`imageSuffix`的表格，以使图像命名约定和图像分辨率生效。`config.lua`文件位于你的项目文件夹中，该文件夹存储了所有的`.lua`文件和图像文件。请看以下示例：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When calling your display objects, use `display.newImageRect( [parentGroup,]
    filename [, baseDirectory] w, h)` instead of `display.newImage()`. The target
    height and width need to be set to the dimensions of your base image.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用你的显示对象时，使用`display.newImageRect( [parentGroup,] filename [, baseDirectory]
    w, h)`而不是`display.newImage()`。目标高度和宽度需要设置为你的基础图像的尺寸。
- en: Frame rate control
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率控制
- en: The frame rate is 30 fps (frames per second) by default. Fps refers to the speed
    at which the image is refreshed in games. Thirty fps is standard in mobile games,
    especially for older devices. You can set it to 60 fps when you add in the fps
    key. Using 60 fps makes your app run smoother. You can easily detect a life-like
    fluidity in the motion when it comes to running animations or collision detections.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 默认帧率为30 fps（每秒帧数）。Fps 指的是游戏中图像刷新的速度。30 fps 是移动游戏的标准，特别是对于较旧的设备。当你添加了 fps 键时，可以将其设置为60
    fps。使用60 fps 会使你的应用程序运行更加流畅。在运行动画或碰撞检测时，你可以轻松地检测到动作的逼真流畅性。
- en: Time for action – scaling display objects on multiple devices
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在多个设备上缩放显示对象
- en: In our `Display Objects` project, we left off displaying a background image
    and three similar display objects in the simulator. When running the project on
    different devices, the coordinates and resolution size were most compatible with
    the iPhone only. When building applications for multiple devices across iOS and
    Android platforms, we can configure it using a `config.lua` file that is compiled
    into the project and accessed at runtime. So let's get to it!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Display Objects` 项目中，我们在模拟器中留下了一个背景图像和三个类似的显示对象未显示。在不同的设备上运行项目时，坐标和分辨率大小与
    iPhone 最兼容。在为 iOS 和 Android 平台上的多个设备构建应用程序时，我们可以使用编译到项目中并在运行时访问的 `config.lua`
    文件进行配置。那么，让我们开始吧！
- en: 'In your text editor, create a new file and write out the following lines:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中，创建一个新文件并写下以下几行：
- en: '[PRE42]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Save your script as `config.lua` in your `Display Objects` project folder.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Display Objects` 项目文件夹中将脚本保存为 `config.lua`。
- en: For Mac users, launch your application in Corona under the iPhone device. Once
    you have done so, under the Corona Simulator menu bar, go to **Window** | **View
    As** | **iPhone 4**. You will notice that the display objects fit perfectly on
    the screen and that there are no empty black spaces showing either.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Mac 用户，在 Corona 下以 iPhone 设备启动你的应用程序。完成此操作后，在 Corona 模拟器菜单栏下，选择 **Window**
    | **View As** | **iPhone 4**。你会注意到显示对象完美地适应屏幕，并且没有出现任何空黑的空白。
- en: Windows users, launch your application in Corona under the Droid device. You
    will notice that all the content is scaled and aligned properly. Under the Corona
    Simulator menu bar, go to **Window** | **View As** | **NexusOne**. Observe the
    similarities in the content placement to that of the Droid. In the following screenshot,
    from left to right, you can see the iPhone 3GS, iPhone 4, Droid, and NexusOne:![Time
    for action – scaling display objects on multiple devices](img/9343OT_02_02.jpg)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 用户，在 Corona 下以 Droid 设备启动你的应用程序。你会注意到所有内容都被适当地缩放和对齐。在 Corona 模拟器菜单栏下，选择
    **Window** | **View As** | **NexusOne**。观察内容布局与 Droid 的相似之处。在以下截图中，从左到右，你可以看到
    iPhone 3GS、iPhone 4、Droid 和 NexusOne：![行动时间 – 在多个设备上缩放显示对象](img/9343OT_02_02.jpg)
- en: '*What just happened?*'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You have now learned a way to implement an easy configuration to display your
    content across a variety of devices on iOS and Android. Content scaling features
    are useful for multiscreen development. If you look in the `config.lua` file we
    created, `width = 320` and `height = 480`. This is the resolution size that the
    content is originally authored for. In this case, it is the iPhone 3G. Since we
    used `scale = "letterbox"`, it enabled the content to uniformly scale up as much
    as possible while still showing the entire content on the screen.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了一种方法，可以在 iOS 和 Android 上的多种设备上轻松配置显示内容。内容缩放功能对于多屏幕开发很有用。如果你查看我们创建的 `config.lua`
    文件，`width = 320` 和 `height = 480`。这是内容最初针对的分辨率大小。在本例中，它是 iPhone 3G。由于我们使用了 `scale
    = "letterbox"`，它使得内容尽可能均匀地放大，同时仍然在屏幕上显示全部内容。
- en: We also set `xAlign = "left"` and `yAlign = "top"`. This fills in the empty
    black screen space that shows on the Droid specifically. The content scaling is
    at the center by default, so aligning the content to the left and top of the screen
    will take away the additional screen space.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了 `xAlign = "left"` 和 `yAlign = "top"`。这填补了 Droid 设备上特别显示的空黑屏幕空间。默认情况下，内容缩放是在中心的，因此将内容对齐到屏幕的左上角将消除额外的屏幕空间。
- en: Dynamic resolution images
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分辨率图像
- en: Earlier, we touched base with dynamic image resolution. The iOS devices are
    a perfect example for this case. Corona has the capability to use base images
    (for devices on the 3GS and lower) and double-resolution images (for the iPhone
    4 that has a retina display), all in the same project file. Any of your double-resolution
    images can be swapped to your high-end iOS device without having to alter your
    code. This will allow your build to work with older devices and lets you handle
    more complex multiscreen deployment cases. You will notice that dynamic image
    resolution works in conjunction with dynamic content scaling.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到了动态图像分辨率。iOS 设备就是这种情况的一个完美例子。Corona 能够在同一个项目文件中使用基本图像（针对3GS及以下设备）和双倍分辨率图像（针对拥有视网膜显示屏的iPhone
    4），你的双倍分辨率图像可以无需修改代码，直接切换到高端iOS设备上。这将使得你的构建能够支持旧设备，并让你处理更复杂的多屏幕部署情况。你会注意到，动态图像分辨率与动态内容缩放是协同工作的。
- en: Using the line, `display.newImageRect( [parentGroup,] filename [, baseDirectory]
    w, h)`, will call out your dynamic resolution images.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这行代码 `display.newImageRect( [parentGroup,] filename [, baseDirectory] w, h)`，可以调用你的动态分辨率图像。
- en: Here, `w` refers to the content *width* of the image and `h` refers to the content
    *height* of the image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`w` 指的是图像的内容*宽度*，而 `h` 指的是图像的内容*高度*。
- en: 'Here is an example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Remember that the two values represent the base image size, *not* the onscreen
    position of the image. You must define the base size in your code so that Corona
    knows how to render the higher resolution alternative images. The contents of
    your project folder would be set up like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这两个值代表基本图像的大小，*不是*图像在屏幕上的位置。你必须在代码中定义基本大小，这样 Corona 才知道如何渲染更高分辨率的替代图像。你的项目文件夹内容将按如下方式设置：
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When creating your double-resolution image, make sure that it is *twice* the
    size of the base image. It's best that you start with the double-resolution image
    when creating your display assets. Corona lets you select your own image-naming
    patterns. The `@2x` convention is one example that can be used, but you have the
    option of naming suffixes to your personal preference. For now, we'll use the
    `@2x` suffix since it distinguishes the double resolution reference. When you
    create your double-resolution image, name it with the `@2x` suffix included. Take
    the same image and resize it to 50 percent of the original size and then use the
    same filename without the `@2x` suffix included.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建双倍分辨率图像时，请确保它是基本图像大小的*两倍*。在创建显示资源时，最好从双倍分辨率图像开始。Corona 允许你选择自己的图像命名模式。`@2x`
    是一个可以使用的约定示例，但你也可以根据个人偏好选择命名后缀。现在，我们将使用 `@2x` 后缀，因为它可以区分双分辨率引用。创建双倍分辨率图像时，请包含
    `@2x` 后缀进行命名。取相同的图像，将其大小调整为原始大小的50%，然后使用不包含 `@2x` 后缀的相同文件名。
- en: 'Other examples of naming suffixes can be as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 其他命名后缀的例子可能如下所示：
- en: '@2'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@2'
- en: '-2'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-2'
- en: -two
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -two
- en: 'As mentioned earlier in the chapter, you have to define your image suffix for
    your double-resolution images in the `imageSuffix` table in your `config.lua`
    file. The content scale you set will allow Corona to determine the ratio between
    the current screen and base content dimensions. The following example uses the
    `@2x` suffix to define double-resolution images:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，你需要在 `config.lua` 文件中的 `imageSuffix` 表中为你的双倍分辨率图像定义图像后缀。你设置的内容缩放比例将允许
    Corona 确定当前屏幕与基本内容尺寸之间的比例。以下示例使用 `@2x` 后缀来定义双倍分辨率图像：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Time for some shapes
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是时候来一些形状了。
- en: 'Another way of creating display objects is using vector objects. You can use
    vector objects to create shapes such as a rectangle, rounded rectangle, and circle
    using the following functions:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 创建显示对象的另一种方式是使用矢量对象。你可以使用矢量对象来创建如下形状的矩形、圆角矩形和圆形：
- en: '`display.newRect([parentGroup,] x, y, width, height)`: This creates a rectangle
    using width by height. The `x` and `y` values determine coordinates for the center
    of the rectangle. Local origin is at the center of the rectangle, and the anchor
    point is initialized to this local origin.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newRect([parentGroup,] x, y, width, height)`: 这个函数用于创建一个由宽度和高度确定的矩形。`x`
    和 `y` 值决定了矩形的中心坐标。局部原点位于矩形的中心，锚点初始化为此局部原点。'
- en: '`display.newRoundedRect([parentGroup,] x, y, width, height, cornerRadius)`:
    This creates a rounded rectangle using width by height. The `x` and `y` values
    determine coordinates for the center of the rectangle. The local origin is at
    the center of the rectangle, and the anchor point is initialized to this local
    origin. You can round off the corners using `cornerRadius`.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newRoundedRect([parentGroup,] x, y, width, height, cornerRadius)`:
    这将创建一个宽度和高度的圆角矩形。`x`和`y`值决定了矩形的中心坐标。局部原点位于矩形的中心，锚点初始化为此局部原点。您可以使用`cornerRadius`来圆滑角。'
- en: '`display.newCircle([parentGroup,] xCenter, yCenter, radius)`: This creates
    a circle using the radius centered at `xCenter`, `yCenter`.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newCircle([parentGroup,] xCenter, yCenter, radius)`: 这将创建一个以`xCenter`，`yCenter`为中心的半径的圆。'
- en: Applying stroke width, fill color, and stroke color
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用笔触宽度、填充颜色和笔触颜色
- en: 'All vector objects can be outlined using strokes. You can set the stroke width,
    fill color, and stroke color using the following methods:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 所有矢量对象都可以使用笔触进行勾勒。您可以使用以下方法设置笔触宽度、填充颜色和笔触颜色：
- en: '`object.strokeWidth`: This creates the stroke width in pixels'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.strokeWidth`: 这创建笔触宽度，以像素为单位'
- en: '`object:setFillColor(red, green, blue, alpha)`: We can use the RGB codes between
    0 and 1\. The `alpha` parameter, which is optional, defaults to 1.0'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setFillColor(red, green, blue, alpha)`: 我们可以使用0到1之间的RGB代码。`alpha`参数是可选的，默认值为1.0。'
- en: '`object:setStrokeColor(red, green, blue, alpha)`: We can use the RGB codes
    between 0 and 255\. The `alpha` parameter, which is optional, defaults to 1.0'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setStrokeColor(red, green, blue, alpha)`: 我们可以使用0到255之间的RGB代码。`alpha`参数是可选的，默认值为1.0。'
- en: 'Here is an example of displaying vector objects using strokes:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用笔触显示矢量对象的示例：
- en: '[PRE46]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will get on output on the simulator similar to the one shown in the following
    image:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在模拟器上获得与以下图像相似的输出：
- en: '![Applying stroke width, fill color, and stroke color](img/9343OT_02_03.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![应用笔触宽度、填充颜色和笔触颜色](img/9343OT_02_03.jpg)'
- en: Text, text, text
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本，文本，文本
- en: 'In [Chapter 1](ch01.html "Chapter 1. Getting Started with Corona SDK"), *Getting
    Started with Corona SDK*, we created the Hello World application using a text
    display object. Let''s go in detail on how text is implemented onscreen:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 开始使用Corona SDK")，*开始使用Corona SDK*中，我们使用文本显示对象创建了Hello
    World应用程序。让我们详细了解一下文本如何在屏幕上实现：
- en: The `display.newText( [parentGroup,] text, x, y, font, fontSize)` method creates
    a text object using the `x` and `y` values. There is no text color by default.
    In the `font` parameter, apply any of the font names in the library. The `fontSize`
    parameter displays the size of the text.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.newText( [parentGroup,] text, x, y, font, fontSize)`方法使用`x`和`y`值创建文本对象。默认情况下没有文本颜色。在`font`参数中，应用库中的任何字体名称。`fontSize`参数显示文本的大小。'
- en: 'Some of the following default constants can be used if you don''t want to apply
    a font name:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不想应用字体名称，可以使用以下一些默认常量：
- en: '`native.systemFont`'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native.systemFont`'
- en: '`native.systemFontBold`'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native.systemFontBold`'
- en: Applying color and string value
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用颜色和字符串值
- en: 'The size, color, and text fields can be set or retrieved in text display objects:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本显示对象中可以设置或检索大小、颜色和文本字段：
- en: '`object.size`: This is the size of the text.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.size`: 这是文本的大小。'
- en: '`object:setFillColor(red, green, blue, alpha)`: We can use the RGB codes between
    0 and 1\. The `alpha` parameter, which is optional, defaults to 1.0.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:setFillColor(red, green, blue, alpha)`: 我们可以使用0到1之间的RGB代码。`alpha`参数是可选的，默认值为1.0。'
- en: '`object.text`: This contains the text of the text object. It allows you to
    update a string value for a test object.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object.text`: 这包含文本对象的文本。它允许您更新测试对象的字符串值。'
- en: What are functions?
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是什么？
- en: Functions can carry out a procedure or compute and return values. We can make
    a function call as a statement, or we can use it as an expression. You can also
    use object methods as functions. You have learned that functions can be variables.
    A table can use these variables to store them as properties.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以执行一个过程或计算并返回值。我们可以将函数调用作为语句，也可以将其作为表达式使用。您还可以将对象方法作为函数使用。您知道函数可以是变量。表可以使用这些变量将它们作为属性存储。
- en: 'Functions are the most important means of abstraction in Lua. One function
    that we have used many times is `print`. In the following example, the `print`
    function is being told to execute one piece of data—the `"My favorite number is
    8"` string:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是Lua中最重要的抽象手段。我们经常使用的一个函数是`print`。在以下示例中，`print`函数被告诉执行一个数据块——`"My favorite
    number is 8"`字符串：
- en: '[PRE47]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Another way of saying this is that `print` is being called with one argument.
    The `print` function is only one of the many built-in functions that Lua has,
    but almost any program you write will involve you defining your own functions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表述方式是，`print`函数被调用时带有一个参数。`print`函数是Lua语言众多内置函数中的一个，但几乎你编写的任何程序都会涉及定义自己的函数。
- en: Defining a function
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: 'When trying to define a function, you have to give it a name that you can call
    out to when you want to return a value. You then have to create a statement or
    statement block of what the value will output and then apply `end` to your function
    after you have finished defining it. Here is an example:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试定义一个函数时，你必须给它一个名字，当你想要返回一个值时可以调用这个名字。然后，你需要创建一个语句或语句块来输出值，并在完成定义后为函数应用`end`。以下是一个示例：
- en: '[PRE48]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice that the function name is `myName`, and it is used to call out what's
    inside the `print("My name is Jane.")` function definition.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数名为`myName`，它被用来调用`print("My name is Jane.")`函数定义中的内容。
- en: 'An extension on defining a function is as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对定义函数的一个扩展如下：
- en: '[PRE49]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The new `myName` function has one argument using the `Name` variable. The `"My
    name is "` string is concatenated with `Name` and then a period as the printed
    result. When the function is called, we used three different names as an argument,
    and the result is printed with a new customized name for each line.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`myName`函数有一个使用`Name`变量的参数。`"My name is "`字符串与`Name`连接，然后以句号作为打印结果。当调用函数时，我们使用了三个不同的名字作为参数，并为每一行打印了一个新的自定义名称。
- en: More display functions
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多显示功能
- en: In Corona, you can change the appearance of the status bar on your device. This
    is a one-line setting in your code that takes effect once you launch your application.
    You can change the appearance of your status bar using the `display.setStatusBar(mode)`
    method. This hides or changes the appearance of the status bar on iOS devices
    (iPad, iPhone, and iPod Touch) and Android 2.x devices. Android 3.x devices are
    not supported.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在Corona中，你可以改变设备上状态栏的外观。这是代码中的一行设置，一旦你启动应用程序就会生效。你可以使用`display.setStatusBar(mode)`方法来改变状态栏的外观。这将在iOS设备（iPad、iPhone和iPod
    Touch）和Android 2.x设备上隐藏或改变状态栏的外观。Android 3.x设备不受支持。
- en: 'The argument mode should be one of the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 参数模式应该是以下之一：
- en: '`display.HiddenStatusBar`:To hide the status bar, you can use the following
    line at the beginning of your code:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.HiddenStatusBar`：若要隐藏状态栏，你可以在代码开始处使用以下这行代码：'
- en: '[PRE50]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the following screenshot, you can see that the status bar is hidden:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到状态栏已被隐藏：
- en: '![More display functions](img/9343OT_02_04.jpg)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/9343OT_02_04.jpg)'
- en: '`display.DefaultStatusBar`: To show the default status bar, you can use the
    following line at the beginning of your code:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.DefaultStatusBar`：若要显示默认状态栏，你可以在代码开始处使用以下这行代码：'
- en: '[PRE51]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The code will display the default status bar, as shown in the following screenshot:'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码将显示默认状态栏，如下截图所示：
- en: '![More display functions](img/9343OT_02_05.jpg)'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/9343OT_02_05.jpg)'
- en: '`display.TranslucentStatusBar`: To show the translucent status bar, you can
    use the following line at the beginning of your code:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.TranslucentStatusBar`：若要显示半透明状态栏，你可以在代码开始处使用以下这行代码：'
- en: '[PRE52]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The translucent status bar will look like the one shown in the following screenshot:'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 半透明状态栏将如下截图所示：
- en: '![More display functions](img/9343OT_02_06.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/9343OT_02_06.jpg)'
- en: '`display.DarkStatusBar`: To show the dark status bar, you can use the following
    line at the beginning of your code:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.DarkStatusBar`：若要显示深色状态栏，你可以在代码开始处使用以下这行代码：'
- en: '[PRE53]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following screenshot is of the dark status bar:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图是深色状态栏：
- en: '![More display functions](img/9343OT_02_07.jpg)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多显示功能](img/9343OT_02_07.jpg)'
- en: Content size properties
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容大小属性
- en: 'When you want to obtain the display information on your device, you can use
    the content size properties to return the values. These properties are as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要获取设备上的显示信息时，可以使用内容大小属性来返回值。这些属性如下：
- en: '`display.contentWidth`: This returns the original width of the content in pixels.
    This will default to the screen width.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.contentWidth`：这会返回内容原始宽度的像素值。默认情况下，这将是屏幕宽度。'
- en: '`display.contentHeight`: This returns the original height of the content in
    pixels. This will default to the screen height.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.contentHeight`：这会返回内容原始高度的像素值。默认情况下，这将是屏幕高度。'
- en: '`display.viewableContentWidth`: This is a read-only property that contains
    the width of the viewable screen area in pixels, within the coordinate system
    of the original content. Accessing this property will display how the content
    is viewed, whether you''re in the portrait or landscape mode. Here is an example:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.viewableContentWidth`：这是一个只读属性，包含视图屏幕区域的宽度（以像素为单位），在原始内容的坐标系内。访问这个属性将显示内容是如何被查看的，无论你是在纵向还是横向模式。以下是一个示例：'
- en: '[PRE54]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`display.viewableContentHeight`: This is a read-only property that contains
    the height of the viewable screen area in pixels, within the coordinate system
    of the original content. Accessing this property will display how the content
    is viewed, whether you''re in the portrait or landscape mode. Here is an example:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.viewableContentHeight`：这是一个只读属性，包含视图屏幕区域的高度（以像素为单位），在原始内容的坐标系内。访问这个属性将显示内容是如何被查看的，无论你是在纵向还是横向模式。以下是一个示例：'
- en: '[PRE55]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`display.statusBarHeight`: This is a read-only property that represents the
    height of the status bar in pixels (only valid on iOS devices). Here is an example:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.statusBarHeight`：这是一个只读属性，表示状态栏的高度（以像素为单位，仅在iOS设备上有效）。以下是一个示例：'
- en: '[PRE56]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Optimize your workflow
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的工作流程
- en: So far, we have touched on the vital basics of programming in Lua and the terminology
    used in Corona SDK. Once you start developing interactive applications to sell
    in the App Store or Android market, you need to be aware of your design choices
    and how they affect the performance of your application. This means taking into
    consideration how much memory your mobile device is using to process the application.
    Here are some things to look for if you're just starting out with Corona SDK.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经接触了Lua编程中的一些基本要点以及Corona SDK中使用的术语。一旦你开始开发交互式应用程序，准备在App Store或Android市场上销售，你需要注意你的设计选择以及它们如何影响应用程序的性能。这意味着要考虑你的移动设备在处理应用程序时使用的内存量。以下是一些如果你刚开始接触Corona
    SDK需要注意的事项。
- en: Use memory efficiently
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效使用内存
- en: In some of our earlier examples, we used global variables in our code. Cases
    like those are an exception since the examples did not contain a high volume of
    functions, loops to call out to, or display objects. Once you start building a
    game that is heavily involved with function calls and numerous display objects,
    the local variables will increase performance within your application and be placed
    on the stack so that Lua can interface them faster.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们早期的例子中，有时在代码中使用了全局变量。像这样的情况是个例外，因为示例没有包含大量的函数、循环调用或显示对象。一旦你开始构建一个与函数调用和众多显示对象高度相关的游戏，局部变量将提高应用程序的性能，并放置在栈上，以便Lua可以更快地接口它们。
- en: 'The following code will cause memory leaks:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将导致内存泄漏：
- en: '[PRE57]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding code removes `myImage` from the display hierarchy once it is touched.
    The only problem is that the memory used by `myImage` leaks because the `myImage`
    variable still refers to it. Since `myImage` is a global variable, the display
    object it references will not be freed even though `myImage` does not display
    on the screen.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在`myImage`被触摸后将其从显示层次结构中移除。唯一的问题是，由于`myImage`变量仍然引用它，`myImage`使用的内存会泄漏。由于`myImage`是一个全局变量，它引用的显示对象即使不在屏幕上显示也不会被释放。
- en: 'Unlike global variables, localizing variables helps speed up the look-up process
    for your display object. It also only exists within the block or chunk of code
    that it''s defined in. Using a local variable in the following code will remove
    the object completely and free memory:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局变量不同，局部化变量可以帮助加快显示对象的查找过程。它也只存在于定义它的代码块或片段中。在以下代码中使用局部变量将完全移除对象并释放内存：
- en: '[PRE58]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Optimize your display images
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的显示图像
- en: It's important to optimize your image file size as much as you can. Using full-screen
    images can impact the performance of your application. They require more time
    to load on a device and consume a lot of texture memory. When a lot of memory
    is consumed in an application, in most cases it'll be forced to quit.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 优化你的图像文件大小非常重要。使用全屏图像可能会影响应用程序的性能。它们需要更长的时间在设备上加载，并且消耗大量的纹理内存。当应用程序消耗大量内存时，在大多数情况下它会被迫退出。
- en: 'The iOS devices vary in the size of their available memory, depending on which
    one you have out of the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备在可用内存大小上有所不同，具体取决于以下设备中的哪一个：
- en: iPhone 3GS, iPad, and iTouch 3G/4G of 256 MB RAM
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 3GS、iPad 和拥有256 MB RAM的iTouch 3G/4G
- en: iPhone 4/4S, iPad 2, iPad Mini, and iTouch 5G of 512 MB RAM
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 4/4S、iPad 2、iPad Mini 和拥有512 MB RAM的iTouch 5G
- en: iPhone 5/5S/6, 6 Plus, iPad 3G, and iPad 4G of 1 GB RAM
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, texture memory on the iPhone 3GS should be kept under 25 MB before
    performance issues start occurring by slowing down your app or even forcing it
    to quit. An iPad 2 would have no problem going farther down that boundary since
    it has more memory available.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [http://docs.coronalabs.com/api/event/memoryWarning/index.html](http://docs.coronalabs.com/api/event/memoryWarning/index.html)
    to apply memory warnings for iOS devices.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: For Android devices, there is around a 24 MB memory limit. So, it's important
    to be aware of how many display objects you have in your scene and how to manage
    them when they are not needed in your app any more.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases when you no longer need an image to be displayed on screen, use the
    following code:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Alternatively, you can also use this line of code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you want to remove an image from the scene completely throughout the lifetime
    of your app, include the following line after your `image.parent:remove( image
    )` or `image:removeSelf()` code:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Keeping memory usage low within your application will prevent crashes and improve
    performance. For more information on optimization, go to [http://developer.coronalabs.com/content/performance-and-optimization](http://developer.coronalabs.com/content/performance-and-optimization).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – basics of Lua
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Which of the following are values?
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: nil
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strings
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which relational operator is false?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '`print(0 == 0)`'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print(3 >= 2)`'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print(2 ~= 2)`'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print(0 ~= 2)`'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What is the correct way to scale an object in the *x* direction?
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '`object.scaleX`'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object.xscale`'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object.Xscale`'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object.xScale`'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed parts of Lua programming that will send you on your way
    to start creating your own apps in Corona. As you continue working with Lua, you'll
    start understanding the terminology better. Eventually, you'll find new programming
    solutions that will benefit your development process.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Some skills you learned so far include the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Creating variables and assigning values to them
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing expressions using operators
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Corona terminal to output or print results
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tables to structure lists, arrays, sets, and so on
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding display objects in the simulator
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your application build to work on different mobile devices
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing dynamic resolution images
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating functions to run a block of code
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section was definitely a lot to take in. There is still a lot of information
    on Lua that we didn't get to touch base on, but you have learned enough to get
    you started. For more information on programming in Lua, you can refer to [http://www.lua.org/pil/index.html](http://www.lua.org/pil/index.html)
    or the resources section on the Corona website at [http://www.coronalabs.com/resources/](http://www.coronalabs.com/resources/).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start making our very first game called Breakout!
    You will get some hands-on experience creating a game framework in Corona and
    applying all the necessary assets to develop a mobile game. You'll be surprised
    how fast and simple it is to create one.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始制作我们的第一个游戏——打砖块！你将亲身体验在 Corona 中创建游戏框架，并应用所有必要的资源来开发一款移动游戏。你会惊讶地发现创建一个游戏竟然如此迅速和简单。
