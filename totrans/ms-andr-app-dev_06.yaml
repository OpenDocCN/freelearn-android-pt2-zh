- en: Chapter 6. CardView and Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first part of this chapter, we will improve our app significantly from
    a UI perspective and make it look professional by starting with a new widget:
    **CardView**. We will learn how to use design time attributes, which will improve
    our designing and development speed, and we will use a third party library to
    include custom fonts in an easy way in our entire app.'
  prefs: []
  type: TYPE_NORMAL
- en: The second part will be focused on the design support library, adding material
    design concepts to our app, improving the tabs, and adding a parallax effect to
    the job offer view. During this, we will clarify what a toolbar, action bar, and
    app bar is, and how to implement up navigation from the app bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'CardView and UI tips:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CardView
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Design time layout attributes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom fonts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Design support library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TabLayout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Toolbar, action bar, and app bar
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CoordinatorLayout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Up navigation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CardView and UI design tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, our application displays the job offers in a row with two text
    views; it displays the information needed and we can say that the app is fine
    as it is and it serves its purpose. However, we can still make a useful app and
    have a professional, good-looking interface at the same time, allowing us to be
    original and different from the competition. For instance, to show job offers,
    we can simulate a job board with adverts pinned on it. For this, we can use the
    CardView widget, which will give it depth and the appearance of a paper card.
    We will change the font of our app. A simple change such as this makes a big difference;
    when we change the default font to a custom font, the app from the users' eyes
    is a customized one, where the developer has taken care of the smallest details.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CardView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CardView was released with Android 5.0\. It is a view with rounded corners
    and an elevation with shadows, thus providing a depth feel and simulating a card.
    Combining this with a recycler view, we get a great-looking list of items, with
    a behavior and look consistent with many apps. The following image is an example
    of a list with CardView and custom fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing CardView](img/4887_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While working with CardView, keep in mind that the rounded corners are implemented
    differently depending on the Android version. Padding is added to avoid clipping
    the child views in versions prior to Android 5.0, as also to achieve the shadow
    effect. In versions later than Android 5.0, shadows are displayed based on the
    property elevation from CardView, and any child intersecting with the rounded
    corners is clipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using CardView, we need to add it as a dependency from the project
    structure window or add the following line to the dependencies inside `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can modify our `row_job_offer.xml` file with a base view as CardView with
    the content inside. This CardView will have some elevation and rounded corners.
    To set these attributes, we need to import CardView''s own attributes by adding
    the following schema to the XML:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will create the new layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We found a texture of a corkboard set it as a background, and on every card,
    we added a pin with an ImageView object at the top. The following is the achieved
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing CardView](img/4887_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The app looks much better than before; now, it's really a job board. By displaying
    the same information—the same two `TextView` with the title and job description—and
    simply changing the appearance, it evolved from a demo app to an app that could
    perfectly be launched in the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: We can continue improving this by changing the font, but before this, we will
    introduce the design time layout attributes, which will make the design of a view
    easier and quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Design-time layout attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with design-time attributes, I always remember a funny story that
    took place in one of my first jobs. I had to display a list of contacts, so when
    I created the view of the contact, I used dummy data, which is used to assign
    some text while you create the view so that you can see the size, color, and general
    look in the design view.
  prefs: []
  type: TYPE_NORMAL
- en: The contact that I created was named *Paco el churrero*, or Frank the churros
    maker. Paco is a synonym for Francisco, and a churro—if you don't know—is a fried
    dough pastry. Anyway, this dummy data was changed to a proper contact name, and
    when the contact list was shown, these contacts were retrieved from a server.
    I can't remember whether I was in a hurry to release the app, I forgot to do it,
    or I simply missed it, but the app went live that way. I started to work on another
    component, and all was fine until one day, when there was a problem on the server
    side, and the server was sending empty contacts. The app was unable to override
    the dummy data with the contact name, and Paco el churrero was shown as a contact!
    Hopefully, the server was fixed before any user noticed.
  prefs: []
  type: TYPE_NORMAL
- en: After this, I created the view with dummy data, and once I was happy with the
    view, I removed the dummy data. However, with this approach, when I was asked
    for a UI change, I had to add the dummy data again.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Android Studio 0.2.11, the design-time layout attributes
    were born. These allow us to display text or any attribute in the design view
    that won't be there when you run the app; this data is only visible in the design
    view.
  prefs: []
  type: TYPE_NORMAL
- en: To use these, we need to add the namespace tools to our layout. The namespace
    is always defined in the root element of the view; you can find the line, `informalexample">`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, we will add dummy text to the job offer and job description `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have problems rendering the design view, change the Android version
    or the theme, as in the following image. If the problem persists, ensure that
    you have the latest version of Android Studio and the latest Android API downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design-time layout attributes](img/4887_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the view is rendered, we can see the job offer with the title and description
    from the design-time attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Design-time layout attributes](img/4887_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use any attribute, text color, background color, and even image source,
    which is really useful when you create a view which contains an image that will
    be downloaded from the internet when the app is running, but you need a preview
    image to see how the view looks while creating it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom fonts in Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with customs fonts on Android, there is an amazing open source
    library—*Calligraphy* by Chris Jenkins—that allows us to set a default font for
    our whole app. This means that every widget with text, a Button, TextView, and
    EditText will show this font by default and we don't have to set the font individually
    for every single item in our app. Let's take a look at this in more detail and
    consider a few arguments in favor of Calligraphy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to apply a custom font, the first thing that we need to do is to
    place that font in the `assets` folder of our app. If we don''t have this folder,
    we need to create it inside the `main` method, at the same level as `java` and
    `src`. Create a second folder, `fonts`, inside `assets` and place the font there.
    In our example, we will use the *Roboto* font; it can be obtained from Google
    fonts at [https://www.google.com/fonts#UsePlace:use/Collection:Roboto](https://www.google.com/fonts#UsePlace:use/Collection:Roboto).
    When the font is downloaded, the app structure should look similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with custom fonts in Android](img/4887_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the font is in its place, we need to create a `Typeface` object from this
    font and set it to `myTextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we now wanted to apply the same font to all the components in our app, such
    as tabs, the title, and job offer cards, we would have to repeat the same code
    in different places around our app. Apart from this, we will also have performance
    issues. Creating a font from an asset requires access to the file; it is an expensive
    operation. If we changed the typeface for the job title and the job description
    inside the adapter, the view of our app wouldn't be fluent while scrolling anymore.
    This brings in extra considerations; for instance, we would have to load the typeface
    once in a static class and use it along with the app. Calligraphy handles all
    of this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good reason to use calligraphy is that it allows us to set the font
    in the XML, so we can have different fonts in the same view and there is no need
    to set the typeface programmatically. We just need to add the `fontPath` attribute
    to the widget and optionally the `ignore` attribute to avoid warnings of Android
    Studio not detecting `fontPath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have explained the advantages of calligraphy, we can use it in
    our app. Add the following line to the dependencies in `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a default font, add the following code to `Oncreate()` inside `MAApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following to any activity where we want to display the default font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, we can find a handwriting font that we like and set it to the card''s
    title and description, which would look similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with custom fonts in Android](img/4887_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The design support library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design support library introduces material design components in an official
    way and is compatible with all the versions of Android starting with Android 2.1\.
    Material design is a new design language introduced with Android Lollipop. Before
    this library was released, we watched videos and considered examples of apps using
    these components, but there was no official way to use it. This established a
    baseline for the apps to follow; therefore, to master Android, we need to master
    material design. You can compile it using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This library includes a visual component as the input text with floating text,
    floating action buttons, **TabLayout…**, and so on. However, material design is
    not only about visual components; it's about movement and transitions between
    its elements, and for this reason, **CoordinatorLayout** has been introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing TabLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TabLayout` design library allows us to have fixed or scrollable tabs with
    text, icons, or a customized view. As you would remember from the first instance
    of this in the book, customizing tabs wasn't very easy to do, and to change from
    scrolling to fixed tabs, we needed different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to change the color and design of the tabs to be fixed; what we
    have to do first is go to `activity_main.xml` and add `TabLayout`, removing the
    previous `PagerTabStrip` tab. Our view will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have this, we need to add tabs to the `Layout` tab. There are two ways
    to do this; one is to create tabs and add them manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way, which is how we will implement the tabs, is to set the view
    pager to `TabLayout`. Our `MainActivity.java` class should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t specify any color, `TabLayout` uses the default color from the
    theme, and the position of the tabs is fixed. Our new tab bar will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing TabLayout](img/4887_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Toolbar, action bar, and app bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before proceeding to add motion and animations to our app, we need to clarify
    the concepts of toolbar, action bar, app bar, and `AppBarLayout` as these may
    cause a bit of confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The action and app bar are the same component; "app bar" is just a new name
    that the action bar has acquired in material design. This is the opaque bar fixed
    at the top of our activity that usually shows the title of the app, navigation
    options, and displays different actions. The icon will or won''t be displayed
    depending on the theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Toolbar, action bar, and app bar](img/4887_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since Android 3.0, the Holo theme or any of its descendants is used by default,
    and these show the action bar.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next concept—toolbar. Introduced in API 21, Android Lollipop,
    it is a generalization of the action bar that doesn't need to be fixed at the
    top of the activity. We can specify whether a toolbar is acting as the activity
    action bar with the `setActionBar()` method. This means that a toolbar will or
    won't act as an action bar depending on what we want.
  prefs: []
  type: TYPE_NORMAL
- en: If we create a toolbar and set it as an action bar, we must use a theme with
    the `.NoActionBar` option to avoid having a duplicated action bar with the one
    that comes by default in a theme and the toolbar that we just converted into the
    action bar.
  prefs: []
  type: TYPE_NORMAL
- en: A new element called `AppBarLayout` has been introduced in the design support
    library. It is `LinearLayout`, intended to contain the toolbar to display animations
    based on scrolling events. We can specify the behavior while scrolling in the
    children with the `app:layout_scrollFlag. AppBarLayout` attribute. It is intended
    to be contained in `CoordinatorLayout`, and the component is introduced in the
    design support library as well, which we will describe in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding motion with CoordinatorLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CoordinatorLayout` allows us to add motion to our app, connecting touch
    events and gestures with views. We can coordinate a scroll movement with the collapsing
    animation of a view, for instance. These gestures or touch events are handled
    with the `Coordinator.Behaviour` class, and `AppBarLayout` already has this private
    class. If we want to use this motion with a custom view, we will have to create
    this behavior ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `CoordinatorLayout` can be implemented in the top level of our app, so we
    can combine this with the application bar or any elements inside our activity
    or fragment. It also can be implemented as a container to interact with its child
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our app, we are going to show a full view of a job offer when
    we click on a card. This will be displayed in a new activity. This activity will
    contain a toolbar showing the title of the job offer and logo of the company.
    If the description is long, we will need to scroll down to read it; at this moment,
    we want to collapse the logo at the top as it is not relevant anymore. In the
    same way, while scrolling back up, we want it to expand again. To control the
    collapsing of the toolbar, we will need `CollapsingToolbarLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: The description will be contained in `NestedScrollView`, which is a scroll view
    from the Android v4 support library. The reason for using `NestedScrollView` is
    that this class can propagate the scroll events to the toolbar, while `ScrollView`
    can't. Ensure that `compile 'com.android.support:support-v4:22.2.0'` is up to
    date.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to download images in the next chapter, so for now, we can just
    place an image from the `drawable` folder to implement the `CoordinatorLayout`
    functionality. In the next chapter, we will load the corresponding image for every
    company offering a job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our offer detail view, `activity_offer_detail.xml`, will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `CollapsingToolbar` layout reacts to the scroll flag and
    tells its children how to react. The toolbar will be pinned at the top, always
    staying visible, `app:layout_collapseMode="pin"`. However, the logo disappears
    with a parallax effect, `app:layout_collapseMode="parallax"`. Don't forget to
    add to the `NestedScrollview` attribute, `app:layout_behavior="@string/appbar_scrolling_view_behavior"`,
    and clean the project to generate this string resource internally. If you have
    problems, you can set the string directly, `"android.support.design.widget.AppBarLayout$ScrollingViewBehavior"`,
    and this will help you identify the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click on a job offer, we need to navigate to `OfferDetailActivity`,
    and we need to send the information of the offer. As you probably know from the
    beginner level, to send information between activities, we use intents. In these
    intents, we can put data or serialized objects. To be able to send an object of
    the `JobOffer` type, we have to create a `JobOffer` class that implements `Serializable`.
    Once we do this, we can detect the click on the element in `JobOffersAdapter`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we start the activity, we need to retrieve the title and set it to the
    toolbar. Add a long text to the `TextView` description inside `NestedScrollView`
    to test with dummy data first. We want to be able to scroll to test the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, ensure that your `styles.xml` file in the folder values uses a theme
    with no action bar by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to test the behavior. Launch the app and scroll down. Take
    a look at how the image collapses and the toolbar is pinned at the top. It will
    look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding motion with CoordinatorLayout](img/4887_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are missing an attribute to achieve a nice effect in the animation. Just
    collapsing the image doesn't collapse it enough; we need to make the image disappear
    in a smooth way, replaced by the background color of the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `contentScrim` attribute to `CollapsingToolbarLayout`, and this will
    fade in the image as it collapses using the primary color of the theme, which
    is the same as the one used by the toolbar at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this attribute, the app looks better when collapsed and expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding motion with CoordinatorLayout](img/4887_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We just need to style the app a bit more by changing colors and adding padding
    to the image; we can change the colors of the theme in `styles.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Resize `AppBarLayout` to `190dp` and add `50dp paddingLeft` and `paddingRight`
    to ImageView to achieve the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding motion with CoordinatorLayout](img/4887_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Back navigation and up navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways of navigating to the previous screen. The one called back
    navigation is the navigation performed with the back button, which can be a hardware
    or software button depending on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Up navigation** is a navigation method introduced with the action bar
    in Android 3.0; here, we can go back to the previous screen using an arrow pointing
    left, which is displayed in the action bar, as shown in the image to the right
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back navigation and up navigation](img/4887_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On some occasions we need to override the functionality of the back navigation.
    For instance, if we have a custom `WebView` and we navigate through a browser,
    when we click on back, the back button will cause us to leave the activity by
    default; however, what we want is to go back in the history of the browser''s
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from this, the back navigation is implemented by default, unlike the
    Up navigation. To implement the Up navigation, we need an action bar (or a toolbar
    acting as an action bar), and we need to activate this navigation with the `setDisplayHomeAsUpEnabled(true)`
    method. Inside `onCreate` in our activity, we will add the following lines to
    set our toolbar as an action bar and to activate the Up navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the back arrow at the top of our activity, as shown in the
    following screenshot. But at the moment, we won''t have any functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back navigation and up navigation](img/4887_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this is activated, we need to capture the click in the back arrow of the
    action bar. This will be detected as an action selection in the menu with the
    `android.R.id.home` ID; we just need to add the following code to our activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has drastically changed in this chapter; we changed the job
    offer list completely and it now looks similar to a nice list of handwritten paper
    cards pinned onto a corkboard. At the same time, you learned concepts from material
    design and how to work with the application bar and the toolbar. There are more
    widgets in the design support library, such as `InputText` or `FloatingButton`,
    that are very easy to implement. It is as easy as adding a widget to a view, which
    is why we focused on the more difficult components such as `CoordinatorLayout`
    or `CollapsingToolbarLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to download the logo of the company, advertise
    the job directly from a URL, talk about memory management, and take a look at
    how to make sure we don't have memory leaks in our app.
  prefs: []
  type: TYPE_NORMAL
