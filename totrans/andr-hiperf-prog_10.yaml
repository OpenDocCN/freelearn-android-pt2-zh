- en: Chapter 10. Performance Tips
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 性能提示
- en: This chapter is about techniques and hints and tips about topics not covered
    in the previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于技术、提示和技巧，涉及前几章未涵盖的主题。
- en: 'Therefore, we want to define here best practices for image handling: images
    are widely used in many applications in the store. For this, we want to know how
    to manage images in an Android application to improve overall performance. For
    this topic, concepts from various previous chapters are needed.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望在这里定义图像处理的最佳实践：图像在商店中的许多应用程序中被广泛使用。为此，我们希望了解如何在Android应用程序中管理图像，以提高整体性能。对于这个主题，需要来自之前各章的概念。
- en: Beyond bitmap management, we will go through alternatives to largely used, but
    not performant, serialization formats such as XML and JSON in order to find a
    better way to speed up client/server communications and limit encoding/decoding
    time and resource consumption.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了位图管理，我们还将探讨广泛使用但性能不佳的序列化格式（如XML和JSON）的替代方案，以找到加快客户端/服务器通信并限制编码/解码时间和资源消耗的更好方法。
- en: In conclusion, the last part of the chapter will discuss a couple of measures
    to improve the application before the building process. These include the reduction
    of resources and how to clean the APK so as to have a smaller APK file to distribute
    through the store in order to be compliant with store limitations and users' expectations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章的最后一部分将讨论在构建过程之前改进应用程序的一些措施。这些措施包括减少资源以及如何清理APK，以便拥有一个较小的APK文件通过商店分发，以满足商店限制和用户的期望。
- en: Bitmaps
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位图
- en: 'One of the biggest challenges with our application is to handle images in an
    efficient way because there are a lot of different perspectives that impact the
    resulting application. This is a particular topic that covers almost everything
    we discussed in previous chapters:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序面临的最大挑战之一是以高效的方式处理图像，因为有很多不同的视角会影响最终的应用程序。这是一个涵盖几乎所有前述章节内容的特殊主题：
- en: Bitmaps need to be in a layout to be displayed correctly. Hence, what we discussed
    in [Chapter 2](ch02.html "Chapter 2. Efficient Debugging"), *Efficient Debugging*,
    is particularly important here.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了正确显示位图，它们需要处于一个布局中。因此，我们在[第2章](ch02.html "第2章. 高效调试")，*高效调试*中讨论的内容在这里尤为重要。
- en: Bad bitmap handling can lead to memory issues due to leaks or because bitmaps
    are used badly as variables instead of being read when needed. Hence, [Chapter
    4](ch04.html "Chapter 4. Memory"), *Memory*, can be helpful to keep in mind key
    concepts while saving and reading large images.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不当的位图处理可能导致内存问题，由于泄漏或是因为位图被错误地作为变量使用，而不是在需要时读取。因此，记住[第4章](ch04.html "第4章. 内存")，*内存*中的关键概念，在保存和读取大图像时可能会有所帮助。
- en: Too many times, we try to process significant amounts of data coming from images
    on the main thread; we will use the topics discussed in [Chapter 5](ch05.html
    "Chapter 5. Multithreading"), *Multithreading*, to understand how to handle bitmaps
    efficiently with no impact on user experience.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们经常会尝试在主线程上处理来自图像的大量数据；我们将使用在[第5章](ch05.html "第5章. 多线程")，*多线程*中讨论的主题，来了解如何高效处理位图，同时不影响用户体验。
- en: Most of the time, images come from a remote resource. We will discuss how to
    retrieve images from a server and how to cache them for future reuse to limit
    networking requests and save battery, as examined in [Chapter 6](ch06.html "Chapter 6. Networking"),
    *Networking*.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数情况下，图像来自远程资源。我们将讨论如何从服务器检索图像，以及如何为将来重用缓存它们，以限制网络请求并节省电量，这在[第6章](ch06.html
    "第6章. 网络通信")，*网络通信*中有所探讨。
- en: Bitmaps are handled in many applications. We will discuss in more detail every
    aspect of the matter, trying to define what to do with them by using best practices
    introduced in the chapters mentioned previously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 位图在许多应用程序中被处理。我们将更详细地讨论这个问题的各个方面，尝试通过使用前述章节引入的最佳实践来定义如何处理它们。
- en: Loading
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载
- en: A displayed image is read as a whole, no matter what the screen resolution is
    or if it is hidden or invisible; its weight is the biggest in its memory. As we
    will see next, every pixel of the image keeps 32 bits of memory occupied by default.
    Hence, multiplying the resolution of the image by 32, we find the number of bits
    the image uses inside the memory. The main problem with this is, of course, the
    high probability of incurring an `OutOfMemoryException` due to the saturation
    of the memory available to the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论屏幕分辨率如何，或者图像是否隐藏或不可见，显示的图像总是被整体读取；其在内存中的权重是最大的。正如我们接下来将看到的，图像的每一个像素默认占用32位内存。因此，将图像的分辨率乘以32，我们可以得到图像在内存中使用的位数。这种做法的主要问题当然是由于应用程序可用内存饱和而导致的高概率出现`OutOfMemoryException`异常。
- en: 'Usually, we use images as they are, without considering performance problems
    that may occur. However, for example, if we are displaying **1920x1080** pixels
    in a **384x216** pixels placeholder, we are adding 8.2 MB into the memory, while
    332 KB is enough. See *Figure 1* to understand the overhead of the unscaled image
    compared with the required one:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们直接使用图像，而不考虑可能出现的性能问题。然而，例如，如果我们在一个**384x216**像素的占位符中显示**1920x1080**像素的图像，我们实际上向内存中添加了8.2
    MB，而实际上只需要332 KB。查看*图1*以了解未缩放图像与所需图像的开销比较：
- en: '![Loading](img/4666_10_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![加载](img/4666_10_01.jpg)'
- en: 'Figure 1: Example of overhead of a non-scaled image in a smaller placeholder'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：未缩放的图像在较小占位符中的开销示例
- en: 'Things get worse if we are dealing with lists or galleries or other widgets
    that show more images at a time. Moreover, Android suffers from high fragmentation
    for screen resolutions and memory availability. Hence, there is no way to evade
    the issue: bitmaps need to be pre-scaled when read. So, how can we pre-scale them
    efficiently? Let''s find out in the following paragraphs.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是列表、图库或其他一次显示更多图像的小部件，情况会更糟。此外，Android在屏幕分辨率和内存可用性方面存在高度碎片化。因此，无法回避这个问题：读取图像时需要预先缩放位图。那么，我们如何有效地预先缩放它们呢？让我们在以下段落中找到答案。
- en: 'The Bitmap class is not so helpful; the `Bitmap.createScaledBitmap()` method
    needs a `Bitmap` object as an input to be scaled. Hence, it forces us to read
    the whole image anyway before creating the new small image, with the evident problem
    of unnecessarily large memory allocation for the entire source image. However,
    there is a way to reduce the weight on the memory of the image while reading it.
    This is the aim of the `BitmapFactory` API. Once we know what the suitable resolution
    for our image to be scaled is, we can use the `BitmapFactory.Options` class to
    set the right parameters and scale the image efficiently from a memory perspective.
    Let''s look at the parameters we can use to reach the right result. The `BitmapFactory`
    class provides different methods to load an image depending on the source:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bitmap类并不那么有用；`Bitmap.createScaledBitmap()`方法需要一个`Bitmap`对象作为输入来进行缩放。因此，它迫使我们无论如何都要在创建新的小图像之前读取整个图像，这显然会导致为整个源图像分配不必要的过多内存。然而，有一种方法可以在读取图像时减少对图像内存的负担。这就是`BitmapFactory`
    API的目标。一旦我们知道适合我们图像缩放的适当分辨率，我们可以使用`BitmapFactory.Options`类来设置正确的参数，从而从内存的角度有效地缩放图像。让我们看看我们可以使用哪些参数来达到正确的结果。`BitmapFactory`类提供了根据不同来源加载图像的不同方法：
- en: '`decodeByteArray()`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeByteArray()`'
- en: '`decodeFile()`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeFile()`'
- en: '`decodeFileDescriptor()`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeFileDescriptor()`'
- en: '`decodeResource()`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeResource()`'
- en: '`decodeStream()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeStream()`'
- en: 'Every one of them is overloaded with the corresponding method, which accepts
    a `BitmapFactory.Options` object besides those needed. This way, we can use this
    class to define our scaling strategy for the image while it is read. If we are
    dealing with very big images, we can use a special API to decode small portions
    of an image: this is `BitmapRegionDecoder`. The `BitmapRegionDecoder.decodeRegion()`
    method accepts a `Rect` and a `BitmapFactory.Options` object as parameters to
    decode the `Rect` region of the image passed in the `BitmapRegionDecoder.newInstance()`
    method.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它们每一个都有相应的方法重载，除了需要的基本参数外，还接受一个`BitmapFactory.Options`对象。这样，我们就可以在读取图像时使用这个类来定义我们的缩放策略。如果我们处理的是非常大的图像，我们可以使用特殊的API来解码图像的小部分：这就是`BitmapRegionDecoder`。`BitmapRegionDecoder.decodeRegion()`方法接受一个`Rect`和一个`BitmapFactory.Options`对象作为参数，以解码在`BitmapRegionDecoder.newInstance()`方法中传递的图像的`Rect`区域。
- en: First of all, we need to know the resolution of the image. To find out, we want
    to get image dimensions without reading the whole source bitmap. This would contribute
    to needlessly increasing the memory allocation. The API provides a way to get
    the source image size by setting a particular property of the `BitmapFactory.Options`
    object called `BitmapFactory.Options.inJustDecodeBounds`. The `BitmapFactory.Options.inJustDecodeBounds`
    property is set to define whether the decoding method should return a `Bitmap`
    object. Hence, we can set it as `true` to disable bitmap processing while reading
    the image resolution, and then set it back to `false` to enable the full reading
    of the image and obtain the desired image. This ensures that no bitmap memory
    is needlessly allocated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道图像的分辨率。为了找出，我们希望在不读取整个源位图的情况下获取图像尺寸。这会导致不必要的内存分配增加。API提供了一种通过设置`BitmapFactory.Options`对象的一个特定属性`BitmapFactory.Options.inJustDecodeBounds`来获取源图像尺寸的方法。`BitmapFactory.Options.inJustDecodeBounds`属性用于定义解码方法是否应返回`Bitmap`对象。因此，我们可以将其设置为`true`以在读取图像分辨率时禁用位图处理，然后再将其设置为`false`以启用完全读取图像并获得所需的图像。这样可以确保不会无谓地分配位图内存。
- en: When we know what resolution we want for our image, we need to apply the new
    settings to the option before processing it. For this, `BitmapFactory.Options.inSampleSize`
    is what we need to use. It is an integer that specifies how many times to divide
    separately each of the dimensions of the image to reach the requested size. It
    is also forced to be a power of two. Hence, if we are setting a different value,
    it will be scaled down to the nearest power of two before the processing step.
    Then, if we set the `BitmapFactory.Options.inSampleSize` to `4`, the final width
    and height will be 1/4 of the original one. Hence, the resulting image will be
    made by 1/16 of the pixels that are in the source bitmap.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道我们想要的图像分辨率时，我们需要在处理之前将新设置应用到选项中。为此，我们需要使用`BitmapFactory.Options.inSampleSize`。这是一个整数，指定将图像的每个维度分别除以多少以到达请求的大小。它也被强制为2的幂。因此，如果我们设置不同的值，它将在处理步骤之前缩小到最接近的2的幂。然后，如果我们设置`BitmapFactory.Options.inSampleSize`为`4`，最终的宽度和高度将是原始尺寸的1/4。因此，生成的图像将由源位图的1/16的像素组成。
- en: 'Let''s see, in the following code snippet, how to apply such useful properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段，了解如何应用这些有用的属性：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Why is there such a strong limitation about the power of two for the sampling
    property? Because, this way, the processed image will be composed of, for example,
    just one pixel out of four in the source. Moreover, this is done pretty fast.
    The advantage is in the speed of computation, while the disadvantage is that we
    cannot scale the image precisely to the desired size.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么采样属性要如此严格地限制为2的幂？因为这样，处理后的图像将由源图像中的四像素取一像素组成。此外，这个过程非常快。优点是计算速度快，而缺点是我们不能精确地将图像缩放到期望的大小。
- en: 'There are other properties to scale the image using a different approach. Instead
    of the `BitmapFactory.Options.inJustDecodeBounds` property, we can use the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他属性以不同的方法来缩放图像。除了`BitmapFactory.Options.inJustDecodeBounds`属性之外，我们还可以使用以下属性：
- en: '`inScaled`: This enables the density check to scale the image based on the
    other values in this list.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inScaled`：这使基于此列表中的其他值启用密度检查来缩放图像。'
- en: '`inDensity`: This is the density to use for the bitmap. If it is different
    from the following `inTargetSize`, then the image will be processed to be scaled
    and reach the `inTargetDensity`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inDensity`：这是位图的密度。如果它与下面的`inTargetSize`不同，那么图像将被处理以缩放并达到`inTargetDensity`。'
- en: '`inTargetDensity`: This is the desired density for the resulting image if it
    is different from the `inDensity` property.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inTargetDensity`：这是如果与`inDensity`属性不同，所需结果的图像密度。'
- en: The scale ratio will be calculated using the formula *scale = inTargetDensity
    / inDensity*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放比例将使用公式*scale = inTargetDensity / inDensity*来计算。
- en: 'Then, we can use the ratio between the actual and desired dimensions in pixels
    of the image to calculate the scale values. Hence, the previous snippet of code
    becomes the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用图像实际和期望尺寸（以像素为单位）之间的比例来计算缩放值。因此，前面的代码片段变成了以下内容：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is using a different calculation to scale the image at a particular size.
    The precision has a cost in terms of speed. Therefore, this solution exchanges
    the speed of the previous one with the precision in creating an image with the
    desired resolution. Hence, as suggested by Google, the best results are reached
    by using a mix of both the previous solutions. The first step is to identify the
    most accurate power of two to use as `BitmapFactory.Options.inSampleSize` to speed
    up the gross scaling if needed. Then, the image is converted from this intermediate
    image to the accurate desired scaled one. If our source image is **1920x1080**
    pixels and we need the final one to be **320x180** pixels, there will be an intermediate
    image of, for example, **480x270** pixels, as shown in *Figure 2*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一种不同的计算方法来在特定尺寸下缩放图像。精度在速度方面是有代价的。因此，这个解决方案用前一个方案的速度与创建所需分辨率的图像的精度进行了交换。因此，正如谷歌建议的那样，通过结合两种前方案，可以得到最佳结果。第一步是确定最精确的2的幂作为`BitmapFactory.Options.inSampleSize`以加快粗略缩放（如果需要）。然后，将图像从这个中间图像转换为精确的所需缩放图像。如果我们的源图像是**1920x1080**像素，而我们需要最终图像是**320x180**像素，那么将会有一个例如**480x270**像素的中间图像，如图*图2*所示：
- en: '![Loading](img/4666_10_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![加载](img/4666_10_02.jpg)'
- en: 'Figure 2: Scaling steps'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：缩放步骤
- en: 'What has been discussed can be implemented with all of the properties introduced
    earlier, as in the following code example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才讨论的内容可以通过之前引入的所有属性来实现，如下面的代码示例所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This solution combines the speed of the first one and the precision of the second.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案结合了第一个方案的速度和第二个方案的精度。
- en: Processing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理
- en: The operations described in the previous section are unpredictable from a timing
    point of view, but they are certainly affecting the CPU. It does not matter what
    the image sizes are, or whether the operations are quick. All of operations must
    be executed in a worker thread, as discussed in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, in order not to block the user interface and degrade perceived
    application performance for lack of responsiveness.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节描述的操作从时间角度来看是不可预测的，但它们肯定会影响CPU。不管图像大小如何，或者操作是否快速，所有这些操作都必须在工作线程中执行，正如我们在[第5章](ch05.html
    "第5章.多线程")《多线程》中讨论的那样，以避免阻塞用户界面并降低因响应性不足而感知的应用程序性能。
- en: The main operation to be done with scaling is to set the bitmap to `ImageView`
    to create a layout. Hence, we need an `AsyncTask` subclass with a reference to
    a view. We discussed this combination of objects in [Chapter 4](ch04.html "Chapter 4. Memory"),
    *Memory* and we found that this leads to an activity leak. Hence, remember to
    use `WeakReference` to hold `ImageView` to be collected when `Activity` has been
    destroyed. Then, don't forget to verify that `ImageView` is still referenced in
    `WeakReference`, otherwise `NullPoionterException` will occur.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩放的主要操作是为`ImageView`设置位图以创建布局。因此，我们需要一个带有视图引用的`AsyncTask`子类。我们在[第4章](ch04.html
    "第4章.内存")《内存》中讨论了这种对象组合，我们发现这会导致活动泄露。因此，记得使用`WeakReference`来持有`ImageView`，以便在`Activity`被销毁时进行回收。然后，不要忘记验证`ImageView`是否仍然在`WeakReference`中被引用，否则会发生`NullPoionterException`。
- en: 'Such an `AsyncTask` subclass can be like the code in the following snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`AsyncTask`子类可以像下面代码片段中的代码一样：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Caching
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Let's talk about where these bitmaps are and how to handle them locally. Most
    of the time, bitmaps are stored in a remote resource, and this forces us to create
    the corresponding code to download them before displaying them on the screen.
    However, we do not want to download them again as many times as they are needed
    to be shown on the screen. Hence, we need a simple and fast way to store images
    and make them available on request.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这些位图存储在哪里以及如何本地处理它们。大多数时候，位图存储在远程资源中，这迫使我们创建相应的代码来下载它们，然后才能在屏幕上显示。然而，我们不想在屏幕上每次需要显示它们时都重新下载。因此，我们需要一种简单且快速的方式来存储图像，并在请求时使它们可用。
- en: However, we must be careful to make sure that at some point the images are deleted.
    Otherwise, the internal memory of the device will be saturated because, potentially,
    the images in an application are not limited. Because of this, we need a limited
    space to store the images. This space is called the **cache**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须小心，确保在某些时候删除图像。否则，设备的内部存储将被占满，因为应用程序中的图像可能是不受限制的。因此，我们需要一个有限的空间来存储图像。这个空间被称为**缓存**。
- en: 'Next, the question is: which is the right algorithm to remove images? The main
    algorithm used by Android is the LRU one. This uses a stack of objects to identify
    which ones have a higher priority, placing them on top and lower priority ones
    at the bottom. Then, when an object is used, it is moved up to gain a higher priority,
    and all of the others are shifted down. Hence, the priority, in this case, is
    the number of requests for a single object; the stack will then be a ranking of
    objects from the most used on top to the least used on the bottom, as shown in
    *Figure 3*, where the image in position 3 is used another time, and it moves to
    the top of the stack:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来问题是：哪种算法是删除图像的正确选择？Android使用的主体算法是LRU。它使用一个对象栈来确定哪些对象具有更高优先级，将它们放在顶部，低优先级的放在底部。然后，当一个对象被使用时，它会被移到顶部以获得更高的优先级，其他所有对象则向下移动。在这种情况下，优先级是单个对象的请求次数；栈将是一个从最常用到最不常用的对象排名，如图*图3*所示，位置3的图像再次被使用，它移动到了栈的顶部：
- en: '![Caching](img/4666_10_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![缓存](img/4666_10_03.jpg)'
- en: 'Figure 3: Example of LRU stack'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：LRU栈的示例
- en: 'With this kind of reasoning, when a new object needs to be added to a full
    stack, the choice is pretty simple: it will take the place of the least used object
    because it has got the least chance of being requested again.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种推理，当一个新对象需要被添加到一个已满的栈时，选择很简单：它将取代最少使用的对象，因为它再次被请求的可能性最小。
- en: All of this logic is implemented and provided by Android in the `LRUCache` object.
    This implementation works in memory and not on disk, to provide a faster and reliable
    cache ready to be queried. This means that any object at the bottom of the stack,
    when it's evicted because of a new addition, is eligible for garbage collection.
    Moreover, this class allows defining the keys and the value types to use because
    it uses generics. Because of this, it can be used for every kind of object we
    need and not only bitmaps. The `LRUCache` object is even thread-safe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些逻辑都由Android在`LRUCache`对象中实现并提供。这个实现是在内存中工作，而不是在磁盘上，以提供更快、更可靠的缓存，随时可供查询。这意味着栈底部的任何对象，在因新添加而逐出时，都有可能被垃圾收集。此外，这个类允许定义要使用的键和值类型，因为它使用了泛型。因此，它不仅可以用于位图，还可以用于我们需要的各种对象。`LRUCache`对象甚至是线程安全的。
- en: 'The things to do after choosing the keys and value types is to define the size
    of the cache. There are no rules for this, but keep in mind that too small a cache
    leads to too many changes inside the stack, making the use of the cache irrelevant,
    while too big a cache can lead to `OutOfMemoryErrors` during the use of our application.
    The right thing to do in this case is to provide to the cache a portion of the
    available memory of the application. In the following code, the `LRUCache` object
    is created using strings as keys and the available memory is divided by 8:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了键和值类型之后，需要做的是定义缓存的大小。这一步没有固定的规则，但需要记住，缓存太小会导致栈内变化过多，使得使用缓存变得没有意义；而缓存太大则可能导致在使用应用程序时出现`OutOfMemoryErrors`。在这种情况下，正确的做法是为缓存分配应用程序可用内存的一部分。在以下代码中，`LRUCache`对象是使用字符串作为键创建的，并且将可用内存除以8：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we need to define the size of a single entry in the cache. This can be
    done by overriding the `LRUCache.sizeOf()` method and returning the right number
    of bytes of a bitmap during instantiation in the following way:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义缓存中单个条目的大小。这可以通过重写`LRUCache.sizeOf()`方法，在实例化时返回位图正确的字节数量来实现：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can use this cache object when an image needs to be displayed in
    `ImageView`, as described in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当需要显示`ImageView`中的图像时，我们可以使用这个缓存对象，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As mentioned previously, this kind of cache resides in the heap memory; when
    the user changes the activity and then comes back, every item must be downloaded,
    scaled, and added to the cache again. Then, we want a cache type that can be persisted
    across multiple access attempts and rebooted. To do this, there is a helpful class
    from the official Android samples in the official repository, called `DiskLRUCache`.
    This is not thread-safe, and so we need a lock when we access it. Moreover, its
    initialization can be a long-running one, and we have to execute it inside a worker
    thread in order not to block the main thread. Let''s use an `AsyncTask` class
    to do so, as in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种类型的缓存位于堆内存中；当用户更改活动然后返回时，必须重新下载、缩放并将每个项目添加到缓存中。然后，我们想要一种可以在多次访问尝试和重启之间持久化的缓存类型。为此，官方存储库中有一个来自官方Android示例的有用类，名为`DiskLRUCache`。这不是线程安全的，因此我们在访问它时需要加锁。此外，它的初始化可能需要较长时间，我们必须在工作者线程中执行它，以避免阻塞主线程。下面我们使用`AsyncTask`类来完成这个任务：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By adding this class, we can use two levels of cache:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这个类，我们可以使用两个级别的缓存：
- en: '**Heap-level cache**: The faster but not persistent cache, as discussed earlier.
    Its aim is to be checked first when an image is needed.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆级缓存**：如前所述，速度快但不持久的缓存。当需要图像时，其目标是首先被检查。'
- en: '**Disk-level cache**: The slower but persistent cache, checked second if the
    other one does not contain the requested image.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘级缓存**：速度较慢但持久化的缓存，如果另一个缓存不包含请求的图像，则第二个检查它。'
- en: 'Hence, the logics behind an image request should be something like that shown
    in *Figure 4*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，图像请求背后的逻辑应该类似于*图4*所示：
- en: '![Caching](img/4666_10_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![缓存](img/4666_10_04.jpg)'
- en: 'Figure 4: Flow diagram for an image request using both cache levels'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：使用两级缓存的图像请求流程图
- en: 'When we want to put an image in the cache, we need to add it to both of them,
    as seen in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将图像放入缓存时，我们需要将它添加到两者中，如下面的代码段所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Displaying
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示
- en: 'As mentioned previously, when an image is displayed on the screen, it is described
    by a 32-bit pixel, with 8 bits for every color of the image, as shown in *Figure
    5*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当图像在屏幕上显示时，它由32位像素描述，每个颜色8位，如图*图5*所示：
- en: '![Displaying](img/4666_10_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![显示](img/4666_10_05.jpg)'
- en: 'Figure 5: Bitmap pixel compression'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：位图像素压缩
- en: Unfortunately, there is no way to use 24 bits without ignoring the transparency
    part; instead, when the image does not contain the alpha byte of the pixel, Android
    will add it anyway, converting a 24-bit image into a 32-bit one. Obviously, this
    has got many side effects in the everyday use of an application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有办法在不忽略透明度部分的情况下使用24位；相反，当图像不包含像素的alpha字节时，Android无论如何都会添加它，将24位图像转换为32位图像。显然，这在应用程序的日常使用中会有很多副作用。
- en: First of all, the amount of memory needed to store the bitmap in the heap is
    greater, leading to more garbage collection events because it is more difficult
    to allocate bigger contiguous memory portions than smaller ones. Moreover, it
    takes longer to allocate and collect such bigger memory blocks. Furthermore, there
    is no compression on allocated memory. The time to decode and display them will
    be longer, affecting both CPU and GPU. What's the solution to this?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，堆内存中存储位图所需的内存量更大，导致垃圾回收事件更多，因为分配较大的连续内存块比分配较小的内存块更困难。此外，分配和收集这些较大的内存块需要更长的时间。而且，分配的内存没有压缩。解码和显示它们的时间会更长，影响CPU和GPU。这个问题的解决方案是什么？
- en: 'Android provides four different pixel formats to be used while dealing with
    images. This means that every single pixel of an image can be described with less
    bits and therefore can be lighter in terms of memory, garbage collection, CPU,
    and GPU. This comes at a cost: the quality will not be the same. Hence, the use
    of this should be by design, because it cannot be correct for every image in our
    application. However, we could think of a way do it in a cleverer fashion; for
    example, we could choose different pixel formats depending on the device''s capabilities.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了四种不同的像素格式，用于处理图像时使用。这意味着图像的每一个像素可以用较少的位描述，因此在内存、垃圾回收、CPU和GPU方面可以更轻便。这需要付出代价：质量将不再相同。因此，这种使用应该是根据设计来决定的，因为它并不适用于我们应用程序中的每一张图像。然而，我们可以考虑一种更智能的方法，例如，我们可以根据设备的性能选择不同的像素格式。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are dealing with applications that handle images, it''s really important
    to check whether, depending on the requirements, it''s possible to use different
    pixel formats to reduce the impact of large memory blocks, which the bitmaps are,
    and improve performance from different points of view: memory, speed, and battery
    charge duration.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理处理图像的应用程序，非常重要的一点是要检查，根据需求，是否可以使用不同的像素格式来减少大内存块（即位图）的影响，并从不同的角度提高性能：内存、速度和电池充电持续时间。
- en: 'The pixel formats currently handled by the Android platform for `Bitmap` objects
    are the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓平台目前为`Bitmap`对象处理的像素格式如下：
- en: '`ARGB_8888`: This is the default discussed value, which uses 32 bits for pixels
    as all of the channels use 8 bits each.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARGB_8888`：这是默认讨论的值，它使用32位来表示像素，因为所有通道都使用8位。'
- en: '`ARGB_4444`: This maintains four channels, as the previous one does, but uses
    just 4 bits for each channel for a 16-bit pixel. Although it saves half the image
    memory, its poor quality on the screen led Google to deprecate this value, recommending
    the default one, despite its advantages in memory management.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARGB_4444`：这保留了四个通道，与前面的格式一样，但每个通道只使用4位，对于一个16位的像素。尽管它节省了一半的图像内存，但其屏幕显示的较差质量导致谷歌不推荐这个值，转而推荐默认值，尽管它在内存管理上有优势。'
- en: '`RGB_565`: This particular value keeps only the color channels, removing the
    alpha one. The red and blue channels are described using 5 bits, while the green
    channel is described using 6 bits. Every pixel uses 16 bits, as with the previous
    format, but ignoring the alpha transparency and improving color quality. Hence,
    this is good to use when dealing with images without transparency.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RGB_565`：这个特定的值只保留颜色通道，移除了alpha通道。红色和蓝色通道使用5位描述，绿色通道使用6位描述。每个像素使用16位，与之前的格式一样，但忽略alpha透明度，提高颜色质量。因此，在处理没有透明度的图像时使用这个格式是很好的选择。'
- en: '`ALPHA_8`: This is used to store just alpha transparency information with no
    color channel.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALPHA_8`：这仅用于存储alpha透明度信息，没有颜色通道。'
- en: 'However, how could we use them? This is also a decoding option. `BitmapFactory.Options.inPreferredConfig`
    is used to define the pixel format to use when an image is about to be decoded.
    So, let''s check the following snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何使用它们呢？这也是一个解码选项。`BitmapFactory.Options.inPreferredConfig`用于定义在图像即将被解码时要使用的像素格式。那么，让我们检查以下代码段：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is obviously expensive because it leads to more computation time and CPU
    usage. However, its cost is less than the whole bitmap in memory, and, if we are
    aware of reusing images, we can save not just time, but critical system resources.
    So, let's see how to reuse the image to further improve the memory usage of our
    application, as described in the following pages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是昂贵的，因为它导致了更多的计算时间和CPU使用。然而，其成本小于内存中的整个位图，如果我们意识到重用图像，不仅可以节省时间，还能节约关键的系统资源。那么，让我们看看如何重用图像以进一步改善我们应用程序的内存使用，如下面几页所述。
- en: Managing memory
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理内存
- en: What has been discussed until now is related to memory management from both
    a heap and disk point of view. However, there is a higher level of abstraction
    we can use to improve heap memory management while dealing with bitmaps. In [Chapter
    4](ch04.html "Chapter 4. Memory"), *Memory*, we introduced a particular design
    pattern to avoid what we called memory churn; this is the object pool pattern.
    With this pattern, a memory allocation can be reused to avoid garbage collection
    when an object is no longer referenced.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止我们所讨论的内容与从堆和磁盘角度进行内存管理有关。然而，在处理位图时，我们可以使用更高级别的抽象来改进堆内存管理。在[第4章](ch04.html
    "第4章. 内存")《内存》中，我们介绍了一个特别的设计模式，以避免我们所说的内存翻滚；这就是对象池模式。使用这种模式，可以在对象不再被引用时重用内存分配，以避免垃圾回收。
- en: When lots of bitmap objects are about to be handled, as in a list or grid, many
    new instantiations and deletions are executed with many garbage collection events
    occurring. This degrades the overall memory performance of the application as
    we know collection events are blocking any other thread, in addition to the large
    memory size of these kinds of objects. Hence, if we could use the object pool
    pattern for bitmaps, we would limit the garbage collector operations without compromising
    and indeed speeding up, the caching technique we discussed previously.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要处理大量位图对象时，如在列表或网格中，会有许多新的实例化和删除操作，伴随着多次垃圾回收事件的发生。这会降低应用程序的整体内存性能，因为众所周知，回收事件会阻塞其他任何线程，而且这些对象的内存占用也很大。因此，如果我们能为位图使用对象池模式，就可以限制垃圾收集器的操作，而不会影响我们之前讨论的缓存技术，实际上还能加快其速度。
- en: 'Practically, we want to reuse the already allocated memory to process new images
    to be displayed. As reported in *Figure 6*, if four images are displayed on the
    screen, the memory allocation should remain the same after a scroll by the user:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们希望重用已分配的内存来处理要显示的新图像。如*图6*所示，如果用户滚动后屏幕上显示四个图像，内存分配应该保持不变。
- en: '![Managing memory](img/4666_10_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![内存管理](img/4666_10_06.jpg)'
- en: 'Figure 6: Heap memory management with the object pool'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：使用对象池的堆内存管理
- en: To implement such a useful mechanism, we need to introduce a particular `BitmapFactory.Options`
    property called `BitmapFactory.Options.inBitmap`. If we use this property, we
    have to provide an existing `Bitmap` object to let the decoder reuse its memory
    allocations. This way, the previous object is not destroyed, and the new one is
    not created, and there is no need for garbage collection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样一个有用的机制，我们需要引入一个特定的`BitmapFactory.Options`属性，名为`BitmapFactory.Options.inBitmap`。如果我们使用这个属性，就必须提供一个现有的`Bitmap`对象，让解码器重用其内存分配。这样，原来的对象不会被销毁，新对象也不会被创建，也就无需进行垃圾回收。
- en: 'However, this useful property has its limitations, as reported in the official
    documentation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个有用的属性也有其局限性，正如官方文档所述：
- en: Until Android Jelly Bean (API Level 18), the provided object and the new one
    must have the exact same size. Starting from Android KitKat (API Level 19), the
    provided bitmap can be larger or equal to the new one, but not smaller.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Jelly Bean（API级别18）之前，提供的对象和新的对象必须有完全相同的尺寸。从Android KitKat（API级别19）开始，提供的位图可以大于或等于新的位图，但不能小于。
- en: The first point implies that images with different pixel formats should not
    be used for this kind of operation.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一点意味着具有不同像素格式的图像不适用于此类操作。
- en: 'Keeping this in mind, let''s see a quick overview of some code to create such
    a logic. First of all, let''s create the controls to meet these requirements:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点，让我们快速了解一下创建此类逻辑的代码。首先，让我们创建满足这些要求的控件：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, let''s write the code to retrieve, if there is one, the reusable `Bitmap`
    object from the pool:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写代码来从池中获取（如果有的话）可重用的`Bitmap`对象：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let''s create a method to add these `BitmapFactory.Options` before
    the decoding process, to use a reusable object instead of creating a new one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个方法，在解码过程之前添加这些`BitmapFactory.Options`，以使用可重用对象而不是创建新对象：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Don''t forget to create a set of reusable bitmaps to search in when you need
    to. So, let''s define a pool of bitmaps as a set of `SoftReference` objects to
    store our images. Our `BitmapCache` class should look like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要的时候，别忘了创建一组可重用的位图来搜索。因此，让我们定义一个位图池，作为一组`SoftReference`对象来存储我们的图像。我们的`BitmapCache`类应该如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Image optimization
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像优化
- en: In the previous pages of this chapter, we discussed how to handle images when
    they are ready to be loaded and displayed. We want now to discuss the way they
    get into the device and how to improve this process. It is now clear that images
    are big memory boulders, and instead of improving the user experience of our application,
    they can break it up if we do not take care of handling them properly. So, we
    can design the best framework to download images from a remote server, but if
    they are too large, or if their compression is not high enough, our application
    will be perceived as slow and expensive. Images need time and bandwidth to be
    downloaded. Hence, our aim is to find the right way to reduce their size as much
    as possible, without compromising their quality.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几页中，我们讨论了当图片准备好加载和显示时如何处理它们。现在我们想要探讨的是图片如何传入设备以及如何改进这一过程。现在很清楚，图片是占用内存的大块头，如果我们不妥善处理它们，它们可能会破坏我们应用的用户体验，而不是提升它。因此，我们可以设计出最佳的框架从远程服务器下载图片，但如果它们体积过大，或者压缩程度不够高，我们的应用仍然会被认为运行缓慢且耗资源。图片需要时间和带宽来下载。因此，我们的目标是尽可能减少它们的体积，同时不损害其质量。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An application that displays images always needs a good design to ensure the
    download process is fast. To do this, images must be as small as possible regarding
    bytes used, to make it easier to transfer them from a remote server to a device
    that may use a poor connection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 显示图片的应用程序总是需要一个良好的设计，以确保下载过程快速。为此，图片在字节使用上必须尽可能小，以便更容易将它们从远程服务器传输到可能使用较差连接的设备上。
- en: 'As analyzed in [Chapter 6](ch06.html "Chapter 6. Networking"), *Networking*,
    there are lots of different conditions for the device to access the server. Moreover,
    this is unpredictable. However, it does not matter which connection is using the
    user''s device, we want to offer the user the best user experience we can. So
    what can we do to reduce the image size? There are two main aspects to consider
    for this: **resolution** and **compression**. Let''s discuss them in more detail.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第六章](ch06.html "第六章. 网络通信")*网络通信*中所分析的，设备访问服务器的条件有很多种，且这是不可预测的。然而，不管用户的设备使用哪种连接，我们都希望提供尽可能最佳的用户体验。那么，我们能做什么来减小图片的大小呢？对此有两个主要方面需要考虑：**分辨率**和**压缩**。让我们更详细地讨论它们。
- en: Resolution
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分辨率
- en: 'The resolution aspect is very underrated when we develop an application that
    displays images. However, let''s think about it for a while: if we are sure the
    image will be displayed in 480x270 pixels at most, why should we download a larger
    image? Moreover, knowing the large fragmentation of screen resolution and densities
    that the Android platform is afflicted by, why should we download images with
    the same resolution on a device of 480x800 pixels and another one of 1920x1080
    pixels?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发显示图片的应用程序时，分辨率方面往往被低估。然而，让我们思考一下：如果我们确定图片最多以480x270像素显示，为什么我们要下载更大的图片呢？此外，考虑到Android平台所遭受的屏幕分辨率和密度的巨大碎片化，为什么我们要在480x800像素的设备和1920x1080像素的设备上下载相同分辨率的图片呢？
- en: The best approach is to serve an image with the same resolution as the placeholder
    of the particular device it will be shown on. Then, if the placeholder is 480x270
    pixels, we should download an image size of 270 pixels or 480 pixels, at the most,
    or the same resolution of the placeholder; the overhead will be lost anyway. Unfortunately,
    this approach can be put into practice only if we have access to the server implementation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的做法是提供与特定设备上占位符相同分辨率的图片。然后，如果占位符是480x270像素，我们最多应该下载270像素或480像素的图片，或者与占位符相同的分辨率；无论如何，额外的开销都会被浪费。不幸的是，只有在我们可以访问服务器实现的情况下，这种方法才能付诸实践。
- en: If we are unable to change the server settings, there are tons of real-time
    image processing services to do this. We can decide to use them in particular
    conditions or connections, or for just a specific type of image or section of
    our application. It will be of benefit anyway.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法更改服务器设置，有许多实时图像处理服务可以完成这项工作。我们可以决定在特定条件或连接下使用它们，或者仅用于特定类型的图片或应用的部分区域。无论如何，这样做都是有利的。
- en: When an image with the same content should be displayed in multiple sections
    of our application, perhaps using different resolutions, the trick is to download
    the image with the highest resolution and then use the techniques discussed earlier
    to scale it down to be used in a different placeholder. This way we are saving
    time, battery charge, and bandwidth. This is not a rule to be applied every time;
    you should always design the best approach to reducing the size of the images
    to be transferred to the device, depending on the application's requirements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在应用程序的多个部分显示内容相同的图像，可能使用不同的分辨率时，诀窍是下载最高分辨率的图像，然后使用前面讨论的技术将其缩小，以在不同的占位符中使用。这样我们就能节省时间、电池电量以及带宽。这并不是每次都需要遵循的规则；你应该根据应用程序的需求，设计最佳的方法来减少要传输到设备的图像大小。
- en: Compression
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩
- en: 'Things get interesting when talking about compression: the most-used image
    format is PNG. It is a type of lossless compression, leading to full-quality images.
    Unfortunately, its ability to compress can lead to bigger files, and then bad
    transferring results and all the other side effects discussed previously.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到压缩时，事情变得有趣：最常使用的图像格式是PNG。它是一种无损压缩类型，能保证图像的完整质量。不幸的是，其压缩能力可能导致更大的文件，从而造成前面讨论过的传输效果差和其他副作用。
- en: A lighter format is the JPEG one; it uses lossy compression to reduce the image
    size and obtain a good result, while there is little difference perceived by the
    user. This is a better choice of format for images that come from a remote resource.
    Unfortunately, it does not handle transparency. Also, there is an even lighter
    format, suggested by Google, called **WebP**; it can use loss or lossless compression
    with or without transparency and animations. This format analyzes pixels and predicts
    the nearby pixels, reducing the quantity of data, in bits, required for an image.
    This is also completely supported starting from Android Jelly Bean (API Level
    17).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG格式是一种更轻的格式；它使用有损压缩来减小图像大小，同时用户几乎无法感知到差异。这对于来自远程资源的图像来说是一个更好的格式选择。不幸的是，它不支持透明度。此外，还有一种由谷歌提出的甚至更轻的格式，称为**WebP**；它可以使用有损或无损压缩，并且可以选择是否包含透明度和动画。这种格式分析像素并预测邻近像素，从而减少图像所需的数据量（以比特为单位）。从Android
    Jelly Bean（API级别17）开始，这种格式得到了完全支持。
- en: Anyway, if we need to use PNG files for any reason, there are lots of tools
    to apply lossy image compression and reduce their sizes drastically. These tools
    allow us to change color profiles, apply filters, and other useful operations
    to reduce the image size. It is up to us to find the right loss for our images.
    An image just exported by the graphics editor programs is bigger than needed;
    we should always clean it, searching for unused data inside it, and then apply
    any compression improvement we need to reduce overheads in image transfers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果我们需要使用PNG文件，有许多工具可以应用有损图像压缩，大幅减小文件大小。这些工具允许我们更改颜色配置文件，应用滤镜以及其他有用的操作来减少图像大小。我们需要找到适合我们图像的正确损失程度。由图形编辑程序刚刚导出的图像通常比实际需要的大；我们应该始终清理图像，查找其中未使用的数据，然后应用所需的任何压缩改进，以减少图像传输中的开销。
- en: Serialization
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: The same considerations related to lowering image sizes to speed up transfers
    can be used for text files as well. So, let's have a quick overview of a typical
    format to transfer data over our client/server architecture. Until a couple of
    years ago, the XML format was the most used. Then developers changed it to JSON
    format. Both are human readable, but JSON is simpler to write because of its syntax.
    It has no need for tags and attributes. For these reasons, JSON is lighter and
    more preferred and used than XML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以将降低图像大小以加快传输速度的考虑应用于文本文件。那么，让我们快速了解一下在客户端/服务器架构中传输数据的典型格式。在几年前，XML格式是最常使用的。后来开发者将其改为JSON格式。这两种格式都是可读的，但由于JSON的语法更简单，不需要标签和属性，因此它更轻便，也更受欢迎和使用，胜过XML。
- en: JSON improvements
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON改进
- en: Google provide an easy-to-use library to handle JSON serialization and deserialization,
    called GSON. In principle, it uses reflection to find the getters and setters
    of a Java bean; then, if everything is in the right place inside the bean, it
    can be deserialized by providing just the wanted class, to create a new object
    filled with all the data inside the JSON file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌提供了一个易于使用的库来处理JSON序列化和反序列化，称为GSON。原则上，它使用反射来查找Java bean的getter和setter；然后，如果bean内部的一切都在正确的位置，只需提供所需的类，就可以反序列化，创建一个填充了JSON文件内所有数据的新对象。
- en: To improve serialization/deserialization performance and transfer timings, we
    need to improve the JSON file design; our goal is to reduce the size of JSON files.
    The main and obvious tip here is to avoid unnecessary data inside the JSON structure.
    So, don't serialize data that the client does not use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高序列化/反序列化性能和传输时间，我们需要改进JSON文件设计；我们的目标是减少JSON文件的大小。这里的主要且明显的提示是避免在JSON结构中包含不必要的数据。因此，不要序列化客户端不使用的数据。
- en: 'The typical approach to data serialization using JSON is to create an array
    of objects to be transferred. However, the JSON format needs a name for every
    property to be recognized correctly during the deserialization process. This way,
    many characters for duplicated strings are added, causing an overhead in the file
    size. The following JSON file example shows a list of objects with the related
    duplicated keys characters:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON进行数据序列化的典型方法是创建一个要传输的对象数组。然而，JSON格式需要为每个属性指定一个名称，以便在反序列化过程中正确识别。这种方式增加了许多重复字符串的字符，导致文件大小产生额外开销。以下JSON文件示例显示了一组带有相关重复键字符的对象列表：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The content of this file can be serialized in a smaller file defining arrays
    of properties instead of arrays of objects. *Figure 7* shows the concept and the
    change of structure to apply here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的内容可以通过定义属性数组而非对象数组来序列化到一个更小的文件中。《图7》展示了这里要应用的结构变更概念：
- en: '![JSON improvements](img/4666_10_07.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![JSON改进](img/4666_10_07.jpg)'
- en: 'Figure 7: Structure change from an array of objects to an array of properties
    to apply to a JSON file'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：从对象数组到属性数组的结构变更，应用于JSON文件中
- en: 'Applying this kind of remodeling, the following file would be the new format,
    containing the same content of the first JSON file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这种重塑方式，以下文件将是新的格式，包含第一个JSON文件中的相同内容：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The actual size of the first file is about 250 bytes, while the second one is
    140 bytes. But the more objects there are in a single file, the greater the savings
    that will be applied to the whole JSON file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件的实际大小约为250字节，而第二个文件为140字节。但是，单个文件中的对象越多，整个JSON文件将应用越多的节省。
- en: JSON alternatives
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON的替代品
- en: However, both the XML and JSON formats are too expensive; they are verbose in
    terms of readability, slower to be encoded by the server, and, once the client
    has received them, slower to decode than other lighter formats. Usually, for debugging
    purposes, developers prefer a human readable format to performance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，XML和JSON格式都过于冗余；它们在可读性方面显得累赘，服务器编码较慢，而且一旦客户端接收它们，解码速度也会比其他轻量级格式慢。通常，出于调试目的，开发者更偏好可读性更强而非性能的格式。
- en: As a matter of fact, there are other formats to let the client and the server
    communicate in a faster way. These are by Google; let's have an overview of these.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有其他格式可以让客户端和服务器以更快的速度进行通信。这些都是谷歌推出的；让我们简要了解一下这些。
- en: Protocol buffers
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议缓冲区
- en: 'The first serializing method developed is called a **protocol buffer**. Similar
    to XML, it provides a way to define data structures, but it is faster and smaller.
    It uses files with a `.proto` extension to set the syntax of the not-readable
    binary file created and transferred later. It is something similar to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个开发的序列化方法被称为**协议缓冲区**。与XML类似，它提供了一种定义数据结构的方法，但它更快且更小。它使用`.proto`扩展名的文件来设置后来创建和传输的不可读二进制文件的语法。它类似于以下内容：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Every message is a key/value pair series. Then, once defined, our data to be
    transmitted would look just like a binary stream. This is the main advantage of
    this method: it is up to 10 times smaller and 100 times faster than an XML file
    with the same data.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消息都是一系列键/值对。定义之后，我们待传输的数据看起来就像一个二进制流。这是这种方法的主要优势：它比含有相同数据的XML文件小10倍，快100倍。
- en: This method is platform independent and can be used across multiple environments.
    Nevertheless, not every developing language is supported; at the moment the current
    release includes Java, C++, and Python compilers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是平台无关的，可以在多个环境中使用。然而，并非每种开发语言都受到支持；目前发布的版本包括Java、C++和Python编译器。
- en: Unfortunately, protocol buffer implementation needs a lot of memory and code
    to be used. This is not suitable for mobile devices where, as we know, there is
    a need to save memory as much as possible to achieve performance goals. For this
    reason, a special version of protocol buffers has been created to minimize code
    and memory usage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，协议缓冲区实现需要大量的内存和代码才能使用。这对于移动设备来说并不合适，因为正如我们所知，需要尽可能节省内存以达到性能目标。因此，创建了一个特殊的协议缓冲区版本，以最小化代码和内存使用。
- en: Flat buffers
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平铺缓冲区
- en: Flat buffers are an advanced serialization method created by Google. A flat
    buffer is made by a flat binary buffer without the need to parse it. Memory allocation
    here is extremely low, while providing high flexibility in defining fields. The
    code overhead is minimal. Also, it is possible to parse JSON texts in a faster
    and more efficient way than other parsers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 平铺缓冲区是谷歌创建的一种高级序列化方法。平铺缓冲区是由无需解析的平铺二进制缓冲区构成的。这里的内存分配极低，同时在定义字段时提供高度灵活性。代码开销最小。此外，解析JSON文本的速度比其他解析器更快、更高效。
- en: This method is open source and there are different implementations with different
    features for every single supported language, because they depend on community
    contributions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是开源的，并且每种支持的语言都有不同的实现和不同的功能，因为它们依赖于社区贡献。
- en: Flat buffers do not need intermediate representation data to be parsed; hence,
    they are faster at providing data than the protocol buffers. Let's have a quick
    look at their integration in an Android application to understand their advantages
    and whether the integration time is worthwhile.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 平铺缓冲区不需要解析中间表示数据；因此，它们在提供数据方面比协议缓冲区要快。让我们快速了解一下它们在Android应用程序中的集成，以了解它们的优势以及集成时间是否值得。
- en: 'The first thing to do is to define a schema file to be used to delineate the
    data structure or to convert the JSON original one if we are migrating from that
    kind of serialization method. So, let''s have a look at the following JSON file
    to convert:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的就是定义一个架构文件，用来界定数据结构，或者如果我们是从那种序列化方法迁移过来的，可以转换原始的JSON。那么，让我们看一下以下要转换的JSON文件：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The schema declaration file should contain a table for every object in the
    file, specifying the type of every property. The following is the corresponding
    schema file content:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 架构声明文件应该包含文件中每个对象的表，指定每个属性的类型。以下是相应的架构文件内容：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once done, we need to create the Java model with classes to use in our application.
    For this purpose, the flat compiler is provided, and we can use it to generate
    all the Java class files by calling the following command line:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们需要创建Java模型以及要在我们的应用程序中使用的类。为此，提供了平铺编译器，我们可以使用它来生成所有Java类文件，通过调用以下命令行：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Refer to the official documentation for further information about the correct
    use of the provided sources. The final file for the `User` class created for the
    model of the previous example is the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关正确使用提供资源的更多信息，请参考官方文档。为上一个示例的模型创建的`User`类的最终文件如下：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This class can be used just by calling the `User.getRootAsUser()` method; just
    after the source, it''s converted into a byte array and then a `ByteBuffer` object,
    as shown in the following snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只需调用`User.getRootAsUser()`方法就可以使用这个类；在源代码之后，它被转换成字节数组，然后是`ByteBuffer`对象，如下面的代码段所示：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For the Android implementation, this solution reduces the transfer size significantly,
    and serialization and deserialization timings are much lower than in the JSON
    case. This means that the flat buffers are much more efficient, and we should
    think of replacing our JSON strategy with one based on flat buffers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android实现，这个解决方案显著减少了传输大小，并且序列化和反序列化时间比JSON情况要低得多。这意味着平铺缓冲区效率更高，我们应该考虑用基于平铺缓冲区的策略来替换我们的JSON策略。
- en: Local serialization
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地序列化
- en: Serialization is worthwhile for communication purposes because its main aim
    is to provide a light way to transmit structured objects in different environments.
    However, serialization and deserialization processes need an overhead of time
    to be executed. So, while it is good for network transfers, it should not be used
    locally by the client, saving the time needed for serialization and deserialization
    operations, for example, to store data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化在通信方面是值得的，因为其主要目的是提供一种在不同环境中传输结构化对象的轻量级方法。然而，序列化和反序列化过程需要执行的时间开销。因此，尽管它适合网络传输，但不应该在客户端本地使用，以节省序列化和反序列化操作所需的时间，例如存储数据。
- en: A typical example is the storing of a JSON file in the cache memory. This must
    be deserialized every time before accessing its data. In addition, if you need
    to change something inside the file, the JSON file must be serialized with the
    new content before saving it into the cache memory. This is much more expensive
    than using a local database with the structured data, even if it is the fastest
    way to develop such a data management system inside an Android application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是将JSON文件存储在缓存内存中。每次访问其数据前都必须进行反序列化。此外，如果你需要更改文件内的内容，必须在将新内容序列化后，再保存到缓存内存中。这比使用带有结构化数据的本地数据库成本要高得多，即使这是在Android应用程序内部开发此类数据管理系统最快的方法。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you need to save data, avoid serialization while handling local data. Choose
    a SQLite database to save data instead of the serialized methods, because the
    database access is much faster than the serialization and deserialization operations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要保存数据时，处理本地数据时避免序列化。选择SQLite数据库来保存数据，而不是序列化方法，因为数据库访问比序列化和反序列化操作要快得多。
- en: Code improvements
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码改进
- en: We want to discuss in the following pages a couple of optimizations related
    to particular coding situations and common patterns. These tips are examples of
    how common habits in practical everyday development work may lead to performance
    faults.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们想讨论一些与特定编码情况和常见模式相关的优化。这些技巧是实际日常开发工作中常见习惯可能导致性能故障的例子。
- en: Getters and setters
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问器与修改器（Getters and setters）
- en: One of the core concepts used in object-oriented programming is **encapsulation**;
    as you know, it means that the fields of an object should not be accessed directly
    by other objects. So, you can encapsulate an object's fields in Java by using
    the private modifier and by creating getter and setter methods to let other objects
    access them. This guarantees that the class itself has complete control over its
    own fields and no one else can use it. Then, you are free to create read-only
    or write-only fields, simply defining just the related method and avoiding defining
    the other one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中使用的一个核心概念是**封装**；正如你所知，这意味着其他对象不应直接访问对象的字段。因此，你可以在Java中使用private修饰符来封装对象的字段，并创建访问器和修改器方法，让其他对象可以访问它们。这保证了类本身对其字段拥有完全控制权，其他人无法使用。然后，你可以自由地创建只读或只写字段，只需定义相关方法，避免定义另一个。
- en: 'The benefits of encapsulation are not at issue, but they come with a cost.
    Accessing fields directly is three times faster than using a getter if there is
    no JIT, and seven times faster if there is a JIT. This means that we should keep
    encapsulating our fields, but we should avoid calling getters and setters where
    it is not necessary. For example, don''t call getters and setter inside a class,
    because it is more expensive and you do not need to do it because the class can
    access its own fields directly. Let''s have an example; the following code calls
    an internal method during instantiation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的好处是毋庸置疑的，但它们是有代价的。如果不存在JIT，直接访问字段比使用访问器快三倍，如果存在JIT，则快七倍。这意味着我们应该继续封装我们的字段，但在没有必要的情况下应避免调用访问器和修改器。例如，在类内部不要调用访问器和修改器，因为这更耗时，而且你不需要这样做，因为类可以直接访问自己的字段。举个例子；以下代码在实例化期间调用了一个内部方法：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although it is not wrong, this code can be made faster during execution by
    removing the internal call to the setter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样做没有错，但通过移除内部对修改器的调用，可以在执行期间提高代码速度：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is just an example, but the main tip here is to avoid calling setters and
    getters internally in every case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，但这里的主要建议是，在任何情况下都应避免在内部调用访问器和修改器。
- en: Inner classes
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部类
- en: 'We''ve already talked about inner classes in [Chapter 4](ch04.html "Chapter 4. Memory"),
    *Memory*, while discussing the problem related to memory leaks. Nesting classes
    in Android is a very common practice because many times we need to have a reference
    of the wrapper class inside the inner one. However, this advantage has a hidden
    cost. Let''s have an example to clarify what we are talking about:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章. 内存")中讨论内存泄漏问题时已经谈过内部类，*Memory*。在Android中嵌套类是一种非常常见的做法，因为很多时候我们需要在内部类中持有对包装类的引用。然而，这种优势隐藏着代价。让我们通过一个例子来明确我们讨论的问题：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The two classes we are dealing with will be separated anyway. This means that
    the compiler will create methods inside the outer class to let the inner one access
    the referenced wrapper class''s variables and methods. Let''s have a look at the
    bytecode of the aforementioned classes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的两类将会被分离。这意味着编译器将在外部类中创建方法，让内部类访问被引用包装类的变量和方法。让我们来看一下前述类的字节码：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `OuterClass` class creates a method for every variable to let the `InnerClass`
    class access it in a package protection-level environment:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`OuterClass`类为每个变量创建了一个方法，让`InnerClass`类在包保护级别环境中访问它：'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The static methods created are needed to let `InnerClass` access the related
    methods of `OuterClass`. This results in slower access, as mentioned in the previous
    paragraph, producing slower code execution. This can be avoided by declaring package-protected
    variables and methods to allow `InnerClass` to access them without the need to
    produce static methods in the bytecode. This would allow access by any other class
    in the same package, but it can speed up the code. So, it is up to us to know
    whether we can do it. If so, `OuterClass` should be turned into the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的静态方法是让`InnerClass`访问`OuterClass`的相关方法。如前所述，这会导致访问变慢，从而执行更慢的代码。如果声明包保护的变量和方法，可以避免这种情况，允许`InnerClass`在不生成字节码中的静态方法的情况下访问它们。这将允许同一包中的任何其他类访问，但也可能加快代码速度。所以，我们需要知道是否可以这样做。如果可以，`OuterClass`应该变成以下形式：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Java 8 in Android N
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android N中的Java 8
- en: The new Android N SDK provides support to the new features Java 8 introduced
    on its release. In the following pages, we will go through them to understand
    how they can be helpful while developing our application, and go through the new
    toolchain introduced to improve timings while building the APK file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Android N SDK在发布时提供了对Java 8引入的新特性的支持。在接下来的页面中，我们将通过它们了解如何在开发应用程序时提供帮助，并了解新的工具链以改善构建APK文件时的时序。
- en: Setup
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: In order to use the new Java 8 features, we need to target the new Android N
    and use the new Android Studio 2.1 that supports Android N, otherwise, those features
    won't be available. At the time of the writing this book, the new Android Studio
    2.1 is in preview version. However, we can use it to have a better understanding
    of the steps to follow to use Java 8 and its new features in our projects. This
    is because the new Jack toolchain, introduced in Android MarshMallow (API Level
    23), which we will discuss in greater detail in the following pages, with the
    new Gradle plugin, is the only way to compile through Java 8 and use the features
    we will go through in the following section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用新的Java 8特性，我们需要面向新的Android N，并使用支持Android N的新Android Studio 2.1，否则，这些特性将不可用。在撰写本书时，新的Android
    Studio 2.1仍处于预览版本。然而，我们可以使用它来更好地了解在项目中使用Java 8及其新特性的步骤。这是因为新的Jack工具链，在Android
    MarshMallow（API级别23）中引入，我们将在接下来的页面中详细讨论，以及新的Gradle插件，是编译Java 8并使用我们将在下一节中介绍的特性唯一方式。
- en: 'At the moment, we need to change the `build.gradle` file in the following way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们需要按照以下方式更改`build.gradle`文件：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This way, we are enabling the Jack toolchain and Java 8 compatibility for our
    project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们为项目启用了Jack工具链和Java 8兼容性。
- en: Features
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性
- en: 'The main new features of Java 8 we can use inside our projects, if targeted
    by using Android N, are the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的项目面向Android N，可以在项目中使用Java 8的主要新特性如下：
- en: Default and static methods inside an interface
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口内的默认和静态方法
- en: Lambda expression
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Repeating annotations
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复注解
- en: Improved reflection APIs
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的反射API
- en: Let's go through them in the following pages.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的页面中了解它们。
- en: Default interface methods
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认接口方法
- en: 'Assume you are developing a library for other projects. You want to write an
    interface for the definition of a behavior of all the classes that implement that
    interface. For example, let''s see what''s inside the following interface:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为其他项目开发一个库。你想要编写一个接口，用于定义实现该接口的所有类的行为。例如，让我们看看以下接口内部的内容：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the following is an implementation of the interface by `Activity`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Activity`对接口的实现：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If now we want to add a feature inside the interface to improve it, we need
    to change all of the classes that implement that interface. Let''s say we want
    to handle the long click on a news as well as the normal click. The interface
    would be turned into the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在我们想要在接口中添加一个特性来改进它，我们需要改变所有实现该接口的类。比方说，我们想要处理新闻的长按以及正常点击。接口将变成如下形式：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, Android Studio would notify us of a compilation error in the `MainActivity`
    class, as well as in any other class that implements the `OnNewsSelected` interface.
    And here comes the magic: using Java 8 and its new features, we can define a default
    implementation of a new method directly inside the interface itself. The following
    snippet shows how this can be done for our interface:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Android Studio 会在`MainActivity`类以及任何实现`OnNewsSelected`接口的其他类中通知我们编译错误。神奇的地方来了：使用
    Java 8 及其新特性，我们可以在接口本身内部直接定义新方法的默认实现。以下代码段展示了如何为我们的接口完成这一操作：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using this feature, there is no need to implement the new method in every class
    that implements the interface, but it's needed only where we need a different
    implementation from the default one we define inside the interface.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个特性，无需在每个实现接口的类中实现新方法，只有在需要与接口内部定义的默认实现不同的实现时才需要。
- en: Static interface methods
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态接口方法
- en: 'Static methods are similar to the default ones, but they cannot be overridden
    by the subclasses. They can be called by using the static references for the classes,
    or by using the object call as well. Then, our `OnNewsSelected` interface example
    would be turned into the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法与默认方法相似，但它们不能被子类覆盖。可以通过使用类的静态引用来调用它们，也可以通过对象调用来调用。那么，我们的`OnNewsSelected`接口示例将变成如下形式：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This way, we are defining only one possible behavior for the long click on news
    and no subclass is able to define its own implementation of the method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们只定义了长按新闻的一种可能行为，没有任何子类能够定义它自己的方法实现。
- en: Lambda expression
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: When we are developing interfaces that define just one method, we are creating
    what is called a **functional interface**. When we create anonymous inner classes
    while using these functional interfaces, the code readability is not so clear.
    Then, from Java 8, we can use the Lambda expression to pass simple code as a parameter
    instead of an anonymous inner class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发只定义一个方法的接口时，我们创建了一个所谓的**函数式接口**。在使用这些函数式接口时创建匿名内部类，代码的可读性不是很清晰。然后，从 Java
    8 开始，我们可以使用 Lambda 表达式将简单代码作为参数传递，而不是匿名内部类。
- en: 'For example, let''s create the following `Adder` functional interface:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建以下`Adder`函数式接口：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A Lambda expression is made up of the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式由以下部分组成：
- en: 'A list of parameters separated by a comma: `(int a, int b)`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由逗号分隔的参数列表：`(int a, int b)`
- en: 'An arrow token: `->`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头符号：`->`
- en: 'A body with a statement block: `a + b`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有声明块的代码体：`a + b`
- en: 'Then, when we need an implementation of the functional interface we defined,
    we can use the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们需要我们定义的功能接口的实现时，我们可以使用以下代码：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we can use the object `adder` as an implementation of the `Adder` interface.
    We could do the same with anonymous classes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用对象`adder`作为`Adder`接口的实现。我们也可以用匿名类来做同样的事情：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The previous code snippet would replace the following one, with obvious improved
    readability:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将替换以下代码，明显提高了可读性：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Repeating annotations
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复注解
- en: 'When compiling with Java 8, we can set a particular annotation feature that
    allows us to add the same annotation multiple times on a class or variable. This
    is the `@Repeatable` annotation to be set on the declaration of an annotation.
    Let''s see the following example, where we want to define multiple manufacturers
    for a single device. Then, let''s add the `@Repeatable` annotation on top of the
    definition as the following code snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 8 编译时，我们可以设置一个特定的注解特性，允许我们在类或变量上多次添加相同的注解。这是要在注解声明上设置的 `@Repeatable`
    注解。让我们看以下示例，我们想为单一设备定义多个制造商。然后，在定义顶部添加 `@Repeatable` 注解，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can use the following to set multiple manufacturers for the same device:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下方法为同一设备设置多个制造商：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Jack toolchain
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jack 工具链
- en: 'A toolchain is a particular sequences of steps to compile our code and create
    the APK file as the output that contains the `.dex` bytecode. *Figure 8* shows
    the main differences between the old Javac toolchain and the new Jack one:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是一系列特定的步骤，用于编译我们的代码并创建包含 `.dex` 字节码的 APK 文件作为输出。《图8》展示了旧的 Javac 工具链与新的 Jack
    工具链之间的主要区别：
- en: '![Jack toolchain](img/4666_10_08.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Jack 工具链](img/4666_10_08.jpg)'
- en: 'Figure 8: Differences between Javac and Jack toolchains'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Javac 与 Jack 工具链之间的区别
- en: 'The Jack toolchain brings new improvements in the building process:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Jack 工具链在构建过程中带来了新的改进：
- en: Faster compilation time
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的编译时间
- en: Code and resources shrinking
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码和资源的缩减
- en: Code obfuscation
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码混淆
- en: Repackaging
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新打包
- en: Multidex compilation
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多 DEX 编译
- en: There is no need to change anything in our code, or in our configuration, in
    order to use the new toolchain except the configuration of the `build.gradle`
    file we dealt with in the *Setup* section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用新的工具链，我们无需更改代码或配置中的任何内容，只需处理 *设置* 部分中提到的 `build.gradle` 文件的配置。
- en: At the time of writing this book, the new Jack toolchain is not compatible with
    the new **Instant Run** feature of Android Studio 2.0\. This means that **Instant
    Run** will be disabled while using the Jack toolchain.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，新的 Jack 工具链与 Android Studio 2.0 的新 **Instant Run** 功能不兼容。这意味着在使用 Jack
    工具链时，**Instant Run** 将被禁用。
- en: APK optimizations
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: APK 优化
- en: 'When everything is done, the code is developed and tested, and users are waiting
    for an update of our application, we use it to build an APK file to distribute
    through the Google Play Store or anywhere else. However, due to multiple factors,
    the resulting APK file is forever getting bigger: new feature implementations,
    new, different configurations to support, new Android versions, more libraries
    used in the application, and so on. This way, we are forcing our users to use
    more bandwidth to update it and more storage to save it. In addition, there is
    a limit to the APK size that can be uploaded and distributed via the store. So,
    are we sure that we are doing well? What can we do to reduce the file size? Let''s
    try to give an answer to these questions in the following pages from different
    points of view.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切准备就绪，代码开发并测试完成，用户正等待我们应用程序的更新时，我们使用它来构建一个 APK 文件，通过 Google Play 商店或其他途径进行分发。然而，由于多种因素，生成的
    APK 文件体积不断增大：新功能的实现、需要支持的新不同配置、新的 Android 版本、应用程序中使用的更多库等等。这样，我们迫使用户使用更多带宽来更新它，以及更多存储空间来保存它。此外，通过商店上传和分发的
    APK 文件大小是有限制的。那么，我们确信我们做得好吗？我们可以做些什么来减小文件大小？在接下来的几页中，让我们尝试从不同的角度来回答这些问题。
- en: Removing unused code
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除未使用的代码
- en: 'High-level languages consider reusability of the code to improve development
    times and reduce debugging. It is also helpful to minimize the APK file size,
    as well as keeping our code cleaner and better organized. Maintaining the code
    as clean as possible should be an everyday activity. Nevertheless, even if we
    are doing it every day, we can still improve the cleanliness of our code inside
    the final build by using a tool we already discussed for security purposes in
    [Chapter 7](ch07.html "Chapter 7. Security"), *Security*. We are talking about
    ProGuard. This not only obfuscates the code to increase the security level, but
    it can also be set to search for and remove unused code in our application when
    enabled:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言考虑代码的可重用性以缩短开发时间和减少调试。这也有助于最小化APK文件的大小，同时保持代码的清洁和更好的组织。尽可能保持代码清洁应成为日常活动。然而，即使我们每天都在这样做，我们仍然可以通过在[第7章](ch07.html
    "第7章 安全")中讨论的安全工具来提高最终构建中代码的清洁度。我们讨论的是ProGuard。它不仅混淆代码以提高安全级别，还可以在启用时搜索并移除应用程序中未使用的代码：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Removing unused resources
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除未使用的资源
- en: We already talked about images and the effect their size has on communications,
    but here the same considerations can be used in order to reduce the APK file size.
    Hence, it could be a good idea to check whether our image sizes can be reduced
    using the online tools to change compression and/or resolution, as described in
    the previous section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过图像及其大小对通信的影响，但这里同样的考虑也可以用来减小APK文件的大小。因此，检查我们的图像是否可以通过在线工具更改压缩率和/或分辨率来减小大小，如前一部分所述，这可能是一个好主意。
- en: As a more general rule, we should always check whether there are unused resources
    inside the project and delete them, whether they are images or any other type
    of resource. This is also helpful for keeping a clean project. In this operation,
    Lint is really useful, searching for any unused resources in the project.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条更通用的规则，我们应该始终检查项目中是否有未使用的资源并删除它们，无论它们是图片还是其他类型的资源。这对于保持项目清洁也很有帮助。在此操作中，Lint非常有用，它可以搜索项目中的任何未使用资源。
- en: 'If those actions are not enough to remove all of the unused resources of the
    project from the final APK file, Gradle helps us by analyzing all the resources
    of the project before the final build. We just have to enable it inside the `build.gradle`
    file, as shown in the following example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些操作不足以从最终APK文件中移除项目的所有未使用资源，Gradle会在最终构建之前分析项目的所有资源来帮助我们。我们只需在`build.gradle`文件中启用它，如下面的示例所示：
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remember to enable minify. Otherwise, the resource shrinking will not work.
    This is really useful where we are using external libraries, but not all of its
    resources are used. For example, if we have added the Google Play Service library
    to our project, but we are not using the Google+ login, or the Google Cast API,
    then Gradle will remove the related unused resources from the resulting file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 记得启用代码压缩。否则，资源缩减功能将无法工作。这对于我们使用外部库但并非所有资源都被使用的情况非常有用。例如，如果我们向项目中添加了Google Play服务库，但我们没有使用Google+登录或Google
    Cast API，那么Gradle将移除结果文件中相关的未使用资源。
- en: 'The same scenario should be covered for different configurations we are supporting
    in our application; for example, if our application supports just the English
    and French languages, but the linked library supports more languages than our
    application, all the others will still be in the final build if we don''t tell
    Gradle which configurations we want. To do this, we can add the `resConfig` property
    to the configuration of the build inside the `build.gradle` file, as shown in
    the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序支持的不同配置，我们也应该考虑同样的场景；例如，如果我们的应用程序只支持英语和法语，但链接的库支持的语言比我们的应用程序多，如果我们不告诉Gradle我们想要哪些配置，那么所有其他配置仍然会在最终构建中。为此，我们可以在`build.gradle`文件中的构建配置中添加`resConfig`属性，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `resConfig` property accepts every configuration type we want to support,
    filtering all the others from the application and the linked libraries. Hence,
    this can be used for all the configurations Android provides, such as densities,
    orientations, languages, Android versions, and so on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`resConfig`属性接受我们希望支持的每一种配置类型，从应用程序和链接的库中过滤掉所有其他的配置。因此，这可以用于所有Android提供的配置，如密度、方向、语言、Android版本等。'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We started this chapter discussing the importance of the good management of
    images from different points of view, because it is critical for every application
    that handles them:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从不同的角度讨论了图像管理的重要性，因为这对于处理它们的每个应用程序都是至关重要的：
- en: '**Loading**: Images are the biggest weight on the memory. Many times we use
    them as they are, without processing them properly to reduce their pressure on
    overall system performance. For this reason, scaling operations are always needed
    in such a fragmented market as that of Android devices. Hence, we discussed the
    proper way to enhance performance while scaling them by using the commonly provided
    Android API.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载**：图片是内存中最大的负担。很多时候，我们直接使用它们，而没有适当地处理以减轻对整个系统性能的压力。因此，在像Android设备这样的碎片化市场中，缩放操作总是必需的。因此，我们讨论了如何在使用Android
    API进行缩放时提高性能的正确方法。'
- en: '**Processing**: Operations over images are expensive, and they need to be executed
    in a worker thread in order to free the main one from unnecessary computations.
    We looked at a way to elaborate images safely from a responsiveness perspective.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理**：图像操作成本高昂，需要在一个工作线程中执行，以释放主线程不必要的计算。我们从响应性的角度研究了如何安全地处理图像。'
- en: '**Caching**: The best way to save external communication is to save data for
    future reuse. That''s why we improved methods and algorithms to cache images,
    maximizing their reuse, introducing the LRU cache architecture for both heap and
    disk cache memory levels to improve persistence and avoid `OutOfMemoryErrors`
    during the use of the application.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：节省外部通信的最佳方式是保存数据以供未来重用。这就是为什么我们改进了缓存图片的方法和算法，最大限度地重用它们，引入了LRU缓存架构，用于堆内存和磁盘缓存内存级别，以提高持久性并避免应用程序使用过程中出现`OutOfMemoryErrors`。'
- en: '**Displaying**: We introduced the pixel format configuration for the images
    to be displayed, in order to speed up the responsiveness of the application and
    improve compression.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示**：我们介绍了待显示图片的像素格式配置，以加快应用程序的响应速度并改善压缩。'
- en: '**Managing memory**: When many images are about to be processed, as in a `ListView`
    or other similar `ViewGroup` with an `Adapter` class, memory churn might occur,
    leading to too many garbage collections over time. For this, we discussed the
    ways that are provided to reuse memory allocation over multiple images processes,
    saving garbage collector interventions.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：当许多图片即将被处理时，如在`ListView`或其他类似的带有`Adapter`类的`ViewGroup`中，可能会发生内存波动，导致随着时间的推移出现过多的垃圾回收。为此，我们讨论了如何重用多次图片处理中的内存分配方法，以减少垃圾收集器的干预。'
- en: Other than the code, we discussed which compressions and resolutions are the
    best for images to be displayed on screens that are becoming increasingly large,
    with higher densities.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码，我们还讨论了对于越来越大的高密度屏幕来说，哪些压缩和分辨率最适合显示图片。
- en: Continuing with networking exchanges of data, we considered and analyzed the
    way to transfer texts over the network, defining best practices for JSON-like
    structured files and introducing multiple serialization techniques, such as protocol
    buffers and flat buffers, provided by Google to reduce overhead in local serialization/deserialization
    operations and to speed up transferring data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续网络数据交换的讨论中，我们考虑并分析了文本通过网络传输的方式，为类似JSON的结构化文件定义了最佳实践，并介绍了多种序列化技术，如谷歌提供的协议缓冲区和扁平缓冲区，以减少本地序列化/反序列化操作的开销，并加快数据传输速度。
- en: Then, we found a couple of habits to be adopted by developers while dealing
    with Java beans and inner classes from a pure Java point of view; a performance
    hit can be taken even if we are following the directions on the use of a common
    language.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到了一些在处理Java豆和内部类时开发者应该养成的习惯；即使我们遵循了使用通用语言的指导方针，也可能会出现性能下降。
- en: Finally, at the end of this chapter, we went through tips to reduce the APK
    file size in order to distribute it through stores. This is important to comply
    with store limits and to maintain a cleaner project for new implementations in
    future.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章的结尾，我们讨论了减少APK文件大小的技巧，以便通过商店进行分发。这对于遵守商店限制并保持项目清洁以便未来实现新的功能来说非常重要。
