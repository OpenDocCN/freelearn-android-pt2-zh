- en: Chapter 9. Intent Service and Pending Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the very beginning of this book, we have been studying different tasks
    that an intent can do to facilitate Android and their types. We have seen that
    intents can help to navigate in between the activities. They are also used to
    transfer data between them. We saw how we can put filters in order to verify whether
    the incoming intent can qualify the component test and in the end, we learned
    the role of intent in Broadcast Receivers. In this chapter, we will have an advanced
    look at how the intents can be used for doing handy things using Intent Services
    and Pending Intents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Intent Service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage and Implementation of Intent Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Pending Intent?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage and Implementation of Pending Intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intent Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intent Service is a simple kind of service that is used to handle asynchronous
    work which has nothing to do with the main thread. This can be done if the client
    sends the request by the `startService(Intent intent)` method. This new task will
    be handled by the worker thread and stops when it runs out of work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intent Service is inherited by the `Service` class present in Android API
  prefs: []
  type: TYPE_NORMAL
- en: Intent Service is used to offload the working thread, so that it does not become
    the bottleneck. It helps to make things go separately as of the main application
    thread. It is to be noted that though it works independently of the main thread,
    only one request can be processed at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: Intent Service is the best way to offload the work from the UI thread of your
    application and into a work queue. There is no need to make asynchronous tasks
    and manage them for every processing. Rather, you define an Intent Service, enable
    it to handle the appropriate data that you want to send for the processing, and
    simply start the service. In the end, you can send the data back to the application
    by broadcasting it in an intent object and catching it from the Broadcast Receiver
    to use it in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of four fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section shows the basic difference between four of the most important elements
    (Service, Thread, Intent Service, and Async Task) of Android development including
    Intent Service.
  prefs: []
  type: TYPE_NORMAL
- en: Best case to use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Best case scenarios for Service, Thread, Intent Service, and Async Task are
    given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Best case scenario |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Service | When task is not too long and has nothing to do with the main thread
    |'
  prefs: []
  type: TYPE_TB
- en: '| Thread | When there is a long task to perform and more than one task has
    to be done in parallel |'
  prefs: []
  type: TYPE_TB
- en: '| Intent Service | When there are long tasks without any intervention from
    the main thread and also where callbacks are needed |'
  prefs: []
  type: TYPE_TB
- en: '| Async Task | When there are long tasks in which communication with the main
    thread is needed and also where there is a need for parallel work to be done |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there is a need for Intent Service to communicate with the main thread, we
    need to use Handler or Broadcast Intents.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The difference in the triggers of Service, Thread, Intent Service, and Async
    Task has been discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Service | Thread | Intent Service | Async Task |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Triggers | By using the `onStartService()` method | By using the `start()`
    method | By Intent | By using the `execute()` method |'
  prefs: []
  type: TYPE_TB
- en: '| Cause of Triggers | Can be called from any thread | Can be called and run
    by any other thread | Can only be called from the main thread | Can only be called
    from the main thread |'
  prefs: []
  type: TYPE_TB
- en: '| Runs on | Can be called from the main thread | Its own thread | Separate
    worker thread | Separate worker thread although the method of the main thread
    can be run in between |'
  prefs: []
  type: TYPE_TB
- en: '| Limitations | Can block the main thread in certain scenarios | Has to be
    manually handled and the code may not be easily understandable | Cannot handle
    multiple tasks simultaneously and all tasks work on the same worker thread | Can
    have only one instance of one task and cannot be run in a loop |'
  prefs: []
  type: TYPE_TB
- en: Usage and implementation of Intent Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the previous parts of this chapter, we have the clear view of the definition
    of Intent Service and what the fundamental differences are that it has with Threads,
    Async Tasks, and Service. It is now time to start with the implementation and
    usage of Intent Services. For this, we will start with the example which will
    help us to learn how to generate a fake notification from Intent Service.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a fake notification from Intent Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will learn the use of Intent Service in producing the notification
    on your notification bar. The example will also explain the use of the `onHandleIntent()`
    method which is used to implement all the functionality of Intent Service that
    also includes sending the broadcast and the notification to the notification bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, at the end of this section you will learn the difference between
    it and Thread, or any other previously mentioned Android-defined method. After
    the completion of this code, start the activity and you will get a view of these
    screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a fake notification from Intent Service](img/9639_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Start of Activity will show the Hello World Screen
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Remember that in this example we will not go through the complete set
    of files that is used in the project. Since this is the last chapter of the book,
    we assume that you already got the basics of Android development in terms of XML
    file, resources, and layouts'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a fake notification from Intent Service](img/9639_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Notification panel showing the Progress notification
  prefs: []
  type: TYPE_NORMAL
- en: A glance at the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example refers to the use of Intent Service in a scenario when there is
    a need for sending a message to the notification bar about progressing or signaling
    of any particular event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Dive into the understanding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Build a new project and open the `src` folder. Create a new class file with
    the name of `CustomIntentService.java` which is the child class of `IntentService`.
    Extend the `IntentService` class and override the method `onHandleIntent(Intent
    intent)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you are all set to implement your own Intent Service that is
    responsible for sending a message to the notification bar and update it in the
    form of the Progress Percentage Bar format. Now, let''s start understanding the
    code by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to declare the variables `notificationManager` and `notification`
    in order to use them inside the `onHandleIntent()` method. There are some other
    static final variables that we will be using in this project. They are `NOTIFICATION_ID`,
    `ACTION_CustomIntentService`, `ACTION_MyUpdate`, `EXTRA_KEY_IN`, `EXTRA_KEY_OUT`,
    and `EXTRA_KEY_UPDATE`. Two new strings variables are also required in order to
    handle the notification string, stated as `activityMessage` and `extraOut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main implementation of this `IntentService` will take place in the `onHandleIntent()`
    method where we will define the working which includes messages to the notification
    bar and broadcasting of messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the start of this `onHandleIntent()`, the extras are obtained by the `intent.getStringExtra()`
    method and saved in the `msgFromActivity` variable which will later be sent to
    broadcast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our main objective is to send a notification which will show 0 to 100 % progress
    (a fake counter) and get updated in the notification bar. For that, we are initializing
    a `for` loop which will go from 0 to 10\. At the start of this, we will call `Thread.sleep(1000)`,
    which will make the thread sleep and will not work for 1000 milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the thread has slept for a certain time, the first counter of our fake
    progress update is done. Our next step is to send a broadcast whose main purpose
    is to give the update. In order to see this, we use the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A quick overview of how we send a broadcast: make a new intent object, and
    give it a name and action of `intentUpdate`; since it is a custom action, give
    it a name of `ACTION_MyUpdate` which you can see in the code; define its category
    which is also a custom category; put the counter information (the variable that
    shows the current counter of the loop) and send a broadcast for this intent.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to send the notification to the notification bar. The following
    lines of code can be seen inside the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code sets the value of `notificationText` to the current counter of the
    loop and converts it into the percentage; makes a new notification by calling
    the `NotificationCompat.Builder()` (which is basically a builder pattern described
    in Android SDK) and gives it the application context, sets its title content,
    text, ticker, when-to-appear, and some other properties. At the end, you have
    to call `notificationManager.notify()` in order to show it in the notification
    bar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to send another broadcast as an acknowledgement, and it has
    the same procedure as that of the previous broadcast, as you can see in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step showed in the code is to override the `onCreate()` method. You
    must have noticed that we did not make a new object of the notification manager
    which will certainly give an error. So, in order to make a new object, we will
    get the system service of Android by using the notification manager `getSystemService
    (Context.NOTIFICATION_SERVICE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example will also need a Broadcast Receiver. If you still don't have an
    idea about it, you can refer to previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Taking another example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example mainly deals with the implementation of notification in
    the Android notification bar. It covered the implementation of Intent Service
    but not the making of Broadcast Receiver and its registration. In this example,
    we will learn how to use Intent Service and convert all the input data to uppercase
    and broadcast it back to Broadcast Receiver. The implementation of Broadcast Receiver
    is also a part of this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the example, use the following code to implement it on your development
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost the same implementation that was done before, in the first example.
    In this example, the working of the `onHandleIntent()` method is shown, in which
    the following steps are taking place:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `onHandleIntent()` method, the first step that you can see is getting
    data from the coming intent and saving it into a variable. The variable `data`
    contains the incoming data which we will convert into the uppercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is logging the data into LogCat, which is obtained by using
    the method `Log.d(String, String)`. The first argument is `TAG`, which is normally
    the class name that is declared at the global level, so that any method may use
    it. This class name is important to distinguish your message from others (makes
    it easy to read). The second argument is the message string which is used to show
    any data in the process, so that at runtime the developer may see its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third step is to convert this data into upper case. This will help to reflect
    the change in the broadcasted intent. Save this back into the data variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the steps are the same as the previous example in which the intent
    object is made, the categories and action are defined, data is put as an extra
    and is sent to be broadcast by the receiver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step, is to set the receiver which will be received from the `sendBroadcast()`
    method. For this, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is that part of the example where how to make a Broadcast
    Receiver is written and this will receive the broadcast back and set `textView`.
    You can see in the code that the `onReceive()` method is overridden where the
    class is extending the Broadcast Receiver. Inside the `onReceive()` method, the
    string is obtained by the `intent.getStringExtra()` method and is saved in the
    result string. This string will be used to set the text of the `textView`, so
    that you can see the changes as they are reflected in the `textView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, the next step is to register this receiver with Intent Service.
    This will be done inside the activity where the receiver is linked to the Intent
    Filter, so that it can have its effect. This is shown in the following piece of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The method `registerReceiver()` is declared inside your activity which will
    be called from the `onCreate()` or `onResume()` methods, so that it can register
    the Broadcast Receiver while starting or resuming the activity.
  prefs: []
  type: TYPE_NORMAL
- en: The Intent Filter is declared and initialized with the object named `intentFilter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `intentFilter` object is set as default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object of the Broadcast Receiver is initiated and registered with the Intent
    Filter by calling the `registerReceiver(Receiver, IntentFilter)` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After registering the receiver with the Intent Filter, the next step is to
    use this in your activity. For this, take a look at the following code. This code
    can be inside any event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initialize an intent in the traditional way by giving that the `IntentService`
    class you just made and put the input text that you want to convert in upper case.
    The extra data that is given to this intent is done by the `Intent.putExtra(String,
    String)` method. The last step is to start the service with this intent. We will
    use the `startService()` method and not the typical `startActivity()` method because
    we use `startActivity` for starting activities through intents in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Pending Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pending Intents are the intents which give token to other applications or you
    may call it a foreign application that may access your intent permission to run
    the predefined piece of code. This way, many other applications such as Alarm
    Manager and Calendar may use your application in order to execute their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Pending Intents are not run instantly; rather, they are run when some other
    activity wants it to run. Pending Intent is a reference that is maintained by
    the system so that it can be used at a later stage. That means that even if the
    application that contains the Pending Intent ends, another application can still
    use the context until `cancel()` is called over that intent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform a broadcast via a Pending Intent, use Pending Intent via `PendingIntent.getBroadcast()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Pending Intents can be launched via three methods, `getActivity(Context
    context, int requestCode, Intent intent, int flags)`, `getBroadcast(Context context,
    int requestCode, Intent intent, int flags)`, and `getService(Context context,
    int requestCode, Intent intent, int flags)`. In order to have a view of Pending
    Intents and how it is made and used in an Android Application, you can proceed
    to the next section which deals with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to make Pending Intents work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section deals with the implementation and explanation of how Pending Intents
    work. In order to have a good understanding of this, we advise you to read the
    previously mentioned definition so that you understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will show you how to make an application in which the user
    can input time (in seconds) into the `editText` field (in seconds) after which
    an alarm will go off and Android's Alarm Manager will make an alarm which will
    be played accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand more, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The piece of code written previously can be inserted into any event which can
    be a button to get the input value in the `EditText` field and process it with
    Pending Intents. The list of steps that is required to understand the previous
    code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the edit text from the layout file and make an object name `text` which
    holds the current state of that widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The integer variable `i` will hold the input value in the edit text which will
    be obtained by `text.getText().toString()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an explicit intent with a `BroadcastReceiver` class as the Intent's target
    class (which we will make after completing this).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to initiate the Pending Intent, we use `PendingIntent.getBroadcast(Context
    context, int requestCode, Intent intent, int flags, int, Intent, int)`. More descriptions
    about this method can be found at [http://developer.android.com/reference/android/app/PendingIntent.html](http://developer.android.com/reference/android/app/PendingIntent.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the system service of Alarm by putting `ALARM_SERVICE` in the `getSystemService()`
    method and direct it towards an `AlarmManager` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the values of the Alarm Manager by the value stored in `i` and give it the
    Pending Intent which will help it to start (since Alarm Manager is a service of
    Android).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `alarmManager.set()` method consists of the arguments `int` type, `long
    triggerMilliSec` (in which you take the current system time and add your variable
    `i` by converting it into milliseconds) and the Pending Intent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a toast in order to show the successful completion of the alarm management.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to make a Broadcast Receiver of your choice and implement
    that receiver. For this, make a Broadcast Receiver and override the method `onReceive()`.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This receiver has a toast which will indicate its status of alarming. The next
    thing is to declare an object of the vibrator kind which can be initiated by calling
    the `context.getSystemService(Context.VIBRATOR_SERVICE)` method. This method is
    responsible for returning back the object which will directly influence the physical
    vibrator of the cell phone. The last step is to start the vibration by calling
    the `vibrator.vibrate(int)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To play the vibrator, you need to add the permission inthe manifest file. You
    can do it by using the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we have to declare this receiver in the `AndroidManifest.xml` file
    and we can do this simply by using the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous example is describing the use of pending Intent and Broadcast Receivers
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The summary of the last chapter of this book can be considered as the conclusion
    of this book. In this chapter, we learned how to implement `intentService` and
    `PendingIntents` and their best case scenarios. The `IntentService` feature and
    its comparison with three most commonly used Android features, such as the Thread,
    Services, and Async Tasks. Moreover, in this chapter, the example of Pending Intent
    is implemented with the explanation of each step. This chapter can be considered
    to be an advance version, or rather you may say, advance use of intents which
    can be done in Android. Keeping in mind that the use of these functionalities
    is not likely to be used, but under certain cases you have to let them work because
    there will be no other solution.
  prefs: []
  type: TYPE_NORMAL
