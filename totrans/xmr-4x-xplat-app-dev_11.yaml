- en: Chapter 11. Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the beginning of Xamarin''s life as a company, their motto has always
    been to present the native APIs on iOS and Android idiomatically to C#. This was
    a great strategy in the beginning, because applications built with Xamarin.iOS
    or Xamarin.Android were pretty much indistinguishable from native Objective-C
    or Java applications. Code sharing was generally limited to non-UI code, which
    left a potential gap to fill in the Xamarin ecosystem: a cross-platform UI abstraction.
    Xamarin.Forms is the solution to this problem, a cross-platform UI framework that
    renders native controls on each platform. `Xamarin.Forms` is a great framework
    for those that know C# (and XAML), but also may not want to get into the full
    details of using the native iOS and Android APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create *Hello World* in Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the Xamarin.Forms architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use XAML with Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover data binding and MVVM with Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Hello World in Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how a Xamarin.Forms application is put together, let's begin by
    creating a simple *Hello World* application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Xamarin Studio and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Multiplatform** | **App** | **Forms App** project from the new
    solution dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your solution something appropriate, such as `HelloForms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure **Use Portable Class Library** is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next**, then click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the three new projects that were successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: HelloForms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HelloForms.Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HelloForms.iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `Xamarin.Forms` applications, the bulk of your code will be shared, and each
    platform-specific project is just a small amount of code that starts up the Xamarin.Forms
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the minimum parts of a Xamarin.Forms application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.xaml` and `App.xaml.cs` in the `HelloForms` PCL library -- this class
    is the main starting point of the Xamarin.Forms application. A simple property,
    `MainPage`, is set to the first page in the application. In the default project
    template, `HelloFormsPage` is created with a single label that will be rendered
    as a `UILabel` on iOS and a `TextView` on Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainActivity.cs` in the `HelloForms.Android` Android project -- the main launcher
    activity of the Android application. The important parts for Xamarin.Forms here
    is the call to `Forms.Init(this, bundle)`, which initializes the Android-specific
    portion of the Xamarin.Forms framework. Next is a call to `LoadApplication(new
    App())`, which starts our Xamarin.Forms application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppDelegate.cs` in the `HelloForms.iOS` iOS project -- very similar to Android,
    except iOS applications start up using a `UIApplicationDelegate` class. `Forms.Init()`
    will initialized the iOS-specific parts of Xamarin.Forms, and just as Android''s
    `LoadApplication(new App())`, will start the Xamarin.Forms application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and run the iOS project; you should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Hello World in Xamarin.Forms](img/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you run the Android project, you will get a UI very similar to the iOS one
    shown in the following screenshot, but using native Android controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Hello World in Xamarin.Forms](img/image00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though it's not covered in this book, Xamarin.Forms also supports Windows
    Phone, WinRT, and UWP applications. However, a PC running Windows and Visual Studio
    is required to develop for Windows platforms. If you can get a Xamarin.Forms application
    working on iOS and Android, then getting a Windows Phone version working should
    be a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the architecture behind Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting started with Xamarin.Forms is very easy, but it is always good to look
    behind the scenes to understand how everything is put together. In the earlier
    chapters of this book, we created a cross-platform application using native iOS
    and Android APIs directly. Certain applications are much more suited for this
    development approach, so understanding the difference between a Xamarin.Forms
    application and a *classic* Xamarin application is important when choosing what
    framework is best suited for your app.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms is an abstraction over the native iOS and Android APIs that you
    can call directly from C#. So, Xamarin.Forms is using the same APIs you would
    in a *classic* Xamarin application, while providing a framework that allows you
    to define your UIs in a cross-platform way. An abstraction layer such as this
    is in many ways a very good thing, because it gives you the benefit of sharing
    the code driving your UI as well as any backend C# code that could also have been
    shared in a standard Xamarin app. The main disadvantage, however, is a slight
    hit in performance that might make it more difficult to create a perfect, buttery-smooth
    experience. Xamarin.Forms gives the option of writing **renderers** and **effects**
    that allow you to override your UI in a platform-specific way. This gives you
    the ability to drop down to native controls where needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the differences between a Xamarin.Forms application and a traditional
    Xamarin app in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the architecture behind Xamarin.Forms](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In both applications, the business logic and backend code of the application
    can be shared, but Xamarin.Forms gives an enormous benefit by allowing your UI
    code to be shared as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, Xamarin.Forms applications have two project templates to choose
    from, so let''s cover each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Xamarin.Forms Shared**: Creates a shared project with all of your Xamarin.Forms
    code, an iOS project, and an Android project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin.Forms Portable**: Creates a **Portable Class Library** (**PCL**)
    containing all shared Xamarin.Forms code, an iOS project, and an Android project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options will work well for any application, in general. Shared projects
    are basically a collection of code files that get added automatically by another
    project referencing it. Using a shared project allows you to use preprocessor
    statements to implement platform-specific code. PCL projects, on the other hand,
    create a portable .NET assembly that can be used on iOS, Android, and various
    other platforms. PCLs can't use preprocessor statements, so you generally set
    up platform-specific code with interface or abstract/base classes. In most cases,
    I think a PCL is a better option, since it inherently encourages better programming
    practices. See [Chapter 3](part0031.xhtml#aid-TI1E2 "Chapter 3. Code Sharing Between
    iOS and Android"), *Code Sharing between iOS and Android*, for details on the
    advantages and disadvantages of these two code-sharing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Using XAML in Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to defining Xamarin.Forms controls from C# code, Xamarin has provided
    the tooling for developing your UI in **Extensible Application Markup Language
    (XAML)**. XAML is a declarative language that is basically a set of XML elements
    that map to a certain control in the Xamarin.Forms framework. Using XAML is comparable
    to using HTML to define the UI on a webpage, with the exception that XAML in Xamarin.Forms
    is creating C# objects that represent a native UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how XAML works in Xamarin.Forms, let''s create a new page with
    different types of Xamarin.Forms controls on it. Return to your `HelloForms` project
    from earlier, and open the `HelloFormsPage.xaml` file. Add the following XAML
    code between the `<ContentPage>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and run the application on iOS; your application will look something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using XAML in Xamarin.Forms](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On Android, the application looks identical to iOS, except it is using native
    Android controls instead of the iOS counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using XAML in Xamarin.Forms](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In our XAML, we created a `StackLayout` control, which is a container for other
    controls. It can lay out controls either vertically or horizontally one by one,
    as defined by the `Orientation` value. We also applied a padding of 10 around
    the sides and bottom, and 20 from the top to adjust for the iOS status bar. You
    may be familiar with this syntax for defining rectangles if you are familiar with
    WPF or Silverlight. Xamarin.Forms uses the same syntax of left, top, right, and
    bottom values, delimited by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also used several of the built-in Xamarin.Forms controls to see how they
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Label`: We used this earlier in the chapter. Used only for displaying text,
    this maps to a `UILabel` on iOS and a `TextView` on Android.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Button`: A general purpose button that can be tapped by a user. This control
    maps to a `UIButton` on iOS and a `Button` on Android.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Entry`: This control is a single-line text entry. It maps to a `UITextField`
    on iOS and an `EditText` on Android.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Image`: This is a simple control for displaying an image on the screen, which
    maps to a `UIImage` on iOS and an `ImageView` on Android. We used the `Source`
    property of this control, which loads an image from a web address. Using URLs
    on this property is nice, but it is best for performance to include the image
    in your project where possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Switch`: This is an on/off switch or toggle button. It maps to a `UISwitch`
    on iOS and a `Switch` on Android.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stepper`: This is a general-purpose input for entering numbers using two plus
    and minus buttons. On iOS, this maps to a `UIStepper`, while on Android, Xamarin.Forms
    implements this functionality with two buttons.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are just some of the controls provided by Xamarin.Forms. There are also
    more complicated controls, such as the `ListView` and `TableView`, which you would
    expect for delivering mobile UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we used XAML in this example, you could also implement this Xamarin.Forms
    page from C#. Here is an example of what that would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, you can see where using XAML can be a bit more readable, and is generally
    a bit better at declaring UIs than C#. However, using C# to define your UIs is
    still a viable, straightforward approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using data-binding and MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be grasping the basics of Xamarin.Forms, but are wondering
    how the MVVM design pattern fits into the picture. The MVVM design pattern was
    originally conceived for use along with XAML and the powerful data binding features
    XAML provides, so it is only natural that it is a perfect design pattern to be
    used with Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover the basics of how data-binding and MVVM is set up with Xamarin.Forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Your Model and ViewModel layers will remain mostly unchanged from the MVVM pattern
    we covered earlier in the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your ViewModels should implement the `INotifyPropertyChanged` interface, which
    facilitates data binding. To simplify things in Xamarin.Forms, you can use the
    `BindableObject` base class and call `OnPropertyChanged` when values change on
    your ViewModels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any `Page` or control in Xamarin.Forms has a `BindingContext`, which is the
    object that it is data-bound to. In general, you can set a corresponding ViewModel
    to each view's `BindingContext` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In XAML, you can set up a data-binding by using syntax of the form `Text="{Binding
    Name}"`. This example would bind the `Text` property of the control to a `Name`
    property of the object residing in the `BindingContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In conjunction with data binding, events can be translated to commands using
    the `ICommand` interface. So, for example, the click event of a `Button` can be
    data-bound to a command exposed by a ViewModel. There is a built-in `Command`
    class in Xamarin.Forms to support this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data binding can also be set up with C# code in Xamarin.Forms using the `Binding`
    class. However, it is generally much easier to set up bindings with XAML, since
    the syntax has been simplified with XAML markup extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the basics, let's go through step-by-step and partially
    convert our `XamSnap` sample application from earlier in the book to use Xamarin.Forms.
    For the most part, we can reuse most of the Model and ViewModel layers, although
    we will have to make a few minor changes to support data-binding with XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new Xamarin.Forms application backed by a PCL, named
    `XamSnap`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create three folders in the `XamSnap` project named `Views`, `ViewModels`,
    and `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the appropriate `ViewModels` and `Models` classes from the `XamSnap` application
    from earlier chapters; these are found in the `XamSnap` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project, just to make sure everything is saved. You will get a few
    compiler errors, which we will resolve shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first class we will need to edit is the `BaseViewModel` class; open it
    and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we removed the calls to the `ServiceContainer` class, because
    Xamarin.Forms provides its own IoC container called the `DependencyService`. It
    functions very similarly to the container we built in the previous chapters, except
    it only has one method, `Get<T>`, and registrations are set up via an assembly
    attribute that we will set up shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we removed the `IsBusyChanged` event in favor of the `INotifyPropertyChanged`
    interface that supports data binding. Inheriting from `BindableObject` gave us
    the helper method, `OnPropertyChanged`, which we use to inform bindings in Xamarin.Forms
    that the value has changed. Notice we didn't pass a `string` containing the property
    name to `OnPropertyChanged`. This method is using a lesser-known feature of .NET
    4.0 called `CallerMemberName`, which will automatically fill in the calling property's
    name at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s set up the services we need with the `DependencyService`. Open
    `App.xaml.cs` in the root of the PCL project and add the following two lines above
    the namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `DependencyService` will automatically pick up these attributes and inspect
    the types we declared. Any interfaces these types implement will be returned for
    any future callers of `DependencyService.Get<T>`. I normally put all `Dependency`
    declarations in the `App.cs` file, just so they are easy to manage and in one
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s modify `LoginViewModel` by adding a new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use this shortly for data-binding the command of a `Button`. One last
    change in the view model layer is to set up `INotifyPropertyChanged` for `MessageViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, you could repeat this pattern for the remaining public properties
    throughout the view model layer, but this is all we will need for this example.
    Next, let''s create a new `Forms ContentPage Xaml` file named `LoginPage` in the
    `Views` folder. In the code-behind file, `LoginPage.xaml.cs`, we''ll just need
    to make a few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We did a few important things here, including setting the `BindingContext` to
    our `LoginViewModel`. We set up the `LoginCommand`, which basically invokes the
    `Login` method and displays a message if something goes wrong. It also navigates
    to a new page if successful. We also set the `Title`, which will show up in the
    top navigation bar of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open `LoginPage.xaml` and we''ll add the following XAML code inside `ContentPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will set up the basics of two text fields, a button, and a spinner, complete
    with all the bindings to make everything work. Since we set up `BindingContext`
    from the `LoginPage` code-behind file, all the properties are bound to `LoginViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create `ConversationsPage` as a XAML page just like before, and edit
    the `ConversationsPage.xaml.cs` code-behind file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we repeated a lot of the same steps. The exception is that we
    used the `OnAppearing` method as a way to load the conversations to display on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the following XAML code to `ConversationsPage.xaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used `ListView` to data-bind a list of items and display
    on the screen. We defined a `DataTemplate` class, which represents a set of cells
    for each item in the list that the `ItemsSource` is data-bound to. In our case,
    a `TextCell` displaying the `Username` is created for each item in the `Conversations`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we must return to the `App.xaml.cs` file and modify the
    startup page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We used a `NavigationPage` here so that Xamarin.Forms can push and pop between
    different pages. This uses a `UINavigationController` on iOS, so you can see how
    the native APIs are being used on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, if you compile and run the application, you will get a functional
    iOS and Android application that can log in and view a list of conversations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using data-binding and MVVM](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of Xamarin.Forms and how it can be very
    useful for building your own cross-platform applications. Xamarin.Forms shines
    for certain types of apps, but can be limiting if you need to write more complicated
    UIs or take advantage of native drawing APIs. We discovered how to use XAML for
    declaring our Xamarin.Forms UIs and understood how Xamarin.Forms controls are
    rendered on each platform. We also dived into the concepts of data-binding and
    how to use the MVVM design pattern with Xamarin.Forms. Last but not least, we
    began porting the `XamSnap` application from earlier in the book to Xamarin.Forms,
    and were able to reuse a lot of our existing code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the process of submitting applications to
    the iOS App Store and Google Play. Getting your app into the store can be a time-consuming
    process, but guidance from the next chapter will give you a head start.
  prefs: []
  type: TYPE_NORMAL
