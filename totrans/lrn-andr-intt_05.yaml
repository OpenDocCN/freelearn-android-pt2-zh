- en: Chapter 5. Data Transfer Using Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have learned the classification of intents, their uses in Android
    Components, and a step-by-step guide to implement them in your Android application.
    This is the right time to look at the most important part of an Android application.
    It is the necessity of an Android application to transfer data from one activity
    to another (whether implicit or explicit). The secure transfer and retrieval of
    data is the prime focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The need to transfer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer between activities – an *INTENTed* way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer in explicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods of explicit data transferring using intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer in implicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the need to transfer data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, an Android application is a combination of different activities.
    These activities consist of layouts, views, and some content. These contents are
    mostly not dynamic nor are they predecided. For example, if an Android layout
    consists of a button, the text in that button can be static or predefined. Similarly,
    if there is any text field or any List View present in an activity, it mostly
    consists of dynamic data that comes from any server or any other means.
  prefs: []
  type: TYPE_NORMAL
- en: In these kinds of situations, we need some dynamic data that our application
    can fetch from the server (or somewhere else), and activities to transfer it between
    one another. This is the scenario in which the transfer of data takes place. Furthermore,
    the transfer of data is highly probable, where one activity performs some manipulation
    on the data and the other activity needs to show it in its Views.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to have a better understanding of the picture, let's take a theoretical
    example of why we need to perform data transfer between activities. The Reader
    application can be a good example to understand the reasons for data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: The Reader application is an application in which there are different kinds
    of news present in a List View, and tapping them leads to the description page
    where the whole news is displayed with images and other texts. Let's have a step-by-step
    look at the flow of this application (taking the TechCrunch Android app as an
    example).The application will start with a splash screen, describing to the reader
    or the developer who made the app.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot is the splash screen; the application will search for
    an Internet connection in order to display the feeds to the app's screen. Once
    the data is locally fetched, it parses it and places it inside the List View.
    Please note that the following screenshot of the List View is basically the custom
    List View that is not directly obtained by a built-in layout of Android. We need
    to make a custom layout for this and then populate it in the normal List View.
    For this, adapters are used (refer to the Internet in order to find how the basic
    List Views are created in Android).
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a simple example](img/9639_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity of the Reader app in which the news are listed in the List View.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are two possibilities of data transfer that are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whole data including the description is fetched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the feed on the List View is clicked on, the description of that feed is
    fetched at that particular moment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Taking a simple example](img/9639_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity showing the description of the story as it was tapped in the preceding
    Activity
  prefs: []
  type: TYPE_NORMAL
- en: No matter what the case is, this step will require the data to be transferred
    from the first activity to the next activity. If the scenario is the first one,
    the description data that was parsed by the first activity will be delivered to
    the second activity in order to populate it in the View. Otherwise, in case of
    the second scenario, it will pass some URL to the second activity from where it
    can fetch the description of the news. Refer to the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer between activities – an INTENTed way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about data transfer between activities, we need to keep in mind
    that the only way to interact and manage the flow of the activities is through
    intents. In the previous chapter, we had a thorough discussion on how to move
    from one activity to the other using intents. Here, we will see how we can transfer
    data along with those intents and how to securely catch the transferred data in
    the destination activity.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer in explicit intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can begin to understand data transfer in intents by noticing its use in
    explicit intents. Recalling the definition of explicit intents, they are intents
    that direct towards another activity (within that application or another application).
    Explicit intents are usually directed to activities within the same application,
    but based on the application requirement, they can also be directed to activities
    belonging to other applications (for example, a device camera).
  prefs: []
  type: TYPE_NORMAL
- en: Methods of data transfer between activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will get started with the various data transfer techniques
    that are used in an Android application. The techniques have their own pros and
    cons. There are a total of three methods to transfer data explicitly from one
    activity to another. We will see them shortly along with their examples. The three
    methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer using `putExtras()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer using `Parcelable` (only applicable to custom data objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer using `Serializable` (only applicable to custom data objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer using putExtras()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android, the simplest way to transfer data from one activity to another is
    by sending it through extras. The intent extras support primitive data types to
    send the data. This means that you can send the data in the form of different
    data types such as `String`, `Boolean`, `Integer`, or `Float`.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically explaining, intent extras can be found inside the `Intent` class
    in the Android API. Developers need to make an object of the `Intent` class. This
    would be the same object that will be used in order to navigate through the activity.
    With this object, there will be multiple polymorphs of the `putExtras()` function.
    These polymorphs take different data types (as described earlier) as arguments
    and load the intent object with that data. With this, the object is finalized.
    Now, calling the `startActivity()` method from the `Activity` class starts the
    execution of the intent.
  prefs: []
  type: TYPE_NORMAL
- en: That was one side of the picture. This intent takes the flow of application
    towards the second activity; it's an activity of the same application in the case
    of an explicit calling, or it can be some other application in the case of an
    implicit intent. This new activity will receive the intent object and extract
    the data from it. From this, there is another method referred to as `getExtras()`
    that is present in the `Intent` class. As a result, it will give all the extras
    that were added by the source activity in the intent object, and using this, we
    can easily extract the desired data present in the extras of the intent.
  prefs: []
  type: TYPE_NORMAL
- en: This theoretical explanation may not make you understand each and everything
    of the data transfer using intent. We will learn more about data transfer using
    intents through examples in the next section, in which a step-by-step explanation
    of the data transfer will be given.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of putExtras()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will study a step-by-step implementation of how to transfer
    data from one activity to another with the help of extras. As you may have previously
    read, this method is the simplest of all when considering data transferring between
    activities. In order to understand the working and implementation of this method,
    you must understand the activity life cycle, handling of different activities,
    and the implementation of intents in order to navigate between activities as prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: In order to begin with the first example, the first step is to make an Android
    project. The steps for making a project in the Android Studio are described in
    the previous chapters; you may refer to them if you want. You will end up making
    a project with various numbers of files and folders (as it comes by default with
    the Android project).
  prefs: []
  type: TYPE_NORMAL
- en: Implement a readymade tutorial
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the sake of simplicity, we are using the name `Activity1` for the source
    activity and `Activity2` for the destination activity. Now, follow the given steps
    in order to successfully implement the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new Android project or choose any existing project in which
    you want to implement the data transfer with intents. Implement the following
    code inside your newly created project in their respective classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project and the following screenshot will appear on the screen:![Implement
    a readymade tutorial](img/9639_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Acivity1.java layout for taking input from the user for PutExtra()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill the `EditText` fields and tap the button to transfer the data. The `Activity2`
    screen will appear with the form data that was entered in the `Activity1` screen:![Implement
    a readymade tutorial](img/9639_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view of the Activity2.java file, which shows that the data is successfully
    caught and showed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Understanding the code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous subsection, *Implement a readymade tutorial*, consists of five
    parts that we will see in detail in the following sections. Like every example
    presented in this book, we have described this example with respect to a new project
    in order to make it flexible and easy to understand. You can easily put this example
    inside your own application; it will not take any extra effort to do it once you
    have a proper understanding of the intent extras.
  prefs: []
  type: TYPE_NORMAL
- en: The Activity1.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Getting started, this is the source activity that will initiate the intent in
    order to navigate to the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple activity that is built when the new Android project is created.
    Recalling the basics, it will have an `onCreate()` method that will be executed
    in the first place when the activity is created by Android. Once the activity
    is created, the layout that is defined in the `main_first.xml` file in the `Layout`
    folder will be rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to get the objects of all the `EditText` fields that are placed
    in the layout file. For this, we will add the following lines in the code which
    will find the View by ID and return the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good to use meaningful names for your objects. Since this book is meant
    for beginners who don't normally work on huge applications, the object names are
    given to make the code as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findViewById()` method belongs to the `Activity` class, whose purpose
    is to find the particular View that can be the child of any layout and return
    the object. Similarly, we will get the other two `EditText` objects by writing
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, we have the objects of all the input fields that are present
    in the `Activity1.java` class. The next step is to implement the functionality
    of the button that will take the input from these fields, add them into the object
    of intent, and send it through.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The return type of the `findViewById()` method is an object of the `View` class.
    So, while using `findViewbyId()`, we need to cast the returning object into a
    particular class type. For understanding this, you can see that the View is being
    casted to `EditText` in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the next step is to implement the `OnClickListener()` method on the button.
    For this, the first step is to get the object of the button using a method similar
    to the one used in the input fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get the button object, we will implement the `setOnClickListener()`
    method with an argument, `OnClickListener()` and its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding line of code, we have attached an `OnClickListener()`
    object with `transferButton` along with its own `setOnClickListener` method. Keep
    in mind that it is still a raw method. It is now time to override the `onClick()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, you can see that the definition of the `onClick()` method
    is given, and inside this method, we will get the data from the `EditText` fields
    and put it in the intent extras. As described in the code, the data is fetched
    from the `EditText` field by calling these lines on every `EditText` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will get the current value present in the input field. We get the values
    of all the `EditText` fields and store them in `valueOne`, `valueTwo`, and `valueThree`
    consecutively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have the data that is to be put inside the intent object, we make
    an object of the intent using the previously described method. We set the source
    and destination activities (that is, `Activity1.java` as the source and `Activity2.java`
    as the destination). The next step is to pass the values inside the code. The
    `Intent.putExtra(String name, String data)` method is the most suitable one to
    put the string value in extras.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments of `putExtra()` is somewhat like the key-value pairs. The first
    argument, `name`, is basically the key by which it will be identified once it
    reaches the destination activity. The other one is simply the value that is to
    be transferred in the extra associated with that key. So, by following line, we
    put the string inside an intent object with a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that the value of the first `EditText` field is placed inside the intent
    object with the key of `EDITTEXT_ONE_VALUE`, we repeat this information for the
    other two values. Once the values are loaded in the intent object, we call the
    `startActivity()` method to execute the intent.
  prefs: []
  type: TYPE_NORMAL
- en: The Activity2.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the destination class in which the incoming intent will be handled.
    This class contains a simple layout file with three `TextView` Views in order
    to show the values coming from the previous activity. In the `onCreate()` method
    the intent is received by the `getIntent()`method. This method belongs to the
    `Activity` class and is used to get the intent which will be navigating to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a method inside the `Intent` class which is used to get all extras
    that are coming with that particular intent object. The following method is used
    to identify a particular set of data coming with the described key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The value associated with the key, `EDITTEXT_ONE_VALUE`, will be extracted from
    the intent object, and saved into the `valueOne` string. Similarly, all the data
    will be taken out of the intent object and saved in this destination class.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is saved in the variables, it is time to get the objects of the
    `TextView` Views and set these values to it. As previously explained, the `TextView`
    Views are obtained using the `findViewById()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `setText()` method is used to set the text in `TextView`, and hence, it
    is saved by the value that is coming from the first activity. This is how the
    destination activity will get the data from the source activity using the `putExtras()`
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: The main_first.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The main_first.xml file is a simple XML file that contains three `EditText`
    fields used by the activity to take input from. Furthermore, it also has a button
    that is used to trigger the event in order to navigate to the next activity. The
    IDs for these Views are given as `edittext1`, `edittext2`, `edittext3`, and `button1`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can make your desired layout file by dragging and dropping it in the GUI.
    The XML code of the layout file is simple, and explained in the previous chapters
    as well. But, keep in mind that *drag-and-drop is not recommended* especially
    for the new Android developers; so, the best way to implement it is via an XML
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The main_second.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the layout file for the second activity that is actually the destination
    and the data-receiving activity. The layout consists of the three `TextView` Views
    that are used to show `valueOne`, `valueTwo`, and `valueThree` as sent from `Activity1`,
    that is, the source activity.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `AndroidManifest.xml` file is the fundamental part of an Android application.
    It keeps track of the whole structure of the application. It contains all the
    activities, receivers, permissions, version-related issues, minimum and maximum
    SDK, and many other things. As we have two activities in our project, `Activity1`
    and `Activity2`, the `AndroidManifest.xml` file has these activities as also different
    things such as the application version name and the version code in the XML tags.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No special permission is required to send the data from one activity to another,
    but in case of data writing and reading on the SD Card or internal memory, we
    do need certain permissions to fulfill the task.
  prefs: []
  type: TYPE_NORMAL
- en: Future considerations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sending data through parcels is one of the basic techniques that is used by
    Android intents. It has many more improvements and efficient enhancements that
    we will further study in the following methods of data transferring. We should
    also keep in mind that this method is restricted to certain limited data types
    (given in the next section). In order to transfer the custom object from one activity
    to another, we need to use the next method of data transferring.
  prefs: []
  type: TYPE_NORMAL
- en: Extras supported data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Intent''s `putExtra()` method supports various data types that can be transferred
    to the destination activity. In the previous example, we used only one data type
    (`String`), but along with that, we can add various other data types. The methods
    are self-explanatory apart from `putParcelable()` and `putSerializable()`, which
    are the next major topics of this chapter. Take a look at the following screenshot
    showing the various data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extras supported data types](img/9639_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different data types that can be added inside the putExtras() intent
  prefs: []
  type: TYPE_NORMAL
- en: The concept of Android Bundles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android data Bundle is a bundle in which various values can be added and
    sent together. For example, if we want to send multiple values via `putExtra()`,
    we create a Bundle, add all of those values inside that Bundle, and then send
    this Bundle with the `intent.putExtras()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can provide data directly to the intent by adding all the values individually
    to the intent, or the second method is to do it by adding all the values in the
    Bundle and sending it through the intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now take a look at how it is possible to provide data to the Bundle
    and send this Bundle to the next activity, by taking the previous activity and
    modifying it a little. While sending data from `Activity1`, instead of adding
    different values directly to the intent, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The concept of Android Bundles](img/9639OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you see in the code, `valueOne`, `valueTwo`, and `valueThree` are added inside
    the Bundle using the `newBundle.putString()` function with a unanimous key for
    each data value. Now, this Bundle is added inside the intent using the `intent.putExtras(newBundle)`
    function, and then we call the `startActivity()` function as it was called in
    the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the destination activity, we can directly catch the data by extracting the
    data bundle first using the `getIntent().getExtras()` function. This will return
    the Bundle object, and by referencing that specific key (that we added in the
    source activity), we can extract the data using following function for all the
    three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second parameter in `Bundle.getString(key, defaultValue)` is the default
    value that will be returned if the value of the specified key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot. You will see the different data types
    that can be simultaneously added into a Bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The concept of Android Bundles](img/9639_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different functions that are used to add different data types inside a Bundle
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer using Parcelable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second and the most important method that is used to transfer data between
    activities is `Parcelable()`. The previous method has a restriction according
    to which we can only send the primitive data types such as `Strings`, `Integers`,
    `Doubles`, and `Floats`. In a practical scenario, when we work on projects, there
    are custom objects that we need to transfer between activities. These custom data
    objects hold information according to the need of the application. Hence, it should
    be transferred accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: As it is now clear that the previous version is for the data transfer of basic
    data types only, Parcelable can be called as the subtype of the previous type.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, the data class is inherited by implementing the `Parcelable`
    class interface in order to make its object compatible with the `putExtra()` intent
    method. We also need to override some of the methods from the `Parcelable` class
    interface in order to give it the functionality. Once it is done, the object of
    that class can be placed inside the intent or the Bundle to navigate it through
    the activities.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of Parcelable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to implement `Parcelable` on a data class
    and then how to transfer that object between activities. There are two scenarios
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one object is being sent from the source class to the destination class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of the custom objects is being sent from the source class to the destination
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the tradition, we will start by creating a new Android project. In the
    given example, we call it the Parcel application. This project has `Activity1.java`
    as the default activity that will be created when the project is newly created.
    It will also behave as the source activity. The second activity will be `Activity2.java`
    that will act as the destination activity that will receive the parcel.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a readymade tutorial
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we are done with making a new project, insert this code inside your application
    This will affect `Activity1.java`, `Activity2.java`, `layout_activity1.xml`, `layout_activity2.xml`,
    and `AndroidManifest.xml`, and introduce another class named `Person.java`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this application and it will bring the `Activity1` output screen on your
    device. Take a look at the following screenshot to see how the application will
    appear on the Android screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implement a readymade tutorial](img/9639_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity1 with three EditText fields in order to take the input from the user,
    and a button to transfer the data to the next activity
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are on the first screen, enter the data and press the button to migrate
    to the next activity that will show the entered data. The screen will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implement a readymade tutorial](img/9639_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity2 showing the transferred data from Activity1 in the form of Parcelable
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Parcelable implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand the working of this example, we need to first understand
    how `Parcelable` works. In Android, there is a need to transfer custom data (that
    is, custom objects and arrays of custom objects) from one activity to another.
    Normally, the custom data classes are not compatible with the extras; so, we implement
    the `Parcelable` interface to that class.
  prefs: []
  type: TYPE_NORMAL
- en: What `Parcelable` does with the custom data class is that it develops compatibility
    with extras. The object or objects of the class implemented using `Parcelable`
    can be added easily inside the `putExtra()` method of the intent. Similarly, it
    can also be part of the Bundle object that can later be transferred via intents.
  prefs: []
  type: TYPE_NORMAL
- en: We can now go through the explanation of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The Activity1.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the source class from which the `Parcelable` object will start to migrate.
    It starts with the implementation of the `onCreate()` method. In this method,
    after setting the main View, we found Views by their IDs and brought their objects
    to the activity. The Views include three `EditText` fields and a button. They
    are used to take inputs from the user and trigger the event in order to start
    transferring the data to the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `button.setOnClickListener()` method, we pass a new `OnClickListener()`
    object inside which the `onClick()` method is overridden. We want the intent to
    start once the button is clicked; that is why we are implementing the intent and
    taking the data from the fields inside the `onClick()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we don''t want the method to directly transfer the data to the intent.
    That is why we are making an object of the `Person.java` class that will hold
    the values obtained from the fields. We name the object as `firstPerson`. In order
    to set the values to this object, we implement the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line will set the first name of that object to the value that
    is obtained from what is written inside the first `EditText` field. The first
    `EditText` field, `nameText`, holds the value of the first name. So, using the
    `nameText.getText()` method, it will return the `Editable` object that can be
    easily converted by calling the `toString()` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same method will be repeated in order to get the value from the second
    and the third `EditText` fields. They will be set inside the same `Person` object.
    You can see this being done using the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, the `firstPerson` object is ready to be delivered from `Activity1`
    to `Activity2`. As the object is inherited by implementing `Parcelable`, we can
    directly add it inside the extra. We will learn how to implement `Parcelable`
    in the forthcoming section. Here, we will see how to add `Parcelable` inside the
    intent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make an object of the `Intent` class and give it the source and destination,
    that is, the source context and `.class` reference of the destination class in
    order to let it know from where to initiate this intent and where to end. We can
    add the `Parcelable` by calling `parcelIntent.putExtra()`. See the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using this, we can easily add the custom `Parcelable` data object inside the
    intent object, and in the next line, simply call the `startActivity()` function
    in order to start the intent.
  prefs: []
  type: TYPE_NORMAL
- en: The Activity2.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this class, we will learn how to catch the transmitted `Parcelable` object
    in the destination class. For this, first of all, start with the normal procedure
    of implementing the `onCreate()` method of the activity. Set the Content View
    and bring in three text Views by finding the IDs from the layout. These three
    text views will show the received values of the first activity's object.
  prefs: []
  type: TYPE_NORMAL
- en: The `getIntent()` method will receive the intent object that was transmitted
    by the `Activity1.java` class that holds the data. Once the object is obtained,
    we can get its extras by calling the `getExtras()` method that will return the
    Bundle that holds the data. Call the `getParcelable()` function on that Bundle
    with the key in order to retrieve the object. This object is now taken by a new
    object of the `Person` class named `incomingPersonObj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the same object that was initiated from the source class at the
    time of calling the intent from `startActivity()`. We will now set the text of
    the text views by calling the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `incomingPersonObj.getFirstname()` method will get the first name of the
    person from `incomingPersonObj` and set its value directly to `nameTextView` when
    the first method is called. The procedure is the same for the `sirnameTextView`
    and `addressTextView` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The layout_activity1.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is the layout file that contains the Views of `Activity1.java`. As mentioned
    in the code, it contains three `EditText` fields with the IDs: `edittext_enter_name`,
    `edittext_enter_sirname`, and `edittext_enter_address`. Apart from that there
    are also three text Views which are used to simply indicate which `EditText` field
    contains which value.'
  prefs: []
  type: TYPE_NORMAL
- en: Every activity requires an event trigger that is used to start any process.
    In this layout, the button will do the task; hence, it is also placed below the
    `EditText` fields.
  prefs: []
  type: TYPE_NORMAL
- en: The layout_activity2.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This layout file creates the layout of `Activity2.java` that is the destination
    activity. This activity is responsible for extracting the data and showing it
    in its layout. The layout consists of three `TextView` Views whose IDs are `person_name_text`,
    `person_sirname_text`, and `person_address_text`. These IDs are used to bring
    these Views to the code (as you can see in the second part of the code).
  prefs: []
  type: TYPE_NORMAL
- en: The Person.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `Person` class is basically the data-holder class whose objects will be
    created anywhere in the application. This is also called the **bean class** that
    is used to hold the data coming from servers in JSON, XML, or any other format.
    In our `Person` class, it has three fields. All fields are private with their
    respective public getters and setters. The `firstName`, `sirName`, and `address`
    objects represent the kind of information they will hold. The `Activity1.java`
    class makes an object of this class, takes the data from the `EditText` fields,
    and adds it inside the object.
  prefs: []
  type: TYPE_NORMAL
- en: This class is inherited by implementing the `Parcelable` interface. This `Parcelable`
    interface needs some important things to be implemented. First of all, we will
    implement a constructor of this class that will take `Parcel` as an argument.
    This constructor will be used from inside this class while implementing the `Parcelable`
    interface. The `in.readString()` method is used to read the value from the parcel.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make this technique work, read the parcel in the same order in which
    it was written in the `writeToParcel()` method. See the order of writing the parcel
    in the code. It is `firstName`, `sirName,` and `address`. The same thing can be
    observed in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `writeToParcel()` method is overridden in order to produce objects of the
    same class by `Parcelable` so that it can be used. `Parcelable.Creator<Person>`
    is used to create instances of that class as used by `Parcel`; it uses the `writeToParcel()`
    method to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Once the object is prepared, it is then forwarded to the next activity and caught
    by the `Activity2.java` class as it is explained in the first and second parts
    of the given code.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The importance of this file cannot be neglected when you are talking about developing
    an Android application. We need to add both the activities in this file in order
    to get them recognized by the Android application. As you can see in the file,
    both activities have their own tags in the manifest file along with their parameters
    and intent filters.
  prefs: []
  type: TYPE_NORMAL
- en: Future Consideration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The preceding method of implementing `Parcelable` is for transferring only one
    `Parcelable` object inside the extras or a Bundle. Similarly, we can transfer
    an Array or ArrayList of the custom data beans by implementing `Parcelable`.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer using Serializable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third type of data transfer method that is used in intents is `Serializable`.
    Many Java developers are already familiar with the term `Serializable` as it was
    used earlier, way before the introduction of Android. The biggest advantage of
    Android is that its development takes place on Java in SDK, and on C++ it's in
    NDK. This makes it extremely lenient and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The same is the case with the functionality; `Java.io.Serializable` is purely
    a function of Java that can be used as it is in Android development. The `putExtras()`
    intent has an option of transferring the Java-serialized object from one activity
    to another without any specific amount of effort. We start this section with the
    introduction of `Serializable` for non-Java users.
  prefs: []
  type: TYPE_NORMAL
- en: What is Serializable?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java comes with a mechanism in which an object can be represented in a byte
    array. It's not just the data that is serialized, but the information about the
    object type and what kind of data is placed inside the object can also be found
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: These serialized objects can be written in the file and stored in any external
    storage (such as an SD Card). The process of remaking the object is called deserialization
    in which the information that is hidden inside the byte array can be gathered
    to regenerate the object in the memory at the time of need.
  prefs: []
  type: TYPE_NORMAL
- en: The process of making and remaking any serialized object is completely JVM independent.
    It means that the object can be serialized in Java and can be remade in any language
    that also supports JVM with the same Java version as at the time of making it
    serialized.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the `ObjectOutputStream` class is used to serialize the object while
    the `ObjectInputStream` class is used to make an object when we are regenerating
    from an existing serialized object. These classes contain the `writeObject()`
    and `readObject()` methods respectively. The methods actually start the process
    of serialization or deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: An example of Serializable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will see how `Serializable` is done in Java. This is the
    inside mechanism of how Android handles these objects. This example contains two
    methods to perform the tasks of serialization and deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the method for serialization is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of Serializable](img/9639OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Person` class implements the `Serializable` interface. This will enable
    the object to be recognized by the `ObjectOutputStream` class's object. First
    of all, we will create a serialized object as shown in the code by setting the
    name and address.
  prefs: []
  type: TYPE_NORMAL
- en: Once the object is created, it is ready to be serialized. We start by making
    an object of `FileOutputStream` that is used to write data into a file; the path
    that will refer to the location where that serialized file exists is also added.
    Make an `ObjectOutputStream` object that will have that file referenced by `ObjectOutputStream
    out = new ObjectOutputStream(fileOut)`. We are now ready to write the object by
    calling `out.writeObject(person)`. This will start to serialize the object (convert
    it to a byte array) and add it to the given location. We will then close the `out`
    and `fileOut` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading data from a serialized source is the next step that we will see. See
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of Serializable](img/9639OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code is simple to understand because it contains almost the same steps as
    those required for writing an object as a serialized file. We will create an instance
    of the `Person` class to hold the remade object. The `FileInputStream` object
    is created. It directs towards the location of the file that is to be deserialized.
    The `ObjectInputStream` object is used to get that file path and make it ready
    to be read. Using this, the `in.readObject()` method is called in order to deserialize
    the object, and it will return the `person` object. Once it is done, we will close
    the `in` and `fileIn` objects.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the object of the deserialized `Person` class which can be in log
    or printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The method of writing serializable objects in Java and Android are the same.
    While we are doing it in Android, we can write the file in an SD Card. The file
    can later be fetched and deserialized by any other activity or application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of Serializable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we have understood the main reasons of using `Serializable`. A quick
    review is always good. The `Serializable` technique is used to convert an object
    into byte array; we can use it to write into a file and store it as a `.ser` file
    on an SD card or any other storage. This serialized object can then be read from
    any location irrespective of the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Serializable` is the simplest method to perform data transfer. It is also
    used for transferring one or more custom data objects from one activity to another.'
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary for serialized files to always have the `.ser` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the other examples and implementations, we will start this by making
    a fresh project. This project will have two activities; one will be the source
    and the other will be the destination. The serialized object will start to navigate
    from one activity, and the destination activity will catch it in order to extract
    data from it. Android supports the native Java procedure of serializing and deserializing
    the object; that is why, we don't have to do anything because the phenomenon of
    serialization is handled by Android itself.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Serializable – a tutorial
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this chapter, the implementation of `Serializable` will start by making a
    new project. By default, this project will have one activity (let's say `Activity1.java`).
    Implement the following steps that will lead you to make a project in which `Serializable`
    is implemented. We will then see its explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the first step, implement the following code in your newly created
    Android project. This will introduce three new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Activity2.java`: This will act as the destination activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_activity2.xml`: This file will hold the layout for the destination
    activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Person.java`: This is the serialized class that is responsible for giving
    data beans'' objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with the implementation, run the project. The following screen
    will appear in which you need to add your data into the fields. Then click on
    the **Enter Data** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing Serializable – a tutorial](img/9639_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Source activity asking data to be entered to send it through serializable
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you press the **Enter Data** button, `Activity2.java` will be opened
    and the following screen will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing Serializable – a tutorial](img/9639_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity2 showing that the data is successfully entered
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, when you see the LogCat of the project, it will show the data that
    we logged in the `Activity2.java` file. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing Serializable – a tutorial](img/9639_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: LogCat showing the successful catching of data in Activity2
  prefs: []
  type: TYPE_NORMAL
- en: Walking through the Serializable code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to understand the working of Serializable in Android, you need to go
    through the previously described details of `Serializable` in Java. We recommend
    you to have a look at this if you haven't already done so. In this section, we
    will rather focus on the explanation of the preceding example and how to implement
    it in an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we have divided it into six parts. The explanation
    of each part is given in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Activity1.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `Activity1.java` class will act as the source activity from which the intent
    will initiate. It will also act as the source activity because it is responsible
    for creating and sending the custom data object. Let's start with the very first
    part of the code, which is the implementation of the `Activity1.java` class.
  prefs: []
  type: TYPE_NORMAL
- en: As it was mentioned earlier, this class is responsible for taking data inputs
    from the user and making a data object out of it. Inside the `onCreate()` method,
    we will first set a particular layout that holds the Views using the `setContentView()`
    method. Once the layout is set, our next task is to bring those Views as objects
    in our Java code, as shown in the following code. This will help us perform various
    tasks on those objects that are bound on those Views in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `findViewById()` function brings the particular View with which
    the ID is associated. We cast it to the `EditText` class, and take it inside the
    `edittext1`, `edittext2`, and `edittext3` objects respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'These three fields will be used to take the input from the user, but we need
    an event trigger that is used to navigate the user from one activity to another
    and is also responsible for data transferring. For that, we implement a button
    in the layout, and we will fetch it in the Java code by calling the `findViewById()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have all the necessary views in our Java code. Our next step is to
    implement the button functionality, that is, what it will do when it is clicked
    on. For that, we need to implement an `OnClickListener` interface on this button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code is responsible for setting the click listener on
    the button. It takes an argument of `OnClickListener` inside which we implement
    the `onClick()` method. This `onClick()` method will be responsible for assigning
    a job to the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are done with that, we will make an object of the `Person` class (the
    `Serializable` object) and set its values to the one that is obtained by taking
    the input from the `EditText` fields. Now, it has two parts; the first is to make
    a new object of the `Person` class. We will do this by calling its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part, we will get the values of the `EditText` object by calling
    the `getText()` method using that object. The `getText()` method returns an `Editable`
    object; so, in order to convert it into string, we call the `toString()` method
    on it. When you observe the code, we have performed all of these tasks together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the value from the `edittext1` object is brought and converted to `String`.
    Second, we are setting the person''s name by its value. We will further set `sirName`
    and `address` of the `person` object using a similar procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have an object that is ready to be transferred. We will now make an
    object of `Intent` and assign its source and destination activity''s contexts.
    It will represent which activity the intent is initiated and to which activity
    it will migrate. We will do this by calling the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once the intent object is made, we will add the data object inside this intent
    and call the `startActivity()` method. In order to put the serialized object in
    the intent object, we will call the `intent.putExtra()` method. The final step
    for this part is to call the `startActivity()` method that will initiate the process
    of navigation.
  prefs: []
  type: TYPE_NORMAL
- en: The Activity2.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The destination activity's main purpose is to catch the intent, extract data
    object from it, and show it in the Views. We start with the implementation of
    the `onCreate()` method. First, the layout is set by calling the `setContentView()`method
    of the `Activity` class. Now, it is time to catch the `intent` object that was
    initiated from the `Activity1.java` class.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the previous example in this chapter, we obtain the intent by calling
    the `getIntent()` function. This function returns an `intent` object that is used
    to launch this activity. Once the `intent` object is here, we call the `getExtras()`
    function. This will return a Bundle that contains all the extras that were added
    on this `intent` object by the sender activity.
  prefs: []
  type: TYPE_NORMAL
- en: On this Bundle, we will now call the `getSerializable()` method that will bring
    the `Serializable` object with the help of the `key` value that is given to it
    by the sender activity. That `key` value should be identical to that of the sender
    activity; otherwise, it will return a null value that may result in the crashing
    of your application due to `NullPointException`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Person` object is now in hand with all the values. Our next task is to
    log these values in the LogCat so that we can verify it. A null-pointer check
    is implemented in order to see whether or not the object is null. If it is not
    null, we log its values by getting it from `person.getName`, `person.getSirName`
    and `person.getAddress`. If the object is null, it will say `Data Object is null`,
    and hence, it will not crash.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Person.java class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When we talk about transferring data from `Serializable`, the `Person.java`
    class is the most important class that we need to implement in order to do the
    transferring. We made a Java class that consists of three private string variables.
    Each one of them has its own getter and setter functions in order to get and set
    the value from outside of the class. As in the previous method, we implemented
    our data bean class using the `Parcelable` interface; here, we will implement
    our class with `Serializable`.
  prefs: []
  type: TYPE_NORMAL
- en: Once it is implemented, Android is ready to treat the objects of this class
    as `Serializable`. Now, whenever it is added inside the intent object, Android
    will transfer it as a byte array. This is a slow process as compared to `Parcelable`,
    but its slowness is not noticeable when we do it on few objects. If we want to
    apply this method where there are thousands of data objects, it may take some
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The layout_activity1.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The layout file belongs to the `Activity1.java` class. When you run the code
    for the first time, the layout that will appear is described in this layout file.
    In the `Activity1.java` class inside the `onCreate()` method, we used the `setContentView()`
    method in order to paste the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this XML file, there are four Views; three of them are `EditText` fields
    that are placed to take input from the user in Activity1\. Apart from that, there
    is a button that is used to trigger an event after the data is completely filled
    in the fields. The IDs given to them are the default ones that were used by the
    `Activity1.java` class to fetch these Views inside the `.java` class, and `edittext1`,
    `edittext2`, and `edittext3` are the IDs for their respective fields.
  prefs: []
  type: TYPE_NORMAL
- en: The layout_activity2.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This layout file contains the Views for the `Activity2.java` class. It consists
    of one `TextView` View that will tell us whether or not the values coming from
    the `Activity1.java` class have been correctly fetched. This text View will then
    show the **Data successfully caught** or **Data object is null** message in accordance
    with the data object.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `AndroidManifest.xml` file consists of all the activities, permissions,
    SDK information, version codes, and many other things. In short, it is used to
    keep all the information regarding the applications. In this, we have our activities,
    `Activity1.java` and `Activity2.java` classes along with their intent values.
    If you forgot to mention any of your activity in this file, it will produce an
    exception in the LogCat saying `ClassNotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Parcelable` and `Serializable` are two methods used to transfer data objects
    from one activity to another. `Serializable` is the simplest one to implement
    while `Parcelable` is the fastest of all. In case you need to perform a task based
    on fewer objects and you want a simple solution, you should go for `Serializable`.
    But if you want a perfect method irrespective of the complexity of the implementation,
    you should go for `Parcelable`.'
  prefs: []
  type: TYPE_NORMAL
- en: Data and the implicit intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, the need of data transfer was described within an
    application. It is now very clear that any application is incomplete without the
    transfer and manipulation of data. In this section of the chapter, we will see
    the scenarios in which there is a need to transfer data to implicit intents.
  prefs: []
  type: TYPE_NORMAL
- en: Recalling the definition of implicit intents, they are those intents that normally
    do not direct towards a specialized target rather they give the flow of the application
    to an outside application, or in other words, they start another activity in order
    to perform a certain task.
  prefs: []
  type: TYPE_NORMAL
- en: The outside applications require some data from your application in order to
    perform tasks. We will now see the scenarios in which the data transfer in the
    form of URI is passed to the implicit intent.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Map can be initiated from your own application with a particular place.
    It means that you can send any location that you need to open in the Google Map
    via implicit intents. Based on the latitude and longitude, you can open a particular
    point in the Google Map. This latitude and longitude is given to the Google Map
    using a URI that is a way to send data to implicit intents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform this task, we need to write the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a map](img/9639OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a particular syntax according to which we need to write the URI string.
    In order to open the map with a particular location, the URI string consists of
    the `geo` keyword followed by the latitude and longitude (comma separated as shown
    in the code). This URI value is given to the implicit intent with the `android.content.Intent.ACTION_VIEW`
    action. This View action will take the URI and open the best available application
    to perform the task. We will then start the intent by calling the `startActivity(intent)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a map](img/9639_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Google Map View in an Android OS.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a webpage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implicit need of transferring data can also be categorized in case you want
    to open a webpage, where you need to open the default web browser with a particular
    loaded page . In this process, we need to transfer the URL that our application
    wants to open in the browser. This URL is also passed with the help of the `Uri.parse()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that we are using the default web browser in this scenario. It
    is not the web View that comes as a part of an Android application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following lines of code in order to send and open the URL in
    the default web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening a webpage](img/9639OS_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the code, there is a string that contains the value (URL)
    that is to be opened in the web browser. This value is then entered in the constructor
    of the intent in the `Uri.parse()` function with an `Intent.ACTION_VIEW` action.
    This will choose the best available option to open the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening a webpage](img/9639_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The view of a browser opening the Google.com webpage as called from our application
  prefs: []
  type: TYPE_NORMAL
- en: Sending an e-mail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a probability that you need a function that needs to call the default
    Google Mail application with a particular typed e-mail and a particular recipient
    in your application. In this case, we again need to add the data, that is, the
    sender name, e-mail body, and e-mail subject into the intent object and start
    the activity with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform this task, we need to write the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending an e-mail](img/9639OS_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make an `Intent` object with the `Intent.ACTION_SEND` action. Its work is to
    open the intent with the sending option. Now, it's time to add the data inside
    this object. The Android API caters to all the scenarios that can occur; hence,
    there are certain constants defined in the `Intent` class that can be used to
    uniquely identify the data by Android. `Intent.EXTRA_EMAIL` is the keyword constant
    that is used in the `putExtra()` method while you are giving an e-mail address
    to the intent. Similarly, there is a keyword constant for mentioning the subject
    in the extras; `Intent.EXTRA_SUBJECT` and `Intent.EXTRA_TEXT` will be used to
    add the body of the e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we call the application with these parameters, it will open Gmail with
    these parameters filled in the fields. It will look something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending an e-mail](img/9639_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A view of the Gmail application as called by our application
  prefs: []
  type: TYPE_NORMAL
- en: Making a call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to initiate a call with a certain number inside your application,
    you need to call the dialer intent. Using `Intent.ACTION_DIAL`, you can provoke
    the dialer intent with a particular number given as the URI. Follow the given
    code to implement the dialer functionality in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a call](img/9639OS_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The URI string contains the telephone number with which the dialer should initiate.
    Once the dialer is opened, it will show the number as it is written, and the user
    can now dial that number.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various other scenarios that can be included in this chapter (such
    as calendar and time widgets), but due to limited space and constraints, we have
    taken only four scenarios into consideration. The implementation of data transferring
    between implicit intents is of extreme significance and can be done with great
    ease.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a detailed learning of how to play with data inside
    an Android application. We learned how to transfer data from one activity to the
    other using different methods and the simple transfer of default data structures
    using the `putExtra()` function of Intent. The custom data objects or the array
    of custom data objects can be sent to another activity using `Parcelable` and
    `Serializable`. We also learned how to implement all these kinds of data-transferring
    methods in our Android application. At the end of the chapter, we briefly covered
    four scenarios in which the data is sent to other applications (using implicit
    intents) when calling them through intents from our application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is of great importance with respect to practical application development
    because transferring data between activities or even outside the application is
    a fundamental part of any Android application, and this can easily be done using
    Android intents.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will study the use of intents for accessing the
    Android features. We will also see how the intent filters work, what are the basics
    of the broadcasting intents, and at the end, we will see the implementation of
    intent service and pending intents.
  prefs: []
  type: TYPE_NORMAL
