- en: Chapter 8. Broadcasting Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about intent filters and how these filters
    provide information about different activities, services, and so on, to the Android
    OS. We also discussed how intent filters work and how they match the coming intent
    object with attributes. This chapter also provides information on action, data,
    and category tests.
  prefs: []
  type: TYPE_NORMAL
- en: Intents are the asynchronous way of sending messages between different components
    of the Android OS. So far, we have only learned to send and receive those messages,
    that is, the intents from one component to another component. But in each of the
    examples we discussed, we had the information about the receiver of the intent,
    such as which activity or service will receive the intent and will use the data
    embedded in the intent.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be extending our knowledge of sending intents to multiple
    broadcast receivers. We will learn how intents are broadcasted by the Android
    OS and how these broadcast intents are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting in the Android OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcast intents in the Android OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System broadcasts in the Android OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the different system broadcasts of the Android OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the battery-low broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the screen `On`/`Off` broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the cell phone reboot completed broadcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending/receiving custom broadcast intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of intents and the structure of intents, as discussed in [Chapter
    2](ch02.html "Chapter 2. Introduction to Android Intents"), *Introduction to Android
    Intents* and [Chapter 3](ch03.html "Chapter 3. Intent and Its Categorization"),
    *Intents and Its Categorization* are the prerequisites for understanding this
    chapter and the further chapters. If you don't have the basic concepts of these
    things, we would recommend that you read [Chapter 3](ch03.html "Chapter 3. Intent
    and Its Categorization"), *Intents and Its Categorization* and [Chapter 4](ch04.html
    "Chapter 4. Intents for Mobile Components"), *Intents for Mobile Components* in
    order to move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting in the Android OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any smartphone running Android OS has a lot of services and actions being executed
    at a particular time. These services and actions can be in the foreground or in
    the background. So the question that comes in our mind here is what these services
    and actions are actually doing. The answer is very simple. These services and
    actions are looking or listening for some events to occur, or performing some
    long operation in the background, or communicating with other components of Android
    OS, and so on. You might be wondering how these components listen for the occurrence
    of any event or how they communicate with other components, especially in background
    when user can't interact with the application directly. In the Android OS, these
    types of tasks are achieved by broadcasting. The Android OS continuously broadcasts
    the information about different actions, such as whether power has been connected
    and Wi-Fi has been turned on. We, the developers, use this broadcast information
    in our apps to make our apps more interactive and smart. In the next section,
    we will see how the Android OS broadcasts different information.
  prefs: []
  type: TYPE_NORMAL
- en: The broadcast intents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The broadcast intents are the `Intent` objects that are broadcasted via a method
    call to the `sendBroadcast()`, `sendStickyBroadcast()`, or `sendOrderedBroadcast()`
    methods of any `Activity` class. These broadcast intents provide a messaging and
    event system between different application components. Also, these intents are
    used by the Android OS to notify interested applications about system events such
    as low battery or whether headphones have been plugged in. To create an instance
    of the broadcast intent, we must include an action string in it. An action stringis
    used to identify the broadcast intent, and it is unique. This action string typically
    uses the Java package name format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will create an instance of the broadcast
    intent and broadcast it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The broadcast intents](img/9639_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding code that there is no special class named `BroadcastIntent`.
    It is an ordinary `Intent` object. We have used these `Intent` objects in methods
    such as `startActivity()` or `startService()`. This time we have passed these
    `Intent` objects in the `sendBroadcast()` method of the `Activity` class. We have
    set its action string by calling the `setAction()` method. As discussed earlier,
    we have used the package-name format in the `setAction()` method. To broadcast
    any intent, we have used the `sendBroadcast()` method. This method broadcasts
    any given intent. Remember that this method call is asynchronous and will return
    immediately. You can't get any results from any receiver and receivers also can't
    abort any broadcast intent. The interested receivers match the action string of
    intent with their action string, and if matched, those receivers are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From now on, we will use the keywords **broadcast** or **broadcasts** instead
    of **broadcast intent** in the whole chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in broadcasts in Android systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android OS contains different types of broadcasts. The Android OS keeps
    broadcasting these intents to notify other applications about the various changes
    in the system. For example, when a device's battery gets low, the Android OS broadcasts
    an intent containing low-battery information; applications and services that are
    interested in this information receive it and perform actions accordingly. These
    broadcasts are predefined in the Android OS and we can listen for those intents
    in our application to make our apps more interactive and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the list of all possible broadcasts in a text file named `broadcast_actions.txt`.
    This file is stored in the `SDK` folder under the `Android` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows a list of some of the Android OS broadcasts with
    the description of their actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Broadcast intent action | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.ACTION_POWER_CONNECTED` | This intent is broadcasted
    when a mobile phone is connected to a power source. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.ACTION_POWER_DISCONNECTED` | This intent is broadcasted
    when a mobile phone is disconnected from any power source. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.BATTERY_LOW` | This intent is broadcasted when a mobile
    phone''s battery gets low. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.BOOT_COMPLETED` | This intent is broadcasted when
    a mobile phone''s booting completes. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.DEVICE_STORAGE_LOW` | This intent is broadcasted when
    a mobile phone''s device storage gets low. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.NEW_OUTGOING_CALL` | This intent is broadcasted when
    a new outgoing call starts. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.SCREEN_OFF` | This intent is broadcasted when a mobile''s
    screen is turned on. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.intent.action.SCREEN_ON` | This intent is broadcasted when a mobile''s
    screen is turned off. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.net.wifi.WIFI_STATE_CHANGED` | This intent is broadcasted when the
    WIFI state of a mobile phone is changed. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.media.VIBRATE_SETTING_CHANGED` | This intent is broadcasted when
    the vibrate settings of a mobile phone are changed. |'
  prefs: []
  type: TYPE_TB
- en: '| `android.provider.Telephony.SMS_RECEIVED` | This intent is broadcasted when
    a mobile phone receives an SMS. |'
  prefs: []
  type: TYPE_TB
- en: As we can see in the preceding table, the Android OS keeps informing different
    applications about various changes in the device's state by sending broadcasts.
    We can listen for these changes or broadcasts and can perform our custom actions
    to make our apps responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have observed that some of the preceding intents, such as `android.provider.Telephony.SMS_RECEIVED`,
    are not included in the list in the `SDK` folder. Such intents are not supported
    in Android and are subject to change in any other future platform releases. Developers
    should be cautious when using these unsupported, hidden features in their apps.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have only talked about broadcasts but we haven't still used them
    in practical examples. In the next section, we will develop some examples, in
    which we will listen for some Android OS's predefined broadcasts and perform actions
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the low-battery state of a device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a small application which will show an alert
    message when the phone's battery gets low. Now, let's get started with the development
    of our first example. But, in order to start this example, you need to build an
    Android project. You can use the Android Studio or Eclipse IDE (as per your convenience),
    but make sure that in the case of Eclipse, you have correctly installed JDK, ADT,
    and Android SDK along with their compatibility. If you don't know the difference
    between these IDEs, you can refer to [Chapter 1](ch01.html "Chapter 1. Understanding
    Android"), *Understanding Android*, of this book. Following those steps will help
    you to create a complete Android project with some predefined files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating an empty Android project, we have to modify two files: one main
    activity file and a manifest file. Also, we have added a receiver file as well.
    Let''s look at these files in details now.'
  prefs: []
  type: TYPE_NORMAL
- en: The BatteryLowReceiver.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we are developing a Battery Low alert app, the first thing we have to do
    is to detect the low battery. For that purpose, we would have to create a `BroadcastLowReceiver`
    class, which will listen to the Battery Low broadcast. The following code shows
    the implementation of the receiver file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The BatteryLowReceiver.java file](img/9639_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the preceding code, we have extended our class from the `BroadcastReceiver`
    class and have overridden the `onReceive()` method. This method will be called
    when any broadcast is received. The first thing we have to do is to check whether
    this intent is the Battery Low intent or some other broadcast. To do so, we check
    the action string of the intent with the standard Android action which is `Intent.ACTION_BATTERY_LOW`.
    If the result is `true`, that means the device's battery is low, and we have to
    perform our custom action.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a thread in which we pass an anonymous `Runnable` object. We
    override the `run()` method, and in this method, we create an instance of `AlertDialog`
    using the `AlertDialog.Builder` interface. We set the details, such as the title
    and the message of the alert, and then we display it.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we have created a thread to show the alert. We could
    have shown alert without doing it in any thread. Well, it must be noted that broadcast
    receivers run for a very small amount of time. It is approximately about 4 milliseconds.
    Developer should be very careful when performing operations in receivers. It is
    a good practice to perform operations such as creating alerts and starting activities
    and services in threads from broadcast receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our `BatteryLowReceiver` class is ready. But, how is this receiver triggered
    and how can this class receive the Battery Low broadcasts from the Android OS?
    The answers to these questions are explained in the next section. Let's see our
    activity file now in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The BatteryLowActivity.java class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class represents our main activity of the application which means that
    whenever an application is launched, this activity will be started first. The
    following code shows the implementation of our activity file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The BatteryLowActivity.java class](img/9639_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As always, we extended our class from the `Activity` class. Then, we have overridden
    the `onCreate()` method of our activity. We created an instance of `IntentFilter`
    and passed the `Intent.ACTION_BATTERY_LOW` action string in its constructor. You
    can read more about intent filters in [Chapter 7](ch07.html "Chapter 7. Intent
    Filters"), *Intent Filters*. After that, we created an instance of our `BatteryLowReceiver`
    class. Finally, we call our `registerReceiver()` method and pass our receiver
    and filter objects in it. This method tells the Android OS that our application
    is interested in the Battery Low broadcast. This is how we can listen to the Battery
    Low broadcast. One thing to be noted here is that when you call the `registerReceiver()`
    method, it is the developer's responsibility to call the `unregisterReceiver()`
    method too, when an application is not interested in listening to the Battery
    Low broadcast. If the developer doesn't unregister it, this application, no matter
    whether it is opened or closed, will listen for the Battery Low broadcast and
    take an action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be bad for the memory and the optimization of our application. We
    can call the `unregisterReceiver()` method in the `onDestroy()`, `onPause()`,
    or `onStop()` callbacks of our `Activity` class, as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The BatteryLowActivity.java class](img/9639_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers can also register a receiver in the `AndroidManifest.xml` file as
    well. The advantage of registering receivers in the manifest file is that developers
    don''t have to unregister them manually by calling the `unregisterReceiver()`
    method. The Android OS takes care of these receivers on its own, and the developer
    doesn''t have to worry about it anymore. The following is the code implementation
    of our `AndroidManifest.xml` file which registers our Battery Low receiver in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding code that we have used the `<receiver>` tag in
    our `<application>` tag to register our broadcast receiver. We have inserted the
    whole package name of `BatteryLowReceiver`, as the name of receiver in the `android:name`
    attribute of the `<receiver>` tag. As we set the intent-filter action in our activity
    file by creating an instance of the `IntentFilter` class, we are embedding the
    `<intent-filter>` tag with the action name set to `android.intent.action.BATTERY_LOW`.
    This intent filter will tell the Android OS that the receiver is interested in
    the low-battery state information of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It must be noted that developers should register receivers by only one method;
    either from their activities by calling the `registerReceiver()` method or from
    their `AndroidManifest.xml` files. It is a good practice to use the `AndroidManifest.xml`
    file to register `BroadcastReceiver` of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our application, we will see a blank screen because we haven''t
    set any layout for our activity. But when mobile phone gets low on battery, an
    alert box will be shown in our phone. The following screenshot shows an alert
    box from our `BatteryLowReceiver` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Detecting the screen on/off state of a phone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost in all Android phones, we have seen a very interesting feature while
    attending a phone call; we can see that the screen goes on or off. In addition
    to this, you might have observed that when you bring your phone near your ear,
    the screen turns off, and when you take it away from your ear and hold it in your
    hand, the screen automatically turns on. This is an interesting behavior of smartphones.
    Let''s say that we want to develop an application in which whenever the screen
    turns on, we want to turn on the speaker mode so that other people with us can
    hear and participate in the phone conversation. And when we put it on our ear
    again and the screen turns off, we want to turn speaker mode off. The following
    figure shows the concept of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the screen on/off state of a phone](img/9639_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's develop such an application in the following example. Let's start
    from creating an Android project in your favorite IDE. Then, we will have to first
    detect whether the screen has been turned on or off. To detect this, we will implement
    our custom `BroadcastReceiver` class. Let's implement our broadcast receiver class
    in next section.
  prefs: []
  type: TYPE_NORMAL
- en: The ScreenOnOffReceiver.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ScreenOnOffReceiver.java file represents our custom broadcast receiver
    for detecting the screen on/off state of the phone. The following code implementation
    shows our screen on/off detecting receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ScreenOnOffReceiver.java file](img/9639_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As in the previous example, we are extending our `ScreenOnOffReceiver` class
    from the `BroadcastReceiver` class and overriding the `onReceive()` method. This
    method will be called when any broadcast intent is received by our application.
    Our application first checks whether it is screen on/off intent or not by comparing
    the intent action with the `Intent.ACTION_SCREEN_ON` or `Intent.ACTION_SCREEN_OFF`
    constants. Remember, in the previous example we were listening for only a single
    broadcast intent. However in this example, we are listening for two broadcast
    intents: one for screen on and other for screen off.'
  prefs: []
  type: TYPE_NORMAL
- en: In Android phones, the screen turns on/off not only during calls. It also becomes
    on/off when the phone is locked/unlocked. So before setting our speaker on/off,
    we have to check whether we are currently in a call or not. We can detect it by
    checking the mode of `AudioManager`. If the mode is `AudioManager.MODE_IN_CALL`,
    that means we are currently in any incoming or outgoing call conversation. Once
    we are confirmed about the call mode status, then we can set the speaker on/off.
    We are using the `AudioManager.setSpeakerphoneOn(boolean)` method for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have implemented our receivers. But we haven''t registered these
    receivers. Remember from our previous example, we used two approaches to register
    our custom broadcast receivers: one from the activity class by using the `registerReceiver()`
    method and the other from the `AndroidManifest.xml` file. Let''s choose the latter
    approach of the `AndroidManifest.xml` file to register our receivers.'
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in the previous example, we will register our `ScreenOnOffReceiver` broadcast
    receiver in this manifest file. It should be noted that in the previous example
    of the Battery Low application, we registered our receiver for only one filter,
    which was the low-battery state of the phone. However, in this example, we are
    listening for two state filters: screen on and screen off. But, we have implemented
    only one broadcast receiver. So, let''s see how we can register one receiver with
    two intent filters in the following code implementation of the `AndroidManifest.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see in the preceding code that we have put the `<receiver>` tag in
    our `<application>` tag to register our receiver. Also, it should be noted that
    this time we have used the `<intent-filter>` tag twice with two different actions
    embedded in it: one for `android.intent.action.SCREEN_ON` and the other for `android.intent.action.SCREEN_OFF`.
    You can read more about multiple intent filters in [Chapter 7](ch07.html "Chapter 7. Intent
    Filters"), *Intent Filters*. These two intent filters along with the receiver
    embedded in our `AndroidManifest.xml` file registers our `ScreenOnOffReceiver`
    broadcast receiver with the Android OS to listen to the screen-on and screen-off
    state changes of the mobile phone.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the cell phone's reboot-completed state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many android applications run services in the background when running multiple
    tasks and operations. For example, a weather application keeps checking the weather
    after a fixed time interval by using a background service. But have you ever wondered
    that when you reboot your cell phone or your battery dies and your phone is rebooted,
    then how these services start running again after reboot? Well, we will see how
    this can be done in this section.
  prefs: []
  type: TYPE_NORMAL
- en: When an Android phone is rebooted successfully, the Android OS broadcasts an
    intent notifying other applications that the reboot is completed. Then those applications
    start their background services again. In this section, we will create an application
    that will listen to the reboot-completed broadcast, and we will start our test
    service from it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an empty Android project in any IDE such as Eclipse or Android
    Studio. As always, we will first implement our broadcast receiver class.
  prefs: []
  type: TYPE_NORMAL
- en: The PhoneRebootCompletedReceiver.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PhoneRebootCompletedReceiver.java class represents our reboot-completed
    broadcast receiver file. The following code shows the implementation of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PhoneRebootCompletedReceiver.java file](img/9639_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding code that we haven't done anything new. We have
    extended our class from the `BroadcastReceiver` class. Then, we check for the
    `Intent.ACTION_BOOT_COMPLETED` action of the intent. If it is `true`, we start
    our temporary service by calling the `Context.startService()` method. Now, let's
    see what the `TempService` class does, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The TempService.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TempService.java class represents our service which will start when the
    Android system booting is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Android 3.0, the user needs to have started the application at least once
    before the application can receive the `android.intent.action.BOOT_COMPLETED`
    broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of our `TempService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TempService.java file](img/9639_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Like any usual service class, we have extended our class from `Service`. We
    have overridden two methods: `onBind()` and `onStartCommand()`. In the `onStartCommand()`
    method, we will display a toast by calling the `Toast.makeText()` method with
    the "**Service started**" text. When our phone''s booting is complete, this toast
    will be displayed. We can implement our custom operations here in this method.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all that we are left with is to inform the Android OS that our application
    is interested in listening out for the Boot Completed broadcast. As in the previous
    applications, we will register our receiver in the `AndroidManifest.xml` file.
    Let's see this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AndroidManifest.xml file informs the Android OS that our application is
    interested in listening for the Boot Completed broadcast. The following code shows
    the implementation of the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Almost everything is the same as in the previous example applications. We have
    registered our receiver using the `<receiver>` tag nested in the `<application>`
    tag with the intent filter of the `android.intent.action.BOOT_COMPLETED` action.
    We have also registered `TempService` by using the `<service>` tag nested within
    the `<application>` tag. It must be noted that the Boot Completed broadcast requires
    users to grant the `android.permission.RECEIVE_BOOT_COMPLETED` permission. We
    can ask the user to grant this permission by adding the `<uses-permission>` tag
    with the `android:name` attribute set to `android.permission.RECEIVE_BOOT_COMPLETED`.
    This is how we can start our custom services when a phone is rebooted.
  prefs: []
  type: TYPE_NORMAL
- en: Sending and receiving custom broadcasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been only receiving broadcasts. And all those intents we
    have experimented with are the Android System broadcasts. In this section, we
    will talk about custom broadcasts. We will see how we can send our own custom
    broadcasts to other applications and how other applications can listen for our
    custom broadcast intents.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create an example that will send custom broadcasts
    to other applications. Let's create the activity and layout file for the application
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The activity_main.xml layout file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The activity_main.xml file represents the layout file of our activity. The
    following code shows the implementation of the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity_main.xml layout file](img/9639_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the layout file, we have placed a button with the ID, `btnSendBroadcastIntent`.
    We will use this button in our activity file to send the broadcast to other applications.
    Let's see the activity file now.
  prefs: []
  type: TYPE_NORMAL
- en: The MainActivity.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MainActivity.java` file is the main launcher point of our application.
    This activity will use the `activity_main.xml` layout file as its visual part.
    The following code shows the implementation of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MainActivity.java file](img/9639_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding code that we have obtained the `Button` object
    from our layout file by calling the `findViewById()` method. Then we set its `OnClickListener()`
    method, and in the overridden `onClick()` method, we perform our main operation
    of sending broadcasts to other applications. We create an `Intent` object and
    set its action string by calling the `Intent.setAction()` method. It should be
    noted that we have defined our own custom action value this time as the `com.packt.CustomBroadcast`
    string. We should follow the package-naming convention when we create our own
    custom broadcast receivers. Finally, we use that intent for broadcasting by calling
    the `sendBroadcast()` method of the `Activity` class. This is how our custom broadcast
    intent is sent to the Android OS and other applications. Now, all of the applications
    and receivers that are listening for this type of broadcast will receive it, and
    hence, can perform their custom operations. In the next section, we will implement
    our custom broadcast receiver class which will receive this type of intent and
    display a toast to notify the user.
  prefs: []
  type: TYPE_NORMAL
- en: The CustomReceiver.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CustomReceiver.java file represents our custom broadcast-receiver class,
    which will receive our custom broadcast. This class can be in this application
    or any other application which is interested in listening for this custom type
    of broadcast. Like all of the previous examples, this class will be the same and
    extended from the `BroadcastReceiver` class. The only difference between the previous
    examples and this example is that we were using the Android OS''s standard predefined
    constant action strings to detect the System broadcasts, but in this example,
    we are listening for our own custom broadcasts with custom action strings set.
    The following code shows the implementation of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code that we haven't done anything new which you
    aren't already familiar with. We have derived our class from `BroadcastReceiver`
    and overridden the `onReceive()` method. We then compared the action string of
    the intent with our own custom string of the `com.packt.CustomBroadcast` action.
    If it is `true`, we will display a toast saying `Broadcast Intent Detected`. We
    can perform our custom operations here in this method. Finally, we have to register
    this receiver so that the Android OS can notify our application about the broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidManifest.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, the AndroidManifest.xml tells the Android OS that our application
    is listening for custom broadcasts. The following code shows the implementation
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that we have registered our custom broadcast receiver in the same
    way as we have registered the receivers for Android System broadcasts. Now, when
    we run this application, we will see a button named **Send Broadcast Intent**.
    When we tap on the button, our custom broadcast will be broadcasted in the Android
    OS. As we have also created a receiver of this custom intent, so we will also
    receive this intent. On receiving the intent, our custom receiver will display
    a toast. The following screenshot shows the execution of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AndroidManifest.xml file](img/9639_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed about broadcasts. We also saw the different Android
    OS's System broadcast intents such as Battery Low, Power Connected and Boot Completed.
    Also, we saw how these broadcasts are received by registering our custom receivers
    and how we can perform our own custom operations in those receivers. Finally,
    we learned about sending our own custom broadcasts and receiving those custom
    intents as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore two special types of intents: `IntentService`
    and `PendingIntent.` Also, we will learn how these intents are used and what can
    be achieved by these intents.'
  prefs: []
  type: TYPE_NORMAL
