- en: Chapter 2. Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining and inflating a layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RelativeLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LinearLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tables – TableLayout and GridLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ListView, GridView, and Adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing layout properties during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing layouts with the Hierarchy Viewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, the User Interface is defined in a **Layout**. A layout can be
    declared in XML or created dynamically in code. (It''s recommended to declare
    the layout in XML rather than in code to keep the presentation layer separate
    from the implementation layer.) A layout can define an individual `ListItem`,
    a fragment, or even the entire Activity. Layout files are stored in the `/res/layout`
    folder and referenced in code with the following identifier: `R.layout.<filename_without_extension>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Android provides a useful variety of `Layout` classes that contain and organize
    individual elements of an activity (such as buttons, checkboxes, and other `Views`).
    The `ViewGroup` object is a container object that serves as the base class for
    Android's family of `Layout` classes. The Views placed in a layout form a hierarchy,
    with the topmost layout being the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides several built-in layout types designed for specific purposes,
    such as the `RelativeLayout`, which allows Views to be positioned with respect
    to other elements. The `LinearLayout` can stack Views or align them horizontally,
    depending on the orientation specified. The `TableLayout` can be used for laying
    out a grid of Views. Within various layouts, we can also justify Views with `Gravity`
    and provide proportional size with `Weight` control. Layouts and `ViewGroups`
    can be nested within each other to create complex configurations. Over a dozen
    different Layout objects are provided for managing widgets, lists, tables, galleries,
    and other display formats, plus you can always derive from the base classes to
    create your own custom layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and inflating a layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the Android Studio wizard to create a new project, it automatically
    creates the `res/layout/activity_main.xml` file (as shown in the following screenshot).
    It then inflates the XML file in the `onCreate()` callback with `setContentView(R.layout.activity_main)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining and inflating a layout](img/05057_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this recipe, we will create two, slightly different layouts and switch between
    them with a button.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `InflateLayout`. Once the
    project is created, expand the `res/layout` folder so we can edit the `activity_main.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `res/layout/activity_main.xml` file so it includes a button as defined
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now make a copy of `activity_main.xml` and call it `activity_main2.xml`. Change
    the button so it matches the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `MainActivity.java` and add the following two methods to handle the button
    clicks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run this application on a device or emulator to see it in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key here is the call to `setContentView()`, which we have come across before
    in the autogenerated `onCreate()` code. Just pass a layout ID to `setContentView()`
    and it automatically inflates the layout.
  prefs: []
  type: TYPE_NORMAL
- en: This code is meant to make the concept easy to understand but would be overkill
    for simply changing the property of a Button (in this example, we could just change
    the alignment on the button click). Inflating the layout is usually needed once,
    in the `onCreate()` method, but there are times when you may want to manually
    inflate a layout, as we did here. (If you were manually handling orientation changes,
    it would be a good example.)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as identifying a layout using a resource ID, as we did here, `setContentView()`can
    also take a View as an argument, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, see the *Fragment* topic, in [Chapter 5](ch05.html
    "Chapter 5. Exploring Fragments, AppWidgets, and the System UI"), *Exploring Fragments,
    AppWidgets, and the System UI*, for the alternative method to change the screen
    layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RelativeLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Introduction*, the `RelativeLayout` allows Views to be
    position-relative to each other and the parent. `RelativeLayout` is particularly
    useful for reducing the number of nested layouts, which is very important for
    reducing memory and processing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project and call it `RelativeLayout`. The default layout uses a
    `RelativeLayout`, which we will use to align Views both horizontally and vertically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `res/layout/activity_main.xml` file and change it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, or view the layout in the **Design** tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very straightforward exercise but it demonstrates several of the
    `RelativeLayout` options: `layout_centerVertical`, `layout_centerHorizontal`,
    `layout_below`, `layout_alignParentBottom`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used `RelativeLayout` layout attributes include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout_below`: This View should be below the View specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_above`: This View should be above the View specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_alignParentTop`: Align this View to the top edge of the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_alignParentBottom`: Align this View to the bottom edge of the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_alignParentLeft`: Align this View to the left edge of the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_alignParentRight`: Align this View to the right edge of the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_centerVertical`: Center this View vertically within the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_centerHorizontal`: Center this View horizontally within the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout_center`: Center this View both horizontally and vertically within the
    parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the complete list of `RelativeLayout` parameters, visit: [http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to what we saw earlier, here is an example using a `LinearLayout`
    just to center a `TextView` (creating the same effect as the `layout_center` parameter
    of `RelativeLayout`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice this layout is one level deeper than the equivalent `RelativeLayout`
    (which is a `LinearLayout` nested within the parent `LinearLayout`.) Though a
    simple example, it's a good idea to avoid unnecessary nesting as it can impact
    performance, especially when a layout is being repeatedly inflated (such as a
    `ListItem`).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Using LinearLayout*, which will give you an alternative layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Optimizing layouts with the Hierarchy Viewer* recipe for more information
    on efficient layout design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LinearLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common layout option is the `LinearLayout`, which arranges the child
    Views in a single column or single row, depending on the orientation specified.
    The default orientation (if not specified) is vertical, which aligns the Views
    in a single column.
  prefs: []
  type: TYPE_NORMAL
- en: The `LinearLayout` has a key feature not offered in the `RelativeLayout`—the
    `weight` attribute. We can specify a `layout_weight` parameter when defining a
    View to allow the View to dynamically size based on the available space. Options
    include having a View fill all the remaining space (if a View has a higher weight),
    having multiple Views fit within the given space (if all have the same weight),
    or spacing the Views proportionally by their weight.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `LinearLayout` with three `EditText` Views to demonstrate how
    the weight attribute can be used. For this example, we will use three `EditText`
    Views—one to enter a `To Address` parameter, another to enter a `Subject`, and
    the third to enter a `Message`. The `To` and `Subject` Views will be a single
    line each, with the remaining space given to the Message View.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project and call it `LinearLayout`. We will replace the default
    `RelativeLayout` created in `activity_main.xml` with a `LinearLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `res/layout/activity_main.xml` file and replace it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, or view the layout in the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using vertical orientation with the `LinearLayout`, the child Views are
    created in a single column (stacked on top of each other). The first two Views
    use the `android:layout_height="wrap_content"` attribute, giving them a single
    line each. `editTextMessage` uses the following to specify the height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When using the `LinearLayout`, it tells Android to calculate the height based
    on the weight. A weight of 0 (the default if not specified) indicates the View
    should not expand. In this example, `editTextMessage` is the only View defined
    with a weight, so it alone will expand to fill any remaining space in the parent
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the horizontal orientation, specify `android:layout_height="0dp"`
    (along with the weight) to have Android calculate the width.
  prefs: []
  type: TYPE_NORMAL
- en: It might be helpful to think of the weight attribute as a percentage. In this
    case, the total weight defined is 1, so this View gets 100 percent of the remaining
    space. If we assigned a weight of 1 to another View, the total would be 2, so
    this View would get 50 percent of the space. Try adding a weight to one of the
    other Views (make sure to change the height to `0dp` as well) to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you added a weight to one (or both) of the other Views, did you notice the
    text position? Without specifying a value for `gravity`, the text just remains
    in the center of the View space. The `editTextMessage` specifies: `android:gravity="top"`,
    which forces the text to the top of the View.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple attribute options can be combined using bitwise `OR`. (Java uses the
    pipe character (|) for `OR`). For example, we could combine two gravity options
    to both align along the top of the parent and center within the available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that the `layout_gravity` and `gravity` tags are not the
    same thing. Where `layout_gravity` dictates where in its parent a View should
    lie, `gravity` controls the positioning of the contents within a View—for example,
    the alignment of text on a button.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe, *Using the RelativeLayout*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tables – TableLayout and GridLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to create a table in your UI, Android provides two convenient
    layout options: the `TableLayout` (along with `TableRow`) and the `GridLayout`
    (added in API 14). Both layout options can create similar looking tables, but
    each using a different approach. With the `TableLayout`, rows and columns are
    added dynamically as you build the table. With the `GridLayout`, row and column
    sizes are defined in the layout definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Neither layout is better, it's just a matter of using the best layout for your
    needs. We'll create a 3 x 3 grid using each layout to give a comparison, as you
    could easily find yourself using both layouts, even within the same application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To stay focused on the layouts and offer an easier comparison, we will create
    two separate applications for this recipe. Create two new Android projects, the
    first called `TableLayout` and the other called `GridLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with the `TableLayout` project, open **activity_main.xml**`.` Change
    the root layout to `TableLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add three `TableRows` with three sets of `TextViews` to each `TableRow` to
    create a 3 x 3 matrix. For demonstration purposes, the columns are labeled A-C
    and the rows 1-3, so the first row of `TextViews` will be A1, B1, and C1\. The
    final result will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, open the `GridLayout` project to edit `activity_main.xml`. Change the root
    layout to `GridLayout`. Add the `columnCount=3` and `rowCount=3` attributes to
    the `GridLayout` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add nine `TextViews` to `GridLayout`. We will use the same text as the
    preceding `TableLayout` for a consistent comparison. Since the `GridView` does
    not use `TableRows`, the first three `TextViews` are in Row 1, the next three
    are in Row 2, and so on. The final result will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can either run the application or use the **Design** tab to see the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see when viewing the tables created, the tables basically look the
    same on screen. The main difference is the code to create them.
  prefs: []
  type: TYPE_NORMAL
- en: In the `TableLayout` XML, each row is added to the table using a `TableRow`.
    Each View becomes a column. This is not a requirement as cells can be skipped
    or left empty. (See how to specify the cell location in a `TableRow` in the following
    section.)
  prefs: []
  type: TYPE_NORMAL
- en: The `GridLayout` uses the opposite approach. The number of rows and columns
    are specified when creating the table. We don't have to specify the row or column
    information (though we can, discussed as follows). Android will automatically
    add each View to the cells in order.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s see more similarities between the layouts. Both layouts have
    the ability to stretch columns to use the remaining screen space. For the `TableLayout`,
    add the following attribute to the xml declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`stretchColumns` specifies the (zero based) index of the columns to stretch.
    (`android:shrinkColumns` is a zero-based index of columns that can shrink, so
    the table can fit the screen.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the same effect with the `GridLayout`, add the following attribute
    to all the Views in the B column (`textView2`, `textView5`, and `textView8`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All cells in a given column must define the weight or it will not stretch.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at some of the differences, as this is really the key to determine
    which layout to use for a given task. The first thing to note is how the columns
    and rows are actually defined. In the `TableLayout`, the rows are specifically
    defined, using a `TableRow`. (Android will determine the number of columns in
    the table based on the row with the most cells.) Use the `android`:`layoutColumn`
    attribute when defining the View to specify the column.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, with the `GridLayout`, the row and column counts are specified
    when defining the table (using the `columnCount` and `rowCount` as shown previously.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we just added `TextViews` to the `GridLayout` and
    let the system position them automatically. We can alter this behavior by specifying
    the row and column position when defining the View, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android automatically increments the cell counter after adding each View, so
    the *next* View should also specify the row and column, otherwise, you may not
    get the intended result.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `LinearLayout` shown in the *LinearLayout* recipe, the `GridLayout`
    also offers the orientation attribute of supporting both horizontal (the default)
    and vertical. The orientation determines how the cells are placed. (Horizontal
    fills the columns first, then moves down to the next row. Vertical fills the first
    column on each row, then moves to the next column.)
  prefs: []
  type: TYPE_NORMAL
- en: Using ListView, GridView, and Adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListView` and `GridView` are both descendants of `ViewGroup`, but they
    are used more like a View since they are data driven. In other words, rather than
    defining all the possible Views that might fill a `ListView` (or `GridView`) at
    design time, the contents are created dynamically from the data passed to the
    View. (The layout of the `ListItem` might be created at design time to control
    the look of the data during runtime.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if you needed to present a list of countries to a user, you
    could create a `LinearLayout` and add a button for each country. There are several
    problems with this approach: determining the countries available, keeping the
    list of buttons up to date, having enough screen space to fit all the countries,
    and so on. Otherwise, you could create a list of countries to populate a `ListView`,
    which will then create a button for each entry.'
  prefs: []
  type: TYPE_NORMAL
- en: We will create an example, using the second approach, to populate a `ListView`
    from an array of country names.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `ListView`. The default `ActivityMain`
    class extends the `Activity` class. We will change it to extend the `ListActivity`
    class instead. We will then create a simple string list and bind it to the `ListView`,
    to derivate the buttons at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the **MainActivity.java** file and change the base declaration so it will
    extend `ListActivity` instead of the `Activity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `onCreate()` so it matches the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the application on an emulator or device to see the populated `ListView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating a simple array of country names, then use that to populate
    a `ListAdapter`. In this example, we used an `ArrayAdapter` when constructing
    the `ListAdapter`, but Android has several other adapter types available as well.
    Such as, if your data is stored in a database, you could use the `CursorAdapter`.
    If one of the built-in types doesn't meet your needs, you can always use the `CustomAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the adapter with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instantiate the `ArrayAdapter` using our string array (the last parameter).
    Notice the `android.R.layout.simple_list_item_1` parameter? This defines the layout
    for the button. Here, we are using one of the layouts as provided by Android,
    but we could create our own layout and pass our ID instead.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the adapter ready, we just pass it to the underlying `ListView`
    with the `setListAdapter()` call. (The underlying `ListView` comes from extending
    the `ListViewActivity`.) Finally, we implement the `setOnItemClickListener` to
    display a Toast when the user presses a button (which represents a country) in
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`ListViews` are very common in Android as they make efficient use of screen
    space with a scrolling View, which can be very handy on small screens. The `ScrollView`
    layout offers an alternative approach to create a similar scrolling effect. The
    main difference between the two approaches is that the `ScrollView` layout is
    fully inflated before being shown to the user, whereas the `ListView` only inflates
    the Views that will be visible. For limited data, this may not be an issue, but
    for larger data sets, the application could run out of memory before the list
    is even shown.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, since the `ListView` is driven by a data adapter, the data can easily
    be changed. Even in our limited example, adding a new country to the screen is
    as simple as adding the name to the country list. More importantly, the list can
    be updated during runtime while the user is using the app (for example, downloading
    an updated list from a website to show real-time options).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ListView` also supports a multiple selection mode using the `setChoiceMode()`
    method. To see it in action, add the following line of code after `setListAdapter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, change the `ListItem` layout from `android.R.layout.simple_list_item_1`
    to `android.R.layout.simple_list_item_checked`.
  prefs: []
  type: TYPE_NORMAL
- en: While most applications requiring a scrolling list turn to the `ListView`, Android
    also offers the `GridView`. They are very similar in functionality, even using
    the same data adapters. The main difference is visual which allows multiple columns.
    For a better understanding, let's change the `ListView` example to a `GridView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to change `MainActivity` to extend from `Activity` again,
    instead of `ListActivity`. (This will undo the preceding Step 1.) Then, replace
    `onCreate()` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's more setup code for the `GridView` than there was for
    the `ListView`. The `onCreate()` method creates a new `GridView` and passes it
    in the `setContentView()` call. (We used this variation of `setContentView`, as
    was mentioned in *Defining and inflating a layout*, instead of creating a layout
    with just a `GridView`, but the end result is the same.)
  prefs: []
  type: TYPE_NORMAL
- en: The `ListViewActivity` base class handles much of this, but the `GridView` does
    not have a corresponding activity class to extend.
  prefs: []
  type: TYPE_NORMAL
- en: Changing layout properties during runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, it's generally the preferred practice to define the
    UI with XML and the application code in Java, keeping the User Interface code
    separate from the application code. There are times where it is much easier or
    more efficient, to alter (or even build) the UI from the Java code. Fortunately,
    this is easily supported in Android.
  prefs: []
  type: TYPE_NORMAL
- en: We saw a small example of modifying the layout from code in the previous recipe,
    where we set the number of `GridView` column to display in the code. In this recipe,
    we will obtain a reference to the `LayoutParams` object to change the margin during
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will set up a simple layout with XML and use a `LinearLayout.LayoutParams`
    object to change the margins of a View during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it....
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `activity_main.xml` file and change the layout from `RelativeLayout`
    to `LinearLayout`. It will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a TextView and include an ID as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `Button` and include an ID as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `MainActivity.java` and add the following code to the `onCreate()` method
    to set up an `onClick` event listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program on a device or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every View (and therefore `ViewGroup`) has a set of layout parameters associated
    with it. In particular, all Views have parameters to inform their parent of their
    desired height and width. These are defined with the `layout_height` and `layout_width`
    parameters. We can access this layout information from the code with the `getLayoutParams()`
    method. The layout information includes the layout height, width, margins, and
    any class-specific parameters. In this example, we moved the button on each click
    by obtaining the button `LayoutParams` and changing the margin.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing layouts with the Hierarchy Viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can start optimizing your layouts, it helps to understand the Android
    layout process. Inflating a layout, begins when the activity first comes into
    display. Three steps occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Measure**: This is where the Views determine their size, starting with the
    parent and working through all the children. The parent may have to call its children
    multiple times to work out the final size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout**: This is where the parent determines the position of its children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw**: This is where the Views are actually rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process starts with the parent, which then iterates through all its children.
    Those children iterate through their children. This creates the Layout Tree, with
    the parent becoming the root node in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchy Viewer** is a tool included with the **Android SDK** for inspecting
    layouts. It graphically shows the Layout Tree along with timing results for each
    view/node. By examining the tree layout and the timing; you can look for inefficient
    design and bottlenecks. Armed with this information, you''re in position to optimize
    your layouts.'
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will use Hierarchy Viewer to inspect the example layout
    given in the *Using RelativeLayout* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *There's more…* section of the *Using RelativeLayout* recipe, a `LinearLayout`
    example was shown to highlight the difference between the layouts. The comment
    was made stating the `LinearLayout` required a nested layout. We're going to create
    a new project called `OptimizingLayouts` using the example `LinearLayout`. We
    will then use Hierarchy Viewer to inspect the layout. We will need a rooted Android
    device or the emulator for this Recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hierarchy Viewer will only connect to rooted devices, such as an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `OptimizingLayouts` project in Android Studio. Run the project on your
    rooted device (or emulator) and make sure the screen is visible (unlock if needed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Android Studio, start the Android Device Monitor by going to the following
    menu option: **Tools** | **Android** | **Android Device Monitor**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Android Device Monitor, change to the Hierarchy View perspective, by going
    to **Window** | **Open Perspective…** this will bring up the following dialog:![How
    to do it...](img/05057_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on **Hierarchy Viewer** and on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Windows** section on the left is the list of devices with the running
    processes. Click on the `OptimizingLayouts` process to inspect the layout.![How
    to do it...](img/05057_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the graphical representation of this activity in the **TreeView** section
    (in the center pane, which occupies most of the Hierarch Viewer perspective).![How
    to do it...](img/05057_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tree Layout section shows a graphical hierarchy of the Views that comprise
    this layout, along with the layout times. (Unfortunately for this demonstration,
    the render times are too fast for visual color-coding references.) What's important
    for this example is the nested `LinearLayouts` as shown previously. (It's worth
    taking some time to explore the other Views that make up this layout so you can
    see what Android is doing for us behind the scenes.)
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned in the `RelativeLayout` example, the solution is to redesign
    this layout using the `RelativeLayout`. Ideally, we want a wider, flatter layout,
    rather than deeply nested layouts to reduce the number of iterations required
    during the sizing step. For timing purposes, this is obviously a trivial example,
    but even this example can have an impact. Imagine the user flicking through a
    `ListView` with thousands of items based on this inefficient layout. If you experience
    stuttering while scrolling, your optimizing steps could start by examining the
    layout in Hierarchy Viewer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Lint** is another tool included with the Android SDK with built-in support
    by Android Studio. By default, you''re already using Lint to check your code for
    issues such as deprecated API calls, unsupported API calls for the target API
    level, security issues, and so on. For our Optimizing Layout concerns, some of
    the conditions that Lint will automatically check include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deep layouts — the default maximum is 10 levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested weights, which are bad for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useless parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useless leaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you check the Lint warning in Android Studio for this layout, you will see
    the following warning on the second `LinearLayout` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/05057_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ViewStub` can also be used to optimize a layout. Think of the `ViewStub`
    as a "lazy load" for your layout. The layout in the `ViewStub` will not inflate
    until it''s needed, which reduces the Views needed to inflate. The layout will
    render faster and use less memory. This is a great way to have functionality that
    is seldom used, such as a `Print` feature, available when needed, but that does
    not take up memory when not needed. Here''s an example of a `ViewStub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to actually inflate the `ViewStub`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the visibility parameter of `ViewStub` to `VISIBLE`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `inflate()` method on the `ViewStub`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the `ViewStub` is inflated, the `ViewStub` ID will be removed from the
    layout and replaced with the inflated ID.
  prefs: []
  type: TYPE_NORMAL
