- en: Chapter 2. Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 布局
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining and inflating a layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和填充布局
- en: Using RelativeLayout
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RelativeLayout
- en: Using LinearLayout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LinearLayout
- en: Creating tables – TableLayout and GridLayout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表格 – TableLayout 和 GridLayout
- en: Using ListView, GridView, and Adapters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ListView、GridView 和适配器
- en: Changing layout properties during runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时更改布局属性
- en: Optimizing layouts with the Hierarchy Viewer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用层次结构查看器优化布局
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In Android, the User Interface is defined in a **Layout**. A layout can be
    declared in XML or created dynamically in code. (It''s recommended to declare
    the layout in XML rather than in code to keep the presentation layer separate
    from the implementation layer.) A layout can define an individual `ListItem`,
    a fragment, or even the entire Activity. Layout files are stored in the `/res/layout`
    folder and referenced in code with the following identifier: `R.layout.<filename_without_extension>`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，用户界面是在一个**布局**中定义的。布局可以在 XML 中声明，或者在代码中动态创建。（建议在 XML 中声明布局，以保持表现层与实现层的分离。）布局可以定义一个单独的`ListItem`、一个片段，甚至是整个
    Activity。布局文件存储在 `/res/layout` 文件夹中，并在代码中使用以下标识符引用：`R.layout.<文件名不带扩展名>`。
- en: Android provides a useful variety of `Layout` classes that contain and organize
    individual elements of an activity (such as buttons, checkboxes, and other `Views`).
    The `ViewGroup` object is a container object that serves as the base class for
    Android's family of `Layout` classes. The Views placed in a layout form a hierarchy,
    with the topmost layout being the parent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了有用的`Layout`类，这些类包含和组织活动的各个元素（如按钮、复选框和其他`Views`）。`ViewGroup`对象是一个容器对象，它作为
    Android 的`Layout`类家族的基础类。放置在布局中的视图形成一个层次结构，最顶层的布局是父布局。
- en: Android provides several built-in layout types designed for specific purposes,
    such as the `RelativeLayout`, which allows Views to be positioned with respect
    to other elements. The `LinearLayout` can stack Views or align them horizontally,
    depending on the orientation specified. The `TableLayout` can be used for laying
    out a grid of Views. Within various layouts, we can also justify Views with `Gravity`
    and provide proportional size with `Weight` control. Layouts and `ViewGroups`
    can be nested within each other to create complex configurations. Over a dozen
    different Layout objects are provided for managing widgets, lists, tables, galleries,
    and other display formats, plus you can always derive from the base classes to
    create your own custom layouts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了多种内置布局类型，专为特定目的设计，如`RelativeLayout`，它允许视图相对于其他元素定位。`LinearLayout`可以根据指定的方向堆叠视图或将它们水平对齐。`TableLayout`可用于布局视图网格。在各种布局中，我们还可以使用`Gravity`对齐视图，并通过`Weight`控制提供比例大小。布局和`ViewGroups`可以相互嵌套，以创建复杂的配置。提供了十几种不同的布局对象，用于管理小部件、列表、表格、画廊和其他显示格式，此外，您还可以从基类派生以创建自己的自定义布局。
- en: Defining and inflating a layout
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和填充布局
- en: When using the Android Studio wizard to create a new project, it automatically
    creates the `res/layout/activity_main.xml` file (as shown in the following screenshot).
    It then inflates the XML file in the `onCreate()` callback with `setContentView(R.layout.activity_main)`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Android Studio 向导创建新项目时，它会自动创建`res/layout/activity_main.xml`文件（如下截图所示）。然后在`onCreate()`回调中使用`setContentView(R.layout.activity_main)`填充
    XML 文件。
- en: '![Defining and inflating a layout](img/05057_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![定义和填充布局](img/05057_02_01.jpg)'
- en: For this recipe, we will create two, slightly different layouts and switch between
    them with a button.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建两个略有不同的布局，并通过按钮在它们之间切换。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `InflateLayout`. Once the
    project is created, expand the `res/layout` folder so we can edit the `activity_main.xml`
    file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新项目，并将其命名为`InflateLayout`。创建项目后，展开`res/layout`文件夹，以便我们可以编辑`activity_main.xml`文件。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Edit the `res/layout/activity_main.xml` file so it includes a button as defined
    here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`res/layout/activity_main.xml`文件，使其包含如下定义的按钮：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now make a copy of `activity_main.xml` and call it `activity_main2.xml`. Change
    the button so it matches the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制`activity_main.xml`并将其命名为`activity_main2.xml`。更改按钮，使其与以下内容相匹配：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `MainActivity.java` and add the following two methods to handle the button
    clicks:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`，并添加以下两个方法来处理按钮点击：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run this application on a device or emulator to see it in action.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行此应用程序，查看效果。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The key here is the call to `setContentView()`, which we have come across before
    in the autogenerated `onCreate()` code. Just pass a layout ID to `setContentView()`
    and it automatically inflates the layout.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是调用`setContentView()`，我们在之前自动生成的`onCreate()`代码中遇到过。只需将布局ID传递给`setContentView()`，它就会自动膨胀布局。
- en: This code is meant to make the concept easy to understand but would be overkill
    for simply changing the property of a Button (in this example, we could just change
    the alignment on the button click). Inflating the layout is usually needed once,
    in the `onCreate()` method, but there are times when you may want to manually
    inflate a layout, as we did here. (If you were manually handling orientation changes,
    it would be a good example.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码旨在让概念易于理解，但对于仅更改按钮属性（在这个例子中，我们只需在按钮点击时更改对齐方式）来说可能过于复杂。通常在`onCreate()`方法中只需要对布局进行一次膨胀，但有时你可能需要像我们这里一样手动膨胀一个布局。（如果你要手动处理方向变化，这将是一个很好的例子。）
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As well as identifying a layout using a resource ID, as we did here, `setContentView()`can
    also take a View as an argument, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像我们在这里用资源ID标识布局，`setContentView()`还可以接受一个视图作为参数，例如：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See also
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参阅以下内容
- en: As mentioned previously, see the *Fragment* topic, in [Chapter 5](ch05.html
    "Chapter 5. Exploring Fragments, AppWidgets, and the System UI"), *Exploring Fragments,
    AppWidgets, and the System UI*, for the alternative method to change the screen
    layout
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，在[第5章](ch05.html "第5章. 探索片段、应用微件和系统UI")，*探索片段、应用微件和系统UI*的*片段*主题中，查看更改屏幕布局的替代方法。
- en: Using RelativeLayout
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RelativeLayout
- en: As mentioned in the *Introduction*, the `RelativeLayout` allows Views to be
    position-relative to each other and the parent. `RelativeLayout` is particularly
    useful for reducing the number of nested layouts, which is very important for
    reducing memory and processing requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如*引言*中所述，`RelativeLayout`允许视图相对于彼此和父视图定位。`RelativeLayout`特别有用，因为它可以减少嵌套布局的数量，这对于降低内存和处理要求非常重要。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project and call it `RelativeLayout`. The default layout uses a
    `RelativeLayout`, which we will use to align Views both horizontally and vertically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`RelativeLayout`的新项目。默认布局使用`RelativeLayout`，我们将用它来水平和垂直对齐视图。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the `res/layout/activity_main.xml` file and change it as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout/activity_main.xml`文件，并按如下方式进行修改：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code, or view the layout in the **Design** tab
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，或者在**设计**标签中查看布局
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This is a very straightforward exercise but it demonstrates several of the
    `RelativeLayout` options: `layout_centerVertical`, `layout_centerHorizontal`,
    `layout_below`, `layout_alignParentBottom`, and so on.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的练习，但它展示了`RelativeLayout`的几种选项：`layout_centerVertical`、`layout_centerHorizontal`、`layout_below`、`layout_alignParentBottom`等。
- en: 'The most commonly used `RelativeLayout` layout attributes include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的`RelativeLayout`布局属性包括：
- en: '`layout_below`: This View should be below the View specified'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_below`：此视图应位于指定视图之下'
- en: '`layout_above`: This View should be above the View specified'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_above`：此视图应位于指定视图之上'
- en: '`layout_alignParentTop`: Align this View to the top edge of the parent'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentTop`：将此视图与父视图的顶部边缘对齐'
- en: '`layout_alignParentBottom`: Align this View to the bottom edge of the parent'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentBottom`：将此视图与父视图的底边缘对齐'
- en: '`layout_alignParentLeft`: Align this View to the left edge of the parent'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentLeft`：将此视图与父视图的左边缘对齐'
- en: '`layout_alignParentRight`: Align this View to the right edge of the parent'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentRight`：将此视图与父视图的右边缘对齐'
- en: '`layout_centerVertical`: Center this View vertically within the parent'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_centerVertical`：在父视图中垂直居中此视图'
- en: '`layout_centerHorizontal`: Center this View horizontally within the parent'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_centerHorizontal`：在父视图中水平居中此视图'
- en: '`layout_center`: Center this View both horizontally and vertically within the
    parent'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_center`：在父视图中水平和垂直居中此视图'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the complete list of `RelativeLayout` parameters, visit: [http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html).'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要获取完整的`RelativeLayout`参数列表，请访问：[http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html)。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In contrast to what we saw earlier, here is an example using a `LinearLayout`
    just to center a `TextView` (creating the same effect as the `layout_center` parameter
    of `RelativeLayout`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的相比，下面是仅使用`LinearLayout`来居中`TextView`的示例（创建与`RelativeLayout`的`layout_center`参数相同的效果）：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice this layout is one level deeper than the equivalent `RelativeLayout`
    (which is a `LinearLayout` nested within the parent `LinearLayout`.) Though a
    simple example, it's a good idea to avoid unnecessary nesting as it can impact
    performance, especially when a layout is being repeatedly inflated (such as a
    `ListItem`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此布局比等效的`RelativeLayout`（即嵌套在父`LinearLayout`中的`LinearLayout`）深一个层级。尽管这是一个简单的例子，但避免不必要的嵌套是一个好主意，因为它可能会影响性能，尤其是在重复膨胀布局时（如`ListItem`）。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe, *Using LinearLayout*, which will give you an alternative layout
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个食谱*使用LinearLayout*将为您提供另一种布局选择
- en: See the *Optimizing layouts with the Hierarchy Viewer* recipe for more information
    on efficient layout design
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关高效布局设计的更多信息，请参阅*使用层次结构查看器优化布局*的食谱。
- en: Using LinearLayout
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LinearLayout
- en: Another common layout option is the `LinearLayout`, which arranges the child
    Views in a single column or single row, depending on the orientation specified.
    The default orientation (if not specified) is vertical, which aligns the Views
    in a single column.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的布局选项是`LinearLayout`，它根据指定的方向，将子视图排列在单列或单行中。默认方向（如果未指定）是垂直，将视图对齐在单列中。
- en: The `LinearLayout` has a key feature not offered in the `RelativeLayout`—the
    `weight` attribute. We can specify a `layout_weight` parameter when defining a
    View to allow the View to dynamically size based on the available space. Options
    include having a View fill all the remaining space (if a View has a higher weight),
    having multiple Views fit within the given space (if all have the same weight),
    or spacing the Views proportionally by their weight.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout`有一个`RelativeLayout`没有的关键特性——`权重`属性。在定义视图时，我们可以指定一个`layout_weight`参数，让视图根据可用空间动态调整大小。选项包括让视图填充所有剩余空间（如果视图具有更高的权重），让多个视图在给定空间内适应（如果所有视图权重相同），或者按权重比例分配视图空间。'
- en: We will create a `LinearLayout` with three `EditText` Views to demonstrate how
    the weight attribute can be used. For this example, we will use three `EditText`
    Views—one to enter a `To Address` parameter, another to enter a `Subject`, and
    the third to enter a `Message`. The `To` and `Subject` Views will be a single
    line each, with the remaining space given to the Message View.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含三个`EditText`视图的`LinearLayout`，以演示权重属性如何使用。在这个例子中，我们将使用三个`EditText`视图——一个用于输入`收件人地址`参数，另一个用于输入`主题`，第三个用于输入`消息`。`收件人`和`主题`视图各占一行，剩余空间留给消息视图。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project and call it `LinearLayout`. We will replace the default
    `RelativeLayout` created in `activity_main.xml` with a `LinearLayout`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，将其命名为`LinearLayout`。我们将用`LinearLayout`替换在`activity_main.xml`中创建的默认`RelativeLayout`。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the `res/layout/activity_main.xml` file and replace it as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout/activity_main.xml`文件，并按如下方式替换：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code, or view the layout in the **Design** tab.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，或者在**设计**标签中查看布局。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When using vertical orientation with the `LinearLayout`, the child Views are
    created in a single column (stacked on top of each other). The first two Views
    use the `android:layout_height="wrap_content"` attribute, giving them a single
    line each. `editTextMessage` uses the following to specify the height:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`LinearLayout`的垂直方向时，子视图会在单列中创建（一个叠在另一个上面）。前两个视图使用`android:layout_height="wrap_content"`属性，使它们各占一行。`editTextMessage`使用以下属性来指定高度：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When using the `LinearLayout`, it tells Android to calculate the height based
    on the weight. A weight of 0 (the default if not specified) indicates the View
    should not expand. In this example, `editTextMessage` is the only View defined
    with a weight, so it alone will expand to fill any remaining space in the parent
    layout.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LinearLayout`时，它会告诉Android根据权重计算高度。权重为0（如果未指定，则为默认值）表示视图不应该扩展。在这个例子中，只有`editTextMessage`视图被定义了权重，因此它将独自扩展以填充父布局中的任何剩余空间。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When using the horizontal orientation, specify `android:layout_height="0dp"`
    (along with the weight) to have Android calculate the width.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用水平方向时，指定`android:layout_height="0dp"`（连同权重），让Android计算宽度。
- en: It might be helpful to think of the weight attribute as a percentage. In this
    case, the total weight defined is 1, so this View gets 100 percent of the remaining
    space. If we assigned a weight of 1 to another View, the total would be 2, so
    this View would get 50 percent of the space. Try adding a weight to one of the
    other Views (make sure to change the height to `0dp` as well) to see it in action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将权重属性视为百分比可能有助于理解。在这种情况下，定义的总权重是1，所以这个视图获得了剩余空间的100%。如果我们给另一个视图分配了1的权重，那么总权重将是2，所以这个视图将获得50%的空间。尝试给其他视图之一添加权重（确保也将高度更改为`0dp`）以查看效果。
- en: 'If you added a weight to one (or both) of the other Views, did you notice the
    text position? Without specifying a value for `gravity`, the text just remains
    in the center of the View space. The `editTextMessage` specifies: `android:gravity="top"`,
    which forces the text to the top of the View.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给其他视图之一（或两者）添加了权重，你注意到文本位置了吗？没有为`gravity`指定值时，文本只会保持在视图空间的中心。`editTextMessage`指定了：`android:gravity="top"`，这将强制文本位于视图的顶部。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Multiple attribute options can be combined using bitwise `OR`. (Java uses the
    pipe character (|) for `OR`). For example, we could combine two gravity options
    to both align along the top of the parent and center within the available space:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用按位`OR`组合多个属性选项。（Java使用管道字符（|）表示`OR`）。例如，我们可以结合两个重力选项，使其既沿着父视图的顶部对齐，又在可用空间内居中：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It should be noted that the `layout_gravity` and `gravity` tags are not the
    same thing. Where `layout_gravity` dictates where in its parent a View should
    lie, `gravity` controls the positioning of the contents within a View—for example,
    the alignment of text on a button.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`layout_gravity`和`gravity`标签不是一回事。`layout_gravity`决定了视图在其父视图中的位置，而`gravity`控制视图内内容的位置——例如，按钮上文本的对齐方式。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The previous recipe, *Using the RelativeLayout*
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前的食谱，*使用RelativeLayout*
- en: Creating tables – TableLayout and GridLayout
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表格——TableLayout和GridLayout
- en: 'When you need to create a table in your UI, Android provides two convenient
    layout options: the `TableLayout` (along with `TableRow`) and the `GridLayout`
    (added in API 14). Both layout options can create similar looking tables, but
    each using a different approach. With the `TableLayout`, rows and columns are
    added dynamically as you build the table. With the `GridLayout`, row and column
    sizes are defined in the layout definition.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在UI中需要创建一个表格时，Android提供了两种方便的布局选项：`TableLayout`（以及`TableRow`）和`GridLayout`（在API
    14中添加）。这两种布局选项可以创建看起来相似的表格，但每个都使用不同的方法。使用`TableLayout`时，行和列是动态添加的，随着表格的构建而添加。使用`GridLayout`时，行和列的大小在布局定义中定义。
- en: Neither layout is better, it's just a matter of using the best layout for your
    needs. We'll create a 3 x 3 grid using each layout to give a comparison, as you
    could easily find yourself using both layouts, even within the same application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种布局没有绝对的好坏，只是根据你的需求选择最适合的布局。我们将使用每种布局创建一个3x3网格以进行比较，因为你可以轻易地在同一个应用程序中使用这两种布局。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: To stay focused on the layouts and offer an easier comparison, we will create
    two separate applications for this recipe. Create two new Android projects, the
    first called `TableLayout` and the other called `GridLayout`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于布局并提供更简单的比较，我们将为这个食谱创建两个独立的应用程序。创建两个新的Android项目，第一个名为`TableLayout`，另一个名为`GridLayout`。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Starting with the `TableLayout` project, open **activity_main.xml**`.` Change
    the root layout to `TableLayout`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`TableLayout`项目开始，打开**activity_main.xml**。将根布局更改为`TableLayout`。
- en: 'Add three `TableRows` with three sets of `TextViews` to each `TableRow` to
    create a 3 x 3 matrix. For demonstration purposes, the columns are labeled A-C
    and the rows 1-3, so the first row of `TextViews` will be A1, B1, and C1\. The
    final result will look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个`TableRows`，每个`TableRow`包含三组`TextViews`，以创建一个3x3矩阵。为了演示目的，列被标记为A-C，行被标记为1-3，所以第一个`TextViews`行将是A1，B1和C1。最终结果将如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, open the `GridLayout` project to edit `activity_main.xml`. Change the root
    layout to `GridLayout`. Add the `columnCount=3` and `rowCount=3` attributes to
    the `GridLayout` element.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`GridLayout`项目以编辑`activity_main.xml`。将根布局更改为`GridLayout`。在`GridLayout`元素中添加`columnCount=3`和`rowCount=3`属性。
- en: 'Now, add nine `TextViews` to `GridLayout`. We will use the same text as the
    preceding `TableLayout` for a consistent comparison. Since the `GridView` does
    not use `TableRows`, the first three `TextViews` are in Row 1, the next three
    are in Row 2, and so on. The final result will look like this:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向`GridLayout`中添加九个`TextViews`。我们将使用与前面的`TableLayout`相同的文本以便进行一致的比较。由于`GridView`不使用`TableRows`，前三个`TextViews`位于第1行，接下来的三个位于第2行，依此类推。最终结果将如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can either run the application or use the **Design** tab to see the results.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以运行应用程序，或者使用**设计**标签来查看结果。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see when viewing the tables created, the tables basically look the
    same on screen. The main difference is the code to create them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在查看创建的表格时所见到的那样，屏幕上的表格基本看起来是一样的。主要区别在于创建它们的代码。
- en: In the `TableLayout` XML, each row is added to the table using a `TableRow`.
    Each View becomes a column. This is not a requirement as cells can be skipped
    or left empty. (See how to specify the cell location in a `TableRow` in the following
    section.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TableLayout`的XML中，每一行都是通过`TableRow`添加到表格中的。每个视图都成为一个列。这不是必须的，因为单元格可以跳过或留空。（在下一节中了解如何在`TableRow`中指定单元格位置。）
- en: The `GridLayout` uses the opposite approach. The number of rows and columns
    are specified when creating the table. We don't have to specify the row or column
    information (though we can, discussed as follows). Android will automatically
    add each View to the cells in order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridLayout`使用相反的方法。在创建表格时指定行数和列数。我们不必指定行或列的信息（尽管我们可以，下面会讨论）。Android会自动按顺序将每个视图添加到单元格中。'
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'First, let''s see more similarities between the layouts. Both layouts have
    the ability to stretch columns to use the remaining screen space. For the `TableLayout`,
    add the following attribute to the xml declaration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看两种布局之间的更多相似之处。这两种布局都有能力拉伸列以使用剩余的屏幕空间。对于`TableLayout`，在xml声明中添加以下属性：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`stretchColumns` specifies the (zero based) index of the columns to stretch.
    (`android:shrinkColumns` is a zero-based index of columns that can shrink, so
    the table can fit the screen.)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretchColumns`指定了需要拉伸的列的（基于零的）索引。（`android:shrinkColumns`是一个可以收缩的列的基于零的索引，以便表格可以适应屏幕。）'
- en: 'To achieve the same effect with the `GridLayout`, add the following attribute
    to all the Views in the B column (`textView2`, `textView5`, and `textView8`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`GridLayout`中实现相同的效果，请在B列中的所有视图上添加以下属性（`textView2`、`textView5`和`textView8`）：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All cells in a given column must define the weight or it will not stretch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 给定列中的所有单元格必须定义权重，否则它不会拉伸。
- en: Now, let's look at some of the differences, as this is really the key to determine
    which layout to use for a given task. The first thing to note is how the columns
    and rows are actually defined. In the `TableLayout`, the rows are specifically
    defined, using a `TableRow`. (Android will determine the number of columns in
    the table based on the row with the most cells.) Use the `android`:`layoutColumn`
    attribute when defining the View to specify the column.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下它们之间的不同之处，因为这确实是决定针对特定任务使用哪种布局的关键。首先要注意的是列和行是如何定义的。在`TableLayout`中，行是明确定义的，使用`TableRow`。（Android会根据拥有最多单元格的行来确定表格中的列数。）在定义视图时，使用`android`:`layoutColumn`属性来指定列。
- en: In contrast, with the `GridLayout`, the row and column counts are specified
    when defining the table (using the `columnCount` and `rowCount` as shown previously.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在`GridLayout`中，在定义表格时（如前所示使用`columnCount`和`rowCount`）指定行数和列数。
- en: 'In the preceding example, we just added `TextViews` to the `GridLayout` and
    let the system position them automatically. We can alter this behavior by specifying
    the row and column position when defining the View, such as:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只是将`TextViews`添加到`GridLayout`中，并让系统自动定位它们。我们可以通过在定义视图时指定行和列的位置来更改此行为，例如：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Android automatically increments the cell counter after adding each View, so
    the *next* View should also specify the row and column, otherwise, you may not
    get the intended result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加每个视图后，Android会自动增加单元格计数器，因此*下一个*视图也应该指定行和列，否则，您可能无法得到预期的结果。
- en: Like the `LinearLayout` shown in the *LinearLayout* recipe, the `GridLayout`
    also offers the orientation attribute of supporting both horizontal (the default)
    and vertical. The orientation determines how the cells are placed. (Horizontal
    fills the columns first, then moves down to the next row. Vertical fills the first
    column on each row, then moves to the next column.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *LinearLayout* 配方中显示的 `LinearLayout` 一样，`GridLayout` 也提供了支持水平和垂直（默认）方向的 orientation
    属性。方向决定了单元格的放置方式。（水平方向首先填充列，然后向下移动到下一行。垂直方向则先填充每行的第一列，然后移动到下一列。）
- en: Using ListView, GridView, and Adapters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ListView`、`GridView` 和适配器
- en: The `ListView` and `GridView` are both descendants of `ViewGroup`, but they
    are used more like a View since they are data driven. In other words, rather than
    defining all the possible Views that might fill a `ListView` (or `GridView`) at
    design time, the contents are created dynamically from the data passed to the
    View. (The layout of the `ListItem` might be created at design time to control
    the look of the data during runtime.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 和 `GridView` 都是 `ViewGroup` 的后代，但它们更像是一个 View，因为它们是由数据驱动的。换句话说，在设计时，你不需要定义可能填充
    `ListView`（或 `GridView`）的所有可能的 View，而是从传递给 View 的数据动态创建内容。（`ListItem` 的布局可以在设计时创建，以控制数据在运行时的外观。）'
- en: 'As an example, if you needed to present a list of countries to a user, you
    could create a `LinearLayout` and add a button for each country. There are several
    problems with this approach: determining the countries available, keeping the
    list of buttons up to date, having enough screen space to fit all the countries,
    and so on. Otherwise, you could create a list of countries to populate a `ListView`,
    which will then create a button for each entry.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要向用户展示一个国家列表，你可以创建一个 `LinearLayout` 并为每个国家添加一个按钮。这种方法有几个问题：确定可用国家、保持按钮列表更新、有足够的屏幕空间来容纳所有国家等等。否则，你可以创建一个国家列表来填充
    `ListView`，它将为每个条目创建一个按钮。
- en: We will create an example, using the second approach, to populate a `ListView`
    from an array of country names.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第二种方法创建一个示例，从一个国家名称数组中填充 `ListView`。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ListView`. The default `ActivityMain`
    class extends the `Activity` class. We will change it to extend the `ListActivity`
    class instead. We will then create a simple string list and bind it to the `ListView`,
    to derivate the buttons at runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新项目，并将其命名为 `ListView`。默认的 `ActivityMain` 类扩展了 `Activity`
    类。我们将改为让它扩展 `ListActivity` 类。然后，我们将创建一个简单的字符串列表并将其绑定到 `ListView` 上，以在运行时派生按钮。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the **MainActivity.java** file and change the base declaration so it will
    extend `ListActivity` instead of the `Activity` class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **MainActivity.java** 文件，并更改基本声明，使其扩展 `ListActivity` 而不是 `Activity` 类：
- en: '[PRE14]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Change `onCreate()` so it matches the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `onCreate()` 使其与以下代码相匹配：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now run the application on an emulator or device to see the populated `ListView`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在模拟器或设备上运行应用程序，查看填充后的 `ListView`。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by creating a simple array of country names, then use that to populate
    a `ListAdapter`. In this example, we used an `ArrayAdapter` when constructing
    the `ListAdapter`, but Android has several other adapter types available as well.
    Such as, if your data is stored in a database, you could use the `CursorAdapter`.
    If one of the built-in types doesn't meet your needs, you can always use the `CustomAdapter`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个简单的国家名称数组，然后使用它来填充 `ListAdapter`。在这个例子中，我们在构造 `ListAdapter` 时使用了 `ArrayAdapter`，但
    Android 还有其他几种适配器类型可用。例如，如果你的数据存储在数据库中，你可以使用 `CursorAdapter`。如果内置类型之一不符合你的需求，你总是可以使用
    `CustomAdapter`。
- en: 'We create the adapter with this line of code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下这行代码创建适配器：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we instantiate the `ArrayAdapter` using our string array (the last parameter).
    Notice the `android.R.layout.simple_list_item_1` parameter? This defines the layout
    for the button. Here, we are using one of the layouts as provided by Android,
    but we could create our own layout and pass our ID instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的字符串数组（最后一个参数）实例化 `ArrayAdapter`。注意 `android.R.layout.simple_list_item_1`
    参数吗？这定义了按钮的布局。这里，我们使用了 Android 提供的布局之一，但我们也可以创建自己的布局并传递我们的 ID。
- en: Once we have the adapter ready, we just pass it to the underlying `ListView`
    with the `setListAdapter()` call. (The underlying `ListView` comes from extending
    the `ListViewActivity`.) Finally, we implement the `setOnItemClickListener` to
    display a Toast when the user presses a button (which represents a country) in
    the list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好适配器，只需通过 `setListAdapter()` 调用将其传递给底层的 `ListView`。（底层的 `ListView` 来自扩展
    `ListViewActivity`。）最后，我们实现 `setOnItemClickListener` 以在用户按下列表中的按钮（代表一个国家）时显示一个
    Toast。
- en: '`ListViews` are very common in Android as they make efficient use of screen
    space with a scrolling View, which can be very handy on small screens. The `ScrollView`
    layout offers an alternative approach to create a similar scrolling effect. The
    main difference between the two approaches is that the `ScrollView` layout is
    fully inflated before being shown to the user, whereas the `ListView` only inflates
    the Views that will be visible. For limited data, this may not be an issue, but
    for larger data sets, the application could run out of memory before the list
    is even shown.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListViews` 在 Android 中非常常见，因为它们通过滚动视图高效地利用屏幕空间，这对于小屏幕非常有用。`ScrollView` 布局提供了一种替代方法来创建类似的滚动效果。这两种方法的主要区别在于，`ScrollView`
    布局在显示给用户之前会完全展开，而 `ListView` 只展开用户将看到的部分视图。对于有限的数据，这可能不是问题，但对于较大的数据集，在列表显示之前应用程序可能会耗尽内存。'
- en: Also, since the `ListView` is driven by a data adapter, the data can easily
    be changed. Even in our limited example, adding a new country to the screen is
    as simple as adding the name to the country list. More importantly, the list can
    be updated during runtime while the user is using the app (for example, downloading
    an updated list from a website to show real-time options).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ListView` 是由数据适配器驱动的，因此数据可以轻松更改。即使在我们的有限示例中，向屏幕添加一个新国家也只需将该名称添加到国家列表中。更重要的是，在用户使用应用程序时，列表可以在运行时更新（例如，从网站下载更新后的列表以显示实时选项）。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ListView` also supports a multiple selection mode using the `setChoiceMode()`
    method. To see it in action, add the following line of code after `setListAdapter()`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 还支持通过 `setChoiceMode()` 方法设置多选模式。要查看其效果，请在 `setListAdapter()` 之后添加以下代码行：'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, change the `ListItem` layout from `android.R.layout.simple_list_item_1`
    to `android.R.layout.simple_list_item_checked`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `ListItem` 布局从 `android.R.layout.simple_list_item_1` 更改为 `android.R.layout.simple_list_item_checked`。
- en: While most applications requiring a scrolling list turn to the `ListView`, Android
    also offers the `GridView`. They are very similar in functionality, even using
    the same data adapters. The main difference is visual which allows multiple columns.
    For a better understanding, let's change the `ListView` example to a `GridView`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数需要滚动列表的应用程序都使用 `ListView`，但 Android 也提供了 `GridView`。它们在功能上非常相似，甚至使用相同的数据适配器。主要区别在于视觉效果，它允许多列显示。为了更好地理解，让我们将
    `ListView` 示例更改为 `GridView`。
- en: 'To start, we need to change `MainActivity` to extend from `Activity` again,
    instead of `ListActivity`. (This will undo the preceding Step 1.) Then, replace
    `onCreate()` with the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `MainActivity` 修改为再次继承自 `Activity`，而不是 `ListActivity`。（这将撤销之前的第1步。）然后，用以下代码替换
    `onCreate()`：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, there's more setup code for the `GridView` than there was for
    the `ListView`. The `onCreate()` method creates a new `GridView` and passes it
    in the `setContentView()` call. (We used this variation of `setContentView`, as
    was mentioned in *Defining and inflating a layout*, instead of creating a layout
    with just a `GridView`, but the end result is the same.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`GridView` 的设置代码比 `ListView` 的要多。`onCreate()` 方法创建了一个新的 `GridView` 并在 `setContentView()`
    调用中传递它。（我们使用了在*定义和填充布局*中提到的 `setContentView` 的这种变体，而不是创建仅包含 `GridView` 的布局，但最终结果相同。）
- en: The `ListViewActivity` base class handles much of this, but the `GridView` does
    not have a corresponding activity class to extend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListViewActivity` 基类处理了其中大部分工作，但 `GridView` 没有相应的活动类来继承。'
- en: Changing layout properties during runtime
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时更改布局属性
- en: In Android development, it's generally the preferred practice to define the
    UI with XML and the application code in Java, keeping the User Interface code
    separate from the application code. There are times where it is much easier or
    more efficient, to alter (or even build) the UI from the Java code. Fortunately,
    this is easily supported in Android.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 开发中，通常推荐的做法是用 XML 定义 UI，用 Java 定义应用程序代码，将用户界面代码与应用程序代码分开。有时，从 Java
    代码中修改（甚至构建）UI 要容易或高效得多。幸运的是，这在 Android 中很容易实现。
- en: We saw a small example of modifying the layout from code in the previous recipe,
    where we set the number of `GridView` column to display in the code. In this recipe,
    we will obtain a reference to the `LayoutParams` object to change the margin during
    runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了一个从代码中修改布局的小例子，我们设置了 `GridView` 列的数量以在代码中显示。在这个示例中，我们将获取对 `LayoutParams`
    对象的引用，以在运行时改变边距。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Here we will set up a simple layout with XML and use a `LinearLayout.LayoutParams`
    object to change the margins of a View during runtime.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 XML 设置一个简单的布局，并使用 `LinearLayout.LayoutParams` 对象在运行时改变视图的边距。
- en: How to do it....
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the `activity_main.xml` file and change the layout from `RelativeLayout`
    to `LinearLayout`. It will look as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 文件，将布局从 `RelativeLayout` 更改为 `LinearLayout`。它将如下所示：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a TextView and include an ID as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `TextView` 并包含一个 ID，如下所示：
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add `Button` and include an ID as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Button` 并包含一个 ID，如下所示：
- en: '[PRE21]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open `MainActivity.java` and add the following code to the `onCreate()` method
    to set up an `onClick` event listener:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并在 `onCreate()` 方法中添加以下代码以设置 `onClick` 事件监听器：
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program on a device or emulator.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Every View (and therefore `ViewGroup`) has a set of layout parameters associated
    with it. In particular, all Views have parameters to inform their parent of their
    desired height and width. These are defined with the `layout_height` and `layout_width`
    parameters. We can access this layout information from the code with the `getLayoutParams()`
    method. The layout information includes the layout height, width, margins, and
    any class-specific parameters. In this example, we moved the button on each click
    by obtaining the button `LayoutParams` and changing the margin.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图（因此也包括 `ViewGroup`）都有一组与其关联的布局参数。特别是，所有视图都有参数来告诉它们的父视图期望的高度和宽度。这些通过 `layout_height`
    和 `layout_width` 参数定义。我们可以使用 `getLayoutParams()` 方法从代码中访问此布局信息。布局信息包括布局高度、宽度、边距以及任何类特定的参数。在这个例子中，我们通过获取按钮的
    `LayoutParams` 并改变边距，在每次点击时移动按钮。
- en: Optimizing layouts with the Hierarchy Viewer
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用层次查看器优化布局
- en: 'Before you can start optimizing your layouts, it helps to understand the Android
    layout process. Inflating a layout, begins when the activity first comes into
    display. Three steps occur:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始优化你的布局之前，了解 Android 布局过程是有帮助的。布局的膨胀开始于活动首次显示时。发生以下三个步骤：
- en: '**Measure**: This is where the Views determine their size, starting with the
    parent and working through all the children. The parent may have to call its children
    multiple times to work out the final size.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量（Measure）**：这里视图确定它们的大小，从父视图开始，遍历所有子视图。父视图可能需要多次调用子视图以确定最终大小。'
- en: '**Layout**: This is where the parent determines the position of its children'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局（Layout）**：这里父视图确定其子视图的位置'
- en: '**Draw**: This is where the Views are actually rendered'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘制（Draw）**：这里视图实际上被渲染。'
- en: This process starts with the parent, which then iterates through all its children.
    Those children iterate through their children. This creates the Layout Tree, with
    the parent becoming the root node in the tree.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程从父视图开始，然后遍历其所有子视图。这些子视图再遍历它们的子视图。这样就创建了布局树（Layout Tree），父视图成为树中的根节点。
- en: '**Hierarchy Viewer** is a tool included with the **Android SDK** for inspecting
    layouts. It graphically shows the Layout Tree along with timing results for each
    view/node. By examining the tree layout and the timing; you can look for inefficient
    design and bottlenecks. Armed with this information, you''re in position to optimize
    your layouts.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**层次查看器（Hierarchy Viewer）**是 **Android SDK** 中包含的一个用于检查布局的工具。它以图形化的方式显示布局树，并附带了每个视图/节点的计时结果。通过检查树状布局和计时，你可以查找低效的设计和瓶颈。拥有这些信息，你就可以优化你的布局了。'
- en: For this recipe, we will use Hierarchy Viewer to inspect the example layout
    given in the *Using RelativeLayout* recipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用层次查看器（Hierarchy Viewer）检查在 *使用 RelativeLayout* 示例中给出的布局。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *There's more…* section of the *Using RelativeLayout* recipe, a `LinearLayout`
    example was shown to highlight the difference between the layouts. The comment
    was made stating the `LinearLayout` required a nested layout. We're going to create
    a new project called `OptimizingLayouts` using the example `LinearLayout`. We
    will then use Hierarchy Viewer to inspect the layout. We will need a rooted Android
    device or the emulator for this Recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Using RelativeLayout* 配方中的 *There's more…* 部分展示了一个 `LinearLayout` 示例，以突出显示布局之间的差异。评论指出
    `LinearLayout` 需要一个嵌套布局。我们将使用示例 `LinearLayout` 创建一个名为 `OptimizingLayouts` 的新项目。然后，我们将使用层次结构查看器检查布局。为此，我们需要一个已获得root权限的Android设备或模拟器。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hierarchy Viewer will only connect to rooted devices, such as an emulator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构查看器只能连接到已获得root权限的设备，例如模拟器。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the `OptimizingLayouts` project in Android Studio. Run the project on your
    rooted device (or emulator) and make sure the screen is visible (unlock if needed).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开 `OptimizingLayouts` 项目。在已获得root权限的设备（或模拟器）上运行项目，并确保屏幕可见（如需解锁则解锁）。
- en: 'In Android Studio, start the Android Device Monitor by going to the following
    menu option: **Tools** | **Android** | **Android Device Monitor**.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，通过以下菜单选项启动 Android Device Monitor：**Tools** | **Android**
    | **Android Device Monitor**。
- en: In Android Device Monitor, change to the Hierarchy View perspective, by going
    to **Window** | **Open Perspective…** this will bring up the following dialog:![How
    to do it...](img/05057_02_02.jpg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Device Monitor 中，通过转到 **Window** | **Open Perspective…** 切换到层次视图视角，这将弹出以下对话框：![如何操作...](img/05057_02_02.jpg)
- en: Now click on **Hierarchy Viewer** and on **OK**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 **Hierarchy Viewer** 然后点击 **OK**。
- en: In the **Windows** section on the left is the list of devices with the running
    processes. Click on the `OptimizingLayouts` process to inspect the layout.![How
    to do it...](img/05057_02_03.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **Windows** 部分列出了带有运行进程的设备列表。点击 `OptimizingLayouts` 进程以检查布局。![如何操作...](img/05057_02_03.jpg)
- en: See the graphical representation of this activity in the **TreeView** section
    (in the center pane, which occupies most of the Hierarch Viewer perspective).![How
    to do it...](img/05057_02_04.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **TreeView** 部分查看此活动的图形表示（位于层次查看器视角的中心窗格，占据了大部分空间）。![如何操作...](img/05057_02_04.jpg)
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Tree Layout section shows a graphical hierarchy of the Views that comprise
    this layout, along with the layout times. (Unfortunately for this demonstration,
    the render times are too fast for visual color-coding references.) What's important
    for this example is the nested `LinearLayouts` as shown previously. (It's worth
    taking some time to explore the other Views that make up this layout so you can
    see what Android is doing for us behind the scenes.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 树状布局部分显示了组成此布局的视图的图形层次结构以及布局时间。（不幸的是，对于此演示，渲染时间太快，无法进行视觉颜色编码参考。）对于此示例重要的是之前展示的嵌套
    `LinearLayouts`。（花时间探索构成此布局的其他视图是值得的，这样您可以看到Android在幕后为我们做了什么。）
- en: As already mentioned in the `RelativeLayout` example, the solution is to redesign
    this layout using the `RelativeLayout`. Ideally, we want a wider, flatter layout,
    rather than deeply nested layouts to reduce the number of iterations required
    during the sizing step. For timing purposes, this is obviously a trivial example,
    but even this example can have an impact. Imagine the user flicking through a
    `ListView` with thousands of items based on this inefficient layout. If you experience
    stuttering while scrolling, your optimizing steps could start by examining the
    layout in Hierarchy Viewer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如已在 `RelativeLayout` 示例中提到，解决方案是使用 `RelativeLayout` 重新设计此布局。理想情况下，我们希望有一个更宽、更扁平的布局，而不是深层嵌套的布局，以减少在调整大小步骤中所需迭代次数。从时间上讲，这显然是一个微不足道的例子，但即使这个例子也可能产生影响。想象一下，用户基于这种低效布局在
    `ListView` 中快速浏览成千上万的条目。如果在滚动时遇到卡顿，您的优化步骤可以从在层次结构查看器中检查布局开始。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**Lint** is another tool included with the Android SDK with built-in support
    by Android Studio. By default, you''re already using Lint to check your code for
    issues such as deprecated API calls, unsupported API calls for the target API
    level, security issues, and so on. For our Optimizing Layout concerns, some of
    the conditions that Lint will automatically check include the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lint** 是 Android SDK 中包含的另一个工具，Android Studio 提供了内置支持。默认情况下，您已经在使用 Lint 检查代码中的问题，例如不推荐使用的
    API 调用、目标 API 级别不支持 API 调用、安全问题等。对于我们的优化布局关注点，Lint 将自动检查的一些条件包括以下内容：'
- en: Deep layouts — the default maximum is 10 levels
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层布局——默认最大层级为10级
- en: Nested weights, which are bad for performance
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套权重，这对性能不利
- en: Useless parent
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无用的父节点
- en: Useless leaf
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无用的叶节点
- en: 'If you check the Lint warning in Android Studio for this layout, you will see
    the following warning on the second `LinearLayout` element:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Android Studio中检查此布局的Lint警告，你会在第二个`LinearLayout`元素上看到以下警告：
- en: '![There''s more...](img/05057_02_05.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/05057_02_05.jpg)'
- en: 'The `ViewStub` can also be used to optimize a layout. Think of the `ViewStub`
    as a "lazy load" for your layout. The layout in the `ViewStub` will not inflate
    until it''s needed, which reduces the Views needed to inflate. The layout will
    render faster and use less memory. This is a great way to have functionality that
    is seldom used, such as a `Print` feature, available when needed, but that does
    not take up memory when not needed. Here''s an example of a `ViewStub`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewStub`还可以用来优化布局。将`ViewStub`视为布局的“懒加载”。`ViewStub`中的布局在需要之前不会展开，这减少了需要展开的视图数量。布局将更快渲染并使用更少的内存。这是在需要时提供不常用功能（如`打印`功能）的一种好方法，但在不需要时不占用内存。以下是一个`ViewStub`的示例：'
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two ways to actually inflate the `ViewStub`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种方法可以展开`ViewStub`：
- en: 'Set the visibility parameter of `ViewStub` to `VISIBLE`:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ViewStub`的可见性参数设置为`VISIBLE`：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `inflate()` method on the `ViewStub`:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ViewStub`上调用`inflate()`方法：
- en: '[PRE25]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the `ViewStub` is inflated, the `ViewStub` ID will be removed from the
    layout and replaced with the inflated ID.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`ViewStub`被展开，`ViewStub`的ID将从布局中移除，并替换为展开后的ID。
