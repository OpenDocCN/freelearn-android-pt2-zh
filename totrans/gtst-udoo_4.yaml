- en: Chapter 4. Using Sensors to Listen to the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are building our prototypes, we want to provide the best possible interaction
    for our final users. Sometimes, we build real-world applications that don''t have
    any human interaction but they simply listen to the environment to collect data
    and decide what to do. Whatever our prototype, if we want to read and understand
    human actions or environment changes, we need to use a new set of electronic components:
    **sensors**.'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we build a physical application, we have to bear in mind that the
    more complex our project is, the more likely we need to add sensors to achieve
    the desired interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start a new real-world application from scratch that
    is capable of sensing our heartbeat and publishing the result to our Android application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with environment sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a heartbeat monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting data from sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing collected data from an Android application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with environment sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In electronics, sensors are components built *to detect any changes* of a particular
    matter or particle property. When any change occurs, the sensor provides a voltage
    variation that can change the current flow and behavior of other electric components.
    If a microcontroller is connected to a sensor, it can decide to take different
    actions according to the running program.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors can detect changes in many *properties*, such as heat radiation, humidity,
    light, radio, sound waves, and many others. When we are using a sensor in our
    projects, we have to choose a particular property to listen to and then we need
    to read and manage the voltage variation. Sometimes, to perform our checks, we
    need to transform these electrical changes into other measurement units, such
    as meters or temperature's degree. At other times, we may use more complex sensors
    that already make a total or a partial conversion for us. For example, if we are
    building a robot rover, we may need to use a sensor to detect the distance from
    an object in order to dodge any room obstacles. In this case, we will use an *ultrasonic
    sensor* that is based on a principle similar to radar or sonar. It emits high
    frequency sound waves and evaluates the echo that is received. Analyzing the time
    interval between sending and receiving the signal echo, we can determinate the
    distance from an object.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, in a generic sketch, we read the elapsed microseconds from the sensor
    before the signal echo is received. To make these values more useful and to find
    the right distance, we may need to write a microsecond to centimeters or inches
    converter inside the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is possible only if we know how the sensor works and how many
    centimeters or inches are traveled by the signal for each microsecond. Fortunately,
    we can find this information in a document released by the component manufacturer,
    which is called a **datasheet**. With this knowledge, we can easily convert all
    probed values into what we are looking for. When we finish the prototype in this
    chapter, we could take a look at the URL [http://arduino.cc/en/tutorial/ping](http://arduino.cc/en/tutorial/ping),
    which includes an example about how to use an ultrasonic sensor and how it's easy
    to convert the detected signal into a different measurement unit.
  prefs: []
  type: TYPE_NORMAL
- en: Building a heartbeat monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we built our first prototype equipped with an LED
    actuator to alter the surround environment, and then we enabled the Android application
    to control the LED behavior through the internal ADK communication. We have seen
    that sensors are really helpful to improve interactions of our prototypes and
    we may be tempted to add this new capability to the previous project. Indeed,
    because we're using a component capable of producing light, we may think about
    adding an external light sensor so that the microcontroller is capable of turning
    on and off the LED according to the environment light.
  prefs: []
  type: TYPE_NORMAL
- en: This is just an example of how we can use a light sensor. Indeed, we have to
    bear in mind that each sensor can be used in different ways and it's our job to
    find a correlation between detected values and the goal of our physical application.
    We should never stop to use sensors only for their main use, as we will see in
    the heartbeat monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a circuit with a light sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous prototypes, the heartbeat monitor is composed of two
    parts. The first one is the circuit and the sketch that should collect data from
    the light sensor and convert it into a value that represents the **beats per minute**
    (**bpm**). The second is the Android application, which shows the computed value
    of our heart rate on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if this prototype could achieve good results, it's always a bad idea to
    use homemade prototypes for medical reasons. The photoresistor is used only for
    a demonstration and *should not* be used for any medical purposes.
  prefs: []
  type: TYPE_NORMAL
- en: For this physical application, we are going to use a **photoresistor** as a
    part of our light sensor. A photoresistor, also called **Light Dependent Resistor**
    (**LDR**), works like a traditional resistor used in previous prototypes, but
    it's slightly different regarding how much resistance it provides. Indeed, its
    resistance is variable according to measured light intensity and if we monitor
    this value, we can easily calculate whether the environment intensity is increasing
    or decreasing. We also use a *bright red* LED, which is different from the one
    used before because it's powerful enough to let the light pass through our skin.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to create a circuit where we can put one side of our index finger
    at the top of the photoresistor, and the bright LED on the other side. In this
    way, a part of the light will pass through our finger and will be detected by
    the photoresistor. During every heartbeat, a pressure wave moves out along the
    arteries increasing our blood volume. When the light goes through our tissues,
    this blood volume variation changes the quantity of light that falls on the sensor.
    So, when we see medium or high changes in the probed values, probably, this is
    our heartbeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the construction of our prototype, we need to put the photoresistor
    into our breadboard so that we can achieve the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a circuit with a light sensor](img/1942OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go through the following steps to achieve the preceding schema:'
  prefs: []
  type: TYPE_NORMAL
- en: The photoresistor may have legs that are too long. Use an electronics component
    cutter to cut the legs so that they are, at most, 1.5cm. This is not a requirement
    but it could simplify the use of the prototype.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the UDOO +3.3V pin to the first line of the breadboard. Be sure not
    to connect the +5V power pin because it may damage the board during connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a *10 KOhm* resistor on the board and connect it to the +3.3V pin; we also
    need to connect the other lead to the analog input A0 pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the photoresistor to the same column of the resistor and the A0 pin;
    the second lead should be connected to the negative line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Photoresistors act like any other resistors, so it's not important which lead
    we connect on this step because *they have no polarity*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect UDOO ground to the negative line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these steps, we built a **voltage divider** circuit composed of two resistors.
    These kinds of circuit produce an output voltage, which is a fraction of the input
    voltage according to the resistance values. This means that, because the resistance
    is variable according to the light intensity, the voltage divider gives an output
    voltage that changes with illumination. In this way, the board notices the changes
    and transforms them in a numeric value, in a range between 0 and 1023\. In other
    words, when the photoresistor is in the shade, we read a high value, while when
    it's in the light, we read a low value. Because we connect the *10 KOhm* resistor
    to the +3.3V pin, we can state that this voltage divider has been built using
    a **pull-up** resistor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Voltage divers are commonly used in many electronic circuits. You can find more
    information about other applications of this kind of circuit at [https://learn.sparkfun.com/tutorials/voltage-dividers](https://learn.sparkfun.com/tutorials/voltage-dividers).
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our prototype, we have to add the bright LED to the circuit. However,
    because we need to put the LED on the opposite side of our finger, we can''t connect
    the component directly to our breadboard, but we need to use a couple of *crocodile
    clips*. As a first step, we need to extend the circuit as per the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a circuit with a light sensor](img/1942OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go through the following steps to achieve the preceding schema:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the UDOO +5V power pin to the positive line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a *220 Ohm* resistor to the breadboard and connect one lead to the negative
    line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of a wire connector to the other lead of the *220 Ohm* resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of a wire connector to the positive line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of the first crocodile clip to the wire connected to the positive
    line of the power bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of the second crocodile clip to the wire connected to the resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the crocodile clip that extends the +5V pin to the long leg of the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Before proceeding with the next step, remember that you're using a really bright
    LED. You should avoid directing it at your eyes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect the crocodile clip that extends the resistor and the ground connection
    to the short leg of the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all the connections are set, the LED should turn on and we can use it as
    a moving part of our prototype. One thing to bear in mind is that the metal terminal
    ends of the crocodile clips *should never touch together* otherwise the circuit
    will stop working and some components may get damaged because of a *short circuit*.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting data from the sketch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a working circuit, we should start to write down our sketch
    to collect data from the light sensor. Then we should analyze these results and
    think about an algorithm to transform readings into a heartbeat counter. We should
    start a new sketch and add the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following declarations on the top of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the object-like macro `SENSOR` with a `A0` value that is the pin we
    will use for the analog read. We set `HEARTBEAT_POLL_PERIOD` to specify how many
    milliseconds the microcontroller should wait between consecutive sensor readings.
    With the `SECONDS` parameter, we define the seconds that should elapse before
    we use collected data to process and estimate the heart rate. Indeed, we multiply
    `SECONDS` by `1000` to convert this value into milliseconds and then we divide
    it by the `HEARTBEAT_POLL_PERIOD` parameter to define the `TIMESLOTS` constant.
    This variable defines how many times we should loop the reading phase to collect
    the right number of readings to estimate the heart rate. In this way, we make
    a read for each `TIMESLOTS` cycle and when the cycle ends, we calculate the heart
    rate. The last variable `sensorReading` is used to store the sensor reading during
    each loop iteration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `setup()` function, add the initialization of the serial port so that
    we can open a communication between the UDOO board and our computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function at the bottom of the sketch to print read values
    through the serial port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `analogRead` built-in function to read the incoming data from the
    analog input pin. Because these pins are read-only, we don't need to do any further
    configuration in the `setup()`function or to change the input resolution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we may need a better analog read resolution with a range between 0
    and 4095 instead of 0 and 1023\. In this case, we should change the resolution
    using the `analogReadResolution` parameter. We can find more information about
    the analog input resolution in the official documentation at [http://arduino.cc/en/Reference/AnalogReadResolution](http://arduino.cc/en/Reference/AnalogReadResolution).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the read is complete, we print the result in the serial port so that we
    can read these values through the Arduino IDE serial monitor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the main `loop()` function, add the `printRawData()` function call for each
    reading timeslot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are making the `TIMESLOTS` iterations so that we can get readings for 10
    seconds, as defined earlier. After all the readings are done, we print a message
    on the serial port and wait for a second before starting again with the readings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The delay of a second and the **Done!** message are only proof of the concept
    that the reading cycle is working correctly. We will remove them later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this configuration, we can upload the sketch and proceed with our first
    experiment. Put the bottom side of your index finger on the photoresistor while
    the LED is put on the other side.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get finer readings, it's better if the contact part with the photoresistor
    and the LED is the part between the phalanx and the nail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the experiment, click on the **Serial Monitor** button and when the
    sketch prints the **Done!** message, we will see some values as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting data from the sketch](img/1942OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the absolute values that the light sensor caught during our heartbeats.
    If we copy and paste a full 10 seconds iteration into Microsoft Excel, Libre Office
    Calc, or Numbers spreadsheet, we can draw a line chart and see the given results
    in a more understandable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting data from the sketch](img/1942OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the values change over time, and when a heartbeat occurs, the
    light sensor detects a variation of the light intensity and this event causes
    a peak in our chart. In other words, we can assume that every peak is related
    to a single heartbeat. The next step is to improve our sketch to approximate and
    convert these values, because we should try to remove reading errors and false
    positives. The main idea is to collect a fixed number of samples after each iteration
    to store the difference between this reading and the last one. If we store all
    differences over the time, we can easily find the trend of our readings and recognize
    when we read a peak. To improve our algorithm, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following variables on the top of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set how many `SAMPLES` we use to calculate the incremental differences. We
    then use `lastReading`, `i`, and `delta` variables to store respectively the last
    reading, the current index to iterate the `readings` array and the current difference
    from the last reading. We then define an accumulator to store the current total
    reading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize the `readings` array in the setup function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `collectReads()` function at the bottom of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first part we are going to read the current value and calculate the difference
    from the last reading. Then we accumulate this difference using the current `totalReading`
    and the last stored difference in the `readings` array. We can now update the
    `readings` array with the new `delta` object for the current index, which is incremented
    in the last line and is kept within bounds using the *modulo operator*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the main `loop()` function, substitute the `printRawData()` function call
    with the new `collectReads()` function and then print the accumulated value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With these enhancements, we can upload the new sketch and repeat the experiment
    in the same way we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: Put your index finger between the photoresistor and the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **serial monitor** on the Arduino IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete a full 10 seconds iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the values into the previous spreadsheet and draw a bar chart.
    We should avoid including the first eight readings because they are related to
    the first iteration where the `readings` array is not initialized yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The collected values produce a chart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting data from the sketch](img/1942OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In these processed readings, there are fluctuations between positive and negative
    values and this occurs when we are climbing or descending the peaks we saw in
    the first chart. With this knowledge, we can improve a little of our algorithm
    so that we can track the climbing or descending phase and choose whether to discard
    the reading or count it as a single heartbeat. To complete this part, we need
    to add the following code using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these declarations at the top of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the `POS_THRESHOLD` and `NEG_THRESHOLD` parameters to set the bounds
    of the interval in which we discard values to avoid false positives. We also define
    a `PERMINUTE` constant to know which is the multiplier to get the beats per minute
    and the `beats` accumulator. As a last declaration, we set the `hillClimb` variable
    to store if the next readings are in the ascending or descending phase. For instance,
    a `True` value means that we are in the ascending phase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `findBeat()` function at the bottom of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We check whether the `totalReading` parameter is below `NEG_THRESHOLD` parameter
    to know whether we are in the descending phase of a peak. In this case, we set
    the `hillClimb` variable to `True`. In the last code block, we check whether we
    are over the `POS_THRESHOLD` and in the ascending phase. In that case, we set
    the `hillClimb` to `False` and count this phase change as a heartbeat. If we take
    a look at the previous chart, through the preceding code we can easily determine
    in which phase we are during each reading, and with this information we can discard
    as many errors and false positives as possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the utility function `calcHeartRate()` at the bottom of the sketch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main `loop()` function, add the following code to use the previous functions
    and to print the heart rate with the number of beats in the serial port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Upload the sketch again and start to count the heartbeats. In the serial monitor,
    we will notice the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last improvement for our sketch is to add the ADK functionalities to send
    computed heartbeats to our Android application. At the top of the sketch, add
    the following *accessory descriptor*, which is almost equal to the one we used
    in the previous prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, in the main `loop()` function, wrap the sketch execution
    in the ADK communication and remove all serial prints together with the last delay
    of a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the heart rate monitor will start when the ADK communication is
    up and running and we will use the `adk.write()` function to send the computed
    heart rate back to the Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Android for data visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our physical application has a fully working circuit to read our heart
    rate through an unconventional use of a light sensor, we should complete the prototype
    with an Android application. From the Android Studio, start a new Android project
    called *HeartMonitor* with **Android API 19**. During the bootstrap process, choose
    a **Blank Activity** named *Monitor*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start writing the application from the user interface, and we have to think
    and design the activity layout. For the purpose of this application, we write
    a simple layout with a title and a text component that we will update every time
    Android receives a heartbeat estimation from the sketch. This layout could be
    achieved through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `styles.xml` file under `res/values/`,add these color declarations and
    replace the standard theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AppTheme` parameter inherits the `Theme.AppCompat` parameter that refers
    to the *Holo Dark* theme available in the Android support library. We also create
    green and red colors that we will use later in our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `activity_monitor.xml` file under `res/layout/`, replace the root layout
    with the highlighted changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `TextView` parameter included in the preceding layout with the following
    code to have a bigger green title that will show the application name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Nest a new `LinearLayout` in the root layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set a margin from the previous element, using all available space to place
    the inner components in a center position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following TextViews to show the label and the placeholder that will
    contain the computed beats per minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the widget within the activity class in order to change it after each
    reading. Add the following declaration at the top of the `Monitor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the view identified by the `bpm` identifier in the `onCreate()` callback
    through the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Without any further configuration, the following is the obtained layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android for data visualization](img/1942OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The application layout is now complete and we can proceed to setup the ADK communication.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the ADKToolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like we did for the first prototype, we need to write all ADK classes and methods
    again to send and receive data. However, because a good principle of software
    development is Don't repeat yourself (DRY), we are going to use an external library
    that provides a high abstraction for all needed functionalities. The library is
    called **ADKToolkit** and it's a wrapper for the native ADK APIs that prevents
    code duplication every time we start a new project. We can find more information
    and examples related to the library at [http://docs.adktoolkit.org](http://docs.adktoolkit.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step that is required is to add the ADKToolkit library to the application
    dependencies. In the projects built with Android Studio, we have two different
    files called `build.gradle`. These files contain all the configurations related
    to the Gradle build system, and one of them is related to the global project,
    while the other is related to the module application we''re building. Even if
    both the files contain a list of dependencies, we should add the library to the
    `build.gradle` file related to the application module, which is located in the
    `app` folder. If we''re using the **Project** panel available on the left of the
    Android Studio interface, we have to double-click on the **build.gradle (Module:
    app)** script. In this file, we need to add the highlighted code within the `dependencies`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we can click on the **Sync Now** button available in the flash message and
    wait for gradle to complete the synchronization process that downloads the ADKToolkit
    library automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did in [Chapter 2](ch02.html "Chapter 2. Know Your Tools"), *Know your
    Tools*, we should update the Android manifest file to register the application
    with the correct intent filter and accessory descriptor. To proceed with the ADK
    configuration, follow these reminders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the accessory filter file `usb_accessory_filter.xml` located under `res/xml/`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the USB `<uses-feature>` tag in the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the activity block of the `AndroidManifest.xml` file, add the ADK `<intent-filter>`
    and the `<meta-data>` tags to set the USB accessory filter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we must initialize the ADKToolkit library to enable the communication and
    start reading processed data. In the `Monitor` class, add the following snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `AdkManager` object at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `AdkManager` initialization in the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AdkManager` is the main class of the ADKToolkit library. To initialize
    the manager instance, we should pass the current context to its constructor, and
    because the activity class inherits from `Context` class, we can simply pass the
    instance using the `this` keyword. All functionalities related to the ADK communication
    will be used through the `mAdkManager` instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Override the `onResume()` and `onPause()` callbacks to start and stop the ADK
    connection when the `Monitor` activity is opening or closing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `mAdkManager` instance exposes the `close()` and `open()` methods to control
    easily the accessory connection. We have to bear in mind that it's a requirement
    to open the ADK communication in the `onResume()` method, because the `AdkManager`
    initialization is not sufficient to enable the channel between Android and Arduino.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the previous steps, we have completed the ADK configuration and now we
    can start to write the logic to receive data from the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous data readings from Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main concept of our Android application is to use the ADKToolkit to make
    continuous readings of data collected by UDOO board. Every time estimations are
    written in the OTG serial port, we need to read these values and update the Android
    user interface, but, before we proceed, we need to make some considerations about
    the Android threading system.
  prefs: []
  type: TYPE_NORMAL
- en: When an Android application starts, all the components of this application run
    in the same process and thread. This is called the **main thread** and it hosts
    among other components, the current foreground `Activity` instance. Whenever we
    need to update any views of the current activity, we should run the updating code
    in the main thread, otherwise the application will crash. On the other hand, we
    have to bear in mind that any operation done in the main thread should be completed
    immediately. If our code is slow or if it makes blocking operations such as I/O,
    the system that will popup the **Application Not Responding** (**ANR**) dialog
    because the main thread is unable to handle user input events.
  prefs: []
  type: TYPE_NORMAL
- en: This error will surely occur if we run continuous readings in the main thread,
    because we should query the light sensor in a cycle, which causes blocking I/O
    operations every 10 seconds. For these reasons, we can make use of an `ExecutorService`
    class that can run periodical scheduled threads. In our case, we will define a
    short-lived thread that will be created every 10 seconds from the above scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the scheduled thread finishes reading data from the OTG serial port, it
    should communicate the received message to the main thread through a `Handler`
    class. We can find more information and examples about how to communicate with
    the main thread in the official Android documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.android.com/training/multiple-threads/communicate-ui.html](https://developer.android.com/training/multiple-threads/communicate-ui.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step we should expose all the required methods to update the Android
    user interface through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java interface called `OnDataChanges` and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Through this code, we define the interface that we will use in our `Handler`
    to update the user interface with the given `heartRate` parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the interface in the `Monitor` class through the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following code at the end of the class to update the Android user
    interface through the `updateBpm` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last required step is to implement our scheduled thread that reads processed
    data from Arduino and writes these values in the user interface. To complete this
    last building block, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package in your namespace called `adk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `adk` package, add a new class named `DataReader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class, add the following declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We're defining the heartbeat polling time and an `int` variable that we use
    later to identify the published message within our handler. We also store the
    references for the `AdkManager` parameter and the `caller` activity to use the
    ADK `read` method and the `updateBpm` callback, respectively. Then we define our
    `ExecutorService` implementation together with a `Handler` that we will attach
    to the main thread.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `DataReader` constructor to define the handling message code
    when the main thread receives a new message from the background thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After storing the `AdkManager` instance and `caller` activity references, we
    attach a new `Handler` to the application's main looper, which lives in the main
    thread. We should override the `handleMessage` callback in order to check the
    user defined message code to identify the `HEARTBEAT_READ` message. In this case,
    we call the `updateBpm` callback using the object attached to the received `message`
    parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Each `Handler` has its own namespace for message codes, so you do not need to
    worry about your `message.what` attribute's possible values conflicting with the
    other handlers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the bottom of the `DataReader` class, add the following private class that
    implements the `Runnable` interface to read and publish sensor data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the thread starts, we read the available data using the `AdkManager read`
    method. This method returns an `AdkMessage` instance that contains the raw received
    bytes and some utilities to parse the response; in our case, we use the `getByte`
    method to get the first received byte. As the last step, we should publish the
    collected value through the main thread handler. We then create a `Message` instance
    using the `obtainMessage` method, which will pull a new message from the handler
    messages pool. Now we can dispatch the message to the main thread using the `sendToTarget`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `DataReader start()` method to start a scheduler that spawns threads
    periodically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we call this method from the `Monitor` activity, the `ExecutorService`
    parameter will be initialized using the `newSingleThreadScheduledExecutor()` function.
    This will create a single-threaded executor that guarantees to execute no more
    than one task at any given time despite the polling period. As the last step,
    we use a periodical scheduler to run our `SensorThread` every `HEARTBEAT_POLLING`
    milliseconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `stop()` method to the `DataReader` class to stop the schedule from
    spawning new threads. In our case, we simply use the `shutdown()` executor''s
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we should go back to the `Monitor` class to start and stop our thread scheduler
    within the activity lifecycle. Add the `DataReader` declaration at the top of
    the `Monitor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start and stop the reading scheduler in the `onResume()` and `onPause()` activity''s
    callbacks, as you can see in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is nothing left to do and our prototype is ready to be deployed. Now we
    can put our index finger between the photoresistor and the LED and take a look
    at the Android application while the result is updated each 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if the prototype obtains good results, we may want more accurate readings.
    A great enhancement for the physical application can be reached with a better
    housing for the photoresistor and the bright LED. Indeed, if we can remove the
    environment light and make both components more stable during readings, we can
    have great improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good approach to achieve this goal is to use an easy-to-get component: *a
    wooden peg*. We can drill the peg in one go, so the holes are lined up. In this
    way, we can put the photoresistor in one hole while the LED is in the other one.
    The rest of components and the breadboard itself remain unaltered. The following
    illustration shows a wooden peg to house both the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing the prototype](img/1942OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another improvement is to change and play with the algorithm parameters available
    in the sketch. Changing the interval and the samples number may obtain better
    results; however, we have to keep in mind that these changes may also get worse
    readings. The following is a collection of algorithm parameters that we may change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For instance, if we find that our photoresistor works badly with 50 milliseconds
    of the `HEARTBEAT_POLL_PERIOD` object-like macro, we may try to use more common
    timings such as 100 or 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the use of external sensors to improve the capabilities
    of our physical applications. We discovered how a sensor works and we took a look
    at an example that detects distance and object proximity.
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, we got some information about the biological process of the
    heartbeat and we found how a photoresistor together with a bright LED could help
    us to detect the heart rate. We did some initial experiments using our first heart
    monitor prototype and collected various absolute values that we plotted later
    into a chart. After the first analysis, we saw that each peak could be a heartbeat
    and this brought us to enhance the reading phase with an algorithm capable of
    computing differences between readings during chosen intervals.
  prefs: []
  type: TYPE_NORMAL
- en: With the previous values, we plotted a new chart and discovered that we should
    check when there is a phase change to find a possible heartbeat. Indeed, our last
    work was to add a function to calculate the heart rate ready to be sent back to
    the Android application through the ADK communication protocol.
  prefs: []
  type: TYPE_NORMAL
- en: To show the previous result, we created a layout for our Android application.
    We configured and used the ADKToolkit library to simplify the communication process.
    Through a `ScheduledExecutorService` instance, that launches short-lived threads
    for data collection, we set the processed heart rate in a custom user interface.
    At the end of this chapter, we explored how to improve our working prototype with
    some advice that we can follow before proceeding with the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build another physical application that uses an
    external component to control the Android application. It will make use of some
    Android native APIs to realize, in an easy way, some features that will not be
    possible without an over complicated hardware and sketch.
  prefs: []
  type: TYPE_NORMAL
