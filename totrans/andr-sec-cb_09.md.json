["```kt\n    static {\n      Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n    }\n    ```", "```kt\n    public static SecretKey generateAESKey(int keysize)\n          throws NoSuchAlgorithmException {\n        final SecureRandom random = new SecureRandom();\n\n        final KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n        generator.init(keysize, random);\n        return generator.generateKey();\n      }\n    ```", "```kt\n    private static IvParameterSpec iv;\n\n    public static IvParameterSpec getIV() {\n        if (iv == null) {\n          byte[] ivByteArray = new byte[32];\n          // populate the array with random bytes\n          new SecureRandom().nextBytes(ivByteArray);\n          iv = new IvParameterSpec(ivByteArray);\n        }\n        return iv;\n      }\n    ```", "```kt\n    public static byte[] encrpyt(String plainText)\n        throws GeneralSecurityException, IOException {\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, getKey(), getIV());\n        return cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n      }\n\n      public static SecretKey getKey() throws NoSuchAlgorithmException {\n        if (key == null) {\n          key = generateAESKey(256);\n        }\n        return key;\n      }\n    ```", "```kt\n    public static String decrpyt(byte[] cipherText)\n          throws GeneralSecurityException, IOException {\n          final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n          cipher.init(Cipher.DECRYPT_MODE, getKey(),getIV());\n          return cipher.doFinal(cipherText).toString();\n        }\n    ```", "```kt\n  final Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"SC\");\n```", "```kt\nbyte[] myCustomSeed = new byte[] { (byte) 42 };\nsecureRandom.setSeed(myCustomSeed);\nint notRandom = secureRandom.nextInt();\n```", "```kt\n    SharedPreferences prefs = SecurePreferences(context);\n\n    Editor edit = prefs.edit();\n    edit.putString(\"pref_fav_book\", \"androidsecuritycookbook\");\n    edit.apply();\n    ```", "```kt\n    private SharedPreferences mPrefs;\n    public final SharedPreferences getSharedPrefs() {\n        if (null == mPrefs) {\n          mPrefs = new SecurePreferences(YourApplication.this);\n        }\n        return mPrefs;\n      }\n    ```", "```kt\n    private SharedPreferences mPrefs;\n    protected final SharedPreferences getSharedPrefs() {\n        if (null == mPrefs) {\n          mPrefs = YourApplication.getInstance().getSharedPrefs();\n        }\n        return mPrefs;\n      }\n    ```", "```kt\n    <?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n    <map>\n    <int name=\"timeout \" value=\"500\" />\n    <boolean name=\"is_logged_in\" value=\"true\" />\n    <string name=\"pref_fav_book\">androidsecuritycookbook</string>\n    </map>\n    ```", "```kt\n    <?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n    <map>\n    <string name=\"MIIEpQIBAAKCAQEAyb6BkBms39I7imXMO0UW1EDJsbGNs\">\n    HhiXTk3JRgAMuK0wosHLLfaVvRUuT3ICK\n    </string>\n    <string name=\"TuwbBU0IrAyL9znGBJ87uEi7pW0FwYwX8SZiiKnD2VZ7\"> va6l7hf5imdM+P3KA3Jk5OZwFj1/Ed2\n    </string>\n    <string name=\"8lqCQqn73Uo84Rj\">k73tlfVNYsPshll19ztma7U\">\n    tEcsr41t5orGWT9/pqJrMC5x503cc=\n    </string>\n    </map>\n    ```", "```kt\n      private static IvParameterSpec iv;\n\n      public static IvParameterSpec getIV() {\n        if (iv == null) {\n          iv = new IvParameterSpec(generateRandomByteArray(32));\n        }\n        return iv;\n      }\n\n      private static byte[] salt;\n\n      public static byte[] getSalt() {\n        if (salt == null) {\n          salt = generateRandomByteArray(32);\n        }\n        return salt;\n      }\n\n      public static byte[] generateRandomByteArray(int sizeInBytes) {\n        byte[] randomNumberByteArray = new byte[sizeInBytes];\n        // populate the array with random bytes using non seeded secure random\n        new SecureRandom().nextBytes(randomNumberByteArray);\n        return randomNumberByteArray;\n      }\n    ```", "```kt\n    public static SecretKey generatePBEKey(char[] password, byte[] salt)\n          throws NoSuchAlgorithmException, InvalidKeySpecException {\n\n        final int iterations = 10000;\n        final int outputKeyLength = 256;\n\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec keySpec = new PBEKeySpec(password, salt, iterations, outputKeyLength);\n        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n        return secretKey;\n      }\n    ```", "```kt\n    public static byte[] encrpytWithPBE(String painText, String userPassword)\n          throws GeneralSecurityException, IOException {\n\n        SecretKey secretKey = generatePBEKey(userPassword.toCharArray(),getSalt());\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, getIV());\n        return cipher.doFinal(painText.getBytes(\"UTF-8\"));\n      }\n    ```", "```kt\n    public static String decrpytWithPBE(byte[] cipherText, String userPassword)\n          throws GeneralSecurityException, IOException {\n\n        SecretKey secretKey = generatePBEKey(userPassword.toCharArray(),getSalt());\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, getIV());\n        return cipher.doFinal(cipherText).toString();\n      }\n    ```", "```kt\nSecretKeyFactory secretKeyFactory;\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\nsecretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1And8bit\");\n} else {\nsecretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n}\n```", "```kt\n    private static final int DB_VERSION = 1;\n      private static final String DB_NAME = \"my_encrypted_data.db\";\n\n      public void initDB(Context context, String password) {\n             SQLiteDatabase.loadLibs(context);\n           SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(DB_NAME, password, null);\n              database.execSQL(\"create table MyTable(a, b)\");\n\n      }\n    ```", "```kt\n    import net.sqlcipher.database.SQLiteOpenHelper;\n\n    public class SQLCipherHelper extends SQLiteOpenHelper {\n    private static final int DB_VERSION = 1;\n\n    private static final String DB_NAME = \"my_encrypted_data.db\";\n\n    public SQLCipherHelper (Context context) {\n        super(context, DB_NAME, null, DB_VERSION);\n        SQLiteDatabase.loadLibs(context);\n\n    }\n    }\n    ```", "```kt\n    public static final String ANDROID_KEYSTORE = \"AndroidKeyStore\";\n\n      public void loadKeyStore() {\n        try {\n          keyStore = KeyStore.getInstance(ANDROID_KEYSTORE);\n          keyStore.load(null);\n        } catch (Exception e) {\n          // TODO: Handle this appropriately in your app\n          e.printStackTrace();\n        }\n      }\n    ```", "```kt\n      public void generateNewKeyPair(String alias, Context context)\n          throws Exception {\n\n        Calendar start = Calendar.getInstance();\n        Calendar end = Calendar.getInstance();\n        // expires 1 year from today\n        end.add(1, Calendar.YEAR);\n\n        KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context)\n    .setAlias(alias)\n    .setSubject(new X500Principal(\"CN=\" + alias))\n    .setSerialNumber(BigInteger.TEN)\n    .setStartDate(start.getTime())\n    .setEndDate(end.getTime())\n    .build();\n\n        // use the Android keystore\n        KeyPairGenerator gen = KeyPairGenerator.getInstance(\"RSA\", ANDROID_KEYSTORE);\n        gen.initialize(spec);\n\n        // generates the keypair\n        gen.generateKeyPair();\n      }\n    ```", "```kt\n      public PrivateKey loadPrivteKey(String alias) throws Exception {\n\n        if (keyStore.isKeyEntry(alias)) {\n          Log.e(TAG, \"Could not find key alias: \" + alias);\n          return null;\n        }\n\n        KeyStore.Entry entry = keyStore.getEntry(KEY_ALIAS, null);\n\n        if (!(entry instanceof KeyStore.PrivateKeyEntry)) {\n          Log.e(TAG, \" alias: \" + alias + \" is not a PrivateKey\");\n          return null;\n        }\n\n        return ((KeyStore.PrivateKeyEntry) entry).getPrivateKey();\n      }\n    ```", "```kt\n    <device-admin  >\n        <uses-policies>\n            <force-lock />\n            <encrypted-storage />\n        </uses-policies>\n    </device-admin>\n    ```", "```kt\n    public class AppPolicyReceiver extends DeviceAdminReceiver {\n\n      // Called when the app is about to be deactivated as a device administrator.\n      @Override\n      public void onDisabled(Context context, Intent intent) {\n        // depending on your requirements, you may want to disable the // app or wipe stored data e.g clear prefs\n        context.getSharedPreferences(context.getPackageName(),\n            Context.MODE_PRIVATE).edit().clear().apply();\n        super.onDisabled(context, intent);\n      }\n\n      @Override\n      public void onEnabled(Context context, Intent intent) {\n        super.onEnabled(context, intent);\n\n        // once enabled enforce\n        AppPolicyController controller = new AppPolicyController();\n        controller.enforceTimeToLock(context);\n\n        controller.shouldPromptToEnableDeviceEncrpytion(context);\n      }\n\n      @Override\n      public CharSequence onDisableRequested(Context context, Intent intent) {\n        // issue warning to the user before disable e.g. app prefs // will be wiped\n        return context.getText(R.string.device_admin_disable_policy);\n      }\n    }\n    ```", "```kt\n    <receiver\n           android:name=\"YOUR_APP_PGK.AppPolicyReceiver\"\n           android:permission=\"android.permission.BIND_DEVICE_ADMIN\" >\n           <meta-data\n             android:name=\"android.app.device_admin\"\n             android:resource=\"@xml/admin_policy_encryption_and_lock_timeout\" />\n\n           <intent-filter>\n             <action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" />\n             <action android:name=\"android.app.action.DEVICE_ADMIN_DISABLED\" />\n             <action android:name=\"android.app.action.DEVICE_ADMIN_DISABLE_REQUESTED\" />\n           </intent-filter>\n    </receiver>\n    ```", "```kt\n    public class AppPolicyController {\n\n      public boolean isDeviceAdminActive(Context context) {\n        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context\n            .getSystemService(Context.DEVICE_POLICY_SERVICE);\n\n        ComponentName appPolicyReceiver = new ComponentName(context,\n            AppPolicyReceiver.class);\n\n        return devicePolicyManager.isAdminActive(appPolicyReceiver);\n      }\n      public Intent getEnableDeviceAdminIntent(Context context) {\n\n        ComponentName appPolicyReceiver = new ComponentName(context,\n            AppPolicyReceiver.class);\n\n        Intent activateDeviceAdminIntent = new Intent(\n            DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);\n\n        activateDeviceAdminIntent.putExtra(\n            DevicePolicyManager.EXTRA_DEVICE_ADMIN, appPolicyReceiver);\n\n        // include optional explanation message\n        activateDeviceAdminIntent.putExtra(\n            DevicePolicyManager.EXTRA_ADD_EXPLANATION,\n            context.getString(R.string.device_admin_activation_\n    message));\n\n        return activateDeviceAdminIntent;\n      }\n\n    public Intent getEnableDeviceEncryptionIntent() {\n        return new Intent(DevicePolicyManager.ACTION_START_ENCRYPTION);\n      }\n    ```", "```kt\n      private static final long MAX_TIME_TILL_LOCK = 3 * 60 * 1000;\n\n      public void enforceTimeToLock(Context context) {\n        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context\n            .getSystemService(Context.DEVICE_POLICY_SERVICE);\n\n        ComponentName appPolicyReceiver = new ComponentName(context,\n            AppPolicyReceiver.class);\n\n        devicePolicyManager.setMaximumTimeToLock(appPolicyReceiver,\n            MAX_TIME_TILL_LOCK);\n      }\n    ```", "```kt\n    public boolean shouldPromptToEnableDeviceEncryption(Context context) {\n        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context\n            .getSystemService(Context.DEVICE_POLICY_SERVICE);\n        int currentStatus = devicePolicyManager.getStorageEncryptionStatus();\n        if (currentStatus == DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE) {\n          return true;\n        }\n        return false;\n      }\n    }\n    ```", "```kt\n    public class AppPolicyDemoActivity extends Activity {\n\n      private static final int ENABLE_DEVICE_ADMIN_REQUEST_CODE = 11;\n      private static final int ENABLE_DEVICE_ENCRYPT_REQUEST_CODE = 12;\n      private AppPolicyController controller;\n      private TextView mStatusTextView;\n\n      @Override\n      public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_app_policy);\n        mStatusTextView = (TextView) findViewById(R.id.deviceAdminStatus);\n\n        controller = new AppPolicyController();\n\n        if (!controller.isDeviceAdminActive(getApplicationContext())) {\n          // Launch the activity to have the user enable our admin.\n          startActivityForResult(\n              controller\n                  .getEnableDeviceAdminIntent(getApplicationContext()),\n              ENABLE_DEVICE_ADMIN_REQUEST_CODE);\n        } else {\n          mStatusTextView.setText(\"Device admin enabled, yay!\");\n          // admin is already activated so ensure policies are set\n          controller.enforceTimeToLock(getApplicationContext());\n          if (controller.shouldPromptToEnableDeviceEncrpytion(this)) {\n            startActivityForResult(\n                controller.getEnableDeviceEncrpytionIntent(),\n                ENABLE_DEVICE_ENCRYPT_REQUEST_CODE);\n          }\n        }\n\n      }\n    ```", "```kt\n      @Override\n      protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == ENABLE_DEVICE_ADMIN_REQUEST_CODE) {\n          if (resultCode != RESULT_OK) {\n            handleDevicePolicyNotActive();\n          } else {\n            mStatusTextView.setText(\"Device admin enabled\");\n            if (controller.shouldPromptToEnableDeviceEncrpytion(this)) {\n              startActivityForResult(\n                  controller.getEnableDeviceEncryptionIntent(),\n                  ENABLE_DEVICE_ENCRYPT_REQUEST_CODE);\n            }\n          }\n\n        } else if (requestCode == ENABLE_DEVICE_ENCRYPT_REQUEST_CODE\n            && resultCode != RESULT_OK) {\n          handleDevicePolicyNotActive();\n        }\n      }\n    ```", "```kt\n      private void handleDevicePolicyNotActive() {\n        Toast.makeText(this, R.string.device_admin_policy_breach_message,\n            Toast.LENGTH_SHORT).show();\n      }\n    }\n    ```", "```kt\n<meta-data  android:name=\"android.app.device_admin\"                android:resource=\"@xml/admin_policy_encryption_and_lock_timeout\" />\n```", "```kt\n<device-admin  >\n    <uses-policies>\n        <disable-camera />\n    </uses-policies>\n</device-admin>\n```"]