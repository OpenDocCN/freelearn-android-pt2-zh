- en: Chapter 7. Securing Application Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 保护应用数据
- en: An application developer's credibility depends on how securely they handle their
    user's data. It is always prudent to not store huge amounts of user data on the
    device. It not only eats up memory but is a huge security risk as well. However,
    there are use cases where applications need to share data, cache application preferences,
    and store data on the device. This data could be private to the application or
    shared with other applications. An example of such data could be the user's preferred
    language or book category. This kind of data is kept by the application to enhance
    the user experience. It is useful within the application itself and is not shared
    with other applications. An example of shared data could be the wish list of books
    that the user keeps adding to the collection as the user browsers through the
    store. This data may or may not be shared with other applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者的信誉取决于他们如何安全地处理用户数据。明智的做法是从不在设备上存储大量用户数据。这不仅会占用内存，而且是一个巨大的安全风险。然而，有些用例需要应用程序共享数据，缓存应用程序偏好设置，并在设备上存储数据。这类数据可能是应用程序私有的，也可能是与其他应用程序共享的。此类数据的例子可能是用户的偏好语言或书籍类别。应用程序保存此类数据是为了提升用户体验。它对应用程序本身有用，并且不与其他应用程序共享。共享数据的例子可能是用户在浏览商店时不断添加到收藏中的书籍愿望清单。此类数据可能会也可能不会与其他应用程序共享。
- en: Based on the privacy and kind of data, different storage mechanisms can be employed.
    An application can decide to use shared preferences, a Ccontent Provider, a file
    stored on internal or external memory, or even the developer's own servers to
    store data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据隐私和数据类型，可以采用不同的存储机制。应用程序可以选择使用共享偏好设置、内容提供者、存储在内部或外部内存中的文件，甚至是开发者自己的服务器来存储数据。
- en: This chapter begins with the most important question of identifying information
    that an application should store and how to make a decision on storage location
    for data. As is always the case, a minimum amount of information should be collected
    and user consent should be obtained before collecting sensitive information. Next,
    we discuss storage mechanisms in Android, including shared preferences, device
    storage, external storage, and storing data on the backend servers. We will discuss
    protocols to secure data in transit. We will close the chapter with a discussion
    on installing an application on external memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从最重要的问题开始，即确定应用程序应存储的识别信息以及如何决定数据的存储位置。通常情况下，应收集最少量的信息，并在收集敏感信息前获得用户同意。接下来，我们将讨论Android中的存储机制，包括共享偏好设置、设备存储、外部存储以及在后端服务器上存储数据。我们将讨论保护传输中数据的协议。我们将以讨论在外部存储上安装应用程序来结束本章。
- en: Data storage decisions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储决策
- en: A number of factors affect the data storage decision in the context of an application.
    Most of them are based on data security aspects that a developer should be aware
    of such as privacy, data retention, and implementation details of the system.
    These are discussed in the following sections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的背景下，许多因素会影响数据存储的决定。其中大部分是基于开发者应该了解的数据安全方面，如隐私、数据保留和系统实现细节。以下各节将讨论这些问题。
- en: Privacy
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐私
- en: Applications today collect and use different kinds of information about their
    users. User preferences, location, health records, financial accounts, and assets
    are some of them. The collection of such information should be done with care
    and with user consent, as collecting private information can cause legal and moral
    issues and can be termed as invasion of privacy. Even when such information is
    collected, it should be stored properly encrypted and transmitted securely. Secure
    data storage and transmission is the focus of the later half of the chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的应用程序收集和使用关于用户的不同类型的信息。用户偏好、位置、健康记录、金融账户和资产等都是其中的一部分。收集此类信息应当谨慎，并得到用户同意，因为收集私人信息可能引发法律和道德问题，并可能被视为侵犯隐私。即使收集了此类信息，也应妥善加密存储并安全传输。本章后半部分的重点是安全数据存储和传输。
- en: Privacy manifests itself in different forms. First, it is different in different
    cultures and countries. Each country has established rules and regulations about
    personally identifiable information, or PII. For example, the European Union has
    a **Data Protection Directive** for the processing and movement of personal data.
    More information can be found at this website maintained by the European Commission's
    Directorate General of Justice [http://ec.europa.eu/justice/data-protection/index_en.htm](http://ec.europa.eu/justice/data-protection/index_en.htm).
    Cyber laws in India about this can be found at [http://deity.gov.in/content/cyber-laws](http://deity.gov.in/content/cyber-laws).
    The United States follows a sectoral approach to data protection. This is a combination
    of legislation, regulation, and self-regulation, rather than government alone.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私以不同的形式表现。首先，在不同的文化和国家中是不同的。每个国家都建立了关于个人识别信息（PII）的规则和法规。例如，欧盟有一个关于处理和转移个人数据的**数据保护指令**。更多信息可以在欧洲委员会司法总司维护的此网站上找到：[http://ec.europa.eu/justice/data-protection/index_en.htm](http://ec.europa.eu/justice/data-protection/index_en.htm)。关于此方面的印度网络法律可以在[http://deity.gov.in/content/cyber-laws](http://deity.gov.in/content/cyber-laws)找到。美国采取的是分部门的数据保护方法。这是立法、监管和自我监管的结合，而不是仅由政府执行。
- en: Second, there are different laws for different use cases. For example, if an
    application is related to medical or health then the rules are different from
    an application that is tracking user location or making financial transactions.
    Some examples of specific laws in the United States are the Americans with Disability
    Act, Children's Online Privacy Act of 1998, and Electronic Communication Privacy
    Act of 1986\. So, it is important to be aware of the rules and regulations pertaining
    to your use case and of the country in which you want to operate. When in doubt,
    use the services of companies that are experts in their field. For example, instead
    of trying to work out your own payment system, you might like to use a payment
    provider such as PayPal that has been doing payment processing for years and is
    compliant with rules and regulations such as PCI in this space.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，不同的使用场景有不同的法律。例如，如果一个应用程序与医疗或健康相关，那么其规则与跟踪用户位置或进行金融交易的应用程序是不同的。美国一些具体的法律例子包括美国残疾人法案、1998年的儿童在线隐私法案和1986年的电子通信隐私法案。因此，了解与您的使用案例以及您希望运营的国家相关的规则和法规非常重要。如有疑问，可以寻求在其领域内具有专业知识的公司的服务。例如，与其尝试建立自己的支付系统，不如使用像PayPal这样的支付提供商，后者已经进行了多年的支付处理，并且符合此领域如PCI等的规则和法规。
- en: Third, the transfer of private information from one country to another falls
    under rules and regulations as well. In most cases, the other country should have
    sufficient protection laws to satisfy the protection criterion of the other country.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，从一个国家向另一个国家转移私人信息也受到规则和法规的约束。在大多数情况下，另一个国家应具备足够的保护法律以满足另一国家的保护标准。
- en: 'The Universal Declaration of Human Rights, Article 12, states the privacy rule
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 《世界人权宣言》第12条规定了隐私规则如下：
- en: '*"No one shall be subjected to arbitrary interference with his privacy, family,
    home or correspondence, nor to attacks upon his honour and reputation. Everyone
    has the right to the protection of the law against such interference or attacks."*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"任何人不得受到任意干涉其隐私、家庭、住宅或通信，也不得受到对其荣誉和声誉的攻击。每个人都有权受到法律的保护，以免受到此类干涉或攻击。"*'
- en: Some examples of PII include full name, e-mail address, mailing address, driving
    license, voter registration number, date of birth, mother's maiden name, birthplace,
    credit card numbers, criminal records, and national identification number. In
    some cases, age, gender, job position, and race may be considered as PII. Sometimes
    privacy may mean anonymity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PII的一些例子包括全名、电子邮件地址、邮寄地址、驾驶执照、选民登记号、出生日期、母亲的婚前姓、出生地、信用卡号码、犯罪记录和国民身份证号码。在某些情况下，年龄、性别、工作职位和种族可能被视为PII。有时，隐私可能意味着匿名。
- en: If your application is collecting PII, you will have to disclose it to your
    users and maybe take their consent. You can present them with terms and conditions
    for using the application or using certain features that might require your application
    to collect sensitive information about users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序正在收集PII，您将不得不向用户披露，并可能需要获得他们的同意。您可以向他们展示使用应用程序或使用可能需要您的应用程序收集有关用户的敏感信息的特定功能的条款和条件。
- en: Data retention
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据保留
- en: Data retention refers to the storage of data for the particular period of time.
    This data is used for tracing and identifying information such as people, devices,
    and location. For example, banking data is usually saved for seven years. Data
    retention should not be an issue in most use cases, unless it is an organization
    catering to a specific use case such as postal, banking, government, telecommunication,
    public health, and safety. In most cases, proper access rights have to be defined
    for access of this PII. Again, data retention rules are different for different
    countries and different use cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据保留是指在一定时间内存储数据。这种数据用于追踪和识别如人员、设备和位置等信息。例如，银行数据通常保存七年。在大多数使用场景中，数据保留不应成为问题，除非是针对特定使用场景的组织，如邮政、银行、政府、电信、公共卫生和安全。在大多数情况下，必须为访问此类个人识别信息（PII）定义适当的访问权限。同样，不同国家和不同使用场景的数据保留规则是不同的。
- en: Implementation decisions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施决策
- en: 'When dealing with data and deciding upon the most secure security mechanism,
    the first question is to identify where that data will be stored. Let''s go back
    to our bookstore example. As we identified in [Chapter 3](ch03.html "Chapter 3. Permissions"),
    *Permissions*, the data elements of our example are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据并决定最安全的安全机制时，第一个问题是确定数据将存储在哪里。让我们回到我们的书店示例。正如我们在[第3章](ch03.html "第3章. 权限")，*权限*中所确定的那样，我们示例中的数据元素是：
- en: Name
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Credit card number
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡号码
- en: Mailing address
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮寄地址
- en: Last author searched
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后搜索的作者
- en: Last language searched
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后搜索的语言
- en: Last category searched
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后搜索的分类
- en: Username
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Password
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Wish list of books
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍愿望清单
- en: Further analysis of the preceding assets, based on their privacy needs, leads
    us to the identification of PII as name, credit card number, mailing address,
    and password. Please note that this classification is changed based on the country
    as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的隐私需求对上述资产进行进一步分析，我们确定了PII为姓名、信用卡号码、邮寄地址和密码。请注意，这种分类也会根据国家而改变。
- en: Next is the question of persistence. Do we want data to be available only during
    one instance of the application or multiple instances? Do we want the data to
    persist resets? In our example, we would like all the assets to be persisted.
    However, if the user preferences such as author, category, and language do not
    persist resets, we do not lose valuable information and the user can select them
    again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是持久性的问题。我们希望数据在应用程序的一个实例中可用，还是在多个实例中？我们希望数据在重置后仍然存在吗？在我们的示例中，我们希望所有资产都能持久化。然而，如果用户偏好（如作者、分类和语言）在重置后不保留，我们并没有丢失有价值的信息，用户可以再次选择它们。
- en: The third important task is to identify which data is private to the application
    and which data is shared. Visibility of data will affect the storage option we
    choose.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项重要的任务是识别哪些数据对应用程序是私有的，哪些数据是共享的。数据的可见性将影响我们选择的存储选项。
- en: 'The fourth question is that of size of data. Large files should preferably
    be stored on external storage. The following figure shows the memory options available
    in a typical Android phone device:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个问题是数据的大小。大文件最好存储在外部存储上。下图展示了典型安卓手机设备中可用的内存选项：
- en: '![Implementation decisions](img/5603OT_07_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![实施决策](img/5603OT_07_01.jpg)'
- en: It is always advisable to use a storage mechanism provided by the framework
    instead of inventing a new one. In the sections that follow, I have discussed
    storage mechanisms provided by the Android framework for different storage needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 始终建议使用框架提供的存储机制，而不是发明一个新的。在以下各节中，我将讨论Android框架为不同存储需求提供的存储机制。
- en: User preferences
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户偏好
- en: An application collects user preferences in two ways. In the first case, an
    application presents a settings screen to the user to choose preferences such
    as language, number of results to show per page, and so on. Such preferences are
    best stored using the `Preference` class. The other case is when user preferences
    are picked up as the user navigates through the application. For example, when
    searching for a book, the user selects books by a particular author. An application
    might want to save such a preference for the next time when the user logs in.
    Such user preferences are best stored using `SharedPreferences`. Under the hood,
    the `Preference` class also calls `SharedPreferences`. Please note that `SharedPreferences`
    only persist primitive data types.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序以两种方式收集用户偏好设置。在第一种情况下，应用程序向用户展示设置屏幕，让用户选择如语言、每页显示的结果数量等偏好设置。这类偏好设置最好使用`Preference`类进行存储。另一种情况是在用户浏览应用程序时自动获取用户偏好设置。例如，在搜索书籍时，用户选择了特定作者的书籍。应用程序可能希望保存此类偏好设置，以便用户下次登录时使用。这类用户偏好设置最好使用`SharedPreferences`进行存储。需要注意的是，`Preference`类在底层也调用了`SharedPreferences`。请记住，`SharedPreferences`只能持久化基本数据类型。
- en: Shared preferences
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享偏好设置
- en: The `SharedPreferences` class is used to store primitive data types in a key-value
    pair. These primitive types include `int`, `long`, `Boolean`, `float`, `string
    set`, and `string`. Data stored in this `SharedPreferences` persists application
    sessions. A preference file is stored in the form of an XML file on the device
    in the `data` directory of the application. This file is thus sandboxed by the
    same Linux permissions as the application itself. The data in the preferences
    file persists even if the application is killed and is destroyed only when the
    application is uninstalled or specific values are removed using the methods of
    the `Preference` class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences`类用于以键值对的形式存储基本数据类型。这些基本类型包括`int`、`long`、`Boolean`、`float`、`string
    set`和`string`。存储在`SharedPreferences`中的数据在应用程序会话中持久存在。偏好文件以XML文件的形式存储在设备上应用程序的`data`目录中。因此，该文件受到与应用程序相同的Linux权限的沙盒保护。即使应用程序被杀死，偏好文件中的数据仍然存在，只有在应用程序被卸载或使用`Preference`类的方法删除特定值时，文件才会被销毁。'
- en: Three operations for any kind of data storage are instantiating storage, storing
    data, and retrieving data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类型的数据存储，有三个操作：实例化存储、存储数据和检索数据。
- en: Creating a preference file
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建偏好设置文件
- en: 'The following code snippet instantiates `SharedPreferences`, using the default
    filename:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段使用默认文件名实例化`SharedPreferences`：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The filename in this case can be retrieved using the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件名可以通过以下代码获取：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may specify the name of the preferences file as well. In the following
    example, the name of the preference file is `MyPref`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定偏好设置文件的名称。在以下示例中，偏好设置文件的名称为`MyPref`：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet brings up an important discussion about preference
    file visibility and sharing. By default, all preference files are private to the
    application that created it. So their mode is `MODE_PRIVATE`. If a preference
    file needs to be shared among different applications, it can either be set to
    `MODE_WORLD_WRITABLE` or `MODE_WORLD_READABLE` to allow other applications to
    write and read the preference file respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段引发了一个关于偏好文件可见性和共享的重要讨论。默认情况下，所有偏好文件都是创建它的应用程序私有的。因此，它们的模式是`MODE_PRIVATE`。如果需要在不同应用程序之间共享偏好文件，可以将其设置为`MODE_WORLD_WRITABLE`或`MODE_WORLD_READABLE`，分别允许其他应用程序写入和读取偏好文件。
- en: Writing preference
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入偏好设置
- en: The next step is to store primitive data into a preference file. The following
    code snippet follows from the preceding code snippet and shows how to add data
    into the preference file. You will notice that you need the `SharedPreferences.Editor`
    class to store values. All values in the `Editor` class are batched and need to
    commit for values to persist. In the following example, `MyString` is the key
    for the string and its value is `Hello World!`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将基本数据存储到偏好文件中。下面的代码片段紧接着前面的代码片段，展示了如何将数据添加到偏好文件中。你会注意到，需要使用`SharedPreferences.Editor`类来存储值。`Editor`类中的所有值都是批处理的，需要提交才能使值持久化。在以下示例中，`MyString`是字符串的键，其值为`Hello
    World!`。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reading preference
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取偏好设置
- en: 'The next step is to read the key-value pairs that are in the preference file.
    The following code snippet follows from the preceding code snippet and shows how
    to read data from the preference file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是读取偏好文件中的键值对。下面的代码片段紧接着前面的代码片段，展示了如何从偏好文件中读取数据：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`SharedPreferences` are accessible to all the components of the application.
    Other applications can write and read the preference file if set to `MODE_WORLD_WRITABLE`
    or `MODE_WORLD_READABLE` respectively.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences`可以被应用程序的所有组件访问。如果设置为`MODE_WORLD_WRITABLE`或`MODE_WORLD_READABLE`，其他应用程序可以写入和读取偏好设置文件。'
- en: To read the preference file of a different application, the first step is to
    get a pointer to the other application's context and then to read the value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取另一个应用程序的偏好设置文件，第一步是获取指向另一个应用程序上下文的指针，然后读取该值。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Preference Activity
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏好设置Activity
- en: With Honeycomb, Android extended the capabilities of the `Preference` class
    to collect settings from UI. These values are set as an XML file and the Activity
    inflates from it. Under the hood, the `Preference` class uses the `SharedPreferences`
    class to store key-value pairs. Such settings are private to the application and
    are only accessible by an `Activity` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从Honeycomb开始，Android扩展了`Preference`类的功能，以从UI收集设置。这些值被设置为XML文件，而Activity从中加载。在幕后，`Preference`类使用`SharedPreferences`类来存储键值对。这些设置是应用程序私有的，只有`Activity`类可以访问。
- en: 'To select a ringtone, the following code has to be set up in the `Preference.xml`
    file under the `res/xml` directory:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择铃声，需要在`res/xml`目录下的`Preference.xml`文件中设置以下代码：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To inflate an Activity from this XML file, the following code is used in the
    `onCreate()` method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要从该XML文件中加载一个Activity，可以在`onCreate()`方法中使用以下代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember to add this Activity in the manifest file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在清单文件中添加这个Activity。
- en: File
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: An application can use Android's filesystem to store and retrieve data as well.
    The `java.io` package provides this functionality. This package provides classes
    to write and read different data types from a file. By default, files created
    by applications are private to the application and cannot be accessed by other
    applications. Files persist reboots and application crashes; they are only removed
    when the application is uninstalled.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序也可以使用Android的文件系统来存储和检索数据。`java.io`包提供了这一功能。这个包提供了从文件中读写不同数据类型的类。默认情况下，应用程序创建的文件是私有的，其他应用程序无法访问。文件在重启和应用程序崩溃后仍然存在；只有在应用程序被卸载时才会被删除。
- en: Creating a file
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件
- en: The following code snippet shows how to create a file. As I have said before,
    by default, all files are private to the application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何创建一个文件。正如我之前所说，默认情况下，所有文件都是应用程序私有的。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The file `MyFile.txt` will be created in the `/data/data/<application-path>/files/`
    directory. The preceding file is created as `MODE_WORLD_READABLE`, that means
    that other applications can read this file. The other options are `MODE_WORLD_READABLE`,
    `MODE_PRIVATE`, and `MODE_APPEND` that let other applications write to the file,
    keep it private to the application, or append to it respectively. It is important
    to decide upon the appropriate visibility. As is always the rule with security,
    only give the least amount of visibility that is required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`MyFile.txt`将被创建在`/data/data/<application-path>/files/`目录中。前面提到的文件是作为`MODE_WORLD_READABLE`创建的，这意味着其他应用程序可以读取这个文件。其他选项分别是`MODE_WORLD_READABLE`、`MODE_PRIVATE`和`MODE_APPEND`，它们允许其他应用程序写入文件、保持文件对应用程序私有或向文件追加内容。决定适当的可见性很重要。在安全性方面，永远只给出所需的最小可见性。
- en: Since `MODE_WORLD_READABLE` and `MODE_WORLD_WRITABLE` are very dangerous options
    to have, starting API level 17, these options have been deprecated. If files still
    need to be shared between applications associated with the same certificate, the
    `android:sharedUserId` option can be used. If these are different applications
    then file access can be handled with a wrapper class that interfaces with the
    file and provides read and write functionality. Access to this wrapper class can
    be protected using permissions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MODE_WORLD_READABLE`和`MODE_WORLD_WRITABLE`是非常危险的选择，从API级别17开始，这些选项已被弃用。如果仍需要与同一证书关联的应用程序之间共享文件，可以使用`android:sharedUserId`选项。如果这些是不同的应用程序，则可以使用封装类来处理文件访问，并提供读写功能。可以通过权限来保护对此封装类的访问。
- en: Writing to a file
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件
- en: The next step is to write to a file. The following code snippet shows the use
    of the `OutputStreamWriter` class to write a string to a file. There are many
    options available in the `java.io` package to write different kinds of data to
    files. Please check the package to pick the correct option for your use case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是写入文件。以下代码段展示了如何使用`OutputStreamWriter`类将字符串写入文件。在`java.io`包中有许多选项可用于将不同类型的数据写入文件。请检查该包以选择适合您用例的正确选项。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Reading from a file
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: Again as stated earlier, please check out the `java.io` package to find the
    best method to read data from a file. The following code snippet shows how to
    read the string from the file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，请检查`java.io`包以找到从文件中读取数据的最佳方法。以下代码段展示了如何从文件中读取字符串。
- en: 'The following example reads one line at a time from the file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例一次从文件中读取一行：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: File operations on an external storage
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部存储上的文件操作
- en: A file can also be created on an external storage. If the API level is 8 or
    greater, Android provides a special function called `getExternalFilesDir()` to
    get the application directory on an external storage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件也可以创建在外部存储上。如果API级别为8或更高，Android提供了一个特殊的函数`getExternalFilesDir()`，用于获取外部存储上的应用程序目录。
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you will notice in the preceding code snippet, the `getExternalFilesDir()`
    method takes a parameter. This parameter is used to identify the appropriate storage
    directory based on the media type. For example, to store a picture, `ENVIRONMENT.DIRECTORY_PICTURES`
    is used, and to store a music file, `ENVIRONMENT.DIRECTORY_MUSIC` is used. If
    such a directory does not exist, it will be created and then the file will be
    stored there. The value `null` is the root directory of the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码段中注意到的，`getExternalFilesDir()`方法接受一个参数。此参数用于根据媒体类型识别适当的存储目录。例如，要存储图片，使用`ENVIRONMENT.DIRECTORY_PICTURES`，要存储音乐文件，使用`ENVIRONMENT.DIRECTORY_MUSIC`。如果这样的目录不存在，它将被创建，然后文件将存储在那里。值`null`是应用程序的根目录。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For an API level of less than 8, users can use `getExternalStorageDirectory()`
    to get the root of the external storage. The file can then be created in the `/Android/data/<application-path>/files/`
    directory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API级别小于8的情况，用户可以使用`getExternalStorageDirectory()`来获取外部存储的根目录。然后可以在`/Android/data/<application-path>/files/`目录中创建文件。
- en: To create a file on an external storage, the application should have the `WRITE_EXTERNAL_STORAGE`
    permission. The files created on external storage will be removed when the user
    uninstalls the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在外部存储上创建文件，应用程序应具有`WRITE_EXTERNAL_STORAGE`权限。创建在外部存储上的文件将在用户卸载应用程序时被移除。
- en: The external storage lacks the security mechanism of internal storage. It is
    best to assume that any data stored on the external storage is insecure and globally
    readable. And if external storage is not mounted, the file is not accessible and
    proper error handling mechanisms have to be employed for the application to fail
    gracefully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 外部存储缺少内部存储的安全机制。最好假设存储在外部存储上的任何数据都是不安全的，并且可以被全局读取。如果外部存储未挂载，文件将无法访问，必须采用适当的错误处理机制，以便应用程序优雅地失败。
- en: In some cases, an external storage may actually be desired, especially if the
    files have no PII and are intended to be shared and be available on different
    devices. The media scanner will scan these directories when searching for relevant
    content. These directories are listed as follows. These follow the root directory
    of the application `/data/data/<application-path>/`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能实际上需要外部存储，特别是如果文件不包含个人识别信息（PII），并且旨在跨不同设备共享和可用。媒体扫描器在搜索相关内容时会扫描这些目录。这些目录如下列出。这些目录遵循应用程序的根目录`/data/data/<application-path>/`。
- en: '**Audio (music) files**: `Music/`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频（音乐）文件**：`Music/`'
- en: '**Podcast files**: `Podcasts/`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播客文件**：`Podcasts/`'
- en: '**Video files (except for camcorder)**: `Movie/`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频文件（除摄像机外）**：`Movie/`'
- en: '**Ringtones**: `Ringtones/`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**铃声**：`Ringtones/`'
- en: '**Pictures**: `Pictures/`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片**：`Pictures/`'
- en: '**Miscellaneous downloads**: `Downloads/`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**杂项下载**：`Downloads/`'
- en: '**Notification sounds**: `Notifications/`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知声音**：`Notifications/`'
- en: '**Alarms**: `Alarms/`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闹钟**：`Alarms/`'
- en: Cache
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: If an application needs to cache data, it is prudent to use a cache storage
    mechanism provided by the Android stack. Android stores cache files in the filesystem
    along with the application so that they are sandboxed with the application that
    created it. All cache files are created in the `/data/data/<application-path>/cache/`
    directory. In case the system is running low on memory, these cache files are
    deleted first. Regular pruning of these files is necessary as they may grow big
    and eat up disk space.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序需要缓存数据，那么使用 Android 栈提供的缓存存储机制是明智的。Android 将缓存文件与应用程序一起存储在文件系统中，这样它们就会被创建它们的应用程序沙盒化。所有缓存文件都创建在`/data/data/<application-path>/cache/`目录中。当系统内存不足时，这些缓存文件会被首先删除。定期修剪这些文件是必要的，因为它们可能会变得很大并占用磁盘空间。
- en: The following code snippet first writes a string to the cache file and then
    reads the same string from the cache file. As you will notice, reading and writing
    is the same as any file input/output, only the location of the file is obtained
    using `getCacheDir()` to write a string.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段首先将字符串写入缓存文件，然后从缓存文件中读取相同的字符串。您会注意到，读取和写入与任何文件输入/输出都相同，只是使用`getCacheDir()`获取文件的位置来写入字符串。
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just as files can be created on an external storage, so can the cache files.
    The approach is different depending upon the API level. Starting with API level
    8, Android provides a special function called `getExternalCacheDir()` to get the
    cache directory on an external storage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与在外部存储上创建文件一样，也可以创建缓存文件。根据 API 级别，方法会有所不同。从 API 级别 8 开始，Android 提供了一个特殊的函数`getExternalCacheDir()`，用于获取外部存储上的缓存目录。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This directory is linked to the application and when the application in uninstalled
    this directory ceases to exist. If it is a multiuser environment each user has
    his/her own personal directory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录与应用程序关联，当应用程序被卸载时，这个目录将不复存在。如果是多用户环境，每个用户都有自己的个人目录。
- en: If the API level is less than 8, users can use `getExternalStorageDirectory()`
    to get the external storage, then create the file in the `/Android/data/<application-path>/cache/`
    directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 级别小于 8，用户可以使用`getExternalStorageDirectory()`获取外部存储，然后在`/Android/data/<application-path>/cache/`目录中创建文件。
- en: To create a cache on an external storage, the application should have the `WRITE_EXTERNAL_STORAGE`
    permission.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在外部存储上创建缓存，应用程序应具有`WRITE_EXTERNAL_STORAGE`权限。
- en: Creating a cache on an external storage is not without security concerns. First,
    if the external storage has not mounted the cache file, it is not accessible and
    proper error handling mechanisms have to be employed for the application to fail
    gracefully. Secondly, an external storage is inherently insecure so anything stored
    on external memory should be assumed to be globally readable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部存储上创建缓存并非没有安全顾虑。首先，如果外部存储没有挂载缓存文件，那么它是无法访问的，必须为应用程序实施适当的错误处理机制，以便应用程序能够优雅地失败。其次，外部存储本质上是安全的，因此应假定外部存储上的任何内容都是全局可读的。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The cache files should be pruned regularly and files that are not needed should
    be removed to preserve memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 应定期修剪缓存文件，并移除不需要的文件以保留内存。
- en: Database
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: A database is the best option to store structured data. Android provides support
    for SQLite using the `android.database.sqlite` package. This database is a part
    of the Android stack and the system administers the database. Using SQLite for
    mobile operating systems is a prudent choice as it is small and requires no setup
    or administration. And it is free!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是存储结构化数据的最佳选择。Android 通过`android.database.sqlite`包支持 SQLite。这个数据库是 Android
    栈的一部分，系统管理数据库。对于移动操作系统来说，使用 SQLite 是一个明智的选择，因为它体积小，无需设置或管理，且是免费的！
- en: Once created, the database files are sandboxed with the application and are
    stored in the `/data/data/<application-path>/databases/` directory. This private
    database will be accessible to all the components of the application but not outside
    the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，数据库文件与应用程序一起被沙盒化，并存储在`/data/data/<application-path>/databases/`目录中。这个私有数据库将对应用程序的所有组件开放，但不会对外开放。
- en: The following code snippet shows how to create a database that resides on the
    internal memory. The class will extend the `SQLiteOpenHelper` class and uses the
    SQL (Structured Query Language) `CREATE_TABLE` clause. The table stores a list
    of books that the user marks as a wish list. There are two columns in our table
    `wishlist`, a column ID that auto increments and the name of the book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何创建一个位于内部存储上的数据库。这个类将扩展`SQLiteOpenHelper`类，并使用SQL（结构化查询语言）的`CREATE_TABLE`子句。该表存储用户标记为心愿单的书籍列表。我们的表`wishlist`中有两列，一列是自动递增的ID，另一列是书名。
- en: You will notice two methods here, `onCreate()` and `onUpgrade()`. `OnCreate()`
    will create a new database (if it does not exist) and a new database table. If
    the database already exists, the method `onUpgrade()` is called.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里有两个方法，`onCreate()`和`onUpgrade()`。`onCreate()`将创建一个新的数据库（如果它不存在）以及一个新的数据库表。如果数据库已经存在，则会调用`onUpgrade()`方法。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, other database queries can be used to add a row, read a row, and
    delete a row. Any good book on SQL can help you with these queries.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，其他数据库查询可以用来添加一行、读取一行和删除一行。任何关于SQL的好书都可以帮助你完成这些查询。
- en: It is also possible to create a database that exists in external memory. Creating
    a custom context class that accepts directory paths can accomplish this. You also
    need to have write access to the external storage. However, it is not advisable
    to do so if there is sensitive information in the tables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能在外部内存中创建一个数据库。创建一个接受目录路径的自定义上下文类可以实现这一点。你还需要拥有对外部存储的写入权限。然而，如果表中有敏感信息，则不建议这样做。
- en: As I noted earlier, the SQLite database is a private database and is sandboxed
    with the application. In case this data need to be shared with other applications
    then this is accomplished using a Content Provider that is addressed as a URI.
    We have already covered Content Providers in detail in [Chapter 2](ch02.html "Chapter 2. Application
    Building Blocks"), *Application Building Blocks*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所提到的，SQLite数据库是一个私有数据库，与应用程序一起被沙盒化。如果需要将此数据与其他应用程序共享，则可以通过作为URI地址的内容提供者来实现。我们在[第2章](ch02.html
    "第2章. 应用程序构建块")，*应用程序构建块*中已经详细介绍了内容提供者。
- en: Account manager
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户管理器
- en: In the context of storing sensitive data, storing passwords or authentication
    tokens is an important aspect. Consider applications such as Google Mail, Twitter,
    and Facebook, which lets users log in. Other applications work with an authentication
    token as used by identity protocols such as OAuth2.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储敏感数据的背景下，存储密码或认证令牌是一个重要的方面。考虑像Google邮箱、Twitter和Facebook这样的应用程序，它们允许用户登录。其他应用程序使用像OAuth2这样的身份协议所使用的认证令牌。
- en: Android provides the `android.accounts.AccountManager` class as a centralized
    repository for storing user credentials. An application can choose to use its
    own pluggable authenticator to handle account authentication. From storing the
    username to identity information to creating your custom account manager, Android's
    `AccountManager` is a powerful utility.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了`android.accounts.AccountManager`类作为存储用户凭据的中心化存储库。应用程序可以选择使用自己的可插拔认证器来处理账户认证。从存储用户名到身份信息，再到创建你自己的自定义账户管理器，安卓的`AccountManager`是一个强大的工具。
- en: The `AccountManager` class functions are permissions protected so that your
    application will have to request for `android.permission.GET_ACCOUNTS` to access
    the list of accounts stored on it and `android.permission.ACCOUNT_MANAGER` for
    OAuth2.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountManager`类的功能受到权限保护，因此你的应用程序需要请求`android.permission.GET_ACCOUNTS`来访问存储在其上的账户列表，以及使用OAuth2的`android.permission.ACCOUNT_MANAGER`。'
- en: 'Each account is in a namespace format. For example, a Google account uses `com.google`
    and a Twitter account uses `com.twitter.android.auth.login`. The `AccountManager`
    is accessed as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个账户都采用命名空间格式。例如，Google账户使用`com.google`，Twitter账户使用`com.twitter.android.auth.login`。以下是如何访问`AccountManager`：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The entire list of accounts can be retrieved using the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码获取整个账户列表：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `auth` token is acquired in the form of a `Bundle` and is retrieved using
    the named value of `KEY_AUTHTOKEN`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth`令牌以`Bundle`的形式获取，使用名为`KEY_AUTHTOKEN`的值来检索。'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are two important points to remember when using `AccountManager`. First,
    if your app is trying to authenticate using OAuth2, your application will be talking
    to the server so this may cause delays and the calls should be made asynchronously.
    Second, the credentials are stored on `AccountManager` in plain text. So on a
    rooted phone, these will be visible to any user using the `adb shell` commands.
    So, as is the case with storing information on a device, instead of storing passwords
    and other PII in clear, it should be stored in a cryptographically secure manner
    by wither hashing it or encrypting it. This will minimize the risk from a compromised
    device.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AccountManager`时有两大要点需记住。首先，如果你的应用尝试使用 OAuth2 进行认证，你的应用将和服务器进行通信，这可能会导致延迟，因此这些调用应该是异步进行的。其次，凭据以明文形式存储在`AccountManager`中。所以在已获得根权限的手机上，任何使用`adb
    shell`命令的用户都能看到这些凭据。因此，在设备上存储信息时，应避免以明文形式存储密码和个人识别信息（PII），而应通过散列或加密以加密安全的方式存储，这将最小化设备被入侵的风险。
- en: SSL/TLS
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL/TLS
- en: I was reading a very interesting research conducted by the students of the Leibniz
    University of Hannover and the Philipps University of Marburg, Germany, about
    MITM (man-in-the-middle) attacks on data in transit. The applications studied
    were using SSL (Secure Socket Layer) or TLS (Transport Layer Security) protocols
    to protect data over the network. Many of the applications were not using SSL/TLS
    properly, which resulted in vulnerability. Another interesting observation is
    that since the Android browser does not show the green padlock usually associated
    with the sites using SSL/TLS, users were not aware of the fact that they were
    using an insecure website. Check out the paper at [http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf](http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf).
    I'm sure it will make an interesting read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我阅读了一项由德国汉诺威莱布尼茨大学和马尔堡菲利普大学的学生进行的研究，非常有趣，关于传输中数据的中间人（MITM）攻击。研究的应用程序使用了 SSL（安全套接层）或
    TLS（传输层安全）协议来保护网络上的数据。许多应用程序没有正确使用 SSL/TLS，导致存在漏洞。另一个有趣的观察是，由于 Android 浏览器通常不会显示通常与使用
    SSL/TLS 的网站相关的绿色挂锁，用户并不了解他们正在使用一个不安全的网站。查看这篇论文：[http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf](http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf)。我相信这将是一次有趣的阅读。
- en: The preceding research brought to light the importance of implementing protocols
    correctly in the applications. This section introduces SSL/TLS and some notes
    to implement it correctly. Developed by Netscape, SSL is a protocol for secure
    communication over the Internet. The protocol follows a series of calls between
    the client and server where they negotiate on a key and cipher suite for data
    exchange.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前述研究揭示了在应用程序中正确实现协议的重要性。本节介绍了 SSL/TLS 并提供了一些正确实现它的注意事项。SSL 是由 Netscape 开发的，用于在互联网上进行安全通信的协议。该协议遵循客户端和服务器之间的一系列调用，在这些调用中，它们协商用于数据交换的密钥和密码套件。
- en: 'Android provides the capability to integrate SSL/TLS using the `javax.net.ssl`,
    `org.apache.http.conn.ssl`, and `android.net` packages. The following figure illustrates
    the sequence in SSL:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了通过`javax.net.ssl`、`org.apache.http.conn.ssl`和`android.net`包集成 SSL/TLS
    的能力。以下图示展示了 SSL 的顺序：
- en: '![SSL/TLS](img/5603OT_07_02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![SSL/TLS](img/5603OT_07_02.jpg)'
- en: The first step is to set up a keystore and import the server certificate chain.
    Next is to link the keystore to `DefaultHttpClient` so it knows where to find
    the certificates for the server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置一个密钥库并导入服务器证书链。接下来是将密钥库链接到`DefaultHttpClient`，这样它就知道在哪里找到服务器的证书。
- en: During the development phase, especially in an enterprise environment, we set
    up our SSL to trust all certificates by creating a custom `TrustManager` and to
    allow all the hostnames using `SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER`.
    If such an application is released, it presents a serious security flaw. Please
    check for this before releasing your application. So remember to fix such issues
    before you release your application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段，尤其是在企业环境中，我们通过创建自定义`TrustManager`使 SSL 信任所有证书，并通过`SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER`允许所有主机名。如果这样的应用程序被发布，它将存在严重的安全缺陷。在发布你的应用程序之前，请检查这一点。因此，在发布应用程序之前，请记得修复这些问题。
- en: Installing an application on an external storage
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在外部存储上安装应用程序
- en: As we have discussed in [Chapter 4](ch04.html "Chapter 4. Defining the Application's
    Policy File"), *Defining the Application's Policy File*, starting with API level
    8, applications can choose to be installed on the SD card. Once the APK is moved
    to external storage, the only memory taken up by the app is private data of applications
    stored on the internal memory. It is important to note that even for SD card resident
    APKs, the DEX (Dalvik Executable) files, private data directories, and native
    shared libraries remain on the internal storage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第4章](ch04.html "第4章. 定义应用程序的策略文件") *定义应用程序的策略文件* 中所讨论的，从API级别8开始，应用程序可以选择安装在SD卡上。一旦APK移动到外部存储，应用程序所占用的唯一内存就是存储在内部内存中的应用程序私有数据。需要注意的是，即使是SD卡上的APK，DEX（Dalvik可执行）文件、私有数据目录和本地共享库仍然保留在内部存储上。
- en: Adding an optional attribute in the manifest file enables this feature. The
    **Application Info** screen for such an application either has a **Move to SD
    card** or **Move to Phone** button, depending on the current storage location
    of APK. The user then has an option to move the APK file accordingly. If the external
    device is un-mounted or the USB mode is set to **Mass Storage** (where the device
    is used as a disk drive), all the running Activities and Services hosted on that
    external device are immediately killed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中添加一个可选属性可以启用此功能。对于此类应用程序的 **应用程序信息** 屏幕上，要么有 **移动到SD卡** 按钮，要么有 **移动到手机**
    按钮，具体取决于APK的当前存储位置。然后用户可以选择相应地移动APK文件。如果外部设备被卸载或USB模式设置为 **大容量存储**（设备被用作磁盘驱动器），则托管在该外部设备上的所有运行中的活动和服务的进程会被立即结束。
- en: 'The following screenshot shows the option **Move to SD Card** in the setting
    of the application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了应用程序设置中的 **移动到SD卡** 选项：
- en: '![Installing an application on an external storage](img/5603OT_07_03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![在外部存储上安装应用程序](img/5603OT_07_03.jpg)'
- en: The `ApplicationInfo` object for each application now has a new flag called
    `FLAG_EXTERNAL_STORAGE`. The value of this flag is set to `true` for applications
    stored on the external devices. If such an application is uninstalled, the internal
    storage for that application is removed as well. If the external device becomes
    unavailable (for example, when the SD card is unmounted), the internal memory
    is not cleared. In this case, the user can clear this internal memory by uninstalling
    the application. The SD card does not need to be mounted for this action.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个应用程序的 `ApplicationInfo` 对象都有一个名为 `FLAG_EXTERNAL_STORAGE` 的新标志。对于存储在外部设备上的应用程序，此标志的值为
    `true`。如果这样的应用程序被卸载，该应用程序的内部存储也会被移除。如果外部设备不可用（例如，当SD卡被卸载时），内部存储不会被清除。在这种情况下，用户可以通过卸载应用程序来清除内部存储。执行此操作不需要挂载SD卡。
- en: Two new broadcasts have been added as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也添加了两个新的广播。
- en: '`ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE`: This intent is sent out when the
    SD card is unmounted. It contains a list of disabled applications (using the `EXTRA_CHANGED_PACKAGE_LIST`
    attribute) and a list of unavailable application UIDs (using the `EXTRA_CHANGED_UID_LIST`
    attribute).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE`：当SD卡被卸载时，会发送此意图。它包含一个禁用应用程序的列表（使用
    `EXTRA_CHANGED_PACKAGE_LIST` 属性）和一个不可用应用程序UID的列表（使用 `EXTRA_CHANGED_UID_LIST` 属性）。'
- en: '`ACTION_EXTERNAL_APPLICATIONS_AVAILABLE`: This intent is sent out when the
    SD card becomes available again. It contains a list of disabled applications (using
    the `EXTRA_CHANGED_PACKAGE_LIST` attribute) and a list of unavailable application
    UIDs (using the `EXTRA_CHANGED_UID_LIST` attribute).'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTION_EXTERNAL_APPLICATIONS_AVAILABLE`：当SD卡再次可用时，会发送此意图。它包含一个禁用应用程序的列表（使用
    `EXTRA_CHANGED_PACKAGE_LIST` 属性）和一个不可用应用程序UID的列表（使用 `EXTRA_CHANGED_UID_LIST` 属性）。'
- en: When an application is moved from internal memory to an external location, `ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE`
    is fired. The assets and resources are then copied over to the new location. The
    application is then enabled and the `ACTION_EXTERNAL_APPLICATIONS_AVAILABLE` broadcast
    intent is fired again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序从内部存储移动到外部位置时，会触发 `ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE`。然后，资源和资产会被复制到新位置。应用程序启用后，会再次触发
    `ACTION_EXTERNAL_APPLICATIONS_AVAILABLE` 广播意图。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Any kind of an external device is inherently insecure. For example, SD cards
    are susceptible to memory corruption due to power failure (dead battery in case
    of a phone) or improper removal of card (without properly unmounting). The SD
    card is also globally readable so applications can be read, written, copied, or
    deleted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的外部设备本质上都是不安全的。例如，由于电源故障（在手机中就是电池耗尽）或不正确的移除方式（没有正确卸载），SD卡可能会遭受内存损坏。SD卡在全球范围内可读，因此应用程序可以被读取、写入、复制或删除。
- en: To securely store APKs on the external devices, Android applications are stored
    in an encrypted container (the ASEC file) so that other applications or programs
    cannot modify or corrupt them. The ASEC file is an encrypted filesystem whose
    key is randomly generated and stored by the device so that it can be decrypted
    only by the device that originally installed it. Thus, an application installed
    on an SD card works for only one device.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在外部设备上安全存储APK，安卓应用程序被存储在一个加密容器（ASEC文件）中，以防止其他应用程序或程序修改或损坏它们。ASEC文件是一个加密的文件系统，其密钥是随机生成的并由设备存储，因此只能由最初安装它的设备进行解密。因此，安装在SD卡上的应用程序只适用于一个设备。
- en: When mounting the SD card (using the Linux loopback mechanism), these containers
    are mounted in the same way as apps on the internal memory. The filesystem enforces
    permissions so that other applications cannot modify its contents and nobody but
    the system itself can modify anything through the ASEC file because other applications
    do not have the key for it. Also the SD card is mounted as `noexec` so nobody
    can put executable code there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载SD卡（使用Linux回环机制）时，这些容器与内部存储上的应用程序以相同的方式挂载。文件系统强制执行权限，使得其他应用程序不能修改其内容，除了系统本身，没有其他人可以通过ASEC文件修改任何内容，因为其他应用程序没有相应的密钥。此外，SD卡以`noexec`方式挂载，因此没有人可以在那里放置可执行代码。
- en: Multiple SD cards can be associated with one device so that SD cards can be
    easily swapped. As long as the SD card is mounted, there is no performance issue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设备可以关联多个SD卡，以便轻松更换SD卡。只要SD卡被挂载，就没有性能问题。
- en: 'The Android developer website ([developer.android.com](http://developer.android.com))
    gives a list of use cases when installing an application on an SD card can make
    the application perform erratically, if the SD card is unmounted. Some of them,
    such as Services, are based on the sequence in which a Service will become available
    when a phone is booted up. These are listed as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发者网站（[developer.android.com](http://developer.android.com)）列出了在SD卡上安装应用程序可能导致应用程序表现不稳定的使用场景，尤其是当SD卡被卸载时。其中一些，如服务，是基于服务在手机启动时可用顺序的。以下是列出的部分情况：
- en: '**Services**: Running Services will be killed. The application can register
    for the `ACTION_EXTERNAL_APPLICATIONS_AVAILABLE` broadcast Intent, which will
    notify your application when applications installed on external storage have become
    available to the system. The Service can be restarted once the Intent is received.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：运行中的服务将被杀死。应用程序可以注册`ACTION_EXTERNAL_APPLICATIONS_AVAILABLE`广播意图，当安装在扩展存储上的应用程序对系统可用时，该意图会通知你的应用程序。一旦收到该意图，服务就可以重新启动。'
- en: '**Alarm services**: Alarms registered with `AlarmManager` will be canceled
    and must be manually re-registered when an external storage is remounted.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闹钟服务**：使用`AlarmManager`注册的闹钟将被取消，并在外部存储重新挂载时手动重新注册。'
- en: '**Input Method Engines (IME)**: An IME is a control that lets users input text.
    If your IME resides on an external storage, it will be replaced by the default
    IME. When an external storage is remounted, the user will have to open the system
    settings to enable the custom IME again.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入法引擎（IME）**：IME是一个控件，允许用户输入文本。如果你的IME位于外部存储上，它将被默认的IME替换。当外部存储重新挂载时，用户将需要打开系统设置以重新启用自定义IME。'
- en: '**Live wallpapers**: The default live wallpaper will replace running live wallpaper
    if the one that is set is stored on an external storage. When an external storage
    is remounted, the user will have to select their custom live wallpaper again.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态壁纸**：如果设置的动态壁纸存储在外部存储上，那么默认的动态壁纸将替换正在运行的动态壁纸。当外部存储重新挂载时，用户将需要重新选择他们自定义的动态壁纸。'
- en: '**App Widgets**: If your App Widget lives on the external storage, it will
    be removed from the home screen. In most cases, a system reset is required for
    the App Widget to appear again on the home screen.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用小部件**：如果你的应用小部件存储在外部存储上，它将被从主屏幕移除。在大多数情况下，需要系统重置才能让应用小部件再次出现在主屏幕上。'
- en: '**Account managers**: If any accounts were created with `AccountManager`, they
    will disappear until the external storage is remounted.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**账户管理器**：如果使用`AccountManager`创建了任何账户，它们将在外部存储重新挂载之前消失。'
- en: '**Sync adapters**: `AbstractThreadedSyncAdapter` and all its sync functionality
    will not work. The external storage has to be remounted for sync to work again.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步适配器**：`AbstractThreadedSyncAdapter`及其所有同步功能将无法工作。需要重新挂载外部存储才能使同步功能再次工作。'
- en: '**Device administrators**: This piece is critical as `DeviceAdminReceiver`
    and all its admin capabilities will be disabled, and this may not be fully functional
    even when the SD card is remounted.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备管理员**：这一部分非常重要，因为`DeviceAdminReceiver`及其所有管理功能将被禁用，即使重新挂载SD卡，这些功能可能也无法完全正常工作。'
- en: '**Broadcast Receivers**: Any Broadcast Receiver that is listening for the `ACTION_BOOT_COMPLETE`
    broadcast will cease to work as the system delivers this broadcast before the
    external storage is mounted to the device. So any application installed on the
    external storage can never receive this broadcast.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播接收器**：任何监听`ACTION_BOOT_COMPLETE`广播的广播接收器将停止工作，因为系统在外部存储挂载到设备之前发送此广播。因此，在外部存储上安装的任何应用程序都无法接收此广播。'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered the storage mechanisms available on Android. We started
    off with an understanding of terms such as privacy and data retention. We should
    always think about these issues before we collect personal identifiable information
    to avoid legal and moral issues. It is important to note that rules and regulations
    pertaining to privacy and data security are different based on country and use
    case. We looked at storing user preferences using shared preferences, storing,
    reading, and writing data on files, caches, and databases. We also covered some
    important considerations when using SSL/TLS and application installation on the
    external memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Android上可用的存储机制。我们从理解隐私和数据保留等术语开始。在收集可识别个人信息之前，我们应当始终考虑这些问题，以避免法律和道德问题。需要注意的是，关于隐私和数据安全的规则和法规根据国家和使用情况的不同而有所不同。我们探讨了使用共享偏好存储用户偏好，以及在文件、缓存和数据库上存储、读取和写入数据的方法。我们还讨论了在使用SSL/TLS以及在外部存储上安装应用程序时需要考虑的一些重要事项。
- en: The next three chapters will cover very interesting topics such as device administration,
    security focused testing, and new and emerging use cases on Android. Keep reading!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三章将介绍非常有趣的话题，包括设备管理、以安全为重点的测试以及Android上的新出现的使用案例。请继续阅读！
