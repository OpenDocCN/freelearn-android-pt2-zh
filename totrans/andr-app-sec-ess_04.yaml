- en: Chapter 4. Defining the Application's Policy File
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 定义应用程序的策略文件
- en: This chapter brings together all the learning we have done so far. We will use
    the application components, Intents, and permissions and put them all together
    to define our application's policy file. This policy file is called `AndroidManifest.xml`
    and is by far the most important file of an application. As you will see, this
    file is the place to define access control policy for your application and components.
    This is also the place to define application and component level specifics that
    the Android system will use to interact with your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将把我们迄今为止所学的所有内容汇集在一起。我们将使用应用程序组件、意图和权限，并将它们全部放在一起来定义我们应用程序的策略文件。这个策略文件被称为`AndroidManifest.xml`，无疑是应用程序最重要的文件。正如您将看到的，这个文件是定义应用程序及其组件访问控制策略的地方。这也是定义应用程序和组件级别特定信息的地方，安卓系统将使用这些信息与您的应用程序交互。
- en: 'The chapter begins with a discussion of `AndroidManfiest.xml`. We will discuss
    the two important tags: `<manifest>` and `<application>` that we have not discussed
    so far. Next, we will discuss the actions that we can perform in the manifest
    file such as declaring permission, sharing a process with other applications,
    external storage, and managing component visibility. The chapter closes with a
    discussion of a checklist for your policy file before you release your application.
    You should adapt the checklist according to your use case. Once you have a comprehensive
    checklist, you can refer to it every time you are ready to make a new release.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从讨论`AndroidManfiest.xml`开始。我们将讨论到目前为止尚未讨论的两个重要标签：`<manifest>`和`<application>`。接下来，我们将讨论在清单文件中可以执行的操作，例如声明权限、与其他应用程序共享进程、外部存储以及管理组件可见性。在您发布应用程序之前，本章将以策略文件的核对清单作为结束讨论。您应该根据您的使用情况调整核对清单。一旦有了全面的核对清单，您就可以在每次准备发布新版本时参考它。
- en: The AndroidManifest.xml file
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件'
- en: All Android applications need to have a manifest file. This file has to be named
    as `AndroidManifest.xml` and has to be placed in the application's root directory.
    This manifest file is the application's policy file. It declares the application
    components, their visibility, access rules, libraries, features, and the minimum
    Android version that the application runs against.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安卓应用程序都需要有一个清单文件。这个文件必须命名为`AndroidManifest.xml`，并且必须放在应用程序的根目录中。这个清单文件是应用程序的策略文件。它声明了应用程序组件、它们的可见性、访问规则、库、特性以及应用程序运行的最低安卓版本。
- en: The Android system uses the manifest file for component resolution. Thus, the
    `AndroidManfiest.xml` file is by far the most important file in the entire application,
    and special care is required when defining it to tighten up the application's
    security.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统使用清单文件进行组件解析。因此，`AndroidManfiest.xml`文件是整个应用程序中最重要文件，定义时需要特别小心，以加强应用程序的安全性。
- en: 'The manifest file is not extensible, so applications cannot add their own attributes
    or tags. The complete list of tags with how these tags can be nested is as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件是不可扩展的，因此应用程序不能添加自己的属性或标签。以下是如何嵌套这些标签的完整标签列表：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have covered most of the tags in previous chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中已经涵盖了大部分标签。
- en: Only two tags, `<manifest>` and `<application>`, are the required tags. There
    is no specific order to declare components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个标签`<manifest>`和`<application>`是必需的标签。声明组件没有特定的顺序。
- en: 'The `<manifest>` tag declares the application specific attributes. It is declared
    as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`<manifest>`标签声明了应用程序特定的属性。它的声明方式如下：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An example of the `<manifest>` tag is shown in the following code snippet. In
    this example, the package is named `com.android.example`, the internal version
    is 10, and the user sees this version as 2.7.0\. The install location is decided
    by the Android system based on where it has room to store the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了`<manifest>`标签的一个示例。在这个例子中，包名为`com.android.example`，内部版本为10，用户看到的版本为2.7.0。安装位置由安卓系统根据存储应用程序的空间决定。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The attributes of the `<manifest>` tag are as follows:.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`<manifest>`标签的属性如下：'
- en: '`package`: This is the name of the package. This is the Java style namespace
    of your application, for example, `com.android.example`. This is the unique ID
    of your application. If you change the name of a published application, it is
    considered a new application and auto updates will not work.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：这是包的名称。这是应用Java风格的命名空间，例如 `com.android.example`。这是您应用的唯一ID。如果您更改已发布应用的名称，它将被视为一个新应用，自动更新将不起作用。'
- en: '`android:sharedUserId`: This attribute is used if two or more applications
    share the same Linux ID. This attribute is discussed in detail in a later section.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:sharedUserId`：如果两个或更多应用共享同一个Linux ID，则使用此属性。此属性将在后面的章节中详细讨论。'
- en: '`android:sharedUserLabel`: This is the user readable name of the shared user
    ID and only makes sense if `android:sharedUserId` is set. It has to be a string
    resource.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:sharedUserLabel`：这是共享用户ID的用户可读名称，仅当设置了 `android:sharedUserId` 时才有意义。它必须是一个字符串资源。'
- en: '`android:versionCode`: This is the version code used internally by the application
    to track revisions. This code is referred to when updating an application with
    the more recent version.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:versionCode`：这是应用内部用来跟踪修订版本的应用版本代码。更新应用至较新版本时会参考此代码。'
- en: '`android:versionName`: This is the version of the application shown to the
    user. It can be set as a raw string or as a reference, and is only used for display
    to users.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:versionName`：这是向用户展示的应用版本。它可以设置为原始字符串或引用，并且仅用于向用户展示。'
- en: '`android:installLocation`: This attribute defines the location where an APK
    will be installed. This attribute is discussed in detail later in the chapter.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:installLocation`：此属性定义了APK将要安装的位置。此属性将在本章后面详细讨论。'
- en: 'The application tag is defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用标签定义如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An example of the `<application>` tag is shown in the following code snippet.
    In this example, the application name, description, icon, and label are set. The
    application is not debuggable and the Android system can instantiate the components.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`<application>` 标签的一个示例在以下代码片段中展示。在此示例中，设置了应用名称、描述、图标和标签。应用不可调试，Android系统可以实例化组件。'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Many attributes of the `<application>` tag serve as the default values for
    the components declared within the application. These tags include `permission`,
    `process`, `icon`, and `label`. Other attributes such as `debuggable` and `enabled`
    are set for the entire application. The attributes of the `<application>` tag
    are discussed as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`<application>` 标签的许多属性作为应用内部声明的组件的默认值。这些标签包括 `permission`、`process`、`icon`
    和 `label`。其他如 `debuggable` 和 `enabled` 的属性是为整个应用设置的。以下将讨论 `<application>` 标签的属性：'
- en: '`android:allowTaskReparenting`: This value can be overridden by the `<activity>`
    element. It allows an Activity to re-parent with the Activity it has affinity
    with, when it is brought to the foreground.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:allowTaskReparenting`：此值可以被 `<activity>` 元素覆盖。它允许当Activity被带到前台时，Activity与其有亲缘关系的Activity重新分组。'
- en: '`android:backupAgent`: This attribute contains the name of the backup agent
    for the application.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:backupAgent`：此属性包含应用的备份代理的名称。'
- en: '`android:debuggable`: This attribute when set to `true` allows an application
    to be debugged. This value should always be set to `false` before releasing the
    app in the market.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:debuggable`：当此属性设置为 `true` 时，应用可以被调试。在将应用发布到市场之前，此值应始终设置为 `false`。'
- en: '`android:description`: This is the user readable description of an application
    set as a reference to a string resource.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:description`：这是作为对字符串资源的引用的应用的用户可读描述。'
- en: '`android:enabled`: This attribute if set to `true`, the Android system can
    instantiate application components. This attribute can be overridden by components.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:enabled`：如果此属性设置为 `true`，Android系统可以实例化应用组件。此属性可以被组件覆盖。'
- en: '`android:hasCode`: This attribute if set to `true`, the application will try
    to load some code when launching thecomponents.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:hasCode`：如果此属性设置为 `true`，应用在启动组件时会尝试加载一些代码。'
- en: '`android:hardwareAccelerated`: This attribute when set to `true` allows an
    application to support hardware accelerated rendering. It was introduced in the
    API level 11.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:hardwareAccelerated`：当此属性设置为 `true` 时，应用可以支持硬件加速渲染。它是在API级别11中引入的。'
- en: '`android:icon`: This is the application icon as a reference to a drawable resource.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:icon`：这是作为对可绘制资源的引用的应用图标。'
- en: '`android:killAfterRestore`: This attribute if set to `true`, the application
    will be terminated once its settings are restored during a full-system restore.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:killAfterRestore`：如果此属性设置为 `true`，则在完整系统恢复期间恢复应用程序设置后，应用程序将被终止。'
- en: '`android:largeHeap`: This attribute lets the Android system create a large
    Dalvik heap for this application and increases the memory footprint of the application,
    so this should be used sparingly.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:largeHeap`：此属性允许安卓系统为该应用程序创建一个大的Dalvik堆，并增加应用程序的内存占用，因此应谨慎使用。'
- en: '`android:label`: This is the user readable label for the application.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:label`：这是应用程序的用户可读标签。'
- en: '`android:logo`: This is the logo for the application.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:logo`：这是应用程序的标志。'
- en: '`android:manageSpaceActivity`: This value is the name of the Activity that
    manages the memory for the application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:manageSpaceActivity`：此值是管理应用程序内存的活动名称。'
- en: '`android:name`: This attribute contains the fully qualified name of the subclass
    that will be instantiated before any other component is started.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:name`：此属性包含将在任何其他组件启动之前实例化的子类的完全限定名称。'
- en: '`android:permission`: This attribute can be overridden by a component and sets
    the permission that a client should have to interact with the application.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:permission`：此属性可以被组件覆盖，并设置客户端应具有与应用程序交互的权限。'
- en: '`android:persistent`: Usually used by a system application, this attribute
    allows the application to be running all the time.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:persistent`：通常由系统应用程序使用，此属性允许应用程序始终运行。'
- en: '`android:process`: This is the name of the process in which a component will
    run. This can be overridden by any component''s `android:process` attribute.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:process`：这是组件将要运行的进程的名称。这可以被任何组件的 `android:process` 属性覆盖。'
- en: '`android:restoreAnyVersion`: This attribute lets the backup agent attempt a
    restore even if the backup currently stored is by a newer application than what
    is attempting to restore now.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:restoreAnyVersion`：此属性允许备份代理在即使当前存储的备份是由比尝试恢复的应用程序更新的新应用程序创建的情况下，尝试恢复。'
- en: '`android:supportsRtl`: This attribute when set to `true` supports right-to-left
    layouts. It was added in the API level 17.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:supportsRtl`：当此属性设置为 `true` 时，支持从右到左的布局。它是在API级别17中添加的。'
- en: '`android:taskAffinity`: This attribute lets all activities have affinity with
    the package name, unless it is set by the Activity explicitly.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:taskAffinity`：此属性让所有活动都与包名称有关联，除非活动明确设置。'
- en: '`android:theme`: This is a reference to the style resource for the application.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:theme`：这是对应用程序样式资源的引用。'
- en: '`android:uiOptions`: This attribute if set to `none`, there are no extra UI
    options; if set to `splitActionBarWhenNarrow`, a bar is set at the bottom if constrained
    for the screen.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:uiOptions`：如果此属性设置为 `none`，则没有额外的UI选项；如果设置为 `splitActionBarWhenNarrow`，则在屏幕受限时会在底部设置一个栏。'
- en: In the following sections we will discuss how to handle specific requirements
    using the policy file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们将讨论如何使用策略文件处理特定要求。
- en: Application policy use cases
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序策略使用场景
- en: This section discusses how to define the application policies using the manifest
    file. I have used use cases and we will discuss how to implement these use cases
    in the policy file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论如何使用清单文件定义应用程序策略。我使用了使用场景，并且我们将讨论如何在策略文件中实现这些使用场景。
- en: Declaring application permissions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明应用程序权限
- en: An application on the Android platform has to declare what resources it intends
    to use for proper functioning of the application. These are the permissions that
    are displayed to the user when they download the application. As discussed in
    [Chapter 3](ch03.html "Chapter 3. Permissions"), *Permissions*, an application
    can define custom permissions as well. Application permissions should be descriptive
    so that users can understand them. Also, as is the general rule with security,
    it is important to request the minimum permissions required.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓平台上的应用程序必须声明它打算使用哪些资源，以便应用程序能够正常运行。这些权限是用户在下载应用程序时显示的权限。正如在[第3章](ch03.html
    "第3章. 权限") *权限* 中所讨论的，应用程序也可以定义自定义权限。应用程序权限应该是描述性的，以便用户能够理解它们。此外，与安全相关的普遍规则是，请求所需的最低权限是很重要的。
- en: 'Application permissions are declared in the manifest file by using the tag
    `<uses-permission>`. An example of a location-based manifest file that uses the
    GPS for retrieving location is shown in the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序权限在清单文件中通过使用 `<uses-permission>` 标签声明。以下代码段展示了一个使用GPS获取位置信息的基于位置的清单文件的示例：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These permissions will be displayed to the users when they install the app,
    and can always be checked by going to **Application** under the settings menu.
    These permissions are seen in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限将在用户安装应用程序时显示给他们，并且可以通过进入设置菜单下的**应用程序**进行检查。以下屏幕截图显示了这些权限：
- en: '![Declaring application permissions](img/5603_04_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![声明应用程序权限](img/5603_04_01.jpg)'
- en: Declaring permissions for external applications
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明外部应用程序的权限
- en: 'The manifest file also declares the permissions an external application (which
    does not run with the same Linux ID) needs to access the application components.
    This can be one of two places in the policy file: in the `<application>` tag or
    along with the component in the `<activity>`, `<provider>`, `<receiver>`, and
    `<service>` tag.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件还声明了一个外部应用程序（不与相同的Linux ID运行）需要访问应用程序组件的权限。这可以是策略文件中的两个位置之一：在`<application>`标签中或者在`<activity>`、`<provider>`、`<receiver>`和`<service>`标签中的组件旁边。
- en: If there are permissions that all components of an application require, then
    it is easy to specify them in the `<application>` tag. If a component requires
    some specific permission, then those can be defined in the specific component
    tag. Remember, only one permission can be declared in any of the tags. If a component
    is protected by permission then the component permission overrides the permission
    declared in the `<application>` tag.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的所有组件都需要某些权限，那么在`<application>`标签中指定它们很容易。如果一个组件需要某些特定的权限，那么可以在特定的组件标签中定义。请记住，任何标签中只能声明一个权限。如果一个组件受到权限保护，那么组件权限将覆盖在`<application>`标签中声明的权限。
- en: 'The following is an example of an application that requires external applications
    to have `android.permission.ACCESS_COARSE_LOCATION` to access its components and
    resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个应用程序示例，它要求外部应用程序具有`android.permission.ACCESS_COARSE_LOCATION`权限才能访问其组件和资源：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a Service requires that any application component that accesses it should
    have access to the external storage, then it can be defined as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个服务要求访问它的任何应用程序组件都需要访问外部存储，那么可以按如下方式定义：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If a policy file has both the preceding tags then when an external component
    makes a request to this Service, it should have `android.permission.WRITE_EXTERNAL_STORAGE`,
    as this permission will override the permission declared by the application tag.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果策略文件同时具有前面的标签，那么当外部组件请求此服务时，它应该具有`android.permission.WRITE_EXTERNAL_STORAGE`权限，因为此权限将覆盖应用程序标签中声明的权限。
- en: Applications running with the same Linux ID
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有相同Linux ID的应用程序运行
- en: Sharing data between applications is always tricky. It is not easy to maintain
    data confidentiality and integrity. Proper access control mechanisms have to be
    put in place based on who has access to how much data. In this section, we will
    discuss how to share application data with the internal applications (signed by
    the same developer key).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序之间共享数据总是很棘手。维护数据保密性和完整性并不容易。必须根据谁可以访问多少数据来建立适当的访问控制机制。在本节中，我们将讨论如何与内部应用程序（由同一开发密钥签名）共享应用程序数据。
- en: 'Android is a layered architecture with an application isolation enforced by
    the operating system itself. Whenever an application is installed on the Android
    device, the Android system gives it a unique user ID defined by the system. Notice
    that the two applications, **example1** and **example2**, in the following screenshot
    are the applications run as separate user IDs, **app_49** and **app_50**:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓是一个分层架构，其应用程序隔离由操作系统本身强制执行。每当在安卓设备上安装一个应用程序时，安卓系统都会给它分配一个由系统定义的唯一用户ID。请注意，以下屏幕截图中，两个应用程序**example1**和**example2**是作为不同的用户ID运行的，分别是**app_49**和**app_50**：
- en: '![Applications running with the same Linux ID](img/5603_04_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![具有相同Linux ID的应用程序运行](img/5603_04_02.jpg)'
- en: However, an application can request the system for a user ID of its choice.
    The other application can then request the same user ID as well. This creates
    tight coupling and does not require components to be made visible to the other
    application or to create shared content providers. This kind of tight coupling
    is done in the manifest tags of all applications that want to run in the same
    process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个应用程序可以请求系统分配一个它选择的用户ID。另一个应用程序也可以请求相同的用户ID。这会创建紧密耦合，不需要将组件对另一个应用程序可见或创建共享的内容提供者。这种紧密耦合是在所有希望在同一进程中运行的应用程序清单标签中完成的。
- en: 'The following is a snippet of manifest files of the two applications `com.example.example1`
    and `com.example.example2` that use the same user ID:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个应用`com.example.example1`和`com.example.example2`的清单文件片段，它们使用相同的用户ID：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following screenshot is displayed when these two applications are running
    on the device. Notice that the applications, `com.example.example1` and `com.example.example2`,
    now have the app ID of **app_113**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了当这两个应用在设备上运行时的显示效果。注意，应用`com.example.example1`和`com.example.example2`现在有了**app_113**的应用ID。
- en: '![Applications running with the same Linux ID](img/5603_04_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![具有相同Linux ID的应用程序运行](img/5603_04_03.jpg)'
- en: 'You will notice that the shared UID follows a certain format akin to a package
    name. Any other naming convention will result in an error such as an installation
    error: `INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到共享UID遵循一定的格式，类似于包名。任何其他命名约定都可能导致错误，例如安装错误：`INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID`。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All applications that share the same UID should have the same certificate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有共享相同UID的应用应该具有相同的证书。
- en: External storage
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部存储
- en: Starting with API Level 8, Android provides support to store Android applications
    (APK files) on external devices, such as an SD card. This helps to free up internal
    phone memory. Once the APK is moved to external storage, the only memory taken
    up by the app is the private data of the application stored on internal memory.
    It is important to note that even for the SD card resident APKs, the **DEX** (**Dalvik
    Executable**) files, private data directories, and native shared libraries remain
    on the internal storage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别8开始，安卓提供了支持将安卓应用（APK文件）存储在外部设备上的功能，例如SD卡。这有助于释放手机内部内存。一旦APK移动到外部存储，应用所占的唯一内存就是存储在内部内存上的应用私有数据。需要注意的是，即使是SD卡上的APK，**DEX**（**Dalvik
    可执行文件**）、私有数据目录和本地共享库仍然存储在内部存储上。
- en: Adding an optional attribute in the manifest file enables this feature. The
    application info screen for such an application either has a move to the SD card
    or move to a phone button depending on the current storage location of APK. The
    user then has an option to move the APK file accordingly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中添加一个可选属性可以启用这个功能。对于这样的应用，应用信息屏幕会有一个移动到SD卡或移动到手机的按钮，具体取决于APK当前的存储位置。然后用户可以选择相应地移动APK文件。
- en: If the external device is un-mounted or the USB mode is set to `Mass Storage`
    (where the device is used as a disk drive), all the running activities and services
    hosted on that external device are immediately killed. A detail of the external
    storage and its security analysis is done in [Chapter 7](ch07.html "Chapter 7. Securing
    Application Data"), *Securing Application Data*. In this section, we will discuss
    how to specify the external storage preference in the policy file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部设备被卸载或USB模式设置为`Mass Storage`（设备被用作磁盘驱动器），所有在外部设备上运行的活动和服务都会立即被终止。[第7章](ch07.html
    "第7章. 保护应用数据") *保护应用数据*中对外部存储及其安全性进行了详细分析。在本节中，我们将讨论如何在策略文件中指定外部存储的首选设置。
- en: 'The feature to enable storing APK on the external devices is enabled by adding
    the optional attribute `android:installLocation` in the application''s manifest
    file in the `<manifest>` element. The attribute `android:installLocation` can
    have the following three values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在应用的清单文件的`<manifest>`元素中添加可选属性`android:installLocation`，可以启用在外部设备上存储APK的功能。属性`android:installLocation`可以有以下三个值：
- en: '`InternalOnly`: The Android system will install the application on the internal
    storage only. In case of insufficient internal memory, storage errors are returned.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InternalOnly`：安卓系统只会在内部存储上安装应用。如果内部存储空间不足，将返回存储错误。'
- en: '`PreferExternal`: The Android system will try to install the application on
    the external storage. In case there is not enough external storage, the application
    will be installed on the internal storage. The user will have the ability to move
    the app from external to internal storage and vice versa as desired.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreferExternal`：安卓系统将尝试在外部存储上安装应用。如果外部存储空间不足，应用将被安装在内部存储上。用户可以根据需要将应用从外部存储移动到内部存储，反之亦然。'
- en: '`auto`: This option lets the Android system decide the best install location
    for the application. The default system policy is to install the application on
    internal storage first. If the system is running low on internal memory, the application
    is then installed on the external storage. The user will have the ability to move
    the application from external to internal storage and vice versa as desired.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`：此选项允许Android系统决定应用程序的最佳安装位置。默认的系统策略是首先在内部存储上安装应用程序。如果系统内部内存不足，则将应用程序安装在外部存储上。用户可以根据需要将应用程序从外部存储移动到内部存储，反之亦然。'
- en: 'For example, if `android:installLocation` is set to `Auto`, then on devices
    running a version of Android less than 2.2, the system will ignore this feature
    and APK will only be installed on the internal memory. The following is the code
    snippet from an application''s manifest file with this option:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果将`android:installLocation`设置为`Auto`，那么在运行Android 2.2以下版本的设备上，系统将忽略此功能，APK只能安装在内部存储上。以下是具有此选项的应用程序清单文件中的代码片段：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is a screenshot of the application with the manifest file as
    specified previously. You will notice that **Move to SD card** is enabled in this
    case:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前指定的应用程序的屏幕截图。你会注意到在这种情况下启用了**移动到SD卡**功能：
- en: '![External storage](img/5603_04_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![外部存储](img/5603_04_04.jpg)'
- en: 'In another application, where `android:installLocation` is not set, the **Move
    to SD card** is disabled as shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个未设置`android:installLocation`的应用程序中，**移动到SD卡**功能被禁用，如下面的屏幕截图所示：
- en: '![External storage](img/5603_04_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![外部存储](img/5603_04_05.jpg)'
- en: Setting component visibility
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置组件可见性
- en: Any of the application components namely, activities, services, providers, and
    receivers can be made discoverable to the external applications. This section
    discusses the nuances of such scenarios.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的任何组件，即活动、服务、提供者和接收器都可以被外部应用程序发现。本节讨论了这些场景的细节。
- en: 'Any Activity or Service can be made private by setting `android:exported=false`.
    This is also the default value for an Activity. See the following two examples
    of a private Activity:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任何活动或服务都可以通过设置`android:exported=false`变为私有的。这也是活动的默认值。以下是一个私有活动的两个示例：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, if you add an Intent Filter to the Activity, then the Activity becomes
    discoverable for the Intent in the Intent Filter. Thus, the Intent Filter should
    never be relied upon as a security boundary. See the following examples for Intent
    Filter declaration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你给活动添加了一个意图过滤器（Intent Filter），那么该活动就会对意图过滤器中的意图变得可发现。因此，意图过滤器绝不能作为安全边界依赖。以下是意图过滤器声明的示例：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both activities and services can also be secured by an access permission required
    by the external component. This is done using the `android:permission` attribute
    of the component tag.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和服务也可以通过外部组件所需的访问权限进行保护。这是通过使用组件标签的`android:permission`属性来实现的。
- en: A Content Provider can be set up for private access by using `android:exported=false`.
    This is also the default value for a provider. In this case, only an application
    with the same ID can access the provider. This access can be limited even further
    by setting the `android:permission` attribute of the provider tag.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者可以通过使用`android:exported=false`设置为私有访问。这也是提供者的默认值。在这种情况下，只有具有相同ID的应用程序才能访问提供者。通过设置提供者标签的`android:permission`属性，甚至可以进一步限制此访问。
- en: A Broadcast Receiver can be made private by using `android:exported=false`.
    This is the default value of the receiver if it does not contain any Intent Filters.
    In this case, only the components with the same ID can send a broadcast to the
    receiver. If the receiver contains Intent Filters then it becomes discoverable
    and the default value of `android:exported` is `false`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 广播接收器可以通过使用`android:exported=false`设置为私有。如果接收器不包含任何意图过滤器，这是接收器的默认值。在这种情况下，只有具有相同ID的组件才能向接收器发送广播。如果接收器包含意图过滤器，则它变得可发现，且`android:exported`的默认值为`false`。
- en: Debugging
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: During the development of an application, we usually set the application to
    be in the debug mode. This lets developers see the verbose logs and can get inside
    the application to check for errors. This is done in the `<application>` tag by
    setting `android:debuggable` to `true`. To avoid security leaks, it is very important
    to set this attribute to `false` before releasing the application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发过程中，我们通常将应用程序设置为调试模式。这允许开发者看到详细的日志，并可以进入应用程序检查错误。这通过在`<application>`标签中设置`android:debuggable`为`true`来实现。为了避免安全漏洞，在发布应用程序之前，将此属性设置为`false`非常重要。
- en: An example of sensitive information that I have seen in my experience includes
    usernames and passwords, memory dumps, internal server errors, and even some funny
    personal notes state of a server and a developer's opinion about a piece of code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，敏感信息的示例包括用户名和密码、内存转储、内部服务器错误，甚至一些有趣的个人笔记，包括服务器状态和开发者对一段代码的看法。
- en: The default value of `android:debuggable` is `false`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:debuggable`的默认值是`false`。'
- en: Backup
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份
- en: Starting with API level 8, an application can choose a backup agent to back
    up the device to the cloud or server. This can be set up in the manifest file
    in the `<application>` tag by setting `android:allowBackup` to `true` and then
    setting `android:backupAgent` to a class name. The default value of `android:allowBackup`
    is set to `true` and the application can set it to `false` if it wants to opt
    out of the backup. There is no default value for `android:backupAgent` and a class
    name should be specified.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别8开始，应用程序可以选择一个备份代理将设备备份到云端或服务器。这可以在清单文件的`<application>`标签中设置`android:allowBackup`为`true`，然后设置`android:backupAgent`为一个类名来实现。`android:allowBackup`的默认值设置为`true`，如果应用程序希望选择退出备份，可以将其设置为`false`。`android:backupAgent`没有默认值，应该指定一个类名。
- en: The security implications of such a backup are debatable as services used to
    back up the data are different and sensitive data, such as usernames and passwords
    can be compromised.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种备份的安全性是有争议的，因为用于备份数据的服务不同，且敏感数据，如用户名和密码可能会被泄露。
- en: Putting it all together
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: The following example puts all the learning we have done so far to analyze `AndroidManifest.xml`
    provided with an Android SDK sample for `RandomMusicPlayer`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将我们迄今为止的学习内容应用于分析随Android SDK示例`RandomMusicPlayer`提供的`AndroidManifest.xml`。
- en: The manifest file specifies that this is version 1 of the application `com.example.android.musicplayer`.
    It runs on SDK 14 but supports backwards up to SDK 7\. The application uses two
    permissions namely, `android.permission.INTERNET` and `android.permission.WAKE_LOCK`.
    The application has one Activity that is the entry point for the application called
    `MainActivity`, one Service called `MusicService`, and one receiver called `MusicIntentReceiver`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件指定这是应用程序`com.example.android.musicplayer`的第1版，它在SDK 14上运行，但支持回退至SDK 7。应用程序使用了两个权限，分别是`android.permission.INTERNET`和`android.permission.WAKE_LOCK`。应用程序有一个名为`MainActivity`的Activity作为入口点，一个名为`MusicService`的服务，以及一个名为`MusicIntentReceiver`的接收器。
- en: '`MusicService` has defined custom actions called `PLAY`, `REWIND`, `PAUSE`,
    `SKIP`, `STOP`, and `TOGGLE_PLAYBACK`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`MusicService`定义了名为`PLAY`、`REWIND`、`PAUSE`、`SKIP`、`STOP`和`TOGGLE_PLAYBACK`的自定义动作。'
- en: The receiver uses the action intent `android.media.AUDIO_BECOMING_NOISY` and
    `android.media.MEDIA_BUTTON` defined by the Android system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器使用Android系统定义的动作意图`android.media.AUDIO_BECOMING_NOISY`和`android.media.MEDIA_BUTTON`。
- en: 'None of the components are protected with permissions. An example of an `AndroidManifst.xml`
    file is shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都没有受到权限保护。以下屏幕截图显示了`AndroidManifst.xml`文件的一个示例：
- en: '![Putting it all together](img/5603_04_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![整合所有内容](img/5603_04_06.jpg)'
- en: Example checklist
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例清单
- en: In this section, I have tried to put together an example list that I suggest
    you refer to whenever you are ready to release a version of your application.
    This is a very general version and you should adapt it according to your own use
    case and components. When creating a checklist think about issues that relate
    to the entire application, those that are specific to a component, and issues
    that might come up by setting the component and application specification together.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我尝试整理了一个建议您在准备发布应用程序版本时参考的示例列表。这是一个非常通用的版本，您应该根据自身使用案例和组件进行适配。在创建清单时，要考虑与整个应用程序相关的问题，与特定组件相关的问题，以及可能由组件和应用程序规范设置共同引发的问题。
- en: Application level
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序级别
- en: 'In this section, I have listed some questions that you should be asking yourself
    as you define the application specific preferences. They may affect how your application
    is viewed, stored, and perceived by users. Some application level questions that
    you may like to ask are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我列出了一些问题，在定义应用程序特定偏好时，你应该问自己这些问题。它们可能会影响用户如何看待、存储和感知你的应用程序。你可能需要问的一些应用程序级别的问题如下：
- en: Do you want to share resources with other applications that you have developed?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否希望与其他你开发的应用程序共享资源？
- en: Did you specify the unique user ID?
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否指定了唯一的用户ID？
- en: Did you define this unique ID for another application either intentionally or
    unintentionally?
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否故意或无意地为另一个应用程序定义了这个唯一ID？
- en: Does your application require some capabilities such as camera, Bluetooth, and
    SMS?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序是否需要一些功能，如摄像头、蓝牙和短信？
- en: Does your application need all these permissions?
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序是否需要所有这些权限？
- en: Is there another permission that is more restrictive than the one you have defined?
    Remember the principle of least privilege
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有比你所定义的权限更严格的权限？请记住最小权限原则。
- en: Do all the components of your application need this permission or only a few?
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序的所有组件都需要这个权限，还是只有少数需要？
- en: Check the spellings of all the permissions once again. The application may compile
    and work even if the permission spelling is incorrect.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次检查所有权限的拼写。即使权限拼写错误，应用程序也可能编译并运行。
- en: If you have defined this permission, is this the correct one that you need?
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你定义了此权限，这是否是你需要的正确权限？
- en: At what API level does the application work?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在哪个API级别上工作？
- en: What is the minimum API level that your application can support?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序能够支持的最小API级别是什么？
- en: Are there any external libraries that your application needs?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序是否需要任何外部库？
- en: Did you remember to turn off the debug attribute before you release?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在发布前是否记得关闭调试属性？
- en: If you are using a backup agent then remember to mention it here
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用了备份代理，那么请记得在这里提及。
- en: Did you remember to set a version number? This will help you during application
    upgrade
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否记得设置一个版本号？这将有助于你在应用程序升级时。
- en: Do you want to set an auto upgrade?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否希望设置自动升级？
- en: Did you remember to sign the application with your release key?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否记得用你的发布密钥签名应用程序？
- en: Sometimes setting a particular screen orientation will not allow your application
    to be visible on certain devices. For example, if your application only supports
    portrait mode then it might not appear for devices with landscape mode only.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时设置特定的屏幕方向将不允许你的应用程序在某些设备上显示。例如，如果你的应用程序只支持竖屏模式，那么它可能不会在只支持横屏模式的设备上显示。
- en: Where do you want to install the APK?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在哪个位置安装APK？
- en: Are there any services that might cease to work if the intent is not received
    in time?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果意图没有及时接收，是否有可能会停止工作的服务？
- en: Do you want some other application level settings, such as the ability of the
    system to restore components?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否希望有一些其他的应用程序级别设置，比如系统恢复组件的能力？
- en: If defining a new permission, think twice if you really want them. Chances are
    there is already an existing permission that will cover your use case.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果定义了新的权限，请三思是否真的需要它们。可能已经有一个现成的权限可以涵盖你的使用场景。
- en: Component level
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件级别
- en: 'Some component level questions that you will want to think about in the policy
    are listed here. These are questions that you should be asking yourself for each
    component:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些你需要在策略中考虑的组件级别的问题。这些问题是你在每个组件上都应该问自己的问题：
- en: Did you define all components?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否定义了所有组件？
- en: If using the third party libraries in your application, did you define all the
    components that you will use?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用了第三方库，你是否定义了你将使用的所有组件？
- en: Was there a particular setting that the third party library expects from your
    application?
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方库是否期望你的应用程序有特定的设置？
- en: Do you want this component to be visible to other applications?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否希望这个组件对其他应用程序可见？
- en: Do you need to add some Intent Filters?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要添加一些意图过滤器吗？
- en: If the component is not supposed to be visible, did you add Intent Filters?
    Remember as soon as you add Intent Filters, your component becomes visible.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组件不应该可见，你是否添加了意图过滤器？请记住，一旦你添加了意图过滤器，你的组件就会变得可见。
- en: Do other components require some special permission to trigger this component?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他组件是否需要一些特殊权限来触发这个组件？
- en: Verify the spelling of the permission name.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核对权限名称的拼写。
- en: Does your application require some capabilities such as camera, Bluetooth, and
    SMS?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序是否需要某些功能，如相机、蓝牙和短信？
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to define an applications policy file. The manifest
    file is the most important artifact of an application and should be defined with
    utmost care. This manifest file declares the permissions requested by an application
    and permissions that the external applications need to access its components.
    With the policy file we also define the storage location of the out APK and the
    minimum SDK against which the out application will run. The policy file exposes
    components that are not sensitive to the application. At the end of this chapter
    we discussed some sample issues that a developer should be aware of when writing
    a manifest file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何定义应用程序的策略文件。清单文件是应用程序最重要的工件，应当非常谨慎地定义。这个清单文件声明了应用程序请求的权限以及外部应用程序访问其组件所需的权限。通过策略文件，我们还定义了APK输出的存储位置以及应用程序将运行的最低SDK版本。策略文件公开了那些对应用程序不敏感的组件。在本章的末尾，我们讨论了开发者在编写清单文件时应该注意的一些示例问题。
- en: This chapter concludes the first section of the book where we learn about an
    Android application structure. Let's move to the next section of this book that
    focuses on secure storage of user data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节结束了本书第一部分的内容，我们学习了关于Android应用程序结构的知识。让我们继续学习本书的下一部分，重点关注用户数据的的安全存储。
