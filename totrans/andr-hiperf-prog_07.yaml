- en: Chapter 7. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 安全
- en: Security is defined in Wikipedia as *"the degree of resistance to, or protection
    from, harm. It applies to any vulnerable and valuable asset, such as a person,
    dwelling, community, item, nation, or organization."*
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科将安全定义为：“对伤害的抵抗程度或保护。它适用于任何脆弱且宝贵的资产，如人、住所、社区、物品、国家或组织。”
- en: When we think of security in software, our mind depicts pictures of hackers
    working with black screens and green fonts, typing always in console commands
    very fast to gain access to a system or to break a firewall. The reality is different
    to that seen in Hollywood. **Security** in software refers to a robust system
    that protects the privacy of its users, avoids undesired interaction from an attacker,
    and has integrity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考软件安全时，脑海中可能会浮现黑客在黑色屏幕和绿色字体中工作的画面，他们快速地在控制台输入命令，以获取系统访问权限或破坏防火墙。但现实与好莱坞电影中的情景不同。**软件安全**指的是一个强大的系统，它保护用户的隐私，避免攻击者的不必要交互，并保持完整性。
- en: 'A computer system can experience several vulnerabilities or attack vectors:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统可能会遇到多种漏洞或攻击向量：
- en: '**Backdoors**: A backdoor is a point used to bypass the security of the application,
    traditionally left by the developers of the system. In 2013, a scandal exposed
    by Snowden suggested that the NSA had backdoors to many operative systems and
    platforms, including those from Google.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后门**：后门是用于绕过应用程序安全性的点，通常是系统开发者留下的。2013年，斯诺登曝光的一个丑闻暗示，国家安全局（NSA）拥有许多操作系统和平台的后门，包括谷歌的。'
- en: '**Denial of service**: A **denial-of-service** (**DoS**) is an attack that
    aims to leave a resource unavailable to the users. The DDoS and DoS attacks belong
    to this category: those attacks consist of sending requests to a server until
    the server can''t handle all of them and stops serving content to legitimate users.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝服务攻击**：**拒绝服务**（**DoS**）是一种旨在使资源对用户不可用的攻击。DDoS和DoS攻击属于这一类别：这些攻击包括向服务器发送请求，直到服务器无法处理所有请求，并停止向合法用户服务内容。'
- en: '**Direct access attack**: In this category, an attacker directly accesses a
    system, generally with the purpose of stealing documentation or relevant information
    contained within it.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接访问攻击**：在这种攻击中，攻击者直接访问系统，通常目的是窃取文档或其中包含的相关信息。'
- en: '**Main-in-the-middle (MitM) attack**: With this attack, a third party interposes
    a computer between a legitimate destination and origin, and establishes itself
    fraudulently as the legitimate destination. The user then sends all the information
    to this interceptor, which often resends again the information to the legitimate
    destination, so the user does not realize the information has been intercepted.![Security](img/4666_07_01.jpg)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间人（MitM）攻击**：在这种攻击中，第三方将计算机插入合法目的地和源头之间，并欺诈性地将自己设置为合法目的地。然后用户将所有信息发送给这个拦截器，拦截器通常又将信息重新发送到合法目的地，因此用户没有意识到信息已被截获。![Security](img/4666_07_01.jpg)'
- en: Topography of a MitM attack
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MitM攻击的拓扑结构
- en: '**Tampering**: Tampering refers to the malicious modification of software,
    generally with the purpose of pretending it is a legitimate version, and performing
    in the background some undesired operation (such as monitoring, or information
    stealing).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改**：篡改是指恶意修改软件，通常目的是假装它是合法版本，并在后台执行一些不希望的操作（如监控或窃取信息）。'
- en: Android, as an operational system, is not free of those risks. It is in fact
    more threatened than other platforms, considering its wide scope (there are more
    than a billion Android devices worldwide). There have been some well-known (and
    widely used) applications with design flags that are generally used as examples
    of what can happen when the software is not correctly designed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作系统，Android并非没有这些风险。实际上，考虑到其广泛的应用范围（全球有超过十亿个Android设备），它比其他平台面临更多的威胁。已经有一些知名（并被广泛使用）的应用程序因设计标志通常被用作软件设计不当可能发生的情况的例子。
- en: WhatsApp – the eternal showcase of "no-gos"
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WhatsApp —— “不可为”的永恒展示
- en: WhatsApp can showcase some of the flags an application can present. A bug was
    reported in 2011, stating that communications within WhatsApp were not encrypted.
    A device connected to the same Wi-Fi network could access the communications between
    other devices. It took almost a year to get this bug fixed, a bug that was not
    especially complex to solve.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WhatsApp可以展示应用程序可能呈现的一些标志。2011年报告了一个漏洞，指出WhatsApp内的通信并未加密。连接到同一Wi-Fi网络的设备可以访问其他设备之间的通信。几乎花了一年的时间来修复这个漏洞，而这个漏洞并不是特别复杂难以解决。
- en: Later that year, a problem that allowed an attacker to impersonate a user and
    take control over his account was also reported. In January 2012, a hacker published
    a website that made it possible to change the status of any device with WhatsApp
    installed, if the phone number was known. The only measure taken by WhatsApp to
    fix this bug was to block the IP address of the website (as any reader can imagine,
    this is far from being an effective measure).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那一年晚些时候，也报告了一个问题，允许攻击者冒充用户并控制他的账户。2012年1月，一名黑客发布了一个网站，如果知道电话号码，就可以更改安装了WhatsApp的任何设备的状态。WhatsApp为修复这个漏洞所采取的唯一措施是封锁了网站的IP地址（正如任何读者可以想象的，这远非一个有效的措施）。
- en: 'A big problem present for many years in WhatsApp is that the messages are stored
    in a local database. This was done in the external storage, which is the file
    accessible by any other application (and any malicious hacker). This idea could
    have its reasons (keeping a backup, for example), but the implementation was a
    disaster. The database was encrypted always using the same encryption key, so
    anybody that had access to the file could easily unencrypt it. The following lines
    are an example of an action that took the database file, and sent it via e-mail:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WhatsApp多年来存在的一个大问题是，消息存储在本地数据库中。这是在外部存储中完成的，任何其他应用程序（以及任何恶意黑客）都可以访问该文件。这个想法可能有它的理由（例如，保持备份），但实施结果是一场灾难。数据库总是使用相同的加密密钥进行加密，因此任何可以访问该文件的人都可以轻松地解密它。以下是一个获取数据库文件并通过电子邮件发送的示例操作：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Going deeper into the code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码
- en: When we make developments in a particular technology, we generally program in
    a high-level language (such as C, C++, or Java) and later compile our code and
    resources into a file that will be executed in an independent platform. The process
    of compiling varies between technologies (Java has a different process than C++,
    since Java will run in a JVM). With more or less difficulty, code that has already
    been compiled can be "reversed" and accessed from the compiled code, which was
    generally unreadable, to something more user-friendly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在特定技术上发展时，通常会用高级语言（如C、C++或Java）编程，然后编译我们的代码和资源到一个文件中，该文件将在独立平台上执行。编译过程在技术之间有所不同（Java的编译过程与C++不同，因为Java将在JVM中运行）。通过或多或少的难度，已经编译的代码可以“逆向”并从编译后的代码访问，编译后的代码通常是不可读的，变为对用户更友好的形式。
- en: 'The following diagram shows how we develop applications in Android:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们在Android中开发应用程序的过程：
- en: '![Going deeper into the code](img/4666_07_18.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![深入代码](img/4666_07_18.jpg)'
- en: 'Here is the explanation for the above:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述内容的解释：
- en: Initially, we develop our application making use of the Android SDK and external
    libraries. Eventually, we also use NDK, which follows a different process of development
    and compiling.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，我们利用Android SDK和外部库开发我们的应用程序。最终，我们还使用了NDK，它遵循不同的开发和编译过程。
- en: When our application is ready and we want to compile it, it will be compiled
    to be executed in the Android virtual machine. This will be compiled in a rough
    equivalent bytecode file with a DEX format, which is the format Android understands.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的应用程序准备好，我们想要编译它时，它将被编译以在Android虚拟机上执行。这将被编译成一个大致相当于DEX格式的字节码文件，这是Android理解的格式。
- en: The file is later packaged and signed. The process of signing it is important,
    since we can then ensure that the file belongs to a particular company and has
    not been altered.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件后来被打包并签名。签名的过程很重要，因为这样我们可以确保文件属于特定的公司，并且没有被篡改。
- en: Later on, the application will be distributed through the Google App Store or
    any of the other alternative markets.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，应用程序将通过Google应用商店或其他替代市场进行分发。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android devices with a version 4.4 of the operating system or earlier use a
    particular version of the virtual machine called Dalvik, named after a fishing
    village in Iceland. This was discontinued with Android 5.0, which includes a new
    version of the virtual machine called **Android Runtime** (**ART**), which uses
    the same bytecode and DEX format.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备如果使用的是4.4版本或更早的操作系统，会使用一个特定的虚拟机版本，名为Dalvik，这个名字来源于冰岛的一个渔村。从Android 5.0开始，这个虚拟机版本被停止使用，取而代之的是一个新的虚拟机版本，名为**Android
    Runtime** (**ART**)，它使用相同的字节码和DEX格式。
- en: In order to access the code that generated an APK file, is as easy as following
    the steps in the reverse direction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问生成APK文件的代码，只需按照逆向步骤进行即可。
- en: Capturing an APK file
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获APK文件
- en: There are different methods we can use to capture an APK file. We will present
    in this book three of them, available at the time of writing (last quarter, 2015).
    Please note that the information provided in this chapter is only for educational
    purposes. There are some rules and legislation that need to be observed when performing
    reverse engineering, which will be discussed later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的方法来捕获APK文件。在本书中，我们将介绍三种（截至2015年第四季度可用）。请注意，本章提供的信息仅用于教育目的。在进行逆向工程时，需要遵守一些规则和立法，这将在后面讨论。
- en: Pulling a file from the device
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从设备中提取文件
- en: If our device is rooted or we are using an emulator with Google Play Services
    installed, it is possible to pull an APK that has been installed. Please note
    that a rooted device can be targeted by malicious applications and attackers.
    If you are going to root your device there is a lot of free information available
    on the Internet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的设备已经root或者我们使用的是安装了Google Play服务的模拟器，可以提取已安装的APK。请注意，root过的设备可能会受到恶意应用程序和攻击者的针对。如果你打算root你的设备，互联网上有大量的免费信息可供参考。
- en: 'When the application has been installed from the Play Store or an alternative
    market, you will first need to connect the `adb` to your computer. First you need
    to determine the package name of the target application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用从Play Store或替代市场安装后，你首先需要将`adb`连接到你的电脑。首先你需要确定目标应用的包名：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Try to match the application name with one of the packages that has been listed,
    which will not always be easy. If you cannot find it, observe the URL from a browser
    when you display the application in the Play Store:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将应用名称与列出的某个包进行匹配，这并不总是容易的。如果你找不到，观察当你在Play Store中显示应用时浏览器的URL：
- en: '![Pulling a file from the device](img/4666_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![从设备中提取文件](img/4666_07_02.jpg)'
- en: 'This image corresponds with Google Maps. The package name is everything after
    `id=-`. When you have identified the package, you need to get the full path to
    it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像与Google Maps相对应。包名是`id=-`之后的所有内容。确定包名后，你需要获取它的完整路径：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This typically returns an address in the folder `/data/app`. When you have
    located it, you need to pull it from the device:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会返回位于`/data/app`文件夹中的地址。找到它后，你需要从设备中提取它：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After this, you will have successfully downloaded your application APK.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样操作之后，你将成功下载应用的APK。
- en: Capturing an APK using Wireshark
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Wireshark捕获APK
- en: Wireshark is a network sniffer and analyzer widely used in the security world.
    It captures the traffic in a network and sniffs it, that means, reading the content
    that is not encrypted. Even if the content is encrypted, there are some techniques
    that can mislead a client or device into believing a server is authentic (man-in-the
    middle), and then intercept all the information that is being sent.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark是一个在安全领域广泛使用的网络嗅探和分析工具。它捕获网络中的流量并进行嗅探，即读取未加密的内容。即使内容被加密，也有一些技术可以误导客户端或设备认为服务器是真实的（中间人攻击），然后拦截所有发送的信息。
- en: 'In order to intercept the APK files (and the Android traffic) you need to create
    a hotspot in your computer. This will depend on the operating system you used.
    In Macintosh, it can easily be done through the option **Internet Sharing**, using
    the Ethernet as the sharing Internet connection and offering the Wi-Fi as the
    hotspot. This option can be found in the **Configuration** menu:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拦截APK文件（以及Android流量），你需要在电脑上创建一个热点。这将取决于你所使用的操作系统。在Macintosh上，可以通过选择**互联网共享**轻松完成，使用以太网作为共享的互联网连接，并提供Wi-Fi作为热点。这个选项可以在**配置**菜单中找到：
- en: '![Capturing an APK using Wireshark](img/4666_07_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![使用Wireshark捕获APK](img/4666_07_03.jpg)'
- en: 'When the phone is already connected to our hotspot and is navigating, we need
    to make Wireshark sniff from the connection. Using Wireshark and setting it up
    can take up an entire book. As a starting point: we need to point to the interface
    being shared with Wireshark, and pay attention to all the packages being sent
    and received. We can make use of filters to point out to the IP that is sending
    the information, since it can be a significant amount of information. When the
    URL and the authentication headers have been determined, we can proceed to download
    the APK using an HTTP request creator such as postman:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当手机已经连接到我们的热点并在浏览时，我们需要让Wireshark从连接中嗅探。使用Wireshark并设置它可能需要一整本书的篇幅。作为一个起点：我们需要指向与Wireshark共享的接口，并注意所有发送和接收的包。我们可以使用过滤器来指出发送信息的IP，因为可能会有大量的信息。当确定了URL和认证头后，我们可以使用如Postman之类的HTTP请求创建器下载APK。
- en: '![Capturing an APK using Wireshark](img/4666_07_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用Wireshark捕获APK](img/4666_07_04.jpg)'
- en: Using external websites
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外部网站
- en: Many websites provide this functionality in exchange for click-per-ad or by
    showing advertisements. A search in Google for `"download APK file online"` will
    throw thousands of websites back. A not very exhaustive search will lead us to
    download our target APK. We do, however, *STRONGLY* discourage this method. As
    we will see later, modifying an APK and inserting malicious code is a trivial
    task. The obscurity behind a website that offers an apparent free download can
    hide a code injection of malware.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站提供这项功能，以点击广告或展示广告作为交换。在Google上搜索"在线下载APK文件"，会返回成千上万的网站。一个不算详尽的搜索将引导我们下载我们的目标APK。然而，我们*强烈*不推荐这种方法。正如我们后面将看到的，修改APK并插入恶意代码是件轻而易举的事。提供明显免费下载的网站背后可能隐藏着恶意代码的注入。
- en: Autopsy of an APK file
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: APK文件解剖
- en: Let's suppose we have obtained an APK file. For the purpose of this section,
    and to keep the exercise easy, we will create a `HelloWorld` application, including
    merely a `TextView` inside `Activity`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经获得了一个APK文件。为了本节的用途，并且为了简化练习，我们将创建一个仅包含`Activity`内一个`TextView`的`HelloWorld`应用程序。
- en: 'To proceed analyzing the interior of our application, let''s first unzip the
    APK and check its content. We will see content similar to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析我们应用程序的内部结构，首先让我们解压APK并检查其内容。我们将看到类似以下的内容：
- en: '![Autopsy of an APK file](img/4666_07_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![APK文件解剖](img/4666_07_05.jpg)'
- en: For the newbies in this world, we can see that the Android manifest and the
    resources inside the `res` folder are directly accessible. The file, `classes.dex`,
    includes the compiled Java files as we explained in the previous section. The
    file, `Resources.arsc` (**Application Resource Files**), contains a list of binary
    resources, including any kind of data used by the program. This file is created
    by the **Android Asset Packaging Tool** (**aapt**).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个领域的新手来说，我们可以看到Android清单和`res`文件夹内的资源是直接可访问的。`classes.dex`文件包含了我们前面解释的编译后的Java文件。`Resources.arsc`文件（**应用程序资源文件**）包含二进制资源的列表，包括程序使用的任何类型的数据。这个文件是由**Android
    Asset Packaging Tool**（**aapt**）创建的。
- en: 'We will now introduce the first technique to read the code of a file that has
    not been obfuscated, and is transforming the file into a JAR file and then opening
    it with a decompiler. We will need two tools to do this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍第一种技术，读取未经混淆的文件的代码，并将文件转换为JAR文件，然后用反编译器打开它。为此，我们需要两个工具：
- en: '**dex2jar**: An open-source tool to transform Android APKs into JAR files.
    The translation is not fully accurate, but is often enough to decompile a JAR
    file (always easier) and to have an insight of the code. It can be downloaded
    from [http://sourceforge.net/p/dex2jar/](http://sourceforge.net/p/dex2jar/).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dex2jar**：一个开源工具，用于将Android APK转换为JAR文件。翻译并非完全准确，但通常足以反编译JAR文件（更容易）并洞察代码。可以从[http://sourceforge.net/p/dex2jar/](http://sourceforge.net/p/dex2jar/)下载。'
- en: '**JD-GUI**: The Java Decompiler Project is another open-source project aiming
    to decompile JAR files after Java Version 5 in an easy and intuitive way. We have
    plugins for Eclipse and IntelliJ, but for the purpose of this chapter we will
    use the standalone application. It can be downloaded from [http://jd.benow.ca/](http://jd.benow.ca/).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JD-GUI**：Java Decompiler项目是另一个开源项目，旨在以简单直观的方式反编译Java 5版本之后的JAR文件。我们为Eclipse和IntelliJ提供了插件，但为了本章的目的，我们将使用独立应用程序。可以从[http://jd.benow.ca/](http://jd.benow.ca/)下载。'
- en: 'When we have downloaded both applications, let''s first transform the APK into
    a JAR file. In order to do that, we need to write the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完这两个应用程序后，首先将APK转换成JAR文件。为此，我们需要编写以下命令：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or the following, if we are using the `.sh` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `.sh` 文件，以下是相关内容：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will generate in the same folder as the `target.apk` a file named `TargetFile_dex2jar.jar`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在与 `target.apk` 同一文件夹中生成一个名为 `TargetFile_dex2jar.jar` 的文件。
- en: 'Now let''s browse to this file, open it with the JD-GUI, and select the `HelloWorldActivity`.
    We will see something similar to the following screen:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开这个文件，使用JD-GUI打开它，并选择 `HelloWorldActivity`。我们将看到类似于以下屏幕的内容：
- en: '![Autopsy of an APK file](img/4666_07_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![APK文件的剖析](img/4666_07_06.jpg)'
- en: 'This is a basic example of an application, but a perceptive reader will realize
    that the possibilities for a more complex application are also immense. For the
    next exercise, let''s download a Crackme and try to play with its `insight.exercise`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用程序的基本示例，但一个敏锐的读者会意识到，对于更复杂的应用程序，可能性也是巨大的。对于下一个练习，让我们下载一个Crackme并尝试玩玩它的
    `insight.exercise`：
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Crackmes are programs generally created to test the knowledge of a programmer
    in reverse engineering. It offers a legal way to "crack" software and practice
    bypassing security measures, since there is no real company involved. They are
    used very often in competitions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Crackmes通常是为了测试程序员在逆向工程方面的知识而创建的程序。它提供了一种合法的方式来“破解”软件并练习绕过安全措施，因为这里没有真正的公司参与。它们经常被用在比赛中。
- en: 'In order to test a real scenario of reverse engineering, we need to download
    the following Crackme (registration required): [http://crackmes.de/users/deurus/android_crackme03/](http://crackmes.de/users/deurus/android_crackme03/).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一个真实的逆向工程场景，我们需要下载以下Crackme（需要注册）：[http://crackmes.de/users/deurus/android_crackme03/](http://crackmes.de/users/deurus/android_crackme03/)。
- en: 'After downloading it, unzip it and install the APK file in an emulator or device.
    After starting it, it will display the following screen:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，解压并将在模拟器或设备上安装APK文件。启动后，它将显示以下屏幕：
- en: '![Autopsy of an APK file](img/4666_07_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![APK文件的剖析](img/4666_07_07.jpg)'
- en: This particular program needs to be installed in a real device, since one of
    the parameters being taken will always be a set of 0s in an emulator. But for
    our purpose, it will work fine.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的程序需要安装在真实设备上，因为在模拟器中，其中一个参数将始终是一组0。但对于我们的目的，它将正常工作。
- en: 'We apply the same procedure as we applied previously in the `HelloWorld` application
    (convert to JAR and then open with JD-GUI). When it is open, navigate to the file,
    `HelloAndroid`. We will see the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用与之前在 `HelloWorld` 应用程序中相同的步骤（转换为JAR，然后用JD-GUI打开）。打开后，导航到文件 `HelloAndroid`。我们将看到以下代码：
- en: '![Autopsy of an APK file](img/4666_07_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![APK文件的剖析](img/4666_07_08.jpg)'
- en: 'This is a set of code that will not compile directly. It is full with random
    breaks and strange returns and conditions. However, we can reorganize it in a
    compiler to display the basics and understand it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组代码，它不能直接编译。它充满了随机的断点和奇怪的返回及条件。然而，我们可以将其重新组织在编译器中以显示基础内容并理解它：
- en: The values of the first and the second `TextView` in the main screen are taken
    into two variables (`str1` and `str2`).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主屏幕上第一个和第二个 `TextView` 的值被取到两个变量中（`str1` 和 `str2`）。
- en: If the length of the first string is smaller than 4, the process is aborted
    and `Toast` is shown with the text `"min 4 chars"`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第一个字符串的长度小于4，则进程会被终止，并显示带有文本 `"min 4 chars"` 的 `Toast`。
- en: There are two strings (`str5` and `str6`) that are, respectively, the device
    ID and the SIM serial number.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个字符串（`str5` 和 `str6`），分别是设备ID和SIM卡序列号。
- en: There are some further combinations of strings (`str7` and `str8`) that take
    a substring of `str5` and `str6`, and another one where an EXOR operator is applied.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一些字符串的组合（`str7` 和 `str8`），它们分别取 `str5` 和 `str6` 的子串，还有一个应用了EXOR运算符的组合。
- en: 'We can reorganize the code a little bit, to ensure it compiles. We can indicate
    our values provided in the same code, and run it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微重新组织一下代码，以确保它能够编译。我们可以在同一代码中指定我们提供的值，并运行它：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Try this code locally in your device to obtain the right information from the
    functions, `getDeviceId()` and `getSimSerialNumber()`. Introduce them later in
    the Crackme, and the message `"God boy"` (as in God) will be shown. Congratulations.
    You have just hacked your first Crackme using reverse engineering.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的设备上尝试这段代码，以从`getDeviceId()`和`getSimSerialNumber()`函数中获取正确的信息。稍后将在Crackme中引入它们，显示的消息将是“God
    boy”（这里指的是上帝）。恭喜你。你刚刚使用逆向工程破解了你的第一个Crackme。
- en: Code injection
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码注入
- en: Another big security risk is a code injection. **Code injections** happen when
    a piece of software is deliberately modified to insert a module of code, generally
    malicious, that performs an unintended operation. These unintended operations
    can range from data stealing, to user surveillance among others. Hence, in this
    particular case, it is particularly important that applications are signed. An
    application that has been signed from a trusted manufacturer will not contain
    injected code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个大的安全风险是代码注入。当软件被故意修改以插入一段通常具有恶意的代码模块，执行非预期操作时，就会发生**代码注入**。这些非预期操作可能包括数据窃取、用户监控等等。因此，在这种情况下，确保应用程序被签名尤为重要。来自可信任制造商签名的应用程序不会包含注入的代码。
- en: Georgie Casey, an Irish engineer, proved in an article in 2013 a scary proof
    of concept. He decompiled SwiftKey, the award-winning keyboard for Android, and
    injected a piece of code that logged all the keystrokes and sent them through
    a web service connected to a public website, where they were displayed. The point
    was to prove that anybody could have done this and upload the manipulated APK
    to one of the alternative stores. A person looking for a free APK could have downloaded
    it and used it, sending it without being aware of all the personal information
    (passwords and credit cards) being sent to the web service of the attacker. The
    process is thoroughly explained in his blog, and it is astonishing how easy the
    process is. In this section, we are going to show the process of modifying a basic
    `HelloWorld` to insert some new functionality in it, but it can be extended as
    far as the imagination allows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 爱尔兰工程师Georgie Casey在2013年的一篇文章中证明了可怕的概念验证。他反编译了获奖的Android键盘SwiftKey，并注入了一段代码，记录所有按键操作，并通过连接到公共网站的Web服务发送它们，在那里显示出来。他的目的是证明任何人都可以这样做，并将修改后的APK上传到替代商店之一。寻找免费APK的人可能已经下载并使用了它，在不知情的情况下将所有个人信息（密码和信用卡）发送到攻击者的Web服务。他在博客中详细解释了整个过程，这个过程有多么简单令人惊讶。在本节中，我们将展示如何修改基本的`HelloWorld`以插入一些新功能，但这个过程可以根据想象力扩展。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sticking to the official application store provides generally a full protection
    against this kind of attack. Google automatically scans all the APKs with a system
    called **Bouncer**, which is able to detect and deactivate malware and code with
    bad intentions. Also, reputable companies such as SwiftKey will not risk their
    reputation publishing an application that includes a KeyLogger to spy on their
    users.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持使用官方应用商店通常可以完全保护免受此类攻击。谷歌会使用一个名为**Bouncer**的系统自动扫描所有APK，该系统能够检测并停用具有恶意意图的恶意软件和代码。此外，像SwiftKey这样的知名公司不会冒险发布包含KeyLogger来监视用户的应用程序，从而损害自己的声誉。
- en: Let's get back to a program similar to `HelloWorld` that we developed in the
    previous sections. We will need another tool in this case, apktool. Previously,
    we transformed our application to a JAR, and then decompiled it with JD-GUI. Now
    we will perform a much more accurate process, which is disassembling and assembling
    the application directly into the Baksmali and Smali format (the format used by
    Android VM). Baksmali and Smali mean, respectively in Icelandic, dissembler and
    assembler (we reckon that Android developers at Google do primarily come from
    Iceland or they have a strong passion about the country, to name so many of their
    components after it). There is not a lot of official documentation about this
    format, so nowadays the most recommended procedure to learn about it is to decompile
    the application. As always—practice is better than theory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到在前几节中开发的类似于`HelloWorld`的程序。在这种情况下，我们需要另一个工具，即apktool。之前，我们将应用程序转换成了JAR，然后使用JD-GUI进行反编译。现在，我们将执行一个更精确的过程，直接将应用程序反汇编和组装成Baksmali和Smali格式（Android虚拟机使用的格式）。Baksmali和Smali在冰岛语中分别意味着反汇编器和汇编器（我们猜想谷歌的Android开发者主要来自冰岛，或者他们对这个国家有着强烈的热情，以至于给如此多的组件起名都与之相关）。关于这种格式没有太多的官方文档，所以现在推荐的了解它的方法是反编译应用程序。一如既往——实践胜于理论。
- en: 'Download apktool from the URL: [http://ibotpeaches.github.io/Apktool/](http://ibotpeaches.github.io/Apktool/).
    When it is safely on your computer, take the APK from the `HelloWorld` application
    and type the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://ibotpeaches.github.io/Apktool/](http://ibotpeaches.github.io/Apktool/)下载apktool。将其安全地下载到您的计算机上，然后从`HelloWorld`应用程序中取出APK，并输入以下命令：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will disassemble the current APK file into the folder `HelloWorld`. If
    we navigate into that folder, we will observe the following structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把当前的APK文件反汇编到`HelloWorld`文件夹中。如果我们进入该文件夹，我们会观察到以下结构：
- en: '`AndroidManifest.xml`: This is human readable'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`：这是可读的文件'
- en: '`res/folder`: The resource folder with all its content decoded'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/文件夹`：包含所有解码内容的资源文件夹'
- en: '`smali/folder`: This folder contains all the source files and is the most important
    one for this section'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smali/文件夹`：这个文件夹包含所有源文件，是这一节最重要的文件夹'
- en: '`apktool.yml`: The configuration file for apktool'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apktool.yml`：apktool的配置文件'
- en: 'Let''s navigate into the folder `smali/` and take a look. The structure will
    be similar to the following one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入`smali/`文件夹看看。其结构可能类似于以下这样：
- en: '![Code injection](img/4666_07_09.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![代码注入](img/4666_07_09.jpg)'
- en: For each class in the APK, we have created a `smali` file. There are some other
    files, with the notation, `class$name.smali`. They represent inner classes inside
    the class file (in our class inside the `R` class, which is the generated class
    to access the Android resources). The `smali` is (broadly) the bytecode representation
    of the Java files.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于APK中的每个类，我们已经创建了一个`smali`文件。还有一些其他文件，标记为`class$name.smali`。它们表示类文件内部的内部类（在我们的`R`类内部的类，这是生成用来访问Android资源的类）。`smali`（广义上）是Java文件的字节码表示。
- en: 'Now it is time to take a look at the `smali` file. Let''s first open `HelloWorldActivity.smali`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看`smali`文件了。首先打开`HelloWorldActivity.smali`：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we read the file, there are some instances and names that will be familiar:
    there seems to be a fair number of Android classes, such as `Activity` or `TextView`,
    and some Android methods, such as `setContentView()`. There seems to be a class
    declaration in the initial first three lines, followed by a constructor declaration,
    and the method `onCreate()` at the end.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们阅读这个文件，会看到一些熟悉的实例和名称：似乎有很多Android类，如`Activity`或`TextView`，还有像`setContentView()`这样的Android方法。文件开头三行看起来是一个类声明，之后是一个构造函数声明，最后是`onCreate()`方法。
- en: 'If we are familiar with some kind of machine programming, we will have heard
    of the meaning of registers (space allocated to insert information). We can observe
    this in lines such as:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们熟悉某种机器编程，就会知道寄存器（分配空间以插入信息）的含义。我们可以在如下这样的行中观察到这一点：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Different types of operations (creating a variable and accessing it) are being
    done, using some directions for the registers—in the preceding code, the directions
    `v0` and `v1` are being used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，执行了不同类型的操作（创建变量并访问它），使用了一些寄存器的方向——在这里使用了`v0`和`v1`方向。
- en: Opcodes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作码
- en: 'An opcode is easy to deduce; it is an operation code to be performed in a machine.
    Dalvik does not have a huge set of them in comparison with other languages and
    technologies (we can access, as a reference, most of them in the following URL:
    [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)).
    One of the advantages of decompiling Java/Dalvik is that the set is reduced and
    is easy to infer, therefore making it easier to automate tools for decompiling.
    Some of the opcodes that are included in the code that we just decompiled are:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码很容易推断，它是机器上要执行的操作代码。与其它语言和技术相比，Dalvik的操作码集合并不庞大（我们可以访问以下URL作为参考，其中包含大部分操作码：[http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)）。反编译Java/Dalvik的优点在于操作码集合较小，容易推断，因此更容易自动化反编译工具。我们刚才反编译的代码中包含的一些操作码有：
- en: '`invoke-super`: Calls to the `super` method'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke-super`：调用`super`方法'
- en: '`new-instance`: Creates a new instance of a variable'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new-instance`：创建一个变量的新实例'
- en: '`const-string`: Creates a string constant'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const-string`：创建一个字符串常量'
- en: '`invoke-virtual`: Invokes a `virtual` method'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke-virtual`：调用一个`virtual`方法'
- en: '`return-void`: Returns void'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return-void`：返回void'
- en: Injecting new code
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入新代码
- en: As we have probably deduced at this stage that the process of injecting code
    consists of creating the smali code from a functional application and injecting
    it into the right place. It is important to take care of the register's numeration
    to avoid overwriting and leaving the previous one without functionality.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可能已经推断出注入代码的过程包括从功能应用创建smali代码并将其注入正确的位置。注意寄存器的编号以避免覆盖并使之前的代码失去功能，这一点很重要。
- en: 'For example, if we create a function that shows a toast on the screen, compile
    the APK and proceed to disassembling, we will end up with some code similar to
    the following (ignoring the creating of the application and activities):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建一个在屏幕上显示吐司的函数，编译APK并进行反汇编，我们最终会得到一些类似于以下内容的代码（忽略创建应用和活动的部分）：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our case, there is no problem with overwriting registers. Let''s now patch
    the original file, where we will obtain something similar to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，覆盖寄存器没有问题。现在让我们修改原始文件，我们得到的结果类似于以下内容：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the constant string in the register `v1` has also been modified and
    now contains the text `"Hello World, Hacked Android!"`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，注册表中`v1`的常量字符串也已经修改，现在包含文本`"Hello World, Hacked Android!"`。
- en: Signing and rebuilding the application
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名与重新构建应用
- en: 'With the last changes applied, it is time to rebuild the application. Similar
    to how we disassemble the application, we will apply the following command to
    rebuild it (please note that you need to be in the disassembled application folder
    in order to rebuild it):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用最后修改后，是时候重新构建应用了。类似于我们如何反汇编应用，我们将应用以下命令来重新构建它（请注意，您需要处于反汇编应用文件夹中才能重新构建它）：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will create in the folder, `dist`, a file name, `HelloWorld.apk`.
    There is still, however, an important thing to do: sign the application. The APK
    we have just created has not been signed, and cannot yet be installed on any device.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在`dist`文件夹中创建一个名为`HelloWorld.apk`的文件。然而，还有一件重要的事情要做：签名应用。我们刚才创建的APK尚未签名，还不能在任何设备上安装。
- en: 'We first need a `keystore` in order to sign it. If we do not have one yet,
    we need to use a program such as `keytool` to generate one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`keystore`来进行签名。如果我们还没有，需要使用如`keytool`这样的程序来生成一个：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will need to input some information for the key. Although not strictly required,
    since the only purpose is for it to serve as a demo to repackage an APK, we still
    need to take care with the key we input, since we need to use it in the next step.
    When it has been generated, the process is as easy as using `jarsigner` to sign
    the resulting APK:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要输入一些密钥信息。虽然这不是严格要求的，因为唯一目的是作为一个重新打包APK的演示，我们仍然需要注意输入的密钥，因为下一步我们需要使用它。生成后，使用`jarsigner`对生成的APK进行签名的过程非常简单：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our resulting application will show the following screen:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的应用将展示以下界面：
- en: '![Signing and rebuilding the application](img/4666_07_10.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![签名与重新构建应用](img/4666_07_10.jpg)'
- en: Protecting our application
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护我们的应用
- en: We have seen that decompiling and recompiling an application is trivial without
    a proper measure. Not only is the purpose to pass the application as if it was
    our own, but we can easily access tokens and code that should not be accessible
    to everybody.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，如果没有适当的措施，反编译和重新编译应用程序是微不足道的。目的不仅仅是为了将应用程序当作自己的，我们还可以轻松访问不应被每个人访问的令牌和代码。
- en: 'We will explore different ideas in this chapter, but the main one is to apply
    obfuscation. **Obfuscation** is the process of making code unreadable to a human,
    slowing down or stopping its understanding. Obfuscation is a big thing in some
    areas, and there are even competitions to create the best obfuscation mechanisms.
    The following is an example of an obfuscated code in Python that displays on the
    screen the text `"Just another Perl / Unix hacker"` (the example is from Wikipedia,
    [https://en.wikipedia.org/wiki/Obfuscation_(software)](https://en.wikipedia.org/wiki/Obfuscation_(software))):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的想法，但主要的是应用混淆。**混淆**是使代码对人类不可读，减慢或停止理解的过程。在某些领域，混淆是一件大事，甚至还有创建最佳混淆机制的竞赛。以下是一个
    Python 语言中混淆代码的示例，它会在屏幕上显示文本 `"Just another Perl / Unix hacker"`（此示例来自维基百科，[https://en.wikipedia.org/wiki/Obfuscation_(software)](https://en.wikipedia.org/wiki/Obfuscation_(software))）：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Android, in particular, and Java, more generally, use ProGuard as a default
    mechanism to apply obfuscation to our source code. Activating ProGuard in our
    Android application is easy. Let''s navigate to `build.gradle`. We will most likely
    have some buildTypes defined (`release` and `debug` are the most common). A common
    practice is to activate ProGuard only for the `release` buildType:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是 Android，以及更广泛的 Java，使用 ProGuard 作为默认机制来对源代码应用混淆。在 Android 应用中激活 ProGuard
    是很简单的。让我们导航到 `build.gradle`。我们很可能有一些定义好的 buildTypes（`release` 和 `debug` 是最常见的）。一种常见的做法是只为
    `release` buildType 激活 ProGuard：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`minifyEnabled true` will do the trick and activate ProGuard for our release.
    Let''s see how a typical ProGuard file to be used with Android looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`minifyEnabled true` 将激活 ProGuard 使我们的发布版本生效。让我们看看一个典型的与 Android 一起使用的 ProGuard
    文件是什么样的：'
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ProGuard typically requires the inclusion of a custom configuration for new
    libraries that are being added, especially libraries using reflection. A ProGuard
    file will be regularly updated in an Android Studio project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ProGuard 通常需要为新添加的库包含一个自定义配置，特别是使用反射的库。在 Android Studio 项目中，ProGuard 文件将定期更新。
- en: Since the support library 19.1, the function `@Keep` was included as a part
    of the annotations library. This annotation can be used to specify that a method
    should not be proguarded. This can be particularly useful when we are accessing
    the method via reflection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自从支持库 19.1 版本以来，函数 `@Keep` 被包含在注释库的一部分中。这个注释可以用来指定一个方法不应该被混淆。当我们通过反射访问方法时，这特别有用。
- en: Insecure storage
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的存储
- en: 'The storage is the process that saves information into our device or computer.
    Android API basically offers five different types of storage:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是将信息保存到我们的设备或计算机的过程。Android API 基本上提供了五种不同的存储类型：
- en: SharedPreferences
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SharedPreferences
- en: The first and basic one is known as `SharedPreferences`. This type of storage
    saves into XML files, in the private folder, the information we have saved as
    pairs of primitives associated with each value. In the following screenshot we
    can see all the files under the folder, `shared_prefs`. Those files are `SharedPreferences`
    files.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种也是最基本的是 `SharedPreferences`。这种存储类型将信息保存为 XML 文件，在私有文件夹中，我们保存的作为与每个值相关联的原始对。在下面的屏幕截图中，我们可以看到
    `shared_prefs` 文件夹下的所有文件。这些文件是 `SharedPreferences` 文件。
- en: '![SharedPreferences](img/4666_07_12.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![SharedPreferences](img/4666_07_12.jpg)'
- en: 'If we pull one of them from the device, we will be able to see the following
    content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从设备中提取其中一个，我们将能够看到以下内容：
- en: '![SharedPreferences](img/4666_07_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![SharedPreferences](img/4666_07_13.jpg)'
- en: 'Each value inside the XML file has the following structure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文件内的每个值都有以下结构：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The name is composed of a combination of the filename and the variable name
    (the name we used to store the value). The type of the primitive `SharedPreference`
    is also delimited within the XML tag (for example, `<string…</string>`). And finally,
    the value is included in the value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是由文件名和变量名（我们用来存储值的名称）的组合构成的。原始类型 `SharedPreference` 也在 XML 标签内被界定（例如，`<string…</string>`）。最后，值包含在值字段内。
- en: 'To store `SharedPreferences`, we need to use a snippet similar to the following
    one:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储 `SharedPreferences`，我们需要使用类似于以下代码段的代码：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And in order to commit the changes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提交更改，我们需要：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And to restore the same value we just stored, we need to operate as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复我们刚才存储的值，我们需要进行如下操作：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: InternalStorage
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: InternalStorage（内部存储）
- en: Another type is the InternalStorage. This means storing information within the
    device's internal memory; it can only be accessed by the application. If the user
    uninstalls the application, this folder will also be uninstalled.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种是InternalStorage。这意味着将信息存储在设备的内部内存中；只能由应用程序访问。如果用户卸载应用程序，此文件夹也将被卸载。
- en: 'This is how we can store information in `InternalStorage`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在 `InternalStorage` 中存储信息的方法：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding snippet will store in a file called `hello_file` the string `"hello_world"`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段将会在名为 `hello_file` 的文件中存储字符串 `"hello_world"`。
- en: 'There are different modes to store files, not just the `MODE_PRIVATE` we have
    seen in this snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 存储文件有不同的模式，不仅仅是我们在本段中看到的 `MODE_PRIVATE`：
- en: '`MODE_APPEND`: This mode means that if the file already exists, it adds content
    to its end rather than overwriting it.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_APPEND`：这个模式意味着如果文件已经存在，它将在文件末尾添加内容，而不是覆盖它。'
- en: '`MODE_WORLD_READABLE`: This is a dangerous mode for a file, since it will be
    readable by the entire system and might create a security hole. If you want to
    use a mechanism to share information between applications, it is better to use
    one of the built-in mechanisms for Android. This mode provides to the file a read
    mode to the entire system.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_WORLD_READABLE`：这是一个危险的文件模式，因为它可以被整个系统读取，可能会造成安全漏洞。如果你想使用一种在应用程序之间共享信息的方法，最好使用Android内置的机制之一。这个模式为整个系统提供了对文件的读取模式。'
- en: '`MODE_WORLD_WRITEABLE`: This is similar to the one mentioned before, but in
    this case it provides write access.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE_WORLD_WRITEABLE`：这与之前提到的类似，但在这个情况下，它提供了写入权限。'
- en: 'There is also another interesting function for the internal files. They can
    be used as a caching mechanism if we open them with the function `getCacheDir()`.
    By opening a file with this command, rather than saving it persistently, we are
    telling Android that the file can be collected when the system is running low
    in memory. Please note that it is not 100% guaranteed that Android will collect
    this file. Rather than relying on the system, you should always ensure manually
    that the file does not grow above a certain size. When the user uninstalls the
    application, all these files will be automatically removed:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 内部文件还有一个有趣的用途。如果我们使用 `getCacheDir()` 函数打开它们，可以作为缓存机制。通过这种方式打开文件，我们告诉Android，当系统内存不足时，可以收集这个文件。请注意，不能100%保证Android会收集这个文件。因此，除了依赖系统，你应该始终确保文件不会超过一定大小。当用户卸载应用程序时，这些文件将被自动删除：
- en: '![InternalStorage](img/4666_07_11.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![InternalStorage](img/4666_07_11.jpg)'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The folder, `data/data`, is protected and is not accessible from devices that
    are not rooted (they are called **private storage**). However, if the devices
    have been rooted they can easily be read. That is why one must never store critical
    information there.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`data/data` 文件夹受到保护，未root的设备无法访问（它们被称为**私有存储**）。然而，如果设备被root了，它们可以很容易地被读取。这就是为什么我们绝不能在那里存储关键信息。'
- en: ExternalStorage
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExternalStorage（外部存储）
- en: 'Similar to the previously studied internal files, the ExternalStorage will
    create a file, but rather than saving it into the private folder it will be saved
    into the external folder (which is typically an SD card). We need two permissions
    in order to work with the ExternalStorage:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前研究的内部文件类似，ExternalStorage将创建一个文件，但它不是保存到私有文件夹中，而是保存到外部文件夹中（通常是SD卡）。为了使用ExternalStorage，我们需要两个权限：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the line `android:maxSdkVersion="18"`. Starting in the API, level 18 applications
    do not require anymore the permissions to write on the ExternalStorage. However,
    due to extreme Android fragmentation happening, it is a good idea.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一行 `android:maxSdkVersion="18"`。从API级别18开始，应用程序不再需要写入ExternalStorage的权限。然而，由于Android极度碎片化，这样做是一个好主意。
- en: As the reader has probably imagined, these permissions serve to write and read
    into the ExternalStorage, respectively.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能已经想象到，这些权限用于分别写入和读取ExternalStorage。
- en: 'In order to write or read into the ExternalStorage, we first need to prove
    that it is available (it might happen that the unit is not mounted for instance
    and therefore our application will not be able to write):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写入或读取ExternalStorage，我们首先需要证明它是可用的（例如，可能会发生存储单元未挂载的情况，因此我们的应用程序将无法写入）：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we have checked that we do have access to the storage system, we can proceed
    to either read or write in the files. To be able to write in a file, we proceed
    on a very similar way to how Java does it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当确认我们可以访问存储系统后，我们可以继续进行文件的读取或写入操作。在文件中写入内容的过程与Java中的操作非常相似：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Likewise, if what we want is to read a file from the ExternalStorage, we would
    proceed with a similar snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想要从 ExternalStorage 中读取文件，可以使用类似的代码片段：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deleting files
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除文件
- en: Please keep in mind that when using ExternalStorage, files will not be deleted
    when the application is removed. If an application is badly designed, we can end
    up with a huge amount of space being taken by files that will never be used.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用 ExternalStorage 时，当应用程序被移除时，文件不会被删除。如果应用程序设计不当，我们可能会因为永远不会使用的文件而占用大量空间。
- en: 'It is a general practice to store backup information in the ExternalStorage,
    but you should ask yourself if this will be the best alternative. In order to
    evaluate if the ExternalStorage should be used, it is a good practice to first
    query the amount of free space available in the device:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是将备份信息存储在 ExternalStorage 中，但你应该问自己这是否是最好的选择。为了评估是否应该使用 ExternalStorage，首先查询设备上可用的自由空间是一个好习惯：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Files can be easily deleted by calling the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用以下命令轻松删除文件：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using external or internal storage
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外部或内部存储
- en: Now that we know both possibilities, the reader might inquire as to which place
    is ideal to store information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了这两种可能性，读者可能会询问哪个地方是存储信息的理想选择。
- en: 'There is no silver bullet, nor a perfect answer. The answer might vary based
    on your constraint and the scenario you are trying to solve. However, keep in
    mind as a summary the following points:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 没有银弹，也没有完美答案。答案可能会根据你的限制和试图解决的问题场景而有所不同。然而，请记住以下总结点：
- en: The ExternalStorage keeps the file that has been saved there even when the application
    has been removed. On the other hand, when the application is removed, all the
    files stored in InternalStorage will be removed.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使应用程序被移除，ExternalStorage 中保存的文件仍然存在。另一方面，当应用程序被移除时，InternalStorage 中保存的所有文件也会被移除。
- en: The InternalStorage is always available. The ExternalStorage might be available
    or not, depending on the device.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InternalStorage 总是可用的。ExternalStorage 的可用性则取决于设备。
- en: InternalStorage provides a better level of protection against foreign access
    to the files, whereas the ExternalStorage are files universally accessible from
    the entire application. Keep in mind that rooted devices can access at any time
    both InternalStorage and ExternalStorage.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InternalStorage 提供了更好的保护级别，防止外部访问文件，而ExternalStorage 中的文件可以从整个应用程序普遍访问。请记住，已获得root权限的设备可以随时访问
    InternalStorage 和 ExternalStorage。
- en: Databases
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: 'Android provide a native support for SQLite databases. The files stored using
    databases are stored in a private folder (`/data/data`). Android provides natively
    the object, `SQLiteOpenHelper`, which can be used to store into tables. Let''s
    see an example of code with `SQLiteOpenHelper`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Android 原生支持SQLite数据库。使用数据库存储的文件保存在一个私有文件夹（`/data/data`）。Android 原生提供了 `SQLiteOpenHelper`
    对象，可用于存储到表格中。让我们看看使用 `SQLiteOpenHelper` 的代码示例：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the database version has been increased we can make use of the method, `onUpgrade()`,
    to update the database schema or perform any required operation in our application.
    The following screenshot shows the folder database inside one of the Google applications
    installed on a device:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库版本已经升级，我们可以使用 `onUpgrade()` 方法来更新数据库架构或在应用程序中执行任何需要的操作。以下截图展示了设备上安装的谷歌应用程序中的一个文件夹数据库：
- en: '![Databases](img/4666_07_14.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![数据库](img/4666_07_14.jpg)'
- en: Performance in databases
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库性能
- en: 'There are several performance improvements that can be added to SQLite databases
    in Android. We will mention some of them here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，可以对SQLite数据库进行多项性能优化。这里我们提到其中的一些：
- en: Use `db.beginTransaction();` and `db.endTransaction();` for data transfers if
    your application is performing a single transaction block. By default, every time
    you are performing a transaction, SQLite runtime will create a wrapper around
    it, making the operation costly. This is only advisable when you are performing
    this operation as a routine (for instance, inside a loop or inside an iteration).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序正在执行单一事务块，使用 `db.beginTransaction();` 和 `db.endTransaction();` 进行数据传输。默认情况下，每次你执行事务时，SQLite运行时都会创建一个包装器，这使得操作成本变高。这仅在当你将此操作作为常规操作执行时（例如，在循环或迭代内部）建议使用。
- en: Relationships are costly in performance terms. Even if you are using an index,
    the overhead and effort required to work with relationships is considerable, and
    it will likely slow down your application visibly.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能方面，关系是昂贵的。即使你使用了索引，处理关系所需的开销和努力也是相当大的，这很可能会明显减慢你的应用程序。
- en: Simplify the schema as much as you want, avoiding redundant attributes if possible.
    On the other hand, a schema should never be too general—this will sacrifice performance
    too. The trade-off between the representativeness and performance of a schema
    is difficult to obtain, but it is key to the survival of a database.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能简化模式，避免不必要的属性。另一方面，模式也不应该过于通用——这会牺牲性能。在模式的代表性和性能之间取得平衡是困难的，但这对于数据库的生存至关重要。
- en: Avoid creating views for tables that need to be accessed frequently. If this
    happens, it is sometimes better to create a particular table and store all the
    information there.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免为需要频繁访问的表创建视图。如果发生这种情况，有时创建一个特定的表并将所有信息存储在那里会更好。
- en: Use `SQLiteStatement` when possible. `SQLiteStatement` is, as you can deduce
    from the name, an SQL statement executed directly against the database. It can
    provide a notorious increase in performance and speed, especially if combined
    with the first point of this list.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用 `SQLiteStatement`。从名字可以推断出，`SQLiteStatement` 是直接针对数据库执行的SQL语句。它能够显著提高性能和速度，尤其是与这个列表中的第一点结合使用时。
- en: SQL injections
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入
- en: As with all database systems, SQLite in Android is also subjected and exposed
    to suffer an SQL injection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有数据库系统一样，Android中的SQLite也可能遭受SQL注入。
- en: 'An SQL injection happens when malicious data is inserted within a legit query,
    having generally pernicious effects over the database. It is better shown with
    an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意数据被插入到合法查询中时，就会发生SQL注入，通常会对数据库产生严重影响。一个例子可以更好地说明这一点：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Imagine that the input variables, `username` and `password`, are taken from
    a form where the user has to input them. In a normal condition, we would expect
    the SQL query to translate into something like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设输入变量 `username` 和 `password` 来自一个表单，用户需要输入它们。在正常情况下，我们预计SQL查询会变成这样：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But let''s imagine for a second that our user is rather a malicious user who
    is intending to gain access to our database. They could input:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们假设一下，如果我们的用户是一个恶意的用户，他打算访问我们的数据库。他们可能会输入：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because of the condition he inputted (`1=1`) and the rest of the query being
    commented, he will practically be able to log into the system without knowing
    any password. To prevent SQL injections, the best method is to sanitize the data
    being entered, and assume by default that it cannot be trusted. In order to do
    that, we have changed the above snippet of code into the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他输入的条件是 (`1=1`) 并且查询的其余部分被注释掉，他实际上可以在不知道任何密码的情况下登录系统。为了防止SQL注入，最好的方法是清理正在输入的数据，并默认认为它不可信。为了做到这一点，我们将上述代码片段改成了以下形式：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By using this easy technique, we have avoided the possibility of a malicious
    user taking over our database.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个简单的方法，我们避免了恶意用户接管我们数据库的可能性。
- en: ORM frameworks
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM框架
- en: 'Besides the pure approach to deal with SQL storage in Android, there is an
    approach in vogue known as ORM frameworks. Although an old paradigm, **ORM** (which
    stands for **object-relational mapping**) facilitates the task of dealing with
    ORM objects, abstracting us from the low-level queries and enabling us to focus
    on our application details. There are several ORM frameworks in almost every language:
    Hibernate for Java, ActiveRecord for Ruby, and so on. Android has a bunch of libraries
    that can be used for ORM purposes: Android Arsenal provides, in fact, an astonishing
    collection of open source libraries. We are providing here some small examples
    of a few libraries to show how they work; it is, of course, the responsibility
    of the reader to evaluate all the pros and cons, and make a decision about their
    implementation into his own project.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 Android 中处理 SQL 存储的纯方法之外，还有一种流行的处理方式称为 ORM 框架。尽管 ORM（对象关系映射）是一个旧范式，但它简化了处理
    ORM 对象的任务，将我们从低级查询中抽象出来，使我们能够专注于应用程序的细节。几乎每种语言都有几个 ORM 框架：Java 中的 Hibernate，Ruby
    中的 ActiveRecord 等等。Android 有一系列可用于 ORM 目的库：实际上，Android Arsenal 提供了令人惊叹的开源库集合。在这里，我们提供一些库的小例子来展示它们是如何工作的；当然，评估所有利弊并决定是否将其实现到自己的项目中，是读者的责任。
- en: OrmLite
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrmLite
- en: 'OrmLite is an open source framework based on Java that provides ORM functionality.
    Please note that the name is not Android ORM Lite—that means, it has not been
    specifically designed targeting Android. OrmLite makes heavy use of annotations.
    Let''s see an example of how the classes look with OrmLite:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: OrmLite 是一个基于 Java 的开源框架，提供了 ORM 功能。请注意，它的名称不是 Android ORM Lite，这意味着它并非专门为 Android
    设计的。OrmLite 大量使用注解。让我们看看使用 OrmLite 时类是什么样的一个例子：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'OrmLite can be found for Android in the following repository:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: OrmLite 在以下仓库中可以找到适用于 Android 的版本：
- en: '[https://github.com/j256/ormlite-android](https://github.com/j256/ormlite-android).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/j256/ormlite-android](https://github.com/j256/ormlite-android)。'
- en: SugarORM
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SugarORM
- en: 'SugarORM is an ORM engine that has been developed exclusively for Android,
    and it can be downloaded from [http://satyan.github.io/sugar/index.html](http://satyan.github.io/sugar/index.html).
    If you are using an application with Gradle it is even easier, since you can also
    add a line to your Gradle build file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SugarORM 是一个专门为 Android 开发的 ORM 引擎，可以从 [http://satyan.github.io/sugar/index.html](http://satyan.github.io/sugar/index.html)
    下载。如果你在一个使用 Gradle 的应用程序中，它甚至更容易，你只需在你的 Gradle 构建文件中添加一行：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And SugarORM will be automatically added to your project. Now it is time to
    update your `AndroidManifest.xml` file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 而 SugarORM 将会自动添加到你的项目中。现在是时候更新你的 `AndroidManifest.xml` 文件了：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And this is how a class `Book` like the previous one we created will look like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们创建的类似于前面一个的 `Book` 类看起来是这样的：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Adding a user after the model has been created couldn''t be easier:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型创建后添加用户再简单不过了：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: GreenDAO
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GreenDAO
- en: 'GreenDAO is arguably the fastest and most performant ORM engine for Android.
    It has been designed specifically for Android, so its development did take into
    account the particularities of the Droid platform that helps the ORM engine to
    be up to 4.5 times faster than OrmLite. The following diagram has been taken from
    the official website of GreenDao, and it shows how it performs in comparison with
    OrmLite in three different cases: insert statements, update statements, or loading
    entities.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: GreenDAO 可以说是 Android 上最快、性能最好的 ORM 引擎。它专门为 Android 设计，因此其开发考虑到了 Droid 平台的特殊性，帮助
    ORM 引擎的速度比 OrmLite 快达 4.5 倍。下面的图表来自 GreenDao 的官方网站，它展示了与 OrmLite 在三种不同情况下（插入语句、更新语句或加载实体）的性能比较。
- en: '![GreenDAO](img/4666_07_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![GreenDAO](img/4666_07_15.jpg)'
- en: Realm
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Realm
- en: 'Realm is a relatively new ORM engine proposed as a replacement for SQLite (and
    CoreData in iOS). Realm is not really built on top of SQLite, but at the top of
    its own persistence engine. One of the upsides of this engine is that it is a
    multiplatform, so it can be easily reused between different technologies. It is
    said to be very lightweight and fast too. It has a simplistic and minimalistic
    nature, which might also be a disadvantage if we need to perform complex operations.
    Following the example of `Book`, this is how we would deal with it using Realm:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Realm 是一个相对较新的 ORM 引擎，被提议作为 SQLite（以及 iOS 中的 CoreData）的替代品。Realm 并不是建立在 SQLite
    之上，而是建立在它自己的持久化引擎之上。这个引擎的一个优点是它是多平台的，因此可以轻松地在不同的技术之间复用。据说它非常轻量级且快速。它具有简单和简约的本质，如果我们需要执行复杂操作，这也可能是一个缺点。以下面的
    `Book` 示例，这就是我们如何使用 Realm 处理它：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Network
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: Storing data on the cloud, your own backend, or any other online solution will
    be in terms of security the best option if done properly (read the next section
    about encrypting communication while talking with a server). To perform network
    operations there are a few classes offered by default in Android, as well as many
    frameworks and libraries that can offer a high-level layer to create HTTP requests.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储在云上、自己的后端或任何其他在线解决方案，如果操作得当（阅读下一节关于与服务器通信时加密的内容），在安全性方面将是最佳选择。为了执行网络操作，Android
    默认提供了一些类，同时还有许多框架和库可以提供高级别的层来创建 HTTP 请求。
- en: Encrypted communication
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密通信
- en: We can never stress enough how important it is to use an encrypted channel of
    communication when creating web services and communicating them with an application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么强调都不过分，在创建 Web 服务以及与应用程序通信时使用加密的通信渠道有多么重要。
- en: Initially, it was intended as a protocol to exchange documents and information
    between scientific institutions, so security was not an important point at that
    time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，它旨在作为科学机构之间交换文档和信息的协议，因此那时安全性不是一个重要问题。
- en: The Internet evolved pretty quickly, and the initially limited HTTPs were suddenly
    facing millions of users interacting between them. There are tons of resources
    to discuss SSL and how the encryption is performed. For the purpose of this book,
    we will mention that the communications under HTTPS (which stands for **HTTP Secure**,
    or HTTP over SSL) are generally protected against man-in-the-middle attacks and
    cannot be easily sniffed. There are still some ways an attacker can manage to
    break into the communication channel and steal the communication, but they require
    a better knowledge and access to the victim. We will, however, mention them, in
    case the reader wants to inspect them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网发展得非常快，最初受限的 HTTPs 突然面临数百万用户之间的互动。有许多资源可以讨论 SSL 以及加密是如何进行的。为了本书的目的，我们将提到
    HTTPS（代表**HTTP Secure**，即 SSL 上的 HTTP）下的通信通常能够抵御中间人攻击，并且不容易被嗅探。然而，攻击者仍然有一些方法可以破解通信通道并窃取通信内容，但这需要更深入的知识和对受害者的访问权限。不过，我们将会提到它们，以防读者想要研究。
- en: Sniffing
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嗅探
- en: Sniffing is the main procedure an attacker would use in order to collect information
    from a network connection. The interesting thing is that, in order to sniff the
    traffic of other devices, you do not need to trick them and make them connect
    to your own network. It can easily be done just by connecting to the same network.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 嗅探是攻击者用来从网络连接中收集信息的主要过程。有趣的是，为了嗅探其他设备的流量，你不需要欺骗它们并让它们连接到你的网络。只需连接到同一个网络就可以轻松完成。
- en: To do that you need to download Wireshark from its official website, [https://www.wireshark.org/](https://www.wireshark.org/).
    Depending on the operating system you are trying to install it on, you might want
    to download a few more packages. Turn on the monitor or promiscuous mode on your
    wireless card. This procedure is fairly easy in Linux and various BSDs systems,
    including Macintosh. In Windows, the procedure can turn out to be pretty complex,
    and sometimes requires special wireless cards or tools.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要从其官方网站[https://www.wireshark.org/](https://www.wireshark.org/)下载 Wireshark。根据你尝试安装的操作系统的不同，你可能还需要下载一些其他软件包。在无线网卡上开启监控或混杂模式。在
    Linux 和各种 BSD 系统中（包括 Macintosh），这个过程相当简单。在 Windows 上，这个过程可能会相当复杂，有时需要特殊的无线网卡或工具。
- en: 'When we start Wireshark for the first time, we will display a screen similar
    to the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动 Wireshark 时，将会显示一个类似的屏幕：
- en: '![Sniffing](img/4666_07_16.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Sniffing](img/4666_07_16.jpg)'
- en: 'In the center of the screen, a listing of all the different interfaces available
    to be monitored will be displayed. This might vary from one machine to the other,
    but in the previous listing we can see:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕中央，将会显示所有可供监控的不同接口列表。这可能因机器而异，但在上一个列表中我们可以看到：
- en: Wi-Fi interfaces
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi 接口
- en: Vboxnet is the interface corresponding to a virtual machine
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vboxnet 是与虚拟机对应的接口
- en: Thunderbolt interfaces from a Macintosh computer
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Macintosh 计算机的 Thunderbolt 接口
- en: lo0 or loopback is the local machine
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lo0 或回环是本地机器
- en: '**Apple wireless direct link interface** (**awdl**)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苹果无线直接链接接口**（**awdl**）'
- en: For our testing purpose we will start an emulator, and select the interface
    Wi-Fi to monitor.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们将启动一个模拟器，并选择要监控的 Wi-Fi 接口。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that sniffing traffic in a network where you do not have the rights
    might be, in the best case, not very friendly. In the worst case, you might be
    committing a crime. Check before putting this knowledge into practice the legal
    situation in your country or region.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在你没有权限的网络中嗅探流量，在最好的情况下可能是不友好的行为。在最坏的情况下，你可能会犯下罪行。在将这一知识付诸实践之前，请检查你所在国家或地区的法律情况。
- en: 'Let''s now start navigating from our device. If we start the browser and navigate
    to a website without any protection, we will be able to display all the different
    requests the browser is performing: HTTP GET operations with its cookies, different
    resources, and so on:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从设备开始浏览。如果我们启动浏览器并访问一个没有任何保护的网站，我们将能够显示浏览器执行的所有不同请求：带有其 cookies 的 HTTP
    GET 操作、不同的资源等等：
- en: '![Sniffing](img/4666_07_17.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![嗅探](img/4666_07_17.jpg)'
- en: In the preceding screenshot, we are able to see cookies, user agents, hosts…
    pretty much the entire HTTP request is transparent! This is what happens when
    we are trying to connect to a URL without SSL. If you check the applications installed
    in your device, you will be able to see that often some of those applications
    are not using any kind of encryption, but just sending the information in plain
    text.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到 cookies、用户代理、主机……几乎整个 HTTP 请求都是透明的！这就是当我们尝试连接到一个没有 SSL 的 URL
    时发生的情况。如果你检查设备上安装的应用程序，你会发现经常有一些应用程序没有使用任何加密，只是以纯文本形式发送信息。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has analyzed security measures in an application. Security itself
    is a complex topic that could extend to several books. After reading this chapter,
    the reader will know how data can be intercepted. They will be able to store information
    securely. A penetration analysis into the code can be performed and in reverse,
    one can check if the application is exposing sensitive information to it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节分析了应用程序中的安全措施。安全本身是一个复杂的主题，其内容可以扩展到多本书籍。阅读完本章后，读者将了解数据可能被截获的方式。他们将能够安全地存储信息。可以对代码进行渗透分析，反之，也可以检查应用程序是否在无意中暴露敏感信息。
- en: ProGuard is an extensive tool to protect our application. We recommend the reader
    to take a further look at the official documentation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ProGuard 是一个广泛用于保护我们应用程序的工具。我们建议读者进一步查看官方文档。
- en: The reader should be familiar after reading this chapter with all the different
    options to store information securely in Android, as well as the advantages and
    disadvantages. The reader should be able to identify SQL injections and know how
    to prevent them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，读者应该熟悉在 Android 中安全存储信息的所有不同选项，以及它们的优缺点。读者应该能够识别 SQL 注入并知道如何预防。
- en: The reader will also be aware of the possibilities of sniffing traffic when
    the network has not been correctly protected. They will be familiar with Wireshark
    and the possibilities it offers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 读者还将了解到，当网络没有得到正确保护时，嗅探流量的可能性。他们将熟悉 Wireshark 及其所提供的可能性。
- en: Security is a huge topic, with many companies and research groups actively investing
    in resources to detect and prevent privacy and security flags. There are many
    other commercial and open source tools that we have not mentioned due to lack
    of space. For a more interested user, we recommend reading the OWASP newsletter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个庞大的话题，许多公司和研究组织都在积极投资资源以检测和预防隐私和安全问题。由于篇幅有限，我们未能提及许多其他商业和开源工具。对于感兴趣的用户，我们建议阅读OWASP通讯。
