- en: Chapter 7. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is defined in Wikipedia as *"the degree of resistance to, or protection
    from, harm. It applies to any vulnerable and valuable asset, such as a person,
    dwelling, community, item, nation, or organization."*
  prefs: []
  type: TYPE_NORMAL
- en: When we think of security in software, our mind depicts pictures of hackers
    working with black screens and green fonts, typing always in console commands
    very fast to gain access to a system or to break a firewall. The reality is different
    to that seen in Hollywood. **Security** in software refers to a robust system
    that protects the privacy of its users, avoids undesired interaction from an attacker,
    and has integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'A computer system can experience several vulnerabilities or attack vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backdoors**: A backdoor is a point used to bypass the security of the application,
    traditionally left by the developers of the system. In 2013, a scandal exposed
    by Snowden suggested that the NSA had backdoors to many operative systems and
    platforms, including those from Google.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Denial of service**: A **denial-of-service** (**DoS**) is an attack that
    aims to leave a resource unavailable to the users. The DDoS and DoS attacks belong
    to this category: those attacks consist of sending requests to a server until
    the server can''t handle all of them and stops serving content to legitimate users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct access attack**: In this category, an attacker directly accesses a
    system, generally with the purpose of stealing documentation or relevant information
    contained within it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main-in-the-middle (MitM) attack**: With this attack, a third party interposes
    a computer between a legitimate destination and origin, and establishes itself
    fraudulently as the legitimate destination. The user then sends all the information
    to this interceptor, which often resends again the information to the legitimate
    destination, so the user does not realize the information has been intercepted.![Security](img/4666_07_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topography of a MitM attack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Tampering**: Tampering refers to the malicious modification of software,
    generally with the purpose of pretending it is a legitimate version, and performing
    in the background some undesired operation (such as monitoring, or information
    stealing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android, as an operational system, is not free of those risks. It is in fact
    more threatened than other platforms, considering its wide scope (there are more
    than a billion Android devices worldwide). There have been some well-known (and
    widely used) applications with design flags that are generally used as examples
    of what can happen when the software is not correctly designed.
  prefs: []
  type: TYPE_NORMAL
- en: WhatsApp – the eternal showcase of "no-gos"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WhatsApp can showcase some of the flags an application can present. A bug was
    reported in 2011, stating that communications within WhatsApp were not encrypted.
    A device connected to the same Wi-Fi network could access the communications between
    other devices. It took almost a year to get this bug fixed, a bug that was not
    especially complex to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Later that year, a problem that allowed an attacker to impersonate a user and
    take control over his account was also reported. In January 2012, a hacker published
    a website that made it possible to change the status of any device with WhatsApp
    installed, if the phone number was known. The only measure taken by WhatsApp to
    fix this bug was to block the IP address of the website (as any reader can imagine,
    this is far from being an effective measure).
  prefs: []
  type: TYPE_NORMAL
- en: 'A big problem present for many years in WhatsApp is that the messages are stored
    in a local database. This was done in the external storage, which is the file
    accessible by any other application (and any malicious hacker). This idea could
    have its reasons (keeping a backup, for example), but the implementation was a
    disaster. The database was encrypted always using the same encryption key, so
    anybody that had access to the file could easily unencrypt it. The following lines
    are an example of an action that took the database file, and sent it via e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Going deeper into the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we make developments in a particular technology, we generally program in
    a high-level language (such as C, C++, or Java) and later compile our code and
    resources into a file that will be executed in an independent platform. The process
    of compiling varies between technologies (Java has a different process than C++,
    since Java will run in a JVM). With more or less difficulty, code that has already
    been compiled can be "reversed" and accessed from the compiled code, which was
    generally unreadable, to something more user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how we develop applications in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Going deeper into the code](img/4666_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the explanation for the above:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we develop our application making use of the Android SDK and external
    libraries. Eventually, we also use NDK, which follows a different process of development
    and compiling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When our application is ready and we want to compile it, it will be compiled
    to be executed in the Android virtual machine. This will be compiled in a rough
    equivalent bytecode file with a DEX format, which is the format Android understands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file is later packaged and signed. The process of signing it is important,
    since we can then ensure that the file belongs to a particular company and has
    not been altered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later on, the application will be distributed through the Google App Store or
    any of the other alternative markets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android devices with a version 4.4 of the operating system or earlier use a
    particular version of the virtual machine called Dalvik, named after a fishing
    village in Iceland. This was discontinued with Android 5.0, which includes a new
    version of the virtual machine called **Android Runtime** (**ART**), which uses
    the same bytecode and DEX format.
  prefs: []
  type: TYPE_NORMAL
- en: In order to access the code that generated an APK file, is as easy as following
    the steps in the reverse direction.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing an APK file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different methods we can use to capture an APK file. We will present
    in this book three of them, available at the time of writing (last quarter, 2015).
    Please note that the information provided in this chapter is only for educational
    purposes. There are some rules and legislation that need to be observed when performing
    reverse engineering, which will be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling a file from the device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If our device is rooted or we are using an emulator with Google Play Services
    installed, it is possible to pull an APK that has been installed. Please note
    that a rooted device can be targeted by malicious applications and attackers.
    If you are going to root your device there is a lot of free information available
    on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application has been installed from the Play Store or an alternative
    market, you will first need to connect the `adb` to your computer. First you need
    to determine the package name of the target application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to match the application name with one of the packages that has been listed,
    which will not always be easy. If you cannot find it, observe the URL from a browser
    when you display the application in the Play Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulling a file from the device](img/4666_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This image corresponds with Google Maps. The package name is everything after
    `id=-`. When you have identified the package, you need to get the full path to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This typically returns an address in the folder `/data/app`. When you have
    located it, you need to pull it from the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After this, you will have successfully downloaded your application APK.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing an APK using Wireshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireshark is a network sniffer and analyzer widely used in the security world.
    It captures the traffic in a network and sniffs it, that means, reading the content
    that is not encrypted. Even if the content is encrypted, there are some techniques
    that can mislead a client or device into believing a server is authentic (man-in-the
    middle), and then intercept all the information that is being sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to intercept the APK files (and the Android traffic) you need to create
    a hotspot in your computer. This will depend on the operating system you used.
    In Macintosh, it can easily be done through the option **Internet Sharing**, using
    the Ethernet as the sharing Internet connection and offering the Wi-Fi as the
    hotspot. This option can be found in the **Configuration** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing an APK using Wireshark](img/4666_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the phone is already connected to our hotspot and is navigating, we need
    to make Wireshark sniff from the connection. Using Wireshark and setting it up
    can take up an entire book. As a starting point: we need to point to the interface
    being shared with Wireshark, and pay attention to all the packages being sent
    and received. We can make use of filters to point out to the IP that is sending
    the information, since it can be a significant amount of information. When the
    URL and the authentication headers have been determined, we can proceed to download
    the APK using an HTTP request creator such as postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing an APK using Wireshark](img/4666_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using external websites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many websites provide this functionality in exchange for click-per-ad or by
    showing advertisements. A search in Google for `"download APK file online"` will
    throw thousands of websites back. A not very exhaustive search will lead us to
    download our target APK. We do, however, *STRONGLY* discourage this method. As
    we will see later, modifying an APK and inserting malicious code is a trivial
    task. The obscurity behind a website that offers an apparent free download can
    hide a code injection of malware.
  prefs: []
  type: TYPE_NORMAL
- en: Autopsy of an APK file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose we have obtained an APK file. For the purpose of this section,
    and to keep the exercise easy, we will create a `HelloWorld` application, including
    merely a `TextView` inside `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed analyzing the interior of our application, let''s first unzip the
    APK and check its content. We will see content similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy of an APK file](img/4666_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the newbies in this world, we can see that the Android manifest and the
    resources inside the `res` folder are directly accessible. The file, `classes.dex`,
    includes the compiled Java files as we explained in the previous section. The
    file, `Resources.arsc` (**Application Resource Files**), contains a list of binary
    resources, including any kind of data used by the program. This file is created
    by the **Android Asset Packaging Tool** (**aapt**).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now introduce the first technique to read the code of a file that has
    not been obfuscated, and is transforming the file into a JAR file and then opening
    it with a decompiler. We will need two tools to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dex2jar**: An open-source tool to transform Android APKs into JAR files.
    The translation is not fully accurate, but is often enough to decompile a JAR
    file (always easier) and to have an insight of the code. It can be downloaded
    from [http://sourceforge.net/p/dex2jar/](http://sourceforge.net/p/dex2jar/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JD-GUI**: The Java Decompiler Project is another open-source project aiming
    to decompile JAR files after Java Version 5 in an easy and intuitive way. We have
    plugins for Eclipse and IntelliJ, but for the purpose of this chapter we will
    use the standalone application. It can be downloaded from [http://jd.benow.ca/](http://jd.benow.ca/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we have downloaded both applications, let''s first transform the APK into
    a JAR file. In order to do that, we need to write the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the following, if we are using the `.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will generate in the same folder as the `target.apk` a file named `TargetFile_dex2jar.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s browse to this file, open it with the JD-GUI, and select the `HelloWorldActivity`.
    We will see something similar to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy of an APK file](img/4666_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a basic example of an application, but a perceptive reader will realize
    that the possibilities for a more complex application are also immense. For the
    next exercise, let''s download a Crackme and try to play with its `insight.exercise`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Crackmes are programs generally created to test the knowledge of a programmer
    in reverse engineering. It offers a legal way to "crack" software and practice
    bypassing security measures, since there is no real company involved. They are
    used very often in competitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test a real scenario of reverse engineering, we need to download
    the following Crackme (registration required): [http://crackmes.de/users/deurus/android_crackme03/](http://crackmes.de/users/deurus/android_crackme03/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading it, unzip it and install the APK file in an emulator or device.
    After starting it, it will display the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy of an APK file](img/4666_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This particular program needs to be installed in a real device, since one of
    the parameters being taken will always be a set of 0s in an emulator. But for
    our purpose, it will work fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We apply the same procedure as we applied previously in the `HelloWorld` application
    (convert to JAR and then open with JD-GUI). When it is open, navigate to the file,
    `HelloAndroid`. We will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Autopsy of an APK file](img/4666_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a set of code that will not compile directly. It is full with random
    breaks and strange returns and conditions. However, we can reorganize it in a
    compiler to display the basics and understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: The values of the first and the second `TextView` in the main screen are taken
    into two variables (`str1` and `str2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the length of the first string is smaller than 4, the process is aborted
    and `Toast` is shown with the text `"min 4 chars"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two strings (`str5` and `str6`) that are, respectively, the device
    ID and the SIM serial number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are some further combinations of strings (`str7` and `str8`) that take
    a substring of `str5` and `str6`, and another one where an EXOR operator is applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can reorganize the code a little bit, to ensure it compiles. We can indicate
    our values provided in the same code, and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Try this code locally in your device to obtain the right information from the
    functions, `getDeviceId()` and `getSimSerialNumber()`. Introduce them later in
    the Crackme, and the message `"God boy"` (as in God) will be shown. Congratulations.
    You have just hacked your first Crackme using reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Code injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another big security risk is a code injection. **Code injections** happen when
    a piece of software is deliberately modified to insert a module of code, generally
    malicious, that performs an unintended operation. These unintended operations
    can range from data stealing, to user surveillance among others. Hence, in this
    particular case, it is particularly important that applications are signed. An
    application that has been signed from a trusted manufacturer will not contain
    injected code.
  prefs: []
  type: TYPE_NORMAL
- en: Georgie Casey, an Irish engineer, proved in an article in 2013 a scary proof
    of concept. He decompiled SwiftKey, the award-winning keyboard for Android, and
    injected a piece of code that logged all the keystrokes and sent them through
    a web service connected to a public website, where they were displayed. The point
    was to prove that anybody could have done this and upload the manipulated APK
    to one of the alternative stores. A person looking for a free APK could have downloaded
    it and used it, sending it without being aware of all the personal information
    (passwords and credit cards) being sent to the web service of the attacker. The
    process is thoroughly explained in his blog, and it is astonishing how easy the
    process is. In this section, we are going to show the process of modifying a basic
    `HelloWorld` to insert some new functionality in it, but it can be extended as
    far as the imagination allows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sticking to the official application store provides generally a full protection
    against this kind of attack. Google automatically scans all the APKs with a system
    called **Bouncer**, which is able to detect and deactivate malware and code with
    bad intentions. Also, reputable companies such as SwiftKey will not risk their
    reputation publishing an application that includes a KeyLogger to spy on their
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to a program similar to `HelloWorld` that we developed in the
    previous sections. We will need another tool in this case, apktool. Previously,
    we transformed our application to a JAR, and then decompiled it with JD-GUI. Now
    we will perform a much more accurate process, which is disassembling and assembling
    the application directly into the Baksmali and Smali format (the format used by
    Android VM). Baksmali and Smali mean, respectively in Icelandic, dissembler and
    assembler (we reckon that Android developers at Google do primarily come from
    Iceland or they have a strong passion about the country, to name so many of their
    components after it). There is not a lot of official documentation about this
    format, so nowadays the most recommended procedure to learn about it is to decompile
    the application. As always—practice is better than theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download apktool from the URL: [http://ibotpeaches.github.io/Apktool/](http://ibotpeaches.github.io/Apktool/).
    When it is safely on your computer, take the APK from the `HelloWorld` application
    and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will disassemble the current APK file into the folder `HelloWorld`. If
    we navigate into that folder, we will observe the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AndroidManifest.xml`: This is human readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res/folder`: The resource folder with all its content decoded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smali/folder`: This folder contains all the source files and is the most important
    one for this section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apktool.yml`: The configuration file for apktool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s navigate into the folder `smali/` and take a look. The structure will
    be similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code injection](img/4666_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For each class in the APK, we have created a `smali` file. There are some other
    files, with the notation, `class$name.smali`. They represent inner classes inside
    the class file (in our class inside the `R` class, which is the generated class
    to access the Android resources). The `smali` is (broadly) the bytecode representation
    of the Java files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to take a look at the `smali` file. Let''s first open `HelloWorldActivity.smali`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we read the file, there are some instances and names that will be familiar:
    there seems to be a fair number of Android classes, such as `Activity` or `TextView`,
    and some Android methods, such as `setContentView()`. There seems to be a class
    declaration in the initial first three lines, followed by a constructor declaration,
    and the method `onCreate()` at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are familiar with some kind of machine programming, we will have heard
    of the meaning of registers (space allocated to insert information). We can observe
    this in lines such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Different types of operations (creating a variable and accessing it) are being
    done, using some directions for the registers—in the preceding code, the directions
    `v0` and `v1` are being used.
  prefs: []
  type: TYPE_NORMAL
- en: Opcodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An opcode is easy to deduce; it is an operation code to be performed in a machine.
    Dalvik does not have a huge set of them in comparison with other languages and
    technologies (we can access, as a reference, most of them in the following URL:
    [http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html](http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html)).
    One of the advantages of decompiling Java/Dalvik is that the set is reduced and
    is easy to infer, therefore making it easier to automate tools for decompiling.
    Some of the opcodes that are included in the code that we just decompiled are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invoke-super`: Calls to the `super` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new-instance`: Creates a new instance of a variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const-string`: Creates a string constant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invoke-virtual`: Invokes a `virtual` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return-void`: Returns void'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting new code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have probably deduced at this stage that the process of injecting code
    consists of creating the smali code from a functional application and injecting
    it into the right place. It is important to take care of the register's numeration
    to avoid overwriting and leaving the previous one without functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we create a function that shows a toast on the screen, compile
    the APK and proceed to disassembling, we will end up with some code similar to
    the following (ignoring the creating of the application and activities):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, there is no problem with overwriting registers. Let''s now patch
    the original file, where we will obtain something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the constant string in the register `v1` has also been modified and
    now contains the text `"Hello World, Hacked Android!"`.
  prefs: []
  type: TYPE_NORMAL
- en: Signing and rebuilding the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the last changes applied, it is time to rebuild the application. Similar
    to how we disassemble the application, we will apply the following command to
    rebuild it (please note that you need to be in the disassembled application folder
    in order to rebuild it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create in the folder, `dist`, a file name, `HelloWorld.apk`.
    There is still, however, an important thing to do: sign the application. The APK
    we have just created has not been signed, and cannot yet be installed on any device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need a `keystore` in order to sign it. If we do not have one yet,
    we need to use a program such as `keytool` to generate one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to input some information for the key. Although not strictly required,
    since the only purpose is for it to serve as a demo to repackage an APK, we still
    need to take care with the key we input, since we need to use it in the next step.
    When it has been generated, the process is as easy as using `jarsigner` to sign
    the resulting APK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our resulting application will show the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Signing and rebuilding the application](img/4666_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Protecting our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that decompiling and recompiling an application is trivial without
    a proper measure. Not only is the purpose to pass the application as if it was
    our own, but we can easily access tokens and code that should not be accessible
    to everybody.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore different ideas in this chapter, but the main one is to apply
    obfuscation. **Obfuscation** is the process of making code unreadable to a human,
    slowing down or stopping its understanding. Obfuscation is a big thing in some
    areas, and there are even competitions to create the best obfuscation mechanisms.
    The following is an example of an obfuscated code in Python that displays on the
    screen the text `"Just another Perl / Unix hacker"` (the example is from Wikipedia,
    [https://en.wikipedia.org/wiki/Obfuscation_(software)](https://en.wikipedia.org/wiki/Obfuscation_(software))):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Android, in particular, and Java, more generally, use ProGuard as a default
    mechanism to apply obfuscation to our source code. Activating ProGuard in our
    Android application is easy. Let''s navigate to `build.gradle`. We will most likely
    have some buildTypes defined (`release` and `debug` are the most common). A common
    practice is to activate ProGuard only for the `release` buildType:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`minifyEnabled true` will do the trick and activate ProGuard for our release.
    Let''s see how a typical ProGuard file to be used with Android looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: ProGuard typically requires the inclusion of a custom configuration for new
    libraries that are being added, especially libraries using reflection. A ProGuard
    file will be regularly updated in an Android Studio project.
  prefs: []
  type: TYPE_NORMAL
- en: Since the support library 19.1, the function `@Keep` was included as a part
    of the annotations library. This annotation can be used to specify that a method
    should not be proguarded. This can be particularly useful when we are accessing
    the method via reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The storage is the process that saves information into our device or computer.
    Android API basically offers five different types of storage:'
  prefs: []
  type: TYPE_NORMAL
- en: SharedPreferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and basic one is known as `SharedPreferences`. This type of storage
    saves into XML files, in the private folder, the information we have saved as
    pairs of primitives associated with each value. In the following screenshot we
    can see all the files under the folder, `shared_prefs`. Those files are `SharedPreferences`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '![SharedPreferences](img/4666_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we pull one of them from the device, we will be able to see the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SharedPreferences](img/4666_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each value inside the XML file has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The name is composed of a combination of the filename and the variable name
    (the name we used to store the value). The type of the primitive `SharedPreference`
    is also delimited within the XML tag (for example, `<string…</string>`). And finally,
    the value is included in the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store `SharedPreferences`, we need to use a snippet similar to the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And in order to commit the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And to restore the same value we just stored, we need to operate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: InternalStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another type is the InternalStorage. This means storing information within the
    device's internal memory; it can only be accessed by the application. If the user
    uninstalls the application, this folder will also be uninstalled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can store information in `InternalStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will store in a file called `hello_file` the string `"hello_world"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different modes to store files, not just the `MODE_PRIVATE` we have
    seen in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODE_APPEND`: This mode means that if the file already exists, it adds content
    to its end rather than overwriting it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODE_WORLD_READABLE`: This is a dangerous mode for a file, since it will be
    readable by the entire system and might create a security hole. If you want to
    use a mechanism to share information between applications, it is better to use
    one of the built-in mechanisms for Android. This mode provides to the file a read
    mode to the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODE_WORLD_WRITEABLE`: This is similar to the one mentioned before, but in
    this case it provides write access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also another interesting function for the internal files. They can
    be used as a caching mechanism if we open them with the function `getCacheDir()`.
    By opening a file with this command, rather than saving it persistently, we are
    telling Android that the file can be collected when the system is running low
    in memory. Please note that it is not 100% guaranteed that Android will collect
    this file. Rather than relying on the system, you should always ensure manually
    that the file does not grow above a certain size. When the user uninstalls the
    application, all these files will be automatically removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![InternalStorage](img/4666_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The folder, `data/data`, is protected and is not accessible from devices that
    are not rooted (they are called **private storage**). However, if the devices
    have been rooted they can easily be read. That is why one must never store critical
    information there.
  prefs: []
  type: TYPE_NORMAL
- en: ExternalStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the previously studied internal files, the ExternalStorage will
    create a file, but rather than saving it into the private folder it will be saved
    into the external folder (which is typically an SD card). We need two permissions
    in order to work with the ExternalStorage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note the line `android:maxSdkVersion="18"`. Starting in the API, level 18 applications
    do not require anymore the permissions to write on the ExternalStorage. However,
    due to extreme Android fragmentation happening, it is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: As the reader has probably imagined, these permissions serve to write and read
    into the ExternalStorage, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write or read into the ExternalStorage, we first need to prove
    that it is available (it might happen that the unit is not mounted for instance
    and therefore our application will not be able to write):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have checked that we do have access to the storage system, we can proceed
    to either read or write in the files. To be able to write in a file, we proceed
    on a very similar way to how Java does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, if what we want is to read a file from the ExternalStorage, we would
    proceed with a similar snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Deleting files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please keep in mind that when using ExternalStorage, files will not be deleted
    when the application is removed. If an application is badly designed, we can end
    up with a huge amount of space being taken by files that will never be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a general practice to store backup information in the ExternalStorage,
    but you should ask yourself if this will be the best alternative. In order to
    evaluate if the ExternalStorage should be used, it is a good practice to first
    query the amount of free space available in the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Files can be easily deleted by calling the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using external or internal storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know both possibilities, the reader might inquire as to which place
    is ideal to store information.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no silver bullet, nor a perfect answer. The answer might vary based
    on your constraint and the scenario you are trying to solve. However, keep in
    mind as a summary the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The ExternalStorage keeps the file that has been saved there even when the application
    has been removed. On the other hand, when the application is removed, all the
    files stored in InternalStorage will be removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The InternalStorage is always available. The ExternalStorage might be available
    or not, depending on the device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InternalStorage provides a better level of protection against foreign access
    to the files, whereas the ExternalStorage are files universally accessible from
    the entire application. Keep in mind that rooted devices can access at any time
    both InternalStorage and ExternalStorage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android provide a native support for SQLite databases. The files stored using
    databases are stored in a private folder (`/data/data`). Android provides natively
    the object, `SQLiteOpenHelper`, which can be used to store into tables. Let''s
    see an example of code with `SQLiteOpenHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the database version has been increased we can make use of the method, `onUpgrade()`,
    to update the database schema or perform any required operation in our application.
    The following screenshot shows the folder database inside one of the Google applications
    installed on a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Databases](img/4666_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Performance in databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several performance improvements that can be added to SQLite databases
    in Android. We will mention some of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `db.beginTransaction();` and `db.endTransaction();` for data transfers if
    your application is performing a single transaction block. By default, every time
    you are performing a transaction, SQLite runtime will create a wrapper around
    it, making the operation costly. This is only advisable when you are performing
    this operation as a routine (for instance, inside a loop or inside an iteration).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships are costly in performance terms. Even if you are using an index,
    the overhead and effort required to work with relationships is considerable, and
    it will likely slow down your application visibly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify the schema as much as you want, avoiding redundant attributes if possible.
    On the other hand, a schema should never be too general—this will sacrifice performance
    too. The trade-off between the representativeness and performance of a schema
    is difficult to obtain, but it is key to the survival of a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid creating views for tables that need to be accessed frequently. If this
    happens, it is sometimes better to create a particular table and store all the
    information there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `SQLiteStatement` when possible. `SQLiteStatement` is, as you can deduce
    from the name, an SQL statement executed directly against the database. It can
    provide a notorious increase in performance and speed, especially if combined
    with the first point of this list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all database systems, SQLite in Android is also subjected and exposed
    to suffer an SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'An SQL injection happens when malicious data is inserted within a legit query,
    having generally pernicious effects over the database. It is better shown with
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that the input variables, `username` and `password`, are taken from
    a form where the user has to input them. In a normal condition, we would expect
    the SQL query to translate into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But let''s imagine for a second that our user is rather a malicious user who
    is intending to gain access to our database. They could input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the condition he inputted (`1=1`) and the rest of the query being
    commented, he will practically be able to log into the system without knowing
    any password. To prevent SQL injections, the best method is to sanitize the data
    being entered, and assume by default that it cannot be trusted. In order to do
    that, we have changed the above snippet of code into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: By using this easy technique, we have avoided the possibility of a malicious
    user taking over our database.
  prefs: []
  type: TYPE_NORMAL
- en: ORM frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the pure approach to deal with SQL storage in Android, there is an
    approach in vogue known as ORM frameworks. Although an old paradigm, **ORM** (which
    stands for **object-relational mapping**) facilitates the task of dealing with
    ORM objects, abstracting us from the low-level queries and enabling us to focus
    on our application details. There are several ORM frameworks in almost every language:
    Hibernate for Java, ActiveRecord for Ruby, and so on. Android has a bunch of libraries
    that can be used for ORM purposes: Android Arsenal provides, in fact, an astonishing
    collection of open source libraries. We are providing here some small examples
    of a few libraries to show how they work; it is, of course, the responsibility
    of the reader to evaluate all the pros and cons, and make a decision about their
    implementation into his own project.'
  prefs: []
  type: TYPE_NORMAL
- en: OrmLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OrmLite is an open source framework based on Java that provides ORM functionality.
    Please note that the name is not Android ORM Lite—that means, it has not been
    specifically designed targeting Android. OrmLite makes heavy use of annotations.
    Let''s see an example of how the classes look with OrmLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'OrmLite can be found for Android in the following repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/j256/ormlite-android](https://github.com/j256/ormlite-android).'
  prefs: []
  type: TYPE_NORMAL
- en: SugarORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SugarORM is an ORM engine that has been developed exclusively for Android,
    and it can be downloaded from [http://satyan.github.io/sugar/index.html](http://satyan.github.io/sugar/index.html).
    If you are using an application with Gradle it is even easier, since you can also
    add a line to your Gradle build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And SugarORM will be automatically added to your project. Now it is time to
    update your `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how a class `Book` like the previous one we created will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a user after the model has been created couldn''t be easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: GreenDAO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GreenDAO is arguably the fastest and most performant ORM engine for Android.
    It has been designed specifically for Android, so its development did take into
    account the particularities of the Droid platform that helps the ORM engine to
    be up to 4.5 times faster than OrmLite. The following diagram has been taken from
    the official website of GreenDao, and it shows how it performs in comparison with
    OrmLite in three different cases: insert statements, update statements, or loading
    entities.'
  prefs: []
  type: TYPE_NORMAL
- en: '![GreenDAO](img/4666_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Realm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Realm is a relatively new ORM engine proposed as a replacement for SQLite (and
    CoreData in iOS). Realm is not really built on top of SQLite, but at the top of
    its own persistence engine. One of the upsides of this engine is that it is a
    multiplatform, so it can be easily reused between different technologies. It is
    said to be very lightweight and fast too. It has a simplistic and minimalistic
    nature, which might also be a disadvantage if we need to perform complex operations.
    Following the example of `Book`, this is how we would deal with it using Realm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing data on the cloud, your own backend, or any other online solution will
    be in terms of security the best option if done properly (read the next section
    about encrypting communication while talking with a server). To perform network
    operations there are a few classes offered by default in Android, as well as many
    frameworks and libraries that can offer a high-level layer to create HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can never stress enough how important it is to use an encrypted channel of
    communication when creating web services and communicating them with an application.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, it was intended as a protocol to exchange documents and information
    between scientific institutions, so security was not an important point at that
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet evolved pretty quickly, and the initially limited HTTPs were suddenly
    facing millions of users interacting between them. There are tons of resources
    to discuss SSL and how the encryption is performed. For the purpose of this book,
    we will mention that the communications under HTTPS (which stands for **HTTP Secure**,
    or HTTP over SSL) are generally protected against man-in-the-middle attacks and
    cannot be easily sniffed. There are still some ways an attacker can manage to
    break into the communication channel and steal the communication, but they require
    a better knowledge and access to the victim. We will, however, mention them, in
    case the reader wants to inspect them.
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sniffing is the main procedure an attacker would use in order to collect information
    from a network connection. The interesting thing is that, in order to sniff the
    traffic of other devices, you do not need to trick them and make them connect
    to your own network. It can easily be done just by connecting to the same network.
  prefs: []
  type: TYPE_NORMAL
- en: To do that you need to download Wireshark from its official website, [https://www.wireshark.org/](https://www.wireshark.org/).
    Depending on the operating system you are trying to install it on, you might want
    to download a few more packages. Turn on the monitor or promiscuous mode on your
    wireless card. This procedure is fairly easy in Linux and various BSDs systems,
    including Macintosh. In Windows, the procedure can turn out to be pretty complex,
    and sometimes requires special wireless cards or tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we start Wireshark for the first time, we will display a screen similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sniffing](img/4666_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the center of the screen, a listing of all the different interfaces available
    to be monitored will be displayed. This might vary from one machine to the other,
    but in the previous listing we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vboxnet is the interface corresponding to a virtual machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thunderbolt interfaces from a Macintosh computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lo0 or loopback is the local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apple wireless direct link interface** (**awdl**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our testing purpose we will start an emulator, and select the interface
    Wi-Fi to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that sniffing traffic in a network where you do not have the rights
    might be, in the best case, not very friendly. In the worst case, you might be
    committing a crime. Check before putting this knowledge into practice the legal
    situation in your country or region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now start navigating from our device. If we start the browser and navigate
    to a website without any protection, we will be able to display all the different
    requests the browser is performing: HTTP GET operations with its cookies, different
    resources, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sniffing](img/4666_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we are able to see cookies, user agents, hosts…
    pretty much the entire HTTP request is transparent! This is what happens when
    we are trying to connect to a URL without SSL. If you check the applications installed
    in your device, you will be able to see that often some of those applications
    are not using any kind of encryption, but just sending the information in plain
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has analyzed security measures in an application. Security itself
    is a complex topic that could extend to several books. After reading this chapter,
    the reader will know how data can be intercepted. They will be able to store information
    securely. A penetration analysis into the code can be performed and in reverse,
    one can check if the application is exposing sensitive information to it.
  prefs: []
  type: TYPE_NORMAL
- en: ProGuard is an extensive tool to protect our application. We recommend the reader
    to take a further look at the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The reader should be familiar after reading this chapter with all the different
    options to store information securely in Android, as well as the advantages and
    disadvantages. The reader should be able to identify SQL injections and know how
    to prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: The reader will also be aware of the possibilities of sniffing traffic when
    the network has not been correctly protected. They will be familiar with Wireshark
    and the possibilities it offers.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a huge topic, with many companies and research groups actively investing
    in resources to detect and prevent privacy and security flags. There are many
    other commercial and open source tools that we have not mentioned due to lack
    of space. For a more interested user, we recommend reading the OWASP newsletter.
  prefs: []
  type: TYPE_NORMAL
