- en: Chapter 9. Writing a Picture Puzzle Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 编写一个拼图游戏
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Implementing picture puzzle game logic
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现拼图游戏逻辑
- en: Implementing the animated 3D image selector
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现3D动画图像选择器
- en: Page-based user interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于页面的用户界面
- en: Image gallery with Picasa downloader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Picasa下载器的图像画廊
- en: Implementing the complete picture-puzzle game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现完整的拼图游戏
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: In this chapter, we continue putting together recipes from the previous chapters.
    We will implement a picture-puzzle game, where a player needs to put the puzzle
    pieces together in order to recreate the original image. Images are streamed from
    the featured gallery of the Picasa photo hosting, and can be picked via a 3D animated
    image selector. Our game has a simple page-based user interface that can serve
    as a starting point to a more complex game UI framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续将前几章的食谱组合在一起。我们将实现一个拼图游戏，玩家需要将拼图块拼在一起以重现原始图像。图像是从Picasa照片托管特色画廊流式传输的，可以通过3D动画图像选择器进行挑选。我们的游戏有一个简单的基于页面的用户界面，可以作为更复杂游戏UI框架的起点。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The example project of this chapter is actually a much simplified version of
    the Linderdaum Puzzle HD game published by the authors on Google Play: [http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD](http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的示例项目实际上是作者在Google Play上发布的Linderdaum Puzzle HD游戏的简化版本：[http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD](http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD)。
- en: Implementing picture puzzle game logic
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现拼图游戏逻辑
- en: This recipe you shows how to implement the game logic for a picture puzzle game.
    The game consists of a set of rectangular tiles shuffled and rendered on the screen.
    Users can tap on individual tiles, and move them around, swapping them with the
    other tiles. Let us draft the backbone data structures to implement this logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了如何为拼图游戏实现游戏逻辑。游戏由一组矩形瓦片组成，这些瓦片在屏幕上随机排列并渲染。用户可以点击单个瓦片，并将它们移动，与其他瓦片交换位置。让我们草拟实现此逻辑的骨干数据结构。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: To feel the game logic better, you can build and run the `2_PuzzleProto` project,
    which can be downloaded from [www.packtpub.com/support](http://www.packtpub.com/support).
    If you want to enjoy the full-featured game, just go ahead and download our Linderdaum
    Puzzle HD from Google Play. You can do it at [http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD](http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地感受游戏逻辑，你可以构建并运行`2_PuzzleProto`项目，该项目可以从[www.packtpub.com/support](http://www.packtpub.com/support)下载。如果你想享受功能完整的游戏，只需继续从Google
    Play下载我们的Linderdaum Puzzle HD。你可以在这里下载：[http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD](http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD)。
- en: '![Getting ready](img/7785_09_qr1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![准备开始](img/7785_09_qr1.jpg)'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we need the `clTile` class to store the state of an individual puzzle
    piece. It contains the current coordinates of the tile''s upper-left corner, the
    original indices of the tile in the grid, and the target coordinates where this
    tile will move to:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要`clTile`类来存储单个拼图块的状态。它包含瓦片左上角的当前坐标、瓦片在网格中的原始索引以及此瓦片将要移动到的目标坐标：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second constructor calculates and sets the `FRect` field, which contains
    the texture coordinates used later for the rendering:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个构造函数计算并设置`FRect`字段，该字段包含稍后用于渲染的纹理坐标：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Calculate the texture coordinates of the tile and store them in `FRect`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算瓦片的纹理坐标并将它们存储在`FRect`中：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next two methods set the target and current coordinates:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下两个方法设置目标和当前坐标：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The tile moves to the target coordinates smoothly. We update the tile position
    using the time counter, and for each time step, the coordinates are recalculated:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 瓦片平滑地移动到目标坐标。我们使用时间计数器更新瓦片位置，并且每个时间步都重新计算坐标：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The state of the game is presented by an array of tiles, which is stored in
    the `clPuzzle` class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏的状态由一个瓦片数组表示，该数组存储在`clPuzzle`类中：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Swap the two tiles specified by their `(i,j)` 2D coordinates:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换由它们的`(i,j)`二维坐标指定的两个瓦片：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The game is complete if all the tiles are in their places. To check if the
    tile is in place, we need to compare its `FOriginX` and `FOriginY` coordinates
    to its current `i` and `j` coordinates:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有的瓦片都在它们的位置上，游戏就完成了。为了检查瓦片是否在位，我们需要比较它的`FOriginX`和`FOriginY`坐标与它当前的`i`和`j`坐标：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`clPuzzle::Timer()` calls the `Update()` method, which calculates new coordinates
    for each of the tiles. This is required to allow the tiles to return to their
    position once the player releases touches:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clPuzzle::Timer()` 调用 `Update()` 方法，该方法计算每个瓦片的新坐标。这样做的目的是当玩家松开触摸时，让瓦片返回到原来的位置：'
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The initial state of the game is generated in the `Retoss()` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏的初始状态在 `Retoss()` 方法中生成：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we create all the tiles at their initial positions:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在初始位置创建所有瓦片：
- en: '[PRE10]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we use Knuth shuffle, also known as Fisher–Yates shuffle ([http://en.wikipedia.org/wiki/Fisher–Yates_shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle))
    to generate a random permutation of the tiles:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用克努斯洗牌法，也称为费雪-耶茨洗牌法（[http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)），生成瓦片的随机排列：
- en: '[PRE11]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The handling of user input is performed in the `OnKey()` method. When the user
    presses the mouse button or taps on the screen, this method is called with the
    `KeyState` argument equal to true. On the mouse release or at the end of the tap,
    the `OnKey()` method is called with `KeyState` set to false. The `mx` and `my`
    parameters contain the 2D coordinates of the touch. Once the touch is active,
    we store the indices of the tile and the initial offset of the touch point respective
    to the upper-left corner of the tile:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入的处理在 `OnKey()` 方法中完成。当用户按下鼠标按钮或轻触屏幕时，该方法会以 `KeyState` 参数为真被调用。在鼠标释放或轻触结束时，`OnKey()`
    方法会以 `KeyState` 设置为假被调用。`mx` 和 `my` 参数包含触摸的2D坐标。一旦触摸激活，我们存储瓦片的索引和触摸点相对于瓦片左上角的初始偏移量：
- en: '[PRE12]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the touch ends, we check the validity of the new tile position and exchange
    the selected tile with the tile in the new position:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当触摸结束时，我们检查新瓦片位置的有效性，并用新位置中的瓦片交换选择的瓦片：
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `2_PuzzleProto` example uses the `clPuzzle` class to show the gameplay without
    any textures or any fancy graphics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`2_PuzzleProto` 示例使用 `clPuzzle` 类来展示没有任何纹理或花哨图形的游戏玩法。'
- en: 'To render the state of the puzzle, the following routine is used:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染拼图的状态，使用了以下例程：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we have selected the tile, we move it to the new mouse or touch position:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择了瓦片，我们将其移动到新的鼠标或触摸位置：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, each tile is rendered with the `DrawTile()` method call:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个瓦片通过调用 `DrawTile()` 方法进行渲染：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `DrawTile()` method calculates the coordinates of the tile in normalized
    screen coordinates `(0...1)` and uses a rectangular vertex array and the `g_Canvas`
    object to render the `Tile` instance:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawTile()` 方法计算瓦片在标准化屏幕坐标 `(0...1)` 中的位置，并使用矩形顶点数组和 `g_Canvas` 对象来渲染 `Tile`
    实例：'
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the next recipes, we combine this simple gameplay with an animated image
    selector and the Picasa images downloader to create a more feature-rich puzzle
    game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的教程中，我们将这个简单的游戏玩法与动画图像选择器和Picasa图像下载器结合起来，创建一个功能更丰富的拼图游戏。
- en: Implementing the animated 3D image selector
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现3D动画图像选择器
- en: The main UI element of our puzzle game is the animated 3D image selector. In
    this recipe, we show you how to render the animated carousel-like selector and
    interact with the user.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拼图游戏的主要UI元素是动画3D图像选择器。在本教程中，我们将向您展示如何渲染类似旋转木马的动画选择器并与用户互动。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before proceeding with this recipe, you may need to go back to [Chapter 7](ch07.html
    "Chapter 7. Cross-platform UI and Input Systems"), *Cross-platform UI and Input
    System*, and read how the `Canvas` class works. A bit of mathematics will be required
    to understand better how the code in this recipe works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本教程之前，您可能需要回到[第7章](ch07.html "第7章.跨平台UI和输入系统")，*跨平台UI和输入系统*，了解 `Canvas` 类是如何工作的。为了更好地理解本教程中的代码，还需要一些数学知识。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The idea behind the rendering is quite simple. We let the individual quads
    move in a way that their corners slide along four guiding curves. The following
    figure shows the same quad in a series of positions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染背后的想法非常简单。我们让各个四边形沿着四条引导曲线移动，使它们的角滑动。下图展示了同一个四边形在不同位置的一系列状态：
- en: '![How to do it...](img/7785_09_1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/7785_09_1.jpg)'
- en: The four curves show the paths of the quad's corners.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 四条曲线展示了四边形角的路径。
- en: We start with the helper `Curve` class, which implements the linear interpolation
    on the set of control points. A curve is represented in a parametric form.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从辅助类 `Curve` 开始，这个类实现了对控制点集的线性插值。曲线以参数形式表示。
- en: '*A parametric equation of a curve is a representation of this curve through
    equations expressing the coordinates of the points of the curve as functions of
    a variable called a parameter.*'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*曲线的参数方程是通过将曲线上的点的坐标表示为参数的函数来表示这条曲线的方程。*'
- en: 'Courtesy: [http://en.wikipedia.org/wiki/Parametric_equation](http://en.wikipedia.org/wiki/Parametric_equation)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考文献：[http://en.wikipedia.org/wiki/Parametric_equation](http://en.wikipedia.org/wiki/Parametric_equation)
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `AddControlPoint()` method adds a new control point to the curve. The curve
    is lazy-evaluated, and now we just store the specified values:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddControlPoint()`方法向曲线添加一个新的控制点。曲线是延迟计算的，现在我们只需存储指定的值：'
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `GetPosition()` method finds a segment for the given parameter `t` and
    calculates a linearly interpolated coordinate of a point on the curve:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetPosition()`方法找到给定参数`t`的段，并计算曲线上点的线性插值坐标：'
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The control points and corresponding arguments are stored in two vectors:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制点和相应的参数存储在两个向量中：
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A 3D image selector control logic is implemented in the `clFlowUI` class:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D图像选择器的控制逻辑在`clFlowUI`类中实现：
- en: '[PRE22]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a 3D camera for our UI:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的 UI 创建一个3D相机：
- en: '[PRE23]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A standard perspective camera is used:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准透视相机：
- en: '[PRE24]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Arctangent is multiplied `by exp(-x^2)`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 余切乘以`exp(-x^2)`：
- en: '[PRE25]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the UI scrolling limits using the current number of elements:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前元素数量更新 UI 滚动限制：
- en: '[PRE26]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calculate the index of the currently selected index image:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算当前选定索引图像的索引：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Coordinates for individual quad are calculated in the `QuadCoords()` method,
    which invokes `Curve::GetPosition()` for each of the four guiding curves:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 四边形的坐标在`QuadCoords()`方法中计算，该方法为每条引导曲线调用`Curve::GetPosition()`：
- en: '[PRE28]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the trajectory control points for each base curve:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每条基本曲线添加轨迹控制点：
- en: '[PRE29]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following are the parameters for the guiding curves. The number of screen
    units (in normalized coordinates) between the sequential control points:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是引导曲线的参数。屏幕单位（在标准化坐标中）之间的连续控制点数量：
- en: '[PRE30]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The empirical tweaking parameter for the quad points, speed:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于四边形顶点的经验调整参数，速度：
- en: '[PRE31]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The height of the image, which means the distance between the lower and upper
    curves, thickness, and slope of the curve:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像的高度，即两条曲线之间的距离，厚度，以及曲线的斜率：
- en: '[PRE32]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The symmetric displacement of curve peaks, exponential falloff, and main coefficient:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 曲线峰值的对称位移，指数衰减，以及主系数：
- en: '[PRE33]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `clFlowFlinger` class holds the dynamic state of the selector:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clFlowFlinger`类保存选择器的动态状态：'
- en: '[PRE34]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Decide what to do on the selection—return `true` if the selection is complete,
    or `false` otherwise:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定在选定时要做什么——如果选择完成则返回`true`，否则返回`false`：
- en: '[PRE35]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Update the animation and handle touches:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新动画和处理触摸：
- en: '[PRE36]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Touch handling is performed in the `OnTouch()` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸处理在`OnTouch()`方法中执行：
- en: '[PRE37]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the touch point has moved less than 1 percent of the screen, or the gesture
    has taken less than 10 milliseconds we consider it being a tap:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果触摸点移动距离少于屏幕的1%，或者手势耗时少于10毫秒，我们认为这是一个点击：
- en: '[PRE38]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Otherwise, if the gesture spans less than 300 milliseconds, we stop the motion:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果手势持续时间少于300毫秒，我们停止运动：
- en: '[PRE39]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The coefficients for positions and timings were chosen empirically based on
    the perception of the motion. The dynamics are implemented in the `Update()` method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置和时序的系数是根据运动的感知经验选择的。动态实现在`Update()`方法中：
- en: '[PRE40]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we reach the last image, we just clamp the position on the guiding curves.
    For a smooth experience, we also add a **rubber band** effect, by interpolating
    the position using the linear formulas. The `Damper` coefficient is purely empiric:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们到达最后一个图像时，只需将位置固定在引导曲线上。为了获得流畅的体验，我们还通过使用线性公式插值位置添加了**橡皮筋**效果。`Damper`系数纯粹是经验性的：
- en: '[PRE41]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A nice set of parameters for comfortable scrolling is defined in the `FlowFlinger.h`
    file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FlowFlinger.h`文件中定义了一组舒适的滚动参数：
- en: '[PRE42]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You are encouraged to try your own values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您尝试自己的值。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The carousel rendering is based on `Canvas` and implemented in the `RenderDirect()`
    function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播渲染基于`Canvas`，在`RenderDirect()`函数中实现：
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We manually specify the quad rendering order. First we render the left-hand
    side images, then the images on the right-hand side, and finally the central image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动指定四边形的渲染顺序。首先渲染左侧的图像，然后是右侧的图像，最后是中央的图像：
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Actual rendering of checks for array boundaries, and application of the `Projection`
    and `View` matrices to each corner of the quad:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际渲染时检查数组边界，并将`Projection`和`View`矩阵应用到四边形的每个角：
- en: '[PRE45]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The final rendering is done using the `BoxR()` function, which is implemented
    in the `main.cpp` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的渲染是通过`BoxR()`函数完成的，该函数实现在`main.cpp`文件中。
- en: 'A modification to the carousel code is needed to support selection. We add
    the `GeomUtil.h` file with a few methods of intersection testing. Similar, to
    the `RenderFlow()` procedure, we iterate over visible images, and for each of
    those, we intersect the ray from the tap location through the image plane:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持选择功能，需要对轮播图代码进行修改。我们添加了`GeomUtil.h`文件，其中包含了一些交线测试方法。类似于`RenderFlow()`过程，我们遍历可见的图像，并对每个图像，从点击位置通过图像平面发射射线进行交点检测：
- en: '[PRE46]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Map the 2D screen touch point to a 3D point and a ray:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将2D屏幕触摸点映射到3D点和一个射线：
- en: '[PRE47]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Iterate over the current image quads:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历当前图像四边形：
- en: '[PRE48]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Transform the quad coordinates into the world space:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将四边形坐标转换到世界空间：
- en: '[PRE49]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Intersect the ray with two triangles:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将射线与两个三角形相交：
- en: '[PRE50]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `Unproject()` and `MouseCoordsToWorldPointAndRay()` functions convert 2D
    screen point coordinates into a ray in the 3D world space, where our carousel
    quads fly. Their implementations can be found in the `GeomUtil.h` file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unproject()`和`MouseCoordsToWorldPointAndRay()`函数将2D屏幕点坐标转换为3D世界空间中的射线，我们的轮播图四边形在其中飞行。它们的实现在`GeomUtil.h`文件中可以找到。'
- en: 'To rewind the selector to some specific image we set a target position:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将选择器回退到特定的图像，我们设置了一个目标位置：
- en: '[PRE51]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe we used 3D lines to render the carousel. It is really simple
    to use the `Canvas` class to render each quad with a texture. We also encourage
    the reader to add a reflection effect, which is easily done by rendering the same
    set of quads with an additional transform representing the reflection from a horizontal
    plane.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了3D线来渲染轮播图。使用`Canvas`类来渲染每个带纹理的四边形非常简单。我们也鼓励读者添加反射效果，这可以通过使用额外的变换来渲染相同的一组四边形，从而轻松实现水平面的反射效果。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Implementing the complete picture-puzzle game*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现完整的拼图游戏*'
- en: Page-based user interface
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于页面的用户界面
- en: In the previous chapter, we developed a game that contained a single page. Most
    of the modern mobile games, however, contain sophisticated user interfaces backed
    by complex business logic. A typical user interface consists of several full-screen
    pages with multiple UI elements, such as buttons, images and, input boxes. These
    are rendered using the in-game rendering system, and do not depend on the user
    interface of the underlying operating system. In this recipe, we show you how
    to approach this problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了一个只包含单个页面的游戏。然而，大多数现代移动游戏都包含由复杂业务逻辑支持的复杂用户界面。典型的用户界面包括几个全屏页面和多个UI元素，如按钮、图像和输入框。这些使用游戏内渲染系统进行渲染，并不依赖于底层操作系统的用户界面。在本示例中，我们将展示如何解决这个问题。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You might want to find out what open source C++ multiplatform UI libraries
    exist out there. The following link will help you: [http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要了解目前存在的开源C++跨平台UI库。以下链接将帮助你：[http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries)。
- en: We would also like to recommend looking at **libRocket** if you want to go for
    a full-scale HTML/CSS user interface for your game ([http://librocket.com](http://librocket.com)).
    Its integration is straightforward, but lies outside of the scope of this book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为游戏提供完整的HTML/CSS用户界面，我们建议你看看**libRocket** ([http://librocket.com](http://librocket.com))。它的集成过程简单直接，但超出了本书的讨论范围。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'A single page handles all the key, touch, timer, and rendering events:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个页面处理所有按键、触摸、定时器和渲染事件：
- en: '[PRE52]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Handle basic UI interaction events:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理基本的UI交互事件：
- en: '[PRE53]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The page we return to when the **BACK** or **ESC** button is tapped on:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击**BACK**或**ESC**按钮时返回的页面：
- en: '[PRE54]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'All the UI pages are managed by the `clGUI` class, which mostly delegates all
    events to the currently selected page:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有UI页面都由`clGUI`类管理，该类将所有事件委托给当前选中的页面：
- en: '[PRE55]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The page itself serves as a container for the `clGUIButton` objects:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面本身作为`clGUIButton`对象的容器：
- en: '[PRE56]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The most important thing here is that `clGUIButton` can detect whether a touch
    point is contained inside the button:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里最重要的一点是`clGUIButton`可以检测触摸点是否包含在按钮内部：
- en: '[PRE57]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: These two classes are enough to build a minimalistic interactive user interface
    for our game.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类足以构建我们游戏的简约交互式用户界面。
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'While setting up the user interface, we construct pages and add them to the
    global `g_GUI` object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置用户界面时，我们构建页面并将它们添加到全局`g_GUI`对象：
- en: '[PRE58]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When the **BACK** button is tapped upon, the pages backflow looks as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**BACK**按钮时，页面回流如下所示：
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We set up references to the back-navigation target pages accordingly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相应地设置返回导航目标页面的引用：
- en: '[PRE60]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The main menu page also contains some useful buttons, which will help the player
    to navigate between different pages:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单页面还包含一些有用的按钮，可以帮助玩家在页面间导航：
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The application starts at the main menu page:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序从主菜单页面开始：
- en: '[PRE62]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The implementations of individual pages are quite straightforward. `clPage_About`
    contains some information, and we only override the `Render()` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 单个页面的实现非常直接。`clPage_About`包含一些信息，我们只覆盖了`Render()`方法：
- en: '[PRE63]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The main menu page contains three buttons—one to exit the application, another
    to start the game, and a button to enter the about page:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单页面包含三个按钮——一个用于退出应用程序，另一个用于开始游戏，还有一个用于进入关于页面：
- en: '[PRE64]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `OnKey()` method also handles the **BACK** and **ESC** buttons. We use
    a single check, since our abstraction layer converts both the keys into a single
    `LK_ESCAPE` code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnKey()`方法还处理**BACK**和**ESC**按钮。由于我们的抽象层将这两个键转换成了单一的`LK_ESCAPE`代码，所以我们使用单个检查：'
- en: '[PRE65]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The game page redirects rendering, touch handling, and timing events to the
    global `g_Game` object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏页面将渲染、触摸处理和计时事件重定向到全局`g_Game`对象：
- en: '[PRE66]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: As an exercise, more UI controls can be added to this minimalistic framework.
    It is easy to add static text labels and images. More complex UI controls, such
    as input boxes, can be implemented too, but will require much more effort. If
    you want to build a complex UI for your game, we recommend using one of the open
    source C++ UI libraries at [http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，可以在这个简约框架中添加更多UI控件。添加静态文本标签和图片很容易。更复杂的UI控件，如输入框，也可以实现，但需要更多努力。如果你想要为你的游戏构建复杂的UI，我们建议使用[http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries)上的开源C++
    UI库之一。
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Implementing the animated 3D image selector*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现动画3D图片选择器*'
- en: Image gallery with Picasa downloader
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Picasa下载器的图片库
- en: In this recipe, we will integrate our Picasa images downloader with a carousel-based
    3D gallery, and use it as a picture selection page in our game.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将把Picasa图片下载器与基于旋转木马的3D图库集成，并在我们的游戏中将其用作图片选择页面。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To download the images and track the state of the downloader, we use the `sImageDescriptor`
    structure describing the state of any game image:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了下载图片并跟踪下载器的状态，我们使用描述任何游戏图片状态的`sImageDescriptor`结构：
- en: '[PRE67]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now comes the image size code. We support a single image type only: small 256
    pixel-wide previews. Multi-stage previews can be implemented when the game first
    loads very small images over the network, let''s say not larger than 128 pixels.
    Then larger 256 pixel previews replace them to give crisp previews on Full HD
    screens. And after the player has picked an image from the gallery, a full-sized
    preview is fetched from the server.'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在是图片大小代码部分。我们仅支持一种图片类型：宽度为256像素的小预览图。游戏初次加载时可以通过网络加载非常小的图片，比如说不超过128像素，然后更大的256像素预览图替换它们，以便在Full
    HD屏幕上提供清晰的预览。当玩家从图库中选择了一张图片后，会从服务器获取全尺寸的预览图。
- en: 'The previously described method is exactly how we do it in our Linderdaum Puzzle
    HD game:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前描述的方法正是我们在Linderdaum Puzzle HD游戏中采用的方法：
- en: '[PRE68]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We set the current state of this image to `L_NOTSTARTED` initially:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最初将此图片的当前状态设置为`L_NOTSTARTED`：
- en: '[PRE69]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The image state can be one of the following:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片状态可以是以下之一：
- en: '[PRE70]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'After the download has completed, we asynchronously load the image from the
    data blob using the `FreeImage` library:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，我们使用`FreeImage`库从数据块中异步加载图片：
- en: '[PRE71]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Asynchronous loading is important, since the image decoding can be quite slow,
    and can interfere with the user experience of the game. After an image has been
    loaded and converted into a `clBitmap`, we should update the texture. Texture
    updates are done synchronously on the OpenGL rendering thread:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步加载很重要，因为图像解码可能相当慢，可能会干扰游戏用户体验。图像加载并转换为 `clBitmap` 后，我们应该更新纹理。纹理更新是在OpenGL渲染线程上同步完成的：
- en: '[PRE72]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s go a level above and see how images are fetched from the server. The
    image collection is retrieved from a website and stored in the `clGallery` object:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们上升一个层次，看看如何从服务器获取图像。图像集合是从网站检索并存储在 `clGallery` 对象中的：
- en: '[PRE73]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Return the full-size image URL:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回全尺寸图像的URL：
- en: '[PRE74]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Restart the downloading of all images that are not loaded:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新开始下载所有未加载的图像：
- en: '[PRE75]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We store the base URLs of all images, and the images themselves:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们存储所有图像的基础URL以及图像本身：
- en: '[PRE76]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To decode an image list, we use the Picasa downloader code from [Chapter 3](ch03.html
    "Chapter 3. Networking"), *Networking*:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解码图像列表，我们使用来自 [第3章](ch03.html "第3章. 网络通信")，*网络通信* 的Picasa下载器代码：
- en: '[PRE77]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Parse the data blob corresponding to the XML image list that has been loaded
    from Picasa:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析从Picasa加载的XML图像列表对应的数据块：
- en: '[PRE78]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Update the descriptors and start downloading the images:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新描述符并开始下载图像：
- en: '[PRE79]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Once the image loading is complete, the task dispatches a `clBitmap::Load2DImage()`
    call to the main thread, so that the OpenGL texture can be updated:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图像加载完成后，该任务会向主线程分派一个 `clBitmap::Load2DImage()` 调用，以便更新OpenGL纹理：
- en: '[PRE80]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The complete source code can be found in the `5_Puzzle` project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在 `5_Puzzle` 项目中找到。
- en: How it works…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The downloading is performed in the global `g_Downloader` object, and the actual
    decoding of the downloaded data is done using the `FreeImage` library.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下载是在全局 `g_Downloader` 对象中完成的，下载数据的实际解码是使用 `FreeImage` 库完成的。
- en: See also
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 网络通信")，*网络通信*'
- en: Implementing the complete picture-puzzle game
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现完整的图片拼图游戏
- en: Finally, we have all the parts at hand, and can combine them together into a
    puzzle game application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们手中有了所有部件，可以将它们组合成一个拼图游戏应用程序。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: Build and run the example `5_Puzzle` from the supplementary materials. This
    example, like others in this book, runs on Android as well as on Windows.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行补充材料中的示例 `5_Puzzle`。这个例子与本书中的其他例子一样，可以在Android和Windows上运行。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We start by augmenting our `3_UIPrototype` project with a new page, `clPage_Gallery`.
    This page delegates rendering and updating to the global `g_Flow` object:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过向 `3_UIPrototype` 项目添加一个新页面 `clPage_Gallery` 来开始。这个页面将渲染和更新委托给全局 `g_Flow`
    对象：
- en: '[PRE81]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `RenderDirect()` method is essentially a slightly modified version of `RenderDirect()`
    from the *Implementing the animated 3D image selector* recipe in this chapter.
    There are only two differences—we replace wireframe quad rendering with the `clCanvas::Rect3D()`
    call (to render a textured 3D rectangle) and use textures from the `g_Gallery`
    object, described recently in this chapter in the *Image gallery with Picasa downloader*
    recipe:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RenderDirect()` 方法实际上是对本章中 *实现动画3D图像选择器* 的 `RenderDirect()` 方法的轻微修改版本。只有两个区别——我们用
    `clCanvas::Rect3D()` 调用（渲染一个带纹理的3D矩形）替换了线框四边形渲染，并使用本章最近描述的 `g_Gallery` 对象中的纹理：'
- en: '[PRE82]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The rendering order is left to right, to prevent incorrect overlapping of images:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染顺序是从左到右，以防止图像重叠错误：
- en: '[PRE83]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Render seven textured 3D rectangles according to the predefined order. We use
    a placeholder texture `g_Texture` if no image is available:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据预定义的顺序渲染七个带纹理的3D矩形。如果没有图像可用，我们使用占位符纹理 `g_Texture`：
- en: '[PRE84]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Once we have a user interface separated into pages, we can delegate all the
    rendering, updates, and input to our `g_GUI` object. Engine callbacks are implemented
    trivially:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将用户界面分成多个页面，就可以将所有渲染、更新和输入委托给我们的 `g_GUI` 对象。引擎回调实现起来非常简单：
- en: '[PRE85]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'On timer update, we should process events posted by other threads:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定时器更新时，我们应该处理其他线程发布的事件：
- en: '[PRE86]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Tap handling is a bit more complicated, since we have to additionally store
    the in-gallery flag. For the sake of simplicity, we have implemented it as the
    global variable `g_InGallery`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击处理要复杂一些，因为我们还需要额外存储图库标志。为了简单起见，我们将其实现为全局变量 `g_InGallery`：
- en: '[PRE87]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Callbacks `OnMouseMove()` and `OnMouseUp()` are similar, and can be found in
    the `5_Puzzle/main.cpp` file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回调`OnMouseMove()`和`OnMouseUp()`类似，可以在`5_Puzzle/main.cpp`文件中找到。
- en: How it works…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s have a brief glimpse of the game. The main menu looks as the following
    screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一眼这个游戏。主菜单看起来如下面的截图所示：
- en: '![How it works…](img/7785_09_2.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/7785_09_2.jpg)'
- en: 'Tapping on **New Game** shows the 3D carousel with images fetched from Picasa,
    as shown in the following screenshot:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**新游戏**会显示从Picasa获取的3D旋转木马图像，如下面的截图所示：
- en: '![How it works…](img/7785_09_3.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/7785_09_3.jpg)'
- en: 'Scroll to the left or right to pick a desired image. Tap on it. The game field
    opens with shuffled tiles of the photo, as shown in the following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 向左或向右滚动以选择所需的图片。点击它。游戏场地会以打乱的照片瓦片打开，如下面的截图所示：
- en: '![How it works…](img/7785_09_4.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/7785_09_4.jpg)'
- en: Move the tiles around to restore the original image.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 移动瓦片以恢复原始图像。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following are some nice features left behind, which add much to the puzzle''s
    usability, and which you can implement as an exercise:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些不错的特点，增加了拼图的可用性，你可以作为练习来实现：
- en: Implement different tile grids. 4 x 4 is easy to play. 8 x 14 is quite challenging.
    Even larger grids look good on 10 inch tablets.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不同的瓦片网格。4 x 4的比较容易玩。8 x 14的相当有挑战性。即使是更大的网格在10英寸的平板上也很好看。
- en: Stitch the correctly assembled tiles together, and move them as a single block.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正确组装的瓦片缝合在一起，并将它们作为一个整体移动。
- en: You can use a flood-fill algorithm to find the adjacent tiles.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用洪泛填充算法来查找相邻的瓦片。
- en: Save the game state, so the player can continue the game where they left off.
    It is also a good idea to save the game when an incoming phone call occurs. You
    can do it in the `OnStop()` callback.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存游戏状态，这样玩家就可以从上次离开的地方继续游戏。当有来电时保存游戏也是一个好主意。你可以在`OnStop()`回调中实现这一点。
- en: Multi-stage previews—load small low-resolution previews in the 3D carousel.
    Once the coarse previews are loaded, fetch higher-resolution preview images. And
    once the player taps on the image he wants to play with, download the high resolution
    image. This will make the game look crisp on a Full HD tablet device.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多阶段预览——在3D旋转木马里加载小尺寸的低分辨率预览。一旦粗略预览加载完毕，获取更高分辨率的预览图像。当玩家点击他想玩的游戏图像时，下载高分辨率图像。这将使游戏在Full
    HD平板设备上看起来更加清晰。
- en: Implement different galleries. You can start with Flickr, as described in the
    recipe *Fetching list of photos from Flickr and Picasa* in [Chapter 3](ch03.html
    "Chapter 3. Networking"), *Networking*.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不同的图库。你可以从Flickr开始，如[第3章](ch03.html "第3章 网络通信")中的菜谱*从Flickr和Picasa获取照片列表*所述，*网络通信*。
- en: See also
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章 网络通信")，*网络通信*'
- en: '[Chapter 4](ch04.html "Chapter 4. Organizing a Virtual Filesystem"), *Organizing
    a Virtual Filesystem*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 组织虚拟文件系统")，*组织虚拟文件系统*'
- en: '[Chapter 5](ch05.html "Chapter 5. Cross-platform Audio Streaming"), *Cross-platform
    Audio Streaming*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章 跨平台音频流媒体")，*跨平台音频流媒体*'
- en: '[Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"), *Unifying
    OpenGL ES 3 and OpenGL 3*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 统一OpenGL ES 3和OpenGL 3")，*统一OpenGL ES 3和OpenGL 3*'
