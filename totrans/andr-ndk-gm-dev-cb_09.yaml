- en: Chapter 9. Writing a Picture Puzzle Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing picture puzzle game logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the animated 3D image selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page-based user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image gallery with Picasa downloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the complete picture-puzzle game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continue putting together recipes from the previous chapters.
    We will implement a picture-puzzle game, where a player needs to put the puzzle
    pieces together in order to recreate the original image. Images are streamed from
    the featured gallery of the Picasa photo hosting, and can be picked via a 3D animated
    image selector. Our game has a simple page-based user interface that can serve
    as a starting point to a more complex game UI framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The example project of this chapter is actually a much simplified version of
    the Linderdaum Puzzle HD game published by the authors on Google Play: [http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD](http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing picture puzzle game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe you shows how to implement the game logic for a picture puzzle game.
    The game consists of a set of rectangular tiles shuffled and rendered on the screen.
    Users can tap on individual tiles, and move them around, swapping them with the
    other tiles. Let us draft the backbone data structures to implement this logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To feel the game logic better, you can build and run the `2_PuzzleProto` project,
    which can be downloaded from [www.packtpub.com/support](http://www.packtpub.com/support).
    If you want to enjoy the full-featured game, just go ahead and download our Linderdaum
    Puzzle HD from Google Play. You can do it at [http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD](http://play.google.com/store/apps/details?id=com.linderdaum.engine.puzzLHD).
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/7785_09_qr1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need the `clTile` class to store the state of an individual puzzle
    piece. It contains the current coordinates of the tile''s upper-left corner, the
    original indices of the tile in the grid, and the target coordinates where this
    tile will move to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second constructor calculates and sets the `FRect` field, which contains
    the texture coordinates used later for the rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the texture coordinates of the tile and store them in `FRect`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next two methods set the target and current coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tile moves to the target coordinates smoothly. We update the tile position
    using the time counter, and for each time step, the coordinates are recalculated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The state of the game is presented by an array of tiles, which is stored in
    the `clPuzzle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Swap the two tiles specified by their `(i,j)` 2D coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The game is complete if all the tiles are in their places. To check if the
    tile is in place, we need to compare its `FOriginX` and `FOriginY` coordinates
    to its current `i` and `j` coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`clPuzzle::Timer()` calls the `Update()` method, which calculates new coordinates
    for each of the tiles. This is required to allow the tiles to return to their
    position once the player releases touches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The initial state of the game is generated in the `Retoss()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we create all the tiles at their initial positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use Knuth shuffle, also known as Fisher–Yates shuffle ([http://en.wikipedia.org/wiki/Fisher–Yates_shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle))
    to generate a random permutation of the tiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The handling of user input is performed in the `OnKey()` method. When the user
    presses the mouse button or taps on the screen, this method is called with the
    `KeyState` argument equal to true. On the mouse release or at the end of the tap,
    the `OnKey()` method is called with `KeyState` set to false. The `mx` and `my`
    parameters contain the 2D coordinates of the touch. Once the touch is active,
    we store the indices of the tile and the initial offset of the touch point respective
    to the upper-left corner of the tile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the touch ends, we check the validity of the new tile position and exchange
    the selected tile with the tile in the new position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `2_PuzzleProto` example uses the `clPuzzle` class to show the gameplay without
    any textures or any fancy graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the state of the puzzle, the following routine is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have selected the tile, we move it to the new mouse or touch position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, each tile is rendered with the `DrawTile()` method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DrawTile()` method calculates the coordinates of the tile in normalized
    screen coordinates `(0...1)` and uses a rectangular vertex array and the `g_Canvas`
    object to render the `Tile` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the next recipes, we combine this simple gameplay with an animated image
    selector and the Picasa images downloader to create a more feature-rich puzzle
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the animated 3D image selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main UI element of our puzzle game is the animated 3D image selector. In
    this recipe, we show you how to render the animated carousel-like selector and
    interact with the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before proceeding with this recipe, you may need to go back to [Chapter 7](ch07.html
    "Chapter 7. Cross-platform UI and Input Systems"), *Cross-platform UI and Input
    System*, and read how the `Canvas` class works. A bit of mathematics will be required
    to understand better how the code in this recipe works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind the rendering is quite simple. We let the individual quads
    move in a way that their corners slide along four guiding curves. The following
    figure shows the same quad in a series of positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7785_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The four curves show the paths of the quad's corners.
  prefs: []
  type: TYPE_NORMAL
- en: We start with the helper `Curve` class, which implements the linear interpolation
    on the set of control points. A curve is represented in a parametric form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A parametric equation of a curve is a representation of this curve through
    equations expressing the coordinates of the points of the curve as functions of
    a variable called a parameter.*'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Courtesy: [http://en.wikipedia.org/wiki/Parametric_equation](http://en.wikipedia.org/wiki/Parametric_equation)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `AddControlPoint()` method adds a new control point to the curve. The curve
    is lazy-evaluated, and now we just store the specified values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `GetPosition()` method finds a segment for the given parameter `t` and
    calculates a linearly interpolated coordinate of a point on the curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The control points and corresponding arguments are stored in two vectors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A 3D image selector control logic is implemented in the `clFlowUI` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a 3D camera for our UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A standard perspective camera is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arctangent is multiplied `by exp(-x^2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the UI scrolling limits using the current number of elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the index of the currently selected index image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Coordinates for individual quad are calculated in the `QuadCoords()` method,
    which invokes `Curve::GetPosition()` for each of the four guiding curves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the trajectory control points for each base curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are the parameters for the guiding curves. The number of screen
    units (in normalized coordinates) between the sequential control points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The empirical tweaking parameter for the quad points, speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The height of the image, which means the distance between the lower and upper
    curves, thickness, and slope of the curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The symmetric displacement of curve peaks, exponential falloff, and main coefficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `clFlowFlinger` class holds the dynamic state of the selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decide what to do on the selection—return `true` if the selection is complete,
    or `false` otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the animation and handle touches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Touch handling is performed in the `OnTouch()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the touch point has moved less than 1 percent of the screen, or the gesture
    has taken less than 10 milliseconds we consider it being a tap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, if the gesture spans less than 300 milliseconds, we stop the motion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The coefficients for positions and timings were chosen empirically based on
    the perception of the motion. The dynamics are implemented in the `Update()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we reach the last image, we just clamp the position on the guiding curves.
    For a smooth experience, we also add a **rubber band** effect, by interpolating
    the position using the linear formulas. The `Damper` coefficient is purely empiric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A nice set of parameters for comfortable scrolling is defined in the `FlowFlinger.h`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are encouraged to try your own values.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The carousel rendering is based on `Canvas` and implemented in the `RenderDirect()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We manually specify the quad rendering order. First we render the left-hand
    side images, then the images on the right-hand side, and finally the central image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Actual rendering of checks for array boundaries, and application of the `Projection`
    and `View` matrices to each corner of the quad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The final rendering is done using the `BoxR()` function, which is implemented
    in the `main.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A modification to the carousel code is needed to support selection. We add
    the `GeomUtil.h` file with a few methods of intersection testing. Similar, to
    the `RenderFlow()` procedure, we iterate over visible images, and for each of
    those, we intersect the ray from the tap location through the image plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Map the 2D screen touch point to a 3D point and a ray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over the current image quads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the quad coordinates into the world space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Intersect the ray with two triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `Unproject()` and `MouseCoordsToWorldPointAndRay()` functions convert 2D
    screen point coordinates into a ray in the 3D world space, where our carousel
    quads fly. Their implementations can be found in the `GeomUtil.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rewind the selector to some specific image we set a target position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we used 3D lines to render the carousel. It is really simple
    to use the `Canvas` class to render each quad with a texture. We also encourage
    the reader to add a reflection effect, which is easily done by rendering the same
    set of quads with an additional transform representing the reflection from a horizontal
    plane.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing the complete picture-puzzle game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page-based user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we developed a game that contained a single page. Most
    of the modern mobile games, however, contain sophisticated user interfaces backed
    by complex business logic. A typical user interface consists of several full-screen
    pages with multiple UI elements, such as buttons, images and, input boxes. These
    are rendered using the in-game rendering system, and do not depend on the user
    interface of the underlying operating system. In this recipe, we show you how
    to approach this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might want to find out what open source C++ multiplatform UI libraries
    exist out there. The following link will help you: [http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries).'
  prefs: []
  type: TYPE_NORMAL
- en: We would also like to recommend looking at **libRocket** if you want to go for
    a full-scale HTML/CSS user interface for your game ([http://librocket.com](http://librocket.com)).
    Its integration is straightforward, but lies outside of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A single page handles all the key, touch, timer, and rendering events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Handle basic UI interaction events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The page we return to when the **BACK** or **ESC** button is tapped on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the UI pages are managed by the `clGUI` class, which mostly delegates all
    events to the currently selected page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The page itself serves as a container for the `clGUIButton` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The most important thing here is that `clGUIButton` can detect whether a touch
    point is contained inside the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two classes are enough to build a minimalistic interactive user interface
    for our game.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While setting up the user interface, we construct pages and add them to the
    global `g_GUI` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When the **BACK** button is tapped upon, the pages backflow looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up references to the back-navigation target pages accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The main menu page also contains some useful buttons, which will help the player
    to navigate between different pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The application starts at the main menu page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementations of individual pages are quite straightforward. `clPage_About`
    contains some information, and we only override the `Render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The main menu page contains three buttons—one to exit the application, another
    to start the game, and a button to enter the about page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnKey()` method also handles the **BACK** and **ESC** buttons. We use
    a single check, since our abstraction layer converts both the keys into a single
    `LK_ESCAPE` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The game page redirects rendering, touch handling, and timing events to the
    global `g_Game` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an exercise, more UI controls can be added to this minimalistic framework.
    It is easy to add static text labels and images. More complex UI controls, such
    as input boxes, can be implemented too, but will require much more effort. If
    you want to build a complex UI for your game, we recommend using one of the open
    source C++ UI libraries at [http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries](http://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing the animated 3D image selector*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image gallery with Picasa downloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will integrate our Picasa images downloader with a carousel-based
    3D gallery, and use it as a picture selection page in our game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To download the images and track the state of the downloader, we use the `sImageDescriptor`
    structure describing the state of any game image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now comes the image size code. We support a single image type only: small 256
    pixel-wide previews. Multi-stage previews can be implemented when the game first
    loads very small images over the network, let''s say not larger than 128 pixels.
    Then larger 256 pixel previews replace them to give crisp previews on Full HD
    screens. And after the player has picked an image from the gallery, a full-sized
    preview is fetched from the server.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The previously described method is exactly how we do it in our Linderdaum Puzzle
    HD game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set the current state of this image to `L_NOTSTARTED` initially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The image state can be one of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the download has completed, we asynchronously load the image from the
    data blob using the `FreeImage` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Asynchronous loading is important, since the image decoding can be quite slow,
    and can interfere with the user experience of the game. After an image has been
    loaded and converted into a `clBitmap`, we should update the texture. Texture
    updates are done synchronously on the OpenGL rendering thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go a level above and see how images are fetched from the server. The
    image collection is retrieved from a website and stored in the `clGallery` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the full-size image URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the downloading of all images that are not loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We store the base URLs of all images, and the images themselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To decode an image list, we use the Picasa downloader code from [Chapter 3](ch03.html
    "Chapter 3. Networking"), *Networking*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse the data blob corresponding to the XML image list that has been loaded
    from Picasa:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the descriptors and start downloading the images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the image loading is complete, the task dispatches a `clBitmap::Load2DImage()`
    call to the main thread, so that the OpenGL texture can be updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete source code can be found in the `5_Puzzle` project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The downloading is performed in the global `g_Downloader` object, and the actual
    decoding of the downloaded data is done using the `FreeImage` library.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the complete picture-puzzle game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have all the parts at hand, and can combine them together into a
    puzzle game application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Build and run the example `5_Puzzle` from the supplementary materials. This
    example, like others in this book, runs on Android as well as on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by augmenting our `3_UIPrototype` project with a new page, `clPage_Gallery`.
    This page delegates rendering and updating to the global `g_Flow` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `RenderDirect()` method is essentially a slightly modified version of `RenderDirect()`
    from the *Implementing the animated 3D image selector* recipe in this chapter.
    There are only two differences—we replace wireframe quad rendering with the `clCanvas::Rect3D()`
    call (to render a textured 3D rectangle) and use textures from the `g_Gallery`
    object, described recently in this chapter in the *Image gallery with Picasa downloader*
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rendering order is left to right, to prevent incorrect overlapping of images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render seven textured 3D rectangles according to the predefined order. We use
    a placeholder texture `g_Texture` if no image is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have a user interface separated into pages, we can delegate all the
    rendering, updates, and input to our `g_GUI` object. Engine callbacks are implemented
    trivially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On timer update, we should process events posted by other threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tap handling is a bit more complicated, since we have to additionally store
    the in-gallery flag. For the sake of simplicity, we have implemented it as the
    global variable `g_InGallery`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Callbacks `OnMouseMove()` and `OnMouseUp()` are similar, and can be found in
    the `5_Puzzle/main.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a brief glimpse of the game. The main menu looks as the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/7785_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Tapping on **New Game** shows the 3D carousel with images fetched from Picasa,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/7785_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Scroll to the left or right to pick a desired image. Tap on it. The game field
    opens with shuffled tiles of the photo, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/7785_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Move the tiles around to restore the original image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some nice features left behind, which add much to the puzzle''s
    usability, and which you can implement as an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement different tile grids. 4 x 4 is easy to play. 8 x 14 is quite challenging.
    Even larger grids look good on 10 inch tablets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stitch the correctly assembled tiles together, and move them as a single block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a flood-fill algorithm to find the adjacent tiles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the game state, so the player can continue the game where they left off.
    It is also a good idea to save the game when an incoming phone call occurs. You
    can do it in the `OnStop()` callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-stage previews—load small low-resolution previews in the 3D carousel.
    Once the coarse previews are loaded, fetch higher-resolution preview images. And
    once the player taps on the image he wants to play with, download the high resolution
    image. This will make the game look crisp on a Full HD tablet device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement different galleries. You can start with Flickr, as described in the
    recipe *Fetching list of photos from Flickr and Picasa* in [Chapter 3](ch03.html
    "Chapter 3. Networking"), *Networking*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Organizing a Virtual Filesystem"), *Organizing
    a Virtual Filesystem*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Cross-platform Audio Streaming"), *Cross-platform
    Audio Streaming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"), *Unifying
    OpenGL ES 3 and OpenGL 3*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
