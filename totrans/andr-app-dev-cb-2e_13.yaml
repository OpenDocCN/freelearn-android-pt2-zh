- en: Chapter 13. Getting Location and Using Geofencing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章. 获取位置和使用地理围栏
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to get the last location
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取最后一次位置
- en: Resolving problems reported with the GoogleApiClient OnConnectionFailedListener
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决使用GoogleApiClient OnConnectionFailedListener报告的问题
- en: How to receive location updates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何接收位置更新
- en: Create and monitor a Geofence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并监控地理围栏
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Location awareness offers many benefits to an app, so many in fact that even
    desktop apps now attempt to get the user's location. Location uses ranges from
    turn-by-turn directions, "find the nearest" applications, alerts based on location,
    and there are now even location-based games that get you out exploring with your
    device.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 位置感知为应用带来了许多好处，实际上，好处如此之多，以至于现在连桌面应用也尝试获取用户的位置信息。位置信息的用途包括逐向导航、"查找最近"的应用程序、基于位置的提醒，以及现在甚至有了让你用设备去探索的基于位置的游戏。
- en: The Google APIs offer many rich features for creating location-aware applications
    and mapping features. Our first recipe *How to get the last location* will look
    at obtaining the last known location as stored on the device. If your app is not
    location intensive, this may provide an ideal way to get the user's location without
    a large resource overhead. If you need constant updates, then turn to the *How
    to receive location updates* recipe. Though constant location updates requires
    more resources, users are likely to understand when you're giving them turn-by-turn
    directions. If you are requesting location updates for a proximity location, take
    a look at using the Geofence option instead, in the *Create and monitor a Geofence*
    recipe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Google API提供了丰富的功能，用于创建具有位置感知的应用程序和地图功能。我们的第一个方法*如何获取最后一次位置*将查看设备上存储的最后一次已知位置。如果你的应用不是位置密集型的，这可能提供了一种获取用户位置而不需要大量资源开销的理想方式。如果你需要持续更新，那么请转向*如何接收位置更新*的方法。尽管持续的位置更新需要更多资源，但用户可能会理解你为他们提供逐向导航时的情况。如果你请求位置更新是为了邻近位置，请查看使用地理围栏选项，在*创建和监控地理围栏*的方法中。
- en: All the recipes in this chapter use the Google Libraries. If you have not already
    downloaded the SDK Packages, follow the instructions from Google.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有方法都使用Google库。如果你还没有下载SDK包，请按照Google的说明操作。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Add SDK Packages from [http://developer.android.com/sdk/installing/adding-packages.html](http://developer.android.com/sdk/installing/adding-packages.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://developer.android.com/sdk/installing/adding-packages.html](http://developer.android.com/sdk/installing/adding-packages.html)添加SDK包。
- en: 'Now that you have the location, there''s a good chance you''ll want to map
    it as well. This is another area where Google makes this very easy on Android
    using the Google Maps API. To get started with Google Maps, take a look at the
    **Google Maps Activity** option when creating a new project in Android Studio.
    Instead of selecting **Blank Activity**, as we normally do for these recipes,
    choose **Google Maps Activity**, as shown in this screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经获得了位置信息，你很可能会想要将其映射出来。这也是Google在Android上使用Google Maps API使操作变得非常简单的另一个领域。要开始使用Google
    Maps，请在Android Studio中创建新项目时查看**Google Maps Activity**选项。与我们在这些方法中通常选择的**空白活动**不同，请选择**Google
    Maps Activity**，如下截图所示：
- en: '![Introduction](img/B05057_13_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B05057_13_1.jpg)'
- en: How to get the last location
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何获取最后一次位置
- en: 'We''ll start this chapter with a simple recipe that is commonly needed: how
    to get the last known location. This is an easy way to use APIs with very little
    overhead resource drain. (This means, your app won''t be responsible for killing
    the battery.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这一章开始介绍一个常用的简单方法：如何获取最后一次已知位置。这是一种使用API而几乎不消耗资源的方法。（这意味着，你的应用不会耗尽电池电量。）
- en: This recipe also provides a good introduction to setting up the Google Location
    APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本方法还提供了设置Google位置API的良好介绍。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `GetLastLocation`. Use
    the default **Phone & Tablet** options, and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为：`GetLastLocation`。使用默认的**手机 & 平板**选项，在选择**活动类型**时，选择**空活动**。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll add the necessary permissions to the Android Manifest, then we''ll
    create a layout with a `Button` and a `TextView` element. Finally, we''ll create
    a `GoogleAPIClient` API to access the last location. Open the Android Manifest
    and follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在Android Manifest中添加必要的权限，然后创建一个带有`Button`和`TextView`元素的布局。最后，我们将创建一个`GoogleAPIClient`
    API来访问最后一次位置。打开Android Manifest并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Under the **Gradle Scripts** section, open the **build.gradle (Module: app)**
    file, as shown in this screenshot:![How to do it...](img/B05057_13_2.jpg)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在**Gradle Scripts**部分下，打开**build.gradle (Module: app)**文件，如下截图所示：![如何操作...](img/B05057_13_2.jpg)'
- en: 'Add the following statement to the `dependencies` section:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dependencies`部分添加以下声明：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with the following
    XML:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，用以下XML替换现有的`TextView`：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件，并添加以下全局变量：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the class for `ConnectionCallbacks`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ConnectionCallbacks`的类：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the class to handle the `OnConnectionFailedListener` callback:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理`OnConnectionFailedListener`回调的类：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following code to the existing `onCreate()` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的`onCreate()`方法中：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the method to set up `GoogleAPIClient`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加设置`GoogleAPIClient`的方法：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following method for the button click:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮点击添加以下方法：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已准备好在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Before we can call the `getLastLocation()` method, we need to set up `GoogleApiClient`.
    We call the `GoogleApiClient.Builder` method in our `setupGoogleApiClient()` method,
    then connect to the library. When the library is ready, it calls our `ConnectionCallbacks.onConnected()`
    method. For demonstration purposes, this is where we enable the button. (We'll
    use this callback in later recipes to start additional features.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`getLastLocation()`方法之前，需要设置`GoogleApiClient`。我们在`setupGoogleApiClient()`方法中调用`GoogleApiClient.Builder`方法，然后连接到库。当库准备就绪时，它会调用我们的`ConnectionCallbacks.onConnected()`方法。出于演示目的，这里是我们启用按钮的地方。（在后续的食谱中，我们将使用此回调启动附加功能。）
- en: We used a button to show we can call `getLastLocation()` on demand; it's not
    a one-time call. The system is responsible for updating the location and may return
    the same last location on repeated calls. (This can be seen in the timestamp—it's
    the location timestamp, not the timestamp when the button is pressed.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了按钮来显示我们可以按需调用`getLastLocation()`；这不是一次性的调用。系统负责更新位置，并在重复调用时可能返回相同的最后位置。（这可以在时间戳中看到——它是位置时间戳，而不是按下按钮时的时间戳。）
- en: This approach of calling the location on demand can be useful in situations
    where you only need the location when something happens in your app (such as geocoding
    an object). Since the system is responsible for the location updates, your app
    will not be responsible for a battery drain from location updates.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种按需调用位置的方法在您只需要在应用程序中发生某些事情时获取位置（例如对对象进行地理编码）的情况下可能很有用。由于系统负责位置更新，因此您的应用程序不会因为位置更新而导致电池耗尽。
- en: 'The accuracy of the location object we receive is based on our permission setting.
    We used `ACCESS_COARSE_LOCATION`, but if we want higher accuracy, we can request
    `ACCESS_FINE_LOCATION` instead, with the following permission:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的位置对象的精确度基于我们的权限设置。我们使用了`ACCESS_COARSE_LOCATION`，但如果我们想要更高的精确度，可以改为请求`ACCESS_FINE_LOCATION`，并使用以下权限：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, to keep the code focused on `GoogleApiClient`, we just wrap the `getLastLocation()`
    with `SecurityException`. In a production application, you should check and request
    the permission as shown in the previous chapter. (See *The new run-time permission
    model*.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使代码专注于`GoogleApiClient`，我们只需用`SecurityException`包装`getLastLocation()`。在生产应用程序中，您应该检查并请求上一章显示的权限。（请参阅*新的运行时权限模型*。）
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If a problem occurs when connecting to the `GoogleApiClient`, the `OnConnectionFailedListener`
    is called. In this example, we display a Toast. The next recipe, *Resolving problems
    reported with the GoogleApiClient OnConnectionFailedListener*, will show a more
    robust way to handle this situation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在连接到`GoogleApiClient`时出现问题，将调用`OnConnectionFailedListener`。在这个例子中，我们显示了一个Toast。下一个食谱，*解决GoogleApiClient
    OnConnectionFailedListener报告的问题*，将展示一种更健壮的方式来处理这种情况。
- en: Testing the location can be a challenge since it's difficult to actually move
    the device when testing and debugging. Fortunately, we have the ability to simulate
    GPS data with the emulator. (It is possible to create mock locations on a physical
    device as well, but it's not as easy.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试位置可能是一个挑战，因为在测试和调试时实际上移动设备是困难的。幸运的是，我们有能力用模拟器模拟GPS数据。（也可以在物理设备上创建模拟位置，但这并不容易。）
- en: Mock locations
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟位置
- en: 'There are three ways to simulate locations with the emulator:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以在模拟器中模拟位置：
- en: Android Studio
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio
- en: DDMS
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDMS
- en: The `Geo` command through Telnet
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Telnet的`Geo`命令
- en: 'To set a mock location in Android Studio, follow these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在Android Studio中设置模拟位置，请按照以下步骤操作：
- en: Navigate to **Tools** | **Android** | **Android Device Monitor**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**工具** | **Android** | **Android Device Monitor**。
- en: Select the **Emulator Control** tab in the device window.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备窗口中选择**Emulator Control**标签页。
- en: Enter GPS coordinates under **Location Controls**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Location Controls**下输入GPS坐标。
- en: 'Here''s a screenshot showing the **Location** **Controls**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示**Location** **Controls**的截图：
- en: '![Mock locations](img/B05057_13_3.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![模拟位置](img/B05057_13_3.jpg)'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Not that simulating the location works by sending GPS data. Therefore, for your
    app to receive the mock location, it will need to be receiving GPS data. Testing
    `lastLocation()` may not send the mock GPS data since it doesn't rely solely on
    the GPS for determining the device location. Try the mock location with the recipe
    *How to receive Location Updates* where we can request the priority. (We can't
    force the system to use any specific location sensor, we can only make a request.
    The system will choose the optimum solution to deliver the results.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模拟位置是通过发送GPS数据来实现的。因此，为了让你的应用接收模拟位置，它需要接收GPS数据。测试`lastLocation()`可能不会发送模拟GPS数据，因为它并不完全依赖GPS来确定设备位置。尝试使用教程*如何接收位置更新*设置模拟位置，在那里我们可以请求优先级。（我们无法强制系统使用任何特定的位置传感器，我们只能提出请求。系统会选择最佳方案来提供结果。）
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *The new Android 6.0 run-time permission model* recipe in [Chapter 14](ch14.html
    "Chapter 14. Getting your app ready for the Play Store"), *Getting Your App Ready
    for the Play Store*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章. 为应用商店准备你的应用")中的*新的Android 6.0运行时权限模型*教程'
- en: 'Setting up Google Play Services: [https://developers.google.com/android/guides/setup](https://developers.google.com/android/guides/setup)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Google Play服务：[https://developers.google.com/android/guides/setup](https://developers.google.com/android/guides/setup)
- en: 'The **FusedLocationProviderApi** interface: [https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FusedLocationProviderApi**接口：[https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi)'
- en: Resolving problems reported with the GoogleApiClient OnConnectionFailedListener
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决使用GoogleApiClient OnConnectionFailedListener报告的问题
- en: With the constantly changing nature of Google APIs, your users are likely to
    attempt to use your application, but not be able to because their files are out
    of date. In the previous example, we just show a Toast, but we can do better.
    We can use the `GoogleApiAvailability` library to display a dialog to help the
    user resolve the problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Google API的不断变化，你的用户可能会尝试使用你的应用程序，但由于文件过时而无法使用。在之前的示例中，我们只是显示了一个Toast，但我们还可以做得更好。我们可以使用`GoogleApiAvailability`库来显示一个对话框，帮助用户解决问题。
- en: We'll continue with the previous recipe and add code to the `onConnectionFailed()`
    callback. We'll use the error result to display additional information to the
    user to resolve their problem.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续之前的教程，并在`onConnectionFailed()`回调中添加代码。我们将使用错误结果向用户显示更多信息，以解决他们的问题。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will continue from the previous recipe, *How to get the last location*.
    If you are loading the project from the downloaded source files, it is called
    `HandleGoogleAPIError`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将从之前的教程*如何获取最后的位置*继续。如果你是从下载的源文件中加载项目，它被称为`HandleGoogleAPIError`。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are continuing from the previous recipe, we''ll only cover the steps
    necessary to update the previous code. Open `ActivityMain.java` and follow these
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从上一个教程继续，我们只涵盖更新之前代码所需的步骤。打开`ActivityMain.java`并按照以下步骤操作：
- en: 'Add the following lines to the global class variables:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局类变量中添加以下行：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following method to show the Google API error dialog:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以显示Google API错误对话框：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following code to override `onActivityResult()`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以覆盖`onActivityResult()`：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `onConnectionFailed()`, replace the existing line of code calling Toast,
    using the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onConnectionFailed()`中，使用以下代码替换调用Toast的现有行：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Instead of displaying the error message with a Toast as we did before, we now
    check `connectionResult` to see what we can do. The `GoogleAPIClient` uses the
    `connectionResult` to indicate possible courses of action. We can call the `hasResolution()`
    method, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用 Toast 显示错误消息不同，我们现在检查 `connectionResult` 以了解我们能做什么。`GoogleAPIClient` 使用
    `connectionResult` 指示可能的行动方案。我们可以按如下方式调用 `hasResolution()` 方法：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the response is `true`, then it's something the user can resolve, such as
    enabling the location service. If the response is `false`, we get an instance
    of the `GoogleApiAvailability` and call the `getErrorDialog()` method. When finished,
    our `onActivityResult()` callback is called, where we reset `mResolvingError`
    and, if successful, attempt to reconnect.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应为 `true`，则用户可以解决，例如启用位置服务。如果响应为 `false`，我们将获取 `GoogleApiAvailability` 的实例并调用
    `getErrorDialog()` 方法。完成后，我们的 `onActivityResult()` 回调将被调用，在那里我们重置 `mResolvingError`，如果成功，尝试重新连接。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you do not have a device with an older Google API for testing, you can try
    testing on an emulator with an older Google API version.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有带有旧版 Google API 的设备进行测试，你可以尝试在带有旧版 Google API 版本的模拟器上进行测试。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'If your application is using fragments, you can get a dialog fragment instead,
    using this code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用正在使用片段，你可以使用以下代码获取一个对话框片段：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Accessing Google APIs: [https://developers.google.com/android/guides/api-client](https://developers.google.com/android/guides/api-client)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Google API：[https://developers.google.com/android/guides/api-client](https://developers.google.com/android/guides/api-client)
- en: How to receive location updates
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何接收位置更新
- en: If your application needs frequent location updates, your application can request
    periodic updates. This recipe will demonstrate this using the `requestLocationUpdates()`
    method from `GoogleApiClient`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用需要频繁的位置更新，你的应用可以请求周期性的更新。本示例将使用 `GoogleApiClient` 的 `requestLocationUpdates()`
    方法来演示这一点。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `LocationUpdates`. Use
    the default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新项目，命名为 `LocationUpdates`。使用默认的 **Phone & Tablet** 选项，并在提示选择
    **Activity Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are receiving updates from the system, we won''t need a button for
    this recipe. Our layout will consist of just the `TextView` to see the location
    data. Open the Android Manifest and follow these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从系统接收更新，因此这个示例不需要按钮。我们的布局将只包含 `TextView` 以查看位置数据。打开 Android 清单文件并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open the file `build.gradle (Module: app)` and add the following statement
    to the `dependencies` section:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开 `build.gradle (Module: app)` 文件，并在 `dependencies` 部分添加以下声明：'
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with the following
    XML:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 文件，并用以下 XML 替换现有的 `TextView`：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 文件，并添加以下全局变量：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the following `LocationListener` class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `LocationListener` 类：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `ConnectionCallbacks` class to receive the location updates:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ConnectionCallbacks` 类以接收位置更新：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an `OnConnectionFailedListener` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `OnConnectionFailedListener` 类：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的 `onCreate()` 回调中添加以下代码：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `setupLocationRequest()` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `setupLocationRequest()` 方法：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以准备在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe is similar to the *How to get the last location* recipe, as we need
    to set up the `GoogleApiClient` as we did before. But, instead of calling the
    `lastLocation()` method on demand, we call the `requestLocationUpdates()` method
    to receive periodic location updates through the `LocationListener` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例与 *如何获取最后位置* 的示例相似，因为我们需要像之前一样设置 `GoogleApiClient`。但是，不是按需调用 `lastLocation()`
    方法，我们调用 `requestLocationUpdates()` 方法，通过 `LocationListener` 类接收周期性的位置更新。
- en: 'The `requestLocationUpdates()` method requires three parameters:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestLocationUpdates()` 方法需要三个参数：'
- en: '`GoogleApiClient`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleApiClient`'
- en: '`LocationRequest`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationRequest`'
- en: '`LocationListener`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocationListener`'
- en: 'We create the `GoogleApiClient` as we did before. This is the code to create
    our `LocationRequest`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样创建 `GoogleApiClient`。这是我们创建 `LocationRequest` 的代码：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When calling `setInterval()`, it's generally best to use the slowest delay that
    works for your purposes, as it requires less device resources. The same idea applies
    when calling `setPriority()`. The third parameter, the `LocationListener`, is
    where we define the callback method `onLocationChanged()`. Here we just display
    the location data along with the location timestamp.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setInterval()`时，通常最好使用对您目的来说最慢的延迟，因为它需要更少的设备资源。调用`setPriority()`时也是同样的道理。第三个参数`LocationListener`是我们定义回调方法`onLocationChanged()`的地方。在这里，我们仅显示位置数据以及位置时间戳。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unlike the previous Android APIs, the `GoogleApiClient` API does not allow the
    selection of specific sensors for the location updates. As mentioned in the *Mock
    Locations* section of *How to get the last Location*, using `LocationRequest.PRIORITY_HIGH_ACCURACY`
    along with the `ACCESS_FINE_LOCATION` permission should use the GPS sensor. Refer
    to the *Mock Locations* section for instructions on simulating your location.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的Android API不同，`GoogleApiClient` API不允许为位置更新选择特定的传感器。如*如何获取最后位置*的*模拟位置*部分所述，使用`LocationRequest.PRIORITY_HIGH_ACCURACY`以及`ACCESS_FINE_LOCATION`权限应该会使用GPS传感器。有关模拟位置的说明，请参考*模拟位置*部分。
- en: Stop receiving location updates
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止接收位置更新
- en: 'When your application no longer needs location updates, call the `removeLocationUpdates()`
    method, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序不再需要位置更新时，请调用`removeLocationUpdates()`方法，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Generally, you would want to disable updates when your application is no longer
    in the foreground, but this depends on your specific application requirements.
    If your application needs constant updates, it may be more desirable to create
    a background service to handle the callbacks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您的应用程序不再处于前台时，您可能希望关闭更新，但这取决于您的具体应用程序需求。如果您的应用程序需要持续更新，可能更希望创建一个后台服务来处理回调。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '**Developer Docs: onLocationChanged** at [https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html](https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：onLocationChanged**在[https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html](https://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html)'
- en: Create and monitor a Geofence
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并监控一个地理围栏
- en: 'If your application needs to know when the user enters a certain location,
    there''s an alternative to having to continuously check the user location: Geofencing.
    A Geofence is a location (latitude and longitude) along with a radius. You can
    create a Geofence and let the system notify you when the user enters the location
    proximity you specified. (Android currently allows up to 100 Geofences per user.)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要知道用户进入某个特定位置的时间，有一种替代方法可以避免不断检查用户位置：地理围栏。地理围栏是一个带有半径的地理位置（纬度和经度）。您可以创建一个地理围栏，当用户进入您指定的位置范围时，系统会通知您。（Android目前允许每个用户最多设置100个地理围栏。）
- en: 'Geofence properties include:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 地理围栏属性包括：
- en: '**Location**: The longitude and latitude'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：经度和纬度'
- en: '**Radius**: The size of the circle (in meters)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：圆的大小（以米为单位）'
- en: '**Loitering delay** : How long the user may remain within the radius before
    sending notifications'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逗留延迟**：用户在发送通知前可以在半径内停留的时间'
- en: '**Expiration**: How long until the Geofence automatically expires'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期时间**：地理围栏自动过期的时长'
- en: '**Transition** **type**: These are listed as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡** **类型**：以下列出了这些类型：'
- en: '`GEOFENCE_TRANSITION_ENTER`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GEOFENCE_TRANSITION_ENTER`'
- en: '`GEOFENCE_TRANSITION_EXIT`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GEOFENCE_TRANSITION_EXIT`'
- en: '`INITIAL_TRIGGER_DWELL`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INITIAL_TRIGGER_DWELL`'
- en: This recipe will show you how to create a Geofence object and use it to create
    an instance of `GeofencingRequest`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将向您展示如何创建一个地理围栏对象，并使用它来创建一个`GeofencingRequest`实例。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Create a new project in Android Studio and call it: `Geofence`. Use the default
    **Phone & Tablet** options and select **Empty Activity** when prompted for **Activity
    Type**.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，命名为`Geofence`。使用默认的**手机 & 平板**选项，在选择**活动类型**时，选择**空活动**。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We won''t need a layout for this recipe as we''ll use Toasts and Notifications
    for the user interaction. We will need to create an additional Java class for
    `IntentService`, which handles the Geofence alerts. Open the Android Manifest
    and follow these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用提示信息和通知与用户互动，因此本指南不需要布局。我们需要为`IntentService`创建一个额外的Java类，用于处理地理围栏警报。打开Android
    Manifest文件，按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE27]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open the file `build.gradle (Module: app)` and add the following statement
    to the `dependencies` section:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开文件`build.gradle (Module: app)`并在`dependencies`部分添加以下声明：'
- en: '[PRE28]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new Java class called `GeofenceIntentService` and extend the `IntentService`
    class. The declaration will look as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GeofenceIntentService`的新Java类并继承`IntentService`类。声明如下所示：
- en: '[PRE29]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following constructor:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下构造函数：
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add `onHandleIntent()` to receive the Geofence alert:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`onHandleIntent()`以接收Geofence警告：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the `sendNotification()` method to display the message to the user:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`sendNotification()`方法以向用户显示消息：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open the Android manifest and add the following within the `<application>`
    element, at the same level as the `<activity>` element:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android清单并在与`<activity>`元素同一级别的`<application>`元素内添加以下内容：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并添加以下全局变量：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the following `ResultCallback` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下`ResultCallback`类：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a `ConnectionCallbacks` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ConnectionCallbacks`类：
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create an `OnConnectionFailedListener` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`OnConnectionFailedListener`类：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`onCreate()`回调中添加以下代码：
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the method to setup the `GoogleAPIClient`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加设置`GoogleAPIClient`的方法：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the `setupGoogleApiClient()` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`setupGoogleApiClient()`方法：
- en: '[PRE40]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a pending intent with the following method:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法创建一个待定意图：
- en: '[PRE41]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the `geofence` object and add it to a list for the request:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`geofence`对象并将其添加到请求的列表中：
- en: '[PRE42]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the `createGeofencingRequest()` method as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建`createGeofencingRequest()`方法：
- en: '[PRE43]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we add the `ACCESS_FINE_LOCATION` permission as this is required for
    Geofencing. We set up the `GoogleApiClient` as we've done in previous recipes
    and wait until `onConnected()` is called to set up the `GeofencingApi`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加`ACCESS_FINE_LOCATION`权限，因为这是Geofencing所必需的。我们像在以前的食谱中一样设置`GoogleApiClient`，并等待`onConnected()`被调用以设置`GeofencingApi`。
- en: 'Before we can call the `GeofencingApi.addGeofences()` method, we have to prepare
    three objects:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以调用`GeofencingApi.addGeofences()`方法之前，我们必须准备三个对象：
- en: '`GoogleApiClient`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleApiClient`'
- en: Geofence Request
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Geofence请求
- en: Pending Intent
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待定意图
- en: We already created the `GoogleApiClient`, which we saved in the `mGoogleApiClient`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`GoogleApiClient`，我们将其保存在`mGoogleApiClient`中。
- en: 'To create the Geofence Request, we use the `GeofencingRequest.Builder`. The
    builder requires the list of Geofence objects, which are created in the `createGeofenceList()`
    method. (Even though we are only creating a single Geofence object, the builder
    requires a list, so we just add our single Geofence to an `ArrayList`.) Here is
    where we set the Geofence properties:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Geofence请求，我们使用`GeofencingRequest.Builder`。构建器需要Geofence对象列表，这些对象在`createGeofenceList()`方法中创建。（即使我们只创建了一个Geofence对象，构建器也需要一个列表，所以我们只需将单个Geofence添加到`ArrayList`中。）以下是设置Geofence属性的地方：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Only the Loitering delay is optional, but we need it since we are using the
    `DWELL` transition. When calling `setTransitionTypes()`, we can combine multiple
    transition types using the `OR` operator, shown with the pipe. Here''s an example
    using `ENTER` and `EXIT` instead:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只有Loitering延迟是可选的，但我们需要它，因为我们使用了`DWELL`转换。在调用`setTransitionTypes()`时，我们可以使用管道显示的`OR`运算符组合多个转换类型。以下是使用`ENTER`和`EXIT`的示例：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For this example, we used the same default latitude and longitude as the emulator.
    Change these values as needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了与模拟器相同的默认纬度和经度。根据需要更改这些值。
- en: Our call to `Geofence.Builder()` creates the Geofence object. With the Geofence
    list ready, we call the `GeofencingRequest.Builder` and set our initial trigger
    to `INITIAL_TRIGGER_DWELL`. (If you change the preceding transition types, you
    may want to change the initial trigger as well.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`Geofence.Builder()`创建Geofence对象。准备好Geofence列表后，我们调用`GeofencingRequest.Builder`并将我们的初始触发器设置为`INITIAL_TRIGGER_DWELL`。（如果你更改前面的转换类型，你可能还需要更改初始触发器。）
- en: The last object we need is a Pending Intent, which is how the system will notify
    our app when the Geofence criteria are met. We created the `GeofenceIntentService`
    to handle the Geofence intent by sending a notification to the user. (For more
    information on notifications, refer to the *Lights, Action, and Sound Redux using
    Notifications* recipe in [Chapter 7](ch07.html "Chapter 7. Alerts and Notifications"),
    *Alerts and Notifications*.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个对象是 Pending Intent，这是系统在满足 Geofence 条件时通知我们应用的途径。我们创建了 `GeofenceIntentService`
    来处理 Geofence 意图，通过向用户发送通知。（有关通知的更多信息，请参阅[第7章](ch07.html "第7章. 警报和通知")中的 *使用通知的灯光、动作和声音
    Redux* 配方，*警报和通知*。）
- en: With all three objects created, we just call `LocationServices.GeofencingApi.addGeofences()`
    and wait for the notification to arrive.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了所有三个对象后，我们只需调用 `LocationServices.GeofencingApi.addGeofences()` 并等待通知的到来。
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To stop receiving Geofence notifications, you can call the `removeGeofences()`
    method with either the `RequestID` parameter or `PendingIntent`. The following
    example uses the same `PendingIntent` method we used for the notification:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 若要停止接收 Geofence 通知，可以调用 `removeGeofences()` 方法，并使用 `RequestID` 参数或 `PendingIntent`。以下示例使用了与通知相同的
    `PendingIntent` 方法：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The `Geofence.Builder` class at: [https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html](https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Geofence.Builder` 类位于：[https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html](https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html)'
- en: 'The `GeofencingRequest.Builder` class at: [https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder](https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeofencingRequest.Builder` 类位于：[https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder](https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder)'
