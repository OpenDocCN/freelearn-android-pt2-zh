- en: Chapter 3. Building Our First Game – Breakout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So far, we have gone through some important basics of programming in Lua and
    applied some code to run in the Corona simulator. Knowing the terminology is a
    small part of learning how to create an application. We''ll need to take a step
    further and get some hands-on experience of what it''s like to structure a project
    from start to finish. We''re going to accomplish this by creating our first game
    from scratch. This will push you further to understand larger chunks of code and
    apply some game logic to create a functional game.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will understand:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure game files in a Corona project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create variables for the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add game objects to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an alert message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to display the score and level number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the fun begin!
  prefs: []
  type: TYPE_NORMAL
- en: Breakout – bringing back old-school gaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have probably seen many forms of the game Breakout in the past couple of
    decades, especially during the Atari days. To give you a good idea of what the
    game is about, here is a brief editorial by Big Fish Games about the history of
    Breakout: [http://www.bigfishgames.com/blog/the-history-of-breakout/](http://www.bigfishgames.com/blog/the-history-of-breakout/).
    The following screenshot is an example of Breakout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breakout – bringing back old-school gaming](img/9343OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the game screen, there are several columns and rows of bricks placed near
    the top of the screen. A ball travels across the screen, bouncing off the top
    and side walls of the screen. When a brick is hit, the ball bounces away and the
    brick is destroyed. The player loses the round when the ball touches the bottom
    of the screen. To prevent this from happening, the player has a movable paddle
    to bounce the ball upward, keeping it in play.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create a clone using touch events and the accelerometer for the
    paddle movement that will be controlled by the player. We'll be adding some physics
    to the ball so that it can bounce around the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be adding the movement of the game objects, collision
    detection, score keeping, and win/lose conditions. Right now, we're going to focus
    on how to set up the game template of Breakout.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Corona physics API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Corona has made it convenient to add physics to your games, especially if you've
    never worked on one before. The engine uses Box2D and takes only a few lines to
    incorporate it into your application than what it normally takes to have it set
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the physics engine in Corona is fairly easy. You use display objects
    and set them as a physical body in your code. Images, sprites, and vector shapes
    can be turned into a physical object. This is substantial in visualizing how you
    want your objects to react in an environment you have created. You can see results
    right away rather than guessing about how they might act in the physical world.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the physics world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making the physics engine available in your app requires the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Starting, pausing, and stopping the physics engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three main functions that affect the physics simulation. The following
    will start, pause, and stop the physics engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`physics.start()`: This will start or resume the physical environment. It is
    usually activated at the beginning of the application for physics bodies to take
    effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.pause()`: This stops the physics engine temporarily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.stop()`: This basically destroys the physical world altogether.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: physics.setGravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function sets the x and y parameters of the global gravity vector in units
    of meters per second square (acceleration units). The default is (0, 9.8) to simulate
    standard earth gravity, pointing downwards on the *y* axis. The syntax is `physics.setGravity(gx,
    gy)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: physics.getGravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns the x and y parameters of the global gravity vector in
    units of meter per second square (acceleration units).
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `gx, gy = physics.getGravity()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tilt-based gravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have `physics.setGravity(gx, gy)` and the accelerometer API applied,
    implementing tilt-based dynamic gravity is simple. The following is an example
    of creating the tilt-based function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The accelerometer is not present in the Corona simulator; a device build must
    be created to see the effect.
  prefs: []
  type: TYPE_NORMAL
- en: physics.setScale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the internal pixels-per-meter ratio used to convert between
    the onscreen Corona coordinates and simulated physics coordinates. This should
    be done before any of the physical objects are instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: The default scaling value is 30\. For devices of higher resolution, such as
    iPad, Android, or iPhone 4, you might wish to increase this value to 60 or more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is `physics.setScale(value)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: physics.setDrawMode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three rendering modes for the physics engine. This can be altered
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is `physics.setDrawMode(mode)`. The three rendering modes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`physics.setDrawMode("debug")`: This mode shows collision engine outlines only,
    as you can see in the following screenshot:![physics.setDrawMode](img/9343OT_03_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.setDrawMode("hybrid")`: This mode overlays collision outlines on normal
    Corona objects, as you can see in the following screenshot:![physics.setDrawMode](img/9343OT_03_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.setDrawMode("normal")`: This mode is the default Corona renderer with
    no collision outlines:![physics.setDrawMode](img/9343OT_03_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The physics data is displayed using color-coded vector graphics, which reflect
    different object types and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orange**: This is used to denote dynamic physics bodies (the default body
    type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dark blue**: This is used to denote kinematic physics bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: This is used to denote static physics bodies such as the ground
    or walls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gray**: This is used to denote a body that is in a *sleeping* state due to
    lack of activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Light blue**: This is used to denote joints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: physics.setPositionIterations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the accuracy of the engine's position calculations. The default
    value is `8`, meaning that the engine will iterate through eight position approximations
    per frame for every object, but will increase processor engagement, so it should
    be handled carefully, because it might slow down the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is `physics.setPositionIterations(value)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: physics.setVelocityIterations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the accuracy of the engine's velocity calculations. The default
    value is 3, meaning that the engine will iterate through three velocity approximations
    per frame for every object. However, this will increase processor engagement,
    so it should be handled carefully because it might slow down the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is `physics.setVelocityIterations( value )`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tutorial is compatible for both iOS and Android devices. The graphics have
    been designed to accommodate the varying screen dimensions of both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Build configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all items displayed on all device screens are shown in the portrait
    mode. We'll be creating this game specifically in the landscape mode, so we'll
    have to alter some build settings and configure how all the items on the screen
    will be displayed. Playing the game in the landscape mode will actually add more
    player interactivity since the paddle will have more screen space to move about
    and less airtime for the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the build.settings file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The build-time properties can be provided in an optional `build.settings` file,
    which uses the Lua syntax. The `build.settings` file is used to set the application
    orientation and autorotation behavior along with a variety of platform-specific
    build parameters. To add the `build.settings` file in your project folder, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project folder called `Breakout` on your desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your preferred text editor, create a new file called `build.settings` and
    save it in your project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close the file. The `build.settings` file is completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default orientation setting determines the initial launch orientation on
    the device and the initial orientation of the Corona simulator.
  prefs: []
  type: TYPE_NORMAL
- en: The default orientation doesn't affect Android devices. The orientation is initialized
    to the actual orientation of the device (unless only one orientation is specified).
    Also, the only supported orientations are `landscapeRight` and `portrait`. On
    a device, you can flip to either `landscapeRight` or `landscapeLeft`, but the
    operating system only reports one flavor of landscape, and Corona's orientation
    event chooses `landscapeRight`.
  prefs: []
  type: TYPE_NORMAL
- en: We have created this application to work with landscape orientations that support
    `landscapeRight`. We have set this orientation as its default so it won't switch
    to `landscapeLeft` or even any `portrait` mode. While working on an iOS device,
    if the `build.settings` isn't set before launching the application, it will go
    to the default portrait mode.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Corona can target builds made for multiple devices across iOS and Android, which
    display various art assets in different resolutions. Corona can scale upward or
    downward depending on your starting resolution. It can also substitute higher-resolution
    image files when needed, ensuring that your app appears clear and sharp on all
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the config.lua file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If no content size is specified, the content width and height returned will
    be the same as the physical screen width and height of the device. If you specify
    a different content width and height in `config.lua`, the content width and height
    will take on those values. To add the config.lua file in your project folder,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your text editor, create a new file called `config.lua` and save it to your
    project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The content width and height allow you to choose a virtual screen size that
    is independent of the physical device screen size. We have set the size to target
    the iPhone 3GS since it displays one of the common dimensions across most devices
    for both iOS and Android platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The scale used for this application is set to `letterbox`. It will uniformly
    scale up content as much as possible while still displaying all content on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: We set `fps` to `60`. By default, the frame rate is 30 fps. In this application,
    this will make the movement of the ball appear faster and allow us to increase
    the speed conveniently. We can stretch the frame rate to 60 fps, which is the
    maximum that Corona can allow.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have configured our application to the landscape mode and set the
    display contents to scale on multiple devices, we''re ready to start designing
    the game. Before we start writing some code for the game, we need to add in some
    art assets that will be displayed on the screen. You can find them in the `Chapter
    3 Resources` folder. You can download the project files that accompany this book
    from the Packt Publishing website. The following are the files that you''ll need
    to add to your `Breakout` project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alertBox.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bg.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmScreen.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ball.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paddle.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brick.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbtn.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important function that we'll be introducing in this game is `display.newGroup()`.
    Display groups allow you to add and remove child display objects and collect the
    related display objects. Initially, there are no children in a group. The local
    origin is at the parent object's origin; the anchor point is initialized to this
    local origin. You can easily organize your display objects in separate groups
    and refer to them by their group name. For example, in Breakout, we'll combine
    menu items such as the **Title** screen and **Play** button in a group called
    `menuScreenGroup`. Every time we access `menuScreenGroup`, any display object
    contained within the display group will be processed.
  prefs: []
  type: TYPE_NORMAL
- en: display.newGroup()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function creates a group in which you can add and remove child display
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `display.newGroup()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Working with system functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system functions that we're going to introduce in this chapter will return
    information about the system (device information and current orientation) and
    control system functions (enabling multi-touch and controlling the idle time,
    accelerometer, and GPS). We'll be using the following system functions to return
    the environment information that our application will be running in and the response
    frequency for the accelerometer events.
  prefs: []
  type: TYPE_NORMAL
- en: system.getInfo()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns information about the system on which the application
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is `system.getInfo(param)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid values for parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"name"`: This returns the model name of the device. For example, on the iTouch,
    this would be the name of the phone as it appears in iTunes, such as "Pat''s iTouch".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"model"`: This returns the device type. These include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPhone
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: iPhone Simulator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Nexus One
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Droid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: myTouch
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Galaxy Tab
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"deviceID"`: This returns a hash-encoded device ID of the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"environment"`: This returns the environment that the app is running on. These
    include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"simulator"`: The Corona simulator'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"device"`: iOS, Android device, and the Xcode simulator'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"platformName"`: This returns the platform name (the OS name), which can be
    any one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mac OS X (Corona simulator on Mac)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Win (Corona simulator on Windows)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: iPhone OS (all iOS devices)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Android (all Android devices)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"platformVersion"`: This returns a string representation of the platform version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"build"`: This returns the Corona build string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"textureMemoryUsed"`: This returns the texture memory usage in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"maxTextureSize"`: This returns the maximum texture width or height supported
    by the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"architectureInfo"`: This returns a string that describes the underlying CPU
    architecture of the device you are running on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: system.setAccelerometerInterval()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the frequency of accelerometer events. On the iPhone, the
    minimum frequency is 10 Hz and the maximum is 100 Hz. Accelerometer events are
    a significant drain on battery, so only increase the frequency when you need faster
    responses, as in games. Always try to lower the frequency whenever possible to
    conserve battery life.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is `system.setAccelerometerInterval( frequency )`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The function sets the sample interval in Hertz. Hertz is cycles per second,
    that is, the number of measurements to take per second. If you set the frequency
    to 75, then the system will take 75 measurements per second.
  prefs: []
  type: TYPE_NORMAL
- en: After you have the assets from the `Chapter 3` `Resources` folder added in your
    project folder, we will begin writing some code!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating variables for the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any application to start, we'll need to create a `main.lua` file. This has
    been discussed in [Chapter 2](ch02.html "Chapter 2. Lua Crash Course and the Corona
    Framework"), *Lua Crash Course and the Corona Framework*, when we worked with
    some sample code and ran it with the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will be structured accordingly in your `main.lua` file by the time
    the game is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: Necessary classes (for example, `physics` or `ui`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Main function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call main function (this has to be called always, or your application will not
    run)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging your code to make it look like the preceding structure is a good practice
    on keeping things organized and running your application efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll be introducing the display group that will show the main
    menu screen and a **Play** button that the user will be able to interact with
    in order to move on to the main game screen. All in-game elements such as the
    paddle, ball, brick objects, and heads-up display elements follow after the player
    interacts with the **Play** button. We'll also be introducing win and lose conditions
    that will be referred as `alertDisplayGroup`. All these game elements will be
    initialized in the beginning of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `main.lua` file in your text editor and save it to your project
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re going to hide the status bar (specifically for iOS devices) and load
    the physics engine. Corona uses the Box2D engine that is already built into the
    SDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the Corona Physics API can be found on the Corona website
    at [http://docs.coronalabs.com/guide/physics/physicsSetup/index.html](http://docs.coronalabs.com/guide/physics/physicsSetup/index.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Box2D physics engine used in Corona SDK was written by Erin Catto of Blizzard
    Entertainment. More information on Box2D can be found at [http://box2d.org/manual.pdf](http://box2d.org/manual.pdf).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add in the menu screen objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the in-game screen objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in HUD elements for the score and level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The HUD is also known as the heads-up display. It is a method of visually representing
    character information on the game screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we''ll add in the alert display group for the win/lose conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following variables hold the values for the bricks display group, score,
    ball velocity, and in-game events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Accelerometer events can only be tested on a device, so we''re going to add
    a variable for touch events on the paddle by calling the `"simulator"` environment.
    This is so that we can test the paddle movement in the Corona simulator. If you
    were to test the application on a device, the event listeners for touch and accelerometer
    on the paddle won''t conflict:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add in the `main()` function. This will start our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `display.setStatusBar(display.HiddenStatusBar)` method is only applicable
    for iOS devices. It hides the appearance of the status bar on the device.
  prefs: []
  type: TYPE_NORMAL
- en: The new Corona API that we added to this game is the physics engine. We'll be
    adding physics parameters to the main game objects (paddle, ball, and bricks)
    for collision detection. Having `setGravity(0,0)` will allow the ball to bounce
    around the playing field freely.
  prefs: []
  type: TYPE_NORMAL
- en: The `local menuScreenGroup`, `local alertDisplayGroup`, and `local bricks` objects
    are all forms of display groups that we can separate and organize our display
    objects in. For example, `local menuScreenGroup` is designated for objects that
    show up on the main menu screen. Hence, they can be removed as a group and not
    as individual objects.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the variables added already have values that are applied to certain
    game objects. There is already a set velocity for the ball using `local vx = 3`
    and `local vy = -3`. The x and y velocities determine how the ball moves on the
    game screen. Depending on the position the ball collides with an object, the ball
    will follow a continuous path. The `brickWidth` and `brickHeight` objects have
    a value that will stay constant throughout the application, so we can line the
    brick objects evenly onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: '`local gameEvent = " "` will store the game events such as `"win"`, `"lose"`,
    and `"finished"`. When a function checks the game status for any of these events,
    it will display the proper condition on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: We have added some system functions as well. We created `local isSimulator =
    "simulator" == system.getInfo("environment")` so that it returns information about
    the system on which the application is running. This will be directed for the
    paddle touch events so that we can test the application in the simulator. If the
    build were to be ported on a device, you would only be able to use the accelerometer
    to move the paddle. The simulator can't test accelerometer events. The other system
    function is `system.setAccelerometerInterval( 100 )`. It sets the frequency of
    the accelerometer events. The minimum frequency on an iPhone is 10 Hz and the
    maximum is 100 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` empty function set will start out the display hierarchy. Think
    of it as a storyboard. The first thing you see is an introduction, and then some
    action happens in the middle that tells you about the main content. In this case,
    the main content is the game play. The last thing you see is some kind of ending
    or closure to tie the story together. The ending is the display of the win/lose
    conditions at the end of a level.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding events and listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events are sent to listeners that are executed by a touch on the mobile screen,
    tap, accelerometer, and so on. Functions or objects can be event listeners. When
    an event occurs, the listener is called by a table that represents the event.
    All events will have a property name that identifies the kind of event.
  prefs: []
  type: TYPE_NORMAL
- en: Register events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Display objects and global runtime objects can be event listeners. You can
    add and remove listeners for events using the following object methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`object:addEventListener()`: This adds a listener to the object''s list of
    listeners. When the named event occurs, the listener will be invoked and supplied
    with a table that represents the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object:removeEventListener()`: This removes the specified listener from the
    object''s list of listeners so that it is no longer notified of events that correspond
    to the specified event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, an image display object registers to receive a touch
    event. Touch events are not broadcast globally. Display objects that register
    for the event and lie underneath it will be candidates to receive the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Runtime events are sent by the system. They broadcast to all listeners. The
    following is an example of registering for an `enterFrame` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Runtime events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application that we're creating uses runtime events. Runtime events have
    no specific target and are only sent to the global runtime. They broadcast to
    all registered listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runtime events are sent by the system. They broadcast to all listeners. The
    following is an example of registering for an `enterFrame` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following events all have string names and will be applied to the Breakout
    game.
  prefs: []
  type: TYPE_NORMAL
- en: enterFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `enterFrame` events occur at the frame interval of the application. They
    are only sent to the global runtime object. For example, if the frame rate is
    30 fps, then it will occur approximately 30 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following properties are available in this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string `"enterFrame"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.time` is the time in milliseconds since the start of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events let you detect movements and determine the device's orientation
    in relation to gravity. These events are only sent to devices that support accelerometer.
    They are only sent to the global runtime object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following properties are available for this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string `"accelerometer"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.xGravity` is the acceleration due to gravity in the *x* direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.yGravity` is the acceleration due to gravity in the *y* direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.zGravity` is the acceleration due to gravity in the *z* direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.xInstant` is the instantaneous acceleration in the *x* direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.yInstant` is the instantaneous acceleration in the *y* direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.zInstant` is the instantaneous acceleration in the *z* direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.isShake` is true when the user shakes the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user's finger touches the screen, a hit event is generated and dispatched
    to display objects in the display hierarchy. Only those objects that intersect
    with the location of the finger on the screen will potentially receive the event.
  prefs: []
  type: TYPE_NORMAL
- en: Touch (single touch)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Touch events are a special kind of hit event. When a user's finger touches the
    screen, they are starting a sequence of touch events, each with different phases.
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string `"touch"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.x` is the *x* position in the screen coordinates of the touch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.y` is the *y* position in the screen coordinates of the touch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.xStart` is the *x* position of the touch from the `"began"` phase of
    the touch sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.yStart` is the *y* position of the touch from the `"began"` phase of
    the touch sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.phase` is a string that identifies where in the touch sequence the event
    occurred:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"began"`: This indicates that a finger touched the screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"moved"`: This indicates that a finger moved on the screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ended"`: This indicates that a finger was lifted from the screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"cancelled"`: This indicates that the system canceled tracking of the touch'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: tap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It generates a hit event when the user touches the screen. The event is dispatched
    to display objects in the display hierarchy. This is similar to the touch event,
    except that a hit count (number of taps) is available in the event callback and
    doesn''t use event phases. The event APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string `"tap"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.numTaps` returns the number of taps on the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.x` is the *x* position in the screen coordinates of the tap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.y` is the *y* position in the screen coordinates of the tap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be touching base with `transition.to()` and `transition.from()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transition.to()`: This animates a display object''s properties over time using
    the `easing` transitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is `handle = transition.to( target, params )`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`transition.from()`: This is similar to `transition.to()` except that the starting
    property values are specified in the function''s parameter table, and the final
    values are the corresponding property values in the target prior to the call.
    The syntax is `handle = transition.from( target, params )`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters used are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`target`: This is a display object that will be the target of the transition.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: This is a table that specifies the properties of the display object,
    which will be animated, and one or more of the following optional non-animated
    properties:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.time`: This specifies the duration of the transition in milliseconds.
    By default, the duration is 500 ms (0.5 seconds).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.transition`: This is by default `easing.linear`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.delay`: This specifies the delay in milliseconds (none by default)
    before the tween begins.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.delta`: This is a Boolean that specifies whether non-control parameters
    are interpreted as final ending values or as changes in value. The default is
    `nil`, meaning false.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.onStart`: This is a function or table listener that is called before
    the tween begins.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.onComplete`: This is a function or a table listener that is called
    after the tween completes.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how two display objects transition throughout the
    space on a device screen. From its current position, the `square` display object
    will move to a new location of `x = 250` and `y = 400` in 1500 milliseconds. The
    `square2` display object will transition from `x = 275` and `y = 0` to its initial
    location in 1500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Creating menu screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having menu screens allows the player to transition through different parts
    of your application. Typically, a game will start out with some kind of screen
    that displays the game title with an interactive user interface button labeled
    **Play** or **Start** to give the player the option to play the game. It is standard
    in any mobile application to have a menu screen before transitioning to the main
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the main menu screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main menu screen will be the first thing in our menu system that the player
    interacts with after the application is launched. It's a great way to introduce
    the title of the game and also give the player an idea of what type of gaming
    environment they should expect. We wouldn't want the player to jump abruptly into
    the app without any proper notification. It's important to allow the player to
    prepare for what is to come when they launch the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a function called `mainMenu()` to introduce the title
    screen. So after `function main()` ends, add in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll be adding in a display group and two display objects to this function.
    One display object is the image that will represent the main menu screen, and
    the other will be a UI button called **Play**. Add them inside `function mainMenu()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember the empty `main()` function set? We need to call `mainMenu()` inside
    it. The entire function should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `mainMenu()` function, we''re going to create another function called
    `loadGame()`. This function will initiate the event from `playbtn` to transition
    to the main game screen. The event will change the alpha of `menuScreenGroup`
    to `0`, which makes it invisible on the screen. Complete the transition by calling
    the `addGameScreen()` function (`addGameScreen()` will be discussed later in the
    *Time for action – adding game objects* section of this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add in an event listener to `playBtn`, so when it is tapped,
    it will call the `loadGame()` function. Add the following line in the `mainMenu()`
    function after the last method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project in the simulator. You should see the main menu screen display
    **Breakout** and the **Play** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a main menu screen only requires a couple of blocks of code. For `loadGame(event)`,
    we passed a parameter called `event`. When the `if` statement is called, it takes
    `playbutton`, which references to the display object `playBtn`, and checks to
    see whether it is true. Since it is, the `menuScreenGroup` will be removed from
    the stage and called in the `addGameScreen()` function. At the same time, the
    event listener for `playBtn` is removed from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – creating a help screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, the design of the menu system is set up so that from the main menu
    screen it transitions to the game play screen. You have the option to extend the
    menu screens without jumping into the game right away. Something additional that
    can be added is a help menu screen after the main menu screen, which explains
    to the players how to play the game.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new image in your preferred image editing program and write out the
    steps for how to play the game. You can then create a new button called **Next**
    and add both art assets to your project folder. In your code, you'll have to create
    a new function and event listener for your **Next** button, which will transition
    to the game play screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game play scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a menu system in place, we can start on the game play elements
    of the application. We'll start adding all of the main game objects that the player
    will interact with. One thing to note when adding in game objects is their placement
    on the screen. Given that this game will be played in the landscape mode, we have
    to remember that there is plenty of space available in the *x* direction and a
    smaller amount in the *y* direction. Based on the original design of the game,
    the bottom wall of the screen causes the player to lose the level or turn if the
    ball lands in that area. So if we were to pinpoint an area to place the paddle
    object, we wouldn't set it near the top of the screen. It makes more sense for
    the paddle to be as close to the bottom of the screen to protect the ball better.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add in the display objects the player will see while in game play:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `loadGame()` function, we''re going to create another function that
    will display all our game objects on screen. The following lines will display
    the art assets that were created for this tutorial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll add in the text that will display the score and level number during
    the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build the first game level, we''re going to call the `gameLevel1()` function,
    which will be explained later in this chapter. Don''t forget to close the `addGameScreen()`
    function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `addGameScreen()` function displays all the game objects shown during game
    play. We have added the `background`, `paddle`, and `ball` display objects from
    the art assets provided for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have added text for the score and level at the top of the game screen. `scoreNum`
    is initially set to `0`. In the next chapter, we'll discuss how to update the
    score number when a brick collision is made. `levelNum` starts at 1, updates when
    the level is completed, and moves on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the function by calling `gameLevel1()`, which will be implemented in
    the next section to start the first level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – building bricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bricks are the last of the game objects we need to add in for this application.
    We''ll be creating two different levels for this game. Each one will have a different
    brick layout from the other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create the function for the first level. Let''s create a new
    function, `gameLevel1()`. We will also set `currentLevel` to `1` since the application
    begins at level 1\. Then, we''ll add in the `bricks` display group and set it
    as `toFront()` so that it appears in front of the game background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method `object:toFront()` moves the target object to the visual front of
    its parent group (`object.parent`). In this case, we are setting the `bricks`
    group to appear as the front-most display group during game play so that it appears
    in front of the background image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add some local variables that will show how many rows and columns of
    bricks will be displayed on screen and where each brick will be placed in the
    playing field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create double `for` loops, one for `numOfRows` and the other for `numOfColumns`.
    Create a brick instance placed according to its width, height, and the number
    corresponding to `numOfRows` and `numOfColumns`. The art asset for the brick display
    object is provided with this chapter. Then, close the function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The setup for level 2 is similar to how level 1 is arranged. The code is almost
    the same, except that our new function is called `gameLevel2()`, `currentLevel`
    is set to `2`, and the values for `numOfRows` and `numOfColumns` have different
    values. Add the following block after the `gameLevel1()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your file and relaunch the simulator. You'll be able to interact with the
    **Play** button and see the transition from the main menu screen to the game screen.
    You will see the game layout for level 1 displayed on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bricks` display group is set as `bricks:toFront()`. This means that the
    group will always be put in front of the display hierarchy, apart from the `background`,
    `paddle`, and `ball` display objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `gameLevel1()` method has set values for the amount of brick objects displayed
    in the playing field. They will be centered based on `contentWidth` of the device
    shell and set at `50` in the y direction. The brick group is placed near the top
    left-hand corner by `brickPlacement`, takes the middle of the screen, and subtracts
    it by half the width of all the brick objects put together. Then, we add 20 more
    pixels in the x direction to center it with the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: We created double `for` loops for `numOfRows` and `numOfColumns`, which start
    the creation of the brick objects from the left-hand corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `brick` display object is given the name `brick`. Just remember
    that `brick` cannot be used the same way as `brick` when calling the object. The
    `brick` object is an instance of `brick`. It is merely used as a string when event
    parameters are called, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The physics body of `brick` is set to `"static"`, so it is not affected by gravity
    pulling down. Then, it is added to the `bricks` group under `bricks.insert(bricks,
    brick)`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – focused platform gaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On completing this chapter and the next one, feel free to redesign the display
    images to focus on a specific platform. For example, you can easily convert the
    code to be compatible for all iOS devices. This can be done by converting display
    objects to `display.newImageRect( [parentGroup,] filename [, baseDirectory] w,
    h )`, so you can substitute image dimensions on devices with larger screen sizes
    (such as iPhone 5/Samsung Galaxy S5). Remember that you'll have to adjust your
    configuration settings to have the changes applied. This pertains to adding a
    unique image suffix (or your preferred suffix naming convention) to your `config.lua`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Red alert!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every game, there is some kind of message that tells you the status of your
    progress when the main action has ended. For this application, we need a way to
    let the player know if they have won or lost a round, how they can play again,
    or when the game is officially completed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying game messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up some win/lose notifications so that we can display these events
    that occur in game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `alertScreen()` and pass two parameters called
    `title` and `message`. Add in a new display object called `alertbox` and have
    it transition from `xScale` and `yScale` of 0.5 using `easing.outExpo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the `title` parameter in the text object called `conditionDisplay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the `message` parameter in the text object called `messageText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new display group called `alertDisplayGroup` and insert all the objects
    into the group. Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your file and run the project in the simulator. The functionality of the
    **Play** button still goes to the game play screen for **Level: 1**. Currently,
    none of the objects have any movement. We''ll be adding touch events, ball movement,
    and collisions in the next chapter. All the game objects should be laid out as
    shown in the following screenshot:![Time for action – displaying game messages](img/9343OT_03_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set up the alert system for the game, but it is not operable at the
    moment until we add in more game functions to set the game objects in motion.
    The next chapter will demonstrate how the `alertScreen()` function passes two
    parameters, `title` and `message`. An `alertBox` display object is added as a
    background to the alert texts when they pop up after a condition occurs. When
    the `alertBox` pops up, it transitions from 0.5 of `xScale` and `yScale` to full
    image scale in 500 milliseconds. This is basically the equivalent of half a second.
  prefs: []
  type: TYPE_NORMAL
- en: The `conditionDisplay` object passes the `title` parameter. This will be the
    text that displays **You Win** or **You Lose**.
  prefs: []
  type: TYPE_NORMAL
- en: The `messageText` object passes the `message` parameter. The text with this
    parameter displays a message such as **Play Again** or **Continue** after a condition
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: All the objects in this function are then inserted into `alertDisplayGroup =
    display.newGroup()`. They will act as one group instead of individual objects
    when they appear on and off the stage.
  prefs: []
  type: TYPE_NORMAL
- en: When running the code in the simulator, if errors pop up in your terminal window,
    be sure to check the line(s) that caused the errors. Sometimes, a simple capitalization
    error or even a comma or quotation mark that is missing can keep your app from
    running in the simulator. Make sure you're aware of those common mistakes. They
    can be easily overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the `Breakout – Part 1` folder in the `Chapter 3` folder to
    see how the first half of the code for this tutorial is set up.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – building a game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. When adding the physics engine in your code, which functions are valid
    to add to your application?
  prefs: []
  type: TYPE_NORMAL
- en: '`physics.start()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`physics.pause()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`physics.stop()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which is correct when adding an event listener?
  prefs: []
  type: TYPE_NORMAL
- en: '`button:addeventlistener("touch", listener)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`button:AddEventListener("touch", listener)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`button:addEventListener(touch, listener)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`button:addEventListener("touch", listener)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What is the correct way to make the following display object transition
    to `x = 300`, `y = 150`, and have the alpha changed to 0.5, in 2 seconds?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`transition.to( square, { time=2000, x=300, y=150, alpha=0.5 })`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`transition.from( square, { time=2000, x=300, y=150, alpha=0.5 })`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`transition.to( square, { time=2, x=300, y=150, alpha=0.5 })`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have completed the first half of this game tutorial. Understanding how to
    structure a Corona project properly makes it easier to keep your code organized
    and tracks your assets better. We have got a taste of working with blocks of code
    that pertain to a small part of the game logic needed to allow the application
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we have:'
  prefs: []
  type: TYPE_NORMAL
- en: Specified the build configuration on displaying the content for Android and
    iOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced the main variables and constants that will run in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiated the physics engine and started to apply it to the game objects
    that require physical bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created transitions from menus to game play screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added display objects and game messages to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's quite an accomplishment of how much we've done so far, including learning
    a new API in the process of coding the application. We still have a lot more to
    add before the game can be fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be finishing the second half of this game tutorial.
    We'll be working with collision detection of the paddle, ball, brick, and wall
    objects. Also, we'll learn how to update the score when a brick is removed from
    the scene and get our win/lose conditions active as well. We're in the home stretch.
    Let's keep going!
  prefs: []
  type: TYPE_NORMAL
