- en: Chapter 2. Designing our App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will think of an idea for an app and transform that idea
    into a real app, create a basic structure to be displayed on the screen, and choose
    an appropriate navigation pattern to move between them.
  prefs: []
  type: TYPE_NORMAL
- en: After taking a look at the most commonly used navigation pattern, we will proceed
    with implementing the tabs pattern composed by fragment and `ViewPager`.
  prefs: []
  type: TYPE_NORMAL
- en: During this, we will do a review of our knowledge of fragments to be able to
    explain the advanced concepts. We will also discuss the importance of `FragmentManager`
    and the fragments back-stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, we will add some good-looking animations to our screen transitions.
    Therefore, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an app navigation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing tabs and ViewPager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animated transitions between screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an app-navigation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that one day you wake up feeling inspired; you have an idea for
    an app that you believe can become more popular than WhatsApp. Without losing
    time, you would want to turn this app idea into reality! This is why it's important
    for you to learn how to design an app and choose the most appropriate navigation
    pattern. Not to sound uninspiring, but you'll find that 99 percent of your ideas
    will already be on Google Play Store. It's simply a fact that there are hundreds
    of thousands of apps available, and the number is always increasing! So, you can
    either decide to improve upon the already existing ones or keep brainstorming
    until you have something original.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the app a reality, the first step is to visualize the app in
    your mind; for this, we need to identify the basic components. We need to simplify
    the idea on screen, and we need to move between screens.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that you are creating this app for Android users. These users are
    used to using navigation patterns such as the sliding panel, which is used in
    apps such as Gmail, Facebook, and Spotify.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at three different and commonly used navigation patterns
    that guarantee that the user won't get lost in our app and will understand the
    app structure instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Basic structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to draw our screens (note that I am not referring to activities or
    fragments yet; by screen I mean what the user can literally see on screen at any
    point during the execution of our app), we need to identify the key points of
    our idea. We need to establish the use cases, speaking in software development
    terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by giving shape to the app that we will build during the course
    of this book: **MasteringAndroidApp**. It''s difficult to visualize all the details
    in your mind at first, so we will start by identifying the components that we
    know we need for sure and later fill in the gaps if there are any.'
  prefs: []
  type: TYPE_NORMAL
- en: We know from the previous chapter that we have a presentation screen, which
    shows the logo of the app for a few seconds while downloading data from the Internet
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this app, we will also have a screen with a list of the information coming
    from the Internet, with individual items that the user can click on to get more
    detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: As the main option, we will show a contact screen with `MapView` showing my
    location and contact data.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we need a **Preferences** or **Settings** screen, where we can turn
    on and off the notifications and deactivate ads or purchase extras.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to create a mock-up. Have a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic structure](img/B04887_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the top, we have the entry point of our application, which is the splash
    screen. The navigation here is straightforward; we can navigate to the next screen
    in a straight line, and there are no buttons or any other possible flow.
  prefs: []
  type: TYPE_NORMAL
- en: On the next level, we have a screen with the list of items (which is a screen
    with contact information), a map view, and a settings screen. These three screens
    are at the same level in our app, so they have the same importance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a third level of navigation, which is the detailed view of
    an item of the list.
  prefs: []
  type: TYPE_NORMAL
- en: The only way we can open this screen is by clicking on an element of the list;
    so, the entry point of this screen is the list screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic structure and flow created, we will look through the
    different extensively used navigation patterns in order to decide which one would
    work best for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the app structure and similar information on material
    design, refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.android.com/design/patterns/app-structure.html](https://developer.android.com/design/patterns/app-structure.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.google.com/design/spec/patterns/app-structure.html#](http://www.google.com/design/spec/patterns/app-structure.html#)'
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dashboard pattern is one of the first patterns used in Android. It consists
    of a set of elements displayed on the main screen as a matrix of icons. In the
    following image, we can see one of the first versions of the Facebook app on the
    left-hand side, and to the right, a customization of the pattern from Motor Trend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dashboard pattern](img/B04887_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This view is great for apps that aim to display a very limited number of options
    clearly; there are no more than two elements per row with a number of rows that
    fits on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: These icons clearly display symbols of the main functionality with all the options
    at the same level. It's an ideal pattern for apps that have a large target audience;
    it's straightforward and self explanatory, so anyone can navigate it.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this design seems old, given that it was extensively used in the
    first versions of Android and is used less nowadays, its usage depends on your
    needs, so don't let this put you off. The Motor Trends app shown in the preceding
    image had a very original implementation of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If the elements don't fit on the screen and we need to scroll in order to discover
    them, we need to reconsider the pattern. The same thing applies when we have too
    few elements; there are better options for these cases. In our particular example,
    we have three main elements, so we will not use this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The sliding panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is well known thanks to apps such as Gmail and Facebook. It presents
    a layout at the top level of the UI; screens come out from the left or right when
    we perform a swipe gesture or click on the top left or right button, which usually
    is an icon displayed with three horizontal lines—also know as the Hamburger icon.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is perfect if we have a large number of options at the same level
    in our app, and it can be combined with other patterns, such as **the tabs pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this panel can be done with the `DrawerLayout` class,
    which is composed of two child views: a `FrameLayout` with the content and the
    navigation drawer, which can be `ListView` or any other custom layout containing
    the options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we select an element in this side panel, a child appears in the middle
    of the screen; this child can help you navigate to a subchild but never to an
    element of the main menu. The child and sub child navigation can be managed with
    the back button or the up navigation in the action bar.
  prefs: []
  type: TYPE_NORMAL
- en: We can close the panel by clicking on an item and know whether the panel is
    closed or open by setting a drawer listener, `ActionBarDrawerToggle`, which contains
    the `onDrawerClosed(View drawerView)` and `onDrawerOpened(View drawerView)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you use `ActionBarDrawerToggle` from `android.support.v7.app`; the
    one included in v4 is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another big advantage of this pattern is that it allows group navigation via
    a main item on the menu that can be expanded into subitems. As you can see in
    the following example, Item 4 has three options inside it in a drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sliding panel](img/B04887_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example of a drawer layout
  prefs: []
  type: TYPE_NORMAL
- en: This would not be suitable for our app as we don't have enough options to make
    the most of this pattern. Also, as this pattern can be combined with the tabs
    pattern, it makes more sense from an educational perspective to develop our example
    with this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tabs pattern is a pattern that you have probably seen and used before.
  prefs: []
  type: TYPE_NORMAL
- en: It shows a fixed menu with components at the same level. Note that when we have
    tabs, the menu is always visible, which doesn't happen in the sliding and dashboard
    patterns. This looks very similar to a web interface and is very user friendly
    considering that the user probably already knows this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pattern has two variants: fixed and sliding tabs. If we only
    have a small number of menu items that can fit on the screen, the first variant
    will be the most suitable as it shows the users all the items at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tabs](img/B04887_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sliding tabs are usually used when all the items don't fit on the screen or
    when they do fit but we know that more items will be added and won't fit in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the two variants is slightly different, so we need to
    consider future changes when deciding the variant. Here, we can see an implementation
    of a sliding variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tabs](img/B04887_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that for platform consistency, we must place the tabs at the top of
    the screen; otherwise, people will think that you are an iOS developer!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some features and formatting specifications from the material design
    guidelines for you to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Present tabs as a single row. Wrap tab labels to a second line if needed and
    then truncate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not include a set of tabbed content within a tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlight the tab corresponding to the visible content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group tabs together hierarchically. Connect a group of tabs with its content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep tabs adjacent to their content. It helps maintain the relationship between
    the two with less ambiguity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following image, we can see an example of scrolling/sliding tabs with
    a submenu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tabs](img/B04887_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graphic specifications while designing tabs along with more information
    about label specs can be found at [http://www.google.com/design/spec/components/tabs.html#](http://www.google.com/design/spec/components/tabs.html#).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of app navigation, we can explore the components
    that we need to implement these patterns. The main components, as you know, are
    activities and fragments. We are going to implement an example of sliding tabs
    with three fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to review briefly the key concepts of fragments
    to explain advanced features and components, such as Fragment Manager and the
    fragments back stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will create an activity called `MainActivity` and four fragments:
    `ListFragment`, `ContactFragment`, `SettingsFragment`, and `DetailsFragment`.
    For this, you can create a `fragments` package and double-click on the package
    to go to **New** | **Fragment** | **Blank Fragment**. Take a look at the following
    dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fragments](img/B04887_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For now, you can create them without the fragment factory methods and the interface
    callbacks. We will cover these later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project so far should look like this in the **Project** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fragments](img/B04887_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the importance of fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fragment represents a behavior or a portion of the user interface in an activity.
    You can combine multiple fragments in a single activity to build a multipane UI
    and reuse a fragment in multiple activities. You can think of a fragment as a
    modular section of an activity that has its own lifecycle and receives its own
    input events, which you can add or remove while the activity is running (sort
    of like a *subactivity* that you can reuse in different activities).
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the importance of fragments](img/B04887_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The fragment lifecycle is slightly different from the activity lifecycle. The
    first difference we notice is the use of the `OnAttach()` and `OnDetach()` methods,
    which connect the fragment to the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Using `onCreate()`, we can create the view in `OnCreateView()`; after this we
    can call `getView()` in our fragment, and it won't be null.
  prefs: []
  type: TYPE_NORMAL
- en: The `onActivityCreated()` method tells the fragment that its activity has been
    completed on its own `Activity.onCreate()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to display a fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to have the fragment in our layout XML. This will create our
    fragment when the view containing it is inflated. Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to create our fragment programmatically and tell Fragment
    Manager to display it in a container. For this, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, inflate a `FrameLayout` container where the fragment will be inserted
    using the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish with the key concepts, it is important to explain why Android examples
    create the fragments using the `MyFragment.newInstance(params)` factory method
    instead of using the default new `MyFragment(params)` constructor. Take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reason behind this pattern is that Android only recreates Fragments using
    the default constructor; therefore, if we have a constructor with parameters,
    it will be ignored, and the parameters will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we send the parameters in a bundle as arguments, allowing the fragment
    to retrieve the parameter if it has to be recreated (due to a device orientation
    change, we use the back navigation).
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fragment Manager is an interface used to interact with the fragments inside
    an activity. This means that any operation, such as adding, replacing, removing,
    or finding a fragment, has to be done through it.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain Fragment Manager, our `Activity` needs to extend from `FragmentActivity`,
    which will allows us to call `getFragmentManager()` or `getSupportFragmentManager()`
    preferably that maintain backwards compatibility using the Fragment Manager included
    in `Android.support.v4`.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to use nested fragments, we can manage them with `getChildFragmentManager()`.
    You cannot inflate a layout into a fragment when this layout includes `<fragment>`.
    Nested fragments are only supported when added to a fragment dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will discuss some scenarios that we will face sooner or later while
    working with fragments. Imagine that we have an activity with two fragments, A
    and B.
  prefs: []
  type: TYPE_NORMAL
- en: A typical scenario is that we are in a fragment and we want to execute a method
    from the activity. In this case, we have two options; one is to implement a `public`
    method in `MyActivity`, for instance `doSomething()`, so that we can cast `getActivity`
    to our activity and call the `((MyActivity)getActivity).doSomething();` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is to make our activity implement an interface defined in our
    fragment, and make the instance of the activity a listener of this interface in
    our fragment during the `onAttach(Activity)` method. We will explain this software
    pattern in [Chapter 4](ch04.html "Chapter 4. Concurrency and Software Design Patterns"),
    *Concurrency and Software Design Patterns*. For the other way around, to get an
    Activity to communicate with a fragment (if we don''t have fragment A instantiated
    in a variable in our activity), we can find the fragment in the manager. A fragment
    can be found using the ID of the container or a tag that we will take a look at
    in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final scenario would be in fragment A and speaking to B; for this, we just
    need to retrieve the manager from the activity and find the fragment. Run the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Fragments stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been speaking about finding a fragment in fragment manager and this
    is possible thanks to the Fragment Manager stack of fragments where we can add
    or remove fragments during transactions.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to display a fragment dynamically, we can decide whether we want
    to add the fragment to the stack or not. Having the fragment on the stack allows
    us to navigate back to the previous fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important for our example; if the user is on the first tab and clicks
    on an item on the list, we want him/her to see the details screen, `DetailsFragment`.
    Now, if the user is on `DetailsFragment` and clicks on the back button, we don''t
    want him/her to leave the App; we want the app to navigate back to the fragment
    stack. This is why when we add `DetailsFragment`, we have to include the `addToBackStack(String
    tag)` option. The tag can either be null, or it can be a `String` type that will
    allow us to find this new fragment by the tag. It will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To clarify further, if we wanted to navigate between three fragments, *A to
    B to C*, and then navigate back, having a stack will allow us to go *C to B to
    A*. However, if we don't add the fragments to the back stack or if we add or replace
    them in the same container, *A to B to C*, this will leave us with only the C
    fragment and without the back navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to implement the back navigation in `DetailsFragment`, we have to let
    the activity know that when I click on back, I want to first navigate back in
    the fragment before quitting the app, as it does by default. This can be done
    by overriding `onKeyDown` and handling the fragment navigation if there is more
    than one fragment in the back stack. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ViewPager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuing with our example, we have two ways of navigating between fragments
    on `MainActivity`: either by tapping on the tabs or by swiping between the fragments.
    To achieve this, we will use `ViewPager`, including the sliding tabs inside it,
    which is a very elegant solution with minimal code and includes synchronization
    between swipe and tabs.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewPager` can be used to slide any kind of view. We could create a gallery
    of images with `ViewPager`; it is very common to see tutorials in the first run
    of some apps where you can slide the screen with instructions on how the app works,
    and this is achieved with `ViewPager`. To add `ViewPager` to `MainActivity`, we
    can simply copy and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the *ViewPager* section, we will see how to use different third
    party libraries to improve the experience with tabs and also how to create these
    tabs manually in case we want our custom solution.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ViewPager` works with an adapter; the adapter is the element in charge of
    creating every *page* that we swipe. In the particular case of swiping fragments,
    there are extensions of the `Adapter` class called `FragmentPagerAdapter` and
    `FragmentStatePagerAdapter` that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FragmentStatePagerAdapter` saves the state of the page, destroys it when it
    does not appear on screen, and recreates it when necessary, similar to what `ListView`
    does with its rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FragmentPagerAdapter` keeps all the pages in memory; therefore, it doesn''t
    have the computing cost associated with saving and restoring the state while swiping.
    The number of pages we can have depends on the memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the number of elements, we can choose one or the other. If we were
    creating an app to read the news, where you could swipe between lots of news articles
    with images and different content, we wouldn't try to have all of them in the
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: We have three fixed tabs, so we will choose `FragmentPagerAdapter`. We will
    create a package adapter and create a `MyPagerAdapter` class that will extend
    `FragmentPagerAdapter`. While extending it, we are asked to override the `getCount()`
    and `getItem(int i)` methods, which return the count of the items and return an
    item in a given position.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a constructor and completing the methods, our class will look
    similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, we need to set the adapter to the pager in `MainActivity`. Execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sliding tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in our example, we are able to swipe between our fragments. Now,
    we will add tabs using `PagerTabStrip` or `PagerTitleStrip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a very elegant way to achieve this, which is including `PageTabStrip`
    in the XML tag of `ViewPager`. Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `PagerTabStrip` will find the tile of the page, and for each page, it
    will display a tab. We need to add the `getPageTitle` method in `MyPagerAdapter`,
    which will return a string for every page. In our case, this would be the name
    of the sections: list, contacts, and settings. For this, you can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app, and voila! We have a fluent tab and sliding navigation supporting
    Android 1.6 (API 4) implemented really easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sliding tabs](img/B04887_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Customizing tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a long story behind tabs in Android; initially, tabs were implemented
    with `TabActivity` but this was deprecated in API 13 and evolved into `FragmentTabHost`.
  prefs: []
  type: TYPE_NORMAL
- en: So, I happily developed an app with `TabHost` following the Android documentation,
    and I realized this had to be changed. At first, I crossed my fingers hoping that
    the deprecation wouldn't affect my app until some users complained about crashes.
    Then, inevitably, I had to remove my deprecated `TabHost` and find a new way.
  prefs: []
  type: TYPE_NORMAL
- en: At first, `FragmentTabHost` seemed a good way to have fixed tabs, but it didn't
    allow tabs with icons on them. Upon having this problem and finding other people
    with the same problem in Stack Overflow at [http://stackoverflow.com/](http://stackoverflow.com/)
    (a website where we can ask questions and find answers on Android and other topics),
    I decided to find another way.
  prefs: []
  type: TYPE_NORMAL
- en: In API 11, the concept of `ActionBar.Tab` appeared, which was a class that allowed
    us to add tabs to the action bar. Finally, I found a way to have tabs in my app,
    which resulted in happy users! But this joy didn't last for long; `ActionBar.Tab`
    was deprecated again!!
  prefs: []
  type: TYPE_NORMAL
- en: This is something that would end up the patience of any developer; this made
    me create my own tabs as buttons in `LinearLayout`. Setting a click listener on
    the buttons and when clicking on a tab I was swiping the `ViewPager` to the right
    page, and the other way around, when detecting a page swipe on the `ViewPager`
    I was selecting the right tab. It was worth the effort because it allowed me to
    have all the freedom that I wanted with the tabs design, and more importantly
    gave me the satisfaction that it would always work (unless one day they deprecate
    `LinearLayout` or `Button`!).
  prefs: []
  type: TYPE_NORMAL
- en: You can always leave your own implementation as the last option. Nowadays, if
    you don't like the sliding tabs design, you have other alternatives from third-party
    libraries, such as `ViewPagerIndicator` and `PagerSlidingTabStrip`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about this, you can check out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/JakeWharton/ViewPagerIndicator](https://github.com/JakeWharton/ViewPagerIndicator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/astuetz/PagerSlidingTabStrip](https://github.com/astuetz/PagerSlidingTabStrip)'
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Small details such as creating our own animations from the screen transitions
    will polish our app and really make it look more professional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example is perfect to talk about transitions as we have two types of screen
    transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a transition between Activities, from `SplashActivity` to `MainActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one (not implemented yet) is a transition between fragments, where
    `ListFragment` is replaced with `DetailsFragment`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the transitions between activities, we need to call `overridePendingTransition`
    just before starting the new activity. The method receives two animations as parameters,
    and these animations can be in an XML file created by us or be chosen from the
    already created animations in Android. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we don''t allow back navigation to `SplashActivity`; however,
    if we were in a transition between activities where we wanted to have the same
    transition when we click on back, we would have to override the back key press
    and set our transition there. For this, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of fragments, we need to specify the transition in the `FragmentTransaction`
    object. Using the object animator, we can define this in two files: `enter.xml`
    and `exit.xml`. Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For Android Lollipop and the later versions, you can set the transition directly
    to the Fragment. Use the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of this chapter, you should have an understanding of the basic navigation
    patterns and be able to translate the idea of an app in your mind into the real
    structure of an Android app. Fragments are a key concept in Android development,
    and we have spent enough time in this chapter mastering them with a review of
    Fragment Manager and the fragments back stack and by learning how to face common
    problems such as communication between them. We considered a working example of
    `ViewPager` with `PagerTabStrip` showing the tile of the pages as tabs, which
    you now know how to customize if needed. We have a skeleton of an app; this project
    can be saved at this stage and used as a template for your future developments.
    We are ready to continue evolving our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create and access the content that will
    populate our fragments and `ViewPager` to bring our app to life.
  prefs: []
  type: TYPE_NORMAL
