- en: Chapter 2. Hello, Platforms!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with developing applications using Visual Studio on Windows,
    then using Xamarin Studio should be very straightforward. Xamarin uses the same
    concept of a **solution** containing one or more **projects**, and it has created
    several new project types for iOS and Android applications. There are also several
    project templates to jump-start your development of common applications.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin Studio supports several out-of-the-box project types, including standard
    .NET class libraries and console applications. You cannot natively develop Windows
    applications on a Mac with Xamarin Studio, but you can certainly develop the shared
    code portion of your application in Xamarin Studio. We'll focus on sharing code
    in the later chapters, but keep in mind that Xamarin enables you to share a common
    C# backend between most platforms that support C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple calculator application for iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple's MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode and storyboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a calculator application for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin's Android designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your first iOS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launch Xamarin Studio and start a new solution. Just like in Visual Studio,
    there are lots of project types that can be created from the **New Solution**
    dialog. Xamarin Studio, formerly **MonoDevelop**, supports the development of
    many different types of projects such as C# applications targeting the Mono runtime
    or .NET Core, NUnit test projects, and even other languages besides C#, such as
    VB or C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin Studio supports the following project types for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single View App**: This is the basic project type that sets up an iOS storyboard
    along with a single view and controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master Detail App**: a project type containing a list of items that you can
    tap to view details about. On iPhone/iPod it will use multiple controls taking
    up the full screen area and the iOS `UISplitViewController` on iPad.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tabbed App**: This is a project type that automatically sets up a `UITabViewController`
    for applications with a tab layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page-Based App**: This project type automatically sets up a `UIPageViewController`
    for paging between screens as a carousel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebView App**: This project type is for creating "hybrid" applications that
    are partially HTML and partially native. The application is set up to take advantage
    of the Razor templating features of Xamarin Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Library**: This is a class library used within other iOS application
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bindings Library**: This is an iOS project that can create C# bindings for
    an Objective-C library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI Test App**: An NUnit test project for running UI tests either locally
    or on Xamarin Test Cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Test App**: This is a special iOS application project that can run NUnit
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, create a new solution and navigate to **iOS** | **App**, and
    create a **Single View App** as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your first iOS application](img/image00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Visual Studio, you can create the correct type of project from **Visual C#
    | iOS | Universal | Single View App** in the new solution dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we will need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an **App Name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an **Organizational Identifier**, which is a "reverse" domain name to
    uniquely identify your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select which iOS devices you want to support; you can keep the default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the minimum iOS version you want to support; you can keep the default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, on the last step, choose a directory to put your project and click
    **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Visual Studio, these settings are available by opening **Project Options**
    for the iOS project. Xamarin Studio has additional steps in its new project dialog,
    but you can always edit these settings after the fact.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that several files and folders are automatically created from
    the project template. These files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`References`: These are the standard references to other libraries you know
    and love from .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Components`: This folder will contain any components added from the Xamarin
    Component store. See [Chapter 9](part0073.xhtml#aid-25JP21 "Chapter 9. Web Services
    with Push Notifications"), *Web Services with Push Notifications*, for more info
    about the Xamarin Component store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources`: This directory will contain any images or plain files that you
    want to be copied directly to your application bundle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppDelegate.cs`: This is Apple''s main class for handling application-level
    events in your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entitlements.plist`: This is a settings file Apple uses to declare permissions
    for certain iOS features such as push notifications and iCloud. You will generally
    only have to use it for advanced iOS features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*ViewController.cs`: This is the controller that represents the first screen
    in your app. It will have the same name as your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Info.plist`: This is Apple''s version of a **manifest** file that can declare
    various settings for your application such as the app title, icon, splash screens,
    and other common settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LaunchScreen.storyboard`: This is a storyboard file for laying out the splash
    screen for your application. By default, Xamarin''s project template puts the
    name of your project here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Main.cs`: This file contains the standard entry point for a C# program: `static
    void Main()`. It''s most likely that you will not need to modify this file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainStoryboard.storyboard`: This is the storyboard definition file for your
    application. It will contain the layouts for the views in your app, list of controllers,
    and the transitions for navigating throughout your app. A storyboard is exactly
    how it sounds: a diagram/flowchart of the different screens in your iOS application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s run the application to see what we get by default from the project
    template. Click on the large play button in the top-left corner of Xamarin Studio.
    You will be greeted by the simulator running your first iOS application as seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your first iOS application](img/image00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So far, your app is just a plain white screen, which is not very exciting or
    useful. Let's get a little more background on iOS development before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your application's minimum iOS target, you can also run the application
    on different versions of the iOS simulator. Apple also provides simulators for
    iPad and all the different iOS devices currently in the market. It is also important
    to know that these are simulators and not emulators. An emulator will run an encapsulated
    version of the mobile OS (just as Android does). Emulators generally exhibit slower
    performance but give you a closer replica of the real OS. Apple's simulators run
    as native Mac applications and are not true operating systems. The benefit is
    that they are very fast in comparison to Android emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Apple's MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting too far with iOS development, it is really important to get a
    foundation on Apple's design pattern for developing on iOS. You might have used
    the **Model View Controller (MVC)** pattern with other technologies such as **ASP.NET**,
    but Apple implements this paradigm in a slightly different way. Apples core set
    of APIs for developing UIs for iOS applications is called UIKit. Xamarin applications
    can take full advantage of UIKit by directly using these APIs from C#. UIKit is
    heavily based on the MVC design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **MVC** design pattern includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This is the backend business logic driving the application. This
    can be any code that, for example, makes web requests to a server or saves data
    to a local **SQLite** database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This is the actual user interface seen on the screen. In iOS terms,
    this is any class that derives from `UIView`. Examples are toolbars, buttons,
    and anything else the user would see on the screen and interact with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This is the workhorse of the **MVC** pattern. The controller
    interacts with the **Model** layer and updates the **View** layer with the results.
    Similar to the **View** layer, any controller class would derive from `UIViewController`.
    This is where a good portion of the code in iOS applications resides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the MVC design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Apple''s MVC pattern](img/image00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand this pattern better, let''s walk through the following example
    of a common scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: We have an iOS application with a search box that needs to query a website for
    a list of jobs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user will enter some text into the `UITextField` textbox and click on the
    `UIButton` button to start the search. This is the **View** layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some code will respond to the button by interacting with the **View**, display
    a `UIActivityIndicatorView` spinner, and call a method in another class to perform
    the search. This is the **Controller** layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A web request will be made in the called class and a list of jobs will be returned
    asynchronously. This is the **Model** layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Controller** will then update the **View** with the list of jobs and hide
    the spinner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on Apple's MVC pattern, see the documentation site at [https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/MVC.html](https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/MVC.html).
  prefs: []
  type: TYPE_NORMAL
- en: A point to note is that you are free to do anything you want in the model layer
    of your application. This is where we can use plain C# classes that can be reused
    on other platforms such as Android. This includes any functionality using the
    C# **Base Class Libraries** (**BCL**), such as working with web services or a
    database. We'll dive deeper into cross-platform architecture and code-sharing
    concepts later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Using the iOS designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our plain white application is quite boring, let's modify the view layer
    of our application with some controls. To do this, we will modify the `MainStoryboard.storyboard`
    file in your project in Xamarin Studio or Visual Studio. Optionally, you can open
    the storyboard file in Xcode, which was previously the method of editing storyboard
    files before the Xamarin.iOS designer. Using Xcode could still be useful if there
    is a feature in iOS storyboards which isn't available in the Xamarin designer,
    or if you need to edit an older iOS format such as XIB files. However, Xcode is
    not quite as good of an experience, since custom controls in Xcode render as plain,
    white squares. Xamarin's designer actually runs your drawing code in custom controls,
    so that you get an accurate view of what your application will look like at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some controls to our app by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project you created earlier in this chapter in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The iOS designer will open, and you will see the layout for the single controller
    in your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Document Outline** tab on the right, you'll see that your controller
    contains a single view in its layout hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-left corner, you'll notice a toolbox containing several types of
    objects that you can drag-and-drop onto your controller's view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, search for `UILabel` and drag the label centered at the top
    of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the label to edit the text of the label to the number zero (**0**).
    You can also fill out this value from the **Properties** tab in the bottom right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, search for `UIButton` and create 10 buttons numbered **0-9** to create
    a number pad. You may edit the text on the button by using the **Properties**
    tab. You can also use **Copy/Paste** to speed up creating them. Double-clicking
    the button would add a click event handler, which you might be familiar with from
    Visual Studio when developing for other platforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your application should start looking a lot more like a real application (a
    calculator) as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the iOS designer](img/image00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Visual Studio on Windows, these steps are identical to Xamarin Studio on
    a Mac. Keep in mind that you must remain connected to a Mac on your local network
    to use the Xamarin.iOS designer. Instructions for connecting to a Mac are in [Chapter
    1](part0015.xhtml#aid-E9OE1 "Chapter 1. Xamarin Setup"), *Xamarin Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: Now you might be wondering about adding user interaction options to the app
    at this point. In Xcode's iOS designer, you would make an **outlet** that makes
    each view visible from C#. An outlet is a reference to a view in a storyboard
    or XIB file that will be filled out with an instance of the view at runtime. You
    can compare this concept to naming a control in other technologies such as **ASP.NET**,
    **WebForms**, or **WPF** (**Windows Presentation Foundation**). Luckily Xamarin's
    iOS designer is a bit simpler than setting up an outlet in Xcode. You merely fill
    out the **Name** field in the **Properties** tab, and Xamarin Studio will generate
    a property in a **partial class**, which gives you access to the label and button
    from your controller. Additionally, you can wire an **action** from a storyboard
    file, which is a method that will be called when an event occurs. Xamarin Studio
    exposes iOS actions as partial methods to be implemented in your classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some interactions to the app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `MainStoryboard.storyboard` file again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the label you created earlier and navigate to the **Properties** pane
    and make sure you have the **Widget** tab selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `label` in the **Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new button with the text **+** for addition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the **Events** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `OnAdd` into its **Up Inside** field. You can remember this as
    the "click" event for the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Xamarin Studio will direct you on where to place the `OnAdd` method in your
    `UIViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for each of the number buttons, but name the **Up Inside**
    event `OnNumber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new button with the text **=** for the calculator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the **Events** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `OnEquals` into its **Up Inside** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Xamarin has improved this experience greatly from what the experience used to
    be in Xcode. Xcode has a strange interface for those more familiar with tools
    like Visual Studio. The method for creating an outlet involved clicking and dragging
    from the control onto an Objective-C header file. Merely filling out a **Name**
    field is much simpler and much more intuitive for developers that have a C# background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have two outlets defined, two new properties will be available
    from your controller. Expand the `*ViewController.cs` file in your solution and
    open the `*ViewController.designer.cs` file. You will see your properties defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is not a good idea to modify this file since the IDE will rebuild it if you
    make further changes in the designer or Xcode. Nevertheless, it is good practice
    to learn how things are actually working behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `*ViewController.cs` file, and let''s enter the following code in
    your controller''s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is just general C# logic for making a calculator operate.
    In the `OnAdd` method we append a `+` symbol if the label's text is non-empty.
    In the `OnNumber` method we replace or append to the label's text appropriately.
    Finally, in the `OnEquals` method we calculate the expression residing in the
    label with a string split operation and integer conversion. We then place the
    result in the label's text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your application, and you will be able to interact with your calculator
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the iOS designer](img/image00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now would be a good time to complete this exercise on your own and finish the
    calculator. Adding buttons for subtraction, multiplication, division, and a "clear"
    button would complete the simple calculator. This should get you a handle on working
    with Apple's APIs for `UIButton`, `UILabel`, and basics of the UIKit framework.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have gone over the basics of laying out controls in Xamarin's iOS designer
    and interacting with outlets in C#, let's go over the standard life cycle of an
    iOS application. The primary location for handling application-level events is
    in the `AppDelegate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open your `AppDelegate.cs` file, you can override the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FinishedLaunching`: This is the first entry point for the application, which
    should return `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidEnterBackground`: This means the user clicked on the home button on their
    device or another app, such as a phone call, came to the foreground. You should
    perform any action needed to save the user''s progress or state of the UI as the
    iOS may kill your application once pushed to the background. While your application
    is in the background, the user could be navigating through the home screen or
    opening other apps. Your application is effectively paused in memory until resumed
    by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WillEnterForeground`: This means the user has reopened your application from
    the background. You might need to perform other actions here such as refreshing
    the data on the screen and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnResignActivation`: This happens if the operating system displays a system
    popup on top of your application. Examples of this are calendar reminders or the
    menu the user can swipe down from the top of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActivated`: This happens immediately after the `OnResignActivation` method
    is executed as the user returns to your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReceiveMemoryWarning`: This is a warning from the operating system to free
    up the memory in your application. It is not commonly needed with Xamarin because
    of the C#''s garbage collector, but if there are any heavy objects such as images
    throughout your app, this is a good place to dispose them. If enough memory cannot
    be freed, the operating system could terminate your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandleOpenUrl`: This is called if you implement a **URL scheme**, which is
    the iOS equivalent of file extension associations on a desktop platform. If you
    register your app for opening different types of files or URLs, this method will
    be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Likewise, in your `*ViewController.cs` file, you can override the following
    methods on your controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewDidLoad`: This occurs when the view associated with your controller is
    loaded. It will occur only once on devices running iOS 6 or higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewWillAppear`: This occurs prior to your view appearing on the screen. If
    there are any views that need to be refreshed while navigating throughout your
    app, this is generally the best place to do it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewDidAppear`: This occurs after the completion of any transition animations
    and your view is displayed on the screen. In some uncommon situations, you might
    need to perform actions here instead of in `ViewWillAppear`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewWillDisappear`: This method is called prior to your view being hidden.
    You might need to perform some clean-up operations here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewDidDisappear`: This occurs after any transition animations are completed
    for displaying a different controller on the screen. Just like the methods for
    appearing, this occurs after `ViewWillDisappear`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several more methods available to override, but many are deprecated
    for newer versions of iOS. Familiarize yourself with Apple's documentation site
    at [http://developer.apple.com/library/ios](http://developer.apple.com/library/ios).
    It is very helpful to read the documentation on each class and method when trying
    to understand how Apple's APIs work. Learning how to read (not necessarily code)
    Objective-C is also a useful skill to learn so that you are able to convert Objective-C
    examples to C# when developing iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first Android application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up an Android application in Xamarin Studio is just as easy as it is
    for iOS and is very similar to the experience in Visual Studio. Xamarin Studio
    includes several project templates that are specific for Android to jump-start
    your development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin Studio includes the following project templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android App**: A standard Android application that targets the newest Android
    SDKs installed on your machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wear App**: A project targeting Android Wear, for smartwatch devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebView App**: A project template for a hybrid app using HTML for certain
    parts. Support for Razor templating is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Library**: A class library that can only be referenced by Android application
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bindings Library**: A project for setting up a Java library to be called
    from C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI Test App**: an NUnit test project for running UI tests either locally
    or on Xamarin Test Cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Test App**: This is a special Android application project that can run
    NUnit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch Xamarin Studio and start a new solution. From the **New Solution** dialog,
    create a new **Android App** under the **Android** section. Select
  prefs: []
  type: TYPE_NORMAL
- en: 'You will end up with a solution looking something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your first Android application](img/image00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Visual Studio, the Android project template is found under **Android | Blank
    App**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the following files and folders specific to Android have
    been created for you:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Components` folder. This is the same as for iOS projects, the place for
    adding components from the Xamarin Component Store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Assets` folder: This directory will contain files with a `build` action
    of `AndroidAsset`. This folder will contain raw files to be bundled with an Android
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Properties/AndroidManifest.xml`: This file contains standard declarations
    about your Android applications, such as the application name, ID, and permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Resources` folder: Resources are images, layouts, strings, and so on that
    can be loaded via Android''s resource system. Each file will have an ID generated
    in `Resources.designer.cs` that you can use to load the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Resources/drawable` folder: Any images used by your application are generally
    placed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Resources/layout` folder: This contains any `*.axml` (Android XML) files
    that Android uses for declaring UIs. Layouts can be for an entire **activity**,
    **fragment**, **dialog**, or **child control** to be displayed on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources/mipmap-*` folders: Contain icons for your application to be displayed
    on different Android devices'' home screens. App icons in these because they are
    used at resolutions different from the device''s current density.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Resources/values` folder: This contains XML files to declare key-value
    pairs for strings (and other types) throughout an application. This is how localization
    for multiple languages is normally set up on Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainActivity.cs`: This is the `MainLauncher` action and the first activityof
    your Android application. There is no `static void Main` function in Android apps;
    execution begins on the activity that has `MainLauncher` set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s perform the following steps to run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the play button to compile and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **Select Device** dialog may appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the emulator of your choice and click on **Start Emulator**. If you have
    set up the x86 emulator in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Xamarin
    Setup"), *Xamarin Setup*, I would recommend using it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait a few seconds for the emulator to start. Once it starts, it is a good idea
    to leave it running as long as you are working on an Android project. This will
    save you a good deal of time waiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the emulator now enabled in the list of devices; select it, and
    click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The very first time you deploy to an emulator or device, Xamarin Studio will
    have to install a few things such as the Mono shared runtime and Android platform
    tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch over to the Android emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your application will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Visual Studio on Windows, you might also try using the **Visual Studio Emulator
    for Android**. It is a nice emulator that comes preinstalled with Visual Studio
    2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all is done, you have deployed your first Android application, complete
    with a single button. Your app will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your first Android application](img/image00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding Android activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android operating system is very focused on the concept of an activity.
    An activity is a task or unit of work that users can perform on their screen.
    For example, users would perform a **phone activity** for dialing a number and
    carry out a second activity for interacting with their address book to locate
    the number. Each Android application is a collection of one or more activities
    that users can launch and press the hardware's back key on their device to exit
    or cancel. The user's history is kept in the Android **back stack**, which you
    can manipulate from code in special cases. When a new activity starts, the previous
    one is paused and maintained in memory for later use, unless the operating system
    is running low on memory.
  prefs: []
  type: TYPE_NORMAL
- en: Activities are loosely coupled with each other; in some ways, you can think
    of them as having completely separate states from one another in memory. Static
    classes, properties, and fields will persist the life of the application, but
    the common practice is to pass a state in an Android **bundle**. This is useful
    for passing an identifier for an item displayed in a list to edit that item in
    a new activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activities have the following lifecycle callback methods that you can override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnCreate`: This is the first method called when your activity is created.
    Set up your views and perform other loading logic here. Most importantly, you
    will call `SetContentView` here to set up your activity''s view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnResume`: This is called when your activity''s view is visible on the screen.
    It is called if your activity is displayed for the first time, and when the user
    returns to it from another activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPause`: This is called to notify that the user has left your activity. It
    can happen prior to navigating to a new activity within your app, locking the
    screen, or hitting the home button. Assume that the user may not return, so you
    need to save any changes the user made here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStart`: This occurs immediately before `OnResume` when the activity''s view
    is about to be displayed on the screen. It occurs when an activity starts and
    when a user returns to it from another activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStop`: This occurs immediately after `OnPause` when the activity''s view
    is no longer displayed on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnRestart`: This method occurs when the user returns to your activity from
    a previous activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActivityResult`: This method is used for communicating with other activities
    in other applications on Android. It is used in conjunction with `StartActvityForResult`;
    for example, you would use this to interact with the Facebook application to log
    in a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDestroy`: This is called when your activity is about to be freed from memory.
    Perform any additional clean-up that could help the operating system here, such
    as disposing of any other heavyweight objects the activity was using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A flowchart of the Android lifecycle is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Android activities](img/image00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike iOS, Android does not enforce any design patterns upon its developers.
    However, it is not possible to make it by without understanding the Android activity
    lifecycle to some degree. Many concepts with activities have a parallel to controllers
    on iOS; for example, `OnStart` is equivalent to `ViwWillAppear` and `OnResume`
    is equivalent to `ViewDidAppear`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other methods of note for working with activities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StartActivity(Type type)`: This method starts a new activity within your application
    and passes no extra information to the activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartActivity(Intent intent)`: This is an overload method for starting a new
    activity with `Intent`. This gives you the ability to pass additional information
    to the new activity, and you can also launch activities in other applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartActivityForResult`: This method starts a new activity with the anticipation
    of receiving `OnActivityResult` when the activity''s operation is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Finish`: This will close the current activity and invoke `OnDestroy` when
    it is completely closed and no longer displayed on the screen. Depending on what
    is currently on the back stack, the user will return to a previous activity or
    the home screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetContentView`: This method sets the primary view to be displayed for an
    activity. It should be called within the `OnCreate` method prior to the activity
    being displayed on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindViewById`: This is a method for locating the view displayed in your activity.
    It has a generic version for returning a view of the appropriate type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of `intent` as an object that describes the transition from one
    activity to another. You can pass additional data through intents as well as modify
    how the activity is displayed and the user's navigation history.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to activities, Android has the concept of a fragment. You can think
    of a fragment to be a miniature activity that is displayed inside a parent activity.
    Fragments are useful for reusing different pieces of a UI throughout your apps
    and can also help you implement split screen navigation on tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin's Android designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default template for Android projects has a little more built-in functionality
    than iOS, so we will have a few controls to remove later. Android user interface
    layouts are defined in XML files that are readable by humans and editable. However,
    Xamarin Studio has provided an excellent design tool that allows you to drag-and-drop
    controls to define your Android layouts. Let's add some more features to your
    application and start using the Android designer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to Xamarin Studio and carry out the following steps to add features
    to your app:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Android project you created earlier in this chapter in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Resources** | **layout** in your project, open `Main.axml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see the Android designer open in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the existing label and button from the Android project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **TextView** from the **Toolbox** section on the right to the empty layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type some default text such as `0` into the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** pane on the right, you'll see the **id** value is set
    to `@+id/textView1`. Let's change it to `@+id/text` so we can later interact with
    the label in C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now drag a **GridLayout** from the **Toolbox** section and under the **Properties**
    panel set **Row Count** to 4 and **Column** to 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag 10 **Button** widgets from the **Toolbox** section and number their text
    **0-9**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set their **id** to `@+id/button0` numbered from **0-9.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two more buttons with ids `@+id/plus` and `@+id/equals`, with their text
    set to **+** and **=** respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Visual Studio, the Xamarin.Android designer is mostly identical to its Xamarin
    Studio counterpart. The main difference is when editing the properties on a control,
    the standard Visual Studio properties editor is used. You may find it useful to
    toggle between **A to Z** and grouped sorting via the toolbar buttons in the **Properties**
    pane.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you try to compile and run your application, you will notice some compiler
    errors. For now, open `MainActivity.cs` and remove the code in the `OnCreate`
    method with the exception of the line calling `SetContentView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `MainActivity` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch your Android application and it should look identical to the changes
    you made in the designer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin''s Android designer](img/image00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Switch back to Xamarin Studio and open `MainActivity.cs`. Let's modify the activity
    to interact with the layouts we set up in the Xamarin.Android designer. We use
    the `FindViewById` method to retrieve a view by the ID we set up in the layout
    file. Xamarin Studio has also auto-generated a static class named `Resource` for
    referencing your identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First declare a class-level private field in `MainActivity.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s retrieve the instance of the **TextView** field by placing this code
    in `OnCreate` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Resource` class is a static class that the Xamarin designer will populate
    for you. For future reference, you may have to build your Android project for
    new IDs and other resources to show up in your C# files in Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method we''ll use for click events, somewhere in `MainActivity.cs`,
    it will look very similar to what we did on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s wire up the `Click` event for `number1` in your activity''s `OnCreate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this code for all number buttons **0-9**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s set up event handlers for the "add" and "equals" buttons as we
    did in the iOS app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s wire up the `Click` event for these buttons in your activity''s
    `OnCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run the application, we''ll get an Android app that functions identically
    to the iOS calculator shown previously in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin''s Android designer](img/image00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our first iOS application in Xamarin Studio. We
    covered Apple's MVC design pattern to better understand the relationship between
    `UIViewController` and `UIView` and also covered how to use the iOS designer in
    Xamarin Studio for editing storyboard files. Next, we created our first Android
    application in Xamarin Studio and learned the activity lifecycle in Android. We
    also used Xamarin's Android designer to make changes to Android XML layouts.
  prefs: []
  type: TYPE_NORMAL
- en: From the topics covered in this chapter, you should be fairly confident in developing
    simple apps for iOS and Android using Xamarin's tools. You should have a basic
    understanding of the native SDKs and design patterns to accomplish tasks on iOS
    and Android.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover various techniques for sharing code across
    platforms with Xamarin Studio. We'll go over different ways for architecting your
    cross-platform application and how to set up projects and solutions for use in
    either Visual Studio or Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
