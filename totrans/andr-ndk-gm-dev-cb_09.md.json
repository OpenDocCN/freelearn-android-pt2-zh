["```kt\n    class clTile\n    {\n    public:\n      int   FOriginX, FOriginY;\n      vec2  FCur, FTarget;\n      LRect FRect;\n      clTile(): FOriginX( 0 ), FOriginY( 0 ) {};\n    ```", "```kt\n      clTile( int OriginX, int OriginY, int Columns, int Rows ): FOriginX( OriginX )\n      , FOriginY( OriginY )\n      {\n    ```", "```kt\n        float TileWf = 1.0f / Columns, TileHf = 1.0f / Rows;\n        float X1f = TileWf * ( OriginX + 0 );\n        float X2f = TileWf * ( OriginX + 1 );\n        float Y1f = TileHf * ( OriginY + 0 );\n        float Y2f = TileHf * ( OriginY + 1 );\n        FRect = LRect( X1f, Y1f, X2f, Y2f );\n        FTarget = FCur = vec2( OriginX, OriginY );\n      }\n    ```", "```kt\n      void SetTarget( int X, int Y )\n      { FTarget = vec2( X, Y ); }\n      void MoveTo( float X, float Y )\n      { FCur.x = X; FCur.y = Y; };\n    ```", "```kt\n      void Update( float dT )\n      {\n        vec2 dS = FTarget - FCur;\n        const float c_Epsilon = 0.001f;\n        if ( fabs( dS.x ) < c_Epsilon )\n        {\n          dS.x = 0;\n          FCur.x = FTarget.x;\n        }\n        if ( fabs( dS.y ) < c_Epsilon )\n        {\n          dS.y = 0;\n          FCur.y = FTarget.y;\n        }\n        const float Speed = 10.0f;\n        FCur += Speed * dT * dS;\n      }\n    };\n    ```", "```kt\n    class clPuzzle\n    {\n    public:\n      mutable std::vector<clTile> FTiles;\n      int FColumns, FRows;\n      bool FMovingImage;\n      int FClickedI, FClickedJ;\n      float FOfsX, FOfsY;\n\n      clPuzzle()\n      : FMovingImage( false )\n      , FClickedI( -1 ), FClickedJ( -1 )\n      , FOfsX( 0.0f ), FOfsY( 0.0f )\n      {\n        Retoss( 4, 4 );\n      }\n    ...\n    ```", "```kt\n      void SwapTiles( int i1, int j1, int i2, int j2 )\n      {\n        std::swap( FTiles[j1 * FColumns + i1],FTiles[j2 * FColumns + i2] );\n      }\n    };\n    ```", "```kt\n    bool clPuzzle::IsComplete() const\n    {\n      for ( int i = 0; i != FColumns; i++ )\n      {\n        for ( int j = 0; j != FRows; j++ )\n        {\n          clTile* T = GetTile( i, j );\n          if ( T->FOriginX != i || T->FOriginY != j)\n            return false;\n        }\n      }\n      return true;\n    }\n    ```", "```kt\n    void clPuzzle::Timer( float DeltaSeconds )\n    {\n      for ( int i = 0; i != FColumns; i++ )\n      {\n        for ( int j = 0; j != FRows; j++ )\n          GetTile( i, j )->Update( DeltaSeconds );\n      }\n    }\n    ```", "```kt\n    void Puzzle::Retoss(int W, int H)\n    {\n      FColumns = W;\n      FRows    = H;\n      FTiles.resize( FColumns * FRows );\n    ```", "```kt\n      for ( int i = 0; i != FColumns; i++ )\n        for ( int j = 0; j != FRows; j++ )\n          FTiles[j * FColumns + i] =clTile( i, FRows - j - 1, FColumns, FRows );\n    ```", "```kt\n      for ( int i = 0; i != FColumns; i++ )\n      {\n        for ( int j = 0; j != FRows; j++ )\n        {\n          int NewI = Math::RandomInRange( i, FColumns - 1 );\n          int NewJ = Math::RandomInRange( j, FRows - 1    );\n          SwapTiles( i, j, NewI, NewJ );\n        }\n      }\n      …\n    }\n    ```", "```kt\n    void Puzzle::OnKey( float mx, float my, bool KeyState )\n    {\n      int i = (int)floor( mx * FColumns );\n      int j = (int)floor( my * FRows );\n      int MouseI = ( i >= 0 && i < FColumns ) ? i : -1;\n      int MouseJ = ( j >= 0 && j < FRows ) ? j : -1;\n      FMovingImage = KeyState;\n      if ( FMovingImage )\n      {\n        FClickedI = MouseI;\n        FClickedJ = MouseJ;\n\n        if ( FClickedI >= 0&& FClickedJ >= 0&& FClickedI < FColumns&& FClickedJ < FRows )\n        {\n          FOfsX = ( ( float )FClickedI / FColumns - mx );\n          FOfsY = ( ( float )FClickedJ / FRows    - my );\n        }\n        else\n        {\n          FClickedI = FClickedJ = -1;\n        }\n      }\n      else\n    ```", "```kt\n      {\n        bool NewPosition = ( MouseI != FClickedI ||MouseJ != FClickedJ );\n        bool ValidPosition1 = ( FClickedI >= 0 && FClickedJ >=0 && FClickedI < FColumns && FClickedJ < FRows );\n        bool ValidPosition2 = ( MouseI >= 0 && MouseJ >= 0 &&MouseI < FColumns && MouseJ < FRows );\n        if ( NewPosition && ValidPosition1 && ValidPosition2 )\n        {\n          int dX = MouseI - FClickedI;\n          int dY = MouseJ - FClickedJ;\n          SwapTiles( FClickedI, FClickedJ, MouseI, MouseJ );\n        }\n        if ( IsComplete() )\n        {\n          // TODO: We've got a winner!\n        }\n        FClickedI = FClickedJ = -1;\n      }\n    }\n    ```", "```kt\nvoid RenderGame( clPuzzle* g, const vec4& Color )\n{\n```", "```kt\n  if ( g->FMovingImage && g->FClickedI >= 0 &&g->FClickedI >= 0 &&g->FClickedI < g->FColumns &&g->FClickedJ < g->FRows )\n  {\n    vec2 MCI = Env_GetMouse();\n    int NewI = g->FClickedI;\n    int NewJ = g->FClickedJ;\n    float PosX, PosY;\n    PosX = Math::Clamp( MCI.x + g->FOfsX, 0.0f, 1.0f );\n    PosX *= g->FColumns;\n    PosY = Math::Clamp( MCI.y + g->FOfsY, 0.0f, 1.0f );\n    PosY *= g->FRows;\n    g->GetTile( NewI, NewJ )->MoveTo( PosX, PosY );\n  }\n```", "```kt\n  for ( int i = 0; i != g->FColumns; i++ )\n    for ( int j = 0; j != g->FRows; j++ )\n      DrawTile( g, i, j, Color );\n}\n```", "```kt\nvoid DrawTile( clPuzzle* g, int i, int j, const vec4& Color )\n{\n  if ( i < 0 || j < 0 || i >= g->FColumns || j >= g->FRows )\n  { return; }\n  clTile* Tile = g->GetTile( i, j );\n  Tile->SetTarget( i, j );\n  float X = Tile->FCur.x;\n  float Y = Tile->FCur.y;\n  float TW = 1.0f / g->FColumns;\n  float TH = 1.0f / g->FRows;\n  vec4 TilePosition(TW * ( X + 0 ), TH * ( Y + 0 ),TW * ( X + 1 ), TH * ( Y + 1 ) );\n  g_Canvas->TexturedRectTiled(TilePosition, 1.0f, 1.0f, g_Texture,Effect, Color, VA, Tile->GetRect() );\n}\n```", "```kt\n    class Curve\n    {\n    public:\n      Curve() {}\n    ```", "```kt\n      void AddControlPoint( float t, const vec3& Pos )\n      {\n        T.push_back( t );\n        P.push_back( Pos );\n      }\n    ```", "```kt\n      vec3 GetPosition( float t ) const\n      {\n        if ( t <= T[0] ) { return P[0]; }\n        int N = (int)T.size();\n        int i = N - 1;\n        for ( int s = 0 ; s < N - 1 ; s++ )\n        {\n          if ( t > T[s] && t <= T[s + 1] )\n          {\n            i = s;\n            break;\n          }\n        }\n        if ( i >= N - 1 ) { return P[N - 1]; }\n        vec3 k = ( P[i + 1] - P[i] ) / ( T[i + 1] - T[i] );\n        return k * ( t - T[i] ) + P[i];\n      }\n    ```", "```kt\n      std::vector<float> T;\n      std::vector<vec3> P;\n    };\n    ```", "```kt\n    class clFlowUI: public iObject\n    {\n    public:\n      clFlowUI( clPtr<clFlowFlinger> Flinger, int NumQuads )\n      {\n        FFlinger = Flinger;\n    ```", "```kt\n        mtx4 RotationMatrix;\n        RotationMatrix.FromPitchPanRoll( 0.0f, -90.0f, 0.0f );\n        FView = mtx4::GetTranslateMatrix(-vec3( 0.0f, -13.2f, 1.2f ) ) * RotationMatrix;\n    ```", "```kt\n        FProjection = Math::Perspective(45.0f, 1.33333f, 0.4f, 2000.0f );\n        float Y[] = { c_Height, c_Height, 0, 0 };\n        float Offs[] = { -c_PeakOffset, c_PeakOffset,c_PeakOffset, - c_PeakOffset };\n        float Coeff[] ={ c_Slope, - c_Slope, - c_Slope, c_Slope };\n        for ( int i = 0 ; i < 4 ; i++ )\n        {\n          const int c_NumPoints = 100;\n          for ( int j = - c_NumPoints / 2 ;j < c_NumPoints / 2 + 1 ; j++ )\n          {\n            float t = ( float )j * c_PointStep;\n            float P = Coef[i] * ( Ofs[i] - t );\n    ```", "```kt\n            float Mult = c_FlowMult *exp( - c_FlowExp * P * P );\n            vec3 Pt( -t, Mult * c_Elevation *atan( P ) / M_PI, Y[i] );\n            FBaseCurve[i].AddControlPoint(t *exp( c_ControlExp * t * t ), Pt);\n          }\n        }\n        …\n    ```", "```kt\n        FFlinger->FMinValue = 0.0f;\n        FFlinger->FMaxValue = c_OneImageSize *( ( float )FNumImg - 1.0f );\n      }\n    ```", "```kt\n      int GetCurrentImage() const\n      {\n         return\n           (int)ceilf( FFlinger->GetValue() / OneImageSize );\n      }\n    ```", "```kt\n      virtual void QuadCoords( vec3* Pts, float t_center )const\n      {\n        float Offs[] ={ c_QuadSize, - c_QuadSize, - c_QuadSize, c_QuadSize };\n        for ( int i = 0 ; i < 4 ; i++ )\n          Pts[i] = FBaseCurve[i].GetPosition(t_center - Offs[i] / 2 );\n      }\n    ```", "```kt\n      Curve FBaseCurve[4];\n    };\n    ```", "```kt\n    const float c_PointStep = 0.2f;\n    ```", "```kt\n    const float c_ControlExp = 0.001f;\n    ```", "```kt\n    const float c_Height = 4.0f\n    const float c_Elevation = 2.0f;\n    const float c_Slope = 0.3f;\n    ```", "```kt\n    const float c_PeakOffset = 3.0f;\n    const float c_FlowExp = 0.01f;\n    const float c_FlowMult = 4.0f;\n    ```", "```kt\n    class clFlowFlinger: public iObject\n    {\n    public:\n      clFlowFlinger()\n      : FPressed( false ), FValue( 0.0f ), FVelocity( 0.0f ) {}\n      virtual ~clFlowFlinger() {}\n    ```", "```kt\n      virtual bool HandleSelection( float mx, float my ){ return false; }\n    ```", "```kt\n      void Update( float DeltaTime );\n      void OnTouch( bool KeyState );\n    …\n    };\n    ```", "```kt\n    void clFlowFlinger::OnTouch( bool KeyState )\n    {\n      int CurImg = ( int )ceilf( FValue / OneImageSize );\n      vec2 MousePt = Env_GetMouse(); \n      double MouseTime = Env_GetMouseTime();\n      FPressed = KeyState;\n      if ( KeyState )\n      {\n        FClickPoint = FLastPoint = MousePt;\n        FClickedTime = FLastTime  = MouseTime;\n        FInitVal = FValue;\n        FVelocity = 0;\n      }\n      else\n      {\n    ```", "```kt\n        double Time = MouseTime - FClickedTime;\n        double c_TimeThreshold = 0.15;\n        float c_LenThreshold = 0.01f;\n        if ( ( FClickPoint - MousePt ).Length() <c_LenThreshold&& ( Time < c_TimeThreshold ) )\n        {\n          HandleSelection( MousePt.x, MousePt.y );\n          FVelocity = 0;\n          return;\n        }\n    ```", "```kt\n        float c_SpanThreshold = 0.3f;\n        float dT = (float)( MouseTime - FLastTime );\n        float dSx = MousePt.x - FLastPoint.x;\n        FVelocity = ( dT < c_SpanThreshold ) ?-AccelCoeff * dSx / dT : 0;\n      }\n    }\n    ```", "```kt\n    void clFlowFlinger::Update( float DeltaTime )\n    {\n      float NewVal = 0.0f;\n      if ( FPressed )\n      {\n        vec2 CurPoint = Env_GetMouse();\n        NewVal = FInitVal;\n        NewVal -= AccelCoef * ( CurPoint.x - FLastPoint.x );\n      }\n      else\n      {\n        NewVal = FValue + FVelocity * DeltaTime;\n        FVelocity -= FVelocity * c_Damping * DeltaTime;\n    ```", "```kt\n        const float Damper = 4.5f * DeltaTime;\n        if ( NewVal > FMaxValue )\n        {\n          FVelocity = 0;\n          NewVal = FMaxValue * Damper + \n            NewVal * ( 1.0f - Damper );\n        }\n        else if ( NewVal < FMinValue )\n        {\n          FVelocity = 0;\n          NewVal = FMinValue * Damper +NewVal * ( 1.0f - Damper );\n        }\n      }\n      FValue = NewVal;\n    }\n    ```", "```kt\n    const float c_AccelCoeff = 15.0f;\n    const float c_ValueGain =  0.1f;\n    const float c_IntGain   = 0.1f;\n    const float c_DiffGain  = 0.1f;\n    const float c_Damping   = 0.7f;\n    ```", "```kt\nvoid RenderDirect( clPtr<clFlowFlinger> Control )\n{\n  int Num = Control->FNumImg;\n  if ( Num < 1 ) { return; }\n  int CurImg = Control->GetCurrentImage();\n  float Dist = ( float )( Num * c_OneImageSize );\n```", "```kt\n  int ImgOrder[] = {CurImg - 3, CurImg - 2, CurImg - 1,CurImg + 3, CurImg + 2, CurImg + 1,CurImg };\n```", "```kt\n  for ( int in_i = 0 ; in_i < 7 ; in_i++ )\n  {\n    int i = ImgOrder[in_i];\n    if ( i < 0 )\n      { i += ( 1 - ( ( int )( i / Num ) ) ) * Num; }\n    if ( i >= Num )\n      { i -= ( ( int )( i / Num ) ) * Num; }\n    if ( i < Num && i > -1 )\n    {\n      vec3 Pt[4];\n      Control->QuadCoords(Pt,Control->FFlinger->FValue - ( float )(i) *c_OneImageSize);\n      vec3 Q[4];\n      for(int j = 0 ; j < 4 ; j++)\n        Q[j] = Control->FProjection *Control->FView * Pt[j];\n      BoxR(Q, 0xFFFFFF);\n    }\n  }\n}\n```", "```kt\nint clFlowUI::GetImageUnderCursor( float mx, float my ) const\n{\n  if ( FNumImg < 1 ) { return -1; }\n```", "```kt\n  vec3 Pt, Dir;\n  MouseCoordsToWorldPointAndRay( FProjection, FView,mx, my, Pt, Dir );\n  int CurImg = GetCurrentImage();\n  int ImgOrder[] = { CurImg, CurImg - 1, CurImg + 1, CurImg - 2,CurImg + 2, CurImg - 3, CurImg + 3 };\n```", "```kt\n  for ( int cnt = 0 ; cnt < countof( ImgOrder ) ; cnt++ )\n  {\n    int i = ImgOrder[cnt];\n    if ( i < 0 || i >= (int)FNumImg ) { continue; }\n```", "```kt\n    vec3 Coords[4];\n    QuadCoords( Coords, FFlinger->GetValue() –( float )(i) * OneImageSize );\n```", "```kt\n    vec3 ISect;\n    if ( IntersectRayToTriangle( Pt, Dir,Coords[0], Coords[1], Coords[2], ISect ) ||( IntersectRayToTriangle( Pt, Dir,Coords[0], Coords[2], Coords[3], ISect ) ) )\n      return i;\n  }\n  return -1;\n}\n```", "```kt\nvoid SetCurrentImageTarget( int i )\n{ FFlinger->SetTargetValue( ( float )i * ( OneImageSize ) ); }\n```", "```kt\n    class clGUIPage: public iObject\n    {\n    public:\n      clGUIPage(): FFallbackPage( NULL ) {}\n      virtual ~clGUIPage() {}\n\n      virtual void Update(float DeltaTime) {}\n      virtual void Render() {}\n      virtual void SetActive();\n    ```", "```kt\n      virtual bool OnKey( int Key, bool KeyState );\n      virtual void OnTouch( const LVector2& Pos, boolTouchState );\n    ```", "```kt\n      clPtr<clGUIPage> FFallbackPage;\n      …\n    };\n    ```", "```kt\n    class clGUI: public iObject\n    {\n    public:\n      clGUI(): FActivePage( NULL ), FPages() {}\n      virtual ~clGUI() {}\n      void AddPage(const clPtr<clGUIPage>& P)\n      {\n        P->FGUI = this;\n        FPages.push_back(P);\n      }\n      void SetActivePage( const clPtr<clGUIPage>& Page )\n      {\n        if ( Page == FActivePage ) { return; }\n        FActivePage = Page;\n      }\n      void Update( float DeltaTime )\n      {\n        if ( FActivePage ) FActivePage->Update( DeltaTime );\n      }\n      void Render()\n      {\n        if ( FActivePage ) FActivePage->Render();\n      }\n      void OnKey( vec2 MousePos, int Key, bool KeyState )\n      {\n        FMousePosition = MousePos;\n        if ( FActivePage ) FActivePage->OnKey( Key, KeyState );\n      }\n      void OnTouch( const LVector2& Pos, bool TouchState )\n      {\n        if ( FActivePage )FActivePage->OnTouch( Pos, TouchState );\n      }\n    private:\n      vec2 FMousePosition;\n      clPtr<clGUIPage> FActivePage;\n      std::vector< clPtr<clGUIPage> > FPages;\n    };\n    ```", "```kt\n    class clGUIButton: public iObject\n    {\n    public:\n      clGUIButton( const LRect& R, const std::string Title,clPtr<clGUIPage> Page ): FRect(R), FTitle(Title), FPressed(false), FFallbackPage(Page) {}\n\n      virtual void Render();\n      virtual void OnTouch( const LVector2& Pos, boolTouchState );\n    ```", "```kt\n      virtual bool Contains( const LVector2& Pos )\n      {\n        return FRect.ContainsPoint( Pos );\n      }\n    public:\n      LRect       FRect;\n      std::string FTitle;\n      bool        FPressed;\n      clPtr<clGUIPage> FFallbackPage;\n    };\n    ```", "```kt\n  g_GUI = new clGUI();\n  clPtr<clGUIPage> Page_MainMenu = new clPage_MainMenu;\n  clPtr<clGUIPage> Page_Game     = new clPage_Game;\n  clPtr<clGUIPage> Page_About    = new clPage_About;\n```", "```kt\nPage_About → Page_MainMenu\nPage_Game → Page_MainMenu\nPage_MainMenu → exit the application\n```", "```kt\n  Page_Game->FFallbackPage = Page_MainMenu;\n  Page_About->FFallbackPage = Page_MainMenu;\n  g_GUI->AddPage( Page_MainMenu );\n  g_GUI->AddPage( Page_Game );\n  g_GUI->AddPage( Page_About );\n```", "```kt\n  Page_MainMenu->AddButton( new clGUIButton( LRect(0.3f, 0.1f, 0.7f, 0.3f ), \"New Game\", Page_Game  ) );\n  Page_MainMenu->AddButton( new clGUIButton( LRect(0.3f, 0.4f, 0.7f, 0.6f ), \"About\",    Page_About ) );\n  Page_MainMenu->AddButton( new clGUIButton( LRect(0.3f, 0.7f, 0.7f, 0.9f ), \"Exit\",     NULL       ) );\n```", "```kt\n  g_GUI->SetActivePage( Page_MainMenu );\n```", "```kt\nclass clPage_About: public clGUIPage\n{\npublic:\n  virtual void Render()\n  {\n    …\n  }\n};\n```", "```kt\nclass clPage_MainMenu: public clGUIPage\n{\npublic:\n```", "```kt\n  virtual bool OnKey( int Key, bool KeyState )\n  {\n    if ( Key == LK_ESCAPE ) ExitApp();\n    return true;\n  }\n  …\n};\n```", "```kt\nclass clPage_Game: public clGUIPage\n{\npublic:\n  virtual void OnTouch( const LVector2& Pos, bool TouchState )\n  {\n    g_Game.OnKey(Pos.x, Pos.y, TouchState);\n    clGUIPage::OnTouch(Pos, TouchState);\n  }\n  virtual void Update(float DT)\n  {\n    g_Game.Timer( DT );\n  }\n  virtual void Render()\n  {\n    RenderGame(&g_Game);\n    clGUIPage::Render();\n  }\n};\n```", "```kt\n    class sImageDescriptor: public iObject\n    {\n    public:\n      size_t FID;\n      std::string FURL; \n    ```", "```kt\n      LPhotoSize FSize;\n    ```", "```kt\n      LImageState FState;\n\n      clPtr<clGLTexture> FTexture;\n      clPtr<clBitmap> FNewBitmap;\n      sImageDescriptor():\n        FState(L_NOTSTARTED),FSize(L_PHOTO_SIZE_256)\n      {\n        FTexture = new clGLTexture();\n      }\n      void StartDownload( bool AsFullSize );\n      void ImageDownloaded( clPtr<Blob> Blob );\n      void UpdateTexture();\n    };\n    ```", "```kt\n    enum LImageState\n    {\n      L_NOTSTARTED, // not started downloading\n      L_LOADING,    // download is in progress\n      L_LOADED,     // loading is finished\n      L_ERROR       // error occured\n    };\n    ```", "```kt\n    void sImageDescriptor::ImageDownloaded( clPtr<clBlob> B )\n    {\n      if ( !B )\n      {\n        FState = L_ERROR;\n        return;\n      }\n      clPtr<clImageLoadingCompleteCallback> CB =new clImageLoadingComplete( this );\n      clPtr<clImageLoadTask> LoadTask =new clImageLoadTask( B, 0, CB,g_Events.GetInternalPtr() );\n      g_Loader->AddTask( LoadTask );\n    }\n    ```", "```kt\n    void sImageDescriptor::UpdateTexture()\n    {\n      this->FState = L_LOADED;\n      FTexture->LoadFromBitmap( FNewBitmap );\n    }\n    ```", "```kt\n    class clGallery: public iObject\n    {\n    public:\n      clGallery(): FNoImagesList(true) {}\n    ```", "```kt\n      std::string GetFullSizeURL(int Idx) const\n      {\n        return ( Idx < (int)FURLs.size() ) ?Picasa_GetDirectImageURL(FURLs[Idx], L_PHOTO_SIZE_ORIGINAL ): std::string();\n      }\n      size_t GetTotalImages() const{\n        return FImages.size();\n      }\n      clPtr<sImageDescriptor> GetImage( size_t Idx ) const{\n        return ( Idx < FImages.size() ) ?\n           FImages[Idx] : NULL;\n      }\n      …\n    ```", "```kt\n      void ResetAllDownloads();\n      bool StartListDownload();\n      …\n    ```", "```kt\n      std::vector<std::string> FURLs;\n      std::vector< clPtr<sImageDescriptor> > FImages;\n    };\n    ```", "```kt\n    class clListDownloadedCallback: public clDownloadCompleteCallback\n    {\n    public:\n      clListDownloadedCallback( const clPtr<clGallery>& G ): FGallery(G) {}\n      virtual void Invoke()\n      {\n        FGallery->ListDownloaded( FResult );\n      }\n\n      clPtr<clGallery> FGallery;\n    };\n\n    void clGallery::ListDownloaded( clPtr<clBlob> B )\n    {\n      if ( !B )\n      {\n        FNoImagesList = true;\n        return;\n      }\n    ```", "```kt\n      FURLs.clear();\n      void*  Data     = B->GetData();\n      size_t DataSize = B->GetSize();\n      Picasa_ParseXMLResponse(std::string( ( char* )Data, DataSize ), FURLs );\n    ```", "```kt\n      FImages.clear();\n      for ( size_t j = 0 ; j != FURLs.size() ; j++ )\n      {\n        LPhotoSize Size = L_PHOTO_SIZE_256;\n        std::string ImgUrl = Picasa_GetDirectImageURL(FURLs[j], Size);\n        clPtr<sImageDescriptor> Desc = new sImageDescriptor();\n        Desc->FSize    = Size;\n        Desc->FURL     = ImgUrl;\n        Desc->FID      = j;\n        FImages.push_back(Desc);\n        Desc->StartDownload( true );\n      }\n      FNoImagesList = false;\n    }\n    ```", "```kt\n    class clImageLoadTask: public iTask\n    {\n    public:\n    …\n      virtual void Run()\n      {\n        clPtr<ImageLoadTask> Guard( this );\n        clPtr<iIStream> In = (FSourceStream == NULL) ?g_FS->ReaderFromBlob( FSource ) : FSourceStream;\n        FResult = new clBitmap();\n        FResult->Load2DImage(In, true);\n        if ( FCallback )\n        {\n          FCallback->FTaskID = GetTaskID();\n          FCallback->FResult = FResult;\n          FCallback->FTask = this;\n          FCallbackQueue->EnqueueCapsule( FCallback );\n          FCallback = NULL;\n        }\n      }\n      …\n    };\n    ```", "```kt\n    class clPage_Gallery: public clGUIPage\n    {\n    public:\n      …\n      virtual void Render()\n      {\n        RenderDirect( g_Flow );\n      }\n      virtual void Update(float DT)\n      {\n        g_Flow->FFlinger->Update(DT);\n      }\n    private:\n      void RenderDirect( clPtr<clFlowUI> Control );\n    };\n    ```", "```kt\n      void RenderDirect( clPtr<clFlowUI> Control );\n      {\n    …\n    ```", "```kt\n        int ImgOrder[] = { CurImg - 3, CurImg - 2, CurImg - 1,CurImg + 3, CurImg + 2, CurImg + 1, CurImg };\n    ```", "```kt\n        for ( int in_i = 0 ; in_i < 7 ; in_i++ )\n        {\n    …\n          if ( i < Num && i > -1 )\n          {\n            …\n            clPtr<sImageDescriptor> Img =g_Gallery->GetImage( i );\n            clPtr<clGLTexture> Txt =Img ? Img->FTexture : g_Texture;\n            g_Canvas->Rect3D( Control->FProjection,Control->FView, Pt[1], Pt[0], Pt[3], Pt[2], Txt,NULL );\n          }\n        }\n      }\n    ```", "```kt\n    void OnDrawFrame() \n    {\n      g_GUI->Render(); \n    }\n    void OnKey( int code, bool pressed )\n    {\n      g_GUI->OnKey( g_Pos, code, pressed );\n    }\n    ```", "```kt\n    void OnTimer( float Delta )\n    {\n      g_Events->DemultiplexEvents();\n      g_GUI->Update( Delta );\n    }\n    ```", "```kt\n    void OnMouseDown( int btn, const LVector2& Pos )\n    {\n      g_Pos = Pos;\n      g_GUI->OnTouch( Pos, true );\n      if  ( g_InGallery )\n      {\n        g_MousePos = Pos;\n        g_MouseTime = Env_GetSeconds();\n        g_Flow->FFlinger->OnTouch( true );\n      }\n    }\n    ```"]