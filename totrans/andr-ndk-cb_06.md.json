["```kt\n    void jni_start_threads() {\n      pthread_t th1, th2;\n      int threadNum1 = 1, threadNum2 = 2;\n      int ret;\n      ret = pthread_create(&th1, NULL, run_by_thread, (void*)&threadNum1);\n      ret = pthread_create(&th2, NULL, run_by_thread, (void*)&threadNum2);\n      void *status;\n      ret = pthread_join(th1, &status);\n      int* st = (int*)status;\n      LOGI(1, \"thread 1 end %d %d\", ret, *st);\n      ret = pthread_join(th2, &status);\n      st = (int*)status;\n      LOGI(1, \"thread 2 end %d %d\", ret, *st);\n    }\n    ```", "```kt\n    int retStatus;\n    void *run_by_thread(void *arg) {\n      int cnt = 3, i;\n      int* threadNum = (int*)arg;\n      for (i = 0; i < cnt; ++i) {\n        sleep(1);\n        LOGI(1, \"thread %d: %d\", *threadNum, i);\n      }\n      if (1 == *threadNum) {\n        retStatus = 100;\n        return (void*)&retStatus;\n      } else if (2 == *threadNum) {\n        retStatus = 200;\n        pthread_exit((void*)&retStatus);\n      }\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE := NativeThreadsCreation\n    LOCAL_SRC_FILES := NativeThreadsCreation.cpp\n    LOCAL_LDLIBS := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsCreation:I *:S\n    ```", "```kt\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);\n```", "```kt\nvoid pthread_exit(void *value_ptr);\n```", "```kt\nint pthread_join(pthread_t thread, void **value_ptr);\n```", "```kt\n    int cnt = 0;\n    int THR = 10;\n    void *run_by_thread1(void *arg) {\n      int* threadNum = (int*)arg;\n      while (cnt < THR) {\n        pthread_mutex_lock(&mux1);\n        while ( pthread_mutex_trylock(&mux2) ) {\n          pthread_mutex_unlock(&mux1);  //avoid deadlock\n          usleep(50000);  //if failed to get mux2, release mux1 first\n          pthread_mutex_lock(&mux1);\n        }\n        ++cnt;\n        LOGI(1, \"thread %d: cnt = %d\", *threadNum, cnt);\n        pthread_mutex_unlock(&mux1);\n        pthread_mutex_unlock(&mux2);\n        sleep(1);\n      }\n    }\n    ```", "```kt\n    void *run_by_thread2(void *arg) {\n      int* threadNum = (int*)arg;\n      while (cnt < THR) {\n        pthread_mutex_lock(&mux2);\n        while ( pthread_mutex_trylock(&mux1) ) {\n          pthread_mutex_unlock(&mux2);  //avoid deadlock\n          usleep(50000);   //if failed to get mux2, release mux1 first\n          pthread_mutex_lock(&mux2);\n        }\n        ++cnt;\n        LOGI(1, \"thread %d: cnt = %d\", *threadNum, cnt);\n        pthread_mutex_unlock(&mux2);\n        pthread_mutex_unlock(&mux1);\n        sleep(1);\n      }\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE := NativeThreadsMutex\n    LOCAL_SRC_FILES := NativeThreadsMutex.cpp\n    LOCAL_LDLIBS := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsMutex:I *:S\n    ```", "```kt\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);\n```", "```kt\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n```", "```kt\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_lock_timeout_np(pthread_mutex_t *mutex, unsigned msecs);\n```", "```kt\n    pthread_mutex_t mux;\n    pthread_cond_t cond;\n    void jni_start_threads() {\n      pthread_t th1, th2;\n      int threadNum1 = 1, threadNum2 = 2;\n      int ret;\n      pthread_mutex_init(&mux, NULL);\n      pthread_cond_init(&cond, NULL);\n      ret = pthread_create(&th1, NULL, run_by_thread1, \n    void*)&threadNum1);\n      LOGI(1, \"thread 1 started\");\n      ret = pthread_create(&th2, NULL, run_by_thread2, \n    void*)&threadNum2);\n      LOGI(1, \"thread 2 started\");\n      ret = pthread_join(th1, NULL);\n      LOGI(1, \"thread 1 end %d\", ret);\n      ret = pthread_join(th2, NULL);\n      LOGI(1, \"thread 2 end %d\", ret);\n      pthread_mutex_destroy(&mux);\n      pthread_cond_destroy(&cond);\n    }\n    ```", "```kt\n    int cnt = 0;\n    int THR = 10, THR2 = 5;\n    void *run_by_thread1(void *arg) {\n      int* threadNum = (int*)arg;\n      pthread_mutex_lock(&mux);\n      while (cnt != THR2) {\n          LOGI(1, \"thread %d: about to wait\", *threadNum);\n          pthread_cond_wait(&cond, &mux);\n      }\n      ++cnt;\n      LOGI(1, \"thread %d: cnt = %d\", *threadNum, cnt);\n      pthread_mutex_unlock(&mux);\n    }\n    ```", "```kt\n    void *run_by_thread2(void *arg) {\n      int* threadNum = (int*)arg;\n      while (cnt < THR) {\n        pthread_mutex_lock(&mux);\n        if (cnt == THR2) {\n          pthread_cond_signal(&cond);\n        } else {\n          ++cnt;\n          LOGI(1, \"thread %d: cnt = %d\", *threadNum, cnt);\n        }\n        pthread_mutex_unlock(&mux);\n        sleep(1);\n      }\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeThreadsCondVar\n    LOCAL_SRC_FILES := NativeThreadsCondVar.cpp\n    LOCAL_LDLIBS    := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsCondVar:I *:S\n    ```", "```kt\nint pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);\n```", "```kt\nint pthread_cond_destroy(pthread_cond_t *cond);\n```", "```kt\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_broadcast(pthread_cond_t *cond);\nint pthread_cond_signal(pthread_cond_t *cond);\n```", "```kt\nint pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t * mutex, const struct timespec *abstime);\nint pthread_cond_timedwait_monotonic_np(pthread_cond_t *cond, pthread_mutex_t        *mutex, const struct timespec  *abstime);\nint pthread_cond_timedwait_relative_np(pthread_cond_t *cond, pthread_mutex_t        *mutex, const struct timespec  *reltime);\nint pthread_cond_timeout_np(pthread_cond_t *cond, pthread_mutex_t * mutex, unsigned msecs);\n```", "```kt\n    void jni_start_threads(JNIEnv *pEnv, jobject pObj, int pNumOfReader, int pNumOfWriter) {\n      pthread_t *ths;\n      int i, ret;\n      int *thNum;\n      ths = (pthread_t*)malloc(sizeof(pthread_t)*(pNumOfReader+pNumOfWriter));\n      thNum = (int*)malloc(sizeof(int)*(pNumOfReader+pNumOfWriter));\n      pthread_rwlock_init(&rwlock, NULL);\n      for (i = 0; i < pNumOfReader + pNumOfWriter; ++i) {\n        thNum[i] = i;\n        if (i < pNumOfReader) {\n          ret = pthread_create(&ths[i], NULL, run_by_read_thread, (void*)&(thNum[i]));\n        } else {\n          ret = pthread_create(&ths[i], NULL, run_by_write_thread, (void*)&(thNum[i]));\n        }\n      }\n      for (i = 0; i < pNumOfReader+pNumOfWriter; ++i) {\n        ret = pthread_join(ths[i], NULL);\n      }\n      pthread_rwlock_destroy(&rwlock);\n      free(thNum);\n      free(ths);\n    }\n    ```", "```kt\n    void *run_by_read_thread(void *arg) {\n      int* threadNum = (int*)arg;\n      int ifRun = 1;\n      int accessTimes = 0;\n      int ifPrint = 1;\n      while (ifRun) {\n        if (!pthread_rwlock_rdlock(&rwlock)) {\n          if (100000*numOfWriter == sharedCnt) {\n            ifRun = 0;\n          }\n          if (0 <= sharedCnt && ifPrint) {\n            LOGI(1, \"reader thread %d sharedCnt value before processing %d\\n\", *threadNum, sharedCnt);\n            int j, k;//some dummy processing\n            for (j = 0; j < 100000; ++j) {\n              k = j*2;\n              k = sqrt(k);\n            }\n            ifPrint = 0;\n            LOGI(1, \"reader thread %d sharedCnt value after processing %d %d\\n\", *threadNum, sharedCnt, k);\n          }\n          if ((++accessTimes) == INT_MAX/5) {\n            accessTimes = 0;\n            LOGI(1, \"reader thread %d still running: %d\\n\", *threadNum, sharedCnt);\n          }\n          pthread_rwlock_unlock(&rwlock);\n        }\n      }\n      LOGI(1, \"reader thread %d return %d\\n\", *threadNum, sharedCnt);\n      return NULL;\n    }\n    ```", "```kt\n    void *run_by_write_thread(void *arg) {\n      int cnt = 100000, i, j, k;\n      int* threadNum = (int*)arg;\n      for (i = 0; i < cnt; ++i) {\n        if (!pthread_rwlock_wrlock(&rwlock)) {\n          int lastShCnt = sharedCnt;\n          for (j = 0; j < 10; ++j) {  //some dummy processing\n            k = j*2;\n            k = sqrt(k);\n          }\n          sharedCnt = lastShCnt + 1;\n          pthread_rwlock_unlock(&rwlock);\n        }\n      }\n      LOGI(1, \"writer thread %d return %d %d\\n\", *threadNum, sharedCnt, k);\n      return NULL;\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeThreadsRWLock\n    LOCAL_SRC_FILES := NativeThreadsRWLock.cpp\n    LOCAL_LDLIBS    := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsRWLock:I *:S\n    ```", "```kt\nint pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n```", "```kt\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n```", "```kt\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n```", "```kt\nint pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);\nint pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);\n```", "```kt\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n```", "```kt\n    void jni_start_threads(JNIEnv *pEnv, jobject pObj, int pNumOfConsumer, int pNumOfProducer, int numOfSlots) {\n      pthread_t *ths;\n      int i, ret;\n      int *thNum;\n      pthread_mutex_init(&mux, NULL);\n      sem_init(&emptySem, 0, numOfSlots);\n      sem_init(&fullSem, 0, 0);\n      ths = (pthread_t*)malloc(sizeof(pthread_t)*(pNumOfConsumer+pNumOfProducer));\n      thNum = (int*)malloc(sizeof(int)*(pNumOfConsumer+pNumOfProducer));\n      for (i = 0; i < pNumOfConsumer + pNumOfProducer; ++i) {\n        thNum[i] = i;\n        if (i < pNumOfConsumer) {\n          ret = pthread_create(&ths[i], NULL, \n    un_by_consumer_thread, (void*)&(thNum[i]));\n        } else {\n          ret = pthread_create(&ths[i], NULL, run_by_producer_thread, (void*)&(thNum[i]));\n        }\n      }\n      for (i = 0; i < pNumOfConsumer+pNumOfProducer; ++i) {\n        ret = pthread_join(ths[i], NULL);\n      }\n      sem_destroy(&emptySem);\n      sem_destroy(&fullSem);\n      pthread_mutex_destroy(&mux);\n      free(thNum);\n      free(ths);\n    }\n    ```", "```kt\n    void *run_by_consumer_thread(void *arg) {\n      int* threadNum = (int*)arg;\n      int i;\n      for (i = 0; i < 4; ++i) {\n        sem_wait(&fullSem);\n        pthread_mutex_lock(&mux);\n        --numOfItems;\n        pthread_mutex_unlock(&mux);\n        sem_post(&emptySem);\n      }\n      return NULL;\n    }\n    ```", "```kt\n    void *run_by_producer_thread(void *arg) {\n      int* threadNum = (int*)arg;\n      int i;\n      for (i = 0; i < 4; ++i) {\n        sem_wait(&emptySem);\n        pthread_mutex_lock(&mux);\n        ++numOfItems;\n        pthread_mutex_unlock(&mux);\n        sem_post(&fullSem);\n      }\n      return NULL;\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeThreadsSemaphore\n    LOCAL_SRC_FILES := NativeThreadsSemaphore.cpp\n    LOCAL_LDLIBS    := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsSemaphore:I *:S\n    ```", "```kt\nextern int sem_init(sem_t *sem, int pshared, unsigned int value);\nextern int    sem_init(sem_t *, int, unsigned int value);\nextern int    sem_destroy(sem_t *);\n```", "```kt\nextern int    sem_trywait(sem_t *);\nextern int    sem_wait(sem_t *);\nextern int    sem_post(sem_t *);\nextern int    sem_getvalue(sem_t *, int *);\n```", "```kt\n        void jni_thread_scope() {\n          pthread_attr_t attr;\n          int ret;\n          pid_t fpId = fork();\n          if (0 == fpId) {\n            pthread_attr_init(&attr);\n            int ret = pthread_attr_setscope(&attr, PTHREAD_SCOPE_PROCESS);\n            pthread_t thFive[5];\n            int threadNums[5];     int i;\n            for (i = 0; i < 5; ++i) {\n              threadNums[i] = i;      ret = pthread_create(&thFive[i], &attr, run_by_thread, (void*)&(threadNums[i]));\n            }\n            for (i = 0; i < 5; ++i) {\n              ret = pthread_join(thFive[i], NULL);\n            }\n          } else {\n            pthread_attr_init(&attr);\n            int ret = pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);\n            pthread_t th1;\n            int threadNum1 = 0;\n            ret = pthread_create(&th1, &attr, run_by_thread, (void*)&threadNum1);\n            ret = pthread_join(th1, NULL);\n          }\n          //code executed by both processes\n          pthread_attr_destroy(&attr);\n        }\n        ```", "```kt\n        void jni_thread_fifo() {\n          pthread_attr_t attr;\n          int ret;\n          pid_t fpId = fork();\n          struct sched_param prio;\n          if (0 == fpId) {\n            //the child process\n            pthread_attr_init(&attr);\n            pthread_t thFive[5];\n            int threadNums[5];\n            int i;\n            for (i = 0; i < 5; ++i) {\n              if (i == 4) {\n                prio.sched_priority = 10;\n              } else {\n                prio.sched_priority = 1;\n              }\n              ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n              ret = pthread_attr_setschedparam(&attr, &prio);\n              threadNums[i] = i;\n              ret = pthread_create(&thFive[i], &attr, run_by_thread, (void*)&(threadNums[i]));\n              pthread_attr_t lattr;\n              struct sched_param lprio;\n              int lpolicy;\n              pthread_getattr_np(thFive[i], &lattr);\n              pthread_attr_getschedpolicy(&lattr, &lpolicy);\n              pthread_attr_getschedparam(&lattr, &lprio);\n              pthread_attr_destroy(&lattr);\n            }\n            for (i = 0; i < 5; ++i) {\n              ret = pthread_join(thFive[i], NULL);\n            }\n          } else {\n            //the parent process\n            pthread_attr_init(&attr);\n            prio.sched_priority = 10;\n            ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n            ret = pthread_attr_setschedparam(&attr, &prio);\n            pthread_t th1;\n            int threadNum1 = 0;\n            ret = pthread_create(&th1, &attr, run_by_thread, (void*)&threadNum1);\n            pthread_attr_t lattr;\n            struct sched_param lprio;\n            int lpolicy;\n            pthread_getattr_np(th1, &lattr);\n            pthread_attr_getschedpolicy(&lattr, &lpolicy);\n            pthread_attr_getschedparam(&lattr, &lprio);\n            pthread_attr_destroy(&lattr);\n            ret = pthread_join(th1, NULL);\n          }\n          //code executed by both processes\n          pthread_attr_destroy(&attr);\n        }\n        ```", "```kt\n        void *run_by_thread(void *arg) {\n          int cnt = 18000000, i;\n          int* threadNum = (int*)arg;\n          for (i = 1; i < cnt; ++i) {\n            if (0 == i%6000000) {\n              LOGI(1, \"process %d thread %d: %d\", getpid(), *threadNum, i);\n            }\n          }\n          LOGI(1, \"process %d thread %d return\", getpid(), *threadNum);\n        }\n        ```", "```kt\n        void jni_thread_set_priority() {\n          int ret;\n          pthread_t thFive[5];\n          int threadNums[5];\n          int i;\n          for (i = 0; i < 5; ++i) {\n            threadNums[i] = i;\n            ret = pthread_create(&thFive[i], NULL, run_by_thread2, (void*)&(threadNums[i]));\n          }\n          for (i = 0; i < 5; ++i) {\n            ret = pthread_join(thFive[i], NULL);\n          }\n        }\n        ```", "```kt\n        void *run_by_thread2(void *arg) {\n          int cnt = 18000000, i;\n          int* threadNum = (int*)arg;\n          switch (*threadNum) {\n          case 0:\n            setpriority(PRIO_PROCESS, 0, 21);\n            break;\n          case 1:\n            setpriority(PRIO_PROCESS, 0, 10);\n            break;\n          case 2:\n            setpriority(PRIO_PROCESS, 0, 0);\n            break;\n          case 3:\n            setpriority(PRIO_PROCESS, 0, -10);\n            break;\n          case 4:\n            setpriority(PRIO_PROCESS, 0, -21);\n            break;\n          default:\n            break;\n          }\n          for (i = 1; i < cnt; ++i) {\n            if (0 == i%6000000) {\n              int prio = getpriority(PRIO_PROCESS, 0);\n              LOGI(1, \"thread %d (prio = %d): %d\", *threadNum, prio, i);\n            }\n          }\n          int prio = getpriority(PRIO_PROCESS, 0);\n          LOGI(1, \"thread %d (prio = %d): %d return\", *threadNum, prio, i);\n        }\n        ```", "```kt\n        void jni_process_setThreadPriority() {\n          int ret;\n          pthread_t thFive[5];\n          int threadNums[5];\n          int i;\n          for (i = 0; i < 5; ++i) {\n            threadNums[i] = i;\n            ret = pthread_create(&thFive[i], NULL, run_by_thread3, (void*)&(threadNums[i]));\n            if(ret) {\n              LOGE(1, \"cannot create the thread %d: %d\", i, ret);\n            }\n            LOGI(1, \"thread %d started\", i);\n          }\n          for (i = 0; i < 5; ++i) {\n            ret = pthread_join(thFive[i], NULL);\n            LOGI(1, \"join returned for thread %d\", i);\n          }\n        }\n        ```", "```kt\n        void *run_by_thread3(void *arg) {\n          int cnt = 18000000, i;\n          int* threadNum = (int*)arg;\n          JNIEnv *env;\n          jmethodID setThreadPriorityMID;\n          cachedJvm->AttachCurrentThread(&env, NULL);\n          jclass procClass = env->FindClass(\"android/os/Process\");\n          setThreadPriorityMID = env->GetStaticMethodID(procClass, \"setThreadPriority\", \"(I)V\");\n          switch (*threadNum) {\n          case 0:\n            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, 21);\n            break;\n          case 1:\n            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, 10);\n            break;\n          case 2:\n            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, 0);\n            break;\n          case 3:\n            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, -10);\n            break;\n          case 4:\n            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, -21);\n            break;\n          default:\n            break;\n\n         }\n          //we can also use getThreadPriority(int tid) through JNI interface\n          for (i = 1; i < cnt; ++i) {\n            if (0 == i%6000000) {\n              int prio = getpriority(PRIO_PROCESS, 0);\n              LOGI(1, \"thread %d (prio = %d): %d\", *threadNum, prio, i);\n            }\n          }\n          int prio = getpriority(PRIO_PROCESS, 0);\n          LOGI(1, \"thread %d (prio = %d): %d return\", *threadNum, prio, i);\n          cachedJvm->DetachCurrentThread();\n        }\n        ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeThreadsSchedule\n    LOCAL_SRC_FILES := NativeThreadsSchedule.cpp\n    LOCAL_LDLIBS    := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsSchedule:I *:S\n    ```", "```kt\nint pthread_attr_init(pthread_attr_t * attr); \nint pthread_attr_destroy(pthread_attr_t * attr);\n```", "```kt\nint pthread_attr_setscope(pthread_attr_t *attr, int  scope); \nint pthread_attr_getscope(pthread_attr_t const *attr);\n```", "```kt\n    void jni_start_threads(JNIEnv *pEnv, jobject pObj, int pNumOfThreads) {\n      pthread_t *ths;\n      int i, ret;\n      int *thNum;\n      ths = (pthread_t*)malloc(sizeof(pthread_t)*pNumOfThreads);\n      thNum = (int*)malloc(sizeof(int)*pNumOfThreads);\n      pthread_mutex_init(&mux, NULL);\n      pthread_key_create(&muxCntKey, free_muxCnt);\n      for (i = 0; i < pNumOfThreads; ++i) {\n        thNum[i] = i;\n        ret = pthread_create(&ths[i], NULL, run_by_thread, (void*)&(thNum[i]));\n      }\n      for (i = 0; i < pNumOfThreads; ++i) {\n        ret = pthread_join(ths[i], NULL);\n      }\n      pthread_key_delete(muxCntKey);\n      pthread_mutex_destroy(&mux);\n      free(thNum);\n      free(ths);\n    }\n    ```", "```kt\n    void thread_step_1() {\n      struct timeval st, cu;\n      long stt, cut;\n      int *muxCntData = (int*)pthread_getspecific(muxCntKey);\n      gettimeofday(&st, NULL);\n      stt = st.tv_sec*1000 + st.tv_usec/1000;\n      do {\n               pthread_mutex_lock(&mux);\n        (*muxCntData)++;\n               pthread_mutex_unlock(&mux);\n        gettimeofday(&st, NULL);\n        cut = st.tv_sec*1000 + st.tv_usec/1000;\n         } while (cut - stt < 10000);\n    }\n    ```", "```kt\n    void thread_step_2(int thNum) {\n      int *muxCntData = (int*)pthread_getspecific(muxCntKey);\n      LOGI(1, \"thread %d: mux usage count: %d\\n\", thNum, *muxCntData);\n    }\n    ```", "```kt\n    void *run_by_thread(void *arg) {\n      int* threadNum = (int*)arg;\n      int *muxCntData = (int*)malloc(sizeof(int));\n      *muxCntData = 0;\n      pthread_setspecific(muxCntKey, (void*)muxCntData);\n      thread_step_1();\n      thread_step_2(*threadNum);\n      return NULL;\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n    include $(CLEAR_VARS)\n    LOCAL_MODULE    := NativeThreadsData\n    LOCAL_SRC_FILES := NativeThreadsData.cpp\n    LOCAL_LDLIBS    := -llog\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    $ adb logcat -v time NativeThreadsData:I *:S\n    ```", "```kt\nint pthread_key_create(pthread_key_t *key, void (*destructor_function)(void *));\nint pthread_key_delete (pthread_key_t key);\n```", "```kt\nint pthread_setspecific(pthread_key_t key, const void *value);\nvoid *pthread_getspecific(pthread_key_t key);\n```"]