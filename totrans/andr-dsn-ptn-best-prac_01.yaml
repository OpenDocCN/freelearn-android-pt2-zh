- en: Chapter 1. Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 设计模式
- en: Design patterns have long been considered some of the most reliable and useful
    approaches to solving common software design problems. Patterns provide general
    and reusable solutions to frequently occurring development issues, such as how
    to add functionality to an object without changing its structure or how best to
    construct complex objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式长期以来被认为是解决常见软件设计问题最可靠和最有用的方法之一。模式为经常出现的发展问题提供了一般性和可重用的解决方案，例如如何在不对对象结构进行修改的情况下添加功能，或者如何最佳地构建复杂对象。
- en: There are several advantages to applying patterns, not least the way that this
    approach assists the developer in following best practices and how it simplifies
    the management of large projects. These benefits are achieved by providing overall
    software structures (patterns) that can be reused to solve similar problems. This
    is not to say that code can be simply cut and pasted from one project to another
    but that the concepts themselves can be used over and over again in many different
    situations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用模式有几个优点，不仅仅是这种方法帮助开发者遵循最佳实践，以及它如何简化大型项目的管理。这些好处是通过提供可以重复使用的整体软件结构（模式）来实现的，以解决类似问题。这并不意味着代码可以从一个项目简单地剪切和粘贴到另一个项目，而是这些概念本身可以在许多不同情况下反复使用。
- en: 'There are a good many other benefits to applying programming patterns, all
    of which will be covered at some point in the book, but here are one or two that
    are worthy of mention now:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用编程模式有许多其他好处，本书的某个部分将会涵盖这些内容，但以下一两个好处是现在值得一提的：
- en: Patterns provide an efficient common language between developers working in
    teams. When a developer describes a structure as say, an **adapter** or a **facade**,
    other developers will understand what this means and will immediately recognize
    the structure and purpose of the code.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式为团队工作的开发者之间提供了一种高效的通用语言。当一个开发者将一个结构描述为例如**适配器**或**外观**时，其他开发者能够理解其含义，并会立即识别代码的结构和目的。
- en: The added layers of abstraction that patterns provide make modifications and
    alterations to code that is already under development much easier. There are even
    patterns designed for these very situations.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式提供的额外抽象层使得对已经处于开发阶段的代码进行修改和调整变得更加容易。甚至还有专门为这些情况设计的模式。
- en: Patterns can be applied at many scales, from the overall architectural structure
    of a project right down to the manufacturing of the most basic object.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式可以在许多尺度上应用，从项目的整体架构结构到最基本对象的制造。
- en: The application of patterns can vastly reduce the amount of inline commentary
    and general documentation required, as patterns also act as their own description.
    The name of a class or interface alone can explain its purpose and place within
    a pattern.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用模式可以大大减少所需的内联注释和一般文档的数量，因为模式本身也充当了自身的描述。仅类的名称或接口就能解释其目的和在模式中的位置。
- en: The Android development platform lends itself nicely to the employment of patterns,
    as not only are applications created largely in Java, but the SDK contains many
    APIs that make use of patterns themselves, such as **factory** interfaces for
    creating objects and **builders** for constructing them. Simple patterns such
    as **Singletons** are even available as a template class type. In this book, we
    shall see not only how to put together our own, large-scale patterns but also
    how make use of these built-in structures to encourage best practice and simplify
    coding.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发平台非常适合采用模式，因为不仅应用程序主要是用 Java 创建的，而且 SDK 包含许多自身使用模式的 API，例如用于创建对象的**工厂**接口和用于构建对象的**建造者**。像**单例**这样的简单模式甚至可以作为模板类类型使用。在本书中，我们不仅将看到如何构建自己的大型模式，还将了解如何利用这些内置结构来促进最佳实践并简化编码。
- en: In this chapter, we will begin by taking a brief look at how the book as a whole
    will pan out, the patterns we will be using, the order in which we will approach
    them, and the demonstration app that we will be building to see how patterns can
    be applied in real-world situations. This will be followed by a quick examination
    of the SDK and which components will best assist us on our journey, in particular,
    the role that the **support library** provides, enabling us to develop for many
    platform versions at once. There is no better way to learn than actual experience,
    and so the rest of the chapter will be taken up by developing a very simple demonstration
    app and employing our first pattern, the **factory pattern**, and its associated
    **abstract factory** pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先简要概述整本书的布局、我们将使用的模式、我们接近它们的顺序，以及我们将构建的演示应用，看看如何在现实世界中应用模式。接下来，我们将快速检查SDK以及哪些组件将最好地协助我们的旅程，尤其是**支持库**所扮演的角色，使我们能够同时为多个平台版本开发。没有比实际经验更好的学习方式，因此本章的剩余部分将用于开发一个非常简单的演示应用，并使用我们的第一个模式——**工厂模式**及其相关的**抽象工厂**模式。
- en: 'In this chapter, you will learn the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How patterns are categorized and which patterns are covered here
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式如何分类以及本书涵盖哪些模式
- en: The purpose of the book's demonstration app
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书演示应用的目的
- en: How to target platform versions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定位平台版本
- en: What support libraries do
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持库的作用是什么
- en: What a factory pattern is and how to construct one
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式是什么以及如何构建一个工厂模式
- en: How to follow a UML class diagram
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何遵循UML类图
- en: How to test an app on both real and virtual devices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实机和虚拟设备上测试应用
- en: How to monitor an app during runtime
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在运行时监控应用
- en: How to use simple debugging tools to test code
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用简单的调试工具来测试代码
- en: What an abstract factory pattern is and how to use one
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式是什么以及如何使用它
- en: How this book works
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书如何运作
- en: The purpose of this book is to show how the application of design patterns can
    directly assist the development of Android applications. During the course of
    the book we will be concentrating on the development of a complete client-side
    mobile application, focusing particularly on when, why, and how patterns can and
    should be employed during Android development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的是展示设计模式的运用如何直接协助开发Android应用。在本书的进程中，我们将专注于开发一个完整的客户端移动应用，特别关注在Android开发过程中何时、为何以及如何使用这些模式。
- en: 'Historically, there has been a certain amount of disagreement as to what exactly
    constitutes a pattern. However, the 23 patterns laid out in the 1994 book *Design
    Patterns* by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, the
    so-called gang of four, are widely accepted as the definitive set and provide
    solutions to nearly all of the software engineering problems that we are likely
    to encounter, and it is for this reason that these patterns will form the backbone
    of the book. These patterns can be broken down into three categories:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，对于什么构成模式存在一定争议。然而，在Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides于1994年出版的《设计模式》一书中提出的23种模式，被称为四人帮的模式，被广泛认为是权威集合，并为我们在软件工程中可能遇到的几乎所有问题提供解决方案，因此这些模式将成为本书的核心。这些模式可以分为三类：
- en: '**Creational** - Used for creating objects'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型** - 用于创建对象'
- en: '**Structural** - Used for organizing groups of objects'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型** - 用于组织对象群组'
- en: '**Behavioral** - Used for communication between objects'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为型** - 用于对象之间的通信'
- en: The practical nature of this book means that we will not be tackling these categories
    in the order they appear here; instead, we will explore individual patterns as
    and when they arise naturally during the development of our app, although this
    generally means starting with creating a structure first.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的实践性质意味着我们不会按照这里出现的顺序来处理这些类别；相反，我们将在开发应用时自然地探索各个模式，这通常意味着首先创建一个结构。
- en: It would be difficult, clumsy, and unrealistic to incorporate all design patterns
    into a single application, so here will attempt to apply as many as might seem
    realistic. For those patterns we decide not to use directly, we will at least
    explore how we might have done so, and in every case give at least one practical
    example of how they are used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有设计模式集成到一个应用程序中是困难、笨拙且不现实的，因此我们将尝试应用尽可能多的看起来现实的模式。对于那些我们决定不直接使用的模式，我们至少会探讨我们可能如何使用它们，并且在每种情况下至少提供一个实际的使用示例。
- en: Patterns are not written in stone, nor do they solve every possible problem,
    and towards the end of the book we will look at how, once we have a grasp of the
    subject, we can create our own patterns or adapt extant ones to suit the rare
    circumstances where none of the established patterns fit.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模式并非刻在石头上，也不能解决所有可能的问题。在本书的末尾，我们将探讨一旦掌握了这个主题，我们如何可以创建自己的模式或调整现有的模式以适应那些既定模式不适用的情况。
- en: In short, patterns are not a set of rules but rather a series of well-worn paths
    leading from known problems to tested solutions. If you spot a shortcut along
    the way, then by all means use it. If you stick to it consistently, then you will
    have created a pattern of your own that is just as valid as the traditional ones
    that we will cover here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，模式并非一套规则，而是一系列从已知问题通往经过验证的解决方案的熟悉路径。如果你在路上发现了一条捷径，那么尽可以采用它。如果你坚持这样做，那么你就创造了自己的一种模式，这种模式与我们在这里将要介绍的传统模式一样有效。
- en: The first few chapters of the book concentrate on UI design and introduce a
    few essential design patterns and how they work conceptually. From about [Chapter
    6](ch06.html "Chapter 6. Activating Patterns"), *Activating Patterns*, onward,
    we will start to apply these and other patterns to real-world examples, and to
    one application in particular. The final chapters concentrate on the final stages
    of development, such as adapting applications for differing devices, a task almost
    purpose-built for design patterns, reaching the widest possible market and how
    to monetize our apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 书的前几章主要关注UI设计，并介绍了一些基本的设计模式及其概念上的工作原理。从大约[第6章](ch06.html "第6章.激活模式")《激活模式》开始，我们将开始将这些和其他模式应用于现实世界的例子，特别是针对一个应用程序。最后几章集中在开发的最后阶段，例如，调整应用程序以适应不同的设备，这项任务几乎是专为设计模式而设的，旨在达到最广泛的市场，以及如何使我们的应用程序盈利。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In case you are new to Android development, the instructions laid out in the
    first two or three chapters are given in detail. If you are already familiar with
    Android development, you will be able to skip these sections and concentrate on
    the patterns themselves.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触Android开发，前两三章中的说明会讲解得非常详细。如果你已经熟悉Android开发，你将能够跳过这些部分，专注于模式本身。
- en: Before we get stuck into our first patterns, it makes sense to take a closer
    look at the app we will be building during the course of the book, as well as
    the challenges and opportunities it presents.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入我们第一个模式之前，仔细看看在本书过程中将要构建的应用程序，以及它所带来的挑战和机遇是有意义的。
- en: What we will build
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将要构建的内容
- en: As mentioned earlier, throughout the course of this book, we will be building
    a small but complete Android application. It will be a good idea now to take a
    little look at what we will be building and why.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本书的过程中，我们将构建一个虽小但完整的Android应用程序。现在了解一下我们将要构建的内容及其原因会是一个好主意。
- en: 'We will put ourselves in the position of an independent Android developer that
    has been approached by a potential client that runs a small business making and
    delivering fresh sandwiches to several local office buildings. There are several
    issues facing our client that they believe can be solved with a mobile app. To
    see what solutions an app might provide, we will break the situation down into
    three sections: the scenario, the problem, and the solution.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设身处地地考虑一个独立Android开发者的角色，这位开发者被一个潜在客户接近，这个客户经营着一家小企业，制作并配送新鲜三明治到当地的几栋办公楼。我们的客户面临几个问题，他们认为可以通过一个移动应用程序来解决。为了了解应用程序可能提供的解决方案，我们将把情况分为三个部分：场景、问题和解决方案。
- en: The scenario
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景概述
- en: The client runs a small but successful business making and then delivering fresh
    sandwiches to nearby office workers so that they can buy and eat them at their
    desks. The sandwiches are very good and, as a result of word-by-mouth advertising,
    are growing in popularity. There is a good opportunity for the business to expand,
    but there are some glaring inefficiencies in the business model that the client
    believes can be resolved with the use of a mobile app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户运营着一家小而成功的业务，为附近的上班族制作并送递新鲜的三明治，让他们可以在办公桌上购买并食用。三明治非常美味，由于口碑宣传，越来越受欢迎。业务有很大的扩展机会，但商业模式中存在一些明显的低效问题，客户认为可以通过使用移动应用程序来解决。
- en: The problem
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题所在
- en: It is almost impossible for the client to anticipate demand. There are many
    occasions where too many of a particular sandwich are made, leading to wastage.
    Likewise, there are times where insufficient sandwich lines are prepared, leading
    to a loss in sales. Not only this, but the word-of-mouth advertising the customers
    provide limits the expansion of the business to a small geographical area. The
    client has no reliable way of knowing if it is worth investing in more staff,
    a motorbike to travel further afield, or even whether to open new kitchens in
    other parts of town.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户几乎无法预测需求。很多时候某种三明治做多了，导致浪费。同样，也有准备三明治品种不足的时候，导致销售额的损失。不仅如此，顾客提供的口碑宣传也限制了业务扩展到较小的地理区域。客户没有可靠的方法来判断是否值得投资更多员工、摩托车以扩大送餐范围，甚至是否在其他镇区开设新的厨房。
- en: The solution
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: A mobile app, provided free for all customers, not only solves these problems
    but makes available a whole new set of opportunities. Never mind that an app will
    solve the issues of unanticipated demand; we now have the chance to take this
    to a whole new level. Why just present the customer with a set menu when we can
    offer them the chance to construct their own personalized sandwich from a list
    of ingredients? Maybe they love the cheese and pickle sandwich our client already
    makes but fancy it with a slice or two of apple, or prefer mango chutney to pickle.
    Maybe they are vegetarian and prefer to filter out meat products from their choices.
    Maybe they have allergies. All of these needs can be met with a well-designed
    mobile app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一款面向所有客户免费的移动应用程序不仅解决了这些问题，还提供了一系列全新的机会。不仅仅是应用程序能够解决无法预料的需求问题；我们现在有机会将这个业务提升到一个全新的层次。为何只向顾客提供固定菜单呢？我们可以提供让他们从一系列食材中构建自己的个性化三明治的机会。也许他们喜欢我们客户已经制作好的芝士和腌菜三明治，但想要加一两片苹果，或者更喜欢芒果酱而不是腌菜。也许他们是素食主义者，更喜欢从选择中过滤掉肉类产品。也许他们有过敏症。所有这些需求都可以通过一个设计良好的移动应用程序来满足。
- en: Furthermore, the geographical limitations of word-of-mouth advertising, and
    even local promotions such a as billboards or notices in local papers, gives no
    indication of just how successful a business might be on a larger stage. The use
    of social media, on the other hand, can give our client clear insights into current
    trends as well as spread the word to the widest possible audience.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，口碑宣传的地理限制，甚至当地广告如广告牌或当地报纸上的通知，都无法指示业务在更大舞台上的可能成功程度。而另一方面，社交媒体的使用不仅可以让我们客户清晰地了解当前趋势，还能将信息传播给尽可能广泛的受众。
- en: Not only can our client now judge accurately the scope of their business but
    can also add entirely new features unique to the digital nature of modern life,
    such as the gamification of the app. Competitions, puzzles, and challenges can
    provide a whole new dimension to engaging customers and present a powerful technique
    to increasing revenue and market presence.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户现在不仅能够准确判断他们业务的范围，还能添加完全新的、与现代数字生活特性相关的功能，比如应用程序的游戏化。竞赛、谜题和挑战可以为吸引顾客提供全新的维度，并呈现一种强大的增加收入和市场影响力的技术手段。
- en: With the task ahead now a little clearer, we are now in a position to start
    coding. We will start with a very simple demonstration of the factory pattern,
    and on the way take a closer look at some of the features of the SDK that we will
    be finding useful along the way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 面前的任务现在更加清晰，我们现在可以开始编码了。我们将从工厂模式的简单演示开始，一路上看一些在开发过程中会用到的一些 SDK 功能。
- en: Targeting platform versions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位平台版本
- en: 'To keep up with the latest technology, new versions of the Android platform
    are released frequently. As developers, this means we can incorporate the newest
    features and developments into our applications. The obvious drawback to this
    is the fact that only the very newest devices will be able to run this platform
    and these devices represent only a tiny proportion of the entire market. Take
    a look at this chart taken from the developer dashboard:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上最新技术，Android平台的新版本会频繁发布。作为开发者，这意味着我们可以将最新的功能和发展融入到我们的应用程序中。显然，这样做的缺点是只有最新的设备才能运行这个平台，而这些设备在整个市场上只占很小的一部分。来看看开发者仪表板上的这张图表：
- en: '![Targeting platform versions](img/B05685_01_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![目标平台版本](img/B05685_01_01.jpg)'
- en: The dashboard can be found at [developer.android.com/about/dashboards/index.html](http://developer.android.com/about/dashboards/index.html)
    and contains this and other up-to-date information that is very useful when first
    planning a project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板可以在[developer.android.com/about/dashboards/index.html](http://developer.android.com/about/dashboards/index.html)找到，其中包含了这个以及其他最新的信息，这些信息在项目初步规划时非常有用。
- en: As you can see, the vast majority of Android devices still run on older platforms.
    Fortunately, Android makes it possible for us to target these older devices while
    still being able to incorporate features from the most recent platform version.
    This is largely achieved through the use of the **support library** and by setting
    a minimum SDK level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，绝大多数的Android设备仍然运行在较旧的平台上。幸运的是，Android允许我们针对这些旧设备进行开发，同时还能融入最新平台版本的功能。这主要是通过使用**支持库**和设置最低SDK级别来实现的。
- en: Deciding which platforms to target is one of the first decisions we will need
    to take, and although it is possible to change this at a later date, deciding
    early which features to incorporate and knowing how these will appear on older
    devices can greatly simplify the overall task.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 决定要针对哪些平台进行开发是我们需要做出的第一个决定之一，尽管我们可以在以后的日期更改这一点，但尽早决定要融入哪些功能以及了解这些功能在旧设备上的表现，可以大大简化整个任务。
- en: To see how this is done, start a new Android Studio project, call it anything
    you choose, and select **Phone and Tablet** as the form factor and **API 16**
    as the **Minimum SDK**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何做到这一点，请启动一个新的Android Studio项目，随意为其命名，选择**手机和平板电脑**作为形态因素，并选择**API 16**作为**最低SDK**。
- en: From the list of templates, select **Empty Activity** and leave everything else
    as is.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板列表中，选择**空活动**，其他保持默认设置。
- en: '![Targeting platform versions](img/B05685_01_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![目标平台版本](img/B05685_01_02.jpg)'
- en: 'Android Studio will automatically select the highest available SDK version
    as the target level. To see how this is applied, open the `build.gradle (Module:
    app)` file from the project pane and note the `defaultConfig` section, which will
    resemble the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'Android Studio会自动选择可用的最高SDK版本作为目标级别。要查看如何应用，请从项目面板中打开`build.gradle (Module:
    app)`文件，并注意`defaultConfig`部分，它将类似于以下代码：'
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This ensures that our project will compile correctly for this range of API
    levels, but if we were building an app that we intended to publish, then we would
    need to inform the Google Play store which devices to make our app available on.
    This can be done with the `build.gradle` modular file, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了我们的项目将针对这个API级别范围正确编译，但如果我们正在构建一个打算发布的app，那么我们需要告诉Google Play商店哪些设备上可以提供我们的app。这可以通过`build.gradle`模块文件来完成，如下所示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We would also need to edit `AndroidManifest.xml` file. For the example here,
    we would add the following `uses-sdk` element to the `manifest` node:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编辑`AndroidManifest.xml`文件。对于这个例子，我们将在`manifest`节点中添加以下`uses-sdk`元素：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once we have determined the range of platforms we wish to target, we can get
    on and see how the support library allows us to incorporate many of the latest
    features on many of the oldest devices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了我们希望针对的平台范围，我们就可以继续了解支持库如何让我们在许多最旧的设备上融入许多最新的功能。
- en: The support library
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持库
- en: When it comes to building backwards-compatible applications, the support library
    is undoubtedly our most powerful tool. It is in fact a series of individual code
    libraries that work by providing alternative classes and interfaces to those found
    in the standard APIs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建向后兼容的应用程序方面，支持库无疑是我们的最强大工具。实际上，它是一系列单独的代码库，通过提供标准API中找到的类和接口的替代品来工作。
- en: There are around 12 individual libraries and they do not only provide compatibility;
    they also include common UI components such as sliding drawers and floating action
    buttons that would otherwise have to be built from scratch. They can also simplify
    the process of developing for different screen sizes and shapes, as well as adding
    one or two miscellaneous functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大约有12个单独的库，它们不仅提供兼容性；它们还包括常见的UI组件，如滑动抽屉和浮动操作按钮，否则这些组件必须从头开始构建。它们还可以简化针对不同屏幕大小和形状的开发过程，以及添加一个或两个杂项功能。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we are developing with Android Studio, we should download the **support repository**
    rather than the support library as the repository is designed specifically for
    the studio, provides exactly the same functionality, and is more efficient.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在Android Studio中进行开发，因此应该下载**支持仓库**而不是支持库，因为该仓库是专门为Studio设计的，提供的功能完全相同，而且效率更高。
- en: In the example we are working on in this chapter, we will not be making any
    use of support libraries. The only one the project includes is the `v7 appcompat
    library`, which was added automatically for us when we started the project. We
    will be returning to support libraries often in the book, so for now, we can concentrate
    on applying our first pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们正在工作的示例中，将不使用任何支持库。项目包含的唯一支持库是`v7 appcompat library`，它在我们开始项目时自动添加。在书中，我们将经常回到支持库，所以现在，我们可以集中精力应用我们的第一个模式。
- en: The factory pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The factory pattern is one of the most widely used creational patterns. As its
    name suggests, it makes things, or more precisely, it creates objects. Its usefulness
    lies in the way it uses a common interface to separate logic from use. The best
    way to see how this works is simply to build one now. Open the project we began
    a page or two previously, or start a new one. Minimum and target SDK levels are
    not important for this exercise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是最常用的创建型模式之一。顾名思义，它制造东西，或者更准确地说，它创建对象。它的有用之处在于它使用一个通用接口将逻辑与使用分离。了解这一机制的最佳方式就是现在就构建一个。打开我们在前一页或两页之前开始的项目，或者开始一个新项目。对于这个练习来说，最低和目标SDK级别并不重要。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Selecting an API level of 21 or higher allows Android Studio to employ a technology
    known as hot-swapping. This avoids having to completely rebuild a project each
    time it is run and vastly speeds up the testing of an app. Even if you intend
    to finally target a lower platform, the time hot-swapping saves makes it well
    worth your while lowering this target once the app is as good as developed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 选择API级别为21或更高，允许Android Studio使用一种称为热交换的技术。这避免了每次运行项目时都完全重新构建项目，极大地加快了应用测试的速度。即使你打算最终针对一个更低的平台，热交换节省的时间也使得在应用开发得差不多时降低这个目标是非常值得的。
- en: 'We are going to build a very simple example app that generates objects to represent
    the different types of bread our sandwich builder app might offer. To emphasize
    the pattern, we will keep it simple and have our objects return nothing more sophisticated
    than a string:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建一个非常简单的示例应用，该应用生成对象来表示我们三明治制作应用可能提供的不同类型的面包。为了强调这个模式，我们会保持简单，让我们的对象返回的仅是一个字符串：
- en: Locate the `MainActivity.java` file in the project view.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目视图中找到`MainActivity.java`文件。
- en: Right-click it and create a `New | Java Class` of **Kind****Interface** called
    `Bread`:![The factory pattern](img/B05685_01_03.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击它，并创建一个名为`Bread`的**接口**类型的`New | Java Class`：![The factory pattern](img/B05685_01_03.jpg)
- en: 'Complete the interface as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成接口如下：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create concrete classes of `Bread`, like so:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Bread`的具体类，如下所示：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, create a new class called `BreadFactory` that looks like this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`BreadFactory`的新类，如下所示：
- en: '[PRE5]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: UML diagrams
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UML图表
- en: The key to understanding design patterns lies in understanding their structure
    and how component parts relate to each other. One of the best ways to view a pattern
    is pictorially, and the Unified Modeling Language (UML) class diagrams are a great
    way to accomplish this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 理解设计模式的关键在于理解它们的结构以及各组成部分之间的相互关系。查看模式的一个最佳方式是图形化，统一建模语言（UML）类图是完成这一任务的好方法。
- en: 'Consider the pattern we just created expressed diagrammatically, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们刚才创建的模式以图表的形式表达，如下所示：
- en: '![UML diagrams](img/B05685_01_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![UML diagrams](img/B05685_01_08.jpg)'
- en: 'With our pattern in place, all that is required is to see it in action. For
    this demonstration, we will make use of the **TextView** in our layout that the
    template generated for us and the `onCreate()` method that is called every time
    our main activity is started:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了我们的模式，需要做的就是看到它的实际效果。在这个演示中，我们将使用模板为我们生成的布局中的 **TextView** 和每次主活动启动时都会调用的
    `onCreate()` 方法：
- en: Open the `activity_main.xml` file in **Text** mode.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 **文本** 模式打开 `activity_main.xml` 文件。
- en: 'Add an `id` to the text view, like so:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文本视图添加一个 `id`，如下所示：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open the `MainActivity.java` file and edit the `onCreate()` method to match
    the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 文件，并编辑 `onCreate()` 方法以匹配以下代码：
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Depending on how you have Android Studio set up, you may have to import the
    TextView widget: `import android.widget.TextView;`. Usually, the editor will prompt
    you and import the widget with a simple press of **Alt + Enter**.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您设置 Android Studio 的方式，您可能需要导入 TextView 控件：`import android.widget.TextView;`。通常，编辑器会提示您，只需按
    **Alt + Enter** 就可以导入控件。
- en: 'You can now test the pattern on an emulator or real device:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在模拟器或真实设备上测试这个模式：
- en: '![UML diagrams](img/B05685_01_07.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![UML 图](img/B05685_01_07.jpg)'
- en: This may appear at first glance as an incredibly long-winded way to achieve
    a very simple goal, but therein lies the beauty of patterns. The added layers
    of abstraction allow us to modify our classes without having to edit our activity
    and vice versa. This usefulness will become more apparent as we develop more complex
    objects and encounter situations that require more than a single factory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这或许会让人觉得是实现一个简单目标的一种极其冗长的方式，但模式的魅力正在于此。增加的抽象层使我们能够修改类，而无需编辑我们的活动，反之亦然。随着我们开发更复杂的对象，遇到需要不仅仅一个工厂的情况时，这种实用性会更加明显。
- en: The example we created here is too simple to really require any testing, but
    now is as good a time as any to explore how we test Android apps on both real
    and virtual devices, as well as how we can monitor performance and use debugging
    tools to test output without having to add unnecessary screen components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的例子过于简单，实际上并不需要测试，但现在是一个探索如何在真实和虚拟设备上测试 Android 应用，以及如何监控性能和使用调试工具测试输出而不必添加不必要的屏幕组件的好时机。
- en: Running and testing an app
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和测试应用
- en: There are an enormous number of Android devices available today, and they come
    in a huge variety of shapes and sizes. As developers, we want our applications
    to run on as many devices and form factors as possible, and we want to be able
    to do it with the minimum of coding. Fortunately, the Android platform is well
    suited to this challenge, allowing us to easily adapt layouts and to construct
    virtual devices to match any form factor we can imagine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在市面上有大量的 Android 设备，它们有着各种各样的形状和大小。作为开发者，我们希望我们的应用程序能在尽可能多的设备和形态因素上运行，并且我们希望用最少的编码就能实现这一点。幸运的是，Android
    平台非常适合应对这一挑战，它让我们可以轻松调整布局，构建虚拟设备以匹配我们所能想象到的任何形态因素。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Google provide a very handy cloud-based app testing facility at firebase.google.com/docs/test-lab/
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Google 在 firebase.google.com/docs/test-lab/ 提供了一个非常便捷的基于云的应用测试工具。
- en: Obviously, virtual devices form an essential part of any testing environment,
    but that is not to say that is not very handy to simply plug in one of our own
    devices and test our apps on that. This is not only faster than any emulator,
    but as we shall see now, very simple to set up.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，虚拟设备是任何测试环境的重要组成部分，但这并不是说直接插入我们自己的设备并在此上进行应用测试就不方便。这不仅比任何模拟器都快，而且正如我们现在将要看到的，设置起来非常简单。
- en: Connecting to a real device
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到真实设备
- en: As well as being faster than virtual devices, actual devices also allow us to
    test our apps in real-world situations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际设备不仅比虚拟设备快，还允许我们在真实世界的情况中测试我们的应用。
- en: 'Connecting a real device to our development environment requires two steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将真实设备连接到我们的开发环境需要两个步骤：
- en: Enable developer options on your handset. On some models, this can involve navigating
    to `Settings | About phone` and tapping on `Build number` seven times, which will
    then add `Developer options` to your settings. Use this to enable **USB debugging**
    and to **Allow mock locations**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的手机上启用开发者选项。在某些型号上，这可能涉及到导航到 `设置 | 关于手机` 并点击 `Build number` 七次，之后会在设置中添加 `开发者选项`。使用它来启用
    **USB 调试** 并选择 **允许模拟位置**。
- en: It is more than likely that you will now be able to connect your device to your
    workstation via a USB or the WiFi plugin cable and for it to show up when you
    open Android Studio. If not, you may need to open the SDK Manager and install
    the **Google USB driver** from the **Tools** tab. On some rare occasions, you
    may have to download a USB driver from the device's manufacturer.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在很可能能够通过USB或WiFi插件电缆将你的设备连接到工作站，并在打开Android Studio时显示出来。如果不是这样，你可能需要打开SDK管理器，并从“工具”选项卡安装**Google
    USB驱动程序**。在某些罕见的情况下，你可能需要从设备制造商处下载USB驱动程序。
- en: A real device can be very useful for quickly testing changes in the functionality
    of an app, but to develop how our app looks and behaves on a variety of screen
    shapes and sizes will mean that we will create some virtual devices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际设备对于快速测试应用程序功能更改非常有用，但要开发应用程序在各种屏幕形状和尺寸上的外观和行为，意味着我们将创建一些虚拟设备。
- en: Connecting to a virtual device
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到虚拟设备
- en: 'Android virtual devices (AVDs) allow developers to experiment freely with a
    variety of emulated hardware setups, but they are notoriously slow, can exhaust
    the resources of many computer systems, and lack many of the features present
    in actual devices. Despite these drawbacks, virtual devices are an essential part
    of an Android developers'' toolkit, and by taking a few things into consideration,
    many of these hindrances can be minimized:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Android虚拟设备（AVD）允许开发者自由地实验各种硬件配置的模拟，但它们速度慢，可能会耗尽许多计算机系统的资源，并且缺少实际设备中的许多功能。尽管有这些缺点，虚拟设备仍然是Android开发者工具箱中不可或缺的一部分，通过考虑一些事项，可以最小化许多这些障碍：
- en: Strip your virtual device down to only the features your app is designed for.
    For example, if you are not building an app that takes photos, remove camera functionality
    from the emulator; one can always be added later.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的虚拟设备精简到只包含你的应用程序所需的功能。例如，如果你的应用不需要拍照，就从模拟器中移除摄像头功能；以后可以根据需要添加。
- en: Keep the memory and storage requirements of the AVD to a minimum. Another device
    can easily be created as and when an app needs it.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将AVD的内存和存储需求降到最低。当应用程序需要时，可以轻松创建另一个设备。
- en: Only create AVDs with very recent API levels when you need to test for specifically
    new features.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在需要测试特定新功能时，才创建具有非常新的API级别的AVD。
- en: Begin by testing on virtual devices with low screen resolution and density.
    These will run much faster and still allow you to test for different screen sizes
    and aspect ratios.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从测试低屏幕分辨率和密度的虚拟设备开始。这些设备运行速度更快，并且仍然允许你测试不同的屏幕尺寸和宽高比。
- en: Try separating very resource demanding functions and testing them individually.
    For example, if your app utilizes large collections of high-definition images,
    you can save time by testing this functionality separately.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将资源需求非常大的功能分离出来，单独测试。例如，如果你的应用使用了大量高清晰度的图片集，你可以通过单独测试这个功能来节省时间。
- en: It is generally quicker to construct virtual devices to suit specific purposes
    rather than an all-purpose one to test all our apps on, and there is a growing
    number of third-party Android emulators available, such as *Android-x86* and *Genymotion*,
    that are often faster and have more development features.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常构建针对特定目的的虚拟设备比构建一个全能型的设备来测试我们所有的应用程序要快，而且现在有越来越多的第三方Android模拟器可用，如*Android-x86*和*Genymotion*，它们通常速度更快且拥有更多开发功能。
- en: 'It is also worth noting that when testing for layouts only, Android Studio
    provides some powerful preview options that allow us to view our potential UIs
    on a wide number of form factors, SDK levels and themes, as can be seen in the
    next image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当仅测试布局时，Android Studio提供了一些强大的预览选项，允许我们在众多形态、SDK级别和主题上查看我们潜在的用户界面，如下一个图像所示：
- en: '![Connecting to a virtual device](img/B05685_01_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![连接到虚拟设备](img/B05685_01_04.jpg)'
- en: For now, create a basic AVD to run and test the current project on. There is
    nothing really to test, but we are going to see how to monitor our app's behavior
    during runtime and how to use the debug monitor service to test output without
    having to use the device screen, which is not an attractive way to debug a project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个基本的AVD来运行并测试当前项目。实际上并没有什么需要测试的，但我们将了解如何监控应用程序在运行时的行为，以及如何使用调试监控服务来测试输出，而无需使用设备屏幕，这不是一个吸引人的调试项目的方式。
- en: Monitoring devices
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控设备
- en: 'The following demonstration works equally well on either an emulated device
    or a real one, so select whichever is easiest for you. If you are creating an
    AVD, then it will not require a large or high density screen or a large memory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的演示在模拟设备或真实设备上同样有效，所以选择对你来说最简单的一个。如果你在创建AVD，那么它不需要大屏幕或高密度屏幕，也不需要大量内存：
- en: Open the project we just worked on.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚才工作的项目。
- en: From the `Tools | Android` menu, enable **ADB Integration**.![Monitoring devices](img/B05685_01_05.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`工具 | 安卓`菜单中，启用**ADB集成**。![监控设备](img/B05685_01_05.jpg)
- en: From the same menu, select **Android Device Monitor**, although this may well
    already be running.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从同一菜单中，选择**Android设备监控器**，尽管它可能已经在运行。
- en: Now run the application on your connected device with the Android Monitor.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在连接的设备上使用Android Monitor运行应用程序。
- en: 'The Device Monitor is useful in several ways:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设备监控器在多种方式上非常有用：
- en: The **Monitors** tab can be used during runtime to view live system information
    such as how much memory or CPU time our app is using. This can be particularly
    helpful when we want to see what resources our apps are using when they are not
    running in the foreground.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控器**标签可以在运行时使用，以查看实时的系统信息，例如我们的应用使用了多少内存或CPU时间。当我们想要查看应用不在前台运行时使用了哪些资源时，这尤其有帮助。'
- en: The monitor can be set to collect a variety of data, such as method tracking
    and resource usage, and store these as files, which can be viewed in the **Captures**
    pane (which can usually be opened from the left-hand gutter).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控器可以设置为收集各种数据，如方法跟踪和资源使用，并将这些数据存储为文件，可以在**捕获**窗格中查看（通常可以从左侧边栏打开）。
- en: Screenshots and videos of an app in action are very simple to capture.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获应用运行时的屏幕截图和视频非常简单。
- en: '**LogCat** is a particularly useful tool as it not only reports live on an
    app''s behavior, but as we will see next, can also generate user-defined output.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogCat**是一个特别有用的工具，它不仅可以实时报告应用的行为，而且如我们接下来将看到的，还可以生成用户定义的输出。'
- en: 'Using a text view to test our factory pattern is a convenient but clumsy way
    to test our code for now, but once we start developing sophisticated layouts,
    it would soon become very inconvenient. A far more elegant solution is to use
    debug tools that can be viewed without affecting our UIs. The rest of this exercise
    demonstrates how to do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本视图测试我们的工厂模式是一种方便但笨拙的方法，但一旦我们开始开发复杂的布局，它很快就会变得非常不方便。一种更优雅的解决方案是使用可以在不影响我们UI的情况下查看的调试工具。本练习的其余部分将演示如何做到这一点：
- en: Open the `MainActivity.java` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件。
- en: 'Declare the following constant:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下常量：
- en: '[PRE8]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, you may have to confirm the importing of `android.util.Log;`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，你可能需要确认导入`android.util.Log;`。
- en: 'Replace the line in the `onCreate()` method that sets the text of the text
    view with the following line:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换`onCreate()`方法中设置文本视图文本的行，使用以下行：
- en: '[PRE9]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Open the Device Monitor again. This can be done with **Alt + 6**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开设备监控器。这可以通过按**Alt + 6**来完成。
- en: From the dropdown in the top-right of the monitor, select **Edit Filter Configuration**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在监控器右上角的下拉菜单中，选择**编辑过滤器配置**。
- en: Complete the resultant dialog, as seen here:![Monitoring devices](img/B05685_01_06.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成如图所示的对话框：![监控设备](img/B05685_01_06.jpg)
- en: 'Running the app and testing our factory demo should produce an output in the
    logcat monitor similar to the one seen here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用并测试我们的工厂演示应该在logcat监控器中产生类似于这里的输出：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can, of course, still use `System.out.println()` if you like, and it will
    print out in the ADB monitor, but you will have to search for it among the other
    output.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你愿意，你仍然可以使用`System.out.println()`，它将在ADB监控器中打印出来，但你将不得不在其他输出中搜索它。
- en: Having seen how we can test our apps on both real and virtual devices and how
    we can use debug and monitoring tools to interrogate our apps during runtime,
    we can now move on to a more realistic situation involving more than a single
    factory and an output more sophisticated than a two-word string.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何在真实和虚拟设备上测试应用，以及如何使用调试和监控工具在运行时对应用进行询问。现在，我们可以进入一个更真实的情况，涉及不止一个工厂，输出的结果也远比一个双词字符串复杂。
- en: The abstract factory pattern
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: When making a sandwich, bread is only our first and most basic ingredient; we
    obviously need some kind of filling. In programming terms, this could mean simply
    building another interface like `Bread` but calling it `Filling` and providing
    it with its own associated factory. Equally, we could create a global interface
    called `Ingredient` and have both `Bread` and `Filling` as examples of this. Either
    way, we would have to do a fair bit of re-coding elsewhere.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 制作三明治时，面包只是我们第一个也是最基础的原料；显然，我们需要某种填充物。在编程术语中，这可能意味着像`Bread`一样简单地构建另一个接口，但将其称为`Filling`，并为它提供自己的关联工厂。同样，我们可以创建一个名为`Ingredient`的全局接口，并将`Bread`和`Filling`作为它的示例。无论哪种方式，我们都需要在其他地方进行大量的重新编码。
- en: The design pattern paradigm offers the **abstract factory pattern** as perhaps
    the most adaptable solution to this dilemma. An abstract factory is simply **a
    factory that creates other factories**. The added layer of abstraction that this
    requires is amply paid off when we consider how little the top-level control code
    in our main activity needs to be altered, if at all. Being able to modify low-level
    structures without affecting those preceding constitutes one of the major reasons
    for applying design patterns, and when applied to complex architectures, this
    flexibility can shave many weeks off development time and allow more room for
    experimentation than other approaches.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式范式提供了**抽象工厂模式**，这可能是解决这一困境最灵活的解决方案。抽象工厂仅仅就是**创建其他工厂的工厂**。这种所需的额外抽象层次，在我们考虑到主活动中的顶层控制代码几乎不需要修改（如果有的话）时得到了充分的回报。能够修改低级结构而不影响之前的结构，正是应用设计模式的主要原因之一，当应用于复杂架构时，这种灵活性可以节省许多开发时间，并比其他方法提供更多的实验空间。
- en: Working with more than one factory
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用一个以上的工厂工作
- en: The similarities between this next project and the last are striking, as they
    should be; one of the best things about patterns is that we can reuse structures.
    You can either edit the previous example or start one from scratch. Here, we will
    be starting a new project; hopefully that will help make the pattern itself clearer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目与上一个项目之间的相似性非常明显，应该是这样；模式最好的事情之一是我们可以重用结构。你可以编辑之前的示例或从头开始。在这里，我们将开始一个新项目；希望这将有助于使模式本身更加清晰。
- en: The **abstract factory** works in a slightly different way to our previous example.
    Here, our activity makes uses of a factory generator, which in turn makes use
    of an abstract factory class that handles the task of deciding which actual factory
    to call, and hence which concrete class to create.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象工厂**的工作方式与我们的上一个示例略有不同。在这里，我们的活动使用了一个工厂生成器，该生成器进而使用一个抽象工厂类来处理决定调用哪个实际工厂的任务，从而创建哪个具体类。'
- en: 'As before we will not concern ourselves with the actual mechanics of input
    and output, but rather concentrate on the pattern''s structure. Before continuing,
    start a new Android Studio project. Call it whatever you choose, set the minimum
    API level as low as you like, and use the Blank Activity template:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们不关心输入和输出的实际机制，而是专注于模式的结构。在继续之前，启动一个新的Android Studio项目。可以随意命名，将最低API级别设为你喜欢的低水平，并使用空白活动模板：
- en: 'We begin, just as we did before, by creating the interface; only this time,
    we will need two of them: one for the bread and one for the filling. They should
    look like this:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始，就像之前一样，创建接口；但这次，我们需要两个：一个用于面包，一个用于填充物。它们应该如下所示：
- en: '[PRE11]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As before, create concrete examples of these interfaces. Here, to save space,
    we will just create two of each. They are all almost identical, so here is just
    one:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，创建这些接口的具体示例。为了节省空间，这里我们只创建每种两个。它们几乎都是相同的，所以这里只有一个：
- en: '[PRE12]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create another `Bread` called `Brioche` and two fillings called `Cheese` and
    `Tomato`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`Brioche`的`Bread`类和两种填充物，分别叫做`Cheese`和`Tomato`。
- en: 'Next, create a class that can call on each type of factory:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个可以调用每种类型工厂的类：
- en: '[PRE13]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now create the factories themselves. First, `BreadFactory`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建工厂本身。首先，`BreadFactory`：
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then, `FillingFactory`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`FillingFactory`：
- en: '[PRE15]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add the factory generator class itself:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加工厂生成器类本身：
- en: '[PRE16]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can test our code just as before, with a debug tag, like so:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像之前一样测试我们的代码，使用一个调试标签，如下所示：
- en: '[PRE17]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When tested, this should produce the following output in the Android monitor:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时，这应该在Android监视器中产生以下输出：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By the time we reach the end of the book, each ingredient will be a complex
    object in its own right, with associated imagery and descriptive text, price,
    calorific value, and more. This is when adhering to patterns will really pay off,
    but a very simple example like the one here is a great way to demonstrate how
    creational patterns such as the abstract factory allow us to make changes to our
    products without affecting client code or deployment.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，每个成分都将是一个复杂的对象，拥有相关的图像和描述性文本、价格、卡路里价值等等。这时遵循模式将真正带来好处，但像这里一个非常简单的例子就能很好地展示出如何使用抽象工厂这样的创建型模式，让我们在不影响客户端代码或部署的情况下对产品进行修改。
- en: 'As before, our understanding of the pattern can be enhanced with a visual representation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，通过视觉表示可以增强我们对模式的了解：
- en: '![Working with more than one factory](img/B05685_01_09.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![同时使用多个工厂](img/B05685_01_09.jpg)'
- en: 'Imagine we wanted to include soft drinks in our menu. These are neither bread
    nor filling, and we would need to introduce a whole new type of object. The pattern
    of how to add this is already laid out. We will need a new interface that would
    be identical to the others, only called `Drink`; it would utilize the same `name()
    and calories()` methods, and concrete classes such as `IcedTea` could be implemented
    along exactly the same lines as above, for example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在菜单中包含软饮料。这些既不是面包也不是填充物，我们需要引入一种全新的对象类型。添加这种模式的方案已经制定好了。我们需要一个新的接口，它与其他接口相同，只是叫做`Drink`；它将使用相同的`name()和calories()`方法，具体的类如`IcedTea`可以按照上面的完全相同的线路实现，例如：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We would need to extend our abstract factory with something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要扩展我们的抽象工厂，如下所示：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We also, of course, need to implement a `DrinkFactory` class, but this too would
    have the same structure as the other factories.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要实现一个`DrinkFactory`类，但这个类的结构与其他工厂相同。
- en: In other words, we can add, delete, change, and generally muck around with the
    nuts and bolts of a project, without ever really having to bother with how these
    changes are perceived by the higher-level logic of our software.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以添加、删除、更改，以及随意摆弄项目的细节，而无需真正关心这些更改是如何被我们软件的高级逻辑所感知的。
- en: The factory pattern is one of the most frequently used of all patterns. It can
    and should be used in many situations. However, like all patterns, it can be overused
    or underused, if not thought about carefully. When considering the overall architecture
    of a project, there are, as we shall see, many other patterns at our disposal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是所有模式中使用最频繁的模式之一。它可以在许多情况下使用，也应该被使用。然而，像所有模式一样，如果不仔细考虑，它可能会被过度使用或使用不足。当我们考虑项目的整体架构时，正如我们将会看到的，还有许多其他模式可供我们使用。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered quite a lot, considering that this is an introductory chapter.
    We've built examples of two of the best known and most useful design patterns
    and hopefully seen why they might be of use to us.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这是一个介绍性的章节，我们已经涵盖了很多内容。我们已经构建了两种最著名和最有用的设计模式的示例，并希望了解它们为什么对我们有用。
- en: We began by looking at what patterns are and why we might use them in an Android
    setting. This was helped by taking a look at the development tools at our disposal,
    and how and why we can and should target specific platform versions and form factors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨了模式是什么，以及为什么在 Android 环境中可能会使用它们。这得益于我们查看了一下可用的开发工具，以及我们如何以及为什么应该针对特定的平台版本和形态因素进行定位。
- en: We then applied this knowledge to create two very simple apps that employed
    basic factory patterns and saw how we can test and then retrieve data from an
    app running on any device, be it real or virtual.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这一知识应用于创建两个非常简单的应用程序，这些程序使用了基本的工厂模式，并看到了如何测试并从运行在任何设备上的应用程序中检索数据，无论是真实的还是虚拟的。
- en: This puts us in a great situation to take a look at other patterns and consider
    which to use when building a fully working app. This is something we will look
    at more closely in the next chapter, where we will introduce the builder pattern
    and how Android layouts are produced.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们有机会看看其他模式，并考虑在构建一个完全工作的应用程序时使用哪些模式。我们将在下一章更详细地介绍这一点，其中将介绍构建器模式以及如何生成 Android
    布局。
