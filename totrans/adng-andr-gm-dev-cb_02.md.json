["```kt\nEntity layer = new Entity();\nmScene.attachChild(layer);\n```", "```kt\n      float baseBufferData[] = {\n          /* First Triangle */\n          0, BASE_HEIGHT, UNUSED, /* first point */\n          BASE_WIDTH, BASE_HEIGHT, UNUSED, /* second point */\n          BASE_WIDTH, 0, UNUSED, \t/* third point */\n\n          /* Second Triangle */\n          BASE_WIDTH, 0, UNUSED, /* first point */\n          0, 0, UNUSED, /* second point */\n          0, BASE_HEIGHT, UNUSED, /* third point */\n      };\n    ```", "```kt\n    Mesh baseMesh = new Mesh((WIDTH * 0.5f) - (BASE_WIDTH * 0.5f), 0, baseBufferData, baseBufferData.length / POINTS_PER_TRIANGLE, DrawMode.TRIANGLES, mEngine.getVertexBufferObjectManager());\n    ```", "```kt\n      0, BASE_HEIGHT, UNUSED, /* first point */\n      BASE_WIDTH, BASE_HEIGHT, UNUSED, /* second point */\n      BASE_WIDTH, 0, UNUSED,  /* third point */\n```", "```kt\n      BASE_WIDTH, 0, UNUSED, /* first point */\n      0, 0, UNUSED, /* second point */\n      0, BASE_HEIGHT, UNUSED, /* third point */\n```", "```kt\n      0, DOOR_HEIGHT, UNUSED, /* first point */\n      DOOR_WIDTH, DOOR_HEIGHT, UNUSED, /* second point */\n      DOOR_WIDTH, 0, UNUSED, /* third point */\n      0, 0, UNUSED, /* fourth point */\n      0, DOOR_HEIGHT, UNUSED /* fifth point */\n```", "```kt\n      BitmapTextureAtlasTextureRegionFactory.setAssetBasePath(\"gfx/\");\n\n        /* Create the bitmap texture atlas for the sprite's texture region */\n        BuildableBitmapTextureAtlas mBitmapTextureAtlas = new BuildableBitmapTextureAtlas(mEngine.getTextureManager(), 256, 256, TextureOptions.BILINEAR);\n\n        /* Create the sprite's texture region via the BitmapTextureAtlasTextureRegionFactory */\n        mSpriteTextureRegion = BitmapTextureAtlasTextureRegionFactory.createFromAsset(mBitmapTextureAtlas, this, \"sprite.png\");\n\n        /* Build the bitmap texture atlas */\n        try {\n          mBitmapTextureAtlas.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 1, 1));\n        } catch (TextureAtlasBuilderException e) {\n          e.printStackTrace();\n        }\n        /* Load the bitmap texture atlas into the device's gpu memory */\n        mBitmapTextureAtlas.load();\n    ```", "```kt\n        final float positionX = WIDTH * 0.5f;\n        final float positionY = HEIGHT * 0.5f;\n\n        /* Add our marble sprite to the bottom left side of the Scene initially */\n        Sprite mSprite = new Sprite(positionX, positionY, mSpriteTextureRegion, mEngine.getVertexBufferObjectManager());\n    The last step is to attach our Sprite to the Scene, as is necessary in order to display any type of Entity on the device's display:\n        /* Attach the marble to the Scene */\n        mScene.attachChild(mSpriteTextureRegion);\n    ```", "```kt\n    /* Create the texture atlas at the same dimensions as the image (300x50)*/\n    BuildableBitmapTextureAtlas mBitmapTextureAtlas = new BuildableBitmapTextureAtlas(mEngine.getTextureManager(), 300, 50, TextureOptions.BILINEAR);\n\n    /* Create the TiledTextureRegion object, passing in the usual parameters,\n     * as well as the number of rows and columns in our sprite sheet for the \n     * final two parameters */\n    mTiledTextureRegion = BitmapTextureAtlasTextureRegionFactory.createTiledFromAsset(mBitmapTextureAtlas, this, \"gfx/sprite_sheet.png\", 12, 1);\n\n    /* Build and load the mBitmapTextureAtlas object */\n    try {\n      mBitmapTextureAtlas.build(new BlackPawnTextureAtlasBuilder<IBitmapTextureAtlasSource, BitmapTextureAtlas>(0, 0, 0));\n    } catch (TextureAtlasBuilderException e) {\n      e.printStackTrace();\n    }\n    mBitmapTextureAtlas.load();\n```", "```kt\n    /* Create a new animated sprite in the center of the scene */\n    AnimatedSprite animatedSprite = new AnimatedSprite(WIDTH * 0.5f, HEIGHT * 0.5f, mTiledTextureRegion, mEngine.getVertexBufferObjectManager());\n\n    /* Length to play each frame before moving to the next */\n    long frameDuration[] = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200};\n\n    /* We can define the indices of the animation to play between */\n    int firstTileIndex = 0;\n    int lastTileIndex = mTiledTextureRegion.getTileCount();\n\n    /* Allow the animation to continuously loop? */\n    boolean loopAnimation = true;\n\n    * Animate the sprite with the data as set defined above */\n    animatedSprite.animate(frameDuration, firstTileIndex, lastTileIndex, loopAnimation, new IAnimationListener(){\n\n      @Override\n      public void onAnimationStarted(AnimatedSprite pAnimatedSprite,\n          int pInitialLoopCount) {\n        /* Fired when the animation first begins to run*/\n      }\n\n      @Override\n      public void onAnimationFrameChanged(AnimatedSprite pAnimatedSprite,\n          int pOldFrameIndex, int pNewFrameIndex) {\n         /* Fired every time a new frame is selected to display*/\n      }\n\n      @Override\n      public void onAnimationLoopFinished(AnimatedSprite pAnimatedSprite,\n          int pRemainingLoopCount, int pInitialLoopCount) {\n        /* Fired when an animation loop ends (from first to last frame) */\n      }\n\n      @Override\n      public void onAnimationFinished(AnimatedSprite pAnimatedSprite) {\n        /* Fired when an animation sequence ends */\n      }\n      );\n\n    mScene.attachChild(animatedSprite);\n```", "```kt\n@Override\nprotected void preDraw(GLState pGLState, Camera pCamera) {\n  // Enable dithering\n  pGLState.enableDither();\n  super.preDraw(pGLState, pCamera);\n}\n\n@Override\nprotected void postDraw(GLState pGLState, Camera pCamera) {\n  // Disable dithering\n  pGLState.disableDither();\n  super.postDraw(pGLState, pCamera);\n}\n```", "```kt\n        mFont = FontFactory.create(mEngine.getFontManager(),\n            mEngine.getTextureManager(), 256, 256,\n            Typeface.create(Typeface.DEFAULT, Typeface.NORMAL), 32f, true,\n            Color.WHITE);\n        mFont.load();\n\n        /*\n         * Prepare the mFont object for the most common characters used. This\n         * will eliminate the need for the garbage collector to run when using a\n         * letter/number that's never been used before\n         */\n          mFont.prepareLetters(\"Time: 1234567890\".toCharArray());\n    Once we've got our Font object created and ready for use, we can create the Text:\n        /* Create the time Text object which will update itself as time passes */\n        Text mTimeText = new Text(0, timeTextHeight, mFont, TIME_STRING_PREFIX\n            + TIME_FORMAT, MAX_CHARACTER_COUNT, mEngine.getVertexBufferObjectManager()) {\n\n          // Overridden methods as seen in step 3...\n        };\n    ```", "```kt\n        int lastSecond = 0;\n\n        @Override\n        protected void onManagedUpdate(float pSecondsElapsed) {\n\n          Calendar c = Calendar.getInstance();\n\n          /*\n          * We will only obtain the second for now in order to verify\n           * that it's time to update the Text's string\n          */\n          final int second = c.get(Calendar.SECOND);\n\n          /*\n           * If the last update's second value is not equal to the\n          * current...\n           */\n          if (lastSecond != second) {\n\n          /* Obtain the new hour and minute time values */\n            final int hour = c.get(Calendar.HOUR);\n            final int minute = c.get(Calendar.MINUTE);\n\n            /* also, update the latest second value */\n            lastSecond = second;\n\n             /* Build a new string with the current time */\n            final String timeTextSuffix = hour + \":\" + minute + \":\"\n               + second;\n\n            /* Set the Text object's string to that of the new time */\n            this.setText(TIME_STRING_PREFIX + timeTextSuffix);\n\n            /*\n              * Since the width of the Text will change with every change\n             * in second, we should realign the Text position to the\n              * edge of the screen minus half the Text's width\n            */\n            this.setX(WIDTH - this.getWidth() * 0.5f);\n          }\n\n          super.onManagedUpdate(pSecondsElapsed);\n        }\n    Finally, we can make color adjustments to the Text and then attach it to the Scene or another Entity:\n        /* Change the color of the Text to blue */\n        mTimeText.setColor(0, 0, 1);\n\n        /* Attach the Text object to the Scene */\n        mScene.attachChild(mTimeText);\n    ```", "```kt\n  private static final String TIME_STRING_PREFIX = \"Time: \";\n  private static final String TIME_FORMAT = \"00:00:00\";\n\n  /* Obtain the maximum number of characters that our Text \n   * object will need to display*/\n  private static final int MAX_CHARACTER_COUNT = TIME_STRING_PREFIX.length() + TIME_FORMAT.length();\n```", "```kt\n    public class RelativeRotation extends BaseGameActivity implements IOnSceneTouchListener{\n    ```", "```kt\n    mScene.setOnSceneTouchListener(this);\n    ```", "```kt\n        /* Add our marble sprite to the bottom left side of the Scene initially */\n        mMarbleSprite = new Sprite(mMarbleTextureRegion.getWidth(), mMarbleTextureRegion.getHeight(), mMarbleTextureRegion, mEngine.getVertexBufferObjectManager());\n\n        /* Attach the marble to the Scene */\n        mScene.attachChild(mMarbleSprite);\n\n        /* Create the arrow sprite and center it in the Scene */\n        mArrowSprite = new Sprite(WIDTH * 0.5f, HEIGHT * 0.5f, mArrowTextureRegion, mEngine.getVertexBufferObjectManager());\n\n        /* Attach the arrow to the Scene */\n        mScene.attachChild(mArrowSprite);\n    ```", "```kt\n      @Override\n      public boolean onSceneTouchEvent(Scene pScene, TouchEvent pSceneTouchEvent) {\n        // If a user moves their finger on the device\n        if(pSceneTouchEvent.isActionMove()){\n\n          /* Set the marble's position to that of the touch even coordinates */\n         mMarbleSprite.setPosition(pSceneTouchEvent.getX(), pSceneTouchEvent.getY());\n\n          /* Calculate the difference between the two sprites x and y coordinates */\n          final float dX = mMarbleSprite.getX() - mArrowSprite.getX();\n          final float dY = mMarbleSprite.getY() - mArrowSprite.getY();\n\n          /* Calculate the angle of rotation in radians*/\n          final float angle = (float) Math.atan2(-dY, dX);\n          /* Convert the angle from radians to degrees, adding the default image rotation */\n          final float rotation = MathUtils.radToDeg(angle) + DEFAULT_IMAGE_ROTATION;\n\n          /* Set the arrow's new rotation */\n          mArrowSprite.setRotation(rotation);\n\n          return true;\n        }\n\n        return false;\n      }\n    ```", "```kt\nmMarbleSprite.setPosition(pSceneTouchEvent.getX(), pSceneTouchEvent.getY());\n```", "```kt\n/* Calculate the difference between the two sprites x and y coordinates */\nfinal float dX = mMarbleSprite.getX() - mArrowSprite.getX();\nfinal float dY = mMarbleSprite.getY() - mArrowSprite.getY();\n\n/* Calculate the angle of rotation in radians*/\nfinal float angle = (float) Math.atan2(-dY, dX);\n```", "```kt\n/* Convert the angle from radians to degrees, adding the default image rotation */\nfinal float rotation = MathUtils.radToDeg(angle) + DEFAULT_IMAGE_ROTATION;\n\n/* Set the arrow's new rotation */\nmArrowSprite.setRotation(rotation);\n```", "```kt\n        /* Value which defines the rotation speed of this Entity */\n        final int rotationIncrementalFactor = 25;\n\n        /* Override the onManagedUpdate() method of this Entity */\n        @Override\n        protected void onManagedUpdate(float pSecondsElapsed) {\n\n          /* Calculate a rotation offset based on time passed */\n          final float rotationOffset = pSecondsElapsed * rotationIncrementalFactor;\n\n          /* Apply the rotation offset to this Entity */\n          this.setRotation(this.getRotation() + rotationOffset);\n\n          /* Proceed with the rest of this Entity's update process */\n          super.onManagedUpdate(pSecondsElapsed);\n        }\n    ```", "```kt\n        /* Value to increment this rectangle's position by on each update */\n        final int incrementXValue = 5;\n\n        /* Obtain half the Entity's width and height values */\n        final float halfWidth = this.getWidth() * 0.5f;\n        final float halfHeight = this.getHeight() * 0.5f;\n\n        /* Override the onManagedUpdate() method of this Entity */\n        @Override\n        protected void onManagedUpdate(float pSecondsElapsed) {\n\n          /* Obtain the current x/y values */\n          final float currentX = this.getX();\n          final float currentY = this.getY();\n\n          /* obtain the max width and next height, used for condition checking */\n          final float maxWidth = currentX + halfWidth;\n          final float nextHeight = currentY + halfHeight;\n\n          // On every update...\n          /* Increment the x position if this Entity is within the camera WIDTH */\n           if(maxWidth <= WIDTH){\n            /* Increase this Entity's x value by 5 pixels */\n            this.setX(currentX + incrementXValue);\n          } else {\n            /* Reset the Entity back to the bottom left of the Scene if it exceeds the mCamera's\n            * HEIGHT value */\n            if(nextHeight >= HEIGHT){\n            this.setPosition(halfWidth, halfHeight);\n            } else {\n              /* if this Entity reaches the WIDTH value of our camera, move it\n               * back to the left side of the Scene and slightly increment its y position */\n              this.setPosition(halfWidth, nextHeight);\n            }\n          }\n\n           /* If the two rectangle's are colliding, set this rectangle's color to GREEN */\n          if(this.collidesWith(mRectangleOne) && this.getColor() != org.andengine.util.adt.color.Color.GREEN){\n          this.setColor(org.andengine.util.adt.color.Color.GREEN);\n\n          /* If the rectangle's are no longer colliding, set this rectangle's color to RED */\n          } else if(this.getColor() != org.andengine.util.adt.color.Color.RED){\n          this.setColor(org.andengine.util.adt.color.Color.RED);\n          }\n\n          /* Proceed with the rest of this Entity's update process */\n          super.onManagedUpdate(pSecondsElapsed);\n       }\n    ```", "```kt\nsuper.onManagedUpdate(pSecondsElapsed * 0.5f);\n```", "```kt\n    /* Define the rectangle's width/height values */\n    final int rectangleDimensions = 80;\n\n    /* Define the initial rectangle position in the bottom \n     * left corner of the Scene */\n    final int initialPosition = (int) (rectangleDimensions * 0.5f);\n\n    /* Create the Entity which we will apply modifiers to */\n    Rectangle rectangle = new Rectangle(initialPosition, initialPosition, rectangleDimensions, rectangleDimensions, mEngine.getVertexBufferObjectManager());\n\n    /* Set the rectangle's color to white so we can see it on the Scene */\n    rectangle.setColor(org.andengine.util.adt.color.Color.WHITE);\n\n    /* Attach the rectangle to the Scene */\n    mScene.attachChild(rectangle);\n    ```", "```kt\n    /* Define the movement modifier values */\n    final float duration = 3;\n    final float fromX = initialPosition;\n    final float toX = WIDTH - rectangleDimension * 0.5f;\n    final float fromY = initialPosition;\n    final float toY = HEIGHT - rectangleDimension * 0.5f;\n\n    /* Create the MoveModifier with the defined values */\n    MoveModifier moveModifier = new MoveModifier(duration, fromX, fromY, toX, toY);\n    ```", "```kt\n    /* Register the moveModifier to our rectangle entity */\n    rectangle.registerEntityModifier(moveModifier);\n    ```", "```kt\n            /* Create a list which specifies X coordinates to follow */\n            final float pointsListX[] = {\n                initialPosition, /* First x position */\n                WIDTH - initialPosition, /* Second x position */\n                WIDTH - initialPosition, /* Third x position */\n                initialPosition, /* Fourth x position */\n                initialPosition /* Fifth x position */\n            };\n\n            /* Create a list which specifies Y coordinates to follow */\n            final float pointsListY[] = {\n                initialPosition, /* First y position */\n                HEIGHT - initialPosition, /* Second y position */\n                initialPosition, /* Third y position */\n                HEIGHT - initialPosition, /* Fourth y position */\n                initialPosition /* Fifth y position */\n            };\n        ```", "```kt\n            /* Obtain the number of control points we have */\n            final int controlPointCount = pointsListX.length;\n\n            /* Create our Path object which we will pair our x/y coordinates into */\n            org.andengine.entity.modifier.PathModifier.Path path = new Path(controlPointCount);\n\n            /* Iterate through our point lists */\n            for(int i = 0; i < controlPointCount; i++){\n              /* Obtain the coordinates of the control point at the index */\n              final float positionX = pointsListX[i];\n              final float positionY = pointsListY[i];\n\n              /* Setup a new way-point by pairing together an x and y coordinate */\n              path.to(positionX, positionY);\n            }\n        ```", "```kt\n            /* Movement duration */\n            final float duration = 3;\n            /* Create the PathModifier */\n            PathModifier pathModifier = new PathModifier(duration, path);\n\n            /* Register the pathModifier object to the rectangle */\n            rectangle.registerEntityModifier(pathModifier);\n        ```", "```kt\n            /* Obtain the number of control points we have */\n            final int controlPointCount = pointsListX.length;\n\n            /* Define the movement tension. Must be between -1 and 1 */\n            final float tension = 0f;\n\n            /* Create the cardinal spline movement modifier configuration */\n            CardinalSplineMoveModifierConfig config = new CardinalSplineMoveModifierConfig(controlPointCount, tension);\n        ```", "```kt\n            /* Iterate through our control point indices */\n            for(int index = 0; index < controlPointCount; index++){\n\n              /* Obtain the coordinates of the control point at the index */\n              final float positionX = pointsListX[index];\n              final float positionY = pointsListY[index];\n\n              /* Set position coordinates at the current index in the config object */\n              config.setControlPoint(index, positionX, positionY);\n            }\n        ```", "```kt\n            /* Movement duration */\n            final float duration = 3;\n\n            /* Create the cardinal spline move modifier object */\n            CardinalSplineMoveModifier cardinalSplineMoveModifier = new CardinalSplineMoveModifier(duration, config);\n\n            /* Register the cardinalSplineMoveModifier object to the rectangle object */\n            rectangle.registerEntityModifier(cardinalSplineMoveModifier);\n        ```", "```kt\n        /* Define the move modifiers properties */\n        final float duration = 3;\n        final float fromX = 0;\n        final float toX = 100;\n\n        /* Create the move modifier */\n        MoveXModifier moveXModifier = new MoveXModifier(duration, fromX, toX);\n\n        /* Create a loop entity modifier, which will loop the move modifier\n         *  indefinitely, or until unregistered from the rectangle.\n         *  If we want to provide a loop count, we can add a second int parameter \n         *  to this constructor */\n        LoopEntityModifier loopEntityModifier = new LoopEntityModifier(moveXModifier);\n\n        /* register the loopEntityModifier to the rectangle */\n        rectangle.registerEntityModifier(loopEntityModifier);\n\n    ```", "```kt\n        /* Scale modifier properties */\n        final float scaleDuration = 2;\n        final float fromScale = 1;\n        final float toScale = 2;\n        /* Create a scale modifier */\n        ScaleModifier scaleModifier = new ScaleModifier(scaleDuration, fromScale, toScale);\n\n        /* Rotation modifier properties */\n        final float rotateDuration = 3;\n        final float fromRotation = 0;\n        final float toRotation = 360 * 4;\n        /* Create a rotation modifier */\n        RotationModifier rotationModifier = new RotationModifier(rotateDuration, fromRotation, toRotation);\n\n        /* Create a parallel entity modifier */\n        ParallelEntityModifier parallelEntityModifier = new ParallelEntityModifier(scaleModifier, rotationModifier);\n\n        /* Register the parallelEntityModifier to the rectangle */\n        rectangle.registerEntityModifier(parallelEntityModifier);\n\n    ```", "```kt\n        /* Move modifier properties */\n        final float moveDuration = 2;\n        final float fromX = initialPosition;\n        final float toX = WIDTH * 0.5f;\n        final float fromY = initialPosition;\n        final float toY = HEIGHT * 0.5f;\n        /* Create a move modifier */\n        MoveModifier moveModifier = new MoveModifier(moveDuration, fromX, fromY, toX, toY);\n\n        /* Create a delay modifier */\n        DelayModifier delayModifier = new DelayModifier(2);\n\n        /* Scale modifier properties */\n        final float scaleDuration = 2;\n        final float fromScale = 1;\n        final float toScale = 0;\n        /* Create a scale modifier */\n        ScaleModifier scaleModifier = new ScaleModifier(scaleDuration, fromScale, toScale);\n\n        /* Create a sequence entity modifier */\n        SequenceEntityModifier sequenceEntityModifier = new SequenceEntityModifier(moveModifier, delayModifier, scaleModifier);\n\n        /* Register the sequenceEntityModifier to the rectangle */\n       rectangle.registerEntityModifier(sequenceEntityModifier);\n    ```", "```kt\nIEntityModifierListener entityModifierListener = new IEntityModifierListener(){\n\n  // When the modifier starts, this method is called\n  @Override\n  public void onModifierStarted(IModifier<IEntity> pModifier,\n      IEntity pItem) {\n    Log.i(\"MODIFIER\", \"Modifier started!\");\n  }\n\n  // When the modifier finishes, this method is called\n  @Override\n  public void onModifierFinished(final IModifier<IEntity> pModifier,\n      final IEntity pItem) {\n    Log.i(\"MODIFIER\", \"Modifier started!\");\n  }\n};\n\nmodifier.addModifierListener();\n```", "```kt\n    /* Move modifier properties */\n    final float duration = 3;\n    final float fromX = initialPosition;\n    final float toX = WIDTH - initialPosition;\n    final float fromY = initialPosition;\n    final float toY = HEIGHT - initialPosition;\n\n    /* Create a move modifier with an ease function */\n    MoveModifier moveModifier = new MoveModifier(duration, fromX, fromY, toX, toY, org.andengine.util.modifier.ease.EaseElasticIn.getInstance());\n\n    rectangle.registerEntityModifier(moveModifier);\n```", "```kt\n        /* Define the center point of the particle system spawn location */\n        final int particleSpawnCenterX = (int) (WIDTH * 0.5f);\n        final int particleSpawnCenterY = (int) (HEIGHT * 0.5f);\n\n        /* Create the particle emitter */\n        PointParticleEmitter particleEmitter = new PointParticleEmitter(particleSpawnCenterX, particleSpawnCenterY);\n    ```", "```kt\n        /* Define the particle system properties */\n        final float minSpawnRate = 25;\n        final float maxSpawnRate = 50;\n        final int maxParticleCount = 150;\n\n        /* Create the particle system */\n        BatchedSpriteParticleSystem particleSystem = new BatchedSpriteParticleSystem(\n            particleEmitter, minSpawnRate, maxSpawnRate, maxParticleCount,\n            mTextureRegion,\n            mEngine.getVertexBufferObjectManager());\n    ```", "```kt\n        /* Add an acceleration initializer to the particle system */\n        particleSystem.addParticleInitializer(new AccelerationParticleInitializer<UncoloredSprite>(25f, -25f, 50f, 100f));\n\n        /* Add an expire initializer to the particle system */\n        particleSystem.addParticleInitializer(new ExpireParticleInitializer<UncoloredSprite>(4));\n\n        /* Add a particle modifier to the particle system */\n        particleSystem.addParticleModifier(new ScaleParticleModifier<UncoloredSprite>(0f, 3f, 0.2f, 1f));\n\n        /* Attach the particle system to the Scene */\n        mScene.attachChild(particleSystem);\n    ```", "```kt\n        /* Define the center point of the particle system spawn location */\n        final int particleSpawnCenterX = (int) (WIDTH * 0.5f);\n        final int particleSpawnCenterY = (int) (HEIGHT * 0.5f);\n\n        /* Define the radius of the circle for the particle emitter */\n        final float particleEmitterRadius = 50;\n\n        /* Create the particle emitter */\n        CircleOutlineParticleEmitter particleEmitter = new CircleOutlineParticleEmitter(particleSpawnCenterX, particleSpawnCenterY, particleEmitterRadius);\n    ```", "```kt\n        /* Define the center point of the particle system spawn location */\n        final int particleSpawnCenterX = (int) (WIDTH * 0.5f);\n        final int particleSpawnCenterY = (int) (HEIGHT * 0.5f);\n\n        /* Define the width and height of the rectangle particle emitter */\n        final float particleEmitterWidth = 50;\n        final float particleEmitterHeight = 100;\n\n        /* Create the particle emitter */\n        RectangleOutlineParticleEmitter particleEmitter = new RectangleOutlineParticleEmitter(particleSpawnCenterX, particleSpawnCenterY, particleEmitterWidth, particleEmitterHeight);\n    ```", "```kt\n        /* Define min/max particle expiration time */\n        final float minExpireTime = 2;\n        final float maxExpireTime = 4;\n        ExpireParticleInitializer<UncoloredSprite> expireParticleInitializer = new ExpireParticleInitializer<UncoloredSprite>(minExpireTime, maxExpireTime);\n    ```", "```kt\n        /* Define the acceleration values */\n        final float minAccelerationX = -25;\n        final float maxAccelerationX = 25;\n        final float minAccelerationY = 25;\n        final float maxAccelerationY = 50;\n\n        AccelerationParticleInitializer<UncoloredSprite> accelerationParticleInitializer = new AccelerationParticleInitializer<UncoloredSprite>(minAccelerationX, maxAccelerationX, minAccelerationY, maxAccelerationY);\n    ```", "```kt\n        /* Define the alpha values */\n        final float minAlpha = 0.5f;\n        final float maxAlpha = 1;\n\n        AlphaParticleInitializer<UncoloredSprite> alphaParticleInitializer = new AlphaParticleInitializer<UncoloredSprite>(minAlpha, maxAlpha);\n    ```", "```kt\n        BlendFunctionParticleInitializer<UncoloredSprite> blendFunctionParticleInitializer = new BlendFunctionParticleInitializer<UncoloredSprite>(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);\n    ```", "```kt\n        /* Define min/max values for particle colors */\n        final float minRed = 0f;\n        final float maxRed = 1f;\n        final float minGreen = 0f;\n        final float maxGreen = 1f;\n        final float minBlue = 0f;\n        final float maxBlue = 1f;\n\n        ColorParticleInitializer<UncoloredSprite> colorParticleInitializer = new ColorParticleInitializer<UncoloredSprite>(minRed, maxRed, minGreen, maxGreen, minBlue, maxBlue);\n    ```", "```kt\n        GravityParticleInitializer<UncoloredSprite> gravityParticleInitializer = new GravityParticleInitializer<UncoloredSprite>();\n    ```", "```kt\n        /* Define min/max values for the particle's rotation */\n        final float minRotation = 0;\n        final float maxRotation = 359;\n\n        RotationParticleInitializer<UncoloredSprite> rotationParticleInitializer = new RotationParticleInitializer<UncoloredSprite>(minRotation, maxRotation);\n    ```", "```kt\n        /* Define min/max values for the particle's scale */\n        final float minScale = 0.5f;\n        final float maxScale = 1.5f;\n        ScaleParticleInitializer<UncoloredSprite> scaleParticleInitializer = new ScaleParticleInitializer<UncoloredSprite>(minScale, maxScale);\n    ```", "```kt\n        /* Define min/max velocity values of the particles */\n        final float minVelocityX = -25;\n        final float maxVelocityX = 25;\n        final float minVelocityY = 25;\n        final float maxVelocityY = 50;\n\n        VelocityParticleInitializer<UncoloredSprite> velocityParticleInitializer = new VelocityParticleInitializer<UncoloredSprite>(minVelocityX, maxVelocityX, minVelocityY, maxVelocityY);\n    ```", "```kt\n        /* Define the alpha modifier's properties */\n        final float fromTime = 1;\n        final float toTime = 2;\n        final float fromAlpha = 1;\n        final float toAlpha = 0;\n        AlphaParticleModifier<UncoloredSprite> alphaParticleModifier = new AlphaParticleModifier<UncoloredSprite>(fromTime, toTime, fromAlpha, toAlpha);\n    ```", "```kt\n        /* Define the color modifier's properties */\n        final float fromTime = 0;\n        final float toTime = 2;\n        final float fromRed = 0;\n        final float toRed = 1;\n        final float fromGreen = 1;\n        final float toGreen = 0;\n        final float fromBlue 0;\n        final float toBlue = 0;\n\n        ColorParticleModifier<UncoloredSprite> colorParticleModifier = new ColorParticleModifier<UncoloredSprite>(fromTime, toTime, fromRed, toRed, fromGreen, toGreen, fromBlue, toBlue);\n    ```", "```kt\n        OffCameraExpireParticleModifier<UncoloredSprite> offCameraExpireParticleModifier = new OffCameraExpireParticleModifier<UncoloredSprite>(mCamera);\n    ```", "```kt\n        /* Define the rotation modifier's properties */\n        final float fromTime = 1;\n        final float toTime = 4;\n        final float fromRotation = 0;\n        final float toRotation = 180;\n\n        RotationParticleModifier<UncoloredSprite> rotationParticleModifier = new RotationParticleModifier<UncoloredSprite>(fromTime, toTime, fromRotation, toRotation);\n    ```", "```kt\n        /* Define the scale modifier's properties */\n        final float fromTime = 1;\n        final float toTime = 3;\n        final float fromScale = 0.5f;\n        final float toScale = 1.5f;\n\n        ScaleParticleModifier<UncoloredSprite> scaleParticleModifier = new ScaleParticleModifier<UncoloredSprite>(fromTime, toTime, fromScale, toScale);\n    ```", "```kt\n        IParticleModifier<UncoloredSprite> customParticleModifier = new IParticleModifier<UncoloredSprite>(){\n\n          /* Fired only once when a particle is first spawned */\n          @Override\n          public void onInitializeParticle(Particle<UncoloredSprite> pParticle) {\n              * Make customized modifications to a particle on initialization */\n          }\n\n          /* Fired on every update to a particle in the particle system */\n          @Override\n          public void onUpdateParticle(Particle<UncoloredSprite> pParticle) {\n              * Make customized modifications to a particle on every update to the particle */\n                    Entity entity = pParticle.getEntity();\n              * Obtain the particle's position and movement properties */\n            final float currentY = entity.getY();\n            final float currentVelocityY = pParticle.getPhysicsHandler().getVelocityY();\n            final float currentAccelerationY = pParticle.getPhysicsHandler().getAccelerationY();\n\n            /* If the particle is close to the bottom of the Scene and is moving... */\n            if(entity.getY() < 20 && currentVelocityY != 0 || currentAccelerationY != 0){\n\n              /* Restrict movement on the Y axis. Simulates landing on the ground */\n              pParticle.getPhysicsHandler().setVelocityY(0);\n              pParticle.getPhysicsHandler().setAccelerationY(0);\n            }\n            }\n\n        };\n    ```"]