- en: Chapter 6. Android NDK Multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and terminating native threads at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing native threads with mutex at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing native threads with conditional variables at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing native threads with reader/writer locks at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing native threads with semaphore at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling native threads at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data for native threads at Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most non-trivial Android apps use more than one thread, therefore multithreaded
    programming is essential to Android development. At Android NDK, **POSIX Threads**
    (**pthreads**) is bundled in Android's Bionic C library to support multithreading.
    This chapter mainly discusses the API functions defined in the `pthread.h` and
    `semaphore.h` header files, which can be found under the `platforms/android-<API
    level>/arch-arm/usr/include/` folder of Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: We will first introduce thread creation and termination. Synchronization is
    important in all multithreaded applications, therefore we discuss four commonly
    used synchronization techniques at Android NDK with four recipes, including mutex,
    conditional variables, reader/writer locks, and semaphore. We then illustrate
    thread scheduling and finally describe how to manage data for threads.
  prefs: []
  type: TYPE_NORMAL
- en: Being a practical book, we will not cover the theories behind multithreaded
    programming. Readers are expected to understand the basics of multithreading,
    including concurrency, mutual exclusion, deadlock, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, pthreads programming is a complicated topic and there are books
    written solely for pthreads programming. This chapter will only focus on the essentials
    at the context of Android NDK programming. Interested readers can refer to the
    book *Pthreads Programming: A POSIX Standard for Better Multiprocessing*, by *Bradford
    Nicols*, *Dick Buttlar*, and *Jacqueline Proulx Farrell* for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and terminating native threads at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe discusses how to create and terminate native threads at Android
    NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are expected to know how to create an Android NDK project. We can refer
    to the *Writing a Hello NDK program* recipe in [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK*, for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to create a simple Android application with
    multiple native threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsCreation`. Set the package
    name as `cookbook.chapter6.nativethreadscreation`. Refer to the *Loading native
    libraries and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsCreation**, select **Android Tools**
    | **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under package `cookbook.chapter6.nativethreadscreation`.
    This Java file simply loads the native library `NativeThreadsCreation` and calls
    the native `jni_start_threads` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `mylog.h` and `NativeThreadsCreation.cpp` files under the `jni` folder.
    The `mylog.h` file contains the Android native `logcat` utility functions, while
    the `NativeThreadsCreation.cpp` file contains the native code to start multiple
    threads. A part of the code is shown next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `jni_start_threads` function starts two threads and waits for the two threads
    to terminate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread` function is executed to the native threads:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file in the `jni` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of the `logcat` output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows how to create and terminate threads at Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Build with pthreads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, pthread is implemented as an external library and must be linked
    by providing a linker flag `-lpthread`. Android's Bionic C library has its own
    pthread implementation bundled in. Therefore, we do not use `-lpthread` in the
    `Android.mk` file in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Thread creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As demonstrated in our code, a thread can be created with the `pthread_create`
    function, which has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function creates and starts a new thread with attributes specified by the
    `attr` input argument. If `attr` is set to `NULL`, default attributes are used.
    The `start_routine` argument points to the function to be executed by the newly
    created thread with `arg` as the input argument to the function. When the function
    returns, the `thread` input argument will point to a location where the thread
    ID is stored and the return value will be zero to indicate success, or other values
    to indicate error.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample code, we created two threads to execute the `run_by_thread` function.
    We pass a pointer to an integer as input argument to the `run_by_thread` function.
  prefs: []
  type: TYPE_NORMAL
- en: Thread termination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The thread is terminated after it returns from the `start_routine` function
    or we explicitly call `pthread_exit`. The `pthread_exit` function has the following
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This function terminates the calling thread and returns the value pointed by
    `value_ptr` to any successful `join` with the calling thread. This is also demonstrated
    in our sample code. We called `pthread_join` on both threads we created. The `pthread_join`
    function has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function suspends the execution of the calling thread until the thread specified
    by the first input argument terminates. When the function returns successfully,
    the second argument can be used to retrieve the exit status of the terminated
    thread as demonstrated in our sample code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `logcat` screenshot that we have seen previously shows that
    calling return from a thread is equivalent to calling `pthread_exit`. Therefore,
    we can get the exit status when either method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pthread_cancel` is not supported by Android Bionic C library pthread. Therefore,
    if we are porting code which uses `pthread_cancel`, we will need to refactor the
    code to get rid of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing native threads with mutex at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe discusses how to use pthread mutex at Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps help to create an Android project that demonstrates the
    usage of pthread mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsMutex`. Set the package name
    as `cookbook.chapter6.nativethreadsmutex`. Refer to the *Loading native libraries
    and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsMutex**, select **Android Tools**
    | **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under the `cookbook.chapter6.nativethreadsmutex`
    package. This Java file simply loads the native `NativeThreadsMutex` library and
    calls the native `jni_start_threads` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two files named `mylog.h` and `NativeThreadsMutex.cpp` in the `jni` folder.
    `NativeThreadsMutex.cpp` contains the code to start two threads. The two threads
    will update a shared counter. A part of the code is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `run_by_thread1` function is executed by the first native thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread2` function is executed by the second native thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the Android project, and use the following command to monitor
    the `logcat` output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `logcat` output is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We also implemented a native method `jni_start_threads_dead` in `NativeThreadsMutex.cpp`,
    which can probably cause a deadlock (we may need to run the code a few times to
    produce the deadlock situation). If we call `jni_start_threads_dead` in `MainActivity.java`,
    the two threads will start and then block as shown in the following `logcat` output:![How
    to do it...](img/1505_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As indicated in this screenshot, the two threads cannot proceed after **started**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample project demonstrates how to use mutex to synchronize native threads.
    We describe the details as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize and destroy mutex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A mutex can be initialized with the `pthread_mutex_init` function, which has
    the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The input argument mutex is a pointer to the mutex to be initialized and `attr`
    indicates the attributes of mutex. If `attr` is set to `NULL`, the default attributes
    will be used. The function will return a zero if the mutex is initialized successfully
    and a non-zero value otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A macro `PTHREAD_MUTEX_INITIALIZER` is also defined in `pthread.h` to initialize
    a mutex with default attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are done with the mutex, we can destroy it with the `pthread_mutex_destroy`
    function, which has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The input argument is a pointer pointing to the mutex to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample project, we created two mutexes `mux1` and `mux2` to synchronize
    the access of a shared counter `cnt` by the two threads. After the two threads
    exit, we destroyed the mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mutex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following four functions are available to lock and unlock a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In all the four functions, the input argument refers to the `mutex` object in
    use. A zero return value indicates the mutex is locked or unlocked successfully.
    The last function allows us to specify a wait timeout in milliseconds. If it cannot
    acquire the mutex after the timeout, it will return `EBUSY` to indicate failure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pthread_mutex_timedlock` function is defined in some pthread implementations
    to allow us to specify a timeout value. However, this function is not available
    in the Android Bionic C library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We demonstrated the usage of the functions previously in our example. In function
    `run_by_thread1`, we first lock `mux1` by `pthread_mutex_lock`, and then `mux2`
    by `pthread_mutex_trylock`. If `mux2` cannot be locked, we unlock `mux1`, sleep
    for 50 milliseconds, and try again. If `mux2` can be locked, we update the shared
    counter `cnt`, log its current value, and then release the two mutexes. Another
    function `run_by_thread2` is similar to `run_by_thread1`, except that it locks
    `mux2` first, and then `mux1`. The two functions are executed by two threads.
    This can be illustrated by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the mutex](img/1505_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, thread 1 needs to obtain `mux1`, then `mux2`
    in order to update `cnt`, while thread 2 needs to acquire `mux2`, then `mux1`
    to update `cnt`. In case thread 1 locked `mux1` and thread 2 locked `mux2`, neither
    threads can proceed. This corresponds to the situation where `pthread_mutex_trylock`
    returns a nonzero value. If this happens, one thread will give up its mutex so
    the other thread can proceed to update the shared counter `cnt` and release the
    two mutexes. Note that we can replace the `pthread_mutex_trylock` with `pthread_mutex_lock_timeout_np`
    in our code. Readers are encouraged to try it out themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also implemented a native method `jni_start_threads_dead` which will probably
    cause a deadlock. The thread setup is similar to the previous case, but we use
    `pthread_mutex_lock` instead of `pthread_mutex_trylock`, and the threads do not
    give up the mutexes they have already locked. This can be illustrated as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the mutex](img/1505_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thread 1 tries to lock `mux1` and then `mux2`, while thread 2 tries to lock
    `mux2` and then `mux1`. In case where thread 1 has locked `mux1` and thread 2
    has locked `mux2`, none of the threads can proceed. Because they won't give up
    the mutexes they've obtained, the two threads will be blocked forever. This is
    referred to as a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that second input argument for function `pthread_mutex_init` is a pointer
    to `pthread_mutexattr_t`. A few functions are defined in `pthread.h` to initialize,
    manipulate, and destroy mutex attributes, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pthread_mutexattr_init`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_mutexattr_destroy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_mutexattr_gettype`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_mutexattr_settype`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_mutexattr_setpshared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_mutexattr_getpshared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interested readers can look into the `pthread.h` header file for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing native threads with conditional variables at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe discusses how to synchronize threads with mutex. This recipe
    describes how to use conditional variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help us create an Android project that demonstrates
    the usage of pthread conditional variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsCondVar`. Set the package
    name as `cookbook.chapter6.nativethreadscondvar`. Refer to the *Loading native
    libraries and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsCondVar**, select **Android Tools**
    | **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under the package `cookbook.chapter6.nativethreadscondvar`.
    This Java file simply loads the native library `NativeThreadsCondVar` and calls
    the native `jni_start_threads` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two files named `mylog.h` and `NativeThreadsCondVar.cpp` under the `jni`
    folder. `NativeThreadsCondVar.cpp` contains the code to start two threads. The
    two threads will update a shared counter. A part of the code is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `jni_start_threads` function initializes the mutex, conditional variable
    and creates two threads:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread1` function is executed by the first native thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread2` function is executed by the second native thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `logcat` output is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While mutexes control access of shared data among threads, conditional variables
    allow threads to synchronize based on the actual value of data. The typical use
    case is one thread waits for a condition to be satisfied. Without a conditional
    variable, the thread needs to check for the condition continuously (often known
    as polling). Conditional variables allow us to handle the situation without the
    resource consuming polling.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize and destroy conditional variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pthread_cond_init` function is used to initialize a conditional variable.
    It has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function initializes the conditional variable pointed by the `cond` input
    argument with attributes referred by `attr` argument. If `attr` is set to `NULL`,
    the default attributes are used.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to mutex, a macro `PTHREAD_COND_INITIALIZER` is defined in `pthread.h`
    to initialize a conditional variable with default attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we are done with the conditional variable, we can destroy it by calling
    `pthread_cond_destroy`, which has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In our sample code, we called these two functions to initialize and destroy
    a conditional variable named `cond`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the conditional variable:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following three functions are commonly used to manipulate a conditional
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All the three functions accept a pointer to the conditional variable in use.
    The first function also takes a pointer to the associated mutex as the second
    argument. Note that a conditional variable must be used with an associated mutex.
  prefs: []
  type: TYPE_NORMAL
- en: The first function should be called after the associated mutex is locked; otherwise
    the function behavior is undefined. It causes the calling thread to block on the
    conditional variable. In addition, the associated mutex is unlocked automatically
    and atomically so that another thread can use it.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third functions are used to unblock the threads that were previously
    blocked on a conditional variable. `pthread_cond_broadcast` will unblock all threads
    that are blocked on the conditional variable pointed by `cond`, while `pthread_cond_signal`
    will unblock at least one of the threads blocked on `cond`. The two functions
    have no effect if no threads are blocked on the conditional variable specified
    by `cond`. In case there are multiple threads to unblock, the order is dependent
    on the scheduling policy, which we will discuss in the *Scheduling native threads
    at Android NDK* recipe later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of these functions is demonstrated in our sample code. In the `run_by_thread1`
    function, thread one will lock the associated mutex, and then wait on the conditional
    variable `cond`. This will cause thread one to release the mutex `mux`. In function
    `run_by_thread2`, thread two will obtain `mux` and increase the shared counter
    `cnt`.
  prefs: []
  type: TYPE_NORMAL
- en: When `cnt` is increased to five, thread two calls `pthread_cond_signal` to unblock
    thread one and release `mux`. Thread one will lock `mux` automatically and atomically
    (note that no `pthread_mutex_lock` call is needed upon wake up), and then increase
    `cnt` from five to six, and finally exit. Thread two will continue to increase
    the `cnt` value to 10 and exit. This explains the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We put the `pthread_cond_wait(&cond, &mux)` function inside a while loop to
    handle spurious wakeup. Spurious wakeup refers to the case where a thread is woken
    up even though no thread signaled the condition. It is recommended that we always
    check the condition when `pthread_cond_wait` is returned. You can refer to [http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_cond_wait.html](http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_cond_wait.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample project demonstrates how conditional variables are used for native
    threads synchronization. We will go through the details in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional variable attributes functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our sample code, we created the conditional variable with default attributes
    by specifying the second argument to `pthread_cond_init` as `NULL`. `pthread.h`
    defines a few functions to initialize and manipulate conditional variable attributes.
    These functions include `pthread_condattr_init`, `pthread_condattr_getpshared`,
    `pthread_condattr_setpshared`, and `pthread_condattr_destroy`. We will not discuss
    these functions because they are not used often. Interested readers can refer
    to the `pthread.h` header file available at `platforms/android-<API level>/arch-arm/usr/include/`
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Timed conditional variable functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pthread.h` also defines a few functions that allow us to specify a timeout
    value for waiting on a conditional variable. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first two functions `pthread_cond_timedwait` and `pthread_cond_timedwait_monotonic_np`
    allow us to specify an absolute time value. When the system time equals or exceeds
    the specified time, a timeout error is returned. The difference between the two
    functions is that the first function uses the wall clock while the second function
    uses the `CLOCK_MONOTONIC` clock. The system wall clock can jump forwards or backwards
    (for example, the wall clock of a machine configured to use Network Time Protocol
    may change upon clock synchronization), while the `CLOCK_MONOTONIC` clock is the
    absolute time elapsed since some fixed point in the past and it cannot be changed
    abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android `pthread.h` also defines a function `pthread_cond_timedwait_monotonic`,
    which is deprecated. It is functionally equivalent to `pthread_cond_timedwait_monotonic_np`.
    We should always use `pthread_cond_timedwait_monotonic_np` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The last two functions `pthread_cond_timedwait_relative_np` and `pthread_cond_timeout_np`
    allow us to specify a relative timeout value with respect to the current time.
    The difference is that the timeout value is specified as `timespec` structure
    in one function and as number of milliseconds in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several methods covered in this recipe end with `np`, which stands for "nonportable".
    This means these functions may not be implemented in other pthread libraries.
    If we are designing our program to also work on platforms other than Android,
    we should avoid using these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing native threads with reader/writer locks at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous two recipes cover thread synchronization with mutex and conditional
    variables. This recipe discusses reader/writer locks in Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the previous two recipes, *Synchronizing native
    threads with mutex at Android NDK* and *Synchronizing native threads with conditional
    variables at Android NDK*, before going through this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help you create an Android project that demonstrates
    the usage of the pthread reader/writer lock:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsRWLock`. Set the package name
    as `cookbook.chapter6.nativethreadsrwlock`. Refer to the *Loading native libraries
    and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsRWLock**, select **Android Tools**
    | **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under package `cookbook.chapter6.nativethreadsrwlock`.
    This Java file simply loads the native library `NativeThreadsRWLock` and calls
    the native method `jni_start_threads`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two files named `mylog.h` and `NativeThreadsRWLock.cpp` under the `jni`
    folder. A part of the code in `NativeThreadsRWLock.cpp` is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jni_start_threads` starts `pNumOfReader` reader threads and `pNumOfWriter`
    writer threads:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_read_thread` function is executed by the reader threads:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_write_thread` function is executed by the writer threads:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `logcat` output is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reader/writer lock is internally implemented with a mutex and a conditional
    variable. It has the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a thread tries to acquire a read lock for a resource, it can succeed as long
    as no other threads hold a write lock for the resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a thread tries to acquire a write lock for a resource, it can succeed only
    when no other threads hold a write or read lock for the resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reader/writer lock guarantees only one thread can modify (need to get the
    write lock) the resource, while permitting multiple threads to read the resource
    (need to get the read lock). It also makes sure no reads happen when the resource
    is being changed. In the following sections we describe the reader/writer lock
    functions provided by Android `pthread.h`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize and destroy a reader/writer lock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two functions are defined to initialize and destroy a reader/writer
    lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`pthread_rwlock_init` initializes a reader/writer lock pointed by the `rwlock`
    argument with the attributes referred by argument `attr`. If `attr` is set to
    `NULL`, the default attributes are used. `pthread_rwlock_destroy` accepts a pointer
    to a reader/writer lock and destroys it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a macro `PTHREAD_RWLOCK_INITIALIZER` defined to initialize a reader/writer
    lock. The default attributes are used in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Using a reader/writer lock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two functions are defined to acquire a read and a write lock
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Both functions accept a pointer to the reader/writer lock and return a zero
    to indicate success. If the lock cannot be acquired, the calling thread will be
    blocked until the block is available or till an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function is defined to unlock either read lock or write lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In our sample code, we demonstrated the usage of these functions. In `run_by_read_thread`
    function, the read threads need to acquire the read lock in order to access the
    value of the shared resource `sharedCnt`. In the `run_by_write_thread` function,
    the write threads need to acquire the write lock before updating the shared resource
    `sharedCnt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we remove the code which locks and unlocks the read and write lock, build
    the application, and rerun it, the output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a reader/writer lock](img/1505_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the output, the shared resource `sharedCnt` is updated to a value
    less than the final value when reader/writer lock is enabled. The reason is illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a reader/writer lock](img/1505_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, two writers get the same value (N) of the shared counter, and
    both update the value from N to N+1\. When they write the value back to the shared
    counter, the shared counter is updated from N to N+1 although it is updated twice
    by two writers. This illustrates why we need write lock. Also note at reader threads,
    two reads of the `sharedCnt` (one before processing and one after processing)
    give us two different values because the writers have updated the value. This
    may not be desirable sometimes and that is why a read lock is necessary at times.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few more read/write lock functions defined in `pthread.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Timed read/write lock and trylock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android `pthread.h` defines the following two functions to allow the calling
    thread to specify a timeout value when trying to acquire the read or write lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the following two functions are available for the calling thread
    to acquire read or write lock without blocking itself. If the lock is not available,
    the functions will return a nonzero value instead of blocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Reader/writer lock attribute functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android `pthread.h` defines a set of functions to initialize and manipulate
    a reader/writer lock attribute, which can be passed to `pthread_rwlock_init` as
    the second argument. These functions include `pthread_rwlockattr_init`, `pthread_rwlockattr_destroy`,
    `pthread_rwlockattr_setpshared`, and `pthread_rwlockattr_getpshared`. They are
    not used often in Android NDK development and therefore not discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing native threads with semaphore at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered mutex, conditional variables, and reader/writer lock in the
    previous three recipes. This is the last recipe on threads synchronization at
    Android NDK, and we will discuss semaphores.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are expected to read through the previous three recipes, *Synchronizing
    native threads with mutex at Android NDK*, *Synchronizing native threads with
    conditional variables at Android NDK*, and *Synchronizing native threads with
    reader/writer locks at Android NDK*, before this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help you create an Android project that demonstrates
    the usage of pthread reader/writer lock:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsSemaphore`. Set the package
    name as `cookbook.chapter6.nativethreadssemaphore`. Refer to the *Loading native
    libraries and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsSemaphore**, select **Android Tools**
    | **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under package `cookbook.chapter6.nativethreadssemaphore`.
    This Java file simply loads the native library `NativeThreadsSemaphore` and calls
    the native `jni_start_threads` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two files named `mylog.h` and `NativeThreadsSemaphore.cpp` under the `jni`
    folder. A part of the code in `NativeThreadsSemaphore.cpp` is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jni_start_threads` creates `pNumOfConsumer` number of consumer threads, `pNumOfProducer`
    number of producer threads, and `numOfSlots` number of slots:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`run_by_consumer_thread` is the function executed by the consumer thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`run_by_producer_thread` is the function executed by producer thread:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `logcat` output is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Semaphores are essentially integer counters. Two primary operations are supported
    by a semaphore:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wait**: It attempts to decrement the semaphore value. If wait is called on
    a semaphore of value zero, the calling thread is blocked until `post` is called
    somewhere else to increment semaphore value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post**: It attempts to increment the semaphore value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The semaphore related functions are defined in `semaphore.h` rather than `pthread.h`.
    Next, we describe a few key functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interprocess mutex, conditional variable, and semaphore are not supported on
    Android. Android uses `Intent`, `Binder`, and so on for interprocess communication
    and synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize and destroy a semaphore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following three functions are defined to initialize or destroy a semaphore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first two functions are used to initialize a semaphore. They both initialize
    the semaphore pointed by the input argument `sem` with the value indicated by
    the argument `value`. The first function also accepts an argument `pshared`, which
    should be set to zero for thread synchronization. If it is set to nonzero, the
    semaphore can be shared between processes, which is not supported on Android and
    therefore not discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Using a semaphore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following functions are defined to use a semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first two functions are used to wait on a semaphore. If the semaphore value
    is not zero, then the value is decreased by one. If the value is zero, the first
    function will return a nonzero value to indicate failure, while the second function
    will block the calling thread. The third function is used to increase the semaphore
    value by one, and the last function is used to query the value of the semaphore.
    Note that the value is returned through the second input argument rather than
    the return value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android `semaphore.h` also defines a function named `sem_timedwait` to allow
    us to specify a timeout value while waiting on a semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample project, we used two semaphores `emptySem` and `fullSem`, and
    a mutex `mux`. The app will create a few producer threads and consumer threads.
    The `emptySem` semaphore is used to indicate the number of slots available to
    store the items produced by the producer thread, while `fullSem` refers to the
    number of items for the consumer thread to consume. The mutex `mux` is used to
    ensure no two threads can access the shared counter `numOfItems` at one time.
  prefs: []
  type: TYPE_NORMAL
- en: The producer thread will need to wait on the `emptySem` semaphore. When it is
    unblocked, the producer has obtained an empty slot. It will lock `mux` and then
    update the shared count `numOfItems`, which means a new item has been produced.
    Therefore, it will call the `post` function on `fullSem` to increment its value.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the consumer thread will wait on `fullSem`. When it is unblocked,
    the consumer has consumed an item. It will lock `mux` and then update the shared
    count `numOfItems`. A new empty slot is available because of the item consumed,
    so the consumer thread will call post on `emptySem` to increment its value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mutex `mux` can also be replaced by a binary semaphore. The possible values
    of a binary semaphore are restricted to zero and one.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling native threads at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe discusses how to schedule native threads at Android NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are suggested to read the *Manipulating classes in JNI* and *Calling
    static and instance methods from native code* recipes in [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, and *Creating and
    terminating native threads at Android NDK* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help us create an Android project that demonstrates
    threads scheduling at Android NDK:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsSchedule`. Set the package
    name as `cookbook.chapter6.nativethreadsschedule`. Refer to the *Loading native
    libraries and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* for more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsSchedule**, select **Android Tools**
    | **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under package `cookbook.chapter6.nativethreadsschedule`.
    This Java file simply loads the native library `NativeThreadsSchedule` and calls
    the native methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add five files named `mylog.h`, `NativeThreadsSchedule.h`, `NativeThreadsSchedule.cpp`,
    `SetPriority.cpp`, and `JNIProcessSetThreadPriority.cpp` under the `jni` folder.
    A part of the code in the last three files is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `NativeThreadsSchedule.cpp` file contains the source code to demonstrate
    the threads scheduling functions defined in `pthread.h`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jni_thread_scope` demonstrates how to set the native thread contention scope:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`jni_thread_fifo` demonstrates how to set the native thread scheduling policy
    and priority:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`run_by_thread` is the actual function to be executed by each native thread:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `SetPriority.cpp` file contains the source code to configure thread nice
    value through `setpriority`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `jni_thread_set_priority` method creates and joins five native methods:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread2` function is executed by each native thread:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `JNIProcessSetThreadPriority.cpp` file contains the source code to configure
    thread nice value through the `android.os.P``rocess.setThreadPriority` Java method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `jni_process_setThreadPriority` method creates and joins five native threads:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread3` function is executed by each native thread. The thread
    nice value is set here:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `MainActivity.java`, disable all native methods except `jni_thread_scope`.
    Build the project and run it. Start a terminal and enter the following command
    to monitor the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In `MainActivity.java`, disable all native methods except `jni_thread_fifo`.
    Build the project and run it. The `logcat` output is shown in the following screenshot:![How
    to do it...](img/1505_06_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity.java`, disable all native methods except `jni_thread_set_priority`.
    Build the project and run it. The `logcat` output is shown in the following screenshot:![How
    to do it...](img/1505_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity.java`, disable all native methods except `jni_process_setThreadPriority`.
    Build the project and run it. The `logcat` output is shown in the following screenshot:![How
    to do it...](img/1505_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can schedule native threads by setting the scheduling contention scope,
    thread priority, and scheduling policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheduling contention scope**: It determines the threads that a thread must
    compete against when the scheduler schedules threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread priority**: It determines which thread is more likely to be selected
    by the scheduler when a CPU is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling policy**: It determines how the scheduler schedules threads with
    the same priority'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way to adjust these settings is through the thread attribute. The following
    functions are defined in `pthread.h` to initialize and destroy an instance of
    `pthread_attr_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In these two functions, the input argument is a pointer to a `pthread_attr_t`
    object. We will now describe contention scope, thread priority, and scheduling
    policy in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling contention scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two scopes are defined in a typical pthread implementation, namely `PTHREAD_SCOPE_SYSTEM`
    and `PTHREAD_SCOPE_PROCESS`. A system scope thread competes for the CPU with all
    other threads system-wide. On the other hand, a process scope thread is scheduled
    against other threads in the same process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Bionic `pthread.h` defines the following two functions to set and get
    the thread scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The two functions accept a pointer to a pthread attribute object as the input
    argument. The `set` function also includes a second argument to let us pass the
    scope constant. These two functions return a zero to indicate success and a nonzero
    value to signal failure.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out `pthread_attr_setscope` with `PTHREAD_SCOPE_PROCESS` as second
    input argument is not supported by Android. In other words, Android native threads
    always have system scope. As shown in `jni_thread_scope` at `NativeThreadsSchedule.cpp`,
    calling `pthread_attr_setscope` with `PTHREAD_SCOPE_PROCESS` will return a nonzero
    value.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated the usage of the two functions previously in the native method
    `jni_thread_scope`. We created two processes in the method. The child process
    runs five threads, and the parent process only runs a single thread. Because they
    are all system scope threads, the threads are scheduled to get roughly same amount
    of CPU time slices regardless of the process they belong to, and therefore they
    finish at roughly the same time as shown in the first `logcat` screenshot in step
    6 of the *How to do it...* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We called `fork` to create a process in our code. This is for demonstration
    purpose. It is strongly discouraged to create a native process with `fork` on
    Android because the native process won't be managed by the Android framework and
    a misbehaving native process can consume lots of CPU cycles and cause security
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling policy and thread priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each thread has an associated scheduling policy and priority. A thread with
    higher priority is more likely to be selected by the scheduler when a CPU is available.
    In case multiple threads have the same priority, the scheduling policy will determine
    how to schedule them. The policies defined in Android `pthread.h` include `SCHED_OTHER`,
    `SCHED_FIFO`, and `SCHED_RR`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The valid range of priority values is associated with the scheduling policy.
  prefs: []
  type: TYPE_NORMAL
- en: '`SCHED_FIFO` : In the **First In First Out (FIFO)** policy, a thread gets the
    CPU until it exits or blocks. If blocked, it is placed at the end of the queue
    for its priority and the front thread in the queue will be given to the CPU. The
    priority range allowed under this policy is 1 to 99.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCHED_RR`: The **Round Robin (RR)** policy is similar to FIFO except that
    each thread is only allowed to run for a certain amount of time, known as quantum.
    When a thread finishes its quantum, it is interrupted and placed at the end of
    the queue for its priority. The priority range allowed under this policy is also
    1 to 99.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCHED_OTHER`: This is the default scheduling policy. It also allows a thread
    to run only a limited amount of times, but the algorithm can be different and
    more complicated than `SCHED_RR`. All threads under this policy have a priority
    of 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'People who are experienced with pthreads programming may be familiar with the
    pthreads policy and priority functions including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pthread_attr_setschedpolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_attr_getschedpolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_attr_setschedparam`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_attr_getschedparam`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions do not work on Android, as expected, although they are defined
    in the Android `pthread.h` header. Therefore, we will not discuss the details
    here.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample project, we implemented a native method `jni_thread_fifo`, which
    attempts to set the scheduling policy as `SCHED_FIFO` and the thread priority.
    As shown in the second `logcat` screenshot, the threads are not affected by these
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, all Android threads are system scope threads with 0 priority, and
    scheduling policy `SCHED_OTHER`.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling using nice value/level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nice value/level is another factor that can affect the scheduler. It is also
    often referred to as priority, but here we will use nice value to differentiate
    it with the thread priority we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following two approaches to adjust the nice value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling setpriority**: This is demonstrated in `SetPriority.cpp`. We created
    five threads with different nice values, and the third `logcat` screenshot in
    step 8 of the *How to do it* section indicates the thread with lower nice values
    return first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calling android.os.Process.setThreadPriority**: This is illustrated in `JNIProcessSetThreadPriority.cpp`.
    As shown in the fourth `logcat` screenshot at step 9 of the *How to do it* section,
    we got similar result as calling `setpriority`. In fact, `setThreadPriority` calls
    `setpriority` internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data for native threads at Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options when we want to preserve thread-wide data across functions,
    including global variables, argument passing, and thread-specific data key. This
    recipe discusses all the three options with a focus on thread-specific data key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readers are recommended to read the *Creating and terminating native threads
    at Android NDK* recipe and the *Synchronizing native threads with mutex at Android
    NDK* recipe in this chapter before this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help us create an Android project that demonstrates
    data management at Android NDK:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application named `NativeThreadsData`. Set the package name
    as `cookbook.chapter6.nativethreadsdata`. Please refer to the *Loading native
    libraries and registering native methods* recipe in [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface* if you want more detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project **NativeThreadsData**, select **Android Tools** |
    **Add Native Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Java file named `MainActivity.java` under package `cookbook.chapter6.nativethreadsdata`.
    This Java file simply loads the native library `NativeThreadsData` and calls the
    native methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `mylog.h` and `NativeThreadsData.cpp` files under the `jni` folder. The
    `mylog.h` contains the Android native `logcat` utility functions, while the `NativeThreadsData.cpp`
    file contains the native code to start multiple threads. A part of the code is
    shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jni_start_threads` starts *n* number of threads, where *n* is specified by
    the variable `pNumOfThreads`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `thread_step_1` function is executed by threads. It gets the data associated
    with the thread- specific key and uses it to count the number of times the mutex
    is locked:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `thread_step_2` function is executed by threads. It gets the data associated
    with the thread-specific key and prints it out:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_by_thread` function is executed by threads:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `logcat` output is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1505_06_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our sample project, we demonstrated passing data using global variables,
    argument, and thread-specific data key:'
  prefs: []
  type: TYPE_NORMAL
- en: The mutex `mux` is declared as a global variable, and each thread can access
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each thread is assigned a thread number as input argument. In the function `run_by_thread`,
    each thread passes the accepted thread number to another function `thread_step_2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined a thread-specific key `muxCntKey`. Each thread can associate its
    own value with the key. In our code, we used this key to store the number of times
    a thread locks the mutex `mux`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we'll discuss the thread-specific data key in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creation and deletion of thread-specific data key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two functions are defined in `pthread.h` to create and delete
    a thread-specific data key respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`pthread_key_create` accepts a pointer to the `pthread_key_t` structure and
    a function pointer to a destruction function to be associated with each key value.
    The destruction function is optional and can be set to `NULL`. In our example,
    we called `pthread_key_create` to create the key named `muxCntKey`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `pthread_key_create` function returns zero to indicate success and some
    other values for failure. If successful, the first input argument `key` will be
    pointing to the newly created key, and the value `NULL` is associated with the
    new key in all active threads. If a new thread is created after the key creation,
    the value `NULL` is also associated with the key for the new thread.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread exits, the associated value of the key is set to `NULL`, and then
    the destruction function associated with the key is called with the key's previously
    associated value as the sole input argument. In our sample code, we defined a
    destruction function `free_muxCnt` to free the memory of data associated with
    the key `muxCntKey`.
  prefs: []
  type: TYPE_NORMAL
- en: '`pthread_key_delete` is relatively simple. It accepts a key created by `pthread_key_create`
    and deletes it. It returns zero for success and a nonzero value for failure.'
  prefs: []
  type: TYPE_NORMAL
- en: Set and get thread-specific data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android `pthread.h` defines the following two functions for thread-specific
    data management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `pthread_setspecific` function accepts a previously created data key and
    a pointer to data to be associated with the key. It returns a zero to indicate
    success and nonzero otherwise. Different threads can call this function to bind
    different values to the same key.
  prefs: []
  type: TYPE_NORMAL
- en: '`pthread_getspecific` accepts a previously created data and key and returns
    a pointer to the data associated with the key in the calling thread.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `run_by_thread` function of our sample code, we associate an integer
    variable initialized to zero to the `muxCntKey` key. In function `thread_step_1`,
    we get the integer variable associated with the key and use it to count the number
    of times `mux` is locked. In function `thread_step_2`, we again obtain the integer
    variable associated with `muxCntKey` and print its value.
  prefs: []
  type: TYPE_NORMAL
