- en: Chapter 8. Operation Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We''ve taken our game, Egg Drop, and explored ways to create game physics
    to react with collision detection and track other useful data, such as lives and
    a points system. We also worked with customizing physical bodies and created names
    for our display objects that apply to the game score count.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we'll add a menu system that incorporates the introduction to the game,
    apply a pause menu during game play, and save high scores when the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: We're on our way to completing an application that has the necessary elements
    to make it ready for the App Store and Google Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Save and load high scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage scenes with the Composer API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a loading screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a main menu, options menu, and credits screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Continuation of Egg Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finished the main game portion of Egg Drop as the main base of our application.
    Now, it's time for us to include how to pause action midgame and also save high
    scores. We will also add some new scenes that will help us introduce and transition
    to the game in an easy and quick fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Resources` folder of `Chapter 8`, grab all the image and file assets
    inside and copy them to your current `Egg Drop` project folder. You can download
    the project files accompanying this book from the Packt Publishing website. We
    will use these files to add the final touches to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Data saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving file information is used in many aspects of game development. We use
    it to save high scores and game settings, such as sound on/off, locking/unlocking
    levels, and so on. It is not necessary to have these features, but as they are
    good to have, maybe you'd like to include them in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In Corona SDK, applications are sandboxed; this means that your files (application
    images, data, and preferences) are stored in a location that no other application
    can access. Your files will reside in an app-specific directory for documents,
    resources, or temporary files. This restriction is related to the files on your
    device, not when you are coding on your Mac or PC.
  prefs: []
  type: TYPE_NORMAL
- en: BeebeGames class for saving and loading values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the BeebeGames class created by Jonathan Beebe. It provides many
    easy and useful functions to use for games. Some of the notable functions included
    incorporate a simple way of saving and loading data that we'll be able add into
    our game. More documentation on the BeebeGames class can be found in the `Chapter
    8` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also refer to [https://github.com/lewisNotestine/luaCorona/blob/master/justATest/code/beebegames.lua](https://github.com/lewisNotestine/luaCorona/blob/master/justATest/code/beebegames.lua)
    to track updates on the class.
  prefs: []
  type: TYPE_NORMAL
- en: You can take a look at other methods relating to animation, transitions, timers,
    and so on if you would like to use them for future use. For now, we'll focus on
    the methods we can use to easily save and load values for our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of saving and loading values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting paths to files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The paths to these files are unique to your application. To create file paths,
    you can use the `system.pathForFile` function. This function generates an absolute
    path to the icon file for your application, using the application''s resource
    directory as the base directory for `Icon.png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, your files must reside in one of the three possible base directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system.DocumentsDirectory`: This should be used for files that need to persist
    between application sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.TemporaryDirectory`: This is a temporary directory. Files written to
    this directory are not guaranteed to exist in subsequent application sessions.
    They may or may not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.ResourceDirectory`: This is the directory where all application assets
    exist. Note that you should never create, modify, or add files to this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on files can be found at [http://docs.coronalabs.com/api/library/system/index.html](http://docs.coronalabs.com/api/library/system/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read files, the `io` library is used. This library allows you to manage files,
    given an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write files, you follow many of the steps that are the same as for reading
    a file. Instead of using a read method, you write data (strings or numbers) to
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving and loading the high score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the **Game Over** screen displays, we will save and load the values of
    our final score and highest score. For this perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `main.lua` file that we created for Egg Drop. We'll continue using
    the same file and add in more code with the new alterations to the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add in two new variables, `local highScoreText` and `local highScore` where
    all the other initialized variables are located, near the top of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce the `saveValue()` function after the preloaded sound files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the `loadValue()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `callGameOver()` function, create an `if` statement to compare
    `gameScore` and `highScore`. Save the highest score by using the `saveValue()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add in the `highScoreText` display text in the same `callGameOver()`
    function, to show the high score at the end of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `gameStart()` function, have the high score loaded by using
    the `loadValue()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – saving and loading the high score](img/9343OT_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After initializing the `saveValue()` and `loadValue()` functions at the game
    level, we created an `if` statement to compare `gameScore`, which is the current
    score during game play, and `highScore`, which is the highest score accrued so
    far. When the outcome of `gameScore` is higher, then it replaces the `highScore`
    data saved.
  prefs: []
  type: TYPE_NORMAL
- en: In order to save the value, a data file needs to be created. We created a variable
    called `local highScoreFilename = "highscore.data"`. We called the `saveValue()`
    function using `highScoreFilename` as a parameter. The `tostring(highScore)` parameter
    will convert the numeric value of `highScore` to a string.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Game Over** screen is visible, `highScoreText` displays the value
    saved from `highScore` above the `gameScore` that is achieved. Adding a high score
    gives the player an incentive to top the highest score and adds the replay value
    to the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the `gameStart()` function, it's important to have the value of `highScore.data`
    loaded at the start of game play. Using the same data file we created to save
    `highScore`, we can also load the value throughout the game. To load the value,
    `local highScore` calls `loadValue(highScoreFileName)`. This takes the information
    from `highScore.data`. To obtain the value, `tonumber(loadedHighScore)` converts
    it to an integer from a string and can be used to display the value of `highScore`.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever found yourself in the middle of playing a game and all of a sudden
    you have to take a bathroom break or your hand cramps up? Obviously, any of these
    situations require you to deter your attention from your game progress, and you
    need to stop the current action temporarily to attend to those needs. This is
    when a pause button comes in handy so that you can stop the action in that moment
    in time and then continue where you left off when you're ready to play again.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s more than just making a button; it''s also pausing all the action on
    screen, including physics and timers by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add in the `local pauseBtn` and `local pauseBG` variables where all the other
    variables are initialized near the beginning of the code. Preload the `btnSound`
    audio after `gameOverSound` near the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `hud()` function and after the `scoreText` chunk, create another
    function that will run the event for the pause button. Call the `onPauseTouch(event)`
    function. Pause the physics in the game by setting `gameIsActive` to `false` and
    have the pause elements appear on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the game is unpaused, have the physics become active again and remove
    all the pause display objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `pauseBtn` UI button and `pauseBG` display object after the `onPauseTouch()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order for `pauseBtn` to display during game play, make it visible and active
    in the `gameActivate()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the game is over, disable `pauseBtn` in the `callGameOver()` function
    Place the code right after the `physics.pause()` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – pausing the game](img/9343OT_08_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the `onPauseTouch(event)` function to control all the pause events
    that occur within the game play. To pause all the motion in the game, we changed
    the Boolean of `gameIsActive` to `false` and the `physics.pause()` function to
    stop all the eggs that are falling from moving. Next, the timer is paused for
    `startDrop` so that any eggs falling from the sky won't accumulate over time as
    long as the pause function is still active.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly transparent overlay called `shade` is called to appear when the pause
    button is pressed. This will deter the attention from the game scene and allow
    the user to differentiate when the game play is not active.
  prefs: []
  type: TYPE_NORMAL
- en: The **Game Paused** banner also displays on the top of the screen by making
    it visible and active. The `pauseBG` object is pushed ahead of the display hierarchy
    by `pauseBG:toFront()`.
  prefs: []
  type: TYPE_NORMAL
- en: To unpause the game, we reversed the process of how the pause display items
    appeared. When `pauseBtn` is pressed for the second time, `shade` is taken away
    by `display.remove(shade); shade = nil`. The `pauseBG.isVisible` and `pauseBG.isActive`
    properties are both set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we had set `gameIsActive` to `false` earlier Well, it's now time
    to set it back to true. This also means resuming physics with `physics.start()`.
    The timer is resumed by the `resumeGame()` local function and calls `timer.resume(startDrop)`
    within the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `pauseBtn` and `pauseBG` display objects are inserted at the end of the
    `if` statement block. The `pauseBtn` object is then shown as visible and active
    once the game is playable. It is invisible and inactive when the **Game Over**
    screen appears so that there are no other touch events that can interfere when
    the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: The Composer API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Composer API provides an easy solution for developers to control scenes
    with or without transitions. This is a great scene-management library to display
    menu systems and even managing multiple levels in a game. Composer also comes
    with a variety of transition effects. More information can be found on the Corona
    Docs at [http://docs.coronalabs.com/api/library/composer/index.html](http://docs.coronalabs.com/api/library/composer/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Our scene management will look similar to the scene template displayed at [http://docs.coronalabs.com/api/library/composer/index.html#scene-template](http://docs.coronalabs.com/api/library/composer/index.html#scene-template).
  prefs: []
  type: TYPE_NORMAL
- en: Game development with the Composer API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder how we're going to apply Composer with Egg Drop. It's really
    simple. We'll have to alter some lines in our game code to make it compatible
    with Composer and create some new scenes for the menu system that is applied before
    game splay.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – altering the game file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will rename our current `main.lua` file to `maingame.lua` and add some additional
    lines to our game code. Be sure to *change* the file name within your `Egg Drop`
    project folder. To rename the file follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following lines near the top of the code. We''ll hide the status
    bar in another scene that we''ll create later on in this chapter. The `gameGroup`
    display group will be altered to fit within the Composer parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the very top of the code, implement Composer by adding `local composer =
    require( "composer" )` and `local scene = composer.newScene()` so that we can
    call the scene events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After `local loadValue = function( strFilename )`, add in the `create()` event.
    We will also add back in our `gameGroup` display group, but under the scene''s
    view property. Also, add in `composer.removeScene( "loadgame" )`. The `"loadgame"`
    scene will be introduced later on in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `create()` event, create the `show()` event and add it before the
    `gameActivate()` function. The `show()` event will transition all our game play
    functions onscreen. Include `gameGroup` in the scene''s view property as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `gameStart()` function, remove the `return gameGroup` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, close `function scene: show( event )` with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `hide()` and `destroy()` events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create event listeners for all the scene events and add `return scene`
    at the end of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the Composer API will help us transition scenes a lot easier and quicker.
    Every time you want to load a new scene into view, `require("composer")` needs
    to be added. The `local scene = composer.newScene()` statement will allow us to
    call the scene events, `create()`, `show()`, `hide()`, and `destroy()`.
  prefs: []
  type: TYPE_NORMAL
- en: At the very end of the game code, we added event listeners for all the scene
    events and for `return scene`.
  prefs: []
  type: TYPE_NORMAL
- en: The format of how each scene is managed with Composer will look similar to the
    preceding code. Most of the game code will be dispatched when a scene is displayed
    by the `create()` and `show()` events. When you want to clean or unload listeners,
    audio, assets, and so on, the `hide()` and `destroy()` events are used.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been used to having `main.lua` as our main source file to show every detail
    of our game code. It's time to organize it efficiently with the help of the Composer
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the new main.lua file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While using Composer, our `main.lua` file is still vital since it is the first
    thing that Corona SDK looks at to launch an application in the simulator. We''re
    going to add some lines of code that will change scenes for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a brand new file called `main.lua` and let''s add it back in our status
    bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import Composer and load the first scene called `loadmainmenu`. We will create
    this scene in the next couple of sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to incorporate Composer throughout the application, we called the `local
    composer = require ( "composer" )` module. The scene will be changed with `composer.gotoScene(
    "loadmainmenu" )`, which is a loading screen directing the user to the main menu
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: New game transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have introduced the Composer API, we can apply some long-awaited
    transitions that will be helpful for our game. One way to approach this is by
    transitioning out of the game once it is over.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – changing screens after the game is over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have renamed our game file, let''s add in a scene transition so
    that our game is not stuck at the **Game** **Over** screen once game play is over.
    To change the screen, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `maingame.lua` file, add in a new variable called `local menuBtn`, where
    all the other variables are initialized in the beginning of the code. Inside the
    `callGameOver()` function, add the following lines after the `highScoreText` code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – changing screens after the game is over](img/9343OT_08_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to transition out of the game over screen, a menu button was created
    to change scenes. Inside the `onMenuTouch()` function, upon the release of the
    button, we called `composer.gotoScene( "mainmenu", "fade", 500 )`. This will allow
    the application to transition to the main menu in 500 milliseconds using a fade,
    which we will create later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – restarting the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you're well aware of how the Composer API works with changing scenes
    and using UI buttons to transition between them, how about creating a button that
    restarts the game after the game over screen appears? So far, the application
    allows the user to go back to the menu screen once the game has reached an end.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `callGameOver()` function, a new local function needs to be created
    that will run an event using the UI button system to change scenes with Composer.
    Note that you can't call the same scene over if you're currently in it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a loading screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading screens provide feedback that the program is in the process of loading.
    This is helpful by informing the user that the next screen is underway, so that
    they don't assume that the application has crashed, especially if the next screen
    is loading a large amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the loading screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll place loading screens when the application launches and before the game
    level starts. This tells the user that more content or information is on its way.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `loadmainmenu.lua` in your project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import Composer and add in the `composer.newScene()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two local variables called `myTimer` and `loadingImage`. Add in the
    `create()` event and a `sceneGroup` display group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `show()` event and add in a `sceneGroup` display group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce the `loadingImage` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another local function called `goToMenu()` and call `composer.gotoScene(
    "mainmenu", "zoomOutInFadeRotate", 500 )` to change the scene to `"mainmenu"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `timer` function and have it call `goToMenu()`once every 1,000 milliseconds.
    Define it with the `myTimer` timer ID. Close the `show()` event with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `hide()` and `destroy()` events. In the `hide()` event, cancel `myTimer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add event listeners for all the scene events and for `return scene`. Save and
    close the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file called `loadgame.lua` in your project folder. We''ll make
    another loading screen that occurs right before the game scene, `maingame.lua`.
    Use `composer.gotoScene( "maingame", "flipFadeOutIn", 500 )` to transition scenes.
    Save and close your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – adding the loading screen](img/9343OT_08_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `loadmainmenu.lua` file, once `loadingImage` was added to the screen,
    we created the `goToMenu()` function to change scenes to `"mainmenu"` and use
    the `"zoomOutInFadeRotate"` transition that zooms out and rotates the loading
    screen image as it fades to the background. The `myTimer = timer.performWithDelay(
    1000, goToMenu, 1 )` statement performs the function in 1,000 milliseconds (one
    second) and runs it once. This is long enough to view the image and have it fade
    out.
  prefs: []
  type: TYPE_NORMAL
- en: All display objects enter the scene by `function scene:show( event )`. The `loadingImage`
    object is placed in `sceneGroup`. To make sure we have no timers running after
    the scene change, `myTime`r stops running with the use of `timer.cancel(myTimer)`
    under `function scene:hide()`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `loadgame.lua` is similar to `loadmainmenu.lua`. For this file,
    Composer transitions scenes to `maingame.lua`, the game play file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A main menu or title screen is one of the first impressions a player sees before
    playing the game. It usually shows small snippets of images or scenery that correlate
    with the actual game and also displays the title of the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are buttons such as **Start** or **Play** that urge the player to go into
    the game if they choose to and some secondary buttons such as **Options** to view
    settings and other information.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create the frontend of our game by introducing the game title and the
    **Play** and **Options** buttons that will transition throughout different scenes
    in the application with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `mainmenu.lua` and import Composer and the UI modules,
    the `composer.newScene()` function, and the variables for timer and audio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `create()` event. Add in the `composer.removeScene( "maingame" )`
    and `composer.removeScene( "options" )` lines, which will remove the `"maingame"`
    and `"options"` scenes. You can remove `"maingame"` after the player has transitioned
    from the main game screen and is sent to the main menu screen. You can remove
    `"options"` after the player has transitioned from the options screen and is sent
    to the main menu screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `show()` event and the `backgroundImage` display object;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce the `playBtn` display object and create a function called `onPlayTouch(event)`
    that uses `composer.gotoScene()` to change the scene to `"loadgame"`. Use the
    `"fade"` effect to change scenes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transition the `playBtn` display object to y = 260 in 500 milliseconds using
    the `easing.inOutExpo` transition. Have it initialized through `btnAnim`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce the `optBtn` display object and create a function called `onOptionsTouch(event)`.
    Use `composer.gotoScene()` to transition the scene to `"options"` using the `"crossFade"`
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transition the `optBtn` display object to `y = 280` in 500 milliseconds using
    the `easing.inOutExpo` transition. Have it initialized through `btnAnim`. Close
    the `scene:show( event )` function with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `hide()` event and cancel the `btnAnim` transition. Also, create
    the `destroy()` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the event listeners for all the scene events and for `return scene`. Save
    and close your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – adding a main menu](img/9343OT_08_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the main menu screen, we added an image that displayed the game title and
    the **Play** and **Options** buttons. The **Options** button is still not functional
    at this time. The `onPlayTouch()` function transitions the scene to `"loadgame"`.
    This will change scenes to `loadgame.lua`. The **Play** button is placed at `x
    = 240`; `y = 440`, (middle and offscreen). When the scene loads, `playBtn` transitions
    to `y = 260`, so it pops up from the bottom of the screen in 1000 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The **Options** button does a similar thing. The `optBtn` object is placed to
    the right of the stage and pops up at `y = 280` in 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `btnAnim` transition is cancelled by `transition.cancel( btnAnim )` through
    the `scene:hide()` function. It is important to clean timers, transitions, and
    event listeners every time you change scenes so that potential memory leaks do
    not occur while in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an options menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An options menu allows users to change various settings in the game or include
    other information that can't be displayed in the main menu. Games can vary from
    having many options to only having a few. Sometimes, an options menu can be called
    a settings menu, which offers the same type of customization to the player's experience.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding an options menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll add an options menu that can be accessed through the main menu. We''re
    going to add a new UI button called **Credits**, which will direct the user to
    the credits screen once it is pressed. To add an option menu perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `options.lua` and import Composer and the UI modules,
    the `composer.newScene()` function, and the variables for timer and audio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `create()` event. Add in `composer.removeScene( "mainmenu" )`, which
    will remove the `"mainmenu"` scene. This will occur after the player has transitioned
    from the main menu screen and is sent to the options screen. Next, add in `composer.removeScene(
    "creditsScreen" )`. This will remove `"creditsScreen"` after the player has transitioned
    from the credits screen back to the options screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the `show()` event and the `backgroundImage` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a button for the credits screen. Transition the `creditsBtn` display
    object to `y = 260` in 1000 milliseconds using the `easing.inOutExpo` transition.
    Have it initialized through `btnAnim`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the **Close** button that loads the main menu. Close the `scene:show(
    event )` with `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `hide()` event and cancel the `btnAnim` transition. Also, create
    the `destroy()` event. Add the event listeners for all the scene events and the
    `return scene` statement. Save and close your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – adding an options menu](img/9343OT_08_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scene, `creditsBtn` will operate in a manner similar to how our main
    menu was created. The **Credits** button is still not functional at this time.
    In the `onCreditsTouch()` function, the scene is transitioned to `"creditsScreen"`
    and uses `"crossFade"` as the effect. From the off-screen position, `creditsBtn`
    transitions to y=260 in 1,000 milliseconds when the scene is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: A **Close** button is created for this scene so that the user will have a way
    to go back to the previous screen. With the `onCloseTouch()` function, Composer
    changes the scene to `"mainmenu"` upon the release of `closeBtn`. The main menu
    screen will display when you press the close button. The `btnAnim` transition
    is canceled through the `scene:hide()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a credits screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A credits screen usually shows and lists all the people involved in the production
    of the game. It can include other information in the form of thanking certain
    individuals and programs used to create the final project.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a credits screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The credits screen that we''ll create will be based on a touch event that transitions
    to the previous screen from which it was introduced. To add a credits screen,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `creditsScreen.lua` and import Composer, the `composer.newScene()`
    function, and the `backgroundImage` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `create()` event. Add in the `composer.removeScene("options")` line,
    which will remove the `"options"` scene. This will occur after the player has
    transitioned from the options screen and is sent to the credits screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the `show()` event and the `backgroundImage` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a local function called `changeToOptions()` with an event parameter.
    Have the function change the scene with Composer back to the options screen, using
    a touch event on `backgroundImage`. Close the `scene:show(event)` function with
    `end`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `hide()` and `destroy()` events. Add the event listeners for all
    the scene events and the `return scene` statement. Save and close your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – adding a credits screen](img/9343OT_08_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The credits screen works with an event listener. The `changeToOptions(event)`
    function will tell Composer to change the scene to `"options"` using `composer.gotoScene(
    "options", "crossFade", 500 )`. At the end of the function, `backgroundImage`
    will activate the event listener when the screen is touched. The `backgroundImage`
    object is inserted into the `sceneGroup` under the `scene:show( event )` function.
    Egg Drop is now fully operable using Composer. Run the game in the simulator.
    You'll be able to transition to all the scenes that we created in this chapter,
    as well as play the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding more levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that Egg Drop is completed and has a working menu system, challenge yourself
    by creating more levels. Minor alterations will have to be added to add some placement
    for additional levels. Remember to apply Composer when changing scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try creating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Level select screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level number buttons to add additional levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating new levels, refer to the format shown in `maingame.lua`. New levels
    can be altered by changing the interval of how fast the egg falls from the sky,
    or maybe by adding other game assets that fall but have to be dodged in order
    to avoid getting a penalty. There are so many possibilities of adding your own
    spin with this game framework. Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – game transitions and scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What function do you call to change scenes with Composer?
  prefs: []
  type: TYPE_NORMAL
- en: '`composer()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`composer.gotoScene()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`composer(changeScene)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What function converts any argument into a number or nil?
  prefs: []
  type: TYPE_NORMAL
- en: '`tonumber()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tostring()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nil`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. How do you pause a timer?
  prefs: []
  type: TYPE_NORMAL
- en: '`timer.cancel()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`physics.pause()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`timer.pause( timerID )`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. How do you resume a timer?
  prefs: []
  type: TYPE_NORMAL
- en: '`resume()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`timer.resume( timerID )`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`timer.performWithDelay()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We have a game that is complete and can go into the App Store
    or Google Play Store. Of course, we will not use this exact game, but you have
    learned enough to create one. It's a great accomplishment to have completed the
    game framework, especially in the short amount of time it took to create something
    so simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some skills you learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving high scores using saveValue() and loadValue()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to pause physics/timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change scenes with the Composer API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transitions between scenes using loading screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a main menu to introduce the game title and submenus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have achieved an important milestone in this chapter. Everything that we
    have gone over in the previous chapters was applied to this sample game. The great
    thing about it is that it took us less than a day's worth of development to code.
    The art assets, on the other hand, are a different story.
  prefs: []
  type: TYPE_NORMAL
- en: We still have a few more things to learn with regard to what Corona SDK is capable
    of. In the next chapter, we'll go into more detail on how to optimize our game
    assets for high-resolution devices. We will also see how to post messages on Facebook
    and Twitter through your application.
  prefs: []
  type: TYPE_NORMAL
