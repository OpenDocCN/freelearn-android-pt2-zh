- en: Chapter 4. Organizing a Virtual Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***File**: An object that can be written to, or read from, or both. A file
    has certain attributes, including type. Common types of files include regular
    files and directories. Other types of files, such as symbolic links, may be supported
    by the implementation.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***Filesystem**: A collection of files and certain of their attributes.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*(Boost documentation, [http://www.boost.org](http://www.boost.org))*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting file streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing portable memory-mapped files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing file writers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with in-memory files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing mount points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating files in the .zip archives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompressing files from the .zip archives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading resources asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing application data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files are the building blocks of any computer system. This chapter deals with
    portable handling of read-only application resources, and provides recipes to
    store the application data. We also use the code from [Chapter 3](ch03.html "Chapter 3. Networking"),
    *Networking,* to organize asynchronous loading of resources from the `.zip` archives.
  prefs: []
  type: TYPE_NORMAL
- en: Let us briefly consider the problems covered in this chapter. The first one
    is the access to application data files. Often, application data for desktop operating
    systems resides in the same folder as the executable file. With Android, things
    get a little more complicated. The application files are packaged in the `.apk`
    file, and we simply cannot use the standard `fopen()`-like functions, or the `std::ifstream`
    and `std::ofstream` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem results from the different rules for the filenames and paths.
    Windows and Linux-based systems use different path separator characters, and provide
    different low-level file access APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The third problem comes from the fact that file I/O operations can easily become
    the slowest part in the whole application. User experience can become problematic
    if interaction lags are involved. To avoid delays, we should perform the I/O on
    a separate thread and handle the results of the `Read()` operation on yet another
    thread. To implement this, we have all the tools required, as discussed in [Chapter
    3](ch03.html "Chapter 3. Networking"), *Networking* — worker threads, tasks, mutexes,
    and asynchronous event queues.
  prefs: []
  type: TYPE_NORMAL
- en: We start with abstract I/O interfaces, implement a portable `.zip` archives
    handling approach, and proceed to asynchronous resources loading.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting file streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File I/O APIs differ slightly between Windows and Android (POSIX) operating
    systems, and we have to hide these differences behind a consistent set of C++
    interfaces. All libraries we have compiled in [Chapter 2](ch02.html "Chapter 2. Porting
    Common Libraries"), *Porting Common Libraries* use their own callbacks and interfaces.
    In order to unify them, we shall write adapters in this and subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please make sure you are familiar with the UNIX concept of the file and memory
    mapping. Wikipedia may be a good start ([http://en.wikipedia.org/wiki/Memory-mapped_file](http://en.wikipedia.org/wiki/Memory-mapped_file)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From now on, our programs will read input data using the following simple interface.
    The base class `iObject` is used to add an intrusive reference counter to instances
    of this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are a few methods that take advantage of memory-mapped files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This interface supports both memory-mapped access using the `MapStream()` and
    `MapStreamFromCurrentPos()` member functions, and sequential access with the `BlockRead()`
    and `Seek()` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To write some data to the storage, we use an output stream interface, as follows
    (again, the base class `iObject` is used to add a reference counter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Seek()`, `GetFileSize()`, `GetFilePos()`, and filename-related methods
    of the `iIStream` interface can be implemented in a single class called `FileMapper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read a continuous block of data from this stream and return the number of bytes
    actually read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return zero if we have already read everything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Advance the current position and return the number of copied bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FileMapper` uses the following `iRawFile` interface to abstract the data
    access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Along with the trivial `GetFileName()` and `SetFileName()` methods implemented
    here, in the following recipes we implement the `GetFileData()` and `GetFileSize()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `iIStream::BlockRead()` method is useful when handling non-seekable streams.
    For the fastest access possible, we use memory-mapped files implemented in the
    following recipe. The `MapStream()` and `MapStreamFromCurrentPos()` methods are
    there to provide access to memory-mapped files in a convenient way. These methods
    return a pointer to the memory where your file, or a part of it, is mapped to.
    The `iOStream::Write()` method works similar to the standard `ofstream::write()`
    function. Refer to the project `1_AbstractStreams` for the full source code of
    this and the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The important problem while programming for multiple platforms, in our case
    for Windows and Linux-based Android, is the conversion of filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the following `PATH_SEPARATOR` constant, using OS-specific macros,
    to determine the path separator character in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following simple function helps us to make sure we use valid filenames
    for our operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing portable memory-mapped files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with in-memory files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing portable memory-mapped files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern operating systems provide a powerful mechanism called the memory-mapped
    files. In short, it allows us to map the contents of the file into the application
    address space. In practice, this means we can treat files as usual arrays and
    access them using C pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the implementation of the interfaces from the previous recipe
    we recommend to read about memory mapping. The overview of this mechanism implementation
    in Windows can be found on the MSDN page at [http://msdn.microsoft.com/en-us/library/ms810613.aspx](http://msdn.microsoft.com/en-us/library/ms810613.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about memory mapping, the reader may refer to the `mmap()`
    function documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Windows, memory-mapped files are created using the `CreateFileMapping()`
    and `MapViewOfFile()` API calls. Android uses the `mmap()` function, which works
    pretty much the same way. Here we declare the `RawFile` class implementing the
    `iRawFile` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RawFile` holds a pointer to a memory-mapped file and its size:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the Windows version, we use two handles for the file and memory-mapping
    object, and for the Android, we use only the file handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the following function to open the file and create the memory mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At first, we need to obtain a valid file descriptor associated with the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the file descriptor, we can create a file mapping. Here we omit error
    checks for the sake of clarity. However, the example in the supplementary materials
    contains more error checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The correct deinitialization function closes all the handles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main functions of the `iRawFile` interface, `GetFileData` and `GetFileSize`,
    have trivial implementation here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `RawFile` class we create an instance and wrap it into a `FileMapper`
    class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FM` object can be used with any function supporting the `iIStream` interface.
    The hierarchy of all our `iRawFile` implementations looks like what is shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7785_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing file writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite frequently, our application might want to store some of its data on the
    disk. Another typical use case we have already encountered is the downloading
    of some file from the network into a memory buffer. Here, we implement two variations
    of the `iOStream` interface for the ordinary and in-memory files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us derive the `FileWriter` class from the `iOStream` interface. We add
    the `Open()` and `Close()` member functions on top of the `iOStream` interface
    and carefully implement the `Write()` operation. Our output stream implementation
    does not use memory-mapped files and uses ordinary file descriptors, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We split Android and Windows-specific code paths using defines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same technique is used in the other methods. The difference between both
    OS systems is is trivial, so we decided to keep everything inside a single class
    and separate the code using defines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: However, things may get more complex if you decide to support more operating
    systems. It can be a good refactoring exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can also present an implementation of the `iOStream` that stores everything
    in a memory block. To store arbitrary data in a memory block, we declare the `Blob`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the blob data pointer to some external memory block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Direct access to data inside this blob:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current size of the blob:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if this blob is responsible for managing the dynamic memory it uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Increase the size of the blob and add more data to it. This method is very
    useful in a network downloader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are lots of other methods in this class. You can find the full source
    code in the `Blob.h` file. We use this `Blob` class, and declare the `MemFileWriter`
    class, which implements our `iOStream` interface, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the absolute position inside a file, where new data will be written
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if we are allowed to resize the blob:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And try to resize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Write data to the current position of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure there is enough space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the actual data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We omit the trivial implementations of `GetFileName()`, `GetFilePos()`, `GetMaxSize()`,
    `SetContainer()`, `GetContainer()`, `GetMaxSize()`, and `SetMaxSize()` member
    functions, along with fields declarations. You will find the full source code
    of them in the code bundle of the book.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with in-memory files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with in-memory files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is very convenient to be able to treat some arbitrary in-memory
    runtime generated data as if it were in a file. As an example, let's consider
    using a JPEG image downloaded from a photo hosting, as an OpenGL texture. We do
    not need to save it into the internal storage, as it is a waste of CPU time. We
    also do not want to write separate code for loading images from memory. Since
    we have our abstract `iIStream` and `iRawFile` interfaces, we just implement the
    latter to support memory blocks as the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipes, we already used the `Blob` class, which is a simple
    wrapper around a `void*` buffer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `iRawFile` interface consists of two methods: `GetFileData()` and `GetFileSize()`.
    We just delegate these calls to an instance of `Blob`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sometimes it is useful to avoid the overhead of using a `Blob` object, and
    for such cases we provide another class, `MemRawFile`, that holds a raw pointer
    to a memory block and optionally takes care of the memory allocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the `MemRawFile` as an adapter for the memory block extracted from a
    `.zip` file and `ManagedMemRawFile` as the container for data downloaded from
    photo sites.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"), *Unifying
    OpenGL ES 3 and OpenGL3*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing mount points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is convenient to access all of the application's resources as if they all
    were in the same folder tree, no matter where they actually come from—from an
    actual file, a `.zip` archive on disk, or an in-memory archive downloaded over
    a network. Let us implement an abstraction layer for this kind of access.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We assume that the reader is familiar with the concepts of NTFS reparse points
    ([http://en.wikipedia.org/wiki/NTFS_reparse_point](http://en.wikipedia.org/wiki/NTFS_reparse_point)),
    UNIX symbolic links ([http://en.wikipedia.org/wiki/Symbolic_link](http://en.wikipedia.org/wiki/Symbolic_link)),
    and directory mounting procedures ([http://en.wikipedia.org/wiki/Mount_(Unix)](http://en.wikipedia.org/wiki/Mount_(Unix))).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our folders tree will consist of abstract mount points. A single mount point
    can correspond to a path to an existing OS folder, a `.zip` archive on disk, a
    path inside a `.zip` archive, or it can even represent a removed network path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to extend the proposed framework with network paths mount points.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if the file exists at this mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert a virtual filename, which is the name of this file in our folders tree,
    to a full filename behind this mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to create a file reader that can be used with the `FileMapper`
    class, for the specified virtual file inside this mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For physical folders we provide a simple implementation that creates instances
    of the `FileMapper` class with the reference to `iRawFile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the reader to access the data inside this mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The collection of mount points will be called `FileSystem`, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MapName()` member function transforms a given virtual filename into a form
    that can be passed to the `CreateReader()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `FS_IsFullPath()` function checks if the path starts with the `/` character
    on Android, or contains the `:\` substring on Windows. The `Str_AddTrailingChar()`
    function ensures we have a path separator at the end of the given path.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileSystem` object acts as a container of the mount points, and redirects
    the file reader creation to the appropriate points. The `Mount` method determines
    the type of the mount point. If the `PhysicalPath` ends with either `.zip` or
    `.apk` substrings, an instance of the `ArchiveMountPoint` class is created, otherwise
    the `PhysicalMountPoint` class is instantiated. The `FileExists()` method iterates
    the active mount points and calls the `iMountPoint::FileExists()` method. The
    `VirtualNameToPhysical()` function finds the appropriate mount point and calls
    the `iMountPoint::MapName()` method for the filename to make it usable with the
    underlying OS I/O functions. Here we omit the trivial details of the `FMountPoints`
    vector management.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our `FileSystem::AddAlias` method, we can create a special mount point
    that decorates a filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the alias path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a prefix to be appended to each file in this mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a pointer to another mount point, which is hidden behind the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This decorator class will add the `FAlias` string before any filename passed
    into it. This simple mount point is useful when developing for both Android and
    Windows, because in Android `.apk`, the files reside lower in the folder hierarchy
    than they do in a Windows development folder. Later we determine the folder, where
    our Android application resides, and mount it using the `AliasMountPoint` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the following is the class diagram of our `iMountPoint` interface
    and its implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/7785_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Decompressing files from the .zip archives*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating files in the .zip archives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To incorporate the contents of a `.zip` file seamlessly into our filesystem,
    we need to read the archive contents and be able to access each file individually.
    Since we are developing our own file I/O library, we use the `iIStream` interface
    to access `.zip` files. The NDK provides a way to read the `.apk` assets from
    your C++ application (see `usr/include/android/asset_manager.h` in your NDK folder).
    However, it is only available on Android 2.3, and will make debugging of file
    access in your game more complex on a desktop computer without an emulator. To
    make our native code portable to previous Android versions and other mobile operating
    systems, we will craft our own assets reader.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android applications are distributed as `.apk` packages, which are basically
    just renamed `.zip` archives, containing a special folder structure and metadata
    inside them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the `zlib` library and the `MiniZIP` project to access the content of
    a `.zip` archive. The most recent versions can be downloaded from [http://www.winimage.com/zLibDll/minizip.html](http://www.winimage.com/zLibDll/minizip.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `zlib` library is designed to be extensible. It does not assume every developer
    uses only the `fopen()` calls or the `std::ifstream` interface. To read the data
    from our own containers with the `iIStream` interface, we cast the `iIStream`
    instances to the `void*` pointers and write a set of routines that are passed
    to `zlib`. These routines resemble the standard `fopen()`-like interface and essentially
    only redirect the `zlib` to our `iIStream` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read compressed data from a `.zip` file. This indirection actually allows to
    access archives inside the other archives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the current position inside a `.zip` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Advance to the specified position. The offset value is relative to the current
    position (`SEEK_CUR`), file start (`SEEK_SET`), or file end (`SEEK_END`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do not close or handle errors, so the `fclose()` and `ferror()` callbacks
    are empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the pointers to all functions are stored in the `zlib_filefunc64_def`
    structure that is passed instead of the usual `FILE*` to all functions of `MiniZIP`.
    We write a simple routine to fill this structure, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have implemented the `fopen()` interface, we can provide the code snippet
    to enumerate the files in the archive represented by the `iIStream` object. This
    is one of the two essential functions in the `ArchiveReader` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate through all the files in this archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Store the encountered filenames in a vector of our own structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The array of `sFileInfo` structures is stored in the `ArchiveReader` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the source stream and enumerate the files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract a single file from the archive into the `FOut` stream. This means we
    can extract compressed files directly into the memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Free everything and optionally close the source stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if such a file exists in the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code is the `sFileInfo` structure mentioned in the preceding
    point, that defines where a file is located inside a `.zip` archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we need an offset to the file data inside the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need a size of the uncompressed file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And a size of the compressed file, to let the `zlib` library know when to stop
    decoding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t forget a pointer to the compressed data itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We do not provide the complete source for the `ArchiveReader` class, however,
    do encourage you to look into the accompanying source code. The second essential
    function, the `ExtractSingleFile()`, is presented in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `ArchiveReader` class to write the `ArchiveMountPoint` that provides
    seamless access to the contents of a `.zip` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a reader interface to access the content of the archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if a specified file exists inside this archive mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `ArchiveReader` class takes care of the memory management and returns a
    ready-to-use instance of `MemRawFile`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Decompressing files from the .zip archives*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Cross-platform Audio Streaming"), *Cross-platform
    Audio Streaming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompressing files from the .zip archives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the `Enumerate_ZIP()` function to iterate through individual files inside
    a `.zip` archive, and now it is time to extract its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code uses the same set of `fopen()`-like functions from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following helper function does the job of file extraction and is used in
    the `ArchiveReader::ExtractSingleFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass the supplied password to the `zlib` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the actual decompression loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the `ExtractSingleFile()` function performs the extraction of a single
    file from an archive into an output stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decompress the data through the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ExtractSingleFile()` method uses the `zlib` and `MiniZIP` libraries. In
    the accompanying material, we have included the `libcompress.c` and `libcompress.h`
    files that contain the amalgamated `zlib`, `MiniZIP,` and `libbzip2` sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `2_MountPoints` example contains the `test.cpp` file with the code to iterate
    an archive file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `ArchiveReader` instance contains all the information about the contents
    of the `test.zip` file.
  prefs: []
  type: TYPE_NORMAL
- en: Loading resources asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preface of this book tells us we are going to develop an asynchronous resources
    loading system in this chapter. We have completed all of the preparations for
    this. We are now equipped with secure memory management, task queues, and finally,
    the `FileSystem` abstraction with archive file support.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do now is to combine all of this code to implement a seemingly
    simple thing: create an application that renders a textured quad and updates its
    texture on-the-fly. An application starts, a white quad appears on the screen,
    and then, as soon as the texture file has loaded from disk, the quad''s texture
    changes. This is relatively easy to do—we just run the `LoadImage` task that we
    implement here, and as soon as this task completes, we get the completion event
    on the main thread, which also owns an event queue. We cannot get away with a
    single mutex to update the texture data, because when we use the OpenGL texture
    objects in [Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"),
    *Unifying OpenGL ES 3 and OpenGL 3,* all of the rendering state must be changed
    only in the same thread that created the texture—in our main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We strongly encourage you to review all of the multithreading techniques from
    [Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*. The simple rendering
    techniques we use here are covered in the in the `App3` example in [Chapter 3](ch03.html
    "Chapter 3. Networking"), *Establishing a Build Environment*, and in the `App4`
    example in [Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"), *Porting
    Common Libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we build the foundation for the resources management. We need the concept
    of a bitmap stored in a memory. It is implemented in the `Bitmap` class, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Image dimensions and raw pixel data are set as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here we use a C-style array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `read_bmp_mem()` function from [Chapter 2](ch02.html "Chapter 2. Porting
    Common Libraries"), *Porting Common Libraries,* is used once again, but this time
    the memory buffer comes from an `iIStream` object. In [Chapter 6](ch06.html "Chapter 6. Unifying
    OpenGL ES 3 and OpenGL 3"), *Unifying OpenGL ES 3 and OpenGL 3* we add the `Texture`
    class to handle all of the OpenGL complexities, but right now we simply render
    the instance of a `Bitmap` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we implement the asynchronous loading operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LoadCompleteCapsule` class is a `iAsyncCapsule`-derived class that has
    the overriden `Run()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To load a `Bitmap` object, we implement the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use three global objects: the filesystem `g_FS`, the event queue `g_Events`,
    and the loader thread `g_Loader`. We initialize them at the beginning of our program.
    At first, we start `FileSystem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `iAsyncQueue` and `WorkerThread` objects are created, just as in [Chapter
    3](ch03.html "Chapter 3. Networking"), *Networking*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can load the bitmap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point `Bmp` is a ready-to-use object that will be automatically updated
    on another thread. Of course, it is not thread-safe to use the `Bmp->FBitmapData`,
    since it might be destroyed while we read it, or only partially updated. To overcome
    these difficulties, we have to introduce so-called **proxy objects** that we use
    in [Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"), *Unifying
    OpenGL ES 3 and OpenGL 3*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete example can be found in `3_AsyncTextures`. It implements the asynchronous
    images loading technique described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Cross-platform Audio Streaming"), *Cross-platform
    Audio Streaming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing application data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application should be able to save its temporary and persistent data. Sometimes
    data should be written into a folder on external storage accessible by other applications.
    Let's find out how to get the path to this folder on Android and Windows, and
    do this in a portable way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your Android smartphone unmounts its external storage while connected to
    a desktop computer, make sure you disconnect it and wait for the storage to be
    remounted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to write some Java code to accomplish this task. First, we will ask
    the `Environment` for the external storage directory and its suffix, so we can
    distinguish our data from other applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Suffix` value can be chosen at will. You can use whatever value you desire.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is quite simple; however, we have to perform some additional checks to
    make sure this path is really there. On some devices, for example, without external
    storage, it will be unavailable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check, if the storage is mounted and can be written to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if the storage is writable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass the path to our C++ code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Native code implements the JNI call `OnCreateNative()` this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a small helper function to convert Java strings to `std::string`,
    which we will use frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the application `6_StoringApplicationData` from the code bundle of the
    book. On Android, it will output a line similar to the following into the system
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, it will print the following into the application console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don''t forget to add the `WRITE_EXTERNAL_STORAGE` permission to your `AndroidManifest.xml`
    for your application to be able to write to the external storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the previous code will always fall back to the internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. Writing a Match-3 Game"), *Writing a Match-3
    Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
