- en: Creating a 3D Spinning Wheel Menu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个3D旋转轮菜单
- en: With the exception of [Chapter 5](7a508b47-7123-4cae-9e93-a1f0affbd9d8.xhtml),
    *Introducing 3D Custom Views*, where we explained how to build custom views using
    OpenGL ES, all the other examples in this book use the 2D drawing methods available
    from the `Canvas` class. In the last two chapters, we have seen how to build slightly
    more complex custom views, but none of them were using any 3D rendering techniques.
    So, in this chapter, we will show how to build and customize a full custom 3D
    view and how to interact with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[第5章](7a508b47-7123-4cae-9e93-a1f0affbd9d8.xhtml)，*介绍3D自定义视图*，我们解释了如何使用OpenGL
    ES构建自定义视图之外，本书中的所有其他示例都使用了`Canvas`类提供的2D绘图方法。在最后两章中，我们看到了如何构建稍微复杂的自定义视图，但它们都没有使用任何3D渲染技术。因此，在本章中，我们将展示如何构建和自定义一个完整的3D视图以及如何与之交互。
- en: 'With more detail, we will cover the following in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，我们将在本章介绍以下内容：
- en: Adding interactions to a 3D custom view
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向3D自定义视图添加交互
- en: Adding a `GestureDetector` to manage complex gestures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`GestureDetector`以管理复杂的手势
- en: Using a `scroller` to manage scroll and fling gestures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scroller`管理滚动和抛动手势
- en: Rendering text into textures and drawing them on OpenGL ES
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本渲染成纹理并在OpenGL ES上绘制它们
- en: Generating geometry programmatically
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化生成几何图形
- en: Creating an interactive 3D custom view
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个交互式的3D自定义视图
- en: In [Chapter 5](7a508b47-7123-4cae-9e93-a1f0affbd9d8.xhtml), *Introducing 3D
    Custom Views, *we saw how to create a very simple rotating cube using OpenGL ES.
    Starting from that example and by just adding a way to react to user interactions,
    we can create the foundations of a more complex and interactive custom view.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](7a508b47-7123-4cae-9e93-a1f0affbd9d8.xhtml)，*介绍3D自定义视图*中，我们看到了如何使用OpenGL
    ES创建一个非常简单的旋转立方体。从这个示例开始，只需添加一种对用户交互做出反应的方式，我们就可以创建更复杂、更具交互性的自定义视图的基础。
- en: Adding interactions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加交互
- en: Let's start by using the code from the `Example25-GLDrawing`. Processing user
    interactions is quite simple, as we have already seen in our previous examples.
    We don't have to do anything different than before, just override the `onTouchEvent()`
    method in our class extending `GLSurfaceView` and react properly to the different
    MotionEvents we will receive. For instance, if we don't return `true` when we
    receive a `MotionEvent.ACTION_DOWN`, we will not receive any further events, as
    we are basically saying that we are not handling the event.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`Example25-GLDrawing`的代码开始。处理用户交互非常简单，正如我们在之前的示例中已经看到的。我们不需要做与之前不同的任何事情，只需在我们扩展`GLSurfaceView`的类中重写`onTouchEvent()`方法，并正确地对我们将接收到的不同MotionEvents做出反应。例如，如果我们接收到`MotionEvent.ACTION_DOWN`时不返回`true`，我们将不会收到任何进一步的事件，因为基本上我们是在说我们不处理这个事件。
- en: 'Once we have the source code of the example, let''s add a simple implementation
    of the `onTouchEvent()` that tracks drag events:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有示例的源代码，让我们添加一个简单的`onTouchEvent()`实现，用于跟踪拖动事件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll use the drag amount to change the angle of rotation of the cube, as
    we will see in the following code snippets. In addition, later in this chapter,
    we will see how we can do this animation using a `scroller` class, but, for the
    moment, let''s use a fixed time-step mechanism:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用拖动量来改变立方体的旋转角度，我们将在以下代码片段中看到这一点。此外，在本章稍后，我们将看到如何使用`scroller`类进行此动画，但目前，让我们使用固定时间步进机制：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It uses the same principles as what we have been doing in previous examples,
    execute a single tick of logic every `TIME_THRESHOLD` milliseconds. The cube angle
    value will be interpolated between the current state and the next state depending
    on the time remaining to the execution of the next logic tick. This interpolated
    value will be stored on the `angleFr` variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了我们之前示例中一直遵循的相同原则，每隔`TIME_THRESHOLD`毫秒执行一次逻辑滴答。立方体角度值将在当前状态和下一个状态之间根据剩余执行时间进行插值。这个插值值将存储在`angleFr`变量中。
- en: 'We have also done some changes to the `onSurfaceChanged` to use the perspective
    projection mode instead of using `Matrix.frustrumM`. The latter defines the six
    clipping planes: near, far, top, bottom, left, and right. However, using `Matrix.perspective`
    allows us to define the projection matrix in terms of the camera field of view
    angle and two clipping planes: near and far. It might be handier in some situations,
    but at the end of the day, both methods achieve the same objective:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对`onSurfaceChanged`进行了一些修改，以使用透视投影模式，而不是使用`Matrix.frustrumM`。后者定义了六个裁剪平面：近、远、上、下、左和右。然而，使用`Matrix.perspective`允许我们以摄像机视场角和两个裁剪平面：近和远来定义投影矩阵。在某些情况下可能更方便，但最终，这两种方法实现了相同的目标：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we have got to do some changes to the `onDrawFrame()` method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对`onDrawFrame()`方法进行一些修改：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Basically, the changes we have got to make are to call the `animateLogic()`
    method to execute any pending logic tick and use the interpolated `angleFr` variable
    for the rotation angle. If we run this example, we will get the same cube we had
    in `Example25` but, in this case, we can control the animation by dragging horizontally
    on the screen. We have also got to remember, that there is no need to call `invalidate`
    or `postInvalidate` as when extending our class from `GLSurfaceView` and, unless
    specifically indicated, the screen will be constantly redrawn.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要做的更改是调用`animateLogic()`方法来执行任何挂起的逻辑滴答，并使用插值的`angleFr`变量作为旋转角度。如果我们运行这个例子，我们将得到与`Example25`中相同的立方体，但在这个情况下，我们可以通过在屏幕上水平拖动来控制动画。我们还必须记住，从`GLSurfaceView`扩展我们的类时，无需调用`invalidate`或`postInvalidate`，除非特别指出，屏幕将不断重绘。
- en: Improving interactions and animations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高交互和动画效果。
- en: We have been using a fixed time-step mechanism to manage the animations, but
    let's see what advantages it gives us to use a `scroller` class provided by Android
    to handle the animations, instead of handling all the animations by ourselves.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用固定时间步机制来管理动画，但让我们看看使用Android提供的`scroller`类来处理动画，而不是自己处理所有动画，会给我们带来哪些优势。
- en: 'First, let''s create a `GestureDetector` instance to handle the touch events:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`GestureDetector`实例来处理触摸事件：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using the `GestureDetectorCompat` from the support library to guarantee
    the same behavior on older versions of Android.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了支持库中的`GestureDetectorCompat`，以确保在旧版本的Android上具有相同的行为。
- en: 'As we covered in [Chapter 3](99203bd5-42a8-4ef7-96a5-83d55acf109d.xhtml), *Handling
    Events*, by introducing a `GestureDetector` we can greatly simplify our `onTouchEvent()`,
    as all the logic will be handled by the `MenuGestureListener`callback instead
    of being on the `onTouchEvent()`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](99203bd5-42a8-4ef7-96a5-83d55acf109d.xhtml)《处理事件》中所述，通过引入`GestureDetector`，我们可以大大简化`onTouchEvent()`，因为所有逻辑将由`MenuGestureListener`回调处理，而不是在`onTouchEvent()`中处理：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `gestureDetector` requires an implementation of an `OnGestureListener`,
    but if we only want to implement some methods and not have to worry about the
    other methods exposed by the interface, we could just extend from `GestureDetector.SimpleOnGestureListener`
    and only override the methods we need. The `GestureDetector.SimpleOnGestureListener`
    class comes with a dummy empty implementation for all the methods exposed in the
    `OnGestureListener` interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`gestureDetector`需要一个`OnGestureListener`的实现，但如果我们只想实现一些方法，不想关心接口公开的其他方法，我们可以从`GestureDetector.SimpleOnGestureListener`继承，只覆盖我们需要的方法。`GestureDetector.SimpleOnGestureListener`类为`OnGestureListener`接口公开的所有方法提供了一个空的实现。'
- en: '`SimpleOnGestureListener` also implements other interfaces to make our lives
    as software engineers easier, but please refer to the Android documentation for
    more information.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleOnGestureListener`还实现了其他接口，以使我们的软件工程师生活更加轻松，但请参考Android文档获取更多信息。'
- en: 'Let''s then create our own internal class, `MenuGestureListener`, extending
    from `GestureDetector.SimpleOnGestureListener`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建自己的内部类`MenuGestureListener`，从`GestureDetector.SimpleOnGestureListener`继承：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we have mentioned before, even if it's an `OnGestureListener` implementation,
    we have got to return `true` on the `onDown()` method. Otherwise, the `onScroll()`
    or `onFling()` methods from our `OnGestureListener` implementation won't be called
    whenever there is a scroll or fling event.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，即使是一个`OnGestureListener`实现，我们也需要在`onDown()`方法中返回`true`。否则，当有滚动或抛掷事件时，我们的`OnGestureListener`实现中的`onScroll()`或`onFling()`方法不会被调用。
- en: 'Anyway, we still have some work to do on the `onDown()` method: We have got
    to stop any running animation so the custom view will feel more reactive to the
    user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们仍然需要在`onDown()`方法上做一些工作：我们需要停止任何正在运行的动画，以便自定义视图对用户的操作更加灵敏。
- en: 'We have implemented two other methods: `onScroll()` and `onFling()`. They''re
    both managing different gestures that directly map to different ways of scrolling.
    Whenever we are dragging on the screen, the `onScroll()` method will be called
    as we will be actually scrolling. On the other hand, when we do a fling gesture;
    that is, when the user drags and lifts the finger from the screen very quickly,
    we need to take into consideration other parameters, such as the velocity and
    friction of the animation. When the gesture finishes, the animation will still
    run for some time, slowing down until stopping depending on the defined friction.
    In that case, the `onFling()` method from our listener will be called with the
    horizontal and vertical velocity of the fling event, leaving the friction to be
    handled by us.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了另外两个方法：`onScroll()`和`onFling()`。它们都管理直接映射到不同滚动方式的不同的手势。当我们拖动屏幕时，将调用`onScroll()`方法，因为实际上我们正在滚动。另一方面，当我们执行抛动手势；即，当用户快速拖动并从屏幕上抬起手指时，我们需要考虑其他参数，如动画的速度和摩擦力。当手势结束时，动画仍会运行一段时间，根据定义的摩擦力逐渐减慢直至停止。在这种情况下，将调用我们监听器中的`onFling()`方法，并带有抛动事件的水平和垂直速度，由我们来处理摩擦力。
- en: In both events, we will be using a `scroller` class to simplify the calculations.
    We could do it ourselves but, although implementing the `onScroll()` logic would
    be quite straightforward, implementing the `onFling()` animation properly would
    require some calculations and complexities that we can take for granted by using
    a `scroller` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个事件中，我们将使用`scroller`类来简化计算。我们本可以自己完成，尽管实现`onScroll()`逻辑相当直接，但正确实现`onFling()`动画需要一些计算和复杂性，通过使用`scroller`类我们可以省去这些麻烦。
- en: On the `onScroll()` implementation, we are simply calling the `startScroll`
    method of the `scroller` from the current position and the dragged distance. To
    get the current position, we have got to call `scroller.computeScrollOffset` first.
    If we don't call it, the current value will always be zero. Once we have called
    this method, we can retrieve the current value of the `scroller` by using the
    `getCurrX` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onScroll()`实现中，我们仅从当前位置和拖动距离调用`scroller`的`startScroll`方法。为了获取当前位置，我们首先需要调用`scroller.computeScrollOffset`。如果我们不调用它，当前值将始终为零。调用此方法后，我们可以通过使用`getCurrX`方法来获取`scroller`的当前值。
- en: As in our listener we are getting the distance as a floating point and `startScroll`
    only accepts integer values, we will round the `distanceX` value by just adding
    0.5 and then converting it in to an integer value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的监听器中获取的是浮点数距离，而`startScroll`只接受整数值，因此我们将`distanceX`值四舍五入，只需加上0.5然后转换为整数值。
- en: Similarly, on the `onFling()` implementation we will be calling the `fling`
    method of the `scroller`. We'll get the current position, as we have described
    in the `onScroll()` implementation, and we will adjust the velocity as it was
    too high from the point of view of animating a rotating cube. We have set the
    maximum and minimum values to 100 full turns of the cube as, in normal circumstances,
    we don't want to limit the rotation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在`onFling()`实现中，我们将调用`scroller`的`fling`方法。我们将获取当前位置，如我们在`onScroll()`实现中所描述的，并且我们将调整速度，因为从旋转立方体的动画角度来看它太高了。我们将立方体的最大和最小值设置为100圈，因为在正常情况下，我们不希望限制旋转。
- en: Now, by using a `scroller`, we can get rid of the `animateLogic()` method and
    all associated variables, as we will no longer need them. On both gestures, scroll
    and fling, the animations will be performed on the background and we can directly
    query the current animated value directly from the `scroller` instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用`scroller`，我们可以摆脱`animateLogic()`方法及其所有相关变量，因为我们不再需要它们。在滚动和抛动两种手势中，动画将在后台执行，我们可以直接从`scroller`实例查询当前的动画值。
- en: 'The only changes we have got to do on the `onDraw()` method is to call the
    `scroller.computeScrollOffset` method to have an updated value and, instead of
    using the `angleFr` variable, get the value from the `scroller`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onDraw()`方法上我们需要做的唯一更改是调用`scroller.computeScrollOffset`方法以获取更新后的值，并且不是使用`angleFr`变量，而是从`scroller`获取值：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding actionable callbacks
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可操作回调
- en: Let's convert this into an actionable menu. We could map an action to each face
    of the cube. As we are rotating the cube horizontally, or on the `y` axis, we
    could map an action to each of the four available faces.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个转换成一个可操作的菜单。我们可以将一个动作映射到立方体的每个面。由于我们是沿着`y`轴水平旋转立方体，我们可以将一个动作映射到四个可用的每个面上。
- en: 'For added clarity, as currently the rotation might end in the middle of a face,
    let''s add a small feature: whenever the animation finishes, let''s snap it to
    the closest face, so we''ll always have a fully aligned front face of the cube
    when there is no animation running.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加清晰，目前旋转可能会在立方体的一个面的中间结束，让我们添加一个小功能：每当动画结束时，让它捕捉到最近的面对齐，这样在没有动画运行时，我们总会有一个完全对齐的立方体前方面。
- en: 'Implementing snapping is fairly simple. We have got to check if the animation
    has finished and, in that case, check which face is facing to the camera. We could
    do so by simply dividing the current rotation angle by `90`; `360` degrees split
    by four faces is `90` degrees each. To see if we are closer to that face than
    from the next one, we have got to get the fractional part of the rotation angle.
    If we calculate the angle modulo `90`, we will get a number between *0* and *89*.
    If that result is smaller than half the degrees needed to switch from one face
    to another, we will be on the right face. However, in the opposite case, if that
    result is bigger than `45`, or smaller than `-45`, we''d have to rotate to the
    next or previous face, respectively. Let''s write this small logic in our `onDraw()`
    method, just after the call to `scroller.computeScrollOffset`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实现捕捉功能相当简单。我们需要检查动画是否已经完成，如果是，检查哪个面正对相机。我们可以简单地将当前旋转角度除以`90`；四个面分割`360`度，每个面是`90`度。为了查看我们是否比下一个面更接近这个面，我们需要获取旋转角度的小数部分。如果我们计算旋转角度模`90`，我们会得到一个介于*0*和*89*之间的数字。如果这个结果小于从一个面切换到另一个面所需度数的一半，我们就在正确的面上。然而，在相反的情况下，如果这个结果大于`45`，或者小于`-45`，我们则分别需要旋转到下一个面或上一个面。让我们在`onDraw()`方法中，在调用`scroller.computeScrollOffset`之后，编写这个小逻辑：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To calculate the snap angle, we do an integer division by `90` and multiply
    the result by `90`. As it''s an integer division, it''ll get rid of the decimal
    part and calculate the absolute angle value of that face. Another way of writing
    that code would be the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算捕捉角度，我们对`90`进行整数除法并将结果乘以`90`。由于这是整数除法，它会去掉小数部分并计算该面的绝对角度值。另一种编写该代码的方式如下：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, depending on the modulo result, we are adding `90` or subtracting `90`
    to effectively go to the next or previous face.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据模运算的结果，我们加上`90`或减去`90`，有效地转到下一个面或上一个面。
- en: 'Now, let''s add the code to manage the user clicks. First, let''s create an
    interface of a listener to delegate the handling of the event to that listener:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加管理用户点击的代码。首先，让我们创建一个事件监听器的接口，将事件处理委托给该监听器：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, let''s add an` OnMenuClickedListener` variable to our class and a setter
    method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们在我们的类中添加一个`OnMenuClickedListener`变量以及一个设置方法：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can implement the `onSingleTapUp` method on the `MenuGestureListener`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`MenuGestureListener`上实现`onSingleTapUp`方法：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s also add an `id` to our custom view in the `activity_main` layout file,
    so we can get the `GLDrawer` view from the code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`activity_main`布局文件中为我们的自定义视图添加一个`id`，这样我们就可以从代码中获取`GLDrawer`视图：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, modify the `MainActivity` class to create an `OnMenuClickedListener`
    and set it to the `GLDrawer` view:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改`MainActivity`类，创建一个`OnMenuClickedListener`并将其设置到`GLDrawer`视图：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we run this example, we will see how the `MainActivity` is logging which
    face are we clicking on the cube:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子，我们会看到`MainActivity`正在记录我们点击立方体的哪个面：
- en: '`com.packt.rrafols.draw I/Example36-Menu3D: option clicked 3`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.packt.rrafols.draw I/Example36-Menu3D: 选项点击了 3`'
- en: '`com.packt.rrafols.draw I/Example36-Menu3D: option clicked 2`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.packt.rrafols.draw I/Example36-Menu3D: 选项点击了 2`。'
- en: We will also see how the snapping works. Play with it to see how it snaps to
    the current face, to the next one, or to the previous one if we are scrolling
    backwards.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到捕捉功能是如何工作的。玩一玩它，看看它是如何捕捉到当前面，下一个面，或者如果我们向后滚动，则捕捉到前一个面。
- en: Customizations
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义
- en: We are still rendering the cube the same way we left it in `Example25`. Let's
    change it to draw every cube face in a different solid color. We can define a
    different color per vertex, but as vertices are shared between faces, their colors
    will be interpolated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然以`Example25`中留下来的方式渲染立方体。让我们改变它，用不同的实心颜色绘制每个立方体面。我们可以为每个顶点定义不同的颜色，但由于顶点在面之间共享，它们的颜色将会被插值。
- en: 'We''d have to replicate some vertices so we can have different unique colors
    for each single face:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不复制一些顶点，以便每个面都有不同的唯一颜色：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have updated the index as well, to map to the new faces. On the duplicated
    vertex, we have added a comment with the new index and the old index.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了索引，以便映射到新的面。在复制的顶点上，我们添加了带有新索引和旧索引的注释。
- en: 'Now, we can define some colors:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一些颜色：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s also change the texture initialization on the `initBuffer` methods to
    create a color `Buffer`, like we did in `Example24-GLDrawing`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也改变`initBuffer`方法中的纹理初始化，创建一个颜色`Buffer`，就像在`Example24-GLDrawing`中所做的那样：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Update the pixel and vertex `Shader`s:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更新像素和顶点`Shader`：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To make it more configurable, let''s create a public `setColors()` method on
    `GLDrawer` to change the colors:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更具可配置性，让我们在`GLDrawer`上创建一个公共的`setColors()`方法来更改颜色：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The implementation on the `Renderer`  is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer`上的实现如下：'
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For simplicity, we will pass the colors as an integer, instead of a float array,
    so we can use colors in hexadecimal encoding, for example. To convert an integer
    color to a float array we can use a simple helper method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将颜色作为整数传递，而不是浮点数数组，这样我们就可以使用十六进制编码的颜色。要将整数颜色转换为浮点数数组，我们可以使用一个简单的辅助方法：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To update the example, let''s set some colors using the method we have just
    added:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新示例，让我们使用刚才添加的方法设置一些颜色：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we run the example, we will get something like the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行示例，我们将得到类似于以下截图的内容：
- en: '![](img/ae6c30d9-7a8d-4dfe-a9b6-887b1e7cc9ae.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae6c30d9-7a8d-4dfe-a9b6-887b1e7cc9ae.png)'
- en: Check the full source code of this example in the `Example36-Menu3D` folder
    in the GitHub repository.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库的`Example36-Menu3D`文件夹中查看此示例的完整源代码。
- en: Beyond the basic implementation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越基本实现
- en: We have got a very basic and actionable 3D menu but, in order for it to be used
    on a production application, we have got to add some more details. For instance,
    we can now select a different menu option depending on the face of the cube we
    are selecting, but unless we are doing a very simple color picker, we'd be selecting
    an option completely blind, as we won't know which face does exactly what.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了一个非常基础且可操作的3D菜单，但为了使其能够用于生产应用程序，我们还需要添加一些更多细节。例如，现在我们可以根据我们选择的立方体面来选择不同的菜单选项，但除非我们正在做一个非常简单的颜色选择器，否则我们将完全盲目地选择一个选项，因为我们不知道每个面具体做什么。
- en: One way to solve this is to render some text depending on which face is selected,
    but on OpenGL ES we can't simply just call `drawText` and render some text, like
    we are used to do when using a `Canvas`. Also, in this example, there are only
    four selectable faces or options; let's make some changes so we can have more
    selectable options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是，根据选择的面来渲染一些文本，但在OpenGL ES上，我们不能像使用`Canvas`时那样简单地调用`drawText`来渲染文本。此外，在这个例子中，只有四个可选择的面或选项；让我们做一些更改，以便有更多可选择选项。
- en: Rendering text
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染文本
- en: As we have just mentioned, to render text, we can't just call a `drawText` method
    that will render some text in 3D inside our small 3D scene. Actually, we'd be
    using `drawText`, but just to render it on a background `Bitmap` that would be
    used as a texture for an additional plane we will be rendering.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，为了渲染文本，我们不能仅仅调用一个`drawText`方法，在小型3D场景内渲染3D文本。实际上，我们会使用`drawText`，但只是将其渲染在背景`Bitmap`上，该`Bitmap`将用作我们还将渲染的附加平面的纹理。
- en: 'In order to do so, we''d have to define the geometry of that plane:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们定义了该平面的几何形状：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the cube front face is at z-coordinate -1.f, this plane will be at -1.4f,
    so 0.4f in front of it, otherwise it might get occluded by the cube.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于立方体前面位于z坐标-1.f，这个平面将位于-1.4f，即比它靠前0.4f，否则它可能会被立方体遮挡。
- en: 'We have got to add the vertex and fragment `Shader` again, to render with a
    texture. Although we will not replace the current `Shader` we have got in our
    code, we will have to live with both sets of `Shader`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次添加顶点和片段`Shader`，以便使用纹理进行渲染。尽管我们不会替换代码中已有的`Shader`，但我们将不得不同时使用这两套`Shader`：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s also update the `initBuffers` method to initialize both sets of `Buffers`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新`initBuffers`方法，以初始化两套`Buffers`：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, this method is allocating both sets of Buffers: one set for
    the cube and another for the plane we will use to draw the text. We have got to
    do a similar approach for the vertex and fragment `Shaders`, we have got to load
    and link both sets of `Shaders`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，此方法分配了两套缓冲区：一套用于立方体，另一套用于我们将用来绘制文本的平面。我们必须对顶点和片段`Shaders`采取类似的方法，我们必须加载并链接两套`Shaders`：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are attaching the shaders we will use to draw the text in a texture to another
    `Shader` program we will store in the `shaderTextProgram` variable. Depending
    on what we want to render we could now switch from `shaderProgram` or `shaderTextProgram`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于在纹理中绘制文本的着色器附加到我们将存储在`shaderTextProgram`变量中的另一个着色器程序。根据我们想要渲染的内容，我们现在可以从`shaderProgram`或`shaderTextProgram`之间切换。
- en: 'Let''s now create a method that returns a Bitmap with a text centered on it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个方法，该方法返回一个在其上居中文本的`Bitmap`：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This method creates a `Bitmap` of `512` by `512` with eight bits per color
    component and four components: alpha, or transparency, red, green, and blue. Then,
    it is creating a `Paint` object with the color and size of the text, getting the
    text boundaries in order to center it on the `Bitmap` and drawing the text twice
    on the `Canvas` object we can get from the `Bitmap`. Text is drawn twice, because
    it first draws the text with a solid white color and then, as we change the `Paint`
    object style to `STROKE`, it''s draws the silhouette using a black color.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个大小为`512`乘`512`的`Bitmap`，每个颜色组件具有八位位深度，包含四个组成部分：alpha（透明度）、红色、绿色和蓝色。然后，它创建一个`Paint`对象，设置文本的颜色和大小，获取文本边界以便在`Bitmap`上居中，并在从`Bitmap`获取的`Canvas`对象上绘制两次文本。文本绘制两次，因为它首先使用纯白色绘制文本，然后，当我们把`Paint`对象的样式改为`STROKE`时，它使用黑色绘制轮廓。
- en: 'The code we had in previous examples to load a texture was loading it from
    a local resource. As it was converting it into an unscaled `Bitmap`, we could
    reuse most of that code to load our generated `Bitmap`. Let''s recover the `loadTexture()`
    method we already had, but let''s change it to use a helper method to upload a
    `Bitmap` into a `Texture`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前示例中的代码用于从本地资源加载纹理，它将其转换为未缩放的`Bitmap`，我们可以重用大部分代码来加载我们生成的`Bitmap`。让我们恢复我们已有的`loadTexture()`方法，但让我们更改它以使用辅助方法将`Bitmap`上传到`Texture`：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The implementation of the helper method is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法的实现如下：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have only got to create a method that puts everything together: that is,
    one that generates a `Bitmap` from a text, generates a `textureIds`, uploads the
    `Bitmap` as a texture, and recycles the `Bitmap`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要创建一个将所有内容结合在一起的方法：即，一个从文本生成`Bitmap`，生成`textureIds`，将`Bitmap`上传为纹理，并回收`Bitmap`的方法：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using this method, we can now generate a different texture for each face of
    the cube:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们现在可以为立方体的每个面生成不同的纹理：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now add at the bottom of the `onDraw()` method some additional code
    to render a plane in front of each face of the cube:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`onDraw()`方法的底部添加一些额外的代码，以在立方体每个面的前方绘制一个平面：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, we are changing the `positionHandle` to the plane geometry, enabling
    the texture vertex array and, in addition, we are enabling the blending mode.
    As the text texture will be transparent with the exception of the text, we need
    to enable blending or otherwise, OpenGL ES will render the transparent pixels
    as black.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们将`positionHandle`更改为平面几何，启用纹理顶点数组，并且，我们还需要启用混合模式。由于除了文本外，文本纹理将是透明的，我们需要启用混合，否则OpenGL
    ES将渲染透明像素为黑色。
- en: To draw different planes, one for each horizontal face of the cube, we are doing
    a small loop where we bind a different texture and rotate by 90 degrees on each
    iteration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制不同的平面，为立方体的每个水平面绘制一个，我们进行了一个小循环，每次迭代绑定不同的纹理并旋转90度。
- en: 'If we run this example, we will see something similar to the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，我们将看到类似于以下截图的内容：
- en: '![](img/70b31fe6-26e6-4027-9e6e-de7345c92dee.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70b31fe6-26e6-4027-9e6e-de7345c92dee.png)'
- en: Multiple faces
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个面
- en: Now that we have added the ability to render some text on top of the faces of
    the cube, we can know what we are selecting when clicking an option, but we are
    still limited to four different options. Currently, we have got the geometry hardcoded
    in the code in several arrays. If we want to make the number of options, or number
    or faces, dynamic we'd have to generate, programmatically, both the geometry and
    the face indexes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在立方体的面上添加了渲染文本的能力，这样在点击选项时我们可以知道选择了什么，但我们仍然局限于四种不同的选项。目前，我们在代码中用几个数组对几何形状进行了硬编码。如果我们想要使选项的数量或面的数量动态化，我们就需要以编程方式生成几何形状和面索引。
- en: Luckily for us, our starting point is to have several choices in a 3D circle,
    so we only have to generate a hollow cylinder with several faces, exactly as much
    as the number of options we'd like to have.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的起点是在3D圆中有几个选择，所以我们只需要生成一个具有多个面的空心圆柱体，正好与我们想要的选项数量相同。
- en: 'Let''s add a method to the `GLDrawer` custom view class, allowing us to set
    the number of options and faces that we will have:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`GLDrawer`自定义视图类中添加一个方法，允许我们设置将要拥有的选项和面的数量：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To generate diverse faces in a form of a cylinder is as easy as dividing the
    `360` degrees, or two times `PI` in radians, of a circle in the amount of faces
    we'd like to have. Here, we are dividing `2.f*Math.PI` by the number of options
    and then multiplying it by the loop iterator. By calculating the sine and the
    cosine of that angle we can get two coordinates, usually `x` and `y` in a 2D projection,
    but in our specific case, we'd map it to `x` and `z` as we are setting the `y`
    coordinate to `-1.f` as the top vertical edge and `1.f` as the bottom vertical
    edge. We are also calculating the next `x` and `z` coordinates, so we can create
    a face quad between these points.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以圆柱体的形式生成不同的面，只需将一个圆的`360`度（或两倍的`PI`弧度）除以我们想要的面数。在这里，我们将`2.f*Math.PI`除以选项的数量，然后乘以循环迭代器。通过计算该角度的正弦和余弦，我们可以得到两个坐标，通常是2D投影中的`x`和`y`，但在我们的特定情况下，我们将它映射到`x`和`z`，因为我们将`y`坐标设置为`-1.f`作为顶部垂直边缘，`1.f`作为底部垂直边缘。我们还在计算下一个`x`和`z`坐标，这样我们就可以在这些点之间创建一个面四边形。
- en: We're generating four points for each face and we're indexing them as two triangles
    in the index array. This matches perfectly with the way we were generating colors
    before, as we're generating four color values for each face and now we are also
    generating exactly four vertices per face, each face will have a unique solid
    color.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个面生成四个点，并将它们作为索引数组中的两个三角形进行索引。这与我们之前生成颜色的方式完全匹配，因为我们为每个面生成了四个颜色值，现在我们也为每个面精确生成四个顶点，每个面都将有一个独特的实心颜色。
- en: 'At the end of the method, we''re calling the `setCoordinates()` method of the
    `GLRenderer`, but that is very simple to implement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的最后，我们调用了`GLRenderer`的`setCoordinates()`方法，但实现起来非常简单：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will work without touching anything else, as long as we call it before
    the surface is created. As we''re talking about it, we have got to update the
    `onSurfaceCreated()` method to use the number of options we''ve set instead of
    the default four we had hardcoded in the code before:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们在创建表面之前调用它，它就可以在不接触其他任何东西的情况下工作。正如我们所说，我们需要更新`onSurfaceCreated()`方法，以使用我们设置的选项数量，而不是之前代码中硬编码的默认四个：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We're also calculating the amount we've got to rotate to switch from one face
    to another. In our previous case it was easy, as there were four faces, `360`
    degrees divided by 4 is 90\. Now, the calculation is still straightforward, but
    we've got to change the hardcoded 90 we had in the code by this new variable we've
    created, named `faceAngle`, the value of which is `360` divided by the number
    of options.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在计算需要旋转多少度才能从一个面切换到另一个面。在我们之前的案例中这是简单的，因为只有四个面，`360`度除以4等于90度。现在，计算仍然简单，但我们需要用我们创建的这个新变量`faceAngle`替换代码中硬编码的90度，其值是`360`除以选项的数量。
- en: 'Let''s test this new feature by calling it on the `MainActivity`, just after
    setting the different colors:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`MainActivity`中测试这个新功能，在设置不同的颜色之后立即调用它：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've not specifically added a check, but the number of colors must be at least
    the same number of options or otherwise we will get an exception when rendering.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有特别添加检查，但颜色的数量至少应该与选项的数量相同，否则在渲染时我们会遇到异常。
- en: 'If we run this example, we will see something similar to the following screenshot,
    depending always on the current rotation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，我们将看到类似于以下截图的内容，具体取决于当前的旋转：
- en: '![](img/29f47705-8e88-43da-aead-ab20139b5456.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29f47705-8e88-43da-aead-ab20139b5456.png)'
- en: Check out the full source code of this example in the `Example37-Menu3D` folder
    in the GitHub repository.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库的`Example37-Menu3D`文件夹中查看这个示例的完整源代码。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've seen how to add interactions to a 3D custom view to make
    it interactive. In addition, we've seen how to use a `scroller` instance to manage
    both scroll and fling gestures and how to render text as a texture and use different
    geometry with different Buffers and different `Shaders`. At the end, we've also
    seen how we can easily generate geometry to make our custom view adaptable and
    dynamic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何向3D自定义视图添加交互功能以实现互动性。此外，我们还了解了如何使用`scroller`实例来管理滚动和抛动手势，以及如何将文本渲染为纹理，并使用不同的Buffer和不同的`Shaders`来应用不同的几何形状。最后，我们还学习了如何轻松生成几何图形，使我们的自定义视图具有适应性和动态性。
- en: In this book, we've seen how to build different kinds of custom views and to
    use both methods and classes from the Android SDK or to use our own, depending
    on our needs. We've also seen how to build both 2D and 3D custom views and to
    make them reactive to user input. At the end of the day, using all the APIs we've
    shown and a lot of creativity we can build any custom view we want. We still have
    to keep in mind that Android provides us with a great framework that is constantly
    evolving and contains plenty of good, and efficient, ways of drawing awesome UIs,
    but sometimes we want to build something special that we can't easily make using
    the standard APIs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们学习了如何构建不同类型的自定义视图，并根据我们的需要使用Android SDK中的方法或类，或者使用我们自己的方法。我们还了解了如何构建2D和3D自定义视图，并使它们对用户输入做出反应。最终，借助我们所展示的所有API和大量的创造力，我们可以构建任何我们想要的自定义视图。但我们仍需牢记，Android为我们提供了一个不断进化的优秀框架，其中包含了许多优秀且高效的绘制出色UI的方法，但有时我们想要构建一些特别的，无法仅通过标准API轻松实现的东西。
- en: To learn even more about building Android UIs and custom views, there are plenty
    of tutorials on development blogs, several open sourced open views, and many sessions
    at meetups and conferences. Attending local meetups and conferences is a great
    way to not only learn about custom views, but also to stay up-to-date with Android
    development. There are many initiatives led by the Android community and I'd really
    like to encourage anyone to contribute in any way they can to keep the Android
    community alive and as awesome as it is.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步了解构建Android UI和自定义视图，开发博客上有大量的教程，许多开源的自定义视图，以及各种聚会和会议上的讨论环节。参加本地的聚会和会议不仅是了解自定义视图的好方法，还能跟上Android开发的最新动态。Android社区有许多举措，我真心鼓励每个人尽其所能地贡献，以保持Android社区的活力和卓越。
