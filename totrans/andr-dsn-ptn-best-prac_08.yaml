- en: Chapter 8. Composing Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how patterns can be used to manipulate, organize, and present data,
    but this data has been fleeting, and we have not yet considered how to ensure
    data persists from one session to the next. In this chapter, we will look at how
    this is done using internal data storage mechanisms. In particular, we will explore
    how users can save their preferences, making the app simpler and more fun to use.
    Before we do this, we will begin the chapter by examining the composite pattern
    and its uses, particularly when it comes to constructing hierarchical structures
    such as Android UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a layout with composer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit application files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store user preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the activity life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add unique identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most immediate ways we can apply design patterns to an Android project
    is layout inflation, and back in [Chapter 6](ch06.html "Chapter 6. Activating
    Patterns"), *Activating Patterns*, we used a builder pattern to inflate a simple
    layout. This example had some serious shortcomings. It only handled text views
    and did not cater for nested layouts. For dynamic layout inflation to be of real
    use to us, we need to be able to include any type of widget or view at any level
    of the layout hierarchy, and this is where the composite design pattern comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: The composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, the composite pattern might seem very similar to the builder
    pattern, as both build complex objects out of smaller ones. There is, however,
    a significant difference in the approach these patterns take. Builders work in
    a very linear fashion, adding objects one at a time. The composite pattern, on
    the other hand, can add groups of objects as well as individual ones. More importantly,
    it does so in such a way that the client can add individual objects or groups
    of objects without having to concern itself with which it is dealing with. In
    other words, we can add completed layouts, individual views, or groups of views
    with exactly the same code.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the ability to compose branching data structures, the ability to
    hide from the client the details of the objects being manipulated is what makes
    the composer pattern so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating a layout composer, we will take a look at the pattern itself,
    applied to a very simple model, so that we can appreciate the workings of the
    pattern better. Here is the overall structure. As you can see, it is very simple
    conceptually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to construct our composite pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with an interface that can represent both individual components and collections
    of components, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this class to extend the interface for individual components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add the class for collections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see here, this pattern is very simple, yet very effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The composite pattern](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see it in action, we need to define some components and composites. We can
    define components with lines like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create composite collections with the `add()` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Nesting compositions within each other is just as simple because we have written
    the code so that we can disregard whether we are creating a `Leaf` or a `Composite`
    and use the same code for either. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a component, which is simply text in this case, is as easy as calling
    its `inflate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining and printing a fair selection of outputs would make for considerably
    cluttered client code, and the solution we will adopt here is to steal an idea
    from another pattern and employ a single builder class to do the work of constructing
    our desired compositions. These could be anything we like, and here is one possible
    builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves the `onCreate()` method of our activity clean and simple to follow,
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although we have only produced a basic output, it should be clear how we can
    now extend this to inflating real layouts and how useful this technique can be.
  prefs: []
  type: TYPE_NORMAL
- en: A Layout composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Activating Patterns"), *Activating Patterns*,
    we used a builder to construct a simple UI. The builder was a perfect choice for
    this task, as we were only concerned with including one type of view. We could
    have adapted this scheme (literally, with an adapter) to cater for other view
    types, but it would be far better to employ a pattern that does not care what
    type of component it is dealing with. Hopefully, the preceding example demonstrates
    the composite pattern's suitability to this kind of task.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will apply the same principle to an actual UI inflater
    that works with different types of view, composite groups of views and, most significantly,
    dynamic nested layouts.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this exercise, we will suppose that our app has a news page.
    This would largely be a promotional feature, but it has been demonstrated that
    consumers are more susceptible to advertising when it is dressed up as news. Many
    of the components, such as header and logo, will remain static, while others will
    change frequently in both content and layout structure. This makes it an ideal
    subject for our composer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the UI we will be developing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Layout composer](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will approach each problem individually, building the code as we go. First,
    we will tackle the issue of creating and displaying a single component view by
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we start with the `Component` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now implement this with the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `Builder`, which, for now, is remarkably simple, containing only
    two properties and a constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, edit the `onCreate()` method of the activity to use our own layout
    as the root and add our view to it, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As it stands, there is nothing impressive about what we have done here, but
    having worked through the previous example, it will be clear where we are going
    with this, and our next step is to create a component that will handle image views.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following snippet, the `ImageLeaf` class is almost identical
    to its textual sibling, differing only in the view type it generates and the use
    of `setImageResource()` to operate on the `id` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be easily added to the builder in the same way as the text view, although
    now we will create a small method for this and call it from the constructor, as
    we may want to add a number of others. The code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As intended, as far as the client code is concerned, there is no difference
    between this and any other component, and it can be inflated with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Image views and text views can both take their respective primary contents (image
    and text) as resource ID integers and so we can use the same `int` parameter for
    both. Dealing with this in the `setContent()` method allows us to decouple the
    actual implementations and allow us to reference each of them simply as a `Component`.
    The `setContent()` method will also prove useful shortly when we apply some formatting
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This is all still very basic, and if we were to create all our components like
    this, regardless of how they were grouped into compositions, the builder code
    would soon become very long-winded. The banner views we just created are unlikely
    to change, and so this system suits this setup. However, we will need to find
    a more flexible approach for more variable content, but before we do, we will
    see how to create composite versions of our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating composites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The true usefulness of the composite pattern lies in its ability to treat groups
    of objects as one, and our two header views offer a good opportunity to show how.
    Seeing as they always appear together, it makes perfect sense to treat them as
    one. There are three ways we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapt one of the existing leaf classes so it can create children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a composite with no parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a composite with a layout as parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see how to do all of these, but first we will implement the most efficient
    in this case and create a composite class based on one of our leaf classes. We
    want the image of our header above the text so will will use the `ImageLeaf` class
    as our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just three quick steps to this task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CompositeImage` class is identical to `ImageLeaf`, with the following
    exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Building this group in the builder is as simple as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now replace our calls in the activity too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This too can be treated exactly the same as all the other components, and making
    an equivalent text version would be very simple. Classes such as these can be
    seen as extensions of their leaf versions, and it was useful here, but it would
    be tidier to create a composite with no container, as this would enable us to
    organize groups that we can later insert into a layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class is a pared-down composite class that can be used to group
    any components, including other groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Imagine we want to group three images to be added later to a layout. The way
    the code stands, we would have to add these definitions during construction. This
    could result in some bulky and unattractive code. We will solve this here by simply
    adding methods to the builder that allow us to create components as we need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the builder to construct these groups like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This group can be inflated like any other component from the client and, because
    our layout has vertical orientation, will be displayed as a column. If we want
    them output in a row, we will need a horizontal orientation and therefore a class
    to generate one.
  prefs: []
  type: TYPE_NORMAL
- en: Create composite layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code for a composite component that will generate a linear layout
    as its root and place any added views inside itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to construct this in the builder is no different to the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now inflate our compositions with just a couple of clearly understandable
    lines of code in our activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting how we used the `setContent()` method of the composite layer
    to set the orientation. Looking at the overall structure, this is clearly the
    right place to do this and this brings us on to our next task, formatting our
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting layouts at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we now have the means to produce any number of complex layouts, a
    quick look at the following output demonstrates that in terms of appearance and
    design, we are still a long way from our desired design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting layouts at runtime](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We saw previously how we set an inserted layout''s orientation from its `setContent()`
    method and this is how we can take greater control over our components'' appearance.
    Taking this further it only takes a moment or two to produce an acceptable layout.
    Just follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by editing the `setContent()` method of the `TextLeaf`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will also require the following method for converting from px to dp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ImageLeaf` component just requires these changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also added one more construction to the builder, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can now be put into place with the follow lines in the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These adjustments should now produce a design along the lines of our original
    spec. Although we have added a lot of code and created specific Android objects,
    a look at the following diagram will demonstrate that the overall pattern remains
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting layouts at runtime](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a great deal more that we could do here, for example, tackling the
    issue of developing landscape layouts and scaling for different screen configurations,
    all of which could be managed simply using the same methodology. What we have
    done, however, is enough to demonstrate how to construct a layout dynamically
    at runtime using a composite pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to leave this pattern for now, as we explore how to provide a little
    customization functionality and consider user preferences and how we can store
    persistent data.
  prefs: []
  type: TYPE_NORMAL
- en: Storage options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly all apps have some form off **settings** menu that allow users to store
    regularly accessed information and customize the app to their own preferences.
    These settings can be anything from changing a password to personalizing the color
    scheme or any number of other tweaks and adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a lot of data and access to a web server, it is often best to cache
    data from this source, as this will both save battery and speed up the application.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we should consider how these setting can save our user time.
    No one wants to have to enter all their details every time they order a sandwich,
    nor do they want to have to construct the same sandwich over and over. This leads
    to the question of how we represent a sandwich across the system and how order
    information is sent to and received by the vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever technology we employ to transfer order data, we can assume at some
    point in the process there will be a human being making the actual sandwich. A
    simple text string would seem to be all we need, and it would certainly suffice
    as instructions for the vendor and to store user favorites. However, there is
    a valuable opportunity here that it would be foolish to miss. Every order that
    is placed contains valuable sales data and by collating these we can build up
    a picture of which products sell well and which don't. For this reason, we need
    to include as much data as we can in the order message. Purchase history can contain
    a lot of useful data, as can time and date of purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever supporting data we choose to collect, one thing that would be immensely
    useful would be to able to identify individual customers, but people do not like
    giving out personal information, and nor should they. There is no reason why someone
    would need to give out their date of birth or gender, simply to buy a sandwich.
    However, as we shall see, we can attach a unique identifier to each downloaded
    app and/or the device it is running on. Furthermore, there is no way that we,
    or anyone else, can identify individuals from this, and it is therefore no threat
    to their security or privacy, which it is vital that we protect.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways we can store data on a user's device so that properties
    persist across sessions. Usually, we will want this data kept private, and in
    the next section we will see how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Creating static files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our main focus in this part of the chapter will be the storage of user preferences.
    There are one or two other storage options we should take a look beforehand, starting
    with the device's internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the first half of the chapter, we assigned quite a long string using the
    `strings.xml` values file. This, and similar, resource files are best suited to
    storing individual words and short phrases, but form an unattractive method for
    storing long sentences or paragraphs. For these circumstances, we can use text
    files and store them in the `res/raw` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The handy thing about the `raw` directory is that it is compiled as part of
    the `R` class, which means its contents can be referenced in the same way as any
    other resource, such as a string or drawable, for example, `R.raw.some_text`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to include lengthy text without messing up the strings file, follow
    these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `res/raw` folder is not included by default, so begin by creating it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in this folder containing your text. Here, it is called `wiki`,
    as it is taken from the Wikipedia entry for sandwich.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your activity or whichever code you are using to inflate your layout and
    add this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now simply add these lines to populate your view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One of the nice things about the raw folder being treated like other resource
    directories is that we can create designated versions for different devices or
    locales. For example, here we have created a folder called `raw-es` and placed
    a Spanish translation of the text inside with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating static files](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using an external text editor, such as Notepad, you will need to
    ensure that the file is saved in `UTF-8` format for the non-Latin characters to
    display correctly.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of resource is very useful and very easy to implement, but such files
    are read-only, and there are bound to be times when we would like to create and
    edit this kind of file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing application files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is of course far more we can do here than store long strings conveniently,
    and being able to alter the content of such files at runtime gives us a lot of
    scope. If there weren't already such a a convenient method for storing user preferences,
    it would make a good candidate, and there are still times when the shared preferences
    structure is inadequate for all our needs. This constitutes one of the main reasons
    for using such files; the other is as a customization function, allowing users
    to make and store notes or bookmarks. Encoded text files can even be created to
    be understood by builders and used to rebuild sandwich objects containing the
    user's favorite ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we are about to explore uses an internal application directory that
    is hidden from other apps on the device. In the following exercise, we will demonstrate
    how users can store persistent and private text files using our app. Start a new
    project or open one that you wish to add internal storage functionality to and
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a simple layout. Base it on the following component tree:![Creating
    and editing application files](img/image_08_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For simplicity's sake, we will use the XML onClick property to assign code to
    each button using `android:onClick="loadFile"` and `android:onClick="saveFile"`
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, construct the `saveFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then make the `loadFile()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example is very simple, but it only needs to demonstrate the potential
    of being able to store data this way. Using the preceding layout, the code is
    easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and editing application files](img/image_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Storing user data, or data we want on the user, like this is very handy and
    very safe. We could always encrypt this data too, but that is a subject for another
    book. The Android framework is no more or less secure than any other mobile platform,
    and as we will not be storing anything more sensitive than preferences in sandwich
    fillings, this system will suit our purposes just fine.
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, also possible to create and access files on a device's external
    storage, such as a micro SD card. These files are public by default and are usually
    created when we want to share something with other apps. The process is similar
    to those we have just explored, and so we won't cover it here. Instead, we will
    get on with storing user preferences using the built in **SharedPreferences**
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Storing user preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already covered why being able to store user settings is so important,
    and we thought briefly about what settings we would like to store. Shared preferences
    use key-value pairs to store their data, and this is fine for values such as `name="desk"
    value="4"` but we want some quite detailed information about some things. For
    example, we want the user to be able to store their favorite sandwiches for easy
    recall.
  prefs: []
  type: TYPE_NORMAL
- en: The first step with this is to see how the Android shared preferences interface
    works generally and where it should be applied.
  prefs: []
  type: TYPE_NORMAL
- en: The activity life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing and retrieving user preferences using the **SharedPreferences** interface
    uses key-value pairs to store and retrieve primitive data types. This is very
    simple to apply, and the process only really gets interesting when we ask when
    and where we should perform these actions. This brings us to activity life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike desktop applications, mobile apps are not usually closed down deliberately
    by the user. Instead, they are generally navigated away from, often leaving them
    semi-active in the background. During runtime, an activity will enter a variety
    of states, such as paused, stopped, or resumed. Each of these states has an associated
    callback method, such as the `onCreate()` method that we are more than familiar
    with. There are several of these that we could use to save and load our user settings,
    and to decide which, we need to take a look at the life cycle itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The activity life cycle](img/image_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram can appear a little confusing, and the best way to see
    what happens when is to write a little debug code. Including `onCreate()`, there
    are seven callback methods that can be called during an activity''s life time:'
  prefs: []
  type: TYPE_NORMAL
- en: onCreate()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: onStart()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: onResume()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: onPause()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: onStop()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: onDestroy()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: onRestart()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At first, it might seem to make sense to save user settings from the `onDestroy()`
    method, as it is the last possible state. To see why this does not often work,
    open any project and override each of the methods in the preceding list and add
    some debug code, as seen in the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A few moments experimentation is enough to see that `onDestroy()` is not always
    called. To ensure our data get saved, we need to store our preferences from the
    `onPause()` or `onStop()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Applying preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how preferences are stored and retrieved, start a new project or open
    an existing one and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new class, `User`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create an XML layout to match this data based on the following preview:![Applying
    preferences](img/image_08_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the activity so that it implements the following listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the following fields and associate them with their XML counterparts
    in the usual manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the buttons locally in the `onCreate()` method and set their click listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following method and call it from within `onCreate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a method for storing the preferences like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `onPause()` method to call it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally add the click listener, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The load and preview functions have been added here simply to allow us to test
    our code, but as you can see, this process can be used to store and retrieve any
    amount of pertinent data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying preferences](img/image_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If for any reason you need to empty your preferences file, this can be done
    with the `edit.clear()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite possible to locate and look at our shared preferences thanks to
    the Android Device Monitor, which can be accessed through the **Tools | Android**
    menu. Open the **File explorer** and navigate to `data/data/com.your_app/shared_prefs/prefs.xml`.
    It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Despite its simplicity, shared preferences form an essential element of nearly
    all Android mobile apps, and as well as these obvious advantages, there is one
    other neat trick we can perform here. We can use the content of the shared preferences
    file to determine whether an app is being run for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a unique identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always a good idea when gathering sales data to have some means of identifying
    individual customers. This need not be by name or anything personal, a simple
    ID number can add a whole new dimension to a data set.
  prefs: []
  type: TYPE_NORMAL
- en: In many situations, we would use a simple incremental system and give each new
    customer a numerical ID with a value one higher than the last. This, of course,
    is impossible on a distributed system such as ours, as each installation has no
    idea how many others there might be. In an ideal world, we would persuade all
    our customers to register with us, perhaps with the offer of a free sandwich,
    but short of bribing our customers, there is another, rather clever technique
    for generating genuinely unique identifiers on distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: The **Universally Unique Identifier** (UUID) is a method of creating unique
    values that is available as a `java.util`. There are several versions, some of
    which are based on namespaces, which are unique identifiers in themselves. The
    version we use here (version 4) uses a random number generator. It might be tempting
    to think this might produce duplicates, but the way the identifier is constructed
    means that there would have to be a download every second for twenty billion years
    before there was a serious risk of duplication, so for the purposes of our sandwich
    vendor, this system is probably adequate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many other features we could use here, such as adding a hit counter
    to preferences and using it to count how many times our app has been accessed
    over how many sandwiches we have sold or keeping a total of monies spent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Welcoming a new user and adding an ID are things we only want to do the first
    time the application is run, so we will add both features at once. Here are the
    steps required to add welcome features and assign a unique user ID:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these two fields, setters, and getters to the `User` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this code to the `loadPrefs()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our app can now welcome and identify each and every user of our app. The beauty
    of using shared preferences to run code only the very first time an app is run,
    is that this method will ignore updates.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A somewhat simpler but less elegant solution to creating user IDs is to take
    the device''s serial number, which can be achieved with something like this: `user.setId(`
    **Build.SERIAL** `.toString())`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered two quite separate topics in this chapter and covered both theoretical
    and practical subject matter. The composite pattern is incredibly useful and we
    saw how it could easily be used in the stead of other patterns, such as the builder.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns are of no use if we do not have a handle on the more mechanical processes
    our software has to perform, such as file storage, and it should be clear that
    the list-like nature of data files, such as the shared preferences we worked with
    earlier, would be well-suited to builder patterns, and more complex data structures
    could be handled with composites.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at more non-immediate structures as we explore
    how to create services and post notifications to users when our application is
    not currently active. This will introduce observer patterns, which you will no
    doubt have encountered, in the form of listener methods.
  prefs: []
  type: TYPE_NORMAL
