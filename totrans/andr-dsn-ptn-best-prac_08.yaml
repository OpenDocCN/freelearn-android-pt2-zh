- en: Chapter 8. Composing Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章. 组合模式
- en: We have seen how patterns can be used to manipulate, organize, and present data,
    but this data has been fleeting, and we have not yet considered how to ensure
    data persists from one session to the next. In this chapter, we will look at how
    this is done using internal data storage mechanisms. In particular, we will explore
    how users can save their preferences, making the app simpler and more fun to use.
    Before we do this, we will begin the chapter by examining the composite pattern
    and its uses, particularly when it comes to constructing hierarchical structures
    such as Android UIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用模式来操作、组织和呈现数据，但这些数据是短暂的，我们还没有考虑如何确保数据从一个会话持续到下一个会话。在本章中，我们将探讨如何使用内部数据存储机制来实现这一点。特别是，我们将探索用户如何保存他们的偏好设置，使应用程序更简单、更有趣。在我们开始之前，本章将首先检查组合模式及其用途，尤其是在构建类似于Android
    UIs这样的层次结构时。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何做到以下几点：
- en: Construct a composite pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建组合模式
- en: Create a layout with composer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合器创建布局
- en: Use static files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态文件
- en: Edit application files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑应用程序文件
- en: Store user preferences
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用户偏好
- en: Understand the activity life cycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解活动生命周期
- en: Add unique identifiers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加唯一标识符
- en: One of the most immediate ways we can apply design patterns to an Android project
    is layout inflation, and back in [Chapter 6](ch06.html "Chapter 6. Activating
    Patterns"), *Activating Patterns*, we used a builder pattern to inflate a simple
    layout. This example had some serious shortcomings. It only handled text views
    and did not cater for nested layouts. For dynamic layout inflation to be of real
    use to us, we need to be able to include any type of widget or view at any level
    of the layout hierarchy, and this is where the composite design pattern comes
    in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将设计模式应用于Android项目的一个最直接的方法是布局膨胀，在[第6章](ch06.html "第6章. 激活模式")《激活模式》中，我们使用了一个构建器模式来膨胀一个简单的布局。这个例子有一些严重的不足之处。它只处理文本视图，并没有考虑嵌套布局。为了使动态布局膨胀对我们真正有用，我们需要能够在布局层次的任何级别上包含任何类型的控件或视图，这正是组合设计模式发挥作用的地方。
- en: The composite pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: At first glance, the composite pattern might seem very similar to the builder
    pattern, as both build complex objects out of smaller ones. There is, however,
    a significant difference in the approach these patterns take. Builders work in
    a very linear fashion, adding objects one at a time. The composite pattern, on
    the other hand, can add groups of objects as well as individual ones. More importantly,
    it does so in such a way that the client can add individual objects or groups
    of objects without having to concern itself with which it is dealing with. In
    other words, we can add completed layouts, individual views, or groups of views
    with exactly the same code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，组合模式可能与构建器模式非常相似，因为它们都从小型组件构建复杂对象。然而，这些模式在方法上有一个显著的区别。构建器以非常线性的方式工作，一次添加一个对象。而组合模式可以添加对象组以及单个对象。更重要的是，它以这样的方式添加，即客户端可以添加单个对象或对象组，而无需关心它正在处理哪个。换句话说，我们可以使用完全相同的代码添加完成的布局、单个视图或视图组。
- en: Along with the ability to compose branching data structures, the ability to
    hide from the client the details of the objects being manipulated is what makes
    the composer pattern so powerful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够组合分支数据结构的能力之外，隐藏客户端正在操作的对象的细节是使组合器模式如此强大的原因。
- en: Before creating a layout composer, we will take a look at the pattern itself,
    applied to a very simple model, so that we can appreciate the workings of the
    pattern better. Here is the overall structure. As you can see, it is very simple
    conceptually.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建布局组合器之前，我们将先看看这个模式本身，应用于一个非常简单的模型，以便我们更好地理解模式的工作原理。这就是整体结构。如您所见，它在概念上非常简单。
- en: 'Follow these steps to construct our composite pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的组合模式：
- en: 'Start with an interface that can represent both individual components and collections
    of components, like so:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个接口开始，该接口可以表示单个组件和组件集合，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add this class to extend the interface for individual components:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这个类以扩展单个组件的接口：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then add the class for collections:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来为集合添加类：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see here, this pattern is very simple, yet very effective:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这里看到的，这个模式非常简单，但非常有效：
- en: '![The composite pattern](img/image_08_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![组合模式](img/image_08_001.jpg)'
- en: 'To see it in action, we need to define some components and composites. We can
    define components with lines like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际效果，我们需要定义一些组件和组合。我们可以使用如下这样的代码行来定义组件：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can create composite collections with the `add()` method like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `add()` 方法创建组合集合，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Nesting compositions within each other is just as simple because we have written
    the code so that we can disregard whether we are creating a `Leaf` or a `Composite`
    and use the same code for either. Here''s an example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在彼此内部嵌套组合同样简单，因为我们编写的代码使得我们可以忽略我们是创建 `Leaf` 还是 `Composite`，并为两者使用相同的代码。以下是一个示例：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Displaying a component, which is simply text in this case, is as easy as calling
    its `inflate()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个组件，在这个例子中它仅仅是一段文本，只需调用其 `inflate()` 方法即可。
- en: Adding a builder
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加构建器
- en: 'Defining and printing a fair selection of outputs would make for considerably
    cluttered client code, and the solution we will adopt here is to steal an idea
    from another pattern and employ a single builder class to do the work of constructing
    our desired compositions. These could be anything we like, and here is one possible
    builder:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 定义并打印出一系列输出的公平选择将导致客户端代码相当混乱，我们将在这里采用的方法是从另一个模式中借鉴一个想法，并使用一个构建器类来完成构建我们所需组合的工作。这些可以是任何我们喜欢的内容，以下是一个可能的构建器：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This leaves the `onCreate()` method of our activity clean and simple to follow,
    as you can see here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的活动的 `onCreate()` 方法保持清晰简洁，正如您在这里看到的：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although we have only produced a basic output, it should be clear how we can
    now extend this to inflating real layouts and how useful this technique can be.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只生成了一个基本的输出，但应该清楚我们现在如何将其扩展到充气实际布局，以及这项技术可能有多么有用。
- en: A Layout composer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局构建器
- en: In [Chapter 6](ch06.html "Chapter 6. Activating Patterns"), *Activating Patterns*,
    we used a builder to construct a simple UI. The builder was a perfect choice for
    this task, as we were only concerned with including one type of view. We could
    have adapted this scheme (literally, with an adapter) to cater for other view
    types, but it would be far better to employ a pattern that does not care what
    type of component it is dealing with. Hopefully, the preceding example demonstrates
    the composite pattern's suitability to this kind of task.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章.激活模式")《激活模式》中，我们使用构建器构建了一个简单的UI。构建器是这项任务的完美选择，因为我们只关心包含一种类型的视图。我们可以通过适配器（字面上）来调整这个方案以适应其他视图类型，但最好使用一种不关心它正在处理哪种类型组件的模式。希望前面的示例展示了组合模式适合这类任务。
- en: In the following example, we will apply the same principle to an actual UI inflater
    that works with different types of view, composite groups of views and, most significantly,
    dynamic nested layouts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将同样的原则应用于一个实际的UI充气器，它处理不同类型的视图，视图组合群以及最重要的动态嵌套布局。
- en: For the purpose of this exercise, we will suppose that our app has a news page.
    This would largely be a promotional feature, but it has been demonstrated that
    consumers are more susceptible to advertising when it is dressed up as news. Many
    of the components, such as header and logo, will remain static, while others will
    change frequently in both content and layout structure. This makes it an ideal
    subject for our composer pattern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习的目的，我们将假设我们的应用程序有一个新闻页面。这主要是一个促销特性，但已经证明，当广告装扮成新闻时，消费者更容易接受广告。许多组件，如标题和标志，将保持静态，而其他组件将频繁更改内容和布局结构。这使得它成为我们组合模式的理想主题。
- en: 'Here is the UI we will be developing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要开发的UI：
- en: '![A Layout composer](img/image_08_002.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![布局构建器](img/image_08_002.jpg)'
- en: Adding components
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加组件
- en: 'We will approach each problem individually, building the code as we go. First,
    we will tackle the issue of creating and displaying a single component view by
    following these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个解决问题，一边构建代码。首先，我们将按照以下步骤解决创建和显示单个组件视图的问题：
- en: 'As before, we start with the `Component` interface:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，我们从 `Component` 接口开始：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now implement this with the following class:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下类来实现这一点：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add the `Builder`, which, for now, is remarkably simple, containing only
    two properties and a constructor:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `Builder`，目前它非常简单，只包含两个属性和构造函数：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, edit the `onCreate()` method of the activity to use our own layout
    as the root and add our view to it, like this:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑活动的 `onCreate()` 方法，使用我们自己的布局作为根布局，并添加我们的视图，如下所示：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As it stands, there is nothing impressive about what we have done here, but
    having worked through the previous example, it will be clear where we are going
    with this, and our next step is to create a component that will handle image views.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们所做的工作并不令人印象深刻，但通过之前例子的演练，我们会很清楚接下来要做什么，下一步是创建一个处理图像视图的组件。
- en: 'As you can see in the following snippet, the `ImageLeaf` class is almost identical
    to its textual sibling, differing only in the view type it generates and the use
    of `setImageResource()` to operate on the `id` argument:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码段所示，`ImageLeaf`类几乎与其文本兄弟类相同，唯一的区别在于它生成的视图类型以及使用`setImageResource()`操作`id`参数：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This can be easily added to the builder in the same way as the text view, although
    now we will create a small method for this and call it from the constructor, as
    we may want to add a number of others. The code should now look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以像文本视图一样轻松地添加到构建器中，但现在我们将为此创建一个小方法，并在构造函数中调用它，因为我们可能想要添加许多其他内容。现在代码应该看起来像这样：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As intended, as far as the client code is concerned, there is no difference
    between this and any other component, and it can be inflated with this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，对于客户端代码来说，这与任何其他组件没有区别，可以使用以下方式来填充它：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Image views and text views can both take their respective primary contents (image
    and text) as resource ID integers and so we can use the same `int` parameter for
    both. Dealing with this in the `setContent()` method allows us to decouple the
    actual implementations and allow us to reference each of them simply as a `Component`.
    The `setContent()` method will also prove useful shortly when we apply some formatting
    attributes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图像视图和文本视图都可以将它们的主要内容（图像和文本）作为资源ID整数，因此我们可以为两者使用相同的`int`参数。在`setContent()`方法中处理这一点可以让我们解耦实际的实现，并允许我们简单地将它们每个都作为`Component`引用。当我们应用一些格式化属性时，`setContent()`方法也会很快证明其有用。
- en: This is all still very basic, and if we were to create all our components like
    this, regardless of how they were grouped into compositions, the builder code
    would soon become very long-winded. The banner views we just created are unlikely
    to change, and so this system suits this setup. However, we will need to find
    a more flexible approach for more variable content, but before we do, we will
    see how to create composite versions of our classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然非常基础，如果我们像这样创建所有组件，无论它们如何组合在一起，构建器代码很快就会变得非常冗长。我们刚刚创建的横幅视图不太可能改变，所以这个系统适合这种设置。然而，对于更易变的内容，我们将需要找到一种更灵活的方法，但在我们这样做之前，我们将了解如何创建我们类的组合版本。
- en: Creating composites
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组合组件
- en: 'The true usefulness of the composite pattern lies in its ability to treat groups
    of objects as one, and our two header views offer a good opportunity to show how.
    Seeing as they always appear together, it makes perfect sense to treat them as
    one. There are three ways we can do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 复合模式的真正价值在于其将一组对象视为一个的能力，我们的两个头部视图提供了一个很好的机会来展示如何做到这一点。由于它们总是同时出现，将它们视为一个是有道理的。我们可以通过以下三种方式做到这一点：
- en: Adapt one of the existing leaf classes so it can create children
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整其中一个现有的叶类，使其能够创建子项
- en: Create a composite with no parent
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个没有父级的组合
- en: Create a composite with a layout as parent
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个以布局为父级的组合
- en: We will see how to do all of these, but first we will implement the most efficient
    in this case and create a composite class based on one of our leaf classes. We
    want the image of our header above the text so will will use the `ImageLeaf` class
    as our template.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何完成所有这些工作，但首先我们将在这种情况下实现最高效的方法，基于我们其中一个叶类创建一个组合类。我们希望标题图像在文本上方，因此我们将使用`ImageLeaf`类作为模板。
- en: 'There are just three quick steps to this task:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这项任务只需三个简单步骤：
- en: 'The `CompositeImage` class is identical to `ImageLeaf`, with the following
    exceptions:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompositeImage`类与`ImageLeaf`完全相同，除了以下例外：'
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Building this group in the builder is as simple as this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建器中构建这个组就像这样简单：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now replace our calls in the activity too:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们也可以替换活动中的调用：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This too can be treated exactly the same as all the other components, and making
    an equivalent text version would be very simple. Classes such as these can be
    seen as extensions of their leaf versions, and it was useful here, but it would
    be tidier to create a composite with no container, as this would enable us to
    organize groups that we can later insert into a layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以像所有其他组件一样处理，制作一个等效的文本版本会非常简单。这些类可以看作是它们叶节点版本的扩展，在这里很有用，但创建一个没有容器的复合组件会更整洁，这将使我们能够组织可以在稍后插入到布局中的组。
- en: 'The following class is a pared-down composite class that can be used to group
    any components, including other groups:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类是一个精简的复合类，可用于组合任何组件，包括其他组：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Imagine we want to group three images to be added later to a layout. The way
    the code stands, we would have to add these definitions during construction. This
    could result in some bulky and unattractive code. We will solve this here by simply
    adding methods to the builder that allow us to create components as we need them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将三个图像组合在一起，以便稍后添加到布局中。按照当前的代码，我们不得不在构建时添加这些定义。这可能导致代码庞大且不美观。我们将通过为构建器添加方法来解决这一问题，使我们能够按需创建组件。
- en: 'These two methods are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法如下：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use the builder to construct these groups like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用构建器像这样构建这些组：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This group can be inflated like any other component from the client and, because
    our layout has vertical orientation, will be displayed as a column. If we want
    them output in a row, we will need a horizontal orientation and therefore a class
    to generate one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组可以像其他任何组件一样从客户端处进行填充，因为我们的布局具有垂直方向，所以将显示为列。如果我们希望它们以行输出，我们将需要水平方向，因此需要生成一个类。
- en: Create composite layouts
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建复合布局
- en: 'Here is the code for a composite component that will generate a linear layout
    as its root and place any added views inside itself:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复合组件的代码，它将生成线性布局作为其根布局，并将任何添加的视图放置在其中：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The code to construct this in the builder is no different to the others:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建器中构建此类的代码与其他代码没有区别：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now inflate our compositions with just a couple of clearly understandable
    lines of code in our activity:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过在活动中编写少量清晰易懂的代码来填充我们的组合：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is worth noting how we used the `setContent()` method of the composite layer
    to set the orientation. Looking at the overall structure, this is clearly the
    right place to do this and this brings us on to our next task, formatting our
    UI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们是如何使用复合层的`setContent()`方法来设置方向的。从整体结构来看，这显然是正确的位置，这也引出了我们的下一个任务，格式化用户界面。
- en: Formatting layouts at runtime
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时格式化布局
- en: 'Although we now have the means to produce any number of complex layouts, a
    quick look at the following output demonstrates that in terms of appearance and
    design, we are still a long way from our desired design:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在有能力生成任意数量的复杂布局，但快速查看以下输出可以看出，在外观和设计方面，我们距离理想的设计还有很长的路要走：
- en: '![Formatting layouts at runtime](img/image_08_003.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![运行时格式化布局](img/image_08_003.jpg)'
- en: 'We saw previously how we set an inserted layout''s orientation from its `setContent()`
    method and this is how we can take greater control over our components'' appearance.
    Taking this further it only takes a moment or two to produce an acceptable layout.
    Just follow these simple steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到过如何通过其`setContent()`方法设置插入布局的方向，这样我们就可以更控制组件的外观。进一步这样做只需一两分钟就能产生一个可接受的布局。只需遵循以下简单步骤：
- en: 'Begin by editing the `setContent()` method of the `TextLeaf`, like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑`TextLeaf`的`setContent()`方法，如下所示：
- en: '[PRE25]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will also require the following method for converting from px to dp:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这还需要以下将px转换为dp的方法：
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `ImageLeaf` component just requires these changes:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ImageLeaf`组件只需要这些更改：'
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also added one more construction to the builder, like so:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为构建器添加了更多的构造，如下所示：
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This can now be put into place with the follow lines in the activity:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过在活动中添加以下几行代码来实现：
- en: '[PRE29]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These adjustments should now produce a design along the lines of our original
    spec. Although we have added a lot of code and created specific Android objects,
    a look at the following diagram will demonstrate that the overall pattern remains
    the same:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调整现在应该能产生符合我们原始规格的设计。尽管我们添加了大量代码并创建了特定的Android对象，但查看以下图表将显示整体模式保持不变：
- en: '![Formatting layouts at runtime](img/image_08_004.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![运行时格式化布局](img/image_08_004.jpg)'
- en: There is a great deal more that we could do here, for example, tackling the
    issue of developing landscape layouts and scaling for different screen configurations,
    all of which could be managed simply using the same methodology. What we have
    done, however, is enough to demonstrate how to construct a layout dynamically
    at runtime using a composite pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里还可以做更多的事情，例如，处理开发横屏布局和针对不同屏幕配置的缩放问题，所有这些都可以使用相同的方法简单地管理。然而，我们已经做得足够了，可以展示如何使用组合模式在运行时动态构建布局。
- en: We are going to leave this pattern for now, as we explore how to provide a little
    customization functionality and consider user preferences and how we can store
    persistent data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将暂时放弃这种模式，去探索如何提供一些定制功能，并考虑用户偏好以及我们如何存储持久数据。
- en: Storage options
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储选项
- en: Nearly all apps have some form off **settings** menu that allow users to store
    regularly accessed information and customize the app to their own preferences.
    These settings can be anything from changing a password to personalizing the color
    scheme or any number of other tweaks and adjustments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的应用程序都有某种形式的**设置**菜单，允许用户存储经常访问的信息，并根据个人偏好定制应用程序。这些设置可以是更改密码、个性化颜色方案，或者是许多其他的调整和修改。
- en: If you have a lot of data and access to a web server, it is often best to cache
    data from this source, as this will both save battery and speed up the application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有大量数据并且可以访问网络服务器，通常最好是从这个来源缓存数据，这将节省电池消耗并加快应用程序的运行速度。
- en: First and foremost, we should consider how these setting can save our user time.
    No one wants to have to enter all their details every time they order a sandwich,
    nor do they want to have to construct the same sandwich over and over. This leads
    to the question of how we represent a sandwich across the system and how order
    information is sent to and received by the vendor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们应该考虑这些设置如何为用户节省时间。没有人希望在每次订购三明治时都输入所有详细信息，也不希望一次又一次地构建同一个三明治。这引出了一个问题，即我们如何在系统中表示三明治，以及如何将订单信息发送给供应商并接收。
- en: Whatever technology we employ to transfer order data, we can assume at some
    point in the process there will be a human being making the actual sandwich. A
    simple text string would seem to be all we need, and it would certainly suffice
    as instructions for the vendor and to store user favorites. However, there is
    a valuable opportunity here that it would be foolish to miss. Every order that
    is placed contains valuable sales data and by collating these we can build up
    a picture of which products sell well and which don't. For this reason, we need
    to include as much data as we can in the order message. Purchase history can contain
    a lot of useful data, as can time and date of purchase.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们采用哪种技术来传输订单数据，我们都可以假设在这个过程中某个时刻会有一个人类实际制作三明治。一个简单的文本字符串似乎是我们所需要的全部，它当然足以作为供应商的指令以及存储用户喜好。然而，这里有一个宝贵的机会，错过它将是愚蠢的。每个放置的订单都包含有价值的销售数据，通过汇总这些数据，我们可以了解哪些产品卖得好，哪些不好。因此，我们需要在订单信息中尽可能多地包含数据。购买历史可以包含许多有用的数据，购买的时间和日期也是如此。
- en: Whatever supporting data we choose to collect, one thing that would be immensely
    useful would be to able to identify individual customers, but people do not like
    giving out personal information, and nor should they. There is no reason why someone
    would need to give out their date of birth or gender, simply to buy a sandwich.
    However, as we shall see, we can attach a unique identifier to each downloaded
    app and/or the device it is running on. Furthermore, there is no way that we,
    or anyone else, can identify individuals from this, and it is therefore no threat
    to their security or privacy, which it is vital that we protect.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择收集哪些支持数据，有一件事将非常有用，那就是能够识别单个客户，但人们不喜欢透露个人信息，他们也不应该透露。没有理由为了买一个三明治而需要提供出生日期或性别。然而，正如我们将会看到的，我们可以为每个下载的应用程序和/或运行它的设备附加一个唯一的标识符。此外，我们或其他人无法从这些信息中识别个人，因此这对他们的安全或隐私没有威胁，保护这些是至关重要的。
- en: There are several ways we can store data on a user's device so that properties
    persist across sessions. Usually, we will want this data kept private, and in
    the next section we will see how this can be achieved.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以在用户的设备上存储数据，以便属性在会话之间持久化。通常，我们希望这些数据保持私密，在下一节中，我们将了解如何实现这一点。
- en: Creating static files
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建静态文件
- en: Our main focus in this part of the chapter will be the storage of user preferences.
    There are one or two other storage options we should take a look beforehand, starting
    with the device's internal storage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们的主要关注点是存储用户偏好。在开始之前，我们应该看看一两个其他的存储选项，首先从设备的内部存储开始。
- en: In the first half of the chapter, we assigned quite a long string using the
    `strings.xml` values file. This, and similar, resource files are best suited to
    storing individual words and short phrases, but form an unattractive method for
    storing long sentences or paragraphs. For these circumstances, we can use text
    files and store them in the `res/raw` directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前半部分，我们使用了`strings.xml`值文件分配了一个相当长的字符串。这类资源文件最适合存储单个单词和短句，但用于存储长句或段落则显得不太吸引人。在这种情况下，我们可以使用文本文件，并将其存储在`res/raw`目录中。
- en: The handy thing about the `raw` directory is that it is compiled as part of
    the `R` class, which means its contents can be referenced in the same way as any
    other resource, such as a string or drawable, for example, `R.raw.some_text`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`raw`目录的方便之处在于，它作为`R`类的一部分被编译，这意味着它的内容可以像引用任何其他资源（如字符串或可绘制资源）一样引用，例如`R.raw.some_text`。'
- en: 'To see how to include lengthy text without messing up the strings file, follow
    these simple steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在不弄乱字符串文件的情况下包含长文本，请按照以下简单步骤操作：
- en: The `res/raw` folder is not included by default, so begin by creating it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下不包含`res/raw`文件夹，因此首先创建它。
- en: Create a new file in this folder containing your text. Here, it is called `wiki`,
    as it is taken from the Wikipedia entry for sandwich.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中创建一个包含你文本的新文件。这里，它被称为`wiki`，因为它取自三明治的维基百科条目。
- en: 'Open your activity or whichever code you are using to inflate your layout and
    add this method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的活动或你用来填充布局的任何代码，并添加这个方法：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now simply add these lines to populate your view.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需添加这些行来填充你的视图。
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One of the nice things about the raw folder being treated like other resource
    directories is that we can create designated versions for different devices or
    locales. For example, here we have created a folder called `raw-es` and placed
    a Spanish translation of the text inside with the same name:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始文件夹像其他资源目录一样处理的好处之一是，我们可以为不同的设备或地区创建指定的版本。例如，这里我们创建了一个名为`raw-es`的文件夹，并在其中放入了相同名称的西班牙语文本翻译：
- en: '![Creating static files](img/image_08_005.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建静态文件](img/image_08_005.jpg)'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using an external text editor, such as Notepad, you will need to
    ensure that the file is saved in `UTF-8` format for the non-Latin characters to
    display correctly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是外部文本编辑器，如记事本，你将需要确保文件以`UTF-8`格式保存，以便非拉丁字符能正确显示。
- en: This kind of resource is very useful and very easy to implement, but such files
    are read-only, and there are bound to be times when we would like to create and
    edit this kind of file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种资源非常有用，而且非常容易实现，但这种文件是只读的，肯定会有我们想要创建和编辑这类文件的时候。
- en: Creating and editing application files
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和编辑应用程序文件
- en: There is of course far more we can do here than store long strings conveniently,
    and being able to alter the content of such files at runtime gives us a lot of
    scope. If there weren't already such a a convenient method for storing user preferences,
    it would make a good candidate, and there are still times when the shared preferences
    structure is inadequate for all our needs. This constitutes one of the main reasons
    for using such files; the other is as a customization function, allowing users
    to make and store notes or bookmarks. Encoded text files can even be created to
    be understood by builders and used to rebuild sandwich objects containing the
    user's favorite ingredients.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这里我们能做的远不止方便地存储长字符串，而且能够在运行时更改这些文件的内容为我们提供了很大的范围。如果没有已经存在的用于存储用户偏好的方便方法，这将是一个很好的选择，而且有时共享偏好结构仍不足以满足我们所有的需求。这是使用这类文件的主要原因之一；另一个是作为定制功能，允许用户制作和存储笔记或书签。编码的文本文件甚至可以被创建者理解并用于重建包含用户喜欢的成分的三明治对象。
- en: 'The method we are about to explore uses an internal application directory that
    is hidden from other apps on the device. In the following exercise, we will demonstrate
    how users can store persistent and private text files using our app. Start a new
    project or open one that you wish to add internal storage functionality to and
    follow these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将探讨的方法使用了一个内部应用目录，这个目录对设备上的其他应用是隐藏的。在下面的练习中，我们将展示用户如何使用我们的应用存储持久且私密的文本文件。启动一个新项目或打开一个你希望添加内部存储功能的项目，然后按照以下步骤操作：
- en: Start by creating a simple layout. Base it on the following component tree:![Creating
    and editing application files](img/image_08_006.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建一个简单的布局开始。基于以下组件树进行设计：![创建和编辑应用文件](img/image_08_006.jpg)
- en: For simplicity's sake, we will use the XML onClick property to assign code to
    each button using `android:onClick="loadFile"` and `android:onClick="saveFile"`
    respectively.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将使用XML的onClick属性，分别为每个按钮指定代码，使用`android:onClick="loadFile"`和`android:onClick="saveFile"`。
- en: 'First, construct the `saveFile()` method:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建`saveFile()`方法：
- en: '[PRE32]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then make the `loadFile()` method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后制作`loadFile()`方法：
- en: '[PRE33]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example is very simple, but it only needs to demonstrate the potential
    of being able to store data this way. Using the preceding layout, the code is
    easy to test.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常简单，但它只需要展示以这种方式存储数据的潜力。使用前面的布局，代码很容易测试。
- en: '![Creating and editing application files](img/image_08_007.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![创建和编辑应用文件](img/image_08_007.jpg)'
- en: Storing user data, or data we want on the user, like this is very handy and
    very safe. We could always encrypt this data too, but that is a subject for another
    book. The Android framework is no more or less secure than any other mobile platform,
    and as we will not be storing anything more sensitive than preferences in sandwich
    fillings, this system will suit our purposes just fine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 存储用户数据，或我们想要了解的用户数据，这种方式非常方便且安全。我们当然也可以加密这些数据，但这不是本书讨论的内容。Android框架与其他移动平台相比，安全性并没有更高或更低，由于我们不会存储比偏好设置更敏感的信息，这个系统将完全满足我们的需求。
- en: It is, of course, also possible to create and access files on a device's external
    storage, such as a micro SD card. These files are public by default and are usually
    created when we want to share something with other apps. The process is similar
    to those we have just explored, and so we won't cover it here. Instead, we will
    get on with storing user preferences using the built in **SharedPreferences**
    interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以在设备的外部存储上创建和访问文件，比如微型SD卡。这些文件默认是公开的，通常在我们需要与其他应用共享内容时创建。这个过程与我们刚才探讨的类似，因此这里不再赘述。相反，我们将继续使用内置的**SharedPreferences**接口存储用户偏好设置。
- en: Storing user preferences
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储用户偏好设置
- en: We have already covered why being able to store user settings is so important,
    and we thought briefly about what settings we would like to store. Shared preferences
    use key-value pairs to store their data, and this is fine for values such as `name="desk"
    value="4"` but we want some quite detailed information about some things. For
    example, we want the user to be able to store their favorite sandwiches for easy
    recall.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过能够存储用户设置的重要性，并简要思考了我们想要存储的设置。共享偏好设置使用键值对来存储数据，这对于像`name="desk" value="4"`这样的值是合适的，但我们想要存储一些更详细的信息。例如，我们希望用户能够轻松地存储他们最喜欢的三明治以便快速回忆。
- en: The first step with this is to see how the Android shared preferences interface
    works generally and where it should be applied.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一步是了解Android共享偏好设置接口通常如何工作以及应该在何处应用它。
- en: The activity life cycle
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动生命周期
- en: Storing and retrieving user preferences using the **SharedPreferences** interface
    uses key-value pairs to store and retrieve primitive data types. This is very
    simple to apply, and the process only really gets interesting when we ask when
    and where we should perform these actions. This brings us to activity life cycles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**SharedPreferences**接口存储和检索用户偏好设置时，使用键值对来存储和检索基本数据类型。应用这一点非常简单，当询问何时何地执行这些操作时，这个过程才真正变得有趣。这就引出了活动生命周期的话题。
- en: 'Unlike desktop applications, mobile apps are not usually closed down deliberately
    by the user. Instead, they are generally navigated away from, often leaving them
    semi-active in the background. During runtime, an activity will enter a variety
    of states, such as paused, stopped, or resumed. Each of these states has an associated
    callback method, such as the `onCreate()` method that we are more than familiar
    with. There are several of these that we could use to save and load our user settings,
    and to decide which, we need to take a look at the life cycle itself:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面应用程序不同，移动应用通常不是被用户故意关闭的。相反，它们通常是被导航离开，经常在后台保持半活动状态。在运行时，一个活动将进入各种状态，如暂停、停止或恢复。这些状态每个都有一个关联的回调方法，比如我们非常熟悉的`onCreate()`方法。我们可以使用其中几个来保存和加载用户设置，为了决定使用哪个，我们需要查看生命周期本身：
- en: '![The activity life cycle](img/image_08_008.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![活动生命周期](img/image_08_008.jpg)'
- en: 'The preceding diagram can appear a little confusing, and the best way to see
    what happens when is to write a little debug code. Including `onCreate()`, there
    are seven callback methods that can be called during an activity''s life time:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表可能有些令人困惑，要了解何时发生什么，编写一些调试代码是最佳方式。包括`onCreate()`在内，在活动的生命周期期间可能会调用七个回调方法：
- en: onCreate()
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onCreate()
- en: onStart()
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onStart()
- en: onResume()
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onResume()
- en: onPause()
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onPause()
- en: onStop()
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onStop()
- en: onDestroy()
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onDestroy()
- en: onRestart()
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: onRestart()
- en: 'At first, it might seem to make sense to save user settings from the `onDestroy()`
    method, as it is the last possible state. To see why this does not often work,
    open any project and override each of the methods in the preceding list and add
    some debug code, as seen in the example here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，从`onDestroy()`方法保存用户设置似乎是有道理的，因为它是最后一个可能的状态。要了解为什么这通常不起作用，打开任何项目并覆盖前面列表中的每个方法，并添加一些调试代码，如这里的示例所示：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A few moments experimentation is enough to see that `onDestroy()` is not always
    called. To ensure our data get saved, we need to store our preferences from the
    `onPause()` or `onStop()` methods.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 稍作实验即可发现`onDestroy()`并不总是被调用。为了确保我们的数据得到保存，我们需要从`onPause()`或`onStop()`方法中存储我们的偏好设置。
- en: Applying preferences
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用偏好设置
- en: 'To see how preferences are stored and retrieved, start a new project or open
    an existing one and follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解偏好设置的存储和检索方式，请启动一个新项目或打开一个现有项目，并按照以下步骤操作：
- en: 'First, create a new class, `User`, like so:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`User`的新类，如下所示：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, create an XML layout to match this data based on the following preview:![Applying
    preferences](img/image_08_009.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据以下预览创建一个 XML 布局以匹配这些数据：![应用偏好设置](img/image_08_009.jpg)
- en: Modify the activity so that it implements the following listener.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改活动，使其实现以下监听器。
- en: '[PRE36]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Include the following fields and associate them with their XML counterparts
    in the usual manner:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照通常的方式包含以下字段，并将它们与它们的 XML 对应项相关联：
- en: '[PRE37]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the buttons locally in the `onCreate()` method and set their click listeners:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中本地添加按钮，并设置它们的点击监听器：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the following method and call it from within `onCreate()`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下方法，并在`onCreate()`内部调用它：
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a method for storing the preferences like this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个如下所示的方法来存储偏好设置：
- en: '[PRE40]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the `onPause()` method to call it:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`onPause()`方法以调用它：
- en: '[PRE41]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally add the click listener, like so:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像这样添加点击监听器：
- en: '[PRE42]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The load and preview functions have been added here simply to allow us to test
    our code, but as you can see, this process can be used to store and retrieve any
    amount of pertinent data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里添加了加载和预览功能，仅仅是为了让我们测试代码，但正如你所见，这个过程可以用来存储和检索任何数量的相关信息：
- en: '![Applying preferences](img/image_08_010.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![应用偏好设置](img/image_08_010.jpg)'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If for any reason you need to empty your preferences file, this can be done
    with the `edit.clear()` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要清空偏好设置文件，可以使用`edit.clear()`方法。
- en: 'It is quite possible to locate and look at our shared preferences thanks to
    the Android Device Monitor, which can be accessed through the **Tools | Android**
    menu. Open the **File explorer** and navigate to `data/data/com.your_app/shared_prefs/prefs.xml`.
    It should look something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**工具 | 安卓**菜单访问的 Android 设备监视器，可以很容易地找到并查看我们的共享偏好设置。打开**文件浏览器**，导航到`data/data/com.your_app/shared_prefs/prefs.xml`。它应该看起来像这样：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Despite its simplicity, shared preferences form an essential element of nearly
    all Android mobile apps, and as well as these obvious advantages, there is one
    other neat trick we can perform here. We can use the content of the shared preferences
    file to determine whether an app is being run for the first time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管共享偏好设置很简单，但它几乎是所有Android移动应用程序不可或缺的元素，除了这些明显的优势之外，我们还可以在这里执行一个很酷的技巧。我们可以使用共享偏好设置文件的内容来确定应用程序是否是第一次运行。
- en: Adding a unique identifier
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加唯一标识符
- en: It is always a good idea when gathering sales data to have some means of identifying
    individual customers. This need not be by name or anything personal, a simple
    ID number can add a whole new dimension to a data set.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集销售数据时，有一个方法来识别单个客户总是一个好主意。这不必是姓名或任何个人信息，一个简单的ID号码可以为数据集增加一个全新的维度。
- en: In many situations, we would use a simple incremental system and give each new
    customer a numerical ID with a value one higher than the last. This, of course,
    is impossible on a distributed system such as ours, as each installation has no
    idea how many others there might be. In an ideal world, we would persuade all
    our customers to register with us, perhaps with the offer of a free sandwich,
    but short of bribing our customers, there is another, rather clever technique
    for generating genuinely unique identifiers on distributed systems.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们会使用简单的递增系统，并为每位新客户分配一个比上一个值高一位的数字ID。当然，在像我们这样的分布式系统中这是不可能的，因为每个安装实例都无法了解可能存在的其他实例数量。在理想情况下，我们会说服所有客户向我们注册，或许通过提供免费三明治的优惠，但除了贿赂客户之外，还有一种相当聪明的技术可以在分布式系统上生成真正唯一的标识符。
- en: The **Universally Unique Identifier** (UUID) is a method of creating unique
    values that is available as a `java.util`. There are several versions, some of
    which are based on namespaces, which are unique identifiers in themselves. The
    version we use here (version 4) uses a random number generator. It might be tempting
    to think this might produce duplicates, but the way the identifier is constructed
    means that there would have to be a download every second for twenty billion years
    before there was a serious risk of duplication, so for the purposes of our sandwich
    vendor, this system is probably adequate.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用唯一标识符**（UUID）是创建唯一值的一种方法，它作为`java.util`的一部分。有几个版本，其中一些基于命名空间，它们本身就是唯一的标识符。我们在这里使用的版本（版本4）使用随机数生成器。可能会诱人地认为这可能会产生重复，但标识符的构建方式意味着在二十亿年内每秒下载一次，才会有严重重复的风险，所以对于我们三明治销售商来说，这个系统可能已经足够了。'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are many other features we could use here, such as adding a hit counter
    to preferences and using it to count how many times our app has been accessed
    over how many sandwiches we have sold or keeping a total of monies spent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在这里使用许多其他功能，例如将点击计数器添加到偏好设置中，用它来统计应用程序被访问的次数，以及我们卖出的三明治数量，或者记录消费总额。
- en: 'Welcoming a new user and adding an ID are things we only want to do the first
    time the application is run, so we will add both features at once. Here are the
    steps required to add welcome features and assign a unique user ID:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎新用户并添加ID是我们只想在应用程序首次运行时执行的操作，因此我们将同时添加这两个功能。以下是添加欢迎功能并分配唯一用户ID所需的步骤：
- en: 'Add these two fields, setters, and getters to the `User` class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`User`类中添加这两个字段、设置器和获取器：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add this code to the `loadPrefs()` method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loadPrefs()`方法中添加以下代码：
- en: '[PRE45]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our app can now welcome and identify each and every user of our app. The beauty
    of using shared preferences to run code only the very first time an app is run,
    is that this method will ignore updates.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以欢迎并识别每一位用户的。使用共享偏好设置来运行代码的美妙之处在于，这种方法会忽略更新，并且只在应用程序首次运行时执行。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A somewhat simpler but less elegant solution to creating user IDs is to take
    the device''s serial number, which can be achieved with something like this: `user.setId(`
    **Build.SERIAL** `.toString())`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户ID的一个相对简单但不够优雅的解决方案是使用设备的序列号，可以通过如下代码实现：`user.setId(` **Build.SERIAL** `.toString())`。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered two quite separate topics in this chapter and covered both theoretical
    and practical subject matter. The composite pattern is incredibly useful and we
    saw how it could easily be used in the stead of other patterns, such as the builder.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了两个完全不同的话题，并涵盖了理论和实践方面的内容。组合模式非常有用，我们看到了它如何轻松地替代其他模式，比如建造者模式。
- en: Patterns are of no use if we do not have a handle on the more mechanical processes
    our software has to perform, such as file storage, and it should be clear that
    the list-like nature of data files, such as the shared preferences we worked with
    earlier, would be well-suited to builder patterns, and more complex data structures
    could be handled with composites.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对软件必须执行的一些更机械的过程没有掌握，比如文件存储，那么模式将无用武之地。应该清楚，类似列表的数据文件（如我们之前使用的共享首选项）的性质非常适合构建器模式，而更复杂的数据结构可以使用组合模式来处理。
- en: In the next chapter, we will look at more non-immediate structures as we explore
    how to create services and post notifications to users when our application is
    not currently active. This will introduce observer patterns, which you will no
    doubt have encountered, in the form of listener methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更多非即时性结构，研究当我们的应用程序当前未激活时如何创建服务和向用户发送通知。这将引入观察者模式，无疑您已经以监听器方法的形式遇到过。
