- en: Chapter 6. Playing Sounds and Music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We hear sound effects and music in almost every type of media we encounter
    daily. Many notable games such as *Pac-Man*, *Angry Birds*, and *Fruit Ninja*
    can be recognized just by their theme music or sound effects alone. Aside from
    the visual imagery we see in games, sounds help impact the mood conveyed in the
    storyline and/or during game play. Quality sound effects and music that pertain
    to the theme of your game helps give a realistic feel to the experience.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to apply sound effects and music that can
    be added to your applications. You have the visual appeal down from creating Breakout
    and Panda Star Catcher in the previous chapters. Now, let's enhance the sensory
    experience for our ears!
  prefs: []
  type: TYPE_NORMAL
- en: 'The main points you''ll be going over are:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading, playing, and looping audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to play, pause, resume, rewind, and stop the audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management (disposing audio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance and encoding tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create some more magic!
  prefs: []
  type: TYPE_NORMAL
- en: Corona audio system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Corona audio system has advanced **Open Audio Library** (**OpenAL**) features.
    OpenAL is designed for the efficient rendering of multichannel three-dimensional
    positional audio. The general functionality of OpenAL is encoded in source objects,
    audio buffers, and a single listener. A source object contains a pointer to a
    buffer, the velocity, position and direction of the sound, and the intensity of
    the sound. Buffers contain audio data in the PCM format, either 8- or 16-bit,
    in either mono or stereo format. The listener object contains the velocity, position
    and direction of the listener, and the general gain applied to all sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the Corona audio system, you can go to [http://developer.coronalabs.com/partner/audionotes](http://developer.coronalabs.com/partner/audionotes).
    General information on OpenAL can be found at [http://www.openal.org](http://www.openal.org).
  prefs: []
  type: TYPE_NORMAL
- en: Sound formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the sound formats that are compatible with iOS and Android
    platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: All platforms support files that are 16-bit, little endian, linear, and in `.wav`
    format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS supports the `.mp3`, `.aif`, `.caf`, and `.aac` formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mac simulator supports the `.mp3`, `.aif`, `.caf`, `.ogg`, and `.aac` formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows simulator supports the `.mp3` and `.ogg` formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android supports the `.mp3` and `.ogg` formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound filename limitations on Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'File extensions are ignored when building in Android, so files are considered
    the same regardless of the extension. The workaround for the mean time is to change
    the filenames to differentiate between file extensions. See the examples listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tap_aac.aac`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tap_aif.aif`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tap_caf.caf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tap_mp3.mp3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tap_ogg.ogg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono sounds at their best
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using mono sounds takes half the amount of memory than stereo sounds. Since
    the Corona audio system uses OpenAL, it will only apply spatialized/3D effects
    to mono sounds. OpenAL does not apply 3D effects stereo samples.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of simultaneous channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The maximum number of channels that can be run is 32\. This allows up to 32
    distinct sounds to be played simultaneously. The API to see the resulting number
    of channels in your code is `audio.totalChannels`.
  prefs: []
  type: TYPE_NORMAL
- en: Time to play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Audio can be loaded in two different ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loadSound()`: This preloads an entire sound into the memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadStream()`: This prepares the sound to be played by reading small chunks
    at a time to save memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: audio.loadSound()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.loadSound()` function loads an entire file completely into the memory
    and returns a reference to the audio data. Files that are loaded completely into
    the memory can be reused, played, and shared simultaneously on multiple channels.
    So, you only need to load one instance of the file. Sounds that you would use
    as sound effects in your game will fit in this category.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.loadSound(audiofileName [, baseDir ])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`audiofileName`: This specifies the name of the audio file you want to load.
    The supported file formats are determined by the platform the file is being run
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseDir`: By default, sound files are expected to be in the application resources
    directory. If the sound file is in the application documents directory, use `system.DocumentsDirectory`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tapSound = audio.loadSound("tap.wav")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smokeSound = audio.loadSound("smoke.mp3")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: audio.loadStream()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.loadStream()` function loads a file to be read as a stream. Streamed
    files are read in small chunks at a time to minimize memory use. Files that are
    large in size and have a long duration would be ideal for this. These files cannot
    be shared simultaneously across multiple channels. If need be, you must load multiple
    instances of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.loadStream( audioFileName [, baseDir ] )`
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`audiofileName`: This specifies the name of the audio file you want to load.
    The supported file formats are determined by the platform the file is being run
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseDir`: By default, sound files are expected to be in the application resources
    directory. If the sound file is in the application documents directory, use `system.DocumentsDirectory`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`music1 = audio.loadStream("song1.mp3")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`music2 = audio.loadStream("song2.wav")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: audio.play()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.play()` function plays the audio specified by the audio handle on
    a channel. If a channel is not specified, an available channel will be automatically
    chosen for you. The function returns the channel number the audio is playing on.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.play( audioHandle [, options ] )`
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`audioHandle`: This is the audio data you want to play'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This is an additional option for playback, formatted as a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters for `options`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This option lets you select the channel number that you want the
    audio to play on. 1 to the maximum number of channels, which is 32, are valid
    channels. If you specify 0 or omit, this parameter will have a channel automatically
    picked for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loops`: This option lets you select the number of times you want the audio
    to loop. 0 means the audio will loop zero times, which means that the sound will
    play once and not loop. Passing -1 will tell the system to infinitely loop the
    sample.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration`: This option is measured in milliseconds, this option will cause
    the system to play the audio for the specified amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadein`: This option is measured in milliseconds, this will start playing
    a sound at the minimum channel volume and transition to the normal channel volume
    over the specified number of milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: This is a callback function that you will call when playback
    ends. The `onComplete` callback function passes back an event parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Looping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Highly compressed formats, such as MP3, AAC, and Ogg Vorbis, can remove samples
    at the end of an audio sample and possibly break a clip that is looped correctly.
    If you experience gaps in looping during playback, try using WAV (compatible with
    iOS and Android). Make sure your lead-in and ending points are clean.
  prefs: []
  type: TYPE_NORMAL
- en: Simultaneous playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sounds loaded via `loadSound()` can be played back simultaneously on multiple
    channels. For example, you can load a sound effect as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to make a variety of bell sounds to occur for multiple objects,
    you can. The audio engine is highly optimized to handle this case. Call `audio.play()`
    using that same handle as many times as you need it (up to the maximum channels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – playing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to learn how sound effects and music are implemented in Corona
    to get an idea of how it really works. To play an audio follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project folder on your desktop called `Playing Audio`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chapter 6 Resources` folder, copy the `ring.wav` and `song1.mp3` sound
    files into your project folder and create a new `main.lua` file. You can download
    the project files that accompany this book from the Packt Publishing website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Preload the following audio with `loadSound()` and `loadStream()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Play `backgroundSound` by setting it to channel 1, loop it infinitely, and
    fade in after 3 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in `ringSound` and play it once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and run the project in the Corona Simulator to hear the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For audio that is merely a short sound effect, we used `audio.loadSound()` to
    prepare the sound. For audio that is large in size or long in duration, `audio.loadStream()`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: The `backgroundSound` file is set to channel 1, and fades in at 3 seconds when
    it starts playing. The `loops = -1` statement means that the file loops infinitely
    from beginning to the end.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – repeating audio with delay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, loading and playing an audio is really simple. It only takes
    two lines of code to play a simple sound. Let's see if you can take it up a notch.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ring.wav` file and load it through `loadSound()`. Create a function
    that plays the audio. Have the sound play at an interval of 2 seconds, repeating
    five times.
  prefs: []
  type: TYPE_NORMAL
- en: Time to take control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the ability to control our sounds, now that we can play them in the
    simulator. If you think back to the days of cassette tape players, it had the
    ability to use functions such as pause, stop, and rewind. Corona's audio API library
    can do just that.
  prefs: []
  type: TYPE_NORMAL
- en: audio.stop()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.stop()` function stops playback on a channel and clears the channel,
    so it can be played on again.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.stop( [channel] )` or `audio.stop( [ { channel = c } ]
    )`.
  prefs: []
  type: TYPE_NORMAL
- en: Having no parameters stops all active channels. The `channel` parameter specifies
    the channel to stop. Specifying 0 stops all channels.
  prefs: []
  type: TYPE_NORMAL
- en: audio.pause()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.pause()` function pauses playback on a channel. This has no effect
    on channels that aren't playing.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.pause( [channel] )` or `audio.pause( [ {channel = c} ]
    )`.
  prefs: []
  type: TYPE_NORMAL
- en: Having no parameters pauses all active channels. The `channel` parameter specifies
    the channel to pause. Specifying 0 pauses all channels.
  prefs: []
  type: TYPE_NORMAL
- en: audio.resume()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The audio.resume() function resumes playback on a channel that is paused. This
    has no effect on channels that aren't paused.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.pause( [channel] )` or `audio.pause( [ {channel = c} ]
    )`.
  prefs: []
  type: TYPE_NORMAL
- en: Having no parameters resumes all paused channels. The `channel` parameter specifies
    the channel to resume. Specifying 0 resumes all channels.
  prefs: []
  type: TYPE_NORMAL
- en: audio.rewind()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.rewind()` function rewinds audio to the beginning position on either
    an active channel or directly on the audio handle.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.rewind( [, audioHandle ] [, { channel=c } ] )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`audioHandle`: The `audioHandle` parameter lets you rewind the data you want.
    It''s best for audio loaded with `audio.loadStream()`. Don''t try using it with
    the `channel` parameter in the same call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: The `channel` parameter lets you select the channel you want the
    rewind operation to apply to. It''s best for audio loaded with `audio.loadSound()`.
    Don''t try using with the `audioHandle` parameter in the same call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – controlling audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s simulate our own little music player by creating user interface buttons
    that will control the audio calls as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chapter 6` folder, copy the `Controlling Audio` project folder to your
    desktop. You will notice several art assets, a `ui.lua` library, `config.lua`
    file, and a `song2.mp3` file inside. You can download the project files accompanying
    this book from the Packt Publishing website.![Time for action – controlling audio](img/9343OT_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same project folder, create a brand new `main.lua` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the audio file via `loadStream()`, name it `music`, and call the UI library.
    Also add it in a local variable called `myMusic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a local function called `onPlayTouch()` with an `event` parameter to
    play the audio file. Add an `if` statement that contains `event.phase == "release"`
    so that the music starts playing when the button releases. Apply the `playBtn`
    display object as a new UI button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a local function called `onPauseTouch()` with an `event` parameter to
    pause the audio file. Add an `if` statement when `event.phase == "release"` so
    that the music pauses. Apply the `pauseBtn` display object as a new UI button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a local function called `onResumeTouch()` with an `event` parameter to
    resume the audio file. Add an `if` statement when `event.phase == "release"` so
    that the music resumes. Apply the `resumeBtn` display object as a new UI button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a local function called `onStopTouch()` with an `event` parameter to stop
    the audio file. Create an `if` statement when `event.phase == "release"` so that
    the music stops. Apply the `stopBtn` display object as a new UI button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a local function called `onRewindTouch()` with an `event` parameter to
    rewind the audio file. Create an`if` statement when `event.phase == "release"`
    so that the music rewinds to the beginning of the track. Apply the `rewindBtn`
    display object as a new UI button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your project and run it in the simulator. You have now created a functional
    media player!![Time for action – controlling audio](img/9343OT_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a UI library for our user interface buttons by calling `require("ui")`.
    This produces the on press look when a button has been pushed down.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variety of functions were created to run each button. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onPlayTouch()`: This calls out `myMusicChannel = audio.play( music, { loops=-1
    } )` when the event is triggered by the user pressing the button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPauseTouch()`: This calls out `audio.pause( myMusicChannel )` to pause the
    song when the button is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResumeTouch()`: This calls out `audio.resume( myMusicChannel )` to resume
    the song if it has been paused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStopTouch()`: This calls out `audio.stop()` if the song is currently playing
    and will stop the audio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRewindTouch()`: This calls out `audio.rewind( myMusicChannel )` to rewind
    the song to the beginning of the track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a song is paused, it resumes only by pressing the **Resume** button. The
    **Play** button will have no effect when the **Pause** button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to call `audio.dispose()` on your loaded audio when you are
    completely done with the audio file. Doing so allows you to recover the memory.
  prefs: []
  type: TYPE_NORMAL
- en: audio.dispose()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `audio.dispose()` function releases the audio memory associated with the
    handle.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.dispose( audioHandle )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`audioHandle`: The handle returned by the `audio.loadSound()` or `audio.loadStream()`
    functions that you want to free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You must not use the handle once the memory is freed. The audio should not be
    playing or paused on any channel when you try to free it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero – disposing audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have just learned how to dispose audio files properly to recover memory
    in your application. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load your audio file and have it play for a specified time. Create a function
    that will dispose the file when calling an `onComplete` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Controlling Audio` project file, dispose the audio in the `onStopTouch()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alterations to audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The audio system also has the ability to alter the minimum and maximum states
    of audio volume, as well as fading the audio when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Volume control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The volume of the audio can be set with values ranging from 0 to 1.0\. This
    setting can be adjusted at any time before or during the extended sound playback.
  prefs: []
  type: TYPE_NORMAL
- en: audio.setVolume()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.setVolume` function sets the volume.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.setVolume( volume [, [options] ] ) --upon success, should
    return true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`volume`: This lets you set the volume level you want to apply. Valid numbers
    range from 0.0 to 1.0, where 1.0 is the maximum volume value. The default volume
    is based on your device ringer volume and will vary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This is a table that supports the channel number you want to set
    the volume on. You can set the volume on any channel between 1 to 32\. Specify
    0 to apply the volume to all the channels. Omitting this parameter entirely sets
    the master volume, which is different from the channel volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`audio.setVolume( 0.75 ) -- set master volume`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`audio.setVolume( 0.5, { channel=2 } ) -- set volume on channel scaled to the
    volume on the master channel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: audio.setMinVolume()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.setMinVolume()` function clamps the minimum volume to the set value.
    Any volumes that go below the minimum volume will be played at the minimum volume
    level.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.setMinVolume( volume, options )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`volume`: This lets you set the new minimum volume level you want to apply.
    Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum volume value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This is a table that supports a single key channel number you want
    to set the minimum volume on. 1 to the minimum number of channels are valid channels.
    Specify 0 to apply the minimum volume to all the channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example is mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: audio.setMaxVolume()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.setMaxVolume()` function clamps the maximum volume to the set value.
    Any volumes that exceed the maximum volume will be played at the maximum volume
    level.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.setMaxVolume( volume, options )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The are parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`volume`: This lets you set the new maximum volume level you want to apply.
    Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This is a table that supports a single key channel number you want
    to set the maximum volume on. 1 to the maximum number of channels are valid channels.
    Specify 0 to apply the maximum volume to all the channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example is mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: audio.getVolume()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.getVolume()` function gets the volume either for a specific channel
    or the master volume.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.getVolume( { channel=c } )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This sets the channel number you want to get the volume on. There
    can be a maximum number of 32 channels that are valid. Specifying 0 will return
    the average volume across all channels. Omitting this parameter entirely gets
    the master volume, which is different than the channel volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some example are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`masterVolume = audio.getVolume() -- get the master volume`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel1Volume = audio.getVolume( { channel=1 } ) -- get the volume on channel
    1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: audio.getMinVolume()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.getMinVolume()` function gets the minimum volume for a specific channel.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.getMinVolume( { channel=c } )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This sets the channel number you want to get the minimum volume
    on. There can be a maximum number of 32 channels that are valid. Specifying 0
    will return the average minimum volume across all channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example is mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: audio.getMaxVolume()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.getMaxVolume()` function gets the maximum volume for a specific channel.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.getMaxVolume( { channel=c } )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This sets the channel number you want to get the maximum volume
    on. There can be a maximum number of 32 channels that are valid. Specifying 0
    will return the average volume across all channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example is mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Fading audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can fade in the volume at the time any audio starts playing, but there are
    other ways to control it as well.
  prefs: []
  type: TYPE_NORMAL
- en: audio.fade()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.fade()` function fades a playing sound in a specified amount to a
    specified volume. The audio will continue playing after the fade completes.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.fade( [ { [channel=c] [, time=t] [, volume=v ] } ] )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This sets the channel number you want to fade on. 1 to the maximum
    number of channels are valid channels. Specify 0 to apply fade to all the channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: This sets the amount of time from now that you want the audio to fade
    out and stop. Omitting this parameter invokes a default fade time, which is 1,000
    milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: This sets the target volume you want to change the fade to. Valid
    numbers are 0.0 to 1.0, where 1.0 is the maximum volume. If this parameter is
    omitted, the default value is 0.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: audio.fadeOut()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `audio.fadeOut()` function stops playing the sound in a specified amount
    of time and fades to the minimum volume. The audio will stop at the end of the
    time and the channel will be freed.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `audio.fadeOut( [ { [channel=c] [, time=t] } ] )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This sets the channel number you want to fade out on. 1 to the maximum
    number of channels are valid channels. Specify 0 to apply fade out to all the
    channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: This sets the amount of time from now that you want the audio to fade
    out over and stop. Omitting this parameter invokes a default fade out time, which
    is 1,000 milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example is mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Performance tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating good quality audios for your games, refer to the helpful notes
    mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: Preloading phase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is best to preload the files you regularly use on startup of your application.
    While `loadStream()` is generally fast, `loadSound()` may take a while since it
    must load and decode the entire file the instant it needs to be used. Generally,
    you don't want to be calling `loadSound()` in the parts of your application that
    users expect it to be running smoothly when events occur, such as during game
    play.
  prefs: []
  type: TYPE_NORMAL
- en: audioPlayFrequency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `config.lua` file, you may specify a field called `audioPlayFrequency`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This tells the OpenAL system what sample rate to mix and playback at. For best
    results, set this no higher than you actually need. So if you never need better
    than 22,050 Hz playback, set this to 22,050\. It produces quality speech recordings
    or middle-quality recordings of music. If you really do need high quality, then
    set this to 44,100 to produce audio CD type of quality at playback.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to have all your audio files encoded at the same frequency when you
    have this set. The supported values are 11,025, 22,050, and 44,100.
  prefs: []
  type: TYPE_NORMAL
- en: Patents and royalties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For highly compressed formats, such as MP3 and AAC, AAC is the better option.
    AAC is the official successor to the MP3 by the MPEG Group. MP3 has patent and
    royalty issues that you may need to concern yourself with, if you distribute anything
    yourself. You might need to consult your lawyers for guidance. When AAC was ratified,
    it was agreed there would be no royalties required for distribution. If you prefer
    to use AAC over MP3, here's a tutorial on how to convert an MP3 to AAC or any
    file format of your preference at [http://support.apple.com/kb/ht1550](http://support.apple.com/kb/ht1550).
  prefs: []
  type: TYPE_NORMAL
- en: Ogg Vorbis is a royalty-free and patent-free format. However, this is not supported
    on iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on audio formats can be found at [http://www.nch.com.au/acm/formats.html](http://www.nch.com.au/acm/formats.html).
    Ray Wenderlich, a mobile developer, also has a tutorial available on file and
    data formats for audio at [http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats](http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats).
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – all about audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What is the proper way of clearing audio files from the memory?
  prefs: []
  type: TYPE_NORMAL
- en: '`audio.pause()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`audio.stop()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`audio.dispose()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`audio.fadeOut()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. How many channels of audio can be played simultaneously in an application?
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '18'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '25'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '32'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. How do you make your audio file loop infinitely?
  prefs: []
  type: TYPE_NORMAL
- en: '`loops = -1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loops = 0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loops = 1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now understand the important aspects of using audio files in the Corona
    SDK. Now, you can go off adding your own sound effects and music to your games,
    or even add them to any of the samples you made in the previous chapters. By doing
    so, you add another part of the user experience that will draw players into the
    environment you have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, you learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Preload and play sound effects and music using `loadSound()` and `loadStream()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control audio functions that pause, resume, stop, and rewind a music track under
    the Audio System API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispose audio from memory when it is no longer in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjust volume in your audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will combine everything you have learned so far to
    create your final game in this book. You'll also be going over other ways to implement
    physical objects and collision mechanics that are popular in mobile games in the
    market today. More exciting information to learn awaits you. Let's power through!
  prefs: []
  type: TYPE_NORMAL
