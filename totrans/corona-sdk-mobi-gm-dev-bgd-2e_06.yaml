- en: Chapter 6. Playing Sounds and Music
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 播放声音和音乐
- en: '*We hear sound effects and music in almost every type of media we encounter
    daily. Many notable games such as *Pac-Man*, *Angry Birds*, and *Fruit Ninja*
    can be recognized just by their theme music or sound effects alone. Aside from
    the visual imagery we see in games, sounds help impact the mood conveyed in the
    storyline and/or during game play. Quality sound effects and music that pertain
    to the theme of your game helps give a realistic feel to the experience.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们在日常生活中遇到的几乎所有类型的媒体中都能听到声音效果和音乐。许多著名游戏如*《吃豆人》*、*《愤怒的小鸟》*和*《水果忍者》*仅凭它们的主题音乐或声音效果就能被识别出来。除了我们在游戏中看到的视觉图像，声音帮助影响故事情节中传达的情绪和/或游戏过程中的氛围。与游戏主题相关的优质声音效果和音乐，有助于给体验带来真实感。*'
- en: In this chapter, you will learn how to apply sound effects and music that can
    be added to your applications. You have the visual appeal down from creating Breakout
    and Panda Star Catcher in the previous chapters. Now, let's enhance the sensory
    experience for our ears!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何为你的应用程序添加声音效果和音乐。在前面章节中创建Breakout和Panda Star Catcher时，你已经掌握了视觉吸引力。现在，让我们为我们的耳朵提升感官体验！
- en: 'The main points you''ll be going over are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要学习的主要内容包括：
- en: Loading, playing, and looping audio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载、播放和循环音频
- en: Understanding how to play, pause, resume, rewind, and stop the audio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何播放、暂停、恢复、倒带和停止音频
- en: Memory management (disposing audio)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理（处理音频）
- en: Volume control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音量控制
- en: Performance and encoding tips
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和编码技巧
- en: Let's create some more magic!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创造更多的魔法！
- en: Corona audio system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Corona音频系统
- en: The Corona audio system has advanced **Open Audio Library** (**OpenAL**) features.
    OpenAL is designed for the efficient rendering of multichannel three-dimensional
    positional audio. The general functionality of OpenAL is encoded in source objects,
    audio buffers, and a single listener. A source object contains a pointer to a
    buffer, the velocity, position and direction of the sound, and the intensity of
    the sound. Buffers contain audio data in the PCM format, either 8- or 16-bit,
    in either mono or stereo format. The listener object contains the velocity, position
    and direction of the listener, and the general gain applied to all sounds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Corona音频系统具有先进的**开放音频库**（**OpenAL**）功能。OpenAL专为高效渲染多通道三维定位音频而设计。OpenAL的一般功能编码在源对象、音频缓冲区和单一监听器中。源对象包含指向缓冲区的指针、声音的速度、位置和方向，以及声音的强度。缓冲区包含PCM格式的音频数据，可以是8位或16位，单声道或立体声格式。监听器对象包含监听者的速度、位置和方向，以及应用于所有声音的总增益。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the Corona audio system, you can go to [http://developer.coronalabs.com/partner/audionotes](http://developer.coronalabs.com/partner/audionotes).
    General information on OpenAL can be found at [http://www.openal.org](http://www.openal.org).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于Corona音频系统的信息，你可以访问[http://developer.coronalabs.com/partner/audionotes](http://developer.coronalabs.com/partner/audionotes)。关于OpenAL的一般信息可以在[http://www.openal.org](http://www.openal.org)找到。
- en: Sound formats
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音格式
- en: 'The following are the sound formats that are compatible with iOS and Android
    platforms:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与iOS和安卓平台兼容的声音格式：
- en: All platforms support files that are 16-bit, little endian, linear, and in `.wav`
    format
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有平台都支持16位、小端、线性的`.wav`格式文件
- en: iOS supports the `.mp3`, `.aif`, `.caf`, and `.aac` formats
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS支持`.mp3`、`.aif`、`.caf`和`.aac`格式
- en: The Mac simulator supports the `.mp3`, `.aif`, `.caf`, `.ogg`, and `.aac` formats
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac模拟器支持`.mp3`、`.aif`、`.caf`、`.ogg`和`.aac`格式
- en: The Windows simulator supports the `.mp3` and `.ogg` formats
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows模拟器支持`.mp3`和`.ogg`格式
- en: Android supports the `.mp3` and `.ogg` formats
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓支持`.mp3`和`.ogg`格式
- en: Sound filename limitations on Android
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓上的声音文件名限制
- en: 'File extensions are ignored when building in Android, so files are considered
    the same regardless of the extension. The workaround for the mean time is to change
    the filenames to differentiate between file extensions. See the examples listed
    here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android构建时，文件扩展名被忽略，因此无论扩展名如何，文件都被视为相同。目前的解决办法是更改文件名以区分扩展名。请参阅以下列出的示例：
- en: '`tap_aac.aac`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_aac.aac`'
- en: '`tap_aif.aif`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_aif.aif`'
- en: '`tap_caf.caf`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_caf.caf`'
- en: '`tap_mp3.mp3`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_mp3.mp3`'
- en: '`tap_ogg.ogg`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_ogg.ogg`'
- en: Mono sounds at their best
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单声道声音效果最佳
- en: Using mono sounds takes half the amount of memory than stereo sounds. Since
    the Corona audio system uses OpenAL, it will only apply spatialized/3D effects
    to mono sounds. OpenAL does not apply 3D effects stereo samples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单声道声音比立体声声音节省一半的内存。由于Corona音频系统使用OpenAL，它只会对单声道声音应用空间化/3D效果。OpenAL不对立体声样本应用3D效果。
- en: Maximum number of simultaneous channels
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时播放的最大通道数
- en: The maximum number of channels that can be run is 32\. This allows up to 32
    distinct sounds to be played simultaneously. The API to see the resulting number
    of channels in your code is `audio.totalChannels`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以运行的最大通道数为32，这使得最多可以同时播放32个不同的声音。在你的代码中查看结果通道数的API是 `audio.totalChannels`。
- en: Time to play
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候播放音乐了
- en: 'Audio can be loaded in two different ways, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可以通过以下两种不同的方式加载：
- en: '`loadSound()`: This preloads an entire sound into the memory'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadSound()`: 这会将整个声音预加载到内存中'
- en: '`loadStream()`: This prepares the sound to be played by reading small chunks
    at a time to save memory'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadStream()`: 这会分小块读取声音以节省内存，准备播放'
- en: audio.loadSound()
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.loadSound()
- en: The `audio.loadSound()` function loads an entire file completely into the memory
    and returns a reference to the audio data. Files that are loaded completely into
    the memory can be reused, played, and shared simultaneously on multiple channels.
    So, you only need to load one instance of the file. Sounds that you would use
    as sound effects in your game will fit in this category.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.loadSound()`函数将整个文件完全加载到内存中，并返回对音频数据的引用。完全加载到内存中的文件可以重复使用、播放，并同时在多个通道上共享。因此，你只需要加载文件的单一实例。在游戏中用作音效的声音将属于这一类。'
- en: The syntax is `audio.loadSound(audiofileName [, baseDir ])`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.loadSound(audiofileName [, baseDir ])`。
- en: 'The parameters are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`audiofileName`: This specifies the name of the audio file you want to load.
    The supported file formats are determined by the platform the file is being run
    on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audiofileName`: 这指定了你想要加载的音频文件的名称。支持的文件格式取决于运行该文件的平台。'
- en: '`baseDir`: By default, sound files are expected to be in the application resources
    directory. If the sound file is in the application documents directory, use `system.DocumentsDirectory`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseDir`: 默认情况下，声音文件应位于应用程序资源目录中。如果声音文件位于应用程序文档目录中，请使用 `system.DocumentsDirectory`。'
- en: 'For example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`tapSound = audio.loadSound("tap.wav")`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tapSound = audio.loadSound("tap.wav")`'
- en: '`smokeSound = audio.loadSound("smoke.mp3")`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smokeSound = audio.loadSound("smoke.mp3")`'
- en: audio.loadStream()
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.loadStream()
- en: The `audio.loadStream()` function loads a file to be read as a stream. Streamed
    files are read in small chunks at a time to minimize memory use. Files that are
    large in size and have a long duration would be ideal for this. These files cannot
    be shared simultaneously across multiple channels. If need be, you must load multiple
    instances of the file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.loadStream()`函数用于加载一个文件，以流的形式读取。流式文件是分小块读取的，以最小化内存使用。对于体积大、时长长的文件，这种方式非常理想。这些文件不能同时在多个通道间共享。如果需要，你必须加载该文件的多个实例。'
- en: The syntax is `audio.loadStream( audioFileName [, baseDir ] )`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.loadStream( audioFileName [, baseDir ] )`
- en: 'The parameters are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`audiofileName`: This specifies the name of the audio file you want to load.
    The supported file formats are determined by the platform the file is being run
    on.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audiofileName`: 这指定了你想要加载的音频文件的名称。支持的文件格式取决于运行该文件的平台。'
- en: '`baseDir`: By default, sound files are expected to be in the application resources
    directory. If the sound file is in the application documents directory, use `system.DocumentsDirectory`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseDir`: 默认情况下，声音文件应位于应用程序资源目录中。如果声音文件位于应用程序文档目录中，请使用 `system.DocumentsDirectory`。'
- en: 'For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`music1 = audio.loadStream("song1.mp3")`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`music1 = audio.loadStream("song1.mp3")`'
- en: '`music2 = audio.loadStream("song2.wav")`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`music2 = audio.loadStream("song2.wav")`'
- en: audio.play()
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.play()
- en: The `audio.play()` function plays the audio specified by the audio handle on
    a channel. If a channel is not specified, an available channel will be automatically
    chosen for you. The function returns the channel number the audio is playing on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.play()`函数在通道上播放由音频句柄指定的音频。如果没有指定通道，将自动为你选择一个可用通道。函数返回音频播放的通道号。'
- en: The syntax is `audio.play( audioHandle [, options ] )`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.play( audioHandle [, options ] )`
- en: 'The parameters are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`audioHandle`: This is the audio data you want to play'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audioHandle`: 这是你想播放的音频数据'
- en: '`options`: This is an additional option for playback, formatted as a table'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是播放的附加选项，格式为表。'
- en: 'Parameters for `options`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`options` 的参数：'
- en: '`channel`: This option lets you select the channel number that you want the
    audio to play on. 1 to the maximum number of channels, which is 32, are valid
    channels. If you specify 0 or omit, this parameter will have a channel automatically
    picked for you.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这个选项允许你选择希望音频播放的通道号。从1到最大通道数32都是有效的通道。如果你指定0或省略，系统将自动为你选择通道。'
- en: '`loops`: This option lets you select the number of times you want the audio
    to loop. 0 means the audio will loop zero times, which means that the sound will
    play once and not loop. Passing -1 will tell the system to infinitely loop the
    sample.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loops`：这个选项允许你选择音频循环的次数。0表示不循环，意味着声音将播放一次并不循环。-1表示系统将无限循环样本。'
- en: '`duration`: This option is measured in milliseconds, this option will cause
    the system to play the audio for the specified amount of time.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`：这个选项以毫秒为单位，它将使系统播放指定时间的音频。'
- en: '`fadein`: This option is measured in milliseconds, this will start playing
    a sound at the minimum channel volume and transition to the normal channel volume
    over the specified number of milliseconds.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadein`：这个选项以毫秒为单位，它将使声音从最小通道音量开始播放，并在指定毫秒数内过渡到正常通道音量。'
- en: '`onComplete`: This is a callback function that you will call when playback
    ends. The `onComplete` callback function passes back an event parameter.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：这是一个回调函数，当播放结束时将被调用。`onComplete` 回调函数会传递一个事件参数。'
- en: 'For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Looping
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: Highly compressed formats, such as MP3, AAC, and Ogg Vorbis, can remove samples
    at the end of an audio sample and possibly break a clip that is looped correctly.
    If you experience gaps in looping during playback, try using WAV (compatible with
    iOS and Android). Make sure your lead-in and ending points are clean.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 高度压缩的格式，如 MP3、AAC 和 Ogg Vorbis，可能会移除音频样本末端的采样点，可能会破坏正确循环的剪辑。如果你在播放过程中遇到循环间隙，请尝试使用
    WAV（兼容 iOS 和 Android）。确保你的引导和结束点干净清晰。
- en: Simultaneous playback
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时播放
- en: 'Sounds loaded via `loadSound()` can be played back simultaneously on multiple
    channels. For example, you can load a sound effect as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `loadSound()` 加载的声音可以在多个通道上同时播放。例如，你可以如下加载一个音效：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to make a variety of bell sounds to occur for multiple objects,
    you can. The audio engine is highly optimized to handle this case. Call `audio.play()`
    using that same handle as many times as you need it (up to the maximum channels):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为多个对象产生各种铃声，你可以这么做。音频引擎经过高度优化，可以处理这种情况。使用相同的句柄调用 `audio.play()`，次数可达最大通道数（32次）：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Time for action – playing audio
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间 – 播放音频
- en: 'We''re going to learn how sound effects and music are implemented in Corona
    to get an idea of how it really works. To play an audio follow the steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习声音效果和音乐在 Corona 中的实现方式，以了解它实际是如何工作的。要播放音频，请按照以下步骤操作：
- en: Create a new project folder on your desktop called `Playing Audio`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的桌面上创建一个名为 `Playing Audio` 的新项目文件夹。
- en: In the `Chapter 6 Resources` folder, copy the `ring.wav` and `song1.mp3` sound
    files into your project folder and create a new `main.lua` file. You can download
    the project files that accompany this book from the Packt Publishing website.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter 6 Resources` 文件夹中，将 `ring.wav` 和 `song1.mp3` 声音文件复制到你的项目文件夹中，并创建一个新的
    `main.lua` 文件。你可以从 Packt Publishing 网站下载伴随这本书的项目文件。
- en: 'Preload the following audio with `loadSound()` and `loadStream()`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `loadSound()` 和 `loadStream()` 预加载以下音频：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Play `backgroundSound` by setting it to channel 1, loop it infinitely, and
    fade in after 3 seconds:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `backgroundSound` 设置为通道1，无限循环，并在3秒后淡入：
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add in `ringSound` and play it once:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ringSound` 并播放一次：
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save and run the project in the Corona Simulator to hear the results.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目并在 Corona 模拟器中运行，以听取结果。
- en: '*What just happened?*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: For audio that is merely a short sound effect, we used `audio.loadSound()` to
    prepare the sound. For audio that is large in size or long in duration, `audio.loadStream()`
    is used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅是短音效的音频，我们使用 `audio.loadSound()` 来准备声音。对于大小较大或时长较长的音频，使用 `audio.loadStream()`。
- en: The `backgroundSound` file is set to channel 1, and fades in at 3 seconds when
    it starts playing. The `loops = -1` statement means that the file loops infinitely
    from beginning to the end.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`backgroundSound` 文件设置为通道1，并在开始播放3秒后淡入。`loops = -1` 表示文件将无限循环从开始到结束。'
- en: Have a go hero – repeating audio with delay
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 – 延迟重复音频
- en: As you can see, loading and playing an audio is really simple. It only takes
    two lines of code to play a simple sound. Let's see if you can take it up a notch.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，加载和播放音频真的很简单。只需两行代码就可以播放一个简单的声音。让我们看看你是否能把它提升一个档次。
- en: Use the `ring.wav` file and load it through `loadSound()`. Create a function
    that plays the audio. Have the sound play at an interval of 2 seconds, repeating
    five times.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ring.wav` 文件并通过 `loadSound()` 加载它。创建一个播放音频的函数。让声音每2秒播放一次，重复五次。
- en: Time to take control
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候掌控一切了
- en: We have the ability to control our sounds, now that we can play them in the
    simulator. If you think back to the days of cassette tape players, it had the
    ability to use functions such as pause, stop, and rewind. Corona's audio API library
    can do just that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在模拟器中播放它们，因此我们有能力控制我们的声音。回想一下卡带播放器的日子，它有暂停、停止和倒带等功能。Corona 的音频 API 库也可以做到这一点。
- en: audio.stop()
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.stop()
- en: The `audio.stop()` function stops playback on a channel and clears the channel,
    so it can be played on again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.stop()` 函数会停止通道上的播放并清除通道，以便可以再次播放。'
- en: The syntax is `audio.stop( [channel] )` or `audio.stop( [ { channel = c } ]
    )`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.stop( [channel] )` 或 `audio.stop( [ { channel = c } ] )`。
- en: Having no parameters stops all active channels. The `channel` parameter specifies
    the channel to stop. Specifying 0 stops all channels.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数会停止所有活动通道。`channel` 参数指定要停止的通道。指定 0 会停止所有通道。
- en: audio.pause()
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.pause()
- en: The `audio.pause()` function pauses playback on a channel. This has no effect
    on channels that aren't playing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.pause()` 函数会在通道上暂停播放。这对没有播放的通道没有影响。'
- en: The syntax is `audio.pause( [channel] )` or `audio.pause( [ {channel = c} ]
    )`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.pause( [channel] )` 或 `audio.pause( [ {channel = c} ] )`。
- en: Having no parameters pauses all active channels. The `channel` parameter specifies
    the channel to pause. Specifying 0 pauses all channels.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数会暂停所有活动通道。`channel` 参数指定要暂停的通道。指定 0 会暂停所有通道。
- en: audio.resume()
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.resume()
- en: The audio.resume() function resumes playback on a channel that is paused. This
    has no effect on channels that aren't paused.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.resume()` 函数会恢复暂停的通道上的播放。这对没有暂停的通道没有影响。'
- en: The syntax is `audio.pause( [channel] )` or `audio.pause( [ {channel = c} ]
    )`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.pause( [channel] )` 或 `audio.pause( [ {channel = c} ] )`。
- en: Having no parameters resumes all paused channels. The `channel` parameter specifies
    the channel to resume. Specifying 0 resumes all channels.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数会恢复所有暂停的通道。`channel` 参数指定要恢复的通道。指定 0 会恢复所有通道。
- en: audio.rewind()
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.rewind()
- en: The `audio.rewind()` function rewinds audio to the beginning position on either
    an active channel or directly on the audio handle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.rewind()` 函数会将音频倒带到活动通道或直接在音频句柄上的开始位置。'
- en: The syntax is `audio.rewind( [, audioHandle ] [, { channel=c } ] )`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.rewind( [, audioHandle ] [, { channel=c } ] )`。
- en: 'The parameters are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`audioHandle`: The `audioHandle` parameter lets you rewind the data you want.
    It''s best for audio loaded with `audio.loadStream()`. Don''t try using it with
    the `channel` parameter in the same call.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audioHandle`：`audioHandle` 参数允许你倒带所需的数据。它最适合用 `audio.loadStream()` 加载的音频。不要尝试与
    `channel` 参数在同一调用中使用。'
- en: '`channel`: The `channel` parameter lets you select the channel you want the
    rewind operation to apply to. It''s best for audio loaded with `audio.loadSound()`.
    Don''t try using with the `audioHandle` parameter in the same call.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：`channel` 参数允许你选择要应用倒带操作的通道。它最适合用 `audio.loadSound()` 加载的音频。不要尝试与
    `audioHandle` 参数在同一调用中使用。'
- en: Time for action – controlling audio
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 控制音频
- en: 'Let''s simulate our own little music player by creating user interface buttons
    that will control the audio calls as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建用户界面按钮来模拟我们自己的小音乐播放器，以下面的方式控制音频调用：
- en: In the `Chapter 6` folder, copy the `Controlling Audio` project folder to your
    desktop. You will notice several art assets, a `ui.lua` library, `config.lua`
    file, and a `song2.mp3` file inside. You can download the project files accompanying
    this book from the Packt Publishing website.![Time for action – controlling audio](img/9343OT_06_01.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter 6` 文件夹中，将 `Controlling Audio` 项目文件夹复制到你的桌面。你会注意到有几个艺术资源，一个 `ui.lua`
    库，一个 `config.lua` 文件，以及一个 `song2.mp3` 文件。你可以从 Packt Publishing 网站下载本书附带的的项目文件。![行动时间
    – 控制音频](img/9343OT_06_01.jpg)
- en: In the same project folder, create a brand new `main.lua` file.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个项目文件夹中，创建一个全新的 `main.lua` 文件。
- en: 'Load the audio file via `loadStream()`, name it `music`, and call the UI library.
    Also add it in a local variable called `myMusic`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `loadStream()` 加载音频文件，将其命名为 `music`，并调用UI库。还在一个名为 `myMusic` 的局部变量中添加它：
- en: '[PRE6]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a local function called `onPlayTouch()` with an `event` parameter to
    play the audio file. Add an `if` statement that contains `event.phase == "release"`
    so that the music starts playing when the button releases. Apply the `playBtn`
    display object as a new UI button:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `onPlayTouch()` 的局部函数，带有一个 `event` 参数以播放音频文件。添加一个包含 `event.phase == "release"`
    的 `if` 语句，以便在按钮释放时开始播放音乐。将 `playBtn` 显示对象作为一个新的UI按钮应用：
- en: '[PRE7]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a local function called `onPauseTouch()` with an `event` parameter to
    pause the audio file. Add an `if` statement when `event.phase == "release"` so
    that the music pauses. Apply the `pauseBtn` display object as a new UI button:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `onPauseTouch()` 的局部函数，带有一个 `event` 参数以暂停音频文件。当 `event.phase == "release"`
    时添加一个 `if` 语句，以便音乐暂停。将 `pauseBtn` 显示对象作为一个新的UI按钮应用：
- en: '[PRE8]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a local function called `onResumeTouch()` with an `event` parameter to
    resume the audio file. Add an `if` statement when `event.phase == "release"` so
    that the music resumes. Apply the `resumeBtn` display object as a new UI button:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onResumeTouch()` 的局部函数，带有一个 `event` 参数以恢复音频文件。当 `event.phase == "release"`
    时添加一个 `if` 语句，以便音乐恢复。将 `resumeBtn` 显示对象作为一个新的UI按钮应用：
- en: '[PRE9]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a local function called `onStopTouch()` with an `event` parameter to stop
    the audio file. Create an `if` statement when `event.phase == "release"` so that
    the music stops. Apply the `stopBtn` display object as a new UI button:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onStopTouch()` 的局部函数，带有一个 `event` 参数以停止音频文件。当 `event.phase == "release"`
    时创建一个 `if` 语句，以便音乐停止。将 `stopBtn` 显示对象作为一个新的UI按钮应用：
- en: '[PRE10]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a local function called `onRewindTouch()` with an `event` parameter to
    rewind the audio file. Create an`if` statement when `event.phase == "release"`
    so that the music rewinds to the beginning of the track. Apply the `rewindBtn`
    display object as a new UI button:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onRewindTouch()` 的局部函数，带有一个 `event` 参数以倒带音频文件。当 `event.phase == "release"`
    时创建一个 `if` 语句，以便音乐倒带到曲目开头。将 `rewindBtn` 显示对象作为一个新的UI按钮应用：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save your project and run it in the simulator. You have now created a functional
    media player!![Time for action – controlling audio](img/9343OT_06_02.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目并在模拟器中运行。现在你已经创建了一个功能齐全的媒体播放器！！![行动时间——控制音频](img/9343OT_06_02.jpg)
- en: '*What just happened?*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We added a UI library for our user interface buttons by calling `require("ui")`.
    This produces the on press look when a button has been pushed down.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `require("ui")` 为我们的用户界面按钮添加了一个UI库。这会在按钮被按下时产生按下时的外观。
- en: 'A variety of functions were created to run each button. They are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了各种功能来运行每个按钮。它们如下：
- en: '`onPlayTouch()`: This calls out `myMusicChannel = audio.play( music, { loops=-1
    } )` when the event is triggered by the user pressing the button'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPlayTouch()`：当用户按下按钮触发事件时，调用 `myMusicChannel = audio.play( music, { loops=-1
    } )`'
- en: '`onPauseTouch()`: This calls out `audio.pause( myMusicChannel )` to pause the
    song when the button is pressed'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPauseTouch()`：当按下按钮时，调用 `audio.pause( myMusicChannel )` 暂停歌曲'
- en: '`onResumeTouch()`: This calls out `audio.resume( myMusicChannel )` to resume
    the song if it has been paused'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResumeTouch()`：如果歌曲已经被暂停，调用 `audio.resume( myMusicChannel )` 恢复歌曲'
- en: '`onStopTouch()`: This calls out `audio.stop()` if the song is currently playing
    and will stop the audio'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStopTouch()`：如果歌曲当前正在播放，调用 `audio.stop()` 停止音频'
- en: '`onRewindTouch()`: This calls out `audio.rewind( myMusicChannel )` to rewind
    the song to the beginning of the track.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRewindTouch()`：调用 `audio.rewind( myMusicChannel )` 将歌曲倒带到曲目开头。'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a song is paused, it resumes only by pressing the **Resume** button. The
    **Play** button will have no effect when the **Pause** button is pressed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当一首歌曲被暂停时，只有按下**恢复**按钮才会继续播放。当按下**暂停**按钮时，**播放**按钮将不起作用。
- en: Memory management
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: It is important to call `audio.dispose()` on your loaded audio when you are
    completely done with the audio file. Doing so allows you to recover the memory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完全完成音频文件时，调用 `audio.dispose()` 非常重要。这样做可以让你回收内存。
- en: audio.dispose()
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.dispose()
- en: The `audio.dispose()` function releases the audio memory associated with the
    handle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.dispose()` 函数释放与句柄关联的音频内存。'
- en: The syntax is `audio.dispose( audioHandle )`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `audio.dispose( audioHandle )`。
- en: 'The parameter is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`audioHandle`: The handle returned by the `audio.loadSound()` or `audio.loadStream()`
    functions that you want to free.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audioHandle`：由你想要释放的 `audio.loadSound()` 或 `audio.loadStream()` 函数返回的句柄。'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You must not use the handle once the memory is freed. The audio should not be
    playing or paused on any channel when you try to free it.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在释放内存后，你一定不能使用该句柄。当尝试释放音频时，音频不应该在任何通道上播放或暂停。
- en: 'For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Have a go hero – disposing audio
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——处理音频
- en: 'You have just learned how to dispose audio files properly to recover memory
    in your application. Try the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何正确处理音频文件，以便在应用程序中回收内存。尝试以下操作：
- en: Load your audio file and have it play for a specified time. Create a function
    that will dispose the file when calling an `onComplete` command.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载你的音频文件，并让它播放指定的时间。创建一个函数，当调用`onComplete`命令时处理文件。
- en: In the `Controlling Audio` project file, dispose the audio in the `onStopTouch()`
    function.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`控制音频`项目文件中，在`onStopTouch()`函数中处理音频。
- en: Alterations to audio
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频更改
- en: The audio system also has the ability to alter the minimum and maximum states
    of audio volume, as well as fading the audio when needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 音频系统还具备更改音频音量的最小和最大状态的能力，以及在需要时淡入淡出音频。
- en: Volume control
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音量控制
- en: The volume of the audio can be set with values ranging from 0 to 1.0\. This
    setting can be adjusted at any time before or during the extended sound playback.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 音频的音量可以设置为0到1.0之间的值。此设置可以在扩展声音播放之前或播放期间的任何时间调整。
- en: audio.setVolume()
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.setVolume()
- en: The `audio.setVolume` function sets the volume.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.setVolume`函数设置音量。'
- en: The syntax is `audio.setVolume( volume [, [options] ] ) --upon success, should
    return true`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `audio.setVolume( volume [, [options] ] ) -- 成功后，应返回true`。
- en: 'The parameters are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`volume`: This lets you set the volume level you want to apply. Valid numbers
    range from 0.0 to 1.0, where 1.0 is the maximum volume value. The default volume
    is based on your device ringer volume and will vary.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：这允许你设置想要应用的音量级别。有效的数字范围从0.0到1.0，其中1.0是最大音量值。默认音量基于你的设备铃声音量，并会有所不同。'
- en: '`options`: This is a table that supports the channel number you want to set
    the volume on. You can set the volume on any channel between 1 to 32\. Specify
    0 to apply the volume to all the channels. Omitting this parameter entirely sets
    the master volume, which is different from the channel volume.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是一个支持你想要设置音量的通道号的表。你可以设置1到32之间的任何通道的音量。指定0以将音量应用到所有通道。完全省略此参数将设置主音量，这与通道音量不同。'
- en: 'For example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`audio.setVolume( 0.75 ) -- set master volume`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audio.setVolume( 0.75 ) -- 设置主音量`'
- en: '`audio.setVolume( 0.5, { channel=2 } ) -- set volume on channel scaled to the
    volume on the master channel`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audio.setVolume( 0.5, { channel=2 } ) -- 设置通道音量，相对于主通道音量缩放`'
- en: audio.setMinVolume()
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.setMinVolume()
- en: The `audio.setMinVolume()` function clamps the minimum volume to the set value.
    Any volumes that go below the minimum volume will be played at the minimum volume
    level.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.setMinVolume()`函数将最小音量限制在设定的值上。任何低于最小音量的音量将以最小音量级别播放。'
- en: The syntax is `audio.setMinVolume( volume, options )`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `audio.setMinVolume( volume, options )`。
- en: 'The parameters are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`volume`: This lets you set the new minimum volume level you want to apply.
    Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum volume value.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：这允许你设置想要应用的新最小音量级别。有效的数字范围从0.0到1.0，其中1.0是最大音量值。'
- en: '`options`: This is a table that supports a single key channel number you want
    to set the minimum volume on. 1 to the minimum number of channels are valid channels.
    Specify 0 to apply the minimum volume to all the channels.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是一个支持你想要设置最小音量的单一关键字通道号的表。1到最小通道数是有效的通道。指定0以将最小音量应用到所有通道。'
- en: 'The example is mentioned as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: audio.setMaxVolume()
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.setMaxVolume()
- en: The `audio.setMaxVolume()` function clamps the maximum volume to the set value.
    Any volumes that exceed the maximum volume will be played at the maximum volume
    level.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.setMaxVolume()`函数将最大音量限制在设定的值上。任何超过最大音量的音量将以最大音量级别播放。'
- en: The syntax is `audio.setMaxVolume( volume, options )`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `audio.setMaxVolume( volume, options )`。
- en: 'The are parameters are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`volume`: This lets you set the new maximum volume level you want to apply.
    Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum value.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：这允许你设置想要应用的新最大音量级别。有效的数字范围从0.0到1.0，其中1.0是最大值。'
- en: '`options`: This is a table that supports a single key channel number you want
    to set the maximum volume on. 1 to the maximum number of channels are valid channels.
    Specify 0 to apply the maximum volume to all the channels.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是一个支持单个键为你要设置最大音量的通道号的表。1到最大通道数都是有效的通道。指定0将把最大音量应用到所有通道。'
- en: 'The example is mentioned as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: audio.getVolume()
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.getVolume()
- en: The `audio.getVolume()` function gets the volume either for a specific channel
    or the master volume.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.getVolume()`函数可以获取特定通道或主音量的音量。'
- en: The syntax is `audio.getVolume( { channel=c } )`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.getVolume( { channel=c } )`。
- en: 'The parameter is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`channel`: This sets the channel number you want to get the volume on. There
    can be a maximum number of 32 channels that are valid. Specifying 0 will return
    the average volume across all channels. Omitting this parameter entirely gets
    the master volume, which is different than the channel volume.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：设置你想要获取音量的通道号。有效的通道号最多可以有32个。指定0将返回所有通道的平均音量。完全省略此参数将获取主音量，这与通道音量不同。'
- en: 'Some example are mentioned as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '`masterVolume = audio.getVolume() -- get the master volume`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`masterVolume = audio.getVolume() -- 获取主音量`'
- en: '`channel1Volume = audio.getVolume( { channel=1 } ) -- get the volume on channel
    1`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel1Volume = audio.getVolume( { channel=1 } ) -- 获取通道1的音量`'
- en: audio.getMinVolume()
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.getMinVolume()
- en: The `audio.getMinVolume()` function gets the minimum volume for a specific channel.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.getMinVolume()`函数可以获取特定通道的最小音量。'
- en: The syntax is `audio.getMinVolume( { channel=c } )`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.getMinVolume( { channel=c } )`。
- en: 'The parameter is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`channel`: This sets the channel number you want to get the minimum volume
    on. There can be a maximum number of 32 channels that are valid. Specifying 0
    will return the average minimum volume across all channels.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：设置你想要获取最小音量的通道号。有效的通道号最多可以有32个。指定0将返回所有通道的平均最小音量。'
- en: 'The example is mentioned as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: audio.getMaxVolume()
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.getMaxVolume()
- en: The `audio.getMaxVolume()` function gets the maximum volume for a specific channel.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.getMaxVolume()`函数可以获取特定通道的最大音量。'
- en: The syntax is `audio.getMaxVolume( { channel=c } )`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.getMaxVolume( { channel=c } )`。
- en: 'The parameter is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`channel`: This sets the channel number you want to get the maximum volume
    on. There can be a maximum number of 32 channels that are valid. Specifying 0
    will return the average volume across all channels.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：设置你想要获取最大音量的通道号。有效的通道号最多可以有32个。指定0将返回所有通道的平均音量。'
- en: 'The example is mentioned as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Fading audio
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 淡入淡出音频
- en: You can fade in the volume at the time any audio starts playing, but there are
    other ways to control it as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何音频开始播放时淡入音量，但也有其他控制方法。
- en: audio.fade()
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.fade()
- en: The `audio.fade()` function fades a playing sound in a specified amount to a
    specified volume. The audio will continue playing after the fade completes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.fade()`函数会在指定的时间内将播放中的声音淡入到指定的音量。淡出完成后，音频将继续播放。'
- en: The syntax is `audio.fade( [ { [channel=c] [, time=t] [, volume=v ] } ] )`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.fade( [ { [channel=c] [, time=t] [, volume=v] } ] )`。
- en: 'The parameters are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`channel`: This sets the channel number you want to fade on. 1 to the maximum
    number of channels are valid channels. Specify 0 to apply fade to all the channels.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：设置你想要淡入的通道号。1到最大通道数都是有效的通道。指定0将把淡入应用到所有通道。'
- en: '`time`: This sets the amount of time from now that you want the audio to fade
    out and stop. Omitting this parameter invokes a default fade time, which is 1,000
    milliseconds.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：设置从现在开始，你希望音频淡出并停止的时间量。省略此参数将调用默认的淡出时间，即1,000毫秒。'
- en: '`volume`: This sets the target volume you want to change the fade to. Valid
    numbers are 0.0 to 1.0, where 1.0 is the maximum volume. If this parameter is
    omitted, the default value is 0.0.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：设置你想要改变淡入的目标音量。有效的数值为0.0到1.0，其中1.0是最大音量。如果省略此参数，默认值为0.0。'
- en: 'See the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: audio.fadeOut()
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.fadeOut()
- en: The `audio.fadeOut()` function stops playing the sound in a specified amount
    of time and fades to the minimum volume. The audio will stop at the end of the
    time and the channel will be freed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio.fadeOut()`函数会在指定的时间内停止播放声音，并淡出到最小音量。在时间结束时音频将停止，通道将被释放。'
- en: The syntax is `audio.fadeOut( [ { [channel=c] [, time=t] } ] )`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 语法为 `audio.fadeOut( [ { [channel=c] [, time=t] } ] )`。
- en: 'The parameters are as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`channel`: This sets the channel number you want to fade out on. 1 to the maximum
    number of channels are valid channels. Specify 0 to apply fade out to all the
    channels.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：设置你要淡出的通道号。1到最大通道数都是有效的通道。指定0以对所有通道应用淡出。'
- en: '`time`: This sets the amount of time from now that you want the audio to fade
    out over and stop. Omitting this parameter invokes a default fade out time, which
    is 1,000 milliseconds.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：此参数设置从现在开始音频淡出并停止的时间长度。省略此参数将调用默认的淡出时间，即1,000毫秒。'
- en: 'The example is mentioned as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例如下：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Performance tips
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能提示
- en: When creating good quality audios for your games, refer to the helpful notes
    mentioned here.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你的游戏创建高质量音频时，可以参考这里提到的有用说明。
- en: Preloading phase
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载阶段
- en: It is best to preload the files you regularly use on startup of your application.
    While `loadStream()` is generally fast, `loadSound()` may take a while since it
    must load and decode the entire file the instant it needs to be used. Generally,
    you don't want to be calling `loadSound()` in the parts of your application that
    users expect it to be running smoothly when events occur, such as during game
    play.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在应用程序启动时预加载你经常使用的文件。虽然`loadStream()`通常很快，但`loadSound()`可能需要一段时间，因为它必须在需要时立即加载并解码整个文件。通常，你不想在应用程序需要流畅运行事件的部分调用`loadSound()`，比如在游戏玩法中。
- en: audioPlayFrequency
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audioPlayFrequency
- en: 'In the `config.lua` file, you may specify a field called `audioPlayFrequency`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config.lua`文件中，你可以指定一个名为`audioPlayFrequency`的字段：
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This tells the OpenAL system what sample rate to mix and playback at. For best
    results, set this no higher than you actually need. So if you never need better
    than 22,050 Hz playback, set this to 22,050\. It produces quality speech recordings
    or middle-quality recordings of music. If you really do need high quality, then
    set this to 44,100 to produce audio CD type of quality at playback.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉OpenAL系统应以什么采样率进行混音和播放。为了获得最佳效果，此设置不应高于实际需求。例如，如果你不需要超过22,050 Hz的播放质量，就将其设置为22,050。这样可以产生高质量的语音录音或中等质量的乐曲录音。如果你确实需要高音质，那么将其设置为44,100以在播放时产生类似音频CD的质量。
- en: It is best to have all your audio files encoded at the same frequency when you
    have this set. The supported values are 11,025, 22,050, and 44,100.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置了此参数时，最好将所有音频文件编码为相同的频率。支持的值有11,025、22,050和44,100。
- en: Patents and royalties
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专利和版税
- en: For highly compressed formats, such as MP3 and AAC, AAC is the better option.
    AAC is the official successor to the MP3 by the MPEG Group. MP3 has patent and
    royalty issues that you may need to concern yourself with, if you distribute anything
    yourself. You might need to consult your lawyers for guidance. When AAC was ratified,
    it was agreed there would be no royalties required for distribution. If you prefer
    to use AAC over MP3, here's a tutorial on how to convert an MP3 to AAC or any
    file format of your preference at [http://support.apple.com/kb/ht1550](http://support.apple.com/kb/ht1550).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度压缩的格式，如MP3和AAC，AAC是更好的选择。AAC是MPEG集团官方指定的MP3的继承者。如果你分发任何东西，可能需要关心MP3的专利和版税问题。你可能需要咨询律师以获得指导。当AAC被批准时，同意分发时不需要版税。如果你偏好使用AAC而非MP3，这里有一个关于如何将MP3转换为AAC或你喜欢的任何文件格式的教程，可以在[http://support.apple.com/kb/ht1550](http://support.apple.com/kb/ht1550)查看。
- en: Ogg Vorbis is a royalty-free and patent-free format. However, this is not supported
    on iOS devices.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Ogg Vorbis是一种无版税和无专利的格式。然而，这种格式在iOS设备上不支持。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on audio formats can be found at [http://www.nch.com.au/acm/formats.html](http://www.nch.com.au/acm/formats.html).
    Ray Wenderlich, a mobile developer, also has a tutorial available on file and
    data formats for audio at [http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats](http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于音频格式的更多信息可以在[http://www.nch.com.au/acm/formats.html](http://www.nch.com.au/acm/formats.html)找到。移动开发者Ray
    Wenderlich也有一篇关于音频文件和数据格式的教程，可以在[http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats](http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats)查看。
- en: Pop quiz – all about audio
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频小测验
- en: Q1\. What is the proper way of clearing audio files from the memory?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 清除内存中音频文件的正确方法是什么？
- en: '`audio.pause()`'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`audio.pause()`'
- en: '`audio.stop()`'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`audio.stop()`'
- en: '`audio.dispose()`'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`audio.dispose()`'
- en: '`audio.fadeOut()`'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`audio.fadeOut()`'
- en: Q2\. How many channels of audio can be played simultaneously in an application?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 应用程序中可以同时播放多少个音频通道？
- en: '10'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '10'
- en: '18'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '18'
- en: '25'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '25'
- en: '32'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '32'
- en: Q3\. How do you make your audio file loop infinitely?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 你如何使音频文件无限循环？
- en: '`loops = -1`'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loops = -1`'
- en: '`loops = 0`'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loops = 0`'
- en: '`loops = 1`'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loops = 1`'
- en: None of the above
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不对
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You now understand the important aspects of using audio files in the Corona
    SDK. Now, you can go off adding your own sound effects and music to your games,
    or even add them to any of the samples you made in the previous chapters. By doing
    so, you add another part of the user experience that will draw players into the
    environment you have created.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在Corona SDK中使用音频文件的重要方面。现在，你可以开始为你的游戏添加自己的声音效果和音乐，甚至可以添加到之前章节中你制作的任何示例中。这样做，你将为用户增加另一部分体验，这将吸引玩家进入你创造的环境。
- en: 'Until now, you learned how to:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何：
- en: Preload and play sound effects and music using `loadSound()` and `loadStream()`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`loadSound()`和`loadStream()`预加载和播放声音效果及音乐
- en: Control audio functions that pause, resume, stop, and rewind a music track under
    the Audio System API
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在音频系统API下控制暂停、恢复、停止和倒带音乐轨道的音频功能
- en: Dispose audio from memory when it is no longer in use
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当音频不再使用时，从内存中释放
- en: Adjust volume in your audio files
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整音频文件中的音量
- en: In the next chapter, you will combine everything you have learned so far to
    create your final game in this book. You'll also be going over other ways to implement
    physical objects and collision mechanics that are popular in mobile games in the
    market today. More exciting information to learn awaits you. Let's power through!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将结合到目前为止所学的所有内容来创建本书中的最终游戏。你还将学习目前市场上流行的移动游戏中实现物理对象和碰撞机制的其他方法。更多令人兴奋的学习内容在等着你。让我们加油！
