- en: Chapter 5. Scene and Layer Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 场景和图层管理
- en: 'Managing scenes and layers is a necessity for a game that utilizes menus and
    multiple game levels. This chapter will cover the creation and use of a scene
    manager with the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理场景和图层对于使用菜单和多个游戏级别的游戏来说是一个必要条件。本章将介绍以下主题的场景管理器的创建和使用：
- en: Creating the scene manager
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建场景管理器
- en: Setting up the resource manager for scene resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为场景资源设置资源管理器
- en: Customizing managed scenes and layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制管理的场景和图层
- en: Setting up an activity to use the scene manager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个活动以使用场景管理器
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Creating a process to manage and handle menus and scenes for a game is one
    of the quickest ways to improve a framework. A well-designed game usually relies
    on a robust and customized scene manager to handle menus and in-game levels. There
    are various approaches to customize a scene manager, but the foundation usually
    consists of:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个管理游戏菜单和场景的过程是提高框架速度的最快方法之一。一个设计良好的游戏通常依赖于强大且定制化的场景管理器来处理菜单和游戏内的关卡。定制场景管理器的方法有很多，但基础通常包括：
- en: Switching between scenes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景之间切换
- en: Automatic loading and unloading of scene resources and elements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动加载和卸载场景资源和元素
- en: Showing a loading screen while handling scene resources and scene construction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理场景资源和构建场景时显示加载屏幕
- en: In addition to the core functions of a scene manager, we are going to create
    a method of showing layers on top of our scenes so that we can add another level
    of usability to our games.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了场景管理器的核心功能之外，我们还将创建一种在场景之上显示图层的方法，这样我们就可以为游戏添加另一层可用性。
- en: Creating the scene manager
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景管理器
- en: Creating a scene manager that just swaps the engine's current scene for another
    scene is quite simple, but not graphically appealing to players. Showing a loading
    screen while resources load and the scene is constructed has become a well-accepted
    practice in game design because it lets the player know that the game is doing
    more than just idling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个仅替换引擎当前场景为另一个场景的场景管理器相当简单，但这种做法对玩家来说并不具有图形上的吸引力。在资源加载和场景构建时显示加载屏幕已经成为游戏设计中的一种广泛接受的做法，因为它让玩家知道游戏在进行的工作不仅仅只是闲置。
- en: Getting ready...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Open the `SceneManager.java` class in this chapter's code bundle. Also, open
    the `ManagedScene.java` and `ManagedLayer.java` classes. We will be referencing
    all three of these classes throughout this recipe. The inline comments within
    the classes provide additional information to what is discussed throughout this
    recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章代码包中的`SceneManager.java`类。同时，也请打开`ManagedScene.java`和`ManagedLayer.java`类。我们将在本食谱的讨论中引用这三个类。类内的内联注释提供了关于本食谱讨论内容的额外信息。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to understand how a `SceneManager` class functions so that
    we can create a custom-tailored one for future projects:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解`SceneManager`类的功能，以便我们可以为未来的项目创建一个定制版的场景管理器：
- en: First, notice that the `SceneManager` class is created as a singleton so that
    we can access it from anywhere in our project. Furthermore, it uses the `getEngine()`
    reference provided by our `ResourceManager` class to store a local reference to
    the engine object, but this reference could be set at the creation of the `SceneManager`
    class if we opted to not use a resource manager.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请注意`SceneManager`类是作为单例创建的，这样我们就可以从项目的任何地方访问它。此外，它使用我们的`ResourceManager`类提供的`getEngine()`引用来存储对引擎对象的本地引用，但如果我们选择不使用资源管理器，这个引用可以在创建`SceneManager`类时设置。
- en: Second, note the variables created after the `getInstance()` method. The first
    two variables, `mCurrentScene` and `mNextScene`, hold references to the currently
    loaded scene and next scene to be loaded. The `mEngine` variable holds a reference
    to the engine. We will use the engine reference to set our managed scenes and
    for registering/unregistering the `mLoadingScreenHandler` update handler. The
    `mNumFramesPassed` integer counts the number of rendered frames within the update
    handler to ensure that the loading screen has been shown for at least one frame.
    The functionality of showing a loading screen is achieved by the next variable,
    `mLoadingScreenHandler`, at which we will take a closer look in the next step.
    The remaining variables are used for the management of layers and either keep
    track of the state of the layering process or hold references to entities related
    to the layering process.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，注意在`getInstance()`方法之后创建的变量。前两个变量`mCurrentScene`和`mNextScene`保存了对当前已加载场景和将要加载的场景的引用。`mEngine`变量保存了对引擎的引用。我们将使用这个引擎引用来设置我们的管理场景，以及注册/注销`mLoadingScreenHandler`更新处理器。整型变量`mNumFramesPassed`在更新处理器中计算已渲染的帧数，以确保加载屏幕至少显示了一帧。通过下一个变量`mLoadingScreenHandler`实现显示加载屏幕的功能，我们将在下一步中更详细地了解它。其余变量用于管理图层，并跟踪图层处理过程的状态或保存与图层处理过程相关的实体引用。
- en: Third, look at the `onUpdate()` method within the `mLoadingScreenHandler IUpdateHandler`
    update handler. Take note that there are two conditional blocks—the first waits
    one frame before it unloads the previous scene and subsequently loads the next,
    while the second waits until the loading screen for the next scene has been shown
    for the minimum amount of time before it hides the loading screen and resets the
    variables used by the update handler. This entire process within the update handler
    enables the use of a loading screen while `ManagedScene` loads and constructs
    itself.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，查看`mLoadingScreenHandler IUpdateHandler`更新处理器中的`onUpdate()`方法。请注意，这里有两个条件块——第一个在卸载上一个场景并随后加载下一个场景之前等待一帧，而第二个则等待直到下一个场景的加载屏幕至少显示最短时间之后，它才隐藏加载屏幕并重置更新处理器使用的变量。更新处理器中的整个这个过程使得在`ManagedScene`加载和构建自身时可以使用加载屏幕。
- en: The next method in the class is the `showScene()` method, which we will call
    when we want to navigate away from the current scene to a following scene. It
    first resets the position and size of the engine's camera to its starting location
    and size to prevent any prior adjustments to the camera from ruining the presentation
    of a new scene. Next, we check if the new scene will show a loading screen via
    the `hasLoadingScreen` property of the `ManagedScene` class.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中的下一个方法是`showScene()`方法，当我们想要从当前场景导航到一个后续场景时，我们将调用它。它首先将引擎相机的位置和大小重置为其起始位置和大小，以防止之前的任何相机调整破坏新场景的展示。接下来，我们通过`ManagedScene`类的`hasLoadingScreen`属性检查新场景是否将显示加载屏幕。
- en: If the new `ManagedScene` class' will be showing a loading screen, we set its
    child scene to the scene returned by the `onLoadingScreenLoadAndShown()` method
    and pause all of the `ManagedScene` class' renderings, updates, and touch events.
    The following `if` block ensures that a new scene can load if one is already in
    the loading stage. This case should be rare, but can happen if a new scene is
    called to be shown from the UI thread. The `mNextScene` variable is then set to
    the new `ManagedScene` class' to be used by the `mLoadingScreenHandler` update
    handler and the engine's scene is set to the new `ManagedScene` class.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果新的`ManagedScene`类将显示加载屏幕，我们将它的子场景设置为`onLoadingScreenLoadAndShown()`方法返回的场景，并暂停`ManagedScene`类的所有渲染、更新和触摸事件。下面的`if`块确保如果场景已经在加载阶段，可以加载新场景。这种情况应该很少见，但如果从UI线程调用显示新场景，则可能会发生。然后，将`mNextScene`变量设置为新的`ManagedScene`类，以供`mLoadingScreenHandler`更新处理器和引擎的场景使用。
- en: If the new `ManagedScene` class will not be showing a loading screen, we set
    the `mNextScene` variable to the new `ManagedScene` class, set the new `ManagedScene`
    class as the engine's scene, unload the previously shown scene, and load the new
    scene. If no loading screen is shown, the `showScene()` method simply acts to
    swap the new scene for the previously shown one.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果新的`ManagedScene`类不显示加载屏幕，我们将`mNextScene`变量设置为新的`ManagedScene`类，将新的`ManagedScene`类设置为引擎的场景，卸载之前显示的场景，并加载新场景。如果没有显示加载屏幕，`showScene()`方法仅用于将新场景替换为之前显示的场景。
- en: Next, take a look at the `showLayer()` method. Because our layers are shown
    on top of everything else in the game, we attach them as the camera `HUD` object's
    child scene. This method starts by first determining if the camera has a `HUD`
    object to attach a child scene. If so, it sets the `mCameraHadHud` Boolean value
    to `true`. If not, we create a placeholder HUD object and set it as the camera's
    `HUD` object. Next, if the `showLayer()` method is called to suspend rendering,
    updates, or touch events of the underlying `ManagedScene`, we set a placeholder
    scene as the `ManagedScene` scene's child scene with the modal properties passed
    to the `showLayer()` method. Finally, we set the layer's camera to the engine's
    camera, scale the layer to match the camera's screen-dependent scale, and set
    the local layer-related variables to be used by the `hideLayer()` method referenced
    in the next step.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，看看`showLayer()`方法。由于我们的层是在游戏中其他所有内容之上显示的，因此我们将它们作为相机`HUD`对象的子场景进行附加。该方法首先确定相机是否有`HUD`对象来附加子场景。如果有，它将`mCameraHadHud`布尔值设置为`true`。如果没有，我们将创建一个占位符HUD对象并将其设置为相机的`HUD`对象。接下来，如果`showLayer()`方法被调用以暂停底层`ManagedScene`的渲染、更新或触摸事件，我们将设置一个占位符场景作为`ManagedScene`场景的子场景，并传递给`showLayer()`方法的模态属性。最后，我们将层的相机设置为引擎的相机，缩放层以匹配相机的屏幕依赖性缩放，并将局部层相关变量设置为下一步引用的`hideLayer()`方法使用。
- en: The `hideLayer()` method first checks whether a layer is currently being shown.
    If it is, the camera `HUD` object's child scene is cleared, the placeholder child
    scene is cleared from the `ManagedScene` class, and the layer-showing system is
    reset.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hideLayer()`方法首先检查当前是否有层正在显示。如果有，将清除相机`HUD`对象的子场景，从`ManagedScene`类中清除占位符子场景，并重置层显示系统。'
- en: 'Follow these steps to understand how the `ManagedScene` and `Man` `gedLayer`
    classes are constructed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤了解`ManagedScene`和`ManagedLayer`类的构建方式：
- en: Looking at the `ManagedScene` class, take note of the variables listed at the
    beginning of the class. The `hasLoadingScreen` Boolean, `minLoadingScreenTime`
    float, and `elapsedLoadingScreenTime` float variables are used by the `SceneManager`
    class when it is handling the `ManagedScene` class' loading screen. The `isLoaded`
    Boolean value reflects the completion state of the `ManagedScene` class' construction.
    The first constructor is a convenient constructor in the event that no loading
    screen is needed. The second constructor sets the loading screen variables according
    to the passed value, which determines the minimum length of time that the loading
    screen should be shown. The public methods following the constructor are called
    by the `SceneManager` class and call the appropriate abstract methods, listed
    at the bottom of the class.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`ManagedScene`类，注意类开始部分列出的变量。`hasLoadingScreen`布尔值、`minLoadingScreenTime`浮点数和`elapsedLoadingScreenTime`浮点数变量由`SceneManager`类在处理`ManagedScene`类的加载屏幕时使用。`isLoaded`布尔值反映了`ManagedScene`类构建的完成状态。第一个构造函数是在不需要加载屏幕的情况下的便捷构造函数。第二个构造函数根据传递的值设置加载屏幕变量，这决定了加载屏幕应显示的最短时间。构造函数后面的公共方法由`SceneManager`类调用，并调用适当的抽象方法，这些方法列在类的底部。
- en: The `ManagedLayer` class is very similar to the `ManagedScene` class, but its
    inherent function and lack of a loading screen make it easier to create. The constructors
    set whether the layer should be unloaded after it is hidden according to the passed
    `pUnloadOnHidden` Boolean variable. The public methods following the constructors
    call the appropriate abstract methods below them.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ManagedLayer`类与`ManagedScene`类非常相似，但其固有的功能和缺少加载屏幕使其更容易创建。构造函数根据传递的`pUnloadOnHidden`布尔变量设置层在隐藏后是否应该卸载。构造函数后面的公共方法调用下面的适当抽象方法。'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The scene manager stores a reference to the engine's current scene. When the
    scene manager is told to show a new scene, it hides and unloads the current scene
    before setting the new scene as the current scene. Then, it loads and shows the
    new scene's loading screen if the scene has one. To show the loading screen before
    loading the rest of the scene, we have to allow the engine to render one frame.
    The `mNumFramesPassed` integer value keeps track of how many updates, and thus
    scene renderings, have occurred since the start of the process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器存储对引擎当前场景的引用。当告诉场景管理器显示一个新场景时，它会先隐藏并卸载当前场景，然后将新场景设置为当前场景。然后，如果场景有的话，它会加载并显示新场景的加载屏幕。为了在加载场景其余部分之前显示加载屏幕，我们必须允许引擎渲染一帧。`mNumFramesPassed`整数值跟踪自过程开始以来发生的更新次数，也就是场景渲染次数。
- en: After the loading screen is shown, or if no loading screen will be used, the
    scene manager calls the scene to load itself by calling `onLoadManagedScene()`.
    Upon completion of the load, and after the loading screen—if present—has been
    shown for a minimum amount of time, the loading screen is hidden and the scene
    is shown. In case the loading screen has not been shown for the minimum amount
    of time, we pause the scene's updates so that the scene will keep from starting
    until the loading screen is hidden. Refer to the inline comments of the supplemental
    code in `SceneManager.java` to learn even more about how this scene manager handles
    the switching of scenes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示加载屏幕之后，或者如果不需要使用加载屏幕，场景管理器通过调用`onLoadManagedScene()`让场景自行加载。加载完成后，如果存在加载屏幕，并且已经显示至少一定时间，则隐藏加载屏幕并显示场景。如果加载屏幕没有显示足够的时间，我们会暂停场景的更新，这样场景就不会在加载屏幕隐藏之前开始。要了解更多关于这个场景管理器如何处理场景切换的信息，请参考`SceneManager.java`补充代码中的内联注释。
- en: To facilitate the use of layers, the scene manager utilizes the camera's HUD
    to ensure that the layer is drawn on top of everything else. If the camera has
    a HUD already, we store it before applying the layer so that we can restore the
    original HUD after the layer is hidden. Furthermore, we have the option of pausing
    the underlying scene's updates, renderings, and touch-areas via the use of a placeholder
    scene. The placeholder scene is attached as a child to the underlying scene, so
    we must store any child scene that the underlying scene already has attached.
    The loading and showing of layers is handled by the same method call from the
    scene manager to let the layer's subclasses determine if reloading is necessary
    or if the layer should be loaded only once to reduce performance-heavy loading.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于使用图层，场景管理器利用摄像头的HUD确保图层绘制在所有其他内容之上。如果摄像头已经有了HUD，我们在应用图层之前先保存它，这样在图层隐藏后可以恢复原始的HUD。此外，我们可以通过使用占位符场景来暂停底层场景的更新、渲染和触摸区域。占位符场景作为子场景附加到底层场景，因此我们必须保存底层场景已经附加的任何子场景。场景管理器通过同一方法调用来处理图层的加载和显示，让图层的子类确定是否需要重新加载，或者是否只需加载一次以减少性能负担重的加载。
- en: See also...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Customizing managed scenes and layers* given in this chapter.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中自定义管理场景和图层*。'
- en: '*Setting up an activity to use the scene manager* given in this chapter.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中设置一个活动以使用场景管理器*。'
- en: '*Applying a HUD to the camera* in [Chapter 4](ch04.html "Chapter 4. Working
    with Cameras"), *Working with Cameras*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在第4章中为摄像头应用HUD*，*使用摄像头*。'
- en: Setting up the resource manager for scene resources
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为场景资源设置资源管理器。
- en: In order to facilitate the loading of resources by the menu and game scenes,
    the resource manager must be first set up to handle the resources. Our resource
    manager will automatically load the respective resources when we call its `loadMenuResources()`
    or `loadGameResources()` methods. Likewise, unloading resources for menus or game
    scenes that use a large amount of memory will simply be a call to the resource
    manager using `unloadMenuResources()`, `unloadGameResources()`, or `unloadSharedResources()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于菜单和游戏场景加载资源，必须首先设置资源管理器来处理这些资源。当我们调用资源管理器的`loadMenuResources()`或`loadGameResources()`方法时，它会自动加载相应的资源。同样，对于使用大量内存的菜单或游戏场景，卸载资源只需调用资源管理器的`unloadMenuResources()`、`unloadGameResources()`或`unloadSharedResources()`方法。
- en: Getting ready...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Open the `ResourceManager.java` class in this chapter's code bundle, as we will
    be referencing it for this recipe. Also, refer to the inline comments of the class
    for more information on specific portions of code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章代码包中的`ResourceManager.java`类，因为我们将参考它来完成这个配方。同时，也请查看该类的内联注释，以获取有关代码特定部分更多信息。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to understand how the `ResourceManager` class is set up
    to be used with our managed scenes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解`ResourceManager`类是如何被设置以与我们的管理场景一起使用的：
- en: Take note of the public, non-static variables defined in the `ResourceManager`
    class. The engine and context variables are used in the class when loading textures,
    but they also give us a way to access those important objects throughout our project.
    The `cameraWidth`, `cameraHeight`, `cameraScaleFactorX`, and `cameraScaleFactorY`
    variables are not used in this class, but will be used throughout the project
    for placing and scaling entities relative to the screen.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意`ResourceManager`类中定义的公共非静态变量。当加载纹理时，这个类会使用引擎和上下文变量，但它们也为我们提供了一种在整个项目中访问这些重要对象的方法。`cameraWidth`、`cameraHeight`、`cameraScaleFactorX`和`cameraScaleFactorY`变量在此类中未使用，但将在整个项目中用于相对于屏幕放置和缩放实体。
- en: Find the `setup()` method. This method sets the non-static variables referenced
    in the previous step and will be called from the overridden `onCreateResources()`
    method in our activity class. It is important that `setup()` is called prior to
    any other calls to the `ResourceManager` class as every other method and variable
    relies on the engine and context variables.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`setup()`方法。这个方法会设置前一步中引用的非静态变量，并在我们的活动类中覆盖的`onCreateResources()`方法中被调用。重要的是，在调用`ResourceManager`类的任何其他方法之前先调用`setup()`，因为其他每个方法和变量都依赖于引擎和上下文变量。
- en: Next, take a look at the static resource variables. These will be used by our
    scenes for entities or sounds and must be set before they are called. Also note
    that the static variables with a game or menu prefix will be respectively used
    by our game or menu scenes while the static variables without a prefix will be
    shared between the two types.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，看看静态资源变量。这些变量将由我们的场景用于实体或声音，并且必须在调用之前设置。还要注意，带有游戏或菜单前缀的静态变量将分别由我们的游戏或菜单场景使用，而没有前缀的静态变量将在两种类型之间共享。
- en: Now find the `loadGameResources()` and `loadMenuResources()` methods. Our managed
    game and menu scenes will call these methods when they first start. These methods
    have the important duty of calling the subsequent `ResourceManager` methods that
    set the static variables referenced in the previous step. Conversely, `unloadGameResources()`
    and `unloadMenuResources()` unload the resources for their respective scenes and
    should be called when the application's flow is finished with the resources.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在找到`loadGameResources()`和`loadMenuResources()`方法。当我们的管理游戏和菜单场景首次启动时，将调用这些方法。这些方法的重要职责是调用后续的`ResourceManager`方法，这些方法设置前一步中引用的静态变量。相反，`unloadGameResources()`和`unloadMenuResources()`卸载其各自场景的资源，并且当应用程序流程完成资源使用后应调用它们。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The resource manager, at its most basic level, provides a means of loading and
    unloading resources. In addition to this, we define a set of variables, including
    the engine and context objects, that gives us easy access to some common elements
    of the game when creating entities in our scenes. These variables can be placed
    within a game manager or object factory as well, but we will include it in our
    resource manager since most calls to the resource manager will be near code used
    to create entities.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，资源管理器提供了加载和卸载资源的手段。除此之外，我们定义了一系列变量，包括引擎和上下文对象，这让我们在创建场景中的实体时能够轻松访问游戏的某些常见元素。这些变量也可以放在游戏管理器或对象工厂中，但由于大多数对资源管理器的调用都接近于创建实体的代码，因此我们将其包含在资源管理器中。
- en: See also...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating the resource manager* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中*创建资源管理器*。
- en: '*Creating the game manager* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中*创建游戏管理器*。
- en: '*Creating object factories* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中*创建对象工厂*。
- en: Customizing managed scenes and layers
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制管理场景和图层
- en: The main purpose of the scene manager is to handle the managed scenes in our
    game. The managed scenes are highly customizable, but we want to avoid rewriting
    as much of our code as possible. To achieve that task, we will use two classes
    that extend the `ManagedScene` class, `ManagedGameScene` and `ManagedMenuScene`.
    By structuring our scene classes in this way, we will have menus and game scenes
    that share a common, respective foundation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器的主要目的是处理我们游戏中的管理场景。这些管理场景是高度可定制的，但我们希望尽可能避免重写我们的代码。为了完成这项任务，我们将使用两个扩展了
    `ManagedScene` 类的类，`ManagedGameScene` 和 `ManagedMenuScene`。通过这种方式构建我们的场景类，我们将拥有共享通用基础的菜单和游戏场景。
- en: Getting ready...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: 'Open the following classes from this chapter''s code bundle: `ManagedMenuScene.java`,
    `ManagedGameScene.java`, `MainMenu.java`, `GameLevel.java`, and `OptionsLayer.java`.
    We will be referencing these classes throughout this recipe.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章代码包中的以下类：`ManagedMenuScene.java`、`ManagedGameScene.java`、`MainMenu.java`、`GameLevel.java`
    和 `OptionsLayer.java`。我们将在本食谱中多次引用这些类。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to understand how the `ManagedMenuScene` and `ManagedGameScene`
    classes build upon the `ManagedScene` class to create customized, extendable scenes
    that can be passed to the `SceneManager` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解 `ManagedMenuScene` 和 `ManagedGameScene` 类是如何基于 `ManagedScene` 类构建的，以创建可定制的、可扩展的场景，并将其传递给
    `SceneManager` 类：
- en: Look at the `ManagedMenuScene` class. It holds only two simple constructors
    and the overridden `onUnloadManagedScene()` method. The overridden method keeps
    the `isLoaded` Boolean value from being set because we will not be taking advantage
    of the scene manager's automatic unloading of menu scenes.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看 `ManagedMenuScene` 类。它只包含两个简单的构造函数和一个重写的 `onUnloadManagedScene()` 方法。重写的方法防止了
    `isLoaded` 布尔值被设置，因为我们将不会利用场景管理器的自动卸载菜单场景功能。
- en: Now, we turn our attention to the `ManagedGameScene` class. The class starts
    off by creating an in-game `HUD` object, a loading screen `Text` object, and a
    loading screen `Scene` object. The main constructor of the `ManagedGameScene`
    class starts by setting the touch-event-binding settings of the scene to true.
    Next, the scene's scale is set to mirror the camera's screen-dependent scaling
    and the scene's position is set to the bottom-center of the camera. Finally, the
    constructor sets the HUD's scale to match the camera's scale.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向 `ManagedGameScene` 类。这个类首先创建了一个游戏内 `HUD` 对象、一个加载屏幕 `Text` 对象以及一个加载屏幕
    `Scene` 对象。`ManagedGameScene` 类的主构造函数首先将场景的触摸事件绑定设置设为真。接下来，设置场景的缩放以镜像摄像机的屏幕依赖性缩放，并将场景的位置设为摄像机的底部中心。最后，构造函数设置
    HUD 的缩放以匹配摄像机的缩放。
- en: The `ManagedGameScene` class overrides the `onLoadingScreenLoadAndShown()` and
    `onLoadingScreenUnloadAndHidden()` methods of the `ManagedScene` class to show
    and hide a simple loading screen that displays a single `Text` object.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ManagedGameScene` 类重写了 `ManagedScene` 类的 `onLoadingScreenLoadAndShown()` 和
    `onLoadingScreenUnloadAndHidden()` 方法，以显示和隐藏一个简单的加载屏幕，该屏幕显示一个单一的 `Text` 对象。'
- en: The `onLoadScene()` method from the `ManagedScene` class is overridden to construct
    a scene that represents the in-game portion of a game with a background and two
    buttons that allow the player to return to the `MainMenu` or show the `OptionsLayer`.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ManagedScene` 类的 `onLoadScene()` 方法被重写，以构建一个表示游戏内部分的场景，该场景包含一个背景和两个按钮，允许玩家返回
    `MainMenu` 或显示 `OptionsLayer`。'
- en: 'Follow these steps to understand how the `ManagedMenuScene` and `ManagedGameScene`
    classes can be extended to create the `MainMenu` and `GameLevel` scenes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解如何扩展 `ManagedMenuScene` 和 `ManagedGameScene` 类以创建 `MainMenu` 和 `GameLevel`
    场景：
- en: The `MainMenu` class is created as a singleton to prevent more than one instance
    of the class from being created and taking up valuable memory. It also foregoes
    a loading screen because it is loaded and created almost instantly. All of the
    entities that make up the `MainMenu` class are defined as class level variables
    and include the background, buttons, text, and moving entities. The scene-flow
    methods inherited from the `ManagedScene` class by the `MainMenu` class are the
    `onLoadScene()`, `onShowScene()`, `onHideScene()`, and `onUnloadScene()` methods,
    of which only the `onLoadScene()` method contains any code. The `onLoadScene()`
    method loads and constructs a scene consisting of a background, 20 horizontally-moving
    clouds, a title, and two buttons. Notice that each of the buttons makes a call
    to the scene manager—the play button shows the `GameLevel` scene and the options
    button shows `OptionsLayer`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainMenu`类被设计为单例模式，以防止创建类的多个实例从而占用宝贵的内存空间。同时，它省略了加载屏幕，因为它几乎是瞬间加载和创建的。构成`MainMenu`类的所有实体都被定义为类级别变量，包括背景、按钮、文本和移动的实体。`MainMenu`类从`ManagedScene`类继承的场景流程方法有`onLoadScene()`、`onShowScene()`、`onHideScene()`和`onUnloadScene()`，其中只有`onLoadScene()`方法包含代码。`onLoadScene()`方法加载并构建了一个场景，包括一个背景、20个水平移动的云朵、一个标题和两个按钮。注意，每个按钮都会调用场景管理器——播放按钮显示`GameLevel`场景，选项按钮显示`OptionsLayer`。'
- en: The `GameLevel` class extends the `ManagedGameScene` class and only overrides
    the `onLoadScene()` method to create and randomly position a square rectangle
    on the scene. This shows that the `ManagedGameScene` class creates the bulk of
    the `GameLevel` class and that elements that differ between levels can still use
    the same foundation created by the `ManagedGameScene` class.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameLevel`类扩展了`ManagedGameScene`类，并只覆盖了`onLoadScene()`方法，在场景中创建并随机定位一个正方形矩形。这表明`ManagedGameScene`类构成了`GameLevel`类的大部分内容，而且不同级别之间的元素仍然可以使用由`ManagedGameScene`类创建的相同基础。'
- en: 'Follow these steps to understand how the `OptionsLayer` class extends the layer-functionality
    of the `ManagedLayer` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解`OptionsLayer`类是如何扩展`ManagedLayer`类的层功能的：
- en: Concerning the `OptionsLayer` class, first notice that it is defined as a singleton,
    so that it will remain in memory after it is first created. Next, note the two
    update handlers, `SlideIn` and `SlideOut`. These animate the layer when it is
    shown or hidden and give an extra layer of graphical interest to the game. The
    update handlers simply move the layer to a specific position at a speed that is
    proportional to the `pSecondsElapsed` parameter of the `onUpdate()` method to
    make the movement smooth.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于`OptionsLayer`类，首先注意它被定义为单例，这样在首次创建后它将保留在内存中。接下来，注意两个更新处理器`SlideIn`和`SlideOut`。这些处理器在显示或隐藏层时为层添加动画效果，并为游戏提供额外的图形兴趣层。更新处理器只是简单地将层移动到`onUpdate()`方法的`pSecondsElapsed`参数成比例的特定位置，以使移动平滑。
- en: The `onLoadLayer()` method inherited from the `ManagedLayer` class is overridden
    to create a black rectangle, which acts as a background for the layer, and two
    `Text` objects that show a title and the way to exit the layer. The `onShowLayer()`
    and `onHideLayer()` methods register the appropriate update handler with the engine.
    Upon sliding the layer offscreen, notice that the `SlideOut` update handler calls
    the scene manager to hide the layer—this is how an ending animation is implemented
    using this particular sene manager's framework.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ManagedLayer`类继承的`onLoadLayer()`方法被覆盖，以创建一个作为层背景的黑色矩形和两个显示标题和退出层方式的`Text`对象。`onShowLayer()`和`onHideLayer()`方法向引擎注册适当的更新处理器。当层滑出屏幕时，注意`SlideOut`更新处理器调用场景管理器隐藏层——这就是使用这个特定场景管理器的框架实现结束动画的方式。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The single purpose of the `ManagedMenuScene` class is to override the `onUnloadManagedScene()`
    method inherited from the `ManagedScene` class to prevent the recreation of entities
    within the scene. Take note of the overridden `onUnloadScene()` method within
    the `MainMenu` class, which extends `ManagedMenuScene`. We leave it empty to ensure
    that the `MainMenu` class is kept in memory so that we can quickly switch back
    to it from the game scenes and other menus.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedMenuScene`类的唯一目的是覆盖从`ManagedScene`类继承的`onUnloadManagedScene()`方法，以防止场景内实体的重新创建。注意在扩展`ManagedMenuScene`的`MainMenu`类中覆盖的`onUnloadScene()`方法，我们将其留空以确保`MainMenu`类保留在内存中，这样我们可以从游戏场景和其他菜单快速切换回它。'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When running this project, if there are any animations in the main menu, take
    note that the animations pause while another scene is being displayed, but resume
    as soon as the main menu is shown again. This is because the main menu is not
    updated as the engine's current scene even though it is still loaded in memory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此项目时，如果主菜单中有任何动画，请注意，当另一个场景正在显示时，动画会暂停，但一旦主菜单再次显示，动画就会恢复。这是因为尽管主菜单仍然加载在内存中，但它不会作为引擎的当前场景进行更新。
- en: The `ManagedGameScene` class uses a `HUD` object to allow the game levels a
    set of controls that move with the engine's camera. Even though we add buttons
    to the `GameHud` object in this example, any control may be used on the HUD. The
    constructors that we use for the `ManagedGameScene` class set the loading screen
    duration, touch options, and the scales of the game scene and `GameHud` to improve
    the visual appeal of the game across devices. For the game scenes, we take advantage
    of the loading screens enabled by the scene manager. For the loading screen, we
    create a simple scene that shows the text, **Loading...**, but any arrangement
    of non-animated entities can be used. While the loading screen is shown, we load
    the game resources and create the game scene. In this case, a simple background
    is constructed from a single sprite, and the onscreen controls are added to the
    `GameHud` object. Notice that the controls added to the `GameHud` object are scaled
    to the inverse of the camera's scale factor. This is necessary because we want
    to create them to be the same physical size across all devices. The last method
    that we define in the `ManagedGameScene` class, `onUnloadScene()`, unloads the
    scene.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedGameScene`类使用一个`HUD`对象，允许游戏关卡拥有一组与引擎摄像机一起移动的控件。尽管在这个例子中我们将按钮添加到`GameHud`对象，但HUD上可以使用任何控件。我们为`ManagedGameScene`类使用的构造函数设置了加载屏幕的持续时间、触摸选项以及游戏场景和`GameHud`的比例，以提升游戏在不同设备上的视觉吸引力。对于游戏场景，我们利用场景管理器启用的加载屏幕。对于加载屏幕，我们创建了一个简单的场景，显示文本**Loading...**，但可以使用任何非动画实体的排列。当显示加载屏幕时，我们加载游戏资源并创建游戏场景。在这种情况下，一个简单的背景由单个精灵构建，屏幕上的控件被添加到`GameHud`对象。请注意，添加到`GameHud`对象的控件会被缩放到摄像机比例因子的倒数。这是必要的，因为我们要使它们在所有设备上具有相同的物理尺寸。在`ManagedGameScene`类中定义的最后一个方法是`onUnloadScene()`，用于卸载场景。'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Notice that we do all of the unloading on the update thread. This keeps the
    engine from trying to process an entity if it was removed earlier in the thread
    and prevents an `ArrayIndexOutOfBoundsException` exception from being thrown.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们所有的卸载操作都是在更新线程中完成的。这样做可以防止引擎尝试处理在当前线程中早已移除的实体，并防止抛出`ArrayIndexOutOfBoundsException`异常。
- en: 'For the main menu we do not need a loading screen so we simply return `null`
    in the `onLoadingScreenLoadAndShown()` method. When creating the simple sprite
    background for the main menu, we must scale it to fill the screen. Notice how
    the main menu utilizes the menu assets from the `ResourceManager` class when creating
    sprites and buttons. Also, notice that by clicking the buttons, we call the `SceneManager`
    class to load the next scene or show a layer. The following two screenshots show
    the main menu on two different devices to demonstrate how the camera scaling functions
    with the scene''s composition. The first screenshot is on a 10.1 inch Motorola
    Xoom:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主菜单，我们不需要加载屏幕，因此在`onLoadingScreenLoadAndShown()`方法中直接返回`null`。在为主菜单创建简单的精灵背景时，我们必须将其缩放以填满屏幕。注意主菜单在创建精灵和按钮时是如何使用`ResourceManager`类中的菜单资源的。同样，注意点击按钮时，我们会调用`SceneManager`类来加载下一个场景或显示一个图层。以下两张截图展示了主菜单在两个不同设备上的显示效果，以演示摄像机缩放如何与场景组合一起工作。第一张截图是在10.1英寸的摩托罗拉Xoom上：
- en: '![How it works...](img/8987OS_05_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_05_01.jpg)'
- en: 'And, the second is on a 5.3 inch Samsung Galaxy Note:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张是在5.3英寸的三星Galaxy Note上：
- en: '![How it works...](img/8987OS_05_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_05_02.jpg)'
- en: 'Our `GameLevel` class is relatively small compared to its super class, `ManagedGameScene`.
    This is because we want the levels to include only the information needed for
    each individual level. The following screenshot shows the `GameLevel` class in
    action:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GameLevel`类与其超类`ManagedGameScene`相比相对较小，这是因为我们希望每个关卡只包含各自所需的信息。以下屏幕截图展示了`GameLevel`类在实际中的使用情况：
- en: '![How it works...](img/8987OS_05_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_05_03.jpg)'
- en: 'The `OptionsLayer` class can be shown from any scene, as seen in the following
    two screenshots. The first is at the main menu:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionsLayer`类可以从任何场景中显示，如下两张截图所示。第一张是在主菜单上：'
- en: '![How it works...](img/8987OS_05_04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_05_04.jpg)'
- en: 'While the second is in-game with the `GameLevel` class loaded:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个游戏级别加载了`GameLevel`类时：
- en: '![How it works...](img/8987OS_05_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_05_05.jpg)'
- en: See also...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating the scene manager* in this chapter.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*创建场景管理器*。
- en: '*Attaching a controller to the display* in [Chapter 4](ch04.html "Chapter 4. Working
    with Cameras"), *Working wit* *Cameras*.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章. 使用相机工作")，*使用相机工作*中*连接控制器到显示*。
- en: Setting up an activity to use the scene manager
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置活动以使用场景管理器
- en: Because of the way that our scene manager works, setting it up for use by an
    `Activity` class that extends AndEngine's `BaseGameActivity` class requires little
    effort. We are also going to implement an accurate screen-resolution scaling approach
    to ensure a consistent appearance across all devices. The `SceneManager` class
    and `ManagedScenes` class rely on the variables defined in the `ResourceManager`
    class to register update handlers and create entities. As we go through the recipe,
    take note that we set up the `ResourceManager` class prior to using any functions
    of the `SceneManager` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的场景管理器的工作方式，将其实例化以供扩展了AndEngine的`BaseGameActivity`类的`Activity`类使用需要很少的努力。我们还将实现一个精确的屏幕分辨率缩放方法，以确保所有设备上的外观一致性。`SceneManager`类和`ManagedScenes`类依赖在`ResourceManager`类中定义的变量来注册更新处理程序和创建实体。在查看这个指南时，请注意我们在使用`SceneManager`类的任何功能之前设置`ResourceManager`类。
- en: Getting ready...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Create a new activity that extends AndEngine's `BaseGameActivity` class, or
    load one that you have already created. Adapting an existing activity to use the
    scene manager requires the same steps as a new one would require, so do not worry
    about starting over on a project just to implement the scene manager.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个扩展了AndEngine的`BaseGameActivity`类的新活动，或者加载你已经创建的一个。将现有活动适配为使用场景管理器需要与新建活动相同的步骤，因此不必担心重新开始一个项目以实现场景管理器。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to prepare an activity to use our scene manager:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤准备一个活动以使用我们的场景管理器：
- en: 'Define the following variables in your activity to handle accurate screen-resolution
    scaling. Doing so will make onscreen elements almost physically identical across
    all Android devices:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的活动中定义以下变量以处理精确的屏幕分辨率缩放。这样做可以使屏幕元素在所有安卓设备上几乎物理上一致：
- en: '[PRE0]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Place the following method in the activity''s class to handle the **Back**
    button:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动类的相应位置添加以下方法来处理**返回**按钮：
- en: '[PRE1]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, fill the `onCreateEngineOptions()` method with the following code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用以下代码填充`onCreateEngineOptions()`方法：
- en: '[PRE2]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Place the following line in the `onCreateResources()` method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreateResources()`方法中放置以下行：
- en: '[PRE3]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, add the following code to the `onCreateScene()` method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onCreateScene()`方法中添加以下代码：
- en: '[PRE4]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first thing that we do is to define the attributes of our development device's
    screen so that we can make the calculations to ensure that all players see our
    game as close to the way that we see it as possible. The calculations are actually
    handled in the `onCreateEngineOptions()` method as shown in the third step. For
    the engine options, we enable sounds, music, dithering for smooth gradients, multisampling
    for smooth edges, and wake-lock to keep our game's resources from being destroyed
    if the player briefly switches away from our game.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义开发设备屏幕的属性，以便我们可以进行计算，确保所有玩家尽可能接近我们看待游戏的方式。实际上，计算是在第三步中展示的`onCreateEngineOptions()`方法中处理的。对于引擎选项，我们启用了声音、音乐、平滑渐变的抖动处理、平滑边缘的多重采样以及防止玩家短暂切换到其他应用时游戏资源被销毁的唤醒锁定。
- en: In step 4, we set up the `ResourceManager` class by passing it the `Engine`
    object, `Context`, the current camera width and height, and the ratio of the current
    camera's size to the design device's screen size. Lastly, we tell the `SceneManager`
    class to show the main menu, and we pass the `MainMenu` class as the engine's
    scene via the `pOnCreateSceneCallback` parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们通过传递`Engine`对象、`Context`、当前相机宽度和高度以及当前相机尺寸与设计设备屏幕尺寸的比例来设置`ResourceManager`类。最后，我们告诉`SceneManager`类显示主菜单，并通过`pOnCreateSceneCallback`参数将`MainMenu`类作为引擎的场景传递。
- en: See also...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Creating the scene manager* in this chapter.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*创建场景管理器*。
- en: '*Know the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"),
    *AndEngine Game Structure*.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中了解*生命周期*。
