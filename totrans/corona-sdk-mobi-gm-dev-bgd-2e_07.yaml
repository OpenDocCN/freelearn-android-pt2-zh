- en: Chapter 7. Physics – Falling Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*There are many variations on how to incorporate a physics engine using display
    objects. So far, we have worked on removing objects with collisions, moving objects
    through the stage area, and launching objects by applying force against gravity,
    just to name a few. Now, we will explore another mechanism that allows gravity
    to control the environment. The next game we''ll create deals with falling physical
    objects.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Work with more physics bodies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the body construction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track the objects caught
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with postcollisions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create falling objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's to creating another fun, simple game in this chapter. Let's get cracking!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Creating our new game – Egg Drop
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every step taken so far has taught us more about game development on iOS/Android
    devices. In this new segment, our game will include sound effects, which will
    enhance the sensory experience in our games.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you are using the latest stable build of Corona SDK.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The new game that we will create is called Egg Drop. The player controls the
    main character, which is a lumberjack with a frying pan. During game play, eggs
    start falling from the sky, and it is the lumberjack's job to catch the eggs in
    his frying pan and not let them hit the ground. Every egg caught earns 500 points.
    The player starts with three lives. When an egg fails to hit the frying pan and
    hits the ground, a life is lost. When all three lives are gone, the game is over.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: When starting the new game project, be sure to grab the `Egg` `Drop` file from
    the `Chapter` `7` folder. You can download the project files accompanying this
    book from the Packt Publishing website at [http://www.packtpub.com/](http://www.packtpub.com/).
    It contains all the necessary files that are built out for you, such as the `build.settings`,
    `config.lua`, and audio files, and the art assets needed for the game. You'll
    then have to create a brand new `main.lua` file in the project folder before you
    start coding.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our new game – Egg Drop](img/9343OT_07_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Starting variables
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will be our first full game setup, which will be filled with notable Corona
    SDK features. We'll combine our base knowledge of what we have learned so far
    with variables, display objects, the physics engine, touch/accelerometer events,
    and audio. Many of Corona's APIs are easy to use and understand. This shows the
    fast learning curve with Corona just by having basic to no knowledge of programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the variables
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with introducing the variables we''ll be using to create
    our game. There will be a combination of display objects and integers to keep
    count; we also need to preload the main sound effects used during game play. Follow
    the steps to declare all the required variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Hide the status bar and add in the `display.newGroup()` group called `gameGroup`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Include the external modules in the game:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add in the display objects:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add in the variables:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the egg boundaries and density:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Setup the accelerometer and audio:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We continued creating a similar set up of our variables, like we did in the
    Panda Star Catcher game. It's more efficient to organize them by separating groups,
    display objects, audio, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Many of the variables displayed have designated integers that fulfill the goals
    of game play. This includes values such as `gameLives` `=` `3` and `eggCount`
    `=` `0`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the main character
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accelerometer events work best within the main scope of the game. It enables
    you to view the full real estate of the game environment, without having to interact
    with touches on the screen. Necessary touch events would make sense for user interface
    buttons such as pause, menu, play, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – moving the character
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eggs will be falling in all different areas of the screen from the sky. Let''s
    prepare our main character to move through all the potential areas on the screen:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new local function called `moveChar()` with an `event` parameter:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add in the accelerometer movement for the character:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create character boundaries where it moves on the screen. This enables the
    character to stay within the game screen and not go past the offscreen boundaries:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for the landscape mode,
    the `xGravity` and `yGravity` values are switched to compensate for the events
    to work properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the code in step 3 keeps the `charObject` display object from going
    past any wall border boundaries.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding touch events
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The character is currently controlled by the accelerometer. Another option to
    control the character is through a touch event. Try replacing the event listener
    with `"touch"` and using event parameters so that the touch event works properly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If you remember how we incorporated the paddle movement with Breakout in [Chapter
    3](ch03.html "Chapter 3. Building Our First Game – Breakout"), *Building Our First
    Game – Breakout* and [Chapter 4](ch04.html "Chapter 4. Game Controls"), *Game
    Controls*, for the simulator, it should be very similar.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Updating the score
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the score is updated, it refers to our text display objects and translates
    the value from the number into a string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous example, you will notice that we set a value of `100` to `gameScore`.
    In the following lines for `scoreText`, `gameScore` is used to concatenate the
    "`Score:` " string and the value of `gameScore`. Doing so displays the value of
    `gameScore` in a string format by `scoreText`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting the score
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Who doesn''t like some friendly competition? We''re familiar with scoreboards
    from the games we made in the previous chapters. So, we are not strangers to tracking
    the score. Perform the following steps to set the score:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不喜欢友好的竞争呢？我们对前面章节中制作的游戏的计分板很熟悉。因此，我们对跟踪得分并不陌生。执行以下步骤来设置得分：
- en: 'Create a local function called `setScore()` with a parameter called `scoreNum`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setScore()`的局部函数，它有一个名为`scoreNum`的参数：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the variables to count the score:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置变量以计算得分：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Have the score updated when points are earned in game play and close the function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在游戏玩法中获得分数时更新得分，并关闭函数：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*What just happened?*'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: When `setScore(scoreNum)` is called within any function, it will refer to all
    the methods using the `gameScore` variable. Assuming `gameScore` `=` `0` at the
    start of the application, the value increments to what `gameScore` is set to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当在任何函数内调用`setScore(scoreNum)`时，它将引用使用`gameScore`变量的所有方法。假设在应用程序开始时`gameScore`
    `=` `0`，则该值会增加到`gameScore`设置的数量。
- en: 'In `scoreText.text` `=` `"Score: " .. gameScore`, `"Score: "` is the string
    that displays on the device during game play. The `gameScore` variable takes the
    current value given to the variable and displays it as a string.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '在`scoreText.text` `=` `"Score: " .. gameScore`中，`"Score: "`是在游戏过程中在设备上显示的字符串。`gameScore`变量获取赋予变量的当前值并将其显示为字符串。'
- en: Displaying the game environment
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示游戏环境
- en: A logical setting for your display objects helps the player envision the relationship
    between the main character and the environment. Since our main character is a
    lumberjack, it would make sense to have him set in a forest or an area focused
    entirely on nature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为显示对象设置逻辑环境可以帮助玩家想象主角与环境之间的关系。由于我们的主角是伐木工人，将他在一个森林或完全专注于自然的环境中设置是有意义的。
- en: Time for action – drawing the background
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——绘制背景
- en: 'In this section, we''ll fill the screen with our environment display objects.
    This includes our background and ground objects, and we can also add physical
    elements to our ground so that we can designate collision events for it. To draw
    the background, perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将屏幕用环境显示对象填充。这包括我们的背景和地面对象，我们还可以为地面添加物理元素，以便我们可以为其指定碰撞事件。要绘制背景，请执行以下步骤：
- en: 'Create a local function called `drawBackground()`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`drawBackground()`的局部函数：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add in the background image:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加背景图像：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add in the ground elements and create the ground physical boundary. Close the
    function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加地面元素并创建地面物理边界。关闭函数：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `background` and `ground` display objects are placed in the function called
    `drawBackground()`. The `display.newImageRect()`function is used since we are
    incorporating dynamic scaling on some of our images. The ground display object
    has a customized physical shape that is not of the same size as the original display
    object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`background`和`ground`显示对象被放置在名为`drawBackground()`的函数中。由于我们对一些图像进行了动态缩放，因此使用了`display.newImageRect()`函数。地面显示对象有一个自定义的物理形状，其大小与原始显示对象不同。'
- en: Our `background` object is centered to the dimensions of the device screen area
    and inserted in `gameGroup`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`background`对象被居中到设备屏幕区域的尺寸中，并插入到`gameGroup`。
- en: The `ground` display object is placed near the bottom of the display area. It
    is assigned a name through `ground.myName` `=` `"ground"`. We'll use the name
    `"ground"` later on to determine collision events. A customized physical boundary
    is made for the ground through `groundShape`. This allows the body of the ground
    to affect the assigned dimensions of the display object. When `physics.addBody()`
    is initialized, we used `groundShape` as the shape parameter. Next, `ground` is
    set to `gameGroup` as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ground`显示对象被放置在显示区域的底部附近。通过`ground.myName` `=` `"ground"`为其分配一个名称。我们将在后面使用名称`"ground"`来确定碰撞事件。通过`groundShape`为地面创建了一个自定义的物理边界。这使得地面的主体可以影响显示对象的指定尺寸。当初始化`physics.addBody()`时，我们使用了`groundShape`作为形状参数。接下来，将`ground`也设置为`gameGroup`。'
- en: Displaying the heads-up display
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示抬头显示器
- en: In gaming, the **heads-up** **display** (**HUD**) is the method used to relay
    information visually to the player. In many games, the common features displayed
    are health/lives, time, weapons, menus, maps, and so on. This keeps your player
    alert to what is currently happening during game play. When it comes to tracking
    your lives, you want to be informed how many are left before your character runs
    out of chances to continue playing and the game ends.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – designing the HUD
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While trying to make the player''s gaming experience an enjoyable one, it''s
    important that the information displayed is relevant to the game and placed strategically,
    so that it doesn''t interfere with the main gaming area. So, to design the HUD,
    perform the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `hud()`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Display the text for the eggs that are caught during game play:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add in text to track the lives:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add in text for the score and close the function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Time for action – designing the HUD](img/9343OT_07_02.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `eggText` display object can be found near the bottom-right corner of the
    screen. It''s still in view to the user while in game play and stays out of the
    main focus at the same time. Notice that `eggText = display.newText( "Caught:
    " .. eggCount, 0, 0, "Arial", 45 )` will refer to `eggCount` when the value is
    updated.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The `livesText` display object setup is similar to `eggText`. It is placed near
    the top-right corner of the screen. The placement for this object is rather prominent
    because of its importance in the game. It's in an area that is noticeable from
    the background and allows the player to refer to during the game. The `livesText`
    display object decrements the number when `gameLives` is updated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The initial setup for `scoreText` starts in the `hud()` function. It is placed
    in the top-left corner of the screen, opposite to `livesText`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game lives
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are no consequences in a game, then there is no sense of urgency to
    complete the main objectives. To keep a player engaged during game play, introducing
    elements that add some challenging aspects will keep the competitiveness and excitement
    going. Adding consequences in a game creates tension for the player and gives
    them more motivation to stay alive.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – counting the lives
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tracking the lives left in the game keeps the player updated on how much sooner
    it will be till the game is over. To count the remaining lives in the game, perform
    the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the function called `livesCount()`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Display the text for lives every time the number is decremented:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*What just happened?*'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `livesCount()` function is a separate function that updates `gameLives`.
    It makes sure that you're aware that `gameLives = gameLives – 1`. This decreases
    the set value instantiated in the beginning of the code. When `gameLives` changes
    values, it displays the update through `livesText`. The `print` statement is used
    towards the end of the function to track the count in the terminal window.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When `gameLives < 1`, the `callGameOver()` function will be called and show
    the game over element of the game.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding images for the game lives
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the game uses display text on screen to show how many lives are left
    during game play. A way to make the HUD display more appealing is by creating/adding
    small icons that correlate with the game, such as eggs or a frying pan.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Three separate display objects need to be created and placed in an orderly fashion
    so that when a life is taken away, the alpha of the object is reduced to 0.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A method needs to be created so that all the three display objects are affected
    when the game lives are reduced to zero.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the main character
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our main character will be animated for every action applied during game play.
    We will also create a complex body construction since the focus of its collision
    points will be on the object the character is holding, and not on their entire
    body.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Complex body construction
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to construct a body from multiple elements. Each body element
    is specified as a separate polygon shape with its own physical properties.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Since collision polygons in Box2D must be convex, any game object with a concave
    shape must be constructed by appending multiple body elements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for a complex body is the same as the simple polygon body constructor,
    except that it has more than one body element listed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Each body element may have its own physical properties, along with a shape
    definition for its collision boundaries. Here is an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As in the simpler cases, the `bodyType` attribute is optional and will default
    to `"dynamic",` if not specified.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the character
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main character was created with a sprite sheet and needs to be set up to
    view the animation it provides. Other display images that will make an appearance
    include a cracked egg when a collision to a physical object has been made. To
    create the character, perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `createChar()`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the sprite sheet for the main character:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set the starting position and physical properties for the main character:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add in the transition image after the egg has made a collision:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Time for action – creating the character](img/9343OT_07_03.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The image sheet being referred to is called `sheetData` and takes the first
    `4` frames of animation from `"charSprite.png"`. We created an animation set called
    `"move"`. Every time `"move"` is called, it starts the animation from frame `1`
    and plays `4` frames from the start at `400` milliseconds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The main display object is called `charObject` and takes on the characteristics
    of `sheetData`. When it calls `setSequence("move")`, that animation sequence plays
    when the `play()` command is executed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: An important change to the physical body of the character is that its main collision
    point will be directed towards the frying pan used in the animation. Any collision
    detection on the character's body will not be read. The `charObject` display object
    is given a name called `"character"`, which will be used to detect the collision
    with the falling egg.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We have also placed the fried egg in this function, to prepare it for the collision.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Adding postcollisions
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to make sure that when an object has interacted with another, an event
    type occurs right after. At the instance of a postcollision, we can confirm the
    collision force between two objects. This helps us determine that the object that
    was destroyed was completed with a set amount of force.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful about how you handle the Box2D physics engine. It will crash during
    a collision if Corona code attempts to modify objects still involved in the collision,
    since Box2D is still working out iterated mathematics on them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: For crash-proof collision detection, do not have collisions occur immediately.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Do not modify/create/destroy physics objects during a collision, in order to
    prevent crashing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: If you need to modify/create/destroy an object as a result of a collision, your
    collision handler should set a flag or add a time delay so that the change can
    occur later, with `timer.performWithDelay()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Body properties
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the native Box2D methods have been made into simpler dot properties
    for display objects. The following examples show that a body, `newBody`, has been
    created using one of the constructor methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: body.isAwake
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for the current awake state. By default, all bodies automatically
    *go* *to* *sleep* when there is no interaction with them for a couple of seconds.
    Bodies stop simulating until some kind of collision or other interaction wakes
    them up.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: body.isBodyActive
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for the active state of a body. Inactive bodies are not destroyed,
    but they are removed from the simulation and cease to interact with other bodies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: body.isBullet
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body that is treated like a *bullet*. Bullets are subject
    to continuous collision detection. The default is `false`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: body.isSensor
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean property that sets the `isSensor` property across all elements
    in the body. A sensor passes through other objects instead of bouncing off them,
    but detects some collision. This property acts across all body elements and will
    override any `isSensor` settings on the elements themselves.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: body.isSleepingAllowed
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body that is allowed to go to sleep. A body that is
    awake is useful in cases such as tilt gravity, since sleeping bodies do not respond
    to changes in global gravity. The default is `true`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: body.isFixedRotation
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body whose rotation should be locked, even if the body
    is about to load or subjected to off-center forces. The default is `false`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: body.angularVelocity
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value of the current rotational velocity in degrees per second.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: body.linearDamping
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value for how much the linear motion of a body is damped. This is
    the rate of decrease of angular velocity over time. The default is zero.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: body.angularDamping
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value for how much the rotation of a body should be damped. The
    default is zero.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: body.bodyType
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a string value for the type of physical body being simulated. The available
    values are `"static"`, `"dynamic"`, and `"kinematic"`, which are explained here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '`static` bodies don''t move or interact with each other. Examples of static
    objects would include the ground or the walls of a maze.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic` bodies are affected by gravity and collisions with other body types.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kinematic` objects are affected by forces but not by gravity. Bodies that
    are draggable objects should be set to `"kinematic"` for the duration of the drag
    event.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default body type is `"dynamic"`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Time for action – creating the egg collision
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have handled collisions in the previous sample games we created. Handling
    postcollisions requires the introduction of force to execute the completion of
    a postcollision event:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `onEggCollision()` with two parameters called
    `self` and `event`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create an `if` statement when the force is greater than `1` and include `not`
    `self.isHit`. Add in the `eggCaughtSound` sound effect:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make `self` invisible and inactive, and replace it with the `friedEgg` display
    object:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a function that transitions the `friedEgg` display object and fades
    it off the stage by using the `onComplete` command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using `if` `event.other.myName == "character"`, update `eggCount` when the
    main character catches the eggs. Also, update `gameScore` by `500` points for
    every collision. If the egg hits the ground, use `elseif event.other.myName ==
    "ground"` and decrement the lives using `livesCount()`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Time for action – creating the egg collision](img/9343OT_07_04.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `onEggCollision( self, event )`, we set up the function with an `if` statement
    for `event.force > 1 and not self.isHit`. When both statements return `true`,
    the sound effect for the egg plays. The initial egg falling from the sky is removed
    from the scene upon collision and replaced by the `friedEgg` display object in
    the same location, using `friedEgg.x = self.x; friedEgg.y = self.y`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The `fadeEgg()`function makes the newly replaced egg object appear in `50` milliseconds
    by `transition.to( eggCrack, { time=50, alpha=1.0, onComplete=fadeCrack } )` and
    then with the `onComplete` command, it returns the object to an invisible state
    with `transition.to( eggCrack, { time=500, alpha=0 } )`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: When the name `"character"` is called from `event.other.myName`, every collision
    assigned to that name increments `eggCount + 1`. Therefore, `eggText` is updated
    with the `eggCount` value. The `setScore( newScore )` statement increments the
    score by `500` with every collision made to `"character"`. When a collision is
    made to `"ground"`, the `livesCount()` function is called, which subtracts life
    by `1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Making the display objects fall
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will apply the main asset (egg object) by learning how to add physical objects
    to the scene and have them fall in random areas in the game. The physics engine
    will take into account a dynamic physics body that we will create for the egg
    display object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the egg object
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine a world, full of falling eggs. It''s not entirely too realistic, but
    in this game, we''re creating this element. At least, we''ll be making sure that
    both gravity and real-world physics will be applied. To add the egg object, perform
    the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `eggDrop()`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add in the `egg` display object properties:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add in the `postCollision` event for the `egg` display object:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Time for action – adding the egg object](img/9343OT_07_05.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set the `egg` value for `x` with `240 + mRand( 120 )`. The `mRand` function
    is equal to `math.random`, which will allow the egg to appear in randomized places
    in an area of `120` pixels, starting at 50 in the *x* direction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: It is vital to make sure that `egg.isHit = false` for the collision event to
    apply correctly. The physics body is set to `"dynamic"` so that it reacts to gravity
    and makes the object fall. There is a customized density and shape made for the
    egg we have created, which was already made at the beginning of the code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The last important detail for the collision to work is adding `egg` to the `onEggCollision()`
    function with `egg.postCollision = onEggCollision` and then making the event listener
    use the `"postCollision"` event with `egg:addEventListener( "postCollision", egg
    )`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the egg drop
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to execute the timer for the eggs, so that they can start dropping
    on the screen. To make the egg drop, perform the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local function called `eggTimer()` and use `timer.performWithDelay`
    to drop an egg every 1 second (`1000` milliseconds) repeatedly. Use `eggDrop()`
    to activate the drop:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Within the first `if` statement in the `onEggCollision()` function, cancel
    the timer using the `timerID` and `startDrop` variables. Add the `if` `gameLives
    < 1` statement then to stop the eggs from falling:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*What just happened?*'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for the eggs to start dropping from the sky, we created a function
    called `eggTimer()`. It activates the `eggDrop()` function by letting an egg drop
    after `1000` milliseconds (1 second) every time infinitely using `startDrop =
    timer.performWithDelay( 1000, eggDrop, 0 )`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking to `onEggCollision()`, we want to check whether `gameLives` has
    reached less than `1`. When this statement is true, the eggs will stop dropping.
    This is done using `timer.cancel( startDrop )`. The `timerID` we set in `eggTimer()`
    is `startDrop`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game play
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every start of a game always has an ending, whether it is a simple *You* *Win*
    or *You* *Lose* or just a *Game* *Over*; all these give closure to the player.
    It's important to notify a player of such events, so that they can reflect on
    the achievements earned.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – calling game over
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make sure that when a game over display screen pops up, any of our
    display objects that are currently in motion stop moving, and the event listeners
    are deactivated. Aside from the visual display of our game over screen, we''ll
    be adding a sound notification that will also help to trigger the event. To end
    the game, perform the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `callGameOver()` and place it after the
    `setScore()` function and before the `drawBackground()` function:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Introduce the sound effects when the game over display pops up. Have `gameIsActive`
    set to `false` and pause the physics in the game:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a shade that overlays the current background:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Display the game over window and reiterate the final score:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Have the score display on the game over screen:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Time for action – calling game over](img/9343OT_07_06.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `gameOver()` function triggers our `gameOverSound` sound effect that we
    preloaded at the beginning of our code. We made sure no events, such as the motion
    from the accelerometer, are disabled through `gameIsActive = false`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The elements of our display objects appear at this point in time with `shade`,
    `gameOverScreen`, and `scoreText`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, `scoreText` disappears when game play has ended by `scoreText.isVisible
    = false` and then reappears in a different area of the screen, using `timer.performWithDelay(
    0, function() scoreText.isVisible = true; end, 1 )`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Starting the game
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will activate all the remaining functions and have them run accordingly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – activating the game
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all the game play elements set in place, it is time to get the application
    started by using the following steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `gameActivate()` and insert `gameIsActive
    = true`. Place the function above the `moveChar()` function:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`gameActivate()`的新局部函数，并插入`gameIsActive = true`。将此函数放在`moveChar()`函数上方：
- en: '[PRE53]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Initialize all the game actions by making a new function called `gameStart()`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`gameStart()`的新函数来初始化所有游戏动作：
- en: '[PRE54]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Start the physics property and set the gravity for the falling object:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动物理属性并为下落物体设置重力：
- en: '[PRE55]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Activate all the functions instantiated. Add an event listener for the `charObject`,
    using the `"accelerometer"` event for the `moveChar()` function:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活所有实例化的函数。为`charObject`添加事件监听器，使用`"accelerometer"`事件监听`moveChar()`函数：
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Instantiate the `gameStart()` function and return the `gameGroup` group:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`gameStart()`函数并返回`gameGroup`组：
- en: '[PRE57]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*What just happened?*'
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: If you remember, in the beginning of our code, we set `gameIsActive = false`.
    We will now change this status through the `gameActivate()` function and make
    `gameIsActive = true`. We made the `gameStart()` function apply all the initial
    game play elements. This includes the start of the physics engine and gravity.
    At the same time, we took the remainder of all the functions and initialized them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在我们的代码开始时，我们设置了`gameIsActive = false`。现在我们将通过`gameActivate()`函数改变这个状态，使`gameIsActive
    = true`。我们让`gameStart()`函数应用所有初始游戏元素。这包括物理引擎和重力的启动。同时，我们取所有函数的余数并初始化它们。
- en: Once all the functions are activated, `gameGroup` needs to be returned so that
    all the display objects appear during the game play.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有函数被激活，需要返回`gameGroup`，以便在游戏进行时显示所有显示对象。
- en: To make sure that your physical object boundaries for your display objects are
    in the right place, use `physics.setDrawMode( "hybrid" )` in the `gameStart()`
    function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的显示对象的物理对象边界位于正确位置，在`gameStart()`函数中使用`physics.setDrawMode( "hybrid" )`。
- en: Pop quiz – animating the graphics
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验 - 动画图形
- en: Q1\. What retrieves or sets the text string of a text object?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1. 什么可以检索或设置文本对象的文本字符串？
- en: '`object.text`'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object.text`'
- en: '`object.size`'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object.size`'
- en: '`object:setTextColor()`'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object:setTextColor()`'
- en: None of the above
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Q2\. What function converts any argument into a string?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2. 什么函数将任何参数转换成字符串？
- en: '`tonumber()`'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tonumber()`'
- en: '`print()`'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print()`'
- en: '`tostring()`'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tostring()`'
- en: '`nil`'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nil`'
- en: Q3\. What body type is affected by gravity and collisions with the other body
    types?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 问题3. 哪种体型受到重力和与其他体型碰撞的影响？
- en: dynamic
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态
- en: kinematic
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动力学
- en: static
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态
- en: None of the above
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The game play construction of our application is now completed. Now that we're
    familiar with a variety of ways to use the physics engine, it goes to show the
    ease of using Box2D for designing other games that involve physics bodies.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的游戏玩法构建现在已完成。现在我们熟悉了使用物理引擎的各种方式，这表明使用Box2D设计涉及物理体的其他游戏是多么容易。
- en: 'We now have a better idea of:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对以下内容有了更好的了解：
- en: Applying the uses of dynamic and static physics bodies
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用动态和静态物理体的使用
- en: Constructing a customized shape for the physical properties of our display objects
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的显示对象的物理属性构建自定义形状
- en: Tracking the number of objects caught using values from variables that are given
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定变量的值跟踪捕获的对象数量
- en: Using postcollisions to switch out images
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后碰撞来切换图像
- en: In the next chapter, we will complete the gaming experience by creating versatile
    menu screens by using the Composer API. You will also learn how to add the pause
    action, save high scores, and understand more about data saving and unloading
    files.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用Composer API创建多功能菜单屏幕来完成游戏体验。你还将学习如何添加暂停动作，保存高分以及了解有关数据保存和卸载文件更多信息。
- en: Using Corona SDK has helped us design and develop games in a minimal amount
    of time. Let's continue adding the final touches to our game!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Corona SDK帮助我们以最少的时间设计和开发游戏。让我们继续为我们的游戏添加最后的润色！
