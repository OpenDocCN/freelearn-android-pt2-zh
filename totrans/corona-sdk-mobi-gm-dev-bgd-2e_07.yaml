- en: Chapter 7. Physics – Falling Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*There are many variations on how to incorporate a physics engine using display
    objects. So far, we have worked on removing objects with collisions, moving objects
    through the stage area, and launching objects by applying force against gravity,
    just to name a few. Now, we will explore another mechanism that allows gravity
    to control the environment. The next game we''ll create deals with falling physical
    objects.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with more physics bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the body construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track the objects caught
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with postcollisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create falling objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's to creating another fun, simple game in this chapter. Let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Creating our new game – Egg Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every step taken so far has taught us more about game development on iOS/Android
    devices. In this new segment, our game will include sound effects, which will
    enhance the sensory experience in our games.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you are using the latest stable build of Corona SDK.
  prefs: []
  type: TYPE_NORMAL
- en: The new game that we will create is called Egg Drop. The player controls the
    main character, which is a lumberjack with a frying pan. During game play, eggs
    start falling from the sky, and it is the lumberjack's job to catch the eggs in
    his frying pan and not let them hit the ground. Every egg caught earns 500 points.
    The player starts with three lives. When an egg fails to hit the frying pan and
    hits the ground, a life is lost. When all three lives are gone, the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: When starting the new game project, be sure to grab the `Egg` `Drop` file from
    the `Chapter` `7` folder. You can download the project files accompanying this
    book from the Packt Publishing website at [http://www.packtpub.com/](http://www.packtpub.com/).
    It contains all the necessary files that are built out for you, such as the `build.settings`,
    `config.lua`, and audio files, and the art assets needed for the game. You'll
    then have to create a brand new `main.lua` file in the project folder before you
    start coding.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our new game – Egg Drop](img/9343OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will be our first full game setup, which will be filled with notable Corona
    SDK features. We'll combine our base knowledge of what we have learned so far
    with variables, display objects, the physics engine, touch/accelerometer events,
    and audio. Many of Corona's APIs are easy to use and understand. This shows the
    fast learning curve with Corona just by having basic to no knowledge of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with introducing the variables we''ll be using to create
    our game. There will be a combination of display objects and integers to keep
    count; we also need to preload the main sound effects used during game play. Follow
    the steps to declare all the required variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hide the status bar and add in the `display.newGroup()` group called `gameGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the external modules in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the display objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the egg boundaries and density:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Setup the accelerometer and audio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We continued creating a similar set up of our variables, like we did in the
    Panda Star Catcher game. It's more efficient to organize them by separating groups,
    display objects, audio, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the variables displayed have designated integers that fulfill the goals
    of game play. This includes values such as `gameLives` `=` `3` and `eggCount`
    `=` `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the main character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accelerometer events work best within the main scope of the game. It enables
    you to view the full real estate of the game environment, without having to interact
    with touches on the screen. Necessary touch events would make sense for user interface
    buttons such as pause, menu, play, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – moving the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eggs will be falling in all different areas of the screen from the sky. Let''s
    prepare our main character to move through all the potential areas on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new local function called `moveChar()` with an `event` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the accelerometer movement for the character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create character boundaries where it moves on the screen. This enables the
    character to stay within the game screen and not go past the offscreen boundaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for the landscape mode,
    the `xGravity` and `yGravity` values are switched to compensate for the events
    to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the code in step 3 keeps the `charObject` display object from going
    past any wall border boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The character is currently controlled by the accelerometer. Another option to
    control the character is through a touch event. Try replacing the event listener
    with `"touch"` and using event parameters so that the touch event works properly.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember how we incorporated the paddle movement with Breakout in [Chapter
    3](ch03.html "Chapter 3. Building Our First Game – Breakout"), *Building Our First
    Game – Breakout* and [Chapter 4](ch04.html "Chapter 4. Game Controls"), *Game
    Controls*, for the simulator, it should be very similar.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the score is updated, it refers to our text display objects and translates
    the value from the number into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, you will notice that we set a value of `100` to `gameScore`.
    In the following lines for `scoreText`, `gameScore` is used to concatenate the
    "`Score:` " string and the value of `gameScore`. Doing so displays the value of
    `gameScore` in a string format by `scoreText`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Who doesn''t like some friendly competition? We''re familiar with scoreboards
    from the games we made in the previous chapters. So, we are not strangers to tracking
    the score. Perform the following steps to set the score:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local function called `setScore()` with a parameter called `scoreNum`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the variables to count the score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Have the score updated when points are earned in game play and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `setScore(scoreNum)` is called within any function, it will refer to all
    the methods using the `gameScore` variable. Assuming `gameScore` `=` `0` at the
    start of the application, the value increments to what `gameScore` is set to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `scoreText.text` `=` `"Score: " .. gameScore`, `"Score: "` is the string
    that displays on the device during game play. The `gameScore` variable takes the
    current value given to the variable and displays it as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the game environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A logical setting for your display objects helps the player envision the relationship
    between the main character and the environment. Since our main character is a
    lumberjack, it would make sense to have him set in a forest or an area focused
    entirely on nature.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – drawing the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll fill the screen with our environment display objects.
    This includes our background and ground objects, and we can also add physical
    elements to our ground so that we can designate collision events for it. To draw
    the background, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local function called `drawBackground()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the background image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the ground elements and create the ground physical boundary. Close the
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `background` and `ground` display objects are placed in the function called
    `drawBackground()`. The `display.newImageRect()`function is used since we are
    incorporating dynamic scaling on some of our images. The ground display object
    has a customized physical shape that is not of the same size as the original display
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Our `background` object is centered to the dimensions of the device screen area
    and inserted in `gameGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ground` display object is placed near the bottom of the display area. It
    is assigned a name through `ground.myName` `=` `"ground"`. We'll use the name
    `"ground"` later on to determine collision events. A customized physical boundary
    is made for the ground through `groundShape`. This allows the body of the ground
    to affect the assigned dimensions of the display object. When `physics.addBody()`
    is initialized, we used `groundShape` as the shape parameter. Next, `ground` is
    set to `gameGroup` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the heads-up display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In gaming, the **heads-up** **display** (**HUD**) is the method used to relay
    information visually to the player. In many games, the common features displayed
    are health/lives, time, weapons, menus, maps, and so on. This keeps your player
    alert to what is currently happening during game play. When it comes to tracking
    your lives, you want to be informed how many are left before your character runs
    out of chances to continue playing and the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – designing the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While trying to make the player''s gaming experience an enjoyable one, it''s
    important that the information displayed is relevant to the game and placed strategically,
    so that it doesn''t interfere with the main gaming area. So, to design the HUD,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `hud()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the text for the eggs that are caught during game play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in text to track the lives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in text for the score and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – designing the HUD](img/9343OT_07_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `eggText` display object can be found near the bottom-right corner of the
    screen. It''s still in view to the user while in game play and stays out of the
    main focus at the same time. Notice that `eggText = display.newText( "Caught:
    " .. eggCount, 0, 0, "Arial", 45 )` will refer to `eggCount` when the value is
    updated.'
  prefs: []
  type: TYPE_NORMAL
- en: The `livesText` display object setup is similar to `eggText`. It is placed near
    the top-right corner of the screen. The placement for this object is rather prominent
    because of its importance in the game. It's in an area that is noticeable from
    the background and allows the player to refer to during the game. The `livesText`
    display object decrements the number when `gameLives` is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The initial setup for `scoreText` starts in the `hud()` function. It is placed
    in the top-left corner of the screen, opposite to `livesText`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game lives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are no consequences in a game, then there is no sense of urgency to
    complete the main objectives. To keep a player engaged during game play, introducing
    elements that add some challenging aspects will keep the competitiveness and excitement
    going. Adding consequences in a game creates tension for the player and gives
    them more motivation to stay alive.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – counting the lives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tracking the lives left in the game keeps the player updated on how much sooner
    it will be till the game is over. To count the remaining lives in the game, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the function called `livesCount()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the text for lives every time the number is decremented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `livesCount()` function is a separate function that updates `gameLives`.
    It makes sure that you're aware that `gameLives = gameLives – 1`. This decreases
    the set value instantiated in the beginning of the code. When `gameLives` changes
    values, it displays the update through `livesText`. The `print` statement is used
    towards the end of the function to track the count in the terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: When `gameLives < 1`, the `callGameOver()` function will be called and show
    the game over element of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding images for the game lives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the game uses display text on screen to show how many lives are left
    during game play. A way to make the HUD display more appealing is by creating/adding
    small icons that correlate with the game, such as eggs or a frying pan.
  prefs: []
  type: TYPE_NORMAL
- en: Three separate display objects need to be created and placed in an orderly fashion
    so that when a life is taken away, the alpha of the object is reduced to 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: A method needs to be created so that all the three display objects are affected
    when the game lives are reduced to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the main character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our main character will be animated for every action applied during game play.
    We will also create a complex body construction since the focus of its collision
    points will be on the object the character is holding, and not on their entire
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Complex body construction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to construct a body from multiple elements. Each body element
    is specified as a separate polygon shape with its own physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: Since collision polygons in Box2D must be convex, any game object with a concave
    shape must be constructed by appending multiple body elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for a complex body is the same as the simple polygon body constructor,
    except that it has more than one body element listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Each body element may have its own physical properties, along with a shape
    definition for its collision boundaries. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As in the simpler cases, the `bodyType` attribute is optional and will default
    to `"dynamic",` if not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main character was created with a sprite sheet and needs to be set up to
    view the animation it provides. Other display images that will make an appearance
    include a cracked egg when a collision to a physical object has been made. To
    create the character, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `createChar()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the sprite sheet for the main character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the starting position and physical properties for the main character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the transition image after the egg has made a collision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – creating the character](img/9343OT_07_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The image sheet being referred to is called `sheetData` and takes the first
    `4` frames of animation from `"charSprite.png"`. We created an animation set called
    `"move"`. Every time `"move"` is called, it starts the animation from frame `1`
    and plays `4` frames from the start at `400` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The main display object is called `charObject` and takes on the characteristics
    of `sheetData`. When it calls `setSequence("move")`, that animation sequence plays
    when the `play()` command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: An important change to the physical body of the character is that its main collision
    point will be directed towards the frying pan used in the animation. Any collision
    detection on the character's body will not be read. The `charObject` display object
    is given a name called `"character"`, which will be used to detect the collision
    with the falling egg.
  prefs: []
  type: TYPE_NORMAL
- en: We have also placed the fried egg in this function, to prepare it for the collision.
  prefs: []
  type: TYPE_NORMAL
- en: Adding postcollisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to make sure that when an object has interacted with another, an event
    type occurs right after. At the instance of a postcollision, we can confirm the
    collision force between two objects. This helps us determine that the object that
    was destroyed was completed with a set amount of force.
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful about how you handle the Box2D physics engine. It will crash during
    a collision if Corona code attempts to modify objects still involved in the collision,
    since Box2D is still working out iterated mathematics on them.
  prefs: []
  type: TYPE_NORMAL
- en: For crash-proof collision detection, do not have collisions occur immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Do not modify/create/destroy physics objects during a collision, in order to
    prevent crashing.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to modify/create/destroy an object as a result of a collision, your
    collision handler should set a flag or add a time delay so that the change can
    occur later, with `timer.performWithDelay()`.
  prefs: []
  type: TYPE_NORMAL
- en: Body properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the native Box2D methods have been made into simpler dot properties
    for display objects. The following examples show that a body, `newBody`, has been
    created using one of the constructor methods.
  prefs: []
  type: TYPE_NORMAL
- en: body.isAwake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for the current awake state. By default, all bodies automatically
    *go* *to* *sleep* when there is no interaction with them for a couple of seconds.
    Bodies stop simulating until some kind of collision or other interaction wakes
    them up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: body.isBodyActive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for the active state of a body. Inactive bodies are not destroyed,
    but they are removed from the simulation and cease to interact with other bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: body.isBullet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body that is treated like a *bullet*. Bullets are subject
    to continuous collision detection. The default is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: body.isSensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean property that sets the `isSensor` property across all elements
    in the body. A sensor passes through other objects instead of bouncing off them,
    but detects some collision. This property acts across all body elements and will
    override any `isSensor` settings on the elements themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: body.isSleepingAllowed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body that is allowed to go to sleep. A body that is
    awake is useful in cases such as tilt gravity, since sleeping bodies do not respond
    to changes in global gravity. The default is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: body.isFixedRotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a Boolean for a body whose rotation should be locked, even if the body
    is about to load or subjected to off-center forces. The default is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: body.angularVelocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value of the current rotational velocity in degrees per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: body.linearDamping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value for how much the linear motion of a body is damped. This is
    the rate of decrease of angular velocity over time. The default is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: body.angularDamping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the value for how much the rotation of a body should be damped. The
    default is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: body.bodyType
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a string value for the type of physical body being simulated. The available
    values are `"static"`, `"dynamic"`, and `"kinematic"`, which are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` bodies don''t move or interact with each other. Examples of static
    objects would include the ground or the walls of a maze.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic` bodies are affected by gravity and collisions with other body types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kinematic` objects are affected by forces but not by gravity. Bodies that
    are draggable objects should be set to `"kinematic"` for the duration of the drag
    event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default body type is `"dynamic"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – creating the egg collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have handled collisions in the previous sample games we created. Handling
    postcollisions requires the introduction of force to execute the completion of
    a postcollision event:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `onEggCollision()` with two parameters called
    `self` and `event`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `if` statement when the force is greater than `1` and include `not`
    `self.isHit`. Add in the `eggCaughtSound` sound effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make `self` invisible and inactive, and replace it with the `friedEgg` display
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that transitions the `friedEgg` display object and fades
    it off the stage by using the `onComplete` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `if` `event.other.myName == "character"`, update `eggCount` when the
    main character catches the eggs. Also, update `gameScore` by `500` points for
    every collision. If the egg hits the ground, use `elseif event.other.myName ==
    "ground"` and decrement the lives using `livesCount()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – creating the egg collision](img/9343OT_07_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `onEggCollision( self, event )`, we set up the function with an `if` statement
    for `event.force > 1 and not self.isHit`. When both statements return `true`,
    the sound effect for the egg plays. The initial egg falling from the sky is removed
    from the scene upon collision and replaced by the `friedEgg` display object in
    the same location, using `friedEgg.x = self.x; friedEgg.y = self.y`.
  prefs: []
  type: TYPE_NORMAL
- en: The `fadeEgg()`function makes the newly replaced egg object appear in `50` milliseconds
    by `transition.to( eggCrack, { time=50, alpha=1.0, onComplete=fadeCrack } )` and
    then with the `onComplete` command, it returns the object to an invisible state
    with `transition.to( eggCrack, { time=500, alpha=0 } )`.
  prefs: []
  type: TYPE_NORMAL
- en: When the name `"character"` is called from `event.other.myName`, every collision
    assigned to that name increments `eggCount + 1`. Therefore, `eggText` is updated
    with the `eggCount` value. The `setScore( newScore )` statement increments the
    score by `500` with every collision made to `"character"`. When a collision is
    made to `"ground"`, the `livesCount()` function is called, which subtracts life
    by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Making the display objects fall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will apply the main asset (egg object) by learning how to add physical objects
    to the scene and have them fall in random areas in the game. The physics engine
    will take into account a dynamic physics body that we will create for the egg
    display object.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the egg object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine a world, full of falling eggs. It''s not entirely too realistic, but
    in this game, we''re creating this element. At least, we''ll be making sure that
    both gravity and real-world physics will be applied. To add the egg object, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `eggDrop()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the `egg` display object properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add in the `postCollision` event for the `egg` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – adding the egg object](img/9343OT_07_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set the `egg` value for `x` with `240 + mRand( 120 )`. The `mRand` function
    is equal to `math.random`, which will allow the egg to appear in randomized places
    in an area of `120` pixels, starting at 50 in the *x* direction.
  prefs: []
  type: TYPE_NORMAL
- en: It is vital to make sure that `egg.isHit = false` for the collision event to
    apply correctly. The physics body is set to `"dynamic"` so that it reacts to gravity
    and makes the object fall. There is a customized density and shape made for the
    egg we have created, which was already made at the beginning of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The last important detail for the collision to work is adding `egg` to the `onEggCollision()`
    function with `egg.postCollision = onEggCollision` and then making the event listener
    use the `"postCollision"` event with `egg:addEventListener( "postCollision", egg
    )`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the egg drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to execute the timer for the eggs, so that they can start dropping
    on the screen. To make the egg drop, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a local function called `eggTimer()` and use `timer.performWithDelay`
    to drop an egg every 1 second (`1000` milliseconds) repeatedly. Use `eggDrop()`
    to activate the drop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the first `if` statement in the `onEggCollision()` function, cancel
    the timer using the `timerID` and `startDrop` variables. Add the `if` `gameLives
    < 1` statement then to stop the eggs from falling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for the eggs to start dropping from the sky, we created a function
    called `eggTimer()`. It activates the `eggDrop()` function by letting an egg drop
    after `1000` milliseconds (1 second) every time infinitely using `startDrop =
    timer.performWithDelay( 1000, eggDrop, 0 )`.
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking to `onEggCollision()`, we want to check whether `gameLives` has
    reached less than `1`. When this statement is true, the eggs will stop dropping.
    This is done using `timer.cancel( startDrop )`. The `timerID` we set in `eggTimer()`
    is `startDrop`.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game play
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every start of a game always has an ending, whether it is a simple *You* *Win*
    or *You* *Lose* or just a *Game* *Over*; all these give closure to the player.
    It's important to notify a player of such events, so that they can reflect on
    the achievements earned.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – calling game over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make sure that when a game over display screen pops up, any of our
    display objects that are currently in motion stop moving, and the event listeners
    are deactivated. Aside from the visual display of our game over screen, we''ll
    be adding a sound notification that will also help to trigger the event. To end
    the game, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `callGameOver()` and place it after the
    `setScore()` function and before the `drawBackground()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce the sound effects when the game over display pops up. Have `gameIsActive`
    set to `false` and pause the physics in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a shade that overlays the current background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the game over window and reiterate the final score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Have the score display on the game over screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – calling game over](img/9343OT_07_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `gameOver()` function triggers our `gameOverSound` sound effect that we
    preloaded at the beginning of our code. We made sure no events, such as the motion
    from the accelerometer, are disabled through `gameIsActive = false`.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of our display objects appear at this point in time with `shade`,
    `gameOverScreen`, and `scoreText`.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, `scoreText` disappears when game play has ended by `scoreText.isVisible
    = false` and then reappears in a different area of the screen, using `timer.performWithDelay(
    0, function() scoreText.isVisible = true; end, 1 )`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will activate all the remaining functions and have them run accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – activating the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all the game play elements set in place, it is time to get the application
    started by using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local function called `gameActivate()` and insert `gameIsActive
    = true`. Place the function above the `moveChar()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize all the game actions by making a new function called `gameStart()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the physics property and set the gravity for the falling object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate all the functions instantiated. Add an event listener for the `charObject`,
    using the `"accelerometer"` event for the `moveChar()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the `gameStart()` function and return the `gameGroup` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember, in the beginning of our code, we set `gameIsActive = false`.
    We will now change this status through the `gameActivate()` function and make
    `gameIsActive = true`. We made the `gameStart()` function apply all the initial
    game play elements. This includes the start of the physics engine and gravity.
    At the same time, we took the remainder of all the functions and initialized them.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the functions are activated, `gameGroup` needs to be returned so that
    all the display objects appear during the game play.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that your physical object boundaries for your display objects are
    in the right place, use `physics.setDrawMode( "hybrid" )` in the `gameStart()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – animating the graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What retrieves or sets the text string of a text object?
  prefs: []
  type: TYPE_NORMAL
- en: '`object.text`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object.size`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`object:setTextColor()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What function converts any argument into a string?
  prefs: []
  type: TYPE_NORMAL
- en: '`tonumber()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tostring()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nil`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What body type is affected by gravity and collisions with the other body
    types?
  prefs: []
  type: TYPE_NORMAL
- en: dynamic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: kinematic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: static
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game play construction of our application is now completed. Now that we're
    familiar with a variety of ways to use the physics engine, it goes to show the
    ease of using Box2D for designing other games that involve physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a better idea of:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the uses of dynamic and static physics bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a customized shape for the physical properties of our display objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the number of objects caught using values from variables that are given
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using postcollisions to switch out images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will complete the gaming experience by creating versatile
    menu screens by using the Composer API. You will also learn how to add the pause
    action, save high scores, and understand more about data saving and unloading
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Using Corona SDK has helped us design and develop games in a minimal amount
    of time. Let's continue adding the final touches to our game!
  prefs: []
  type: TYPE_NORMAL
