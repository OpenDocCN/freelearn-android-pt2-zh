# 第二章．强制访问控制和 SELinux

在第一章中，我们介绍了*Linux 访问控制*的一些不足之处。在这些系统中，对象的拥有者对其权限标志拥有完全控制权，在以`root`身份或具有某些能力执行时，可以表现出更大的能力（例如，能够执行`chown`）。在本章中，我们将：

+   检查 MAC 的基础知识

+   介绍一些 SELinux 的行业驱动因素

+   讨论标签、用户、角色和类型

+   探索实现具体策略以允许和限制对象交互的实现方式

理想的 MAC 系统保持提供对内核资源（如文件）的明确访问控制属性，无论对象的拥有者是谁。例如，在 MAC 系统中，对象的拥有者可能无法完全控制其权限。在 Linux 中，MAC 框架与当前的 DAC 控制正交工作。这意味着 MAC 控制不会干扰 DAC 控制。换句话说，为了避免 MAC 和 DAC 系统之间的潜在冲突，内核在检查 MAC 权限之前，会先使用 DAC 权限验证访问。如果 DAC 权限导致权限冲突，那么将不会检查 MAC 权限。只有当 DAC 权限通过时，内核才会针对 MAC 权限提供者验证访问。在任何一级失败都将导致返回`EACCESS`。如果 DAC 和 MAC 权限都通过，那么内核资源（例如，一个文件描述符）将被发送回用户空间。

在 Linux 中，在 2.6.x 系列的内核中合并了一个名为**Linux 安全模块**（**LSM**）的框架。此框架允许你通过将 LSM 钩子绑定到安全提供程序，以在构建时选择启用强制访问控制系统。**安全增强型 Linux**（**SELinux**）是内核内首个使用此 MAC 安全框架的消费者，它是一个强制访问控制系统的实现。SELinux 被广泛包含在各种 Linux 系统中，例如**红帽企业级 Linux**（**RHEL**）以及其衍生出的 Fedora。最近，它也开始随 Android 系统一起发布。想要查看 SELinux 的源代码可以在 Linux 源代码树的`kernel/security/selinux`目录下找到。

# 回到基础

SELinux 是由美国政府与犹他大学共同设计的一种名为 **FLUX Advanced Security Kernel** (**FLASK**) 的重新实现。SELinux 和 FLASK 架构提供了一个中央策略文件，在确定访问控制决策结果时使用。这个中央策略以白名单形式存在。这意味着所有访问控制规则必须由策略文件明确定义。这个策略文件被抽象化，并由一个名为安全服务器的软件组件提供服务。当 Linux 内核需要做出访问控制决策并且启用了 SELinux 时，内核通过 LSM 钩子与安全服务器进行交互。

在运行中的系统中，进程是获得 CPU 时间来执行任务的活动实体。用户只是调用这些进程来代表他们执行工作。这是一个重要的概念。在我们编写这本书时，我们相信运行在我们机器上的具有我们凭据的字处理器没有打开我们的 SSH 密钥并将它们嵌入到文档元数据中。现在，是进程控制着计算资源，而不是用户。进程是运行实体，是进程向内核请求资源的系统调用，而不是物理人类。考虑到这一点，SELinux 系统中的第一个参与者通常是进程，通常被称为 **主体**。是主体访问文件。是安全服务器用来做出访问决策的主体。

因此，主体使用内核资源。这种内核资源是 **目标** 的一个例子。主体在目标上执行操作。自然地，人们应该问：“主体执行哪些操作？”这些被称为访问向量，通常与执行的 syscall 名称相关联。例如，主体可以在目标上执行 `open`。需要注意的是，目标也可以是进程。例如，如果系统调用是 `ptrace`，主体可能是类似于调试器的东西，而目标则是你希望调试的进程。主体通常是进程，但目标可能是进程、套接字、文件或其他东西。

# 标签

SELinux 使用标签来描述与目标和主体相关的策略语义。标签是与对象关联的元数据，维护主体和目标的访问信息。与该对象关联的数据是一个字符串。回到调试器示例，`gdb` 进程可能有一个主体标签字符串为 `debugger`，而目标可能有一个标签为 `debugee`。然后在安全策略中，可以使用一些语义来表达具有主体标签 `debugger` 的进程被允许调试具有目标标签 `debugee` 的应用程序。

幸运的是，或许也是不幸的是，SELinux 并没有使用如此简单的标签。实际上，标签由四个冒号分隔的字段组成：用户、角色、类型和级别。这种额外的复杂性为非常灵活的控制选项提供了可能。

## 用户

标签中的第一个字段用于标识用户。用户字段作为**基于用户的访问控制**（**UBAC**）设计的一部分。然而，这通常并不与人机用户相关联，而是与 DAC 中的用户概念相关。SELinux 用户通常会定义一组传统用户。一个常见的例子是将所有正常用户标识为 SELinux 用户，如`user_u`。也许还会为系统进程设置一个单独的用户，比如`system_u`。在桌面 SELinux 社区的传统中，用户部分的字符串通常会以`_u`结尾。

## 角色

标签中的第二个字段是角色。角色作为**基于角色的访问控制**（**RBAC**）设计的一部分。角色用于向用户提供更细致的权限。例如，假设我们保留了用户字段`sysadm_u`给管理员。管理员可能会执行不同的任务，根据任务的不同，`sysadm_u`中的角色（以及相应的权限）可能会改变。例如，当管理员需要挂载和卸载文件系统时，角色字段可能会变为`mount_admin_r`。当管理员设置`iptables`规则时，角色可能会变为`net_admin_r`。角色允许在执行任务的范围内隔离权限。

## 类型

类型是冒号分隔标签的第三个字段。类型字段在 SELinux 的**类型强制**（**TE**）部分进行评估。TE 是推动 SELinux 安全能力的主要组成部分，正是在这一环节政策开始生效。

SELinux 基于一个白名单系统，默认情况下拒绝一切，并需要从策略中获得明确的允许，以便进行交互。这种允许最初是通过引用主体和目标类型的允许规则从策略中确定的。SELinux 类型还可以分配属性。属性可以帮助您为多种类型提供一组通用规则。属性可以像继承模型那样使用。

# 访问向量

数据是通过系统调用和可能的用户定义访问方法由进程访问的。用户定义的访问方法通常由用户空间对象管理器控制。这些访问路径，也称为向量，构成了一组可以应用于对象的行为。例如，如果一个进程打开一个文件，写入一些数据然后再次读取，那么执行的访问向量将是`open`、`read`和`write`。如果一个进程调试另一个进程，那么访问向量将是`ptrace`。

# 多级安全

SELinux 还支持一个**多级安全**（**MLS**）模型，该模型向**Bell-LaPadula**（**BLP**）模型致敬，但也可以使用其他模型。BLP 模型是为了正式化国防部的安全政策而创建的。例如，一个有秘密许可的人不应该能够阅读绝密材料。但是，假设这个人有一个绝妙的想法，最终需要以绝密级别保护；那么这些数据可以被"升级"为绝密。这被称为"不向上读或向下写"。

SELinux 对此字段的实现包含子字段。第一个字段是敏感性，将始终存在。在之前例子的背景下，相关的敏感性包括秘密和绝密。第二个子字段是类别，可能不存在。这些字段在政府分类的背景下也是有意义的。数据本身可能是分隔的，所以尽管敏感性相同，比如都是绝密，但数据只应该分发给同一隔间或类别内的人。敏感性通过优势关键词以层次化的方式定义。在典型的策略中，`s0`是最低敏感性，而`n > 0`的`sN`是最高敏感性。因此，`s1`的敏感性高于`s0`。类别是集合。与级别相关的控制，包括敏感性和可能的类别，遵循集合论概念，如优势和相等。在 MLS 安全中，所有交互默认都是允许的，与类型强制不同。敏感性和类别都可以是范围的，类别可以列举。因此，一个标签可能有一些数量的敏感性和不同数量的类别。

# 将其组合起来

SELinux 标签非常灵活，有时也相当复杂。通常，从关注类型强制的一个人为例子开始是有益的。随后，我们可以根据需要更细粒度的需求，添加其他字段。方便的是，你可以将这个模型投射到日常生活中的场景，为材料提供一定的实质性感觉。著名的 SELinux 人物 Dan Walsh 发表了一篇博客，使用宠物作为类比。让我们以此为基础，但在进行中我们会做一些修改，并定义自己的例子。最好从简单的类型强制开始，因为它最容易理解。

### 注意

你可以阅读 Dan Walsh 的原始博客文章，了解宠物类比，文章地址是[`opensource.com/business/13/11/selinux-policy-guide`](http://opensource.com/business/13/11/selinux-policy-guide)。

假设我们有一只猫和一只狗。我们不希望猫吃狗粮。我们不希望狗吃猫粮。在这一点上，我们已经识别出两个主体，一只猫和一只狗，以及两个目标，猫粮和狗粮。我们还识别出一个访问向量，即吃。我们可以使用允许规则来实现我们的策略。可能的规则可能如下所示：

```kt
allow cat cat_chow:food eat;
allow dog dog_chow:food eat;

```

让我们用这个例子来开始定义我们希望实施的表达访问控制的基本语法。第一个标记是 `allow`，表明我们希望允许主体和目标之间的交互。狗被分配类型 `dog`，猫为 `cat`。猫粮被分配类型 `cat_chow`，狗粮为 `dog_chow`。在这种情况下，访问向量是 `eat`。使用这种基本语法（也是有效的 SELinux 语法），我们限制动物只能吃它们应该吃的食物。注意类型后的 `:food` 注解。这是目标对象的类字段。例如，还可能有 `dog_chow` `treat` 和 `cat_chow` 类，这可能表明我们希望以可能与允许访问非零食食物不同的方式允许访问零食。

假设我们又得到两只狗，我们的场景有三只狗。这些狗的大小不同：小的、中等的和大的。我们希望确保这些新狗不要吃其他狗的食物。我们可以为每只狗创建一个新类型，并阻止狗吃其他狗的食物。它可能看起来像这样：

```kt
allow cat cat_chow:food eat;
allow dog_small dog_small_chow:food eat;
allow dog_medium dog_medium_chow:food eat;
allow dog_large dog_large chow:food eat;

```

这将起作用；然而，类型的总数将难以管理，如果我们允许大狗吃小品种的食物，那么类型将继续增长。我们可以做的是使用 MLS 支持，为每个目标或狗食碗分配一个敏感度。假设以下情况：

+   猫的食物碗具有敏感度，`tiny`

+   小狗的食物碗具有敏感度，`small`

+   中型狗的食物碗具有敏感度，`medium`

+   大狗的食物碗具有敏感度，`large`

我们还需要确保对这些主题进行适当的敏感度标注：

+   猫应有敏感度，`tiny`

+   小狗应有敏感度，`small`

+   中型狗应有敏感度，`medium`

+   大狗应有敏感度，`large`

在这一点上，我们需要引入额外的语法以允许交互，因为默认情况下，MLS 允许一切而 TE 拒绝一切。我们将使用 `mlsconstrain` 来限制系统内的交互。规则可能如下所示：

```kt
mlsconstrain food eat (l1 eq l2);

```

这个约束只允许主体吃具有相同敏感度级别的食物。SELinux 定义了关键字 `l1` 和 `l2`。`l1` 关键字是目标的级别，`l2` 是源的级别。因为规则是白名单的一部分，这也防止主体吃不具有等效敏感度级别的食物。

现在，假设我们又有了一条大型犬。现在我们有了两条大型品种的狗。然而，它们有不同的饮食，需要接触不同的食物。我们可以添加一个新的类型或修改现有的类型，但这将具有导致我们使用敏感性防止访问的相同限制。我们可以添加另一个敏感性，但可能会有点混淆，因为有`large1`和`large2`敏感性。在这一点上，类别将允许我们在控制上更加细化。假设我们添加了一个表示品种的类别。我们标签的 MLS 部分将看起来像这样：

```kt
large:golden_retriever
large:black_lab

```

这些规则可以用来防止黑拉布拉多犬吃金毛犬的食物。现在假设你又惊喜地得到了另一条狗，一条圣伯纳犬。假设这条新的伯纳犬可以吃任何大型犬的食物，但其他大型犬不能吃它的食物。我们可以给食物碗和狗贴上标签。

| 狗品种 | 主体标签 | 目标标签 |
| --- | --- | --- |
| 金毛犬 | `Dog:large:golden_retriver` | `dog_chow:large:golden_retriver` |
| 黑拉布拉多犬 | `Dog:large:black_lab` | `dog_chow:large:black_lab` |
| 圣伯纳犬 | `Dog:large:saint_bernard, black_lab, golden_retriever` | `dog_chow:large:saint_bernard` |
| 猫 | `Cat:tiny` | `cat_chow:tiny` |

现有的`mlsconstraint`需要修改。如果圣伯纳犬的食物吃完了，去吃黑拉布拉多犬的食物，由于等级不同（`Dog:large:saint_bernard, black_lab, golden_retriever`与`dog_chow:large:black_lab`不同），圣伯纳犬将无法吃它。记住，这些等级是集合，因此我们需要引入某种概念，如果主体集合支配目标集合，那么应该允许这种交互。

这可以通过`dom`关键词实现：

```kt
mlsconstrain food eat (l1 dom l2);

```

主导关键词`dom`与等于不同，表示`l1`是`l2`的超集。换句话说，与目标`l2`相关的级别包含在与主体`l1`相关联的潜在更大级别集合中。在这一点上，我们能够保持所有食物的分离，按照我们的意愿使用。

在得到所有这些狗之后，你意识到是时候喂它们了，所以你拿了一袋狗粮，在每个碗中放一些。但是，在我们能在碗中添加狗粮之前，我们需要一些允许规则和标签。记住，SELinux 是一个基于白名单的系统，所有内容必须明确允许。

我们将人类标记为`human`标签，并定义一些规则。哦，对了...别忘了喂猫：

```kt
allow human dog_chow:food put;
allow human cat_chow:food put;

```

我们还需要给`human`标记上所有的敏感性和类别，但当我们需要在系统中添加额外的狗、品种和品种大小时，这将变得繁琐。如果类型是`human`，我们可以绕过这个约束。采用这种方法，我们总是相信`human`会将正确的食物放入适当的碗中：

```kt
mlsconstrain food eat (l1 dom l2);
mlsconstrain food put (t1 == human);

```

注意在 MLS 约束的访问向量中加入了`put`。瞧！现在人类可以喂养他日益增长的动物群体了。

所以你的生日到了，你收到了一个自动喂狗器作为礼物。你给食物分配器打上标签`dispenser`，并修改 MLS 约束：

```kt
mlsconstrain food eat (l1 dom l2);
mlsconstrain food put (t1 == human or t1 == dispenser);

```

再次，我们发现需要减少类型数量并组织起来，以防止不得不重复行。这时，属性就显得非常方便。我们可以首先定义一个属性，并将其分配给我们的`human`和`dispenser`类型。

```kt
attribute feeder;

```

然后我们可以将其添加到类型中：

```kt
typeattribute human, feeder;
typeattribute dispenser, feeder;

```

这也可以在类型声明时完成：

```kt
type human, feeder;
type dispenser, feeder;

```

在这一点上，我们可以修改 MLS 声明，使其看起来像这样：

```kt
mlsconstrain food eat (l1 dom l2);
mlsconstrain food put (t1 == feeder);

```

现在假设你雇佣了一个家政服务。你希望确保任何由家政服务派遣的人都能够喂养你的宠物。就此而言，让我们也让你的家庭成员喂养它们。这将是一个使用用户能力的良好案例。我们将定义以下用户：`adults_u`、`kids_u`和`maid_u`。然后我们需要添加一个约束声明，以允许这些用户的互动：

```kt
mlsconstrain food put (u1 == adults_u or u1 == maid_u);

```

这将防止儿童喂养狗，但允许家政和成人喂养。现在假设你雇佣了一个园丁。你可以创建另一个用户`gardener_u`，或者你可以将用户合并为几个类别并使用角色。假设我们将`gardener_u`和`maid_u`合并为`staff_u`。没有理由让园丁喂养狗，因此我们可以使用基于角色的转换来让员工在职责之间移动。例如，假设员工可以执行多项服务，即同一个人可能既园艺又打扫。在这种情况下，他们可能会承担`gardener_r`或`maid_r`的角色。我们可以使用 SELinux 的角色功能来满足这一需求：

```kt
mlsconstrain food put (u1 == adults_u or (u1 == staff_u and r1 == animal_care_r);

```

员工只有在`animal_care_r`角色中才能喂养狗。如何进入和退出该角色是唯一缺少的组件。你需要有一个明确的系统，规定员工如何进入动物护理角色并转换回来。在 SELinux 中，这些转换要么通过动态角色转换自动发生，要么通过源代码修改。我们将假设任何人类实体（园丁、成人、儿童）都从`human_r`角色开始。

动态角色转换遵循一个两部分的规则，第一部分允许通过一个允许规则发生转换：

```kt
allow human_r animal_care_r;

```

角色转换声明如下：

```kt
role_transition human_r dog_chow animal_care_r;
role_transition human_r cat_chow animal_care_r;

```

这将是一个将`dog_chow`和`cat_chow`类型归为一个新属性`animal_chow`的好案例，并重写前面的角色转换为：

```kt
typeattribute dog_chow, animal_chow;
typeattribute cat_chow, animal_chow;
role_transition human_r animal_chow animal_care_r;

```

使用这些角色转换，你只能从 `human_r` 角色转换到 `animal_care_r`。你还需要定义转换以返回。同样重要的是要注意，你可能会定义其他角色。假设你定义了 `gardener_r` 角色，并且当某人处于该角色时，他们不能转换到 `animal_care_r`。假设你制定这项政策的理由是园丁可能会使用对宠物不安全的化学物质，因此他们在喂宠物之前需要洗手。在这种情况下，他们应该只能从 `hand_wash_r` 角色转换到 `animal_care_r`。

# 复杂性与最佳实践

正如你现在所理解的，SELinux 是复杂的，可以被认为是一种通用的“元编程策略语言”。你实际上是在编程哪些交互被允许在一个非常复杂的操作系统中发生，比如 Linux，交互本身通常是复杂的。就像编程语言一样，你可以用不同的风格和方法做事情，这将产生不同的结果。也许在那个程序中使用 `switch()` 会使其更清晰易懂，而不是 `else-if` 块，尽管从功能上讲，你最终会得到相同的结果。SELinux 也是如此；你通常可以使用执行机制的一部分来完成更适合使用另一种机制来完成的事情。在后面的章节中，我们将介绍对目标和主体进行标记的过程，这是系统中较为困难的部分之一。

当某人编写一个程序时，他们通常会有一个要求软件应执行的一系列要求。这些是软件的要求。在 SELinux 中，你也应该这样做。你应该收集安全要求并了解你希望保护自己免受的威胁模型。一个设计良好的 SELinux 策略将满足这些目标。一个伟大的设计将以易于扩展的方式进行。这就是谨慎和明智地使用 UBAC、RBAC、TE 和 MLS 组合最终将帮助你实现要求和设计目标的地方。

# 总结

在本章中，我们介绍了 SELinux 的主要工作部分，包括类型强制执行、多级别和多类别安全以及用户和角色。此外，我们还了解了如何将这些技术应用于实现越来越复杂的访问策略到一个具体的示例。在下一章中，我们将走出内核，探索 Android 在其非常独特的用户空间中是如何工作的。
