# 第三章：安卓的奇妙之处

确实如此。尽管它是建立在熟悉的 Linux 内核之上，但 Android 有一个完全定制的用户空间，而且其中许多功能都是对其 GNU 表亲的重写，有些是全新的，或者与其桌面版本的功能有显著不同。由于这些差异，这些系统不得不被修改以支持 SELinux。在本章中，我们将：

+   介绍安卓的安全模型

+   调查 binder、zygote 和属性服务

+   探讨为了补充这些系统而添加的 SELinux 元素及其原因

这些系统的覆盖范围将是适度的，但稍后在我们对 Android 的 SE 探索性调查中适当的时候，我们将详细介绍每个系统的更复杂细节。

# 安卓的安全模型

安卓的核心安全模型基于 Linux 的 DAC，包括能力。然而，Android 以一种非常非传统的方式使用 Linux 的 UID/GID 概念。系统上的每个进程都有自己的 UID，而不是启动它的用户的 UID。这些 UID（通常是唯一的）提供了沙箱和进程隔离。不过，在某些情况下，进程可以共享 UID 和 GID。通常，当一个进程与另一个进程共享 UID 时，是因为它们都需要系统上的同一组权限并共享数据。GID 也是如此。然而，在 Android 中，有些 GID 实际上用于获取访问底层系统（如 SD 卡文件系统）的权限。简而言之，UID 用于隔离进程，而不是系统的人类用户。实际上，直到安卓 Jelly Bean 4.3 版本，Android 才支持多个人类用户。它始终是为单个人类用户操作的设备而设计的……至少在运行时是这样。

在这个安全模型中，有两个进程类别。第一个被称为系统组件服务。这些是在系统初始化脚本中声明的服务。它们往往是高度特权的，因此几乎从不与其他进程共享 UID。一个示例系统组件服务是**无线接口层守护进程**（**RILD**）。RILD 负责处理 Android 用户空间与设备上的调制解调器之间的消息。由于它所做的事情的性质，它通常以 root UID 运行。没有要求进程必须是纯本地代码。系统服务器具有非本地组件，以系统 UID 运行，并且是高度特权的。几乎所有这些系统都有一个共同点；它们有一个 UID，要么是 root，要么被设置为许多敏感内核对象（如套接字、管道和文件）的所有者。 

第二类是应用程序。这些应用程序通常是用 Java 编写的，尽管这不是必须的；这与系统组件服务通常用本地代码编写但不作为要求类似。这些应用程序在安装时会自动分配 UID，系统为这一目的保留这些 UID。包管理器负责向应用程序发放 UID。这些 UID 与系统上的任何敏感或危险的东西无关，应用程序不带任何功能运行。为了访问系统资源，应用程序必须将其附加组添加到其中，或者必须由单独的进程进行仲裁。

使用附加组的简单示例可以在应用程序需要使用 SD 卡时看到。为了访问 SD 卡，应用程序必须在它们的附加 GIDs 中拥有`SDCARD_RW`权限。这些权限通过内核使用标准的 Linux DAC 权限执行。附加组在应用程序安装期间由包管理器分配，基于声明的权限。在 Android 中，应用程序必须在应用程序的清单中声明一个名为`uses-permission`的东西。这个权限以字符串形式出现，并映射到一个附加 GID。这种映射在系统中的一个文件中维护，具体为`/system/etc/permissions/platform.xml`。你将在后面的章节中看到这些权限字符串的应用。

应用程序获取系统资源的第二种方式是通过另一个进程。希望使用系统资源的应用程序必须让另一个进程代表它执行此操作。大多数请求都由一个名为**系统服务器**的进程处理。系统服务器会检查发起仲裁请求的应用程序是否在其清单文件中声明了匹配的权限字符串。如果已声明，则允许其继续操作；否则，将抛出安全异常。实际上，即使是 Android 中的仲裁访问也本质上使用的是 DAC 模型。尽管对象所有者通过权限字符串控制对象上的访问规则，但受保护对象的任何使用者只需请求权限字符串即可获得访问权限。本质上，任何人都可以编写一个请求任何所需权限字符串的应用程序。在安装应用程序时，用户会看到应用程序请求的权限列表，并可以选择批量接受或拒绝。如果用户意图安装应用程序，则必须授予所有请求的权限。如果用户不够谨慎，可能会无意中允许应用程序以可能威胁设备、应用程序或用户数据安全的方式访问受保护的对象。设备所有者应始终确保他们对应用程序使用声明的权限感到满意。

### 注意

如果需要示例或进一步讨论，请参考[`developer.android.com/guide/topics/security/permissions.html`](http://developer.android.com/guide/topics/security/permissions.html)。

# Binder

之前讨论的仲裁访问方法需要某种形式的**进程间通信**（**IPC**），虽然 Android 确实使用了 Unix 域套接字，但它还引入了自己更广泛使用的 IPC 机制。这种 IPC 机制称为 binder，是 Android 操作系统中的核心 IPC 机制。它从 BeOS 和 Palm OS 的 OpenBinder 实现中具有历史相关性，由于最初的 Android 开发团队由许多 OpenBinder 工程师组成，因此 binder 也随之进入了 Android。然而，Android 对 binder 代码库进行了彻底的重新编写，专门针对 Linux。

### 注意

目前，binder 还没有完全融入 Linux 内核，Android 的许多内核更改仍然处于阶段性状态。

关于 binder 及其主要采用的实现有一些争议。一些人反对它在驱动程序中与竞争对手的实现（如`dbus`）相比所做的繁重工作。然而，在这场辩论得到解决之前，可能还需要很长时间。无论 binder 是否继续作为 Android 特定的技术，或在 Linux 内核中得到普及，或者最终在 Android 中被其他技术取代，binder 在可预见的未来都将存在。

## Binder 的架构

Binder IPC 遵循客户端/服务器架构。服务发布一个接口，客户端从该接口消费。客户端可以通过两种方法之一绑定到服务：已知地址或服务名称。

系统中的每个 binder 接口被称为 binder 节点。每个 binder 节点都有一个地址。当客户端想要使用一个接口时，必须通过这个地址绑定到一个 binder 节点上。这类似于通过 IP 地址浏览网页。然而，与通常长时间固定不变的 IP 地址不同，binder 地址可能会因为发布服务的重启或设备启动时服务的启动顺序而改变。进程的顺序并不能完全保证，因此发布进程服务可能会导致分配不同的 binder 令牌（一个在进程间共享的简单 binder 对象）。此外，这种间接方式允许运行时仅通过已发布的服务名称重新定位服务实现，无需使用令牌。

这种重定向的方式类似于 DNS 为网络设备访问提供从名称到 IP 地址解析的方式。Binder 有一个称为上下文管理器（也称为服务管理器）的东西。上下文管理器位于固定的节点地址`0`。发布服务将名称和 Binder 令牌发送到上下文管理器，然后，当客户端需要通过名称查找服务时，他们会检查 Binder 节点 0 并将名称解析为 Binder 令牌。Binder 令牌是这个地址（或 ID）的正确名称，它唯一地标识了一个 Binder 接口。客户端绑定到实现 Binder 接口的进程后，这些进程就会使用已建立的 Binder 协议执行 Binder 事务。此协议允许类似于方法调用的同步事务。

由于 Binder 是一个内核驱动，因此它具有一些确定跨接口可以执行操作的良好特性。首先，它允许传输文件描述符。它还管理一个线程池，用于分派服务方法。此外，它采用了一种称为零拷贝的方法，即 Binder 在进程间不复制任何事务数据...而是共享它们。Binder 还支持对象的引用计数，并允许服务查询客户端应用程序的 Linux 凭证，如 UID、GID 和**进程 ID**（**PID**）。Binder 还允许服务和客户端通过其链接到死亡功能知道对方何时终止。

在 Android 系统中，通常情况下，我们不会直接与 Binder 交互。相反，我们通过服务和它的**Android 接口描述语言**（**AIDL**）接口来与 Service 交互。最后一章将提供关于 AIDL 在实际中应用的详细示例，以用于我们的自定义 Android 系统的 SE，但在此期间，以下是一个简单的 AIDL 接口示例，它提供了远程进程执行`getAccountName()`和`putAccountName()`函数的方法：

```kt
package com.example.sample;

interface IRemoteInterface {
  String getAccountName();
  boolean putAccountName(in String name);
}
```

使用 AIDL 接口的优美之处在于，它用于生成大量代码来管理数据和进程，而这些工作否则需要手动完成。例如，以下是从前面 AIDL 示例生成的代码的一小部分：

```kt
@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
{
switch (code)
{
case INTERFACE_TRANSACTION:
{
reply.writeString(DESCRIPTOR);
return true;
}
case TRANSACTION_getAccountName:
{
data.enforceInterface(DESCRIPTOR);
java.lang.String _result = this.getAccountName();
reply.writeNoException();
reply.writeString(_result);
return true;
}
case TRANSACTION_putAccountName:
{
data.enforceInterface(DESCRIPTOR);
java.lang.String _arg0;
_arg0 = data.readString();
...
```

## Binder 与安全

Binder 的安全含义非常重大。你应该能够控制谁成为上下文管理器，因为恶意上下文管理器可能会通过将客户端发送到恶意服务而非适当服务来破坏整个系统。除此之外，你可能还想要控制哪些客户端可以绑定到哪些 Binder 对象。最后，你可能还希望控制是否可以通过 Binder 发送文件描述符。Binder 还允许某人通过接口伪造凭证，这种设计是为了好的用途。例如，一些特权系统进程，如**活动管理服务**（**AMS**），代表其他进程执行操作。在这种伪装中暴露的凭证是你正在为其工作的进程的凭证，而不是特权实体的凭证。这类似于授权委托，当有人代表你行事时使用。

安卓的 Binder IPC 机制传统上由 DAC 权限控制。然而，正如我们在第一章，*Linux 访问控制*中所看到的，这些权限有一些缺陷。因此，需要修改 Binder 以支持 SELinux，因为否则 Binder 驱动程序不会实现任何附加安全模块的钩子。为此，斯蒂芬·斯马利向谷歌发送了一个补丁，实现了这些功能。该补丁为被称为**Linux 安全模块**（**LSM**）框架的消费者实现了新的钩子。这个框架允许 LSMs 如 SELinux 被调用，然后做出访问决策。这个补丁的细节超出了本书的范围。重要的是 Binder 被打了补丁，现在 SELinux 可以使用 MAC 控制其功能。

### 注意

斯蒂芬·斯马利是美国国家安全局（**NSA**）的可信系统研究组织的一名计算机安全研究员，并领导着 SE Android 项目。他发送给谷歌以修改 Binder 以支持 SELinux 钩子的补丁可以在[这里查看](https://android-review.googlesource.com/45984)。

由于 SELinux 和 Binder 的集成，SE for Android 有一个带有访问向量（一种花哨的说法，即“它能执行的操作”）的附加类别。在之前的例子中，来自第二章，*强制访问控制和 SELinux*，目标类别是`food`。类似地，Binder 的 SELinux 类别是`binder`。它定义了下面列举的访问向量。如果你还记得，第二章中`food`的访问向量是`eat`。以下是为 Binder 可用的访问向量：

+   `impersonate`：这会在 Binder 接口上创建伪造凭证

+   `call`：这会将客户端绑定到一个 Binder 接口，并使用它

+   `set_context_mgr`：这会设置上下文管理器

+   `transfer`：这用于传输一个文件描述符

# Zygote – 应用程序孵化

在 Android 中，非原生应用程序传统上使用 Dalvik **虚拟机**（**VM**）并运行称为 DEX 的专有字节码。应用程序还通过称为分叉和专化的机制，从一个名为 zygote 的公共进程孵化而来。Zygote 本身是一个进程，其中加载了 Dalvik VM 和一些公共类，如`java.util.*`。从 zygote 到执行某些应用程序代码的 zygote 子进程的机制称为分叉和专化。

### 注意

自从 Android 4.4 版本以来，Android 正在用**Android 运行时**（**ART**）替换这个。据推测，Android L 将完全不用 Dalvik VM。

这个过程的第一部分涉及一个套接字连接。Zygote 通过这个套接字监听应用程序的孵化请求。一些参数包括应该加载的应用程序的包名，以及一个表示应用程序是否为系统服务器的标志。一旦接收到孵化命令，就可以进行分叉。

### 注意

跟踪这个初始套接字连接的一个很好的方式是使用`app_process`工具。这个命令以 Dalvik 启动一个进程。更多信息，请导航到`frameworks/base/cmds/app_process/app_main.cpp`。

分叉之后，现在的父 zygote 将返回监听套接字以接收更多请求。子进程正在执行，需要发生几件事情。首先需要发生的是 UID 和 GID 的切换。Zygote 以 root 的 UID 运行，为了符合 Android 的安全模型，它必须将子进程的 UIDs 和 GIDs 设置为非 root 的其他值。子进程将根据包管理器和补充 GIDs 定义设置 UID 和 GID。它还设置了进程的资源限制和调度策略。然后它将应用程序的权限集清零（无权限）。在系统服务器的情况下，权限集不是被清除，而是设置为通过套接字发送的参数之一。在此之后，子进程开始运行。Zygote 中更靠后的代码加载类，以及系统交互的其他部分，如意图传递，用于启动一个活动。这些部分超出了本书的范围。

# 属性服务

安卓系统中的属性服务提供了一个在所有进程之间共享的键值对映射。所有进程共享一部分专门用于此系统的内存页面。然而，所有进程中的映射都是`只读`的，除了 init 进程，它有`读写`映射。属性服务系统驻留在 init 中，这个系统的工作就是更新或添加键值映射中的值。若要更改一个值，必须通过属性服务，但任何人都可以读取一个值。务必注意，如果你使用属性服务，不要存储敏感信息。它主要旨在用于小数据值，而不是通用的大值存储。以下是属性服务的一个非常基础的介绍。稍后将会进行更彻底的调查。

要设置属性，必须通过 Unix 域套接字向属性服务发送请求。属性服务将解析请求，并在权限允许的情况下设置值。属性具有以句点分隔的段，如包名，在构建时静态分配权限。权限和属性服务代码可以在`system/core/property_service.c`一起找到。这个接口预期的参数包括一个命令、属性名称和属性值。对于那些好奇的人，这些都在`prop_msg`结构中定义，该结构在`bionic/libc/include/sys/_system_properties.h`中定义。收到消息后，属性服务会检查对等套接字的凭据与静态权限映射是否一致。如果 UID 是 root，它可以写入任何内容，否则它必须是 UID 或 GID 的匹配项。在非常新的安卓版本中，或者应用了来自[`android-review.googlesource.com/#/c/98428/`](https://android-review.googlesource.com/#/c/98428/)补丁的版本，权限检查和硬编码的 DAC 已经被 SELinux 控制所取代。

由于设置值的权限是由用户空间使用 DAC 控制的，因此属性设置机制共享了固有的 rooting 漏洞缺陷。考虑到这一点，在 SELinux 中增强了属性服务代码。由于这是一个用户空间进程，它通过内核使用 SELinux API 来编程一个称为用户空间对象管理器的东西。这意味着用户空间应用程序会检查内核中的 SELinux，以确保它可以执行某项活动……在这种情况下，就是设置属性。

# 总结

安卓拥有一些非常独特的特性。从使用通用的 UID 和 GID 模型来提升其安全目标，到其自定义的 binder IPC 机制，这些系统对设备的安全性和功能性都有影响。在下一章，当我们让 UDOOUDOO 运行并启用其上的 Android SE 时，这些系统将再次发挥作用。
