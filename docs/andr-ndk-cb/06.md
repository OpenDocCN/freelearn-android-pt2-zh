# 第六章。安卓 NDK 多线程

在本章中，我们将介绍:

*   在安卓 NDK 创建和终止本地线程
*   在安卓 NDK 系统上同步本地线程和互斥体
*   在安卓 NDK 系统上同步本地线程和条件变量
*   在安卓 NDK 系统上同步本地线程和读/写锁
*   在安卓 NDK 系统上同步本地线程和信号量
*   在安卓 NDK 系统上调度本地线程
*   在安卓 NDK 管理本机线程的数据

# 简介

大多数非平凡的安卓应用程序使用不止一个线程，因此多线程编程对安卓开发至关重要。在安卓 NDK，为了支持多线程，将 **POSIX 线程** ( **pthreads** )捆绑在安卓的仿生 C 库中。本章主要讨论`pthread.h`和`semaphore.h`头文件中定义的 API 函数，可以在安卓 NDK 的`platforms/android-<API level>/arch-arm/usr/include/`文件夹下找到。

我们将首先介绍线程创建和终止。同步在所有多线程应用中都很重要，因此我们讨论了 Android NDK 的四种常用同步技术，包括互斥、条件变量、读/写锁和信号量。然后我们说明线程调度，最后描述如何管理线程的数据。

作为一本实用的书，我们不会涉及多线程编程背后的理论。读者应该了解多线程的基础知识，包括并发、互斥、死锁等。

此外，pthreads 编程是一个复杂的话题，有专门为 pthreads 编程编写的书籍。本章将只关注安卓 NDK 编程环境中的要点。感兴趣的读者可以参考本书 *Pthreads Programming:一个更好的多处理的 POSIX 标准*，由*布拉德福德尼科尔斯**迪克巴特拉*和*杰奎琳普劳克斯法瑞尔*获得更多信息。

# 在 Android NDK 创建和终止本机线程

这个食谱讨论了如何在安卓 NDK 系统上创建和终止本地线程。

## 准备…

读者应该知道如何创建一个安卓 NDK 项目。我们可以参考[第一章](01.html "Chapter 1. Hello NDK")、*你好 NDK* 的*写你好 NDK 程序*食谱，了解详细说明。

## 怎么做...

以下步骤描述了如何 创建一个简单的带有多个本机线程的安卓应用程序:

1.  创建一个名为`NativeThreadsCreation`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadscreation`。有关更多详细说明，请参考[第 2 章](02.html "Chapter 2. Java Native Interface")、 *Java 本机接口*中的*加载本机库和注册本机方法*配方。
2.  右键单击项目**原生创建**，选择**安卓工具** | **添加原生支持**。
3.  在包`cookbook.chapter6.nativethreadscreation`下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载本机库`NativeThreadsCreation`并调用本机`jni_start_threads`方法。
4.  Add `mylog.h` and `NativeThreadsCreation.cpp` files under the `jni` folder. The `mylog.h` file contains the Android native `logcat` utility functions, while the `NativeThreadsCreation.cpp` file contains the native code to start multiple threads. A part of the code is shown next.

    `jni_start_threads` 函数启动两个线程，等待两个线程终止:

    ```
    void jni_start_threads() {
      pthread_t th1, th2;
      int threadNum1 = 1, threadNum2 = 2;
      int ret;
      ret = pthread_create(&th1, NULL, run_by_thread, (void*)&threadNum1);
      ret = pthread_create(&th2, NULL, run_by_thread, (void*)&threadNum2);
      void *status;
      ret = pthread_join(th1, &status);
      int* st = (int*)status;
      LOGI(1, "thread 1 end %d %d", ret, *st);
      ret = pthread_join(th2, &status);
      st = (int*)status;
      LOGI(1, "thread 2 end %d %d", ret, *st);
    }
    ```

    对本机线程执行`run_by_thread` 功能:

    ```
    int retStatus;
    void *run_by_thread(void *arg) {
      int cnt = 3, i;
      int* threadNum = (int*)arg;
      for (i = 0; i < cnt; ++i) {
        sleep(1);
        LOGI(1, "thread %d: %d", *threadNum, i);
      }
      if (1 == *threadNum) {
        retStatus = 100;
        return (void*)&retStatus;
      } else if (2 == *threadNum) {
        retStatus = 200;
        pthread_exit((void*)&retStatus);
      }
    }
    ```

5.  在`jni`文件夹的 中添加一个`Android.mk`文件，代码如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE := NativeThreadsCreation
    LOCAL_SRC_FILES := NativeThreadsCreation.cpp
    LOCAL_LDLIBS := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  Build and run the Android project, and use the following command to monitor the `logcat` output:

    ```
    $ adb logcat -v time NativeThreadsCreation:I *:S
    ```

    以下是`logcat`输出的截图:

    ![How to do it...](graphics/1505_06_01.jpg)

## 它是如何工作的...

这个食谱展示了如何在安卓 NDK 系统上创建和终止线程。

### 用 pthreads 构建

传统上，pthread 是作为外部库实现的 ，必须通过提供链接器标志`-lpthread`进行链接。安卓的仿生 C 库捆绑了自己的 pthread 实现。因此，我们在项目中不使用`Android.mk`文件中的`-lpthread`。

### 线程创建

如我们的代码所示，可以使用`pthread_create`函数创建线程，该函数具有以下原型:

```
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);
```

该函数创建并启动一个新线程，其属性由`attr`输入参数指定。如果`attr`设置为`NULL`，则使用默认属性。`start_routine`参数指向新创建的线程要执行的函数，其中`arg`作为该函数的输入参数。当函数返回时，`thread`输入参数将指向存储线程标识的位置，返回值为零表示成功，其他值表示错误。

在我们的示例代码中，我们创建了两个线程来执行`run_by_thread`函数。我们将一个整数指针作为输入参数传递给 `run_by_thread`函数。

### 线程终止

线程在从`start_routine`函数返回后终止，或者我们明确地称之为`pthread_exit`。`pthread_exit`功能有以下原型:

```
void pthread_exit(void *value_ptr);
```

该函数终止调用线程，并将`value_ptr`指向的值返回给调用线程的任何成功的`join`。我们的示例代码也演示了这一点。我们在创建的两个线程上都调用了`pthread_join`。`pthread_join`功能有以下原型:

```
int pthread_join(pthread_t thread, void **value_ptr);
```

该函数暂停调用线程的执行，直到第一个输入参数指定的线程终止。当函数成功返回时，第二个参数可以用来检索终止线程的退出状态，如我们的示例代码所示。

另外，我们之前看到的`logcat`截图显示，从一个线程调用 return 相当于调用`pthread_exit`。因此，我们可以在调用任一方法时获得退出状态。

### 注

`pthread_cancel`安卓仿生 C 库 pthread 不支持。因此，如果我们移植使用`pthread_cancel`的代码，我们将需要重构代码来摆脱它。

# 在安卓 NDK 系统上同步本地线程和互斥体

这个食谱讨论了如何在安卓 NDK 使用 pthread 互斥体。

## 怎么做...

以下步骤有助于创建一个演示 pthread 互斥体用法的 Android 项目:

1.  创建一个名为`NativeThreadsMutex`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadsmutex`。有关更多详细说明，请参考[第 2 章](02.html "Chapter 2. Java Native Interface")、 *Java 本机接口*中的*加载本机库和注册本机方法*配方。
2.  右键单击项目**原生以太黑盒**，选择**安卓工具** | **添加原生支持**。
3.  在`cookbook.chapter6.nativethreadsmutex`包下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载原生的`NativeThreadsMutex`库，并调用原生的 `jni_start_threads`方法。
4.  Add two files named `mylog.h` and `NativeThreadsMutex.cpp` in the `jni` folder. `NativeThreadsMutex.cpp` contains the code to start two threads. The two threads will update a shared counter. A part of the code is shown as follows:

    `run_by_thread1`函数由第一个本机线程执行:

    ```
    int cnt = 0;
    int THR = 10;
    void *run_by_thread1(void *arg) {
      int* threadNum = (int*)arg;
      while (cnt < THR) {
        pthread_mutex_lock(&mux1);
        while ( pthread_mutex_trylock(&mux2) ) {
          pthread_mutex_unlock(&mux1);  //avoid deadlock
          usleep(50000);  //if failed to get mux2, release mux1 first
          pthread_mutex_lock(&mux1);
        }
        ++cnt;
        LOGI(1, "thread %d: cnt = %d", *threadNum, cnt);
        pthread_mutex_unlock(&mux1);
        pthread_mutex_unlock(&mux2);
        sleep(1);
      }
    }
    ```

    第二个本机线程执行`run_by_thread2` 功能:

    ```
    void *run_by_thread2(void *arg) {
      int* threadNum = (int*)arg;
      while (cnt < THR) {
        pthread_mutex_lock(&mux2);
        while ( pthread_mutex_trylock(&mux1) ) {
          pthread_mutex_unlock(&mux2);  //avoid deadlock
          usleep(50000);   //if failed to get mux2, release mux1 first
          pthread_mutex_lock(&mux2);
        }
        ++cnt;
        LOGI(1, "thread %d: cnt = %d", *threadNum, cnt);
        pthread_mutex_unlock(&mux2);
        pthread_mutex_unlock(&mux1);
        sleep(1);
      }
    }
    ```

5.  在`jni`文件夹中添加一个`Android.mk`文件，内容如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE := NativeThreadsMutex
    LOCAL_SRC_FILES := NativeThreadsMutex.cpp
    LOCAL_LDLIBS := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  Build and run the Android project, and use the following command to monitor the `logcat` output.

    ```
    $ adb logcat -v time NativeThreadsMutex:I *:S
    ```

    `logcat`输出如下所示:

    ![How to do it...](graphics/1505_06_02.jpg)

7.  We also implemented a native method `jni_start_threads_dead` in `NativeThreadsMutex.cpp`, which can probably cause a deadlock (we may need to run the code a few times to produce the deadlock situation). If we call `jni_start_threads_dead` in `MainActivity.java`, the two threads will start and then block as shown in the following `logcat` output:

    ![How to do it...](graphics/1505_06_03.jpg)

    如本截图所示，**启动**后，两个线程无法进行。

## 它是如何工作的...

示例项目演示了如何使用互斥来同步本机线程。我们对细节描述如下:

### 初始化并销毁互斥体

互斥体可以用`pthread_mutex_init`函数初始化，其原型如下:

```
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
```

输入参数互斥体是一个指向待初始化互斥体的指针，`attr`表示互斥体的属性。如果`attr`设置为`NULL`，将使用默认属性。如果互斥体初始化成功，函数将返回一个零，否则返回一个非零值。

### 注

在`pthread.h`中还定义了一个宏 `PTHREAD_MUTEX_INITIALIZER`，用默认属性初始化互斥体。

当我们处理完互斥体后，我们可以用`pthread_mutex_destroy`函数销毁它，它有以下原型:

```
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

输入参数是指向要销毁的互斥体的指针。

在我们的示例项目中，我们创建了两个互斥体`mux1`和`mux2`来同步两个线程对共享计数器`cnt`的访问。在两个线程退出后，我们销毁了互斥体。

### 使用互斥体

以下四个功能可用于锁定和解锁互斥体:

```
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_lock_timeout_np(pthread_mutex_t *mutex, unsigned msecs);
```

在所有四个函数中，输入参数都是指正在使用的`mutex`对象。返回值为零表示互斥锁成功锁定或解锁。最后一个函数允许我们以毫秒为单位指定等待超时。如果超时后无法获取互斥，则返回`EBUSY`表示失败。

### 注

在一些 pthread 实现中定义了`pthread_mutex_timedlock` 函数，以允许我们指定超时值。但是这个功能在安卓仿生 C 库中是没有的。

我们在前面的例子中演示了函数的用法。在功能`run_by_thread1`中，我们先通过`pthread_mutex_lock`锁定`mux1`，然后通过`pthread_mutex_trylock`锁定`mux2`。如果`mux2`无法锁定，我们解锁`mux1`，休眠 50 毫秒，再试一次。如果`mux2`可以锁定，我们更新共享计数器`cnt`，记录其当前值，然后释放两个互斥体。另一个功能`run_by_thread2`与`run_by_thread1`类似，只是先锁定`mux2`，再锁定`mux1`。这两个函数由两个线程执行。这可以通过下图来说明:

![Using the mutex](graphics/1505_06_04.jpg)

如上图所示，线程 1 需要获取`mux1`，然后`mux2`才能更新`cnt`，而线程 2 需要获取`mux2`，然后`mux1`才能更新`cnt`。在螺纹 1 锁定`mux1`和螺纹 2 锁定`mux2`的情况下，两个螺纹都不能继续。这对应于`pthread_mutex_trylock`返回非零值的情况。如果发生这种情况，一个线程将放弃其互斥体，这样另一个线程就可以继续更新共享计数器`cnt`并释放两个互斥体。请注意，我们可以在代码中将`pthread_mutex_trylock`替换为`pthread_mutex_lock_timeout_np`。鼓励读者自己尝试一下。

我们还实现了一个本地的方法`jni_start_threads_dead`，这可能会导致死锁。线程设置和前面的情况类似，但是我们用`pthread_mutex_lock`代替`pthread_mutex_trylock`，线程不会放弃已经锁定的互斥体。如下图所示:

![Using the mutex](graphics/1505_06_05.jpg)

线程 1 尝试锁定`mux1`然后`mux2`，而线程 2 尝试锁定`mux2`然后`mux1`。在螺纹 1 已经锁定`mux1`和螺纹 2 已经锁定`mux2`的情况下，任何螺纹都不能继续。因为他们不会放弃他们已经获得的互斥锁，这两个线程将永远被阻塞。这被称为死锁。

## 还有更多...

回想一下，函数 `pthread_mutex_init`的第二个输入参数是指向`pthread_mutexattr_t`的指针。在`pthread.h`中定义了一些函数来初始化、操作和销毁互斥属性，包括:

*   `pthread_mutexattr_init`
*   `pthread_mutexattr_destroy`
*   `pthread_mutexattr_gettype`
*   `pthread_mutexattr_settype`
*   `pthread_mutexattr_setpshared`
*   `pthread_mutexattr_getpshared`

感兴趣的读者可以查看`pthread.h`头文件了解更多信息。

# 在 Android NDK 用条件变量同步本机线程

上一个食谱 讨论了如何用互斥锁同步线程。这个配方描述了如何使用条件变量。

## 怎么做...

以下步骤将帮助我们创建一个演示 pthread 条件变量用法的 Android 项目:

1.  创建一个名为`NativeThreadsCondVar`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadscondvar`。有关更多详细说明，请参考[第 2 章](02.html "Chapter 2. Java Native Interface")、 *Java 本机接口*中的*加载本机库和注册本机方法*配方。
2.  右键点击项目**原生图标工具栏**，选择**安卓工具** | **添加原生支持**。
3.  在包`cookbook.chapter6.nativethreadscondvar`下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载原生库`NativeThreadsCondVar`并调用原生`jni_start_threads`方法。
4.  Add two files named `mylog.h` and `NativeThreadsCondVar.cpp` under the `jni` folder. `NativeThreadsCondVar.cpp` contains the code to start two threads. The two threads will update a shared counter. A part of the code is shown as follows:

    `jni_start_threads` 函数初始化互斥体，条件变量并创建两个线程:

    ```
    pthread_mutex_t mux;
    pthread_cond_t cond;
    void jni_start_threads() {
      pthread_t th1, th2;
      int threadNum1 = 1, threadNum2 = 2;
      int ret;
      pthread_mutex_init(&mux, NULL);
      pthread_cond_init(&cond, NULL);
      ret = pthread_create(&th1, NULL, run_by_thread1, 
    void*)&threadNum1);
      LOGI(1, "thread 1 started");
      ret = pthread_create(&th2, NULL, run_by_thread2, 
    void*)&threadNum2);
      LOGI(1, "thread 2 started");
      ret = pthread_join(th1, NULL);
      LOGI(1, "thread 1 end %d", ret);
      ret = pthread_join(th2, NULL);
      LOGI(1, "thread 2 end %d", ret);
      pthread_mutex_destroy(&mux);
      pthread_cond_destroy(&cond);
    }
    ```

    `run_by_thread1` 功能是 所执行的第一个原生线程:

    ```
    int cnt = 0;
    int THR = 10, THR2 = 5;
    void *run_by_thread1(void *arg) {
      int* threadNum = (int*)arg;
      pthread_mutex_lock(&mux);
      while (cnt != THR2) {
          LOGI(1, "thread %d: about to wait", *threadNum);
          pthread_cond_wait(&cond, &mux);
      }
      ++cnt;
      LOGI(1, "thread %d: cnt = %d", *threadNum, cnt);
      pthread_mutex_unlock(&mux);
    }
    ```

    `run_by_thread2`功能由第二个本机线程执行:

    ```
    void *run_by_thread2(void *arg) {
      int* threadNum = (int*)arg;
      while (cnt < THR) {
        pthread_mutex_lock(&mux);
        if (cnt == THR2) {
          pthread_cond_signal(&cond);
        } else {
          ++cnt;
          LOGI(1, "thread %d: cnt = %d", *threadNum, cnt);
        }
        pthread_mutex_unlock(&mux);
        sleep(1);
      }
    }
    ```

5.  在`jni`文件夹下添加一个`Android.mk`文件，内容如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE    := NativeThreadsCondVar
    LOCAL_SRC_FILES := NativeThreadsCondVar.cpp
    LOCAL_LDLIBS    := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  Build and run the Android project, and use the following command to monitor the `logcat` output:

    ```
    $ adb logcat -v time NativeThreadsCondVar:I *:S
    ```

    `logcat`输出如下所示:

    ![How to do it...](graphics/1505_06_06.jpg)

## 它是如何工作的...

虽然互斥体控制线程间共享数据的访问，但条件变量允许线程基于数据的实际值进行同步。典型的用例是一个线程等待一个条件被满足。 如果没有条件变量，线程需要持续检查条件(通常称为轮询)。条件变量允许我们在不消耗资源的情况下处理这种情况。

### 初始化和销毁条件变量

`pthread_cond_init`功能用于初始化条件变量。它有以下原型:

```
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
```

该函数使用`attr`参数引用的属性初始化由`cond`输入参数指向的条件变量。如果`attr`设置为`NULL`，则使用默认属性。

与互斥类似，在`pthread.h`中定义了一个宏`PTHREAD_COND_INITIALIZER`，用默认属性初始化一个条件变量。

在我们完成条件变量后，我们可以通过调用`pthread_cond_destroy`来销毁它，它有以下原型:

```
int pthread_cond_destroy(pthread_cond_t *cond);
```

在我们的示例代码中，我们调用了这两个函数来初始化和销毁名为`cond`的条件变量。

### 使用条件变量:

以下三个函数是常用于操作条件变量的:

```
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
```

这三个函数都接受一个指向正在使用的条件变量的指针。第一个函数还将指向相关互斥体的指针作为第二个参数。请注意，条件变量必须与关联的互斥体一起使用。

第一个函数应该在关联的互斥锁被锁定后调用；否则函数行为是未定义的。它导致调用线程阻塞条件变量。此外，关联的互斥体会自动自动解锁，以便其他线程可以使用它。

第二个和第三个函数用于解除阻塞先前在条件变量上被阻塞的线程。`pthread_cond_broadcast`将解除阻止所有在`cond`指向的条件变量上被阻止的线程，而`pthread_cond_signal`将解除阻止至少一个在`cond`上被阻止的线程。如果在`cond`指定的条件变量上没有线程被阻塞，这两个函数没有任何作用。如果有多个线程需要解锁，顺序取决于调度策略，我们将在本章稍后的*在安卓 NDK* 调度本地线程食谱中讨论。

我们的示例代码演示了这些函数的用法。在`run_by_thread1`函数中，线程一将锁定关联的互斥体，然后等待条件变量`cond`。这将导致线程一释放互斥体`mux`。在功能`run_by_thread2`中，线程二将获得`mux`并增加共享计数器`cnt`。

当`cnt`增加到 5 时，线程二调用`pthread_cond_signal` 解锁线程一，释放`mux`。线程一会自动原子锁定`mux`(注意唤醒时不需要`pthread_mutex_lock`调用)，然后将`cnt`从五增加到六，最后退出。线程二将继续增加`cnt`值至 10 并退出。这解释了前面的截图。

### 注

我们将`pthread_cond_wait(&cond, &mux)`函数放在 while 循环中来处理虚假唤醒。虚假唤醒指的是一个线程被唤醒的情况，即使没有线程发出条件信号。建议我们在返回`pthread_cond_wait` 时，要经常检查情况。更多信息可参考[http://pubs . open group . org/online pubs/7908799/xsh/pthread _ cond _ wait . html](http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_cond_wait.html)。

## 还有更多...

示例项目演示了如何将条件变量用于本机线程同步。我们将在下一节详细介绍。

### 条件变量属性函数

在我们的示例代码中，我们通过将第二个参数`pthread_cond_init`指定为`NULL`来创建带有默认属性的条件变量。`pthread.h`定义了一些函数来初始化和操作条件变量属性。这些功能包括`pthread_condattr_init`、`pthread_condattr_getpshared`、`pthread_condattr_setpshared`和`pthread_condattr_destroy`。我们将不讨论这些功能，因为它们不经常使用。感兴趣的读者可以参考`platforms/android-<API level>/arch-arm/usr/include/`上的`pthread.h`头文件了解更多信息。

### 定时条件变量函数

`pthread.h`还定义了一些函数，允许我们指定等待条件变量的超时值。它们如下所示:

```
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t * mutex, const struct timespec *abstime);
int pthread_cond_timedwait_monotonic_np(pthread_cond_t *cond, pthread_mutex_t        *mutex, const struct timespec  *abstime);
int pthread_cond_timedwait_relative_np(pthread_cond_t *cond, pthread_mutex_t        *mutex, const struct timespec  *reltime);
int pthread_cond_timeout_np(pthread_cond_t *cond, pthread_mutex_t * mutex, unsigned msecs);
```

前两个函数 `pthread_cond_timedwait`和`pthread_cond_timedwait_monotonic_np` 允许我们指定一个绝对时间值。当系统时间等于或超过指定时间时，将返回超时错误。两种功能的区别在于，第一种功能使用挂钟，第二种功能使用`CLOCK_MONOTONIC`钟。系统挂钟可以向前或向后跳转(例如，配置为使用网络时间协议的机器的挂钟可能会在时钟同步时发生变化)，而`CLOCK_MONOTONIC`时钟是从过去某个固定点开始经过的绝对时间，不能突然更改。

### 注

安卓`pthread.h`也定义了一个函数`pthread_cond_timedwait_monotonic`，不推荐使用。它在功能上相当于`pthread_cond_timedwait_monotonic_np`。我们应该总是使用`pthread_cond_timedwait_monotonic_np`来代替。

最后两个函数`pthread_cond_timedwait_relative_np` 和`pthread_cond_timeout_np` 允许我们指定相对于当前时间的相对超时值。区别在于超时值在一个函数中被指定为`timespec`结构，而在另一个函数中被指定为毫秒数。

### 注

本食谱中涉及的几种方法以`np`结尾，表示“不可移植”。这意味着这些功能可能无法在其他 pthread 库中实现。如果我们设计的程序也可以在安卓以外的平台上工作，我们应该避免使用这些功能。

# 在安卓 NDK 系统上同步本地线程和读/写器锁

前面两个食谱涵盖了 线程同步与互斥和条件变量。这个食谱讨论了安卓 NDK 系统中的读写器锁。

## 做好准备...

建议读者在阅读这一篇之前，先阅读前面的两个食谱，分别是在安卓 NDK 上的*同步本地线程和互斥体，以及在安卓 NDK* 上的*同步本地线程和条件变量。*

## 怎么做...

以下步骤将帮助您创建一个演示 pthread 读/写锁用法的 Android 项目:

1.  创建一个名为`NativeThreadsRWLock`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadsrwlock`。有关更多详细说明，请参考[第 2 章](02.html "Chapter 2. Java Native Interface")、 *Java 本机接口*中的*加载本机库和注册本机方法*配方。
2.  右键单击项目**原生线程锁定**，选择**安卓工具** | **添加原生支持**。
3.  在包`cookbook.chapter6.nativethreadsrwlock`下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载本机库`NativeThreadsRWLock`并调用本机方法`jni_start_threads`。
4.  Add two files named `mylog.h` and `NativeThreadsRWLock.cpp` under the `jni` folder. A part of the code in `NativeThreadsRWLock.cpp` is shown as follows:

    `jni_start_threads`开始`pNumOfReader`读者线程和`pNumOfWriter`作家线程:

    ```
    void jni_start_threads(JNIEnv *pEnv, jobject pObj, int pNumOfReader, int pNumOfWriter) {
      pthread_t *ths;
      int i, ret;
      int *thNum;
      ths = (pthread_t*)malloc(sizeof(pthread_t)*(pNumOfReader+pNumOfWriter));
      thNum = (int*)malloc(sizeof(int)*(pNumOfReader+pNumOfWriter));
      pthread_rwlock_init(&rwlock, NULL);
      for (i = 0; i < pNumOfReader + pNumOfWriter; ++i) {
        thNum[i] = i;
        if (i < pNumOfReader) {
          ret = pthread_create(&ths[i], NULL, run_by_read_thread, (void*)&(thNum[i]));
        } else {
          ret = pthread_create(&ths[i], NULL, run_by_write_thread, (void*)&(thNum[i]));
        }
      }
      for (i = 0; i < pNumOfReader+pNumOfWriter; ++i) {
        ret = pthread_join(ths[i], NULL);
      }
      pthread_rwlock_destroy(&rwlock);
      free(thNum);
      free(ths);
    }
    ```

    `run_by_read_thread`功能是由读者线程执行的 :

    ```
    void *run_by_read_thread(void *arg) {
      int* threadNum = (int*)arg;
      int ifRun = 1;
      int accessTimes = 0;
      int ifPrint = 1;
      while (ifRun) {
        if (!pthread_rwlock_rdlock(&rwlock)) {
          if (100000*numOfWriter == sharedCnt) {
            ifRun = 0;
          }
          if (0 <= sharedCnt && ifPrint) {
            LOGI(1, "reader thread %d sharedCnt value before processing %d\n", *threadNum, sharedCnt);
            int j, k;//some dummy processing
            for (j = 0; j < 100000; ++j) {
              k = j*2;
              k = sqrt(k);
            }
            ifPrint = 0;
            LOGI(1, "reader thread %d sharedCnt value after processing %d %d\n", *threadNum, sharedCnt, k);
          }
          if ((++accessTimes) == INT_MAX/5) {
            accessTimes = 0;
            LOGI(1, "reader thread %d still running: %d\n", *threadNum, sharedCnt);
          }
          pthread_rwlock_unlock(&rwlock);
        }
      }
      LOGI(1, "reader thread %d return %d\n", *threadNum, sharedCnt);
      return NULL;
    }
    ```

    `run_by_write_thread`功能由编写器线程执行:

    ```
    void *run_by_write_thread(void *arg) {
      int cnt = 100000, i, j, k;
      int* threadNum = (int*)arg;
      for (i = 0; i < cnt; ++i) {
        if (!pthread_rwlock_wrlock(&rwlock)) {
          int lastShCnt = sharedCnt;
          for (j = 0; j < 10; ++j) {  //some dummy processing
            k = j*2;
            k = sqrt(k);
          }
          sharedCnt = lastShCnt + 1;
          pthread_rwlock_unlock(&rwlock);
        }
      }
      LOGI(1, "writer thread %d return %d %d\n", *threadNum, sharedCnt, k);
      return NULL;
    }
    ```

5.  在 下添加一个`Android.mk`文件到`jni`文件夹，内容如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE    := NativeThreadsRWLock
    LOCAL_SRC_FILES := NativeThreadsRWLock.cpp
    LOCAL_LDLIBS    := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  Build and run the Android project, and use the following command to monitor the `logcat` output:

    ```
    $ adb logcat -v time NativeThreadsRWLock:I *:S
    ```

    `logcat`输出如下所示:

    ![How to do it...](graphics/1505_06_07.jpg)

## 它是如何工作的...

读取器/写入器锁由互斥体和条件变量在内部实现。它有以下规则:

*   如果一个线程试图获取一个资源的 读锁，只要没有其他线程持有该资源的写锁，它就可以成功。
*   如果一个线程试图获取资源的写锁，只有当没有其他线程持有该资源的写锁或读锁时，它才能成功。
*   读/写锁保证只有一个线程可以修改(需要获得写锁)资源，同时允许多个线程读取资源(需要获得读锁)。它还确保在资源被更改时不会发生读取。在接下来的章节中，我们将描述安卓`pthread.h`提供的读写器锁定功能。

### 初始化并销毁读/写锁

以下两个函数被定义为 初始化和销毁读/写器锁:

```
int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

`pthread_rwlock_init`用参数`attr`引用的属性初始化`rwlock`参数指向的读/写器锁。如果`attr`设置为`NULL`，则使用默认属性。 `pthread_rwlock_destroy`接受指向读/写器锁的指针并销毁它。

### 注

还定义了一个宏`PTHREAD_RWLOCK_INITIALIZER`来初始化读/写器锁。在这种情况下使用默认属性。

### 使用读/写锁

定义以下两个函数分别获取读和写锁:

```
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
```

这两个函数都接受一个指向读/写锁的指针，并返回一个零来表示成功。如果无法获取锁，调用线程将被阻塞，直到该块可用或出现错误。

定义以下函数来解锁读锁或写锁:

```
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

在我们的示例代码中，我们演示了这些函数的用法。在`run_by_read_thread`函数中，读取线程需要获取读取锁，才能访问共享资源`sharedCnt`的值。在`run_by_write_thread`功能中，写线程需要在更新共享资源`sharedCnt`之前获取写锁。

如果我们删除锁定和解锁读写锁的代码，构建应用程序，然后重新运行它，输出如下图所示:

![Using a reader/writer lock](graphics/1505_06_08.jpg)

如输出所示，当启用读/写锁定时，共享资源`sharedCnt`被更新为小于最终值的值。原因如下图所示:

![Using a reader/writer lock](graphics/1505_06_09.jpg)

在此图中，两个写入程序获得共享计数器的相同值(N)，并且都将该值从 N 更新为 N+1。当他们将值写回共享计数器时，共享计数器从 N 更新为 N+1，尽管它由两个写入器更新两次。这说明了为什么我们需要写锁。还要注意在读取器线程中，`sharedCnt`的两次读取(一次在处理前，一次在处理后)给了我们两个不同的值，因为写入器已经更新了该值。这有时可能是不可取的，这就是为什么读锁有时是必要的。

## 还有更多...

在`pthread.h`中定义了一些读/写锁定功能。

### 定时读/写锁定和尝试锁定

Android `pthread.h`定义了以下两个 函数，允许调用线程在尝试获取读或写锁时指定超时值:

```
int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);
```

此外，以下两个函数可用于调用线程获取读或写锁，而不会阻塞自身。如果锁不可用，函数将返回非零值，而不是阻塞:

```
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
```

### 读取器/写入器锁定属性功能

Android `pthread.h`定义了一组函数来初始化和操作读/写器锁属性，可以作为第二个参数传递给`pthread_rwlock_init`。这些功能包括`pthread_rwlockattr_init`、`pthread_rwlockattr_destroy`、`pthread_rwlockattr_setpshared`和`pthread_rwlockattr_getpshared`。它们在安卓 NDK 开发中并不常用，因此在此不做讨论。

# 在安卓 NDK 用信号量同步本地线程

我们已经涵盖了互斥、 条件变量，以及读者/作者锁定在前面的三个食谱。这是安卓 NDK 的最后一个线程同步方法，我们将讨论信号量。

## 做好准备...

读者应该先通读一下前面的三个食谱，*在安卓 NDK* 同步本地线程和互斥体，*在安卓 NDK* 同步本地线程和条件变量，*在安卓 NDK* 同步本地线程和读/写器锁。

## 怎么做...

以下步骤将帮助您创建一个演示 pthread 读/写锁用法的 Android 项目:

1.  创建一个名为`NativeThreadsSemaphore`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadssemaphore`。有关更多详细说明，请参考[第 2 章](02.html "Chapter 2. Java Native Interface")、 *Java 本机接口*中的*加载本机库和注册本机方法*配方。
2.  右键单击项目**原生组件**，选择**安卓工具** | **添加原生支持**。
3.  在包`cookbook.chapter6.nativethreadssemaphore`下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载本机库`NativeThreadsSemaphore`并调用本机`jni_start_threads`方法。
4.  Add two files named `mylog.h` and `NativeThreadsSemaphore.cpp` under the `jni` folder. A part of the code in `NativeThreadsSemaphore.cpp` is shown as follows:

    `jni_start_threads`创建`pNumOfConsumer`数量的消费者线程、`pNumOfProducer`数量的生产者线程和`numOfSlots`数量的槽:

    ```
    void jni_start_threads(JNIEnv *pEnv, jobject pObj, int pNumOfConsumer, int pNumOfProducer, int numOfSlots) {
      pthread_t *ths;
      int i, ret;
      int *thNum;
      pthread_mutex_init(&mux, NULL);
      sem_init(&emptySem, 0, numOfSlots);
      sem_init(&fullSem, 0, 0);
      ths = (pthread_t*)malloc(sizeof(pthread_t)*(pNumOfConsumer+pNumOfProducer));
      thNum = (int*)malloc(sizeof(int)*(pNumOfConsumer+pNumOfProducer));
      for (i = 0; i < pNumOfConsumer + pNumOfProducer; ++i) {
        thNum[i] = i;
        if (i < pNumOfConsumer) {
          ret = pthread_create(&ths[i], NULL, 
    un_by_consumer_thread, (void*)&(thNum[i]));
        } else {
          ret = pthread_create(&ths[i], NULL, run_by_producer_thread, (void*)&(thNum[i]));
        }
      }
      for (i = 0; i < pNumOfConsumer+pNumOfProducer; ++i) {
        ret = pthread_join(ths[i], NULL);
      }
      sem_destroy(&emptySem);
      sem_destroy(&fullSem);
      pthread_mutex_destroy(&mux);
      free(thNum);
      free(ths);
    }
    ```

    `run_by_consumer_thread`是消费者线程执行的功能:

    ```
    void *run_by_consumer_thread(void *arg) {
      int* threadNum = (int*)arg;
      int i;
      for (i = 0; i < 4; ++i) {
        sem_wait(&fullSem);
        pthread_mutex_lock(&mux);
        --numOfItems;
        pthread_mutex_unlock(&mux);
        sem_post(&emptySem);
      }
      return NULL;
    }
    ```

    `run_by_producer_thread`是由生产者线程执行的 功能:

    ```
    void *run_by_producer_thread(void *arg) {
      int* threadNum = (int*)arg;
      int i;
      for (i = 0; i < 4; ++i) {
        sem_wait(&emptySem);
        pthread_mutex_lock(&mux);
        ++numOfItems;
        pthread_mutex_unlock(&mux);
        sem_post(&fullSem);
      }
      return NULL;
    }
    ```

5.  在`jni`文件夹下添加一个`Android.mk`文件，内容如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE    := NativeThreadsSemaphore
    LOCAL_SRC_FILES := NativeThreadsSemaphore.cpp
    LOCAL_LDLIBS    := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  Build and run the Android project, and use the following command to monitor the `logcat` output:

    ```
    $ adb logcat -v time NativeThreadsSemaphore:I *:S
    ```

    `logcat`输出如下截图所示:

    ![How to do it...](graphics/1505_06_10.jpg)

## 它是如何工作的...

信号量本质上是整数计数器。信号量支持两个主要操作:

*   **等待**:试图减少信号量值。如果对值为零的信号量调用等待，调用线程将被阻塞，直到在其他地方调用`post`来增加信号量值。
*   **Post** :试图增加信号量值。

信号量相关功能在`semaphore.h`而不是`pthread.h`中定义。接下来，我们描述几个关键功能。

### 注

Android 不支持进程间互斥、条件变量和信号量。安卓使用`Intent`、`Binder`等进行进程间通信和同步。

### 初始化并销毁信号量

以下三个函数被定义为 初始化或破坏信号量:

```
extern int sem_init(sem_t *sem, int pshared, unsigned int value);
extern int    sem_init(sem_t *, int, unsigned int value);
extern int    sem_destroy(sem_t *);
```

前两个函数用于初始化信号量。它们都用参数`value`指示的值初始化输入参数`sem`所指向的信号量。第一个函数还接受一个参数`pshared`，对于线程同步，这个参数应该设置为零。如果设置为非零，信号量可以在进程之间共享，这在 Android 上是不支持的，因此不讨论。

### 使用旗语

以下函数被定义为使用信号量。

```
extern int    sem_trywait(sem_t *);
extern int    sem_wait(sem_t *);
extern int    sem_post(sem_t *);
extern int    sem_getvalue(sem_t *, int *);
```

前两个函数用于等待信号量。如果信号量值不为零，则该值会减少 1。如果该值为零，第一个函数将返回一个非零值来指示失败，而第二个函数将阻塞调用线程。第三个函数用于将信号量值增加 1，最后一个函数用于查询信号量的值。请注意，该值是通过第二个输入参数而不是返回值返回的。

### 注

Android `semaphore.h`还定义了一个名为`sem_timedwait`的函数，允许我们在等待信号量时指定超时值。

在我们的示例项目中，我们使用了两个信号量`emptySem`和`fullSem`，以及一个互斥量`mux`。该应用程序将创建一些生产者线程和消费者线程。`emptySem`信号量用于指示可用于存储生产者线程产生的项目的槽的数量，而`fullSem`是指消费者线程消费的项目的数量。互斥`mux`用于保证没有两个线程可以同时访问共享计数器`numOfItems`。

生产者线程将需要等待`emptySem`信号量。当它被解除阻塞时，生产者获得了一个空槽。它将锁定`mux`然后更新共享计数`numOfItems`，这意味着一个新的项目已经产生。因此，它将调用`fullSem`上的`post`函数来增加其值。

另一方面，消费者线程将等待`fullSem`。当它被解锁时，消费者已经消费了一个项目。它将锁定`mux`，然后更新共享计数`numOfItems`。由于消耗的物品有一个新的空槽可用，因此消耗线程将在`emptySem`上调用 post 来增加其值。

### 注

互斥`mux`也可以用二进制信号量代替。二进制信号量的可能值被限制为 0 和 1。

# 在安卓 NDK 上调度本机线程

这个食谱讨论了如何在安卓 NDK 系统上调度本地线程。

## 做好准备...

建议读者阅读本章[第二章](02.html "Chapter 2. Java Native Interface")、 *Java 原生接口*、*安卓 NDK* 食谱中的【JNI】和*操纵类调用静态和实例方法。*

## 怎么做...

以下步骤将帮助我们创建一个展示安卓 NDK 线程调度的安卓项目:

1.  创建一个名为`NativeThreadsSchedule`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadsschedule`。有关更多详细说明，请参考[第 2 章](02.html "Chapter 2. Java Native Interface")、 *Java 本机接口*中的*加载本机库和注册本机方法*配方。
2.  右键单击项目**原生计划**，选择**安卓工具** | **添加原生支持**。
3.  在包`cookbook.chapter6.nativethreadsschedule`下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载本机库`NativeThreadsSchedule`并调用本机方法。
4.  在`jni`文件夹下添加五个名为`mylog.h`、`NativeThreadsSchedule.h`、`NativeThreadsSchedule.cpp`、`SetPriority.cpp`和`JNIProcessSetThreadPriority.cpp`的文件。最后三个文件中的部分代码如下所示:
    *   The `NativeThreadsSchedule.cpp` file contains the source code to demonstrate the threads scheduling functions defined in `pthread.h`

        `jni_thread_scope`演示如何设置本机线程争用范围:

        ```
        void jni_thread_scope() {
          pthread_attr_t attr;
          int ret;
          pid_t fpId = fork();
          if (0 == fpId) {
            pthread_attr_init(&attr);
            int ret = pthread_attr_setscope(&attr, PTHREAD_SCOPE_PROCESS);
            pthread_t thFive[5];
            int threadNums[5];
            int i;
            for (i = 0; i < 5; ++i) {
              threadNums[i] = i;      ret = pthread_create(&thFive[i], &attr, run_by_thread, (void*)&(threadNums[i]));
            }
            for (i = 0; i < 5; ++i) {
              ret = pthread_join(thFive[i], NULL);
            }
          } else {
            pthread_attr_init(&attr);
            int ret = pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
            pthread_t th1;
            int threadNum1 = 0;
            ret = pthread_create(&th1, &attr, run_by_thread, (void*)&threadNum1);
            ret = pthread_join(th1, NULL);
          }
          //code executed by both processes
          pthread_attr_destroy(&attr);
        }
        ```

        `jni_thread_fifo`演示如何设置本机线程调度策略和优先级:

        ```
        void jni_thread_fifo() {
          pthread_attr_t attr;
          int ret;
          pid_t fpId = fork();
          struct sched_param prio;
          if (0 == fpId) {
            //the child process
            pthread_attr_init(&attr);
            pthread_t thFive[5];
            int threadNums[5];
            int i;
            for (i = 0; i < 5; ++i) {
              if (i == 4) {
                prio.sched_priority = 10;
              } else {
                prio.sched_priority = 1;
              }
              ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
              ret = pthread_attr_setschedparam(&attr, &prio);
              threadNums[i] = i;
              ret = pthread_create(&thFive[i], &attr, run_by_thread, (void*)&(threadNums[i]));
              pthread_attr_t lattr;
              struct sched_param lprio;
              int lpolicy;
              pthread_getattr_np(thFive[i], &lattr);
              pthread_attr_getschedpolicy(&lattr, &lpolicy);
              pthread_attr_getschedparam(&lattr, &lprio);
              pthread_attr_destroy(&lattr);
            }
            for (i = 0; i < 5; ++i) {
              ret = pthread_join(thFive[i], NULL);
            }
          } else {
            //the parent process
            pthread_attr_init(&attr);
            prio.sched_priority = 10;
            ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
            ret = pthread_attr_setschedparam(&attr, &prio);
            pthread_t th1;
            int threadNum1 = 0;
            ret = pthread_create(&th1, &attr, run_by_thread, (void*)&threadNum1);
            pthread_attr_t lattr;
            struct sched_param lprio;
            int lpolicy;
            pthread_getattr_np(th1, &lattr);
            pthread_attr_getschedpolicy(&lattr, &lpolicy);
            pthread_attr_getschedparam(&lattr, &lprio);
            pthread_attr_destroy(&lattr);
            ret = pthread_join(th1, NULL);
          }
          //code executed by both processes
          pthread_attr_destroy(&attr);
        }
        ```

        `run_by_thread`是每个本地线程要执行的实际 功能:

        ```
        void *run_by_thread(void *arg) {
          int cnt = 18000000, i;
          int* threadNum = (int*)arg;
          for (i = 1; i < cnt; ++i) {
            if (0 == i%6000000) {
              LOGI(1, "process %d thread %d: %d", getpid(), *threadNum, i);
            }
          }
          LOGI(1, "process %d thread %d return", getpid(), *threadNum);
        }
        ```

    *   The `SetPriority.cpp` file contains the source code to configure thread nice value through `setpriority`

        `jni_thread_set_priority` 方法创建并连接了五个本地方法:

        ```
        void jni_thread_set_priority() {
          int ret;
          pthread_t thFive[5];
          int threadNums[5];
          int i;
          for (i = 0; i < 5; ++i) {
            threadNums[i] = i;
            ret = pthread_create(&thFive[i], NULL, run_by_thread2, (void*)&(threadNums[i]));
          }
          for (i = 0; i < 5; ++i) {
            ret = pthread_join(thFive[i], NULL);
          }
        }
        ```

        `run_by_thread2`功能是由每个本机线程执行的:

        ```
        void *run_by_thread2(void *arg) {
          int cnt = 18000000, i;
          int* threadNum = (int*)arg;
          switch (*threadNum) {
          case 0:
            setpriority(PRIO_PROCESS, 0, 21);
            break;
          case 1:
            setpriority(PRIO_PROCESS, 0, 10);
            break;
          case 2:
            setpriority(PRIO_PROCESS, 0, 0);
            break;
          case 3:
            setpriority(PRIO_PROCESS, 0, -10);
            break;
          case 4:
            setpriority(PRIO_PROCESS, 0, -21);
            break;
          default:
            break;
          }
          for (i = 1; i < cnt; ++i) {
            if (0 == i%6000000) {
              int prio = getpriority(PRIO_PROCESS, 0);
              LOGI(1, "thread %d (prio = %d): %d", *threadNum, prio, i);
            }
          }
          int prio = getpriority(PRIO_PROCESS, 0);
          LOGI(1, "thread %d (prio = %d): %d return", *threadNum, prio, i);
        }
        ```

    *   The `JNIProcessSetThreadPriority.cpp` file contains the source code to configure thread nice value through the `android.os.P``rocess.setThreadPriority` Java method

        `jni_process_setThreadPriority` 方法创建并连接五个本地线程:

        ```
        void jni_process_setThreadPriority() {
          int ret;
          pthread_t thFive[5];
          int threadNums[5];
          int i;
          for (i = 0; i < 5; ++i) {
            threadNums[i] = i;
            ret = pthread_create(&thFive[i], NULL, run_by_thread3, (void*)&(threadNums[i]));
            if(ret) {
              LOGE(1, "cannot create the thread %d: %d", i, ret);
            }
            LOGI(1, "thread %d started", i);
          }
          for (i = 0; i < 5; ++i) {
            ret = pthread_join(thFive[i], NULL);
            LOGI(1, "join returned for thread %d", i);
          }
        }
        ```

        `run_by_thread3`功能由每个本机线程执行。线程友好值在这里设置:

        ```
        void *run_by_thread3(void *arg) {
          int cnt = 18000000, i;
          int* threadNum = (int*)arg;
          JNIEnv *env;
          jmethodID setThreadPriorityMID;
          cachedJvm->AttachCurrentThread(&env, NULL);
          jclass procClass = env->FindClass("android/os/Process");
          setThreadPriorityMID = env->GetStaticMethodID(procClass, "setThreadPriority", "(I)V");
          switch (*threadNum) {
          case 0:
            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, 21);
            break;
          case 1:
            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, 10);
            break;
          case 2:
            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, 0);
            break;
          case 3:
            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, -10);
            break;
          case 4:
            env->CallStaticVoidMethod(procClass, setThreadPriorityMID, -21);
            break;
          default:
            break;

         }
          //we can also use getThreadPriority(int tid) through JNI interface
          for (i = 1; i < cnt; ++i) {
            if (0 == i%6000000) {
              int prio = getpriority(PRIO_PROCESS, 0);
              LOGI(1, "thread %d (prio = %d): %d", *threadNum, prio, i);
            }
          }
          int prio = getpriority(PRIO_PROCESS, 0);
          LOGI(1, "thread %d (prio = %d): %d return", *threadNum, prio, i);
          cachedJvm->DetachCurrentThread();
        }
        ```

5.  在`jni`文件夹下添加一个`Android.mk`文件，内容如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE    := NativeThreadsSchedule
    LOCAL_SRC_FILES := NativeThreadsSchedule.cpp
    LOCAL_LDLIBS    := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  In `MainActivity.java`, disable all native methods except `jni_thread_scope`. Build the project and run it. Start a terminal and enter the following command to monitor the `logcat` output:

    ```
    $ adb logcat -v time NativeThreadsSchedule:I *:S
    ```

    以下屏幕截图显示了输出:

    ![How to do it...](graphics/1505_06_11.jpg)

7.  In `MainActivity.java`, disable all native methods except `jni_thread_fifo`. Build the project and run it. The `logcat` output is shown in the following screenshot:

    ![How to do it...](graphics/1505_06_12.jpg)

8.  In `MainActivity.java`, disable all native methods except `jni_thread_set_priority`. Build the project and run it. The `logcat` output is shown in the following screenshot:

    ![How to do it...](graphics/1505_06_13.jpg)

9.  In `MainActivity.java`, disable all native methods except `jni_process_setThreadPriority`. Build the project and run it. The `logcat` output is shown in the following screenshot:

    ![How to do it...](graphics/1505_06_14.jpg)

## 它是如何工作的...

我们可以通过设置调度争用范围、线程优先级和调度策略来调度本机线程:

*   **调度争用范围**:它确定当调度器调度线程时线程必须与之竞争的线程
*   **线程优先级**:它决定了当一个 CPU 可用时，调度器选择哪个线程的可能性更大
*   **调度策略**:决定调度器如何调度优先级相同的线程

调整这些设置的一种方法是通过线程属性。在`pthread.h`中定义了以下函数来初始化和销毁`pthread_attr_t`的实例:

```
int pthread_attr_init(pthread_attr_t * attr); 
int pthread_attr_destroy(pthread_attr_t * attr);
```

在这两个函数中，输入参数是指向`pthread_attr_t`对象的指针。我们现在将详细描述争用范围、线程优先级和调度策略。

### 调度争用范围

在典型的 pthread 实现中定义了两个范围，即`PTHREAD_SCOPE_SYSTEM`和`PTHREAD_SCOPE_PROCESS`。系统范围线程与系统范围内的所有其他线程争夺 CPU。另一方面，一个进程范围线程相对于同一进程中的其他线程进行调度。

安卓仿生`pthread.h`定义以下两个功能来设置和获取线程范围:

```
int pthread_attr_setscope(pthread_attr_t *attr, int  scope); 
int pthread_attr_getscope(pthread_attr_t const *attr);
```

这两个函数接受指向 pthread 属性对象的指针作为输入参数。`set`函数还包括第二个参数，让我们传递范围常数。这两个函数返回零表示成功，返回非零值表示失败。

原来安卓不支持以`PTHREAD_SCOPE_PROCESS`为第二输入参数的`pthread_attr_setscope`。换句话说，Android 原生线程总是有系统范围的。如`NativeThreadsSchedule.cpp`的`jni_thread_scope`所示，用`PTHREAD_SCOPE_PROCESS`调用`pthread_attr_setscope`将返回一个非零值。

我们之前在原生方法`jni_thread_scope`中演示了这两个函数的用法。我们在方法中创建了两个过程。子进程运行五个线程，父进程只运行一个线程。因为它们都是系统范围的线程，所以无论线程属于哪个进程，它们都被调度来获得大致相同数量的 CPU 时间片，因此它们大致在相同的时间完成，如*如何做到这一点的第 6 步中的第一个`logcat`截图所示...*本食谱的一节。

### 注

我们调用`fork`在代码中创建一个过程。这是为了演示。强烈建议不要在安卓上创建带有`fork`的原生进程，因为原生进程不会被安卓框架管理，行为不当的原生进程会消耗大量的 CPU 周期并导致安全漏洞。

### 调度策略和线程优先级

每个线程都有一个相关的 调度策略和优先级。当中央处理器可用时，调度程序更有可能选择优先级较高的线程。如果多个线程具有相同的优先级，调度策略将决定如何调度它们。安卓`pthread.h`中定义的策略包括`SCHED_OTHER`、`SCHED_FIFO`和`SCHED_RR`。

### 注

优先级值的有效范围与调度策略相关联。

`SCHED_FIFO` :在 **先进先出(FIFO)** 策略中，一个线程获得 CPU，直到它退出或阻塞。如果被阻塞，它将被放在队列的末尾以获得优先权，队列中的前端线程将被交给中央处理器。此策略允许的优先级范围是 1 到 99。

`SCHED_RR`:**循环赛(RR)** 策略类似于 FIFO，不同的是每个线程只允许运行一定的时间，称为量子。当一个线程完成它的量程时，它会被中断，并被放在它的优先级队列的末尾。该策略允许的优先级范围也是 1 到 99。

`SCHED_OTHER`:这是默认的调度策略。它也允许一个线程只运行有限的次数，但是算法可以不同，比`SCHED_RR`更复杂。该策略下所有线程的优先级均为 0。

有 pthreads 编程经验的人可能熟悉 pthreads 策略和优先功能，包括:

*   `pthread_attr_setschedpolicy`
*   `pthread_attr_getschedpolicy`
*   `pthread_attr_setschedparam`
*   `pthread_attr_getschedparam`

这些功能虽然在安卓`pthread.h`头中有定义，但并不像预期的那样在安卓上运行。因此，这里不讨论细节。

在我们的示例项目中，我们实现了一个本机方法`jni_thread_fifo`，该方法试图将调度策略设置为`SCHED_FIFO`并设置线程优先级。如第二张`logcat`截图所示，线程不受这些设置的影响。

综上所述，所有安卓线程都是优先级为 0 的系统范围线程，调度策略`SCHED_OTHER`。

### 使用良好值/级别进行调度

不错的数值/等级是另一个可以 影响调度器的因素。它也经常被称为优先级，但是在这里我们将使用 nice 值来区分它和我们前面讨论的线程优先级。

我们使用以下两种方法来调整 nice 值:

*   **调用优先级**:这在`SetPriority.cpp`中演示。我们创建了五个不同尼斯值的线程，第三个`logcat`截图在*如何做*部分的第 8 步表示尼斯值较低的线程先返回。
*   **调用 Android . OS . process . setthreadpriority**:这在`JNIProcessSetThreadPriority.cpp`中有说明。如*如何做*部分第 9 步第四张`logcat`截图所示，我们得到了类似调用`setpriority`的结果。事实上，`setThreadPriority`内部称`setpriority`。

# 在 Android NDK 管理本机线程的数据

当我们 想要跨函数保留线程范围的数据时，有几个选项，包括全局变量、参数传递和线程特定的数据键。这个方法讨论了所有三个选项，重点是线程特定的数据键。

## 做好准备...

建议读者在阅读本章之前先阅读*在安卓 NDK* 创建和终止本机线程的方法和*在安卓 NDK* 同步本机线程和互斥体的方法。

## 怎么做...

以下步骤将帮助我们创建一个展示安卓 NDK 数据管理的安卓项目:

1.  创建一个名为`NativeThreadsData`的安卓应用。将包名设置为`cookbook.chapter6.nativethreadsdata`。如需更多详细说明，请参考[第二章](02.html "Chapter 2. Java Native Interface")、 *Java 原生接口*中的*加载原生库和注册原生方法*食谱。
2.  右键单击项目**原生以太数据**，选择**安卓工具** | **添加原生支持**。
3.  在包`cookbook.chapter6.nativethreadsdata`下添加一个名为`MainActivity.java`的 Java 文件。这个 Java 文件只是加载本机库`NativeThreadsData`并调用本机方法。
4.  Add `mylog.h` and `NativeThreadsData.cpp` files under the `jni` folder. The `mylog.h` contains the Android native `logcat` utility functions, while the `NativeThreadsData.cpp` file contains the native code to start multiple threads. A part of the code is shown as follows:

    `jni_start_threads`开始 *n* 线程数，其中 *n* 由变量`pNumOfThreads`指定:

    ```
    void jni_start_threads(JNIEnv *pEnv, jobject pObj, int pNumOfThreads) {
      pthread_t *ths;
      int i, ret;
      int *thNum;
      ths = (pthread_t*)malloc(sizeof(pthread_t)*pNumOfThreads);
      thNum = (int*)malloc(sizeof(int)*pNumOfThreads);
      pthread_mutex_init(&mux, NULL);
      pthread_key_create(&muxCntKey, free_muxCnt);
      for (i = 0; i < pNumOfThreads; ++i) {
        thNum[i] = i;
        ret = pthread_create(&ths[i], NULL, run_by_thread, (void*)&(thNum[i]));
      }
      for (i = 0; i < pNumOfThreads; ++i) {
        ret = pthread_join(ths[i], NULL);
      }
      pthread_key_delete(muxCntKey);
      pthread_mutex_destroy(&mux);
      free(thNum);
      free(ths);
    }
    ```

    `thread_step_1`功能由线程执行。它获取与线程- 特定键相关的数据，并使用它来计算互斥锁被锁定的次数:

    ```
    void thread_step_1() {
      struct timeval st, cu;
      long stt, cut;
      int *muxCntData = (int*)pthread_getspecific(muxCntKey);
      gettimeofday(&st, NULL);
      stt = st.tv_sec*1000 + st.tv_usec/1000;
      do {
               pthread_mutex_lock(&mux);
        (*muxCntData)++;
               pthread_mutex_unlock(&mux);
        gettimeofday(&st, NULL);
        cut = st.tv_sec*1000 + st.tv_usec/1000;
         } while (cut - stt < 10000);
    }
    ```

    `thread_step_2`功能由线程执行。它获取与特定于线程的密钥相关联的数据，并将其打印出来:

    ```
    void thread_step_2(int thNum) {
      int *muxCntData = (int*)pthread_getspecific(muxCntKey);
      LOGI(1, "thread %d: mux usage count: %d\n", thNum, *muxCntData);
    }
    ```

    `run_by_thread`功能 由线程执行:

    ```
    void *run_by_thread(void *arg) {
      int* threadNum = (int*)arg;
      int *muxCntData = (int*)malloc(sizeof(int));
      *muxCntData = 0;
      pthread_setspecific(muxCntKey, (void*)muxCntData);
      thread_step_1();
      thread_step_2(*threadNum);
      return NULL;
    }
    ```

5.  在`jni`文件夹下添加一个`Android.mk`文件，内容如下:

    ```
    LOCAL_PATH := $(call my-dir)
    include $(CLEAR_VARS)
    LOCAL_MODULE    := NativeThreadsData
    LOCAL_SRC_FILES := NativeThreadsData.cpp
    LOCAL_LDLIBS    := -llog
    include $(BUILD_SHARED_LIBRARY)
    ```

6.  Build and run the Android project, and use the following command to monitor the `logcat` output:

    ```
    $ adb logcat -v time NativeThreadsData:I *:S
    ```

    `logcat`输出如下截图所示:

    ![How to do it...](graphics/1505_06_15.jpg)

## 它是如何工作的...

在我们的示例项目中，我们演示了使用全局变量、参数和线程特定的数据键传递数据:

*   互斥体`mux`声明为全局变量，每个线程都可以访问。
*   每个线程都被分配一个线程号作为输入参数。在功能`run_by_thread`中，每个线程将接受的线程号传递给另一个功能`thread_step_2`。
*   我们定义了一个线程特定的键`muxCntKey`。每个线程可以将自己的值与 键相关联。在我们的代码中，我们使用这个键来存储线程锁定互斥体的次数`mux`。

接下来，我们将详细讨论线程特定的数据键。

### 线程特定数据密钥的创建和删除

`pthread.h`中定义了以下两个函数，分别用于创建和删除线程特定的数据键:

```
int pthread_key_create(pthread_key_t *key, void (*destructor_function)(void *));
int pthread_key_delete (pthread_key_t key);
```

`pthread_key_create` 接受指向`pthread_key_t`结构的指针和指向与每个键值相关联的销毁函数的函数指针。销毁功能是可选的，可以设置为`NULL`。在我们的例子中，我们调用`pthread_key_create`来创建名为`muxCntKey`的密钥。

`pthread_key_create`功能返回零表示成功，其他一些值表示失败。如果成功，第一个输入参数`key`将指向新创建的键，并且值`NULL`与所有活动线程中的新键相关联。如果在密钥创建之后创建了新的线程，则值`NULL`也与新线程的密钥相关联。

当线程退出时，键的关联值被设置为`NULL`，然后调用与该键关联的销毁函数，将该键先前的关联值作为唯一的输入参数。在我们的示例代码中，我们定义了一个销毁函数`free_muxCnt`来释放与密钥`muxCntKey`相关的数据内存。

`pthread_key_delete`比较简单。它接受`pthread_key_create`创建的密钥并删除它。它返回零表示成功，返回非零值表示失败。

### 设置并获取线程特定的数据

安卓`pthread.h`为线程特定的数据管理定义了以下两个功能:

```
int pthread_setspecific(pthread_key_t key, const void *value);
void *pthread_getspecific(pthread_key_t key);
```

`pthread_setspecific`函数接受一个先前创建的数据键和一个指向与该键相关的数据的指针。它返回零表示成功，否则返回非零值。不同的线程可以调用这个函数，将不同的值绑定到同一个键。

`pthread_getspecific`接受一个先前创建的数据和键，并返回一个指向调用线程中与该键相关联的数据的指针。

在示例代码的`run_by_thread`函数中，我们将初始化为零的整数变量与`muxCntKey`键相关联。在函数`thread_step_1`中，我们得到与键相关的整数变量，并使用它来计算`mux`被锁定的次数。在函数`thread_step_2`中，我们再次获取与`muxCntKey`关联的整数变量并打印其值。