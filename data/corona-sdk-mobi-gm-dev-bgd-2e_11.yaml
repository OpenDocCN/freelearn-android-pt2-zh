- en: Chapter 11. Implementing In-App Purchases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 实现 应用内购买
- en: '*In-App Purchase is an optional feature that developers can use to embed a
    store directly within an app. Sometimes, you may want to extend some features
    in your current game to keep your consumers interested in playing. Here''s your
    chance, and possibly, more revenue in your pocket!*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*应用内购买是开发者可以选择使用的一个功能，可以直接在应用中嵌入商店。有时，你可能希望扩展当前游戏的一些功能，以保持玩家的兴趣。现在就是你的机会，也许还能让你的口袋里收入更多！*'
- en: This chapter is only concerned with In-App Purchases in the Apple iTunes Store
    for the iOS platform. Android developers who want to implement In-App Purchases
    in their apps can refer to for reference. The set up for In-App Purchase is done
    in a similar fashion for iOS and Android. There are, however, some differences
    that need to be set up in your `build.settings` file and code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅关注 iOS 平台上 Apple iTunes Store 的应用内购买。希望在应用中实现应用内购买的 Android 开发者可以参考相关内容。iOS
    和 Android 的应用内购买设置方式类似。但是，在 `build.settings` 文件和代码中需要设置一些不同之处。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application interface used here is frequently updated. However, you will
    be able to perform all the steps irrespective of the interface you're using.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的应用程序界面经常更新。但无论你使用的是哪种界面，你都能完成所有步骤。
- en: 'We''ll cover the following in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章介绍以下内容：
- en: Consumable, nonconsumable, and subscription purchases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗性、非消耗性和订阅购买
- en: Making transactions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行交易
- en: Restoring purchased items
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复已购项目
- en: Initializing Corona's store module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 Corona 的商店模块
- en: Creating and testing In-App Purchases on a device
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备上创建和测试应用内购买
- en: Ready, set, go!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 准备，设定，出发！
- en: The wonders of In-App Purchase
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用内购买的奇妙之处
- en: 'The purpose of implementing In-App Purchase is to add an in-app payment functionality
    to collect payment for enhanced functionality or additional content usable in
    your game. The following are options of incorporating this feature:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实施应用内购买的目的在于为应用添加应用内支付功能，以收取增强功能或游戏内可使用的额外内容的费用。以下是将此功能融入应用的选择：
- en: A game that offers new level packs to play outside the default content
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供除默认内容之外的全新关卡包进行游戏的应用
- en: A freemium game that allows you to purchase virtual currency to create or build
    new assets during game play
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你通过购买虚拟货币在游戏过程中创建或建立新资产的高级游戏
- en: Adding additional characters or special power ups to enhance game elements
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外的角色或特殊能力提升以增强游戏元素
- en: These are some examples that can be implemented with In-App Purchases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以使用应用内购买实现的示例。
- en: In-App Purchases allow users to purchase additional content within an application.
    The App Store manages transaction information only. Developers cannot use the
    App Store to deliver content. So, either you bundle content with your app when
    you ship it (it will be unlocked on purchase), or you have to work out your own
    system to download the data, if you wish to deliver content.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用内购买允许用户在应用程序内购买额外内容。App Store 只管理交易信息。开发者不能使用 App Store 传送内容。因此，你可以在发布应用时捆绑内容（购买后即可解锁），或者如果你希望传送内容，需要自己设计下载数据的系统。
- en: Types of In-App Purchases
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用内购买的类型
- en: There are several In-App Purchase types that you can apply in your apps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在应用中使用几种不同的应用内购买类型。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on In-App Purchases on the Apple website at [https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html](https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Apple 网站上找到更多关于应用内购买的信息，地址为[https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html](https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html)。
- en: '**Consumable**: These are products that must be purchased each time the user
    needs that item. They''re typically one-time services, such as money in an app
    where you need to pay for supplies to build structures.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消耗性**：这些是用户每次需要该物品时都必须购买的产品。它们通常是单次服务，如在需要支付建造建筑物的供应品的游戏中使用的货币。'
- en: '**Nonconsumable**: These are products that only need to be purchased once by
    the user. These could be additional level packs in a game.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非消耗性**：这些是用户只需购买一次的产品。这些可能是游戏中的附加关卡包。'
- en: '**Auto-renewing subscriptions**: These are products that allow the user to
    purchase in-app content for a set duration of time. An example of an auto-renewable
    subscription would be a magazine or newspaper that takes advantage of the auto-renewing
    functionality built into iOS.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动续订订阅**：这些产品允许用户购买一定时间内的应用内内容。一个自动续订订阅的例子是一份利用 iOS 内置的自动续订功能的杂志或报纸。'
- en: '**Free subscriptions**: These are used to put free subscription content in
    Newsstand. Once a user signs up for a free subscription, it will be available
    on all devices associated with that user''s Apple ID. Note that free subscriptions
    do not expire and can only be offered in Newsstand-enabled apps.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免费订阅**：这些用于在 Newsstand 中放置免费订阅内容。一旦用户注册了免费订阅，它将在与该用户 Apple ID 相关联的所有设备上可用。请注意，免费订阅不会过期，并且只能在启用
    Newsstand 的应用中提供。'
- en: '**Non-renewing subscriptions**: Similar to auto-renewable subscriptions, these
    are non-renewing subscriptions that require a user to renew each time the subscription
    is due to expire. Your app must contain code that recognizes when the expiration
    occurs. It must also prompt the user to purchase a new subscription. An auto-renewable
    subscription eliminates these steps.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非续订订阅**：与自动续订订阅类似，这些是非续订订阅，要求用户在订阅到期时每次都进行续订。你的应用必须包含识别到期发生的代码。还必须提示用户购买新的订阅。自动续订订阅则省略了这些步骤。'
- en: Corona's store module
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Corona 的商店模块
- en: 'Applying In-App Purchases in your application can be a little mind-boggling
    and tedious process. Integrating it with Corona requires calling the store module:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中应用应用内购买可能是一个相当令人困惑和繁琐的过程。与 Corona 集成需要调用商店模块：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The store module is already incorporated to the Corona API, similar to Facebook
    and Game Network. You can find more information on Corona's store module at [http://docs.coronalabs.com/daily/guide/monetization/IAP/index.html](http://docs.coronalabs.com/daily/guide/monetization/IAP/index.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 商店模块已经整合到 Corona API 中，类似于 Facebook 和游戏网络。你可以在 [http://docs.coronalabs.com/daily/guide/monetization/IAP/index.html](http://docs.coronalabs.com/daily/guide/monetization/IAP/index.html)
    了解更多关于 Corona 商店模块的信息。
- en: store.init()
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.init()
- en: 'The `store.init()` function must be called when handling store transactions
    to your app. It activates In-App Purchases and allows you to receive callbacks
    with the listener function you specify:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理应用程序中的商店交易时，必须调用 `store.init()` 函数。它激活了应用内购买，并允许你使用指定的监听函数接收回调：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only parameter here is `listener`. It's a function that handles transaction
    callback events.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的参数是 `listener`。它是一个处理交易回调事件的功能函数。
- en: 'The following blocks determine the transaction states that can occur during
    an In-App Purchase. The four different states are purchased, restored, cancelled,
    and failed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块确定了在应用内购买过程中可能发生的交易状态。四种不同的状态分别是：购买、恢复、取消和失败：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: event.transaction
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.transaction
- en: The `event.transaction` object contains the transaction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`event.transaction` 对象包含了交易信息。'
- en: 'The transaction object supports the following read-only properties:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 交易对象支持以下只读属性：
- en: '`"state"`: This is a string containing the state of the transaction. Valid
    values are `"purchased"`, `"restored"`, `"cancelled"`, and `"failed"`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"state"`：这是一个字符串，包含交易的状态。有效的值有 `"purchased"`、`"restored"`、`"cancelled"` 和
    `"failed"`。'
- en: '`"productIdentifier"`: This is the product identifier associated with the transaction.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"productIdentifier"`：这是与交易关联的产品标识符。'
- en: '`"receipt"`: This is a unique receipt returned from the App Store. It is returned
    as a hexadecimal string.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"receipt"`：这是从 App Store 返回的唯一收据。它以十六进制字符串的形式返回。'
- en: '`"signature"`: This is a string used to verify the purchase. For Google Play,
    it is returned by `"inapp_signature"`. In iOS, it returns `nil`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"signature"`：这是一个用于验证购买的有效字符串。对于 Google Play，它由 `"inapp_signature"` 返回。在 iOS
    中，它返回 `nil`。'
- en: '`"identifier"`: This is a unique transaction identifier returned from the App
    Store. It is a string.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"identifier"`：这是从 App Store 返回的唯一交易标识符。它是一个字符串。'
- en: '`"date"`: This is the date the transaction occurred.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"date"`：这是交易发生的日期。'
- en: '`"originalReceipt"`: This is a unique receipt returned from the App Store from
    the original purchase attempt. It is mostly relevant in the case of a restore.
    It is returned as a hexadecimal string.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"originalReceipt"`：这是从 App Store 原始购买尝试返回的唯一收据。它主要在恢复的情况下相关。它以十六进制字符串的形式返回。'
- en: '`"originalIdentifier"`: This is a unique transaction identifier returned from
    the Store from the original purchase attempt. This is mostly relevant in the case
    of a restore. It is a string.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"originalIdentifier"`：这是从商店原始购买尝试返回的唯一交易标识符。这在恢复的情况下最为相关。它是一个字符串。'
- en: '`"originalDate"`: This is the date of the original transaction. It is mostly
    relevant in the case of a restore.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"originalDate"`：这是原始交易的日期。这在恢复的情况下最为相关。'
- en: '`"errorType"`: This is the type of error that occurred when the state is `"failed"`
    (a string).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"errorType"`：这是状态为`"failed"`时发生的错误类型（一个字符串）。'
- en: '`"errorString"`: This is a descriptive error message of what went wrong in
    the `"failed"` case.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"errorString"`：这是在`"failed"`情况下出现问题的描述性错误信息。'
- en: store.loadProducts()
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.loadProducts()
- en: 'The `store.loadProducts()` function retrieves information about items available
    for sale. This includes the price of each item, a name, and a description:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`store.loadProducts()`函数获取有关待售商品的信息。这包括每件商品的价格、名称和描述：'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Its parameters are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它的参数如下：
- en: '`arrayOfProductIdentifiers`: This is an array with each element containing
    a string of the product ID of the In-App product you want to know about'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayOfProductIdentifiers`：这是一个数组，每个元素包含你想要了解的应用内产品产品ID的字符串。'
- en: '`listener`: This is a callback function that is invoked when the store finishes
    retrieving the product information'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listener`：这是一个回调函数，当商店完成获取产品信息时被调用'
- en: 'The following block displays the list of products that are available in the
    app. Information about the product can be retrieved from the `loadProductsCallback()`
    function and determines whether it is valid or invalid:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了应用中可用的产品列表。可以通过`loadProductsCallback()`函数获取产品信息，并判断其有效或无效：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: event.products
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.products
- en: When a requested list of products is returned by `store.loadProducts()`, the
    array of product information can be accessed through the `event.products` property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当`store.loadProducts()`返回请求的产品列表时，可以通过`event.products`属性访问产品信息数组。
- en: 'Product information, such as title, description, price, and the product identifier,
    is contained in a table:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 产品信息，如标题、描述、价格和产品标识符，包含在表格中：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Each entry in the `event.products` array supports the following fields:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`event.products`数组中的每个条目支持以下字段：'
- en: '`title`: This is the localized name of the item'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是项目的本地化名称'
- en: '`description`: This is the localized description of the item'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：这是项目的本地化描述'
- en: '`price`: This is the price of an item (as a number)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price`：这是项目的价格（作为一个数字）'
- en: '`productIdentifier`: This is the product identifier'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productIdentifier`：这是产品标识符'
- en: event.invalidProducts
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.invalidProducts
- en: When `store.loadProducts()` returns its requested list of products, any products
    you requested that are not available for sale will be returned in an array. You
    can access the array of invalid products through the `event.invalidProducts` property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当`store.loadProducts()`返回其请求的产品列表时，任何你请求的不可售产品将以数组形式返回。你可以通过`event.invalidProducts`属性访问无效产品的数组。
- en: 'This is a Lua array containing the product identifier string requested from
    `store.loadProducts()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Lua数组，包含从`store.loadProducts()`请求的产品标识符字符串：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: store.canMakePurchases
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.canMakePurchases
- en: The `store.canMakePurchases` function returns true if purchases are allowed,
    and false otherwise. Corona's API can check whether purchasing is possible. iOS
    devices provide a setting that disables purchasing. This can be used to avoid
    purchasing apps accidentally.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`store.canMakePurchases`函数如果允许购买则返回true，否则返回false。Corona的API可以检查是否可以进行购买。iOS设备提供了一个禁用购买的设置。这可以用来避免意外购买应用。'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: store.purchase()
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.purchase()
- en: The `store.purchase()` function initiates a purchase transaction on a provided
    list of products.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`store.purchase()`函数启动对提供的产品列表的购买交易。'
- en: 'This function will send purchase requests to the store. The listener specified
    in `store.init()` will be invoked when the store finishes processing the transaction:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将向商店发送购买请求。当商店处理完交易后，将在`store.init()`中指定的监听器将被调用：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Its only parameter is `arrayOfProducts`, an array specifying the products you
    want to buy:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它唯一的参数是`arrayOfProducts`，一个指定你想要购买的产品数组：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: store.finishTransaction()
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.finishTransaction()
- en: This function notifies the App Store that a transaction is complete.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通知应用商店交易已完成。
- en: After you finish handling a transaction, you must call `store.finishTransaction()`
    on the transaction object. If you don't do this, the App Store will think your
    transaction was interrupted and will attempt to resume it on the next application
    launch.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成事务处理后，必须在该事务对象上调用`store.finishTransaction()`。如果你不这样做，App Store会认为你的事务被中断，并会在下次应用程序启动时尝试恢复它。
- en: 'Syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: 'Transaction: The `transaction` object belonging to the transaction you want
    to mark as finished.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 事务：属于你想标记为完成的事务的`transaction`对象。
- en: 'Example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: store.restore()
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: store.restore()
- en: 'Any previously purchased items that have been wiped clean from a device or
    upgraded to a new device can be restored on the user''s account without paying
    for the product again. The `store.restore()` API initiates this process. Transactions
    can be restored by the `transactionCallback` listener, which is registered with
    `store.init()`. The transaction state will be `"restored"` and your app may then
    make use of the `"originalReceipt"`, `"originalIdentifier"`, and `"originalDate"`
    fields of the transaction object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何之前购买的项目，如果从设备上清除或升级到新设备，都可以在用户的账户上恢复，无需再次为产品付费。`store.restore()` API会启动这个过程。通过使用`store.init()`注册的`transactionCallback`监听器，可以恢复事务。事务状态将是`"restored"`，然后你的应用程序可以使用事务对象的`"originalReceipt"`、`"originalIdentifier"`和`"originalDate"`字段。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The block will run through the `transactionCallback()` function and determine
    whether a product has been previously purchased from the application. If the result
    is true, `store.restore()` will initiate the process of retrieving the product
    without asking the user to pay for it again:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码块将通过`transactionCallback()`函数运行，并确定之前是否从应用程序购买过产品。如果结果为真，`store.restore()`将启动获取产品的过程，而无需让用户再次付费：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create an In-App Purchase
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用内购买
- en: 'Before reading on, make sure you know how to create an App ID and Distribution
    Provisioning Profile from the iOS Provisioning Portal. Also, make sure you know
    how to manage new applications in iTunes Connect. If you''re unsure, refer to
    [Chapter 10](ch10.html "Chapter 10. Optimizing, Testing, and Shipping Your Games"),
    *Optimizing, Testing, and Shipping Your Games*, for more information. Here are
    the things that need to be ready in your app before creating an In-App Purchase:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你知道如何从iOS配置门户创建App ID和分发配置文件。还要确保你知道如何在iTunes Connect中管理新应用程序。如果你不确定，请参考[第10章](ch10.html
    "第10章. 优化、测试和发布你的游戏")，*优化、测试和发布你的游戏*，了解更多信息。在创建应用内购买之前，以下是你应用中需要准备的事项：
- en: A Distribution Certificate already made for your app.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用已经制作好的分发证书。
- en: 'An explicit App ID for your application, for example, `com.companyname.appname`.
    Do not substitute a wildcard character (asterisk: "*"). The Bundle ID needs to
    be completely unique in order to use the In-App Purchase function.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用程序指定一个显式的App ID，例如，`com.companyname.appname`。不要使用通配符（星号："*"）。为了使用应用内购买功能，捆绑ID需要完全唯一。
- en: An ad hoc Distribution Provisioning Profile (used to test In-App Purchases).
    When you're ready to submit an app with In-App Purchase, an App Store Distribution
    Provisioning Profile is required.![Create an In-App Purchase](img/9343OT_11_01.jpg)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个临时分发配置文件（用于测试应用内购买）。当你准备提交带有应用内购买的应用程序时，需要一个App Store分发配置文件。[创建应用内购买](img/9343OT_11_01.jpg)
- en: Your application information must be set up in iTunes Connect. You do not need
    to get your binary uploaded to create or test In-App Purchases.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序信息必须在iTunes Connect中设置。在创建或测试应用内购买时，你不需要上传你的二进制文件。
- en: Make sure that you have an iOS Paid Applications contract in effect with Apple.
    If you don't, you'll need to request it in **Contracts, Tax, and Banking** located
    on the iTunes Connect home page. You will need to provide your banking and tax
    information in order to offer In-App Purchases in your apps.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你已经与苹果公司签订了有效的iOS付费应用程序合同。如果没有，你需要在iTunes Connect主页上的**合同、税务和银行信息**中申请。你需要提供你的银行和税务信息，以便在应用中提供应用内购买。
- en: Time for action – creating the In-App Purchase in iTunes Connect
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——在iTunes Connect中创建应用内购买
- en: 'We''ll be implementing an In-App Purchase through iTunes Connect and create
    a scenario in a sample application that will call a transaction. Let''s create
    the Product ID that will be used in our In-App Purchase:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过iTunes Connect实现应用内购买，并在示例应用程序中创建一个将调用事务的场景。让我们创建将在应用内购买中使用的产品ID：
- en: Log in to iTunes Connect. On the home page, select **Manage Your Applications**.
    Select the application you plan to add an In-App Purchase to.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到iTunes Connect。在首页上，选择**管理您的应用程序**。选择您计划添加应用内购买的应用程序。
- en: Once you're on the app summary page, click on the **Manage In-App Purchases**
    button and then click on the **Create New** button in the top-left corner.![Time
    for action – creating the In-App Purchase in iTunes Connect](img/9343OT_11_02.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在应用概览页面时，点击**管理应用内购买**按钮，然后在左上角点击**创建新购买项目**按钮。[![行动时间——在iTunes Connect中创建应用内购买](img/9343OT_11_02.jpg)]
- en: You will be brought to a page that shows you a summary of the types of In-App
    Purchases that you can create. For this example, **Non-Consumable** is selected.
    We'll be creating a product that needs to be purchased only once.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个页面，该页面显示了您可以创建的应用内购买类型概览。在本例中，选择了**非消耗性**。我们将创建一个只需购买一次的产品。
- en: In the next page is the area where you fill in the information about the product.
    The information applies to consumable, nonconsumable, and non-renewing subscription
    In-App Purchases. Fill the **Reference Name** and **Product ID** fields for your
    product. The Product ID needs to be a unique identifier and can be any alphanumeric
    sequence of letters and numbers (for example, `com.companyname.appname.productid`).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个页面，您需要填写有关产品的信息。这些信息适用于消耗性、非消耗性和非续订订阅的应用内购买。为您的产品填写**参考名称**和**产品ID**字段。产品ID需要是一个唯一的标识符，可以是字母和数字的任意组合（例如，`com.companyname.appname.productid`）。
- en: Note
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Auto-renewing subscriptions require you to generate a shared secret. If you
    are to use auto-renewing subscriptions in your app, then on the **Manage in-App
    Purchases** page, click on the **View or generate a shared secret** link. You
    will be brought to a page to generate the shared secret. Click on the **Generate**
    button. The shared secret will display a string of 32 randomly generated alphanumeric
    characters. When you choose auto-renewing subscriptions, the difference from the
    other In-App Purchase types is that you have to choose the duration between auto-renewals
    of your product. For more information on auto-renewing subscriptions, go to [http://developer.apple.com/library/ios/iTunesConnectGuide](http://developer.apple.com/library/ios/iTunesConnectGuide).
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动续订订阅需要您生成一个共享密钥。如果您要在应用中使用自动续订订阅，请在**管理应用内购买**页面上，点击**查看或生成共享密钥**链接。您将被带到生成共享密钥的页面。点击**生成**按钮。共享密钥将显示32个随机生成的字母数字字符。当您选择自动续订订阅时，与其他应用内购买类型的不同之处在于，您必须选择产品之间自动续订的持续时间。有关自动续订订阅的更多信息，请访问[http://developer.apple.com/library/ios/iTunesConnectGuide](http://developer.apple.com/library/ios/iTunesConnectGuide)。
- en: '![Time for action – creating the In-App Purchase in iTunes Connect](img/9343OT_11_03.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——在iTunes Connect中创建应用内购买](img/9343OT_11_03.jpg)'
- en: Click on the **Add Language** button. Select the language that will be used
    for the In-App Purchase. Add a display name for your product and a short description
    about it. When you're done, click on the **Save** button.![Time for action – creating
    the In-App Purchase in iTunes Connect](img/9343OT_11_04.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加语言**按钮。选择将用于应用内购买的语言。为您的产品添加一个显示名称和简短描述。完成后，点击**保存**按钮。[![行动时间——在iTunes
    Connect中创建应用内购买](img/9343OT_11_04.jpg)]
- en: In **Pricing and Availability**, ensure that **Yes** is selected for **Cleared
    for Sale**. In the **Price Tier** drop-down menu, select the price you plan to
    sell your In-App Purchase for. In this example, **Tier 1** is selected. In **Screenshot
    for Review**, you'll need to upload a screenshot of your In-App Purchase. If you're
    testing on an ad hoc build, the screenshot is not necessary. Once you're ready
    for distribution, the screenshot is required so that the In-App Purchase can be
    reviewed upon submittal. Click on the **Save** button when done.![Time for action
    – creating the In-App Purchase in iTunes Connect](img/9343OT_11_05.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**定价和可用性**部分，确保**已清除销售**选项选择为**是**。在**价格层级**下拉菜单中，选择您计划销售应用内购买的价格。在本例中，选择了**层级1**。在**审核截图**部分，您需要上传应用内购买的截图。如果您在临时版本上进行测试，则无需截图。当您准备分发时，需要上传截图以便在提交审核时对应用内购买进行审查。完成后点击**保存**按钮。[![行动时间——在iTunes
    Connect中创建应用内购买](img/9343OT_11_05.jpg)]
- en: You will see a summary of the In-App Purchase that you created on the next page.
    Click on the **Done** button if all of the information looks correct.![Time for
    action – creating the In-App Purchase in iTunes Connect](img/9343OT_11_06.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在下一页看到你创建的应用内购买的摘要。如果所有信息看起来都正确，请点击**完成**按钮。![动手时间——在iTunes Connect中创建应用内购买](img/9343OT_11_06.jpg)
- en: '*What just happened?*'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Adding a new In-App Purchase is a very simple process. The information contained
    in the Product ID is what will be called upon during a transaction. Managing the
    type of In-App Purchase entirely depends on what type of product you want to sell
    in your game. This example demonstrates the purpose of taking a nonconsumable
    product that represents purchasing/unlocking a new level in a game. This is a
    common scenario for users who to want to sell level packs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的应用内购买是一个非常简单的过程。交易过程中将调用产品ID中包含的信息。管理应用内购买类型完全取决于你想在游戏中销售的产品类型。这个例子展示了购买/解锁游戏中一个新级别的非消耗性产品的目的。这对于想要销售关卡包的用户来说是一个常见场景。
- en: Your application does not have to be completed to test In-App Purchases. All
    that is required is to have your application information set up in iTunes Connect
    so that you can manage the features of In-App Purchase.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序不需要完成就可以测试应用内购买。需要做的是在iTunes Connect中设置你的应用程序信息，这样你就可以管理应用内购买的功能。
- en: Time for action – using the Corona store module to create an In-App Purchase
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——使用Corona商店模块创建应用内购买
- en: 'Now that we have set up our Product ID for our In-App Purchase in iTunes Connect,
    we can implement it in our app to purchase the product we''re going to sell. A
    sample menu app of Breakout was created to demonstrate how to purchase levels
    within an application. The app contains two levels in the level select screen.
    The first is available by default. The second is locked and can only be unlocked
    by purchasing it for $0.99\. We''re going create a level select screen so that
    it acts in that manner:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在iTunes Connect中为应用内购买设置了产品ID，我们就可以在应用中实现它，以购买我们将要销售的产品。创建了一个Breakout的示例菜单应用，以演示如何在应用程序内购买关卡。该应用在关卡选择屏幕上包含两个级别。第一个默认可用。第二个被锁定，只能通过支付0.99美元来解锁。我们将创建一个关卡选择屏幕，使其按此方式操作：
- en: In the `Chapter 11` folder, copy the `Breakout In-App Purchase Demo` project
    folder to your desktop. You can download the project files accompanying this book
    from the Packt Publishing website. You will notice that the configuration, libraries,
    assets, and `.lua` files needed are included.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`第11章`文件夹中，将`Breakout应用内购买演示`项目文件夹复制到你的桌面。你可以从Packt Publishing网站下载伴随这本书的项目文件。你会注意到，配置、库、资源和`.lua`文件都已包含。
- en: Create a new `levelselect.lua` file and save it to the project folder.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`levelselect.lua`文件并将其保存到项目文件夹中。
- en: 'Set up the scene with the following variables and saving/loading functions.
    The most important variable of all is `local store = require("store")`, which
    calls the store module for In-App Purchases:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下变量和保存/加载函数设置场景。最重要的变量是`local store = require("store")`，它调用应用内购买的商店模块：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `create()` event and remove the `"mainmenu"`, `"level1"`, and `"level2"`
    scenes:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`create()`事件，并移除`"mainmenu"`、`"level1"`和`"level2"`场景：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, create the `show()` event and an array that contains a string of **Product
    ID** set as an In-App Purchase in iTunes Connect:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`show()`事件和一个数组，其中包含设置为iTunes Connect中应用内购买的**产品ID**的字符串：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a local blank table for `validProducts` and `invalidProducts`. Create a
    local function called `unpackValidProducts()` that checks valid and invalid Product
    IDs:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`validProducts`和`invalidProducts`添加一个本地空表。创建一个名为`unpackValidProducts()`的本地函数，检查有效的和无效的产品ID：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a local function called `loadProductsCallback()` with an `event` parameter.
    Set up the handler to receive product information with print statements:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`loadProductsCallback()`的本地函数，带有一个`event`参数。设置处理程序以使用打印语句接收产品信息：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a local function called `transactionCallback()` with an `event` parameter.
    Add several cases of results that are supposed to occur for every `transaction.state`
    event. When the store is done with the transaction, call `store.finishTransaction(event.transaction)`
    before the end of the function. Set up a another local function called `setUpStore()`
    with an `event` parameter to call `store.loadProducts(listOfProducts, loadProductsCallback)`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `transactionCallback()` 的局部函数，带有 `event` 参数。为每个 `transaction.state` 事件可能发生的结果添加几种情况。当商店完成交易时，在函数结束前调用
    `store.finishTransaction(event.transaction)`。设置另一个名为 `setUpStore()` 的局部函数，带有 `event`
    参数，以调用 `store.loadProducts(listOfProducts, loadProductsCallback)`：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set up the display objects for the background and level **1** button:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置背景和关卡**1**按钮的显示对象：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Set up the level **2** button placement:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置关卡**2**按钮的位置：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the local `onBuyLevel2Touch(event)` function and create an `if` statement
    to check `event.phase == ended and level2Unlocked ~= tonumber(loadedLevel2Unlocked)`
    so that the scene changes to `mainmenu.lua`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用局部函数 `onBuyLevel2Touch(event)` 并创建一个 `if` 语句，检查 `event.phase == ended and
    level2Unlocked ~= tonumber(loadedLevel2Unlocked)`，以便场景切换到 `mainmenu.lua`：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Within the same `if` statement, create a local function called `buyLevel2()`
    with a `product` parameter to call the `store.purchase()` function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 `if` 语句中，创建一个名为 `buyLevel2()` 的局部函数，带有 `product` 参数，以调用 `store.purchase()`
    函数：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add an `elseif` statement to check when level 2 has been purchased and unlocked,
    once the transaction has been completed:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `elseif` 语句，以检查在交易完成后，是否已购买并解锁了关卡2：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Activate the In-App Purchase with `store.init()` and call `transactionCallback()`
    as the parameter. Also call `setupMyStore()` with a timer set at 500 milliseconds:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `store.init()` 激活应用内购买，并将 `transactionCallback()` 作为参数调用。同时以500毫秒的定时器调用 `setupMyStore()`：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the **Close** UI button and a local function called `onCloseTouch()`
    with an event parameter. Have the function transition scenes to `loadmainmenu.lua`
    upon release of the **Close** button. Close the `enterScene()` event with `end`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**关闭**的UI按钮，以及一个名为 `onCloseTouch()` 的局部函数，带有事件参数。让该函数在释放**关闭**按钮时，切换到 `loadmainmenu.lua`
    场景。使用 `end` 结束 `enterScene()` 事件：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `hide()` and `destroy()` events. Within the `hide()` event, cancel
    the `menuTimer` timer. Add all the event listeners for the scene events and `return
    scene`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `hide()` 和 `destroy()` 事件。在 `hide()` 事件中，取消 `menuTimer` 定时器。为场景事件添加所有事件监听器并
    `return scene`：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save the file and run the project in the Corona simulator. When you select the
    **Play** button, you will notice a **1** button and a **Locked** button on the
    level select screen. When you press the **Locked** button, it calls the store
    to make a transaction. You will notice a print statement in the terminal that
    displays what **Product ID** is being referred to for purchase. Full In-App Purchase
    features cannot be tested in the simulator. You will have to create a distribution
    build and upload it on an iOS device to initiate a purchase in the store.![Time
    for action – using the Corona store module to create an In-App Purchase](img/9343OT_11_07.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在 Corona 模拟器中运行项目。当你点击**播放**按钮时，你会在关卡选择屏幕上注意到一个**1**按钮和一个**锁定**按钮。当你按下**锁定**按钮时，它会调用商店进行交易。你会在终端中注意到一条打印语句，显示正在参考哪个**产品ID**进行购买。完整的内购功能无法在模拟器中测试。你将需要创建一个发行版本，并在iOS设备上上传以在商店中发起购买。![行动时间
    – 使用 Corona 商店模块创建应用内购买](img/9343OT_11_07.jpg)
- en: '*What just happened?*'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In this example, we used the `saveValue()` and `loadValue()` functions from
    BeebeGames Class to implement how our locked level will go from locked to unlocked
    mode using movie clips as buttons. The array in `local listOfProducts` displays
    **Product ID** in a string format. The Product ID in this example needs to be
    a nonconsumable In-App Purchase type and has to be an existing one in iTunes Connect.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了 BeebeGames 类中的 `saveValue()` 和 `loadValue()` 函数，来实现如何通过电影剪辑作为按钮，使我们的锁定关卡从锁定模式转变为解锁模式。`local
    listOfProducts` 中的数组以字符串格式显示**产品ID**。在此示例中，产品ID需要是一种非消耗性应用内购买类型，并且必须在 iTunes Connect
    中已存在。
- en: 'The `unpackValidProducts()` function checks how many valid and invalid items
    are in the In-App Purchase. The `loadProductsCallback()` function receives the
    product information in the store. The `transactionCallback(event)` function checks
    every state: `"purchased"`, `"restored"`, `"cancelled"`, and `"failed"`. When
    a `"purchased"` state is achieved within the In-App Purchase, the `saveValue()`
    function is called to change the value of `level2.data`. When the transaction
    is completed, `store.finishTransaction(event.transaction)` needs to be called
    to tell the store that you are done with your purchase.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpackValidProducts()`函数检查应用内购买中有多少有效和无效的商品。`loadProductsCallback()`函数接收商店中的产品信息。`transactionCallback(event)`函数检查每种状态：`"purchased"`，`"restored"`，`"cancelled"`和`"failed"`。在应用内购买中实现`"purchased"`状态时，会调用`saveValue()`函数来更改`level2.data`的值。交易完成后，需要调用`store.finishTransaction(event.transaction)`来告诉商店你的购买已经完成。'
- en: The `setupMyStore(event)` function calls `store.loadProducts(listOfProducts,
    loadProductsCallback)` and checks the available Product ID (or IDs) in the application.
    The event is handled once `store.init(transactionCallback)` is initialized and
    `setupMyStore()` is called.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupMyStore(event)`函数调用`store.loadProducts(listOfProducts, loadProductsCallback)`并检查应用程序中可用的产品ID（或IDs）。一旦`store.init(transactionCallback)`初始化并调用`setupMyStore()`，事件就会被处理。'
- en: The `onBuyLevel2Touch(event)` function allows us to check when an In-App Purchase
    has been made for the locked level. When the user is able to purchase and when
    they accept the In-App Purchase, the transaction is processed and the value of
    `level2Unlocked` will match that of `tonumber(loadedLevel2Unlocked)`. The `buyLevel2(product)`
    function validates the purchased item with `store.purchase()` once the Product
    ID returns valid.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBuyLevel2Touch(event)`函数允许我们检查是否已为锁定级别进行了应用内购买。当用户能够购买并接受应用内购买时，将处理交易，`level2Unlocked`的值将与`tonumber(loadedLevel2Unlocked)`相匹配。`buyLevel2(product)`函数一旦产品ID返回有效，就会使用`store.purchase()`验证购买的商品。'
- en: After the In-App Purchase, the screen transitions to the main menu to allow
    the **Locked** button to change to the level **2** button. Once the button has
    changed to frame 2, level 2 is accessible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用内购买完成后，屏幕会过渡到主菜单，允许**锁定**按钮变为级别**2**的按钮。一旦按钮变为帧2，级别2就可以访问了。
- en: Have a go hero – handling multiple Product IDs
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——处理多个产品ID
- en: Now that you know how to create an In-App Purchase for one product, try adding
    more than one product to the same application. The scenarios are open ended.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道如何为单一产品创建应用内购买，尝试为同一应用程序添加多个产品。场景是开放式的。
- en: 'You can add the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加以下内容：
- en: More levels for purchases
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多可供购买的级别
- en: A variety of characters the user can play as if your game has a main character
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的游戏有主角，可以设置多种角色供用户扮演。
- en: New background scenes for your application
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用程序添加新的背景场景
- en: How you handle new products for your store is up to you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何处理商店的新产品完全由你决定。
- en: Testing In-App Purchases
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用内购买
- en: You would want to ensure that the purchases work correctly. Apple provides a
    sandbox environment that allows you to test your app In-App Purchases. The sandbox
    environment uses the same model as the App Store, but does not process actual
    payments. Transactions return as if payments were processed successfully. It is
    a requirement to test In-App Purchases in a sandbox environment before submitting
    them for a review by Apple.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保购买能够正确进行。苹果提供了一个沙盒环境，允许你测试应用内购买。沙盒环境与App Store使用相同的模型，但不会处理实际支付。交易会返回，就像支付已经成功处理一样。在提交给苹果审核之前，测试应用内购买在沙盒环境中是必须的。
- en: When testing in the sandbox environment, you'll need to create a separate user
    test account that is different from your current iTunes Connect account. Using
    your current account is not allowed for testing your store in the sandbox.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在沙盒环境中测试时，你需要创建一个与当前iTunes Connect账户不同的独立用户测试账户。在沙盒环境中测试你的商店时，不允许使用你的当前账户。
- en: User test accounts
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户测试账户
- en: While you're logged in to your iTunes Connect account, you'll have to select
    the **Manage Users** link from the Home page. Select **Test User** on the **Select
    User Type** page. Add a new user and ensure that the test account uses an e-mail
    address that is not associated with any other Apple account. All test accounts
    should only be used in the test environment when testing In-App Purchases. Click
    on the **Save** button when all of the information is filled in.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录到您的iTunes Connect账户时，您需要从主页选择**管理用户**链接。在**选择用户类型**页面选择**测试用户**。添加一个新用户，并确保测试账户使用的电子邮件地址没有与其他任何Apple账户关联。所有测试账户在测试应用内购买时只应在测试环境中使用。当所有信息填写完毕后，点击**保存**按钮。
- en: Once your user test account is created, you'll have to make sure that you've
    signed out of your Apple account in the **Store** settings of your device. This
    will keep non-test accounts from being used when testing In-App Purchases. You're
    only allowed to sign in to your user test account when prompted in the In-App
    Purchase sandbox to test your application. Do not sign in to your test account
    before the application is launched. This will prevent it from invalidating your
    test account.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户测试账户后，您需要确保在设备的**商店**设置中已登出您的Apple账户。这将防止在测试应用内购买时使用非测试账户。当应用内购买沙盒提示时，您只能登录到您的用户测试账户以测试应用程序。在启动应用程序之前，不要登录到您的测试账户。这将防止它使您的测试账户无效。
- en: Time for action – testing the In-App Purchase with the Breakout In-App Purchase
    Demo
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用Breakout应用内购买演示测试应用内购买
- en: 'Before you can test an In-App Purchase on an iOS device, make sure that you
    have a test user account in iTunes Connect. Also, make sure that you''ve created
    a distribution build using an ad hoc Distribution Provisioning Profile for the
    app to test In-App Purchase''s features. If you followed all the earlier steps
    in this chapter, testing a purchase through the store will work accordingly:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以在iOS设备上测试应用内购买之前，请确保您在iTunes Connect中有一个测试用户账户。同时，请确保您使用临时分发配置文件为要测试应用内购买功能的应用创建了一个分发构建。如果您按照本章前面的所有步骤操作，通过商店进行购买测试将相应地顺利进行：
- en: In the Corona simulator, create a distribution build of the Breakout In-App
    Purchase Demo. Once the build has been compiled, upload the build on your iOS
    device.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Corona模拟器中，创建Breakout应用内购买演示的分发构建。一旦构建完成编译，将构建上传到您的iOS设备。
- en: Keep your device connected to your machine and launch Xcode. From the toolbar,
    go to **Windows** | **Organizer**. Once you're in **Organizer**, select the device
    that is connected in the **Devices** section and then select **Console**. This
    will allow you to check the console output of your device to catch debug messages
    from your code (that is, print statements) and any application crashes.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持设备与您的机器连接，并启动Xcode。从工具栏中，转到**窗口** | **组织者**。一旦进入**组织者**，在**设备**部分选择已连接的设备，然后选择**控制台**。这将允许您检查设备上的控制台输出，以捕获代码中的调试信息（即打印语句）以及任何应用程序崩溃。
- en: Before launching the application, you'll need to select the **Settings** icon
    on your device. Scroll up until you see the **Store** icon and select it.![Time
    for action – testing the In-App Purchase with the Breakout In-App Purchase Demo](img/9343OT_11_08.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，您需要在设备上选择**设置**图标。向上滚动直到看到**商店**图标并选择它。![行动时间 – 使用Breakout应用内购买演示测试应用内购买](img/9343OT_11_08.jpg)
- en: Sign out of your iTunes Store account if you're logged in, so that you can test
    In-App Purchases in the sandbox environment.![Time for action – testing the In-App
    Purchase with the Breakout In-App Purchase Demo](img/9343OT_11_09.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已登录iTunes商店账户，请登出，这样您就可以在沙盒环境中测试应用内购买。![行动时间 – 使用Breakout应用内购买演示测试应用内购买](img/9343OT_11_09.jpg)
- en: Launch the Breakout In-App Purchase Demo from your device. Select the **Play**
    button and then select the **Locked** button. The screen will transition back
    to the main menu, and a window will pop up to confirm your In-App Purchase. Press
    **OK** to continue with the purchase.![Time for action – testing the In-App Purchase
    with the Breakout In-App Purchase Demo](img/9343OT_11_10.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的设备上启动Breakout应用内购买演示。选择**播放**按钮，然后选择**锁定**按钮。屏幕将转回主菜单，并弹出一个窗口以确认您的应用内购买。按下**确定**继续购买。![行动时间
    – 使用Breakout应用内购买演示测试应用内购买](img/9343OT_11_10.jpg)
- en: Next, you will be greeted with another window to sign in with your Apple ID.
    This is where you will log in with the test user account you created in iTunes
    Connect. Do not sign in with your actual Apple account that was used to log in
    to iTunes Connect.![Time for action – testing the In-App Purchase with the Breakout
    In-App Purchase Demo](img/9343OT_11_11.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将看到一个窗口，提示你使用Apple ID登录。在这里，你需要使用在iTunes Connect中创建的测试用户账户登录。不要使用用于登录iTunes
    Connect的实际Apple账户。![行动时间——使用Breakout In-App Purchase Demo测试应用内购买](img/9343OT_11_11.jpg)
- en: Once you've logged in, select the **Play** button again. You will notice that
    the **2** button has been unlocked. When you select it, you will have access to
    that scene.![Time for action – testing the In-App Purchase with the Breakout In-App
    Purchase Demo](img/9343OT_11_12.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，再次选择**播放**按钮。你会注意到**2**按钮已经被解锁。选择它后，你将可以访问那个场景。![行动时间——使用Breakout In-App
    Purchase Demo测试应用内购买](img/9343OT_11_12.jpg)
- en: Exit the app and refer to the console. You will notice the output from the device
    and some familiar print statements from your code. The console log displays the
    Product ID used for the In-App Purchase and informs you whether it is valid and
    whether the transaction is successful.![Time for action – testing the In-App Purchase
    with the Breakout In-App Purchase Demo](img/9343OT_11_13.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出应用程序并参考控制台。你会注意到来自设备的输出和你的代码中一些熟悉的打印语句。控制台日志显示了用于应用内购买的产品ID，并通知你它是否有效以及交易是否成功。![行动时间——使用Breakout
    In-App Purchase Demo测试应用内购买](img/9343OT_11_13.jpg)
- en: If you want to ensure that the In-App Purchase actually worked, delete the application
    from your device and log out of your user test account. Upload the same build
    on your device—there's no need to create a new one. Launch the application and
    run the In-App Purchase again. Log in using the same user test account. You should
    receive a pop-up window that mentions that you've already purchased the product,
    and asks you whether you want to download it again for free. Receiving a notification
    means your In-App Purchase was successful.![Time for action – testing the In-App
    Purchase with the Breakout In-App Purchase Demo](img/9343OT_11_14.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要确保应用内购买确实有效，请从你的设备上删除应用程序，并退出你的测试用户账户。上传同样的版本到你的设备上——无需创建新的版本。启动应用程序并重新运行应用内购买。使用同样的测试用户账户登录。你应该会看到一个弹出窗口，提示你已经购买了该产品，并询问你是否希望再次免费下载。收到通知意味着你的应用内购买成功了。![行动时间——使用Breakout
    In-App Purchase Demo测试应用内购买](img/9343OT_11_14.jpg)
- en: '*What just happened?*'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: It is important to follow the In-App Purchase test steps properly. To make sure
    you're getting accurate results in the sandbox environment, signing out of your
    Apple account from the **Store** settings is the key to this entire process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正确遵循应用内购买测试步骤非常重要。为了确保你在沙盒环境中获得准确的结果，从**商店**设置中退出你的Apple账户是整个流程的关键。
- en: Once you launch the application and call the store function by pressing the
    Locked button, you will notice the display name and price of the In-App Purchase.
    It should match with what you created in iTunes Connect, if you have implemented
    it correctly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并通过按下锁定按钮调用商店功能后，你会注意到应用内购买的商品的显示名称和价格。如果你正确实现，它应该与你在iTunes Connect中创建的内容相匹配。
- en: When you log in by using the test user account you created in iTunes Connect,
    the transaction should go through without any errors, assuming that there are
    no server issues on Apple's side or connection problems on the device. Level 2
    on the level select screen will be unlocked and accessible. Congratulations! You
    have created an In-App Purchase.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在iTunes Connect中创建的测试用户账户登录后，假设苹果服务器端没有问题或设备连接没有问题，交易应该能够顺利进行，不会出现任何错误。在关卡选择屏幕上的第2级将会被解锁并可以访问。恭喜你！你已经创建了一个应用内购买（In-App
    Purchase）。
- en: Have a go hero – using other In-App Purchase types
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手试试——使用其他类型的应用内购买英雄*（注：此处"Have a go hero"可能指的是一种鼓励尝试的挑战，直译可能不太通顺，故保留原文，仅将"using
    other In-App Purchase types"翻译为“使用其他类型的应用内购买”）*。
- en: In the Breakout In-App Purchase Demo, we focused more on nonconsumable In-App
    Purchases. Try integrating consumable, auto-renewing, or non-renewing subscriptions
    with your own apps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Breakout In-App Purchase Demo中，我们更关注非消耗性应用内购买。尝试将消耗性、自动续订或非续订订阅与你自己应用整合。
- en: Apps that feature consumable products are games that require currency to buy
    or build things in a free-to-play environment. Subscription products can be focused
    towards games that are never-ending and are constantly updated with new levels
    or games that may require an online server to interact in a multiplayer environment.
    See what you can come up with!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那些包含消耗性产品的应用是那些在免费游戏环境中需要货币购买或建造物品的游戏。订阅产品可以针对那些永不结束且不断更新新关卡的游戏，或者可能需要在线服务器在多人环境中交互的游戏。看看您能想出什么！
- en: Pop quiz – all about In-App Purchases
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于应用内购买的小测验。
- en: Q1\. What are nonconsumable purchases?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 非消耗性购买是什么？
- en: Products that only need to be purchased once by the user.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户只需购买一次的产品。
- en: Products that need to be purchased each time the user needs the item.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户每次需要该项物品时都需要购买的产品。
- en: Products that allow the user to purchase content for a set duration of time.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户购买一定时间期限内容的产品。
- en: A subscription that requires a user to renew each time it expires.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户每次到期都需要续订的订阅。
- en: Q2\. What is true about testing In-App Purchases?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 关于测试应用内购买，以下哪个是正确的？
- en: You need to be logged in to your account at all times.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要始终登录到您的账户。
- en: Your Apple account is used to test In-App Purchases.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的Apple账户用于测试应用内购买。
- en: Login to your user test account when prompted in In-App Purchase sandbox.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在应用内购买沙盒中提示时，登录您的用户测试账户。
- en: None of the above.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: Q3\. What type of Provisioning Profile must be used to test In-App Purchases?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 测试应用内购买必须使用哪种配置文件？
- en: Development Provisioning Profile.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发配置文件。
- en: Ad Hoc Distribution Provisioning Profile.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ad Hoc分发配置文件。
- en: App Store Distribution Provisioning Profile.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: App Store分发配置文件。
- en: None of the above.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结。
- en: We can finally see the light at the end of the tunnel. By now, you should have
    an idea on how to implement In-App Purchases in your games. It is a very lengthy
    process to organize, set up the code, and test accurate purchases in the sandbox
    environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于看到了隧道尽头的光明。至此，您应该对如何在您的游戏中实现应用内购买有了初步了解。这是一个非常耗时的过程，需要组织、设置代码，并在沙盒环境中测试准确的购买。
- en: 'The following were taught in this chapter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中讲解了以下内容：
- en: How to set up product IDs for In-App Purchases in iTunes Connect
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在iTunes Connect中为应用内购买设置产品ID。
- en: Implementing purchase items using Corona's store module
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Corona的商店模块实现购买项目。
- en: Adding test user accounts in iTunes Connect
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iTunes Connect中添加测试用户账户。
- en: Testing In-App Purchases on a device
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备上测试应用内购买。
- en: Grasping the concept of In-App Purchasing can take some time. It is best to
    study the sample code and review the functions pertaining to Corona's store module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握应用内购买的概念可能需要一些时间。最好研究示例代码，并查看与Corona的商店模块相关的功能。
- en: 'Please check out Apple''s *In-App Purchase Programming Guide* at: [https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf)
    and the In-App Purchases in the API Reference section of Corona Labs site: for
    more references pertaining to this topic.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看苹果的*应用内购买编程指南*：[https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf)，以及Corona
    Labs网站API参考部分中的应用内购买，了解更多关于此话题的参考资料。
- en: After 11 chapters, we have reached the end of this book. You now have obtained
    enough knowledge to create your own applications to sell in the Apple App Store
    or Google Play Store. Hopefully all the information you have acquired has been
    helpful. I look forward to hearing about the games you have developed using Corona
    SDK!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 经过11章的学习，我们已经到了这本书的结尾。现在，您已经获得了足够的知识来创建自己的应用程序，并在Apple App Store或Google Play
    Store中销售。希望您获得的所有信息都能有所帮助。我期待听到您使用Corona SDK开发的游戏！
