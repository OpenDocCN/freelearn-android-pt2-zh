- en: Chapter 6. Practicing Test-driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 实践测试驱动开发
- en: This chapter introduces the **Test-driven Development** (**TDD**) discipline.
    We will start with TDD practices in the general sense, and later on move to the
    concepts and techniques more closely related to the Android platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了**测试驱动开发**（**TDD**）的纪律。我们将从广义上的TDD实践开始，随后转移到与Android平台更相关的概念和技术。
- en: This is a code-intensive chapter, so be prepared to type as you read, which
    would help you get the most out of the examples provided.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码密集的章节，所以准备好边阅读边输入，这将帮助你从提供的示例中获得最大收益。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Introducing and explaining Test-driven Development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入并解释测试驱动开发（Test-driven Development）。
- en: Analyzing its advantages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析其优点。
- en: Introducing a real-life example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个现实生活中的例子。
- en: Understanding project requirements by writing tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写测试来理解项目需求。
- en: Evolving through the project by applying TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用TDD在项目中不断发展。
- en: Getting an application that fully complies with the requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得一个完全符合要求的程序。
- en: Getting started with TDD
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用TDD。
- en: Briefly, Test-driven Development is the strategy of writing tests in parallel
    with the development process. These test cases are written in advance of the code
    that is supposed to satisfy them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试驱动开发是边开发边编写测试的策略。这些测试用例是在预期将满足它们的代码之前编写的。
- en: A single test is written, and then the code needed to satisfy the compilation
    of this test is written, then the behavior that the test decrees should exist
    is written. We continue writing tests and implementation until the full set of
    desired behaviors is checked by the tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个测试，然后编写满足这个测试编译所需的代码，接着实现测试规定的应有的行为。我们持续编写测试和实现，直到测试检查完所有期望行为的完整集合。
- en: This contrasts with other approaches to the development process, where the tests
    are written at the end when all the coding has been done.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他开发过程方法形成对比，那些方法是在所有编码完成后的末期编写测试。
- en: 'Writing the tests in advance of the code that satisfies them has the following
    advantages:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 提前编写满足它们的代码的测试具有以下优点：
- en: Tests get written one way or another, while if the tests are left till the end
    it is highly probable that they will never be written
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试以这样或那样的方式编写，而如果将测试留到开发末期，很可能会永远写不出来。
- en: Developers take more responsibility for the quality of their work, when having
    to consider the tests as they code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发者在编写代码时需要考虑测试时，他们会对自己工作的质量承担更多责任。
- en: Design decisions are taken in smaller steps and afterwards the code satisfying
    the tests is improved by refactoring. Remember, this is while having the tests
    running, so that there are no regressions in expected behavior.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设计决策分小步进行，之后通过重构改进满足测试的代码。记住，这需要在测试运行的情况下进行，以确保预期行为没有回归。
- en: 'Test-driven Development is often explained in a diagram like the following,
    to help us understand the process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发通常通过以下类似的图表来解释，以帮助我们理解这个过程：
- en: '![Getting started with TDD](img/00021.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TDD](img/00021.jpeg)'
- en: The following sections expand on the individual actions associated with the
    TDD, red, green, refactor cycle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将详细展开与TDD相关的红、绿、重构循环的个别行动。
- en: Writing a test case
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个测试用例。
- en: We start our development process with writing a test case. This apparently is
    a simple process that will put some machinery to work inside our heads. After
    all, it is not possible to write some code, test it or not, if we don't have a
    clear understanding of the problem domain, and its details. Usually, this step
    will get you face to face with the aspects of the problem you don't understand,
    and you need to grasp these if you want to model and write the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从编写一个测试用例开始开发过程。这显然是一个简单的过程，会在我们脑海中启动一些机制。毕竟，如果我们对问题领域及其细节没有清晰的理解，就不可能编写一些代码，测试它或不测试。通常，这一步会让你直接面对你不理解的问题方面，如果你想建模和编写代码，就需要掌握这些方面。
- en: Running all tests
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行所有测试。
- en: Once the test is written the next step is to run it, along with all other tests
    we have written so far. Here, the importance of an IDE with built-in support of
    the testing environment is perhaps more evident than in other situations, cutting
    the development time by a good fraction. It is expected that, firstly, our newly
    written test fails as we still haven't written any code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试后，下一步是运行它，以及到目前为止我们编写的所有其他测试。在这里，拥有内置测试环境支持的IDE的重要性可能比其他情况下更加明显，可以大幅缩短开发时间。我们预期，首先，我们新编写的测试会失败，因为我们还没有编写任何代码。
- en: To be able to complete our test, we write additional code and take design decisions.
    The additional code written is the minimum possible to get our test to compile.
    Consider here, that not compiling is failing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的测试，我们编写额外的代码并做出设计决策。编写的额外代码是最少的，以使我们的测试能够编译。在这里请注意，不能编译就是失败。
- en: When we get the test to compile and run, and if the test fails, then we try
    to write the minimum amount of code necessary to make the test succeed. This may
    sound awkward at this point, but the following code example in this chapter will
    help you understand the process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们让测试编译并运行，如果测试失败了，那么我们会尝试编写最少的代码以使测试成功。这在目前听起来可能有些别扭，但本章接下来的代码示例将帮助你理解这个过程。
- en: Optionally, instead of running all tests again you can just run the newly added
    tests first, to save some time as sometimes running the tests on the emulator
    could be rather slow. Then run the whole test suite to verify that everything
    is still working properly. We don't want to add a new feature by breaking any
    features already existing in our code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以先只运行新增加的测试，以节省一些时间，因为有时在模拟器上运行测试可能会相当慢。然后再运行整个测试套件，以验证一切是否仍然正常工作。我们不想在添加新功能时破坏代码中已有的任何功能。
- en: Refactoring the code
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构代码
- en: When the test succeeds, we refactor the code added to keep it tidy, clean, and
    the minimal needed for a maintainable and extensible application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试成功时，我们会重构添加的代码，以保持其整洁、干净，并且是可维护和可扩展应用程序所需的最小代码量。
- en: We run all the tests again, to verify that our refactoring has not broken anything,
    and if the tests are again satisfied and no more refactoring is needed, we finish
    our task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行所有测试，以验证重构是否破坏了任何功能，如果测试再次通过且无需进一步重构，那么我们就完成了任务。
- en: Running the tests after refactoring is an incredible safety net that has been
    put in place by this methodology. If we made a mistake refactoring an algorithm,
    extracting variables, introducing parameters, changing signatures, or whatever
    the refactoring mechanism, this testing infrastructure will detect the problem.
    Furthermore, if some refactoring or optimization could not be valid for every
    possible case, we can verify it for every case used by the application expressing
    this as a test case.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后运行测试是这种方法提供的一个非常安全的保障。如果我们重构算法时犯了错误，提取变量，引入参数，改变签名，或者无论重构机制是什么，这个测试基础设施都会发现问题。此外，如果某些重构或优化对每个可能的情况都不适用，我们可以通过作为测试用例表达的应用程序中的每个案例来验证它。
- en: Advantages of TDD
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD的优点
- en: Personally, the main advantage I've seen so far is that it quickly focuses you
    on your programming goal, and it is harder to get distracted or eager, and implement
    options in your software that will never be used (sometimes known as gold plating).
    This implementation of unneeded features is a waste of your precious development
    time and as you may already know, judiciously administering these resources may
    be the difference between successfully reaching the end of the project or not.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，到目前为止看到的主要优点是它能快速让你专注于编程目标，而且不容易分心或急躁，在软件中实施那些永远不会被使用的选项（有时被称为镀金）。这种实施不必要功能的做法是浪费你宝贵的发展时间。正如你可能已经知道的，谨慎地管理这些资源可能是成功完成项目与否则之间的区别。
- en: The other advantage is that you always have a safety net for your changes. Every
    time you change a piece of code, you can be absolutely sure that other parts of
    the system are not affected, as long as there are tests verifying that the conditions
    haven't changed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，你始终有一个安全网来保护你的更改。每次你更改一段代码时，只要有关联的测试验证条件没有改变，你就可以完全确定系统的其他部分没有受到影响。
- en: 'Don''t forget, TDD cannot be indiscriminately applied to any project. I think
    that, as well as any other technique; you should use your judgment and expertise
    to recognize where it can be applied and where not. Always remember: *there are
    no silver bullets*.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，TDD不能随意应用于任何项目。我认为，像任何其他技术一样，你应该运用你的判断力和专业知识来识别它适用的地方和不适用的地方。始终记住：*没有银弹*。
- en: Understanding the requirements
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解需求
- en: To be able to write a test about any subject, we should first understand the
    subject under test, this means breaking apart the requirement you are attempting
    to implement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够编写关于任何主题的测试，我们首先应该了解被测试的主题，这意味着要分解你试图实现的要求。
- en: We mentioned that one of the advantages is that you focus upon a goal quickly,
    instead of revolving around the requirements as a big, unconquerable whole.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，其中一个优点是你可以快速关注一个目标，而不是围绕需求这个庞大而难以克服的整体旋转。
- en: Translating requirements into tests and cross referencing them is perhaps the
    best way to understand the requirements, and to be sure that there is always an
    implementation and verification for all of them. Also, when the requirements change
    (something that is very frequent in software development projects), we can change
    the tests verifying these requirements, and then change the implementation to
    be sure that everything was correctly understood and mapped to the code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将需求翻译成测试，并相互参照，可能是理解需求最佳方式，以确保所有需求都有实现和验证。此外，当需求发生变化（这在软件开发项目中非常常见）时，我们可以更改验证这些需求的测试，然后更改实现以确保所有内容都被正确理解和映射到代码中。
- en: Creating a sample project – the temperature converter
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建示例项目 - 温度转换器
- en: You might have guessed it from some of the code snippets so far, that our TDD
    examples will revolve around an extremely simple Android sample project. It doesn't
    try to show all the fancy Android features, but focuses on testing and gradually
    building the application from the test, applying the concepts learned before.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从迄今为止的一些代码片段中猜到了，我们的TDD示例将围绕一个极其简单的Android示例项目展开。它不试图展示所有花哨的Android功能，而是专注于测试，并逐步从测试中构建应用程序，应用之前学到的概念。
- en: Let's pretend that we have received a list of requirements to develop an Android
    temperature converter application. Though oversimplified, we will be following
    the steps you normally would, to develop such an application. However, in this
    case we will introduce the Test-driven Development techniques in the process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们收到了一个开发Android温度转换应用程序的需求列表。虽然过于简化，但我们将按照正常步骤来开发此类应用程序。但是，在这种情况下，我们将在过程中引入测试驱动开发技术。
- en: List of requirements
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求列表
- en: Usually (let's be honest), the list of requirements are very vague, and there
    are a high number of details not fully covered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常（让我们诚实一点），需求列表非常模糊，有很多细节没有完全覆盖。
- en: 'As an example, let''s pretend that we receive this list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们收到了这个列表：
- en: The application converts temperatures from Celsius to Fahrenheit and vice-versa
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序将温度从摄氏度转换为华氏度，反之亦然。
- en: The user interface presents two fields to enter the temperatures; one for Celsius
    the other for Fahrenheit
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面提供了两个输入温度的字段；一个用于摄氏度，另一个用于华氏度。
- en: When a temperature is entered in one field, the other one is automatically updated
    with the conversion
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个字段中输入温度时，另一个字段会自动更新为转换后的值。
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有错误，应向用户显示，最好使用相同的字段。
- en: Some space in the user interface should be reserved for the on-screen keyboard,
    to ease the application operation when several conversions are entered
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面应保留一些空间用于屏幕键盘，以便在进行多次转换输入时简化应用程序的操作。
- en: Entry fields should start empty
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段应从空开始
- en: Values entered are decimal values with two digits after the point
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的值是带有两位小数的十进制值
- en: Digits are right aligned
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字右对齐
- en: Last entered values should be retained even after the application is paused
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序暂停后，最后输入的值应保持不变。
- en: User interface concept design
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面概念设计
- en: 'Let''s assume that we receive this conceptual user interface design from the
    user interface design team (I apologize right now to all designers for my lack
    of imagination and skill):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从用户界面设计团队收到了这个概念性的用户界面设计（我现在就为我的缺乏想象力和技巧向所有设计师道歉）：
- en: '![User interface concept design](img/00022.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面概念设计](img/00022.jpeg)'
- en: Creating the project
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Our first step is to create the project. Now, since we have done this for five
    chapters already I don''t think I need to give you a step-by-step guide. Just
    run through the Android Studio new project wizard, and select an Android mobile
    project with your package name, plus other boilerplate, and no Activity template.
    Android Studio will automatically create you an example `AndroidApplicationTestCase`.
    Bear in mind, if you get stuck, you can refer to the code accompaniment for this
    book. When created, it should look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建项目。现在，由于我们已经为前五个章节做过这个，我认为我不需要为你提供一步一步的指导。只需通过Android Studio新项目向导，选择带有你的包名的Android移动项目，加上其他样板文件，不要Activity模板。Android
    Studio会自动为你创建一个示例`AndroidApplicationTestCase`。记住，如果你遇到困难，可以参考本书的代码附录。创建后，它应该看起来像这样：
- en: '![Creating the project](img/00023.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/00023.jpeg)'
- en: Now let's quickly create a new Activity called `TemperatureConverterActivity`
    (we didn't use the template generator, because it adds loads of code that is not
    needed right now), don't forget to add the Activity to your `AndroidManifest`
    file. Fanatic TDD'ers might be shaking their fist right now, as really you should
    make this Activity only when needed in your tests, but I'm trying to guide you
    with some familiarity at the same time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速创建一个名为`TemperatureConverterActivity`的新Activity（我们没有使用模板生成器，因为它添加了很多现在不需要的代码），不要忘记将Activity添加到你的`AndroidManifest`文件中。狂热的TDD实践者现在可能正激动地挥舞着拳头，因为实际上你应该在测试中需要时才创建这个Activity，但我同时也在尝试用一些熟悉的内容引导你。
- en: Creating a Java module
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Java模块
- en: On top of this template project, we want to add another module of code. This
    will be a Java-only module and will act as a dependency or library, if you will,
    for our main Android module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板项目之上，我们想要添加另一个代码模块。这将是一个仅Java的模块，并将作为我们主Android模块的依赖或库。
- en: The idea here is two-fold. First, it allows you to separate code that is Java
    only, and does not have a dependency on Android, in a big project this can be
    your core domain; the business logic that runs your app, and it is important that
    you modularize this, so you can work on it without having to think about Android
    as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法有两方面。首先，它允许你将仅Java的代码（不依赖于Android）分离出来，在一个大项目中，这可以是你的核心领域；运行你的应用程序的业务逻辑，重要的是你要模块化这部分，这样你就可以在不考虑Android的情况下工作。
- en: Secondly, having a Java-only module as we've said before, allows you to call
    on the vast history of Java as an established programming language when it comes
    to testing. Testing of the Java module is fast, simple, and easy. You can write
    JUnit tests for the JVM and have them running in milliseconds (which we will do!).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，正如我们之前所说，拥有一个仅Java的模块，在测试时可以让你调用Java作为一门成熟编程语言的丰富历史。Java模块的测试快速、简单、便捷。你可以为JVM编写JUnit测试，并在几毫秒内运行它们（我们将会这样做！）。
- en: 'From Android Studio, navigate to **File** | **New Module,** this gives you
    the **Create new module** dialog. Under **More Modules**, select **Java Library,**
    and hit **Next**. Name your library `core`, and ensure the package name is the
    same as your Android application, and press on **Finish**. The last screen should
    have looked something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，导航到**文件** | **新建模块**，这将弹出**创建新模块**对话框。在**更多模块**下，选择**Java库**，然后点击**下一步**。给你的库命名为`core`，确保包名与你的Android应用程序相同，然后点击**完成**。最后一个界面应该看起来像这样：
- en: '![Creating a Java module](img/00024.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个Java模块](img/00024.jpeg)'
- en: 'Once created, you need to add the one-way dependency from your Android `:app`
    module to the `:core` module. Within, `/app/build.gradle,` add the dependency
    on core:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，你需要从你的Android `:app`模块添加单向依赖到`:core`模块。在`/app/build.gradle`中，添加对核心模块的依赖：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This allows us to reference files from our core module inside of our Android
    application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们从Android应用程序内部引用核心模块中的文件。
- en: Creating the TemperatureConverterActivityTests class
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`TemperatureConverterActivityTests`类
- en: Proceed with creating the first test by selecting the main test package name,
    `com.blundell.tut.` This is under `src/androidTest/Java` in the AndroidStudio
    project view, or under `app/java/(androidTest)` in the AndroidStudio Android view.
    Then right-click here, and select **New** | **Java Class**, call it, `TemperatureConverterActivityTests`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择主测试包名`com.blundell.tut.`继续创建第一个测试。这在AndroidStudio项目视图中的`src/androidTest/Java`下，或者在AndroidStudio
    Android视图中的`app/java/(androidTest)`下。然后在这里右键点击，选择**新建** | **Java类**，将其命名为`TemperatureConverterActivityTests`。
- en: Once the class is created, we need to go about turning it into a test class.
    We should select our superclass depending on what and how we are going to test.
    In [Chapter 2](part0020_split_000.html#page "Chapter 2. Understanding Testing
    with the Android SDK"), *Understanding Testing with the Android SDK*, we reviewed
    the available alternatives. Use it as a reference when you try to decide what
    superclass to use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类之后，我们需要将其转变为一个测试类。我们应该根据要测试的内容和方式来选择我们的超类。在[第2章](part0020_split_000.html#page
    "Chapter 2. Understanding Testing with the Android SDK")《*理解使用Android SDK的测试*》中，我们回顾了可用的选择。在尝试决定使用哪个超类时，可以将其作为参考。
- en: In this particular case, we are testing a single Activity and using the system
    infrastructure, therefore, we should use `ActivityInstrumentationTestCase2`. Also
    note that as `ActivityInstrumentationTestCase2` is a generic class, we need the
    template parameter as well. This is the Activity under test, which in our case,
    is `TemperatureConverterActivity`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，我们正在测试单个Activity并使用系统基础设施，因此，我们应该使用`ActivityInstrumentationTestCase2`。还请注意，由于`ActivityInstrumentationTestCase2`是一个泛型类，我们还需要模板参数。这是我们测试的Activity，在我们的例子中，是`TemperatureConverterActivity`。
- en: We now notice that our class has some errors we need to fix before running.
    Otherwise the errors will prevent the test from running.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在注意到，在运行之前需要修复类中的一些错误。否则，这些错误将阻止测试运行。
- en: 'The problem we need to fix has been described before in [Chapter 2](part0020_split_000.html#page
    "Chapter 2. Understanding Testing with the Android SDK"), *Understanding Testing
    with the Android SDK*, under the *The no-argument constructor* section. As this
    pattern dictates, we need to implement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修复的问题在[第2章](part0020_split_000.html#page "Chapter 2. Understanding Testing
    with the Android SDK")《*理解使用Android SDK的测试*》中的*无参数构造函数*部分已经描述过。根据此模式，我们需要实现：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far we have performed the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们执行了以下步骤：
- en: We added the no argument constructor `TemperatureConverterActivityTests()`.
    From this constructor, we invoke the constructor that takes a name as a parameter.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个无参数构造函数`TemperatureConverterActivityTests()`。从这个构造函数中，我们调用了需要名称作为参数的构造函数。
- en: Finally, in this given name constructor, we invoke the super constructor and
    set the name.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在这个给定名称的构造函数中，我们调用了超构造函数并设置名称。
- en: 'To verify that everything has been set up and is in place, you may run the
    tests by right clicking on the class, and selecting **Run** | **The Name of the
    Test Class**. There are no tests to run yet, but at least we can verify that the
    infrastructure supporting our tests is already in place. It should fail with a
    **No tests** found warning. Here is how to run the test class, in case you missed
    it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证是否一切已经设置好并就位，你可以通过右键点击类，选择**运行** | **测试类的名称**来运行测试。目前还没有测试可运行，但至少我们可以验证支持我们测试的基础设施已经就位。它应该会以**未找到测试**警告失败。以下是运行测试类的步骤，以防你错过了：
- en: '![Creating the TemperatureConverterActivityTests class](img/00025.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![创建TemperatureConverterActivityTests类](img/00025.jpeg)'
- en: Creating the fixture
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建夹具
- en: 'We can start creating our test fixture by populating the `setup()` method with
    the elements we need in our tests. Almost unavoidable, in this case, is the use
    of the Activity under test, so let''s prepare for the situation and add it to
    the fixture:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`setup()`方法中添加测试所需的元素来开始创建测试夹具。在这种情况下，几乎不可避免的是要使用待测试的Activity，因此让我们为此情况做好准备，并将其添加到夹具中：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After introducing the previous code, create the `activity` field using AndroidStudio's
    refactoring tools to save you time. (*F2* for next error, *Alt* + *Enter* for
    quick fix, *Enter* again to create field, *Enter* again to confirm the fields
    type, done!)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 引入上述代码后，使用AndroidStudio的重构工具创建`activity`字段以节省时间。（*F2*查看下一个错误，*Alt* + *Enter*快速修复，*Enter*创建字段，*Enter*再次确认字段类型，完成！）
- en: The `ActivityInstrumentationTestCase2.getActivity()` method has a side effect.
    If the Activity under test is not running, it will be started. This may change
    the intention of a test if we use `getActivity()` as a simple accessor several
    times in a test, and for some reason the Activity finishes or crashes before test
    completion. We will be inadvertently restarting the Activity, that is why in our
    tests we discourage the use of `getActivity()` in favor of having it in the fixture,
    so that we are implicitly restarting the activity for every test.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityInstrumentationTestCase2.getActivity()`方法有一个副作用。如果测试的活动没有运行，它将被启动。如果我们在测试中多次将`getActivity()`作为简单的访问器，并且由于某种原因活动在测试完成前结束或崩溃，这可能会改变测试的意图。我们将会无意中重新启动活动，这就是为什么在测试中我们不鼓励使用`getActivity()`，而倾向于在夹具中拥有它，这样我们隐式地为每个测试重新启动活动。'
- en: Creating the user interface
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Back to our Test-driven Development track, we see from our concise list of requirements
    that there are two entries for Celsius and Fahrenheit temperatures, respectively.
    So let's add them to our test fixture.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试驱动开发轨道，从我们简洁的需求列表中可以看出，分别有两个条目用于摄氏度和华氏度温度。因此，让我们将它们添加到我们的测试夹具中。
- en: They don't exist yet, and we haven't even started designing the user interface
    layout, but we know that there should be two entries like these for sure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它们尚未存在，我们甚至还没有开始设计用户界面布局，但我们知道肯定需要有两个这样的条目。
- en: 'This is the code you should add to the `setUp()` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '这是你应该添加到`setUp()`方法中的代码： '
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are some important things to notice:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的事情需要注意：
- en: We choose the names `converter_celsius_input` because, converter_ is the location
    of this field (in the `TemperatorConverter` Activity) `celsius_` is what the field
    represents, and finally input is how the fields behave
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择名称`converter_celsius_input`，因为`converter_`是此字段（在`TemperatorConverter`活动中）的位置，`celsius_`是字段代表的内容，最后input是字段的行为方式。
- en: We define the fields for our fixture using `EditText`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`EditText`为我们的夹具定义字段
- en: We use the previously created Activity to find the Views by ID
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用之前创建的活动通过ID查找视图
- en: We use the `R` class for the main project even though these IDs do not exist
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使这些ID不存在，我们仍然在主项目中使用`R`类
- en: Testing the existence of the user interface components
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用户界面组件的存在
- en: 'Once we have added them to the `setUp()` method, as indicated in the previous
    section, we can write our first test and check the views existence:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`setUp()`方法中添加了它们，如前一部分所示，我们可以编写我们的第一个测试并检查视图的存在：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are not able to run the tests yet because we must fix some compilation problems
    first. We should fix the missing IDs in the `R` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不能运行测试，因为我们必须先解决一些编译问题。我们应该修复`R`类中缺失的ID。
- en: Having created our test fixture that references elements and IDs in the user
    interface that we don't have yet, it's mandated by the Test-driven Development
    paradigm that we add the needed code to satisfy our tests. The first thing we
    should do is get the test to compile, so if we have some tests testing unimplemented
    features, they will fail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了引用我们尚未拥有的用户界面元素和ID的测试夹具后，测试驱动开发范式要求我们添加所需的代码以满足我们的测试。我们应该做的第一件事是让测试编译，这样如果我们有测试未实现功能的测试，它们将失败。
- en: Getting the IDs defined
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取定义的ID
- en: Our first stop would be to have the IDs for the user interface elements defined
    in the `R` class, so the errors generated by referencing undefined constants `R.id.converter_celsius_input`
    and `R.id.converter_fahrenheit_input` go away.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要定义用户界面元素在`R`类中的ID，这样引用未定义常量`R.id.converter_celsius_input`和`R.id.converter_fahrenheit_input`产生的错误就会消失。
- en: 'You, as an experienced Android developer, will know how to do it. I''ll give
    you a refresher anyway. Create an `activity_temperature_converter.xml` layout
    in the layout editor, and add the required user interface components to get something
    that resembles the design previously introduced in the *User Interface concept
    design* section, as shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验丰富的Android开发者，你将知道如何操作。不管怎样，我会为你提供一个复习。在布局编辑器中创建一个`activity_temperature_converter.xml`布局，并添加所需的用户界面组件，以得到类似于之前在*用户界面概念设计*部分介绍的设计，如下代码所示：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Doing so, we get our tests to compile (don''t forget to add the strings and
    dimensions), run the tests, do they pass? They shouldn''t! You need to hook up
    your new activity layout (I bet you beat me to it):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们让测试编译（别忘了添加字符串和尺寸），运行测试，它们通过了吗？不，它们不应该！你需要挂接你的新活动布局（我敢打赌你已经领先一步了）：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the tests once more, and you should get the following result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，你应该得到以下结果：
- en: The `testHasInputFields` test succeeded
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testHasInputFields`测试成功'
- en: Everything is green now
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在一切变绿了
- en: 'The output of the test is seen as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出的结果如下所示：
- en: '![Getting the IDs defined](img/00026.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![获取定义的ID](img/00026.jpeg)'
- en: This clearly means that we are on track with applying TDD.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地意味着我们正在按照TDD的路线进行。
- en: You may also have noticed that we added some decorative and non-functional items
    to our user interface that we are not testing (say padding), mainly to keep our
    example as simple as possible. In a real-case scenario, you may want to add tests
    for these elements too.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，我们在用户界面中添加了一些装饰性非功能性项目，我们没有测试（比如填充），主要是为了让我们的示例尽可能简单。在实际场景中，你可能还想为这些元素添加测试。
- en: Translating requirements to tests
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将需求翻译为测试
- en: Tests have a double feature. They verify the correctness of our code but, sometimes,
    and more prominently in TDD, they help us understand the design and digest what
    we are implementing. To be able to create the tests, we need to understand the
    problem we are dealing with, and if we don't, we should at least have a rough
    outline of the problem to allow us to start to handle it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试具有双重特性。它们验证我们代码的正确性，但在有时，特别是在TDD中，它们可以帮助我们理解设计并消化我们正在实现的内容。为了能够创建测试，我们需要了解我们正在处理的问题，如果我们不了解，我们至少应该有一个大致的问题轮廓，以便我们可以开始处理它。
- en: Many times, the requirements behind the user interface are not clearly expressed,
    but you should be able to understand them from the wireframed UI design. If we
    pretend that this is the case, then we can grasp the design by writing our tests
    first.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，用户界面背后的需求并没有明确表达，但你应该能够从线框UI设计中理解它们。如果我们假设这是这种情况，那么我们可以通过首先编写我们的测试来抓住设计。
- en: Empty fields
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空字段
- en: 'From one of our requirements, we get: Entry fields should start empty.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的一项需求中，我们得到：输入字段应该从空开始。
- en: 'To express this in a test, we can write the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试中表达这一点，我们可以编写以下内容：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we simply compare the initial contents of the fields against the empty
    string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需将字段的初始内容与空字符串进行比较。
- en: This test passes straight away, great! Although a tenant of TDD always starts
    with a red test, you might want to do a quick sanity check, and add some text
    to the XML for `EditText` and run the tests, and when it goes red and green again
    when you remove the added text, you know your test is validating the behavior
    you expect (and it wasn't green as a side effect of something you did not expect).
    We successfully converted one requirement to a test, and validated it by obtaining
    the test results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试立即通过，太好了！尽管TDD的一个原则是从红色测试开始，你可能想要做一个快速的正确性检查，为`EditText`的XML添加一些文本并运行测试，当它在你删除添加的文本后再次变红变绿时，你知道你的测试正在验证你期望的行为（而不是因为你不期望的副作用而变绿）。我们成功地将一个需求转换为测试，并通过获取测试结果来验证它。
- en: View properties
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图属性
- en: 'Identically, we can verify other properties of the Views composing our layout.
    Among other things, we can verify:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以验证组成我们布局的视图的其他属性。我们可以验证其他事项，例如：
- en: Fields (appear on the screen as expected)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段（如预期出现在屏幕上）
- en: Font sizes
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小
- en: Margins
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边距
- en: Screen alignment
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕对齐
- en: 'Let''s start verifying that the fields are on the screen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先验证字段是否在屏幕上：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As explained before, we use an assert from here: `ViewAsserts`: `assertOnScreen`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们从这里使用一个断言：`ViewAsserts`：`assertOnScreen`。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Static imports and how to make the most of them was explained in [Chapter 2](part0020_split_000.html#page
    "Chapter 2. Understanding Testing with the Android SDK"), *Understanding Testing
    with the Android SDK*. If you haven't done it before, now is the time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入及其最佳使用方式在[第2章](part0020_split_000.html#page "第2章. 使用Android SDK进行测试理解")中进行了说明，*理解使用Android
    SDK的测试*。如果你之前没有做过，现在是时候了。
- en: The `assertOnScreen()` method needs an origin to start looking for the other
    Views. In this case, because we want to start from the top-most level, we use
    `getDecorView()`, which retrieves the top-level window view containing the standard
    window frame and decorations, with the client's content inside.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertOnScreen()`方法需要一个起点来寻找其他视图。在这种情况下，因为我们要从最高级别开始，我们使用`getDecorView()`，它获取包含标准窗口框架和装饰的顶级窗口视图，以及客户端内容。'
- en: By running this test, we can ensure that the entry fields are on the screen,
    as the UI design dictates. In some way, we already knew that Views, with these
    specific IDs, existed. That is, we made the fixture compile by adding the Views
    to the main layout, but we were not sure they were appearing on the screen at
    all. So, nothing else is needed but the sole presence of this test, to ensure
    that the condition is not changed in the future. If we remove one of the fields
    for some reason, this test will tell us that it is missing, and not complying
    with the UI design.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个测试，我们可以确保输入字段出现在屏幕上，正如UI设计所规定的那样。在某种程度上，我们已经知道具有这些特定ID的视图存在。也就是说，我们通过将视图添加到主布局中，使装置得以编译，但我们并不确定它们是否真的出现在屏幕上。因此，仅需要这个测试的存在，以确保将来不会改变这个条件。如果我们因为某些原因移除了其中一个字段，这个测试会告诉我们它缺失了，不符合UI设计。
- en: 'Following with our list of requirements, we should test that the Views are
    aligned in the layout as we expect:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的需求列表，我们应该测试视图是否按照我们期望的方式在布局中排列：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We continue using asserts from `ViewAssert`—in this case, `assertLeftAligned`
    and `assertRightAligned`. These methods verify the alignment of the specified
    Views. To get this test running we have to add the two lookups for the label TextView''s
    in the `setUp()` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用`ViewAssert`中的断言——在这种情况下，使用`assertLeftAligned`和`assertRightAligned`。这些方法验证指定视图的对齐方式。为了运行这个测试，我们必须在`setUp()`方法中为标签TextView添加两个查找：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `LinearLayout` class we are using by default arranges the fields in the
    way we are expecting them. Again, while we don't need to add anything to the layout,
    to satisfy the test, this will act as a guard condition.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认使用的`LinearLayout`类以我们期望的方式排列字段。再次强调，虽然我们不需要向布局中添加任何东西以满足测试，但这将作为一个保护条件。
- en: 'Once we''ve verified that they are correctly aligned, we should verify that
    they are covering the whole screen width, as specified by the schematic drawing.
    In this example, it''s sufficient to verify `LayoutParams` having the correct
    values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证它们正确对齐，我们应该验证它们是否覆盖了整个屏幕宽度，如原理图所指定。在这个例子中，只需验证`LayoutParams`具有正确的值就足够了：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We used a custom message to easily identify the problem, in case the test fails.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自定义信息以便在测试失败时轻松识别问题。
- en: 'By running this test, we obtain the following message indicating that the test
    failed: **AssertionFailedError: celsiusInput layout width is not MATCH_PARENT
    expected:<-1> but was:<-2>**.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '运行这个测试，我们得到以下信息，表明测试失败了：**AssertionFailedError: celsiusInput布局宽度不是MATCH_PARENT，预期：<-1>
    但实际：<-2>**。'
- en: 'This leads us to the layout definition. We must change `layout_width` to be
    `match_parent` for the Celsius and Fahrenheit fields:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们到布局定义。我们必须将`layout_width`从Celsius和Fahrenheit字段更改为`match_parent`：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Same for Fahrenheit—after the change is done, we repeat the cycle, and by running
    the test again, we can verify that it is now successful.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Fahrenheit字段也是如此——更改完成后，我们重复这个循环，并再次运行测试，以验证现在它是否成功。
- en: Our method is starting to appear. We create the test to verify a condition described
    in the requirements. If it's not met, we change the cause of the problem, and
    running the tests again, we verify that the latest change solves the problem,
    and what is perhaps more important is that the change doesn't break the existing
    code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法开始显现。我们创建测试用以验证需求中描述的条件。如果条件不满足，我们就改变问题产生的原因，并再次运行测试，验证最新的更改是否解决了问题，或许更重要的是，这个更改没有破坏现有的代码。
- en: 'Next, let''s verify that the font sizes are defined as per our requirements:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们验证字体大小是否符合我们的要求：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Retrieving the font size used by the field is enough in this case.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，获取字段使用的字体大小就足够了。
- en: The default font size is not `24px`, so we need to add this to our layout. It's
    a good practice to add the corresponding dimension to a resource file, and then
    use it where it's needed in the layout. So, let's add `label_text_size` to `res/values/dimens.xml,`
    with a value of `24sp`. Then reference it in the `Text` `size` property of the
    labels, `celsius_label` and `fahrenheit_label`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认字体大小不是`24px`，因此我们需要将其添加到我们的布局中。一个好的做法是将相应的尺寸添加到资源文件中，然后在布局中需要的地方使用它。所以，让我们在`res/values/dimens.xml`中添加`label_text_size`，值为`24sp`。然后在标签`celsius_label`和`fahrenheit_label`的`Text`大小属性中引用它。
- en: 'Now, the test may pass or it may not, depending on the resolution of your device
    or emulator you are using. This is because we are asserting in the test, the pixel
    size, but we have declared in the `dimens.xml,` to use `sp` (scale independent
    pixels). Let''s harden this test. To resolve this we could either convert our
    `px` to `sp` in the test class, or use the `sp` value in the test. I have chosen
    to use `sp` in the test, although you could argue for either:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试可能通过也可能不通过，这取决于你使用的设备或模拟器的分辨率。这是因为我们在测试中断言像素大小，但在`dimens.xml`中我们声明使用`sp`（与缩放无关的像素）。让我们加强这个测试。为了解决这个问题，我们可以在测试类中将`px`转换为`sp`，或者在测试中使用`sp`值。我选择在测试中使用`sp`，尽管你也可以为另一种方法争论：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let''s verify that margins are interpreted as described in the user
    interface design:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们验证边距是否按照用户界面设计中的描述进行了解释：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a similar case as before (I've skipped the step of testing the raw pixel
    value). We need to add the margin to our layout. Let's add the margin dimension
    to the resource file, and then use it where it's needed in the layout. Set the
    `margin` dimension in `res/values/dimens.xml` to a value of `8dp`. Then, reference
    it in the `layout_margin_start` property of both fields, `celsius` and `fahrenheit`,
    and also in the `start` `margin` of the labels.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的案例类似（我跳过了测试原始像素值的步骤）。我们需要在布局中添加边距。让我们在资源文件中添加边距尺寸，然后在布局中需要的地方引用它。在`res/values/dimens.xml`中将`margin`尺寸设置为`8dp`。然后，在`celsius`和`fahrenheit`两个字段的`layout_margin_start`属性以及标签的`start`
    `margin`中引用它。
- en: 'The `helper` method to get the integer pixel size from a resource `dimen,`
    just wraps the `float` method already discussed:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 获取从资源`dimen`中整数像素大小的`helper`方法，只是包装了之前讨论过的`float`方法：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One more thing that is left is to verify the justification (alignment) of the
    entered values. We will validate the input shortly, to allow only the permitted
    values, but for now let''s just pay attention to the justification. The intention
    is to have values that are smaller than the whole field, justified to the right
    and vertically centered:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事是剩下的，就是验证输入值的对齐（调整）。我们很快就会验证输入，只允许输入允许的值，但现在让我们关注对齐。意图是让小于整个字段的值右对齐并垂直居中：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we verify the `gravity` values as usual. However, we are using a custom
    message to help us identify the values that could be wrong. As the `Gravity` class
    defines several constants whose values are better identified if expressed in hexadecimal,
    we are converting the values to this base in the message.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们像往常一样验证`gravity`值。然而，我们使用自定义消息来帮助我们识别可能出错的值。由于`Gravity`类定义了几个常量，其值以十六进制表示更容易识别，我们在消息中将这些值转换为这种基数。
- en: If this test is failing due to the default gravity used for the fields, then
    what is only left is to change it. Go to the layout definition and alter these
    `gravity` values, so that the test succeeds.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个测试因为字段使用的默认重力而失败，那么剩下的就是改变它。转到布局定义并更改这些`gravity`值，以便测试成功。
- en: 'This is precisely what we need to add:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要添加的内容：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Screen layout
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕布局
- en: We now want to verify that the requirement specifying that enough screen space
    should be reserved to display the keyboard, is actually fulfilled.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望验证是否已经满足规定屏幕空间应保留足够空间以显示键盘的要求。
- en: 'We can write a test like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写如下测试：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This verifies that the actual position of the last field in the screen, which
    is `fahrenheitInput`, is not lower than a suggested value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了屏幕上最后一个字段`fahrenheitInput`的实际位置是否不低于建议值。
- en: 'We can run the tests again verifying that everything is green again. Run up
    your application, and you should have a complete user interface backed by tests,
    as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次运行测试，验证一切是否再次变绿。运行你的应用程序，你应该会有一个由测试支持的完整用户界面，如下截图所示：
- en: '![Screen layout](img/00027.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕布局](img/00027.jpeg)'
- en: Adding functionality
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加功能
- en: The user interface is in place. Now, we can start adding some basic functionality.
    This functionality will include the code to handle the actual temperature conversion.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面已经就位。现在，我们可以开始添加一些基本功能。这些功能将包括处理实际温度转换的代码。
- en: Temperature conversion
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 温度转换
- en: 'From the list of requirements, we can obtain this statement: When one temperature
    is entered in one field, the other one is automatically updated with the conversion.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从需求列表中，我们可以得到这个声明：在一个字段中输入一个温度时，另一个字段应自动更新为转换后的温度。
- en: 'Following our plan, we must implement this as a test to verify that the correct
    functionality is there. Our test would look something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的计划，我们必须实现这个测试以验证正确功能的存在。我们的测试可能看起来像这样：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s run through this step-by-step:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地执行这个操作：
- en: Firstly, as we already know, to interact with the UI changing its values we
    should run the test on the UI thread, and thus because we use `EditText.setText`,
    the test is annotated with `@UiThreadTest`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，正如我们已经知道的，为了与UI交互并更改其值，我们应该在UI线程上运行测试，因此由于我们使用`EditText.setText`，测试被注解为`@UiThreadTest`。
- en: Secondly, we are using a specialized class to replace `EditText` providing some
    convenience methods such as `clear()` and `setNumber()`. This will improve our
    application design.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们使用一个专门的类来替换`EditText`，提供一些便捷方法，如`clear()`和`setNumber()`。这将改善我们的应用设计。
- en: Next, we invoke a converter, named `TemperatureConverter`, a utility class providing
    the different methods to convert between different temperature units, and using
    different types for the temperature values.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用一个名为`TemperatureConverter`的转换器，这是一个工具类，提供不同的方法来转换不同的温度单位，并使用不同的温度值类型。
- en: Finally, as we will be truncating the results to provide them in a suitable
    format presented in the user interface, we should compare against a delta to assert
    the value of the conversion.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于我们将截断结果以在用户界面中以合适的格式呈现，我们应该与一个增量比较来断言转换值的准确性。
- en: Creating the test like this will force us to follow the planned path. Our first
    objective is to add the needed methods and code to get the test to compile, and
    then to satisfy the test's needs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这样创建测试将迫使我们按照计划路径执行。我们的第一个目标是添加所需的方法和代码以使测试能够编译，然后满足测试的需求。
- en: The EditNumber class
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditNumber类
- en: 'In our main package, not in the tests one (which is not the one under `/androidTest/`),
    we should create the `EditNumber` class extending `EditText,` as we need to extend
    its functionality. Once the class is created, we need to change the type of the
    fields in our test class member types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主包中（不是在测试包中，也不是在`/androidTest/`下的那个），我们应该创建一个继承`EditText`的`EditNumber`类，因为我们需要扩展其功能。创建类后，我们需要更改测试类成员类型的字段类型：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, change any cast that is present in the tests. Your IDE will highlight
    these; press *F2* to find them in the class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更改测试中存在的任何强制类型转换。你的IDE会高亮这些代码；按下*F2*在类中找到它们。
- en: 'There are still two problems we need to fix before being able to compile the
    test:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够编译测试之前，我们还需要解决两个问题：
- en: We still don't have the `clear()` and `setNumber()`methods in `EditNumber`
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`EditNumber`中仍然没有`clear()`和`setNumber()`方法
- en: We don't have the `TemperatureConverter` utility class
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还没有`TemperatureConverter`工具类
- en: From inside our test class, we can use the IDE to help us create the methods.
    Press *F2* again, and you should be taken to the error for **Cannot resolve method
    clear()**. Now press *Alt* + *Enter* to create the `clear()`method in type `EditNumber`.
    Same for `getNumber()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类的内部，我们可以使用IDE来帮助我们创建方法。再次按下*F2*，你应被带到**无法解析方法clear()**的错误处。现在按下*Alt* + *Enter*，在`EditNumber`类型中创建`clear()`方法。`getNumber()`方法同理。
- en: Finally, we must create the `TemperatureConverter` class. This class will hold
    the mathematical conversions of Celsius and Fahrenheit, and no Android code. Therefore,
    we can create this package inside of our `/core/` module. As previously discussed,
    it will be under the same package structure, only this module does not know about
    Android and, therefore, we can write JVM tests that run much faster.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建`TemperatureConverter`类。这个类将包含摄氏度和华氏度的数学转换，不包含任何Android代码。因此，我们可以在`/core/`模块内创建此包。如先前讨论的，它将位于相同的包结构下，只是这个模块不知道Android，因此我们可以编写运行速度更快的JVM测试。
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure to create it in the core module under the same package as your main
    code, and not in the test package.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在核心模块中创建它，并且与你的主代码位于同一包下，而不是测试包。
- en: 'Here''s how to create that class in the core module, and the current state
    of our application:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在核心模块中创建该类，以及我们应用程序当前状态的方法：
- en: '![The EditNumber class](img/00028.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber类](img/00028.jpeg)'
- en: Having done this, in our test, it creates the `fahrenheitToCelsius` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，在我们的测试中，创建了`fahrenheitToCelsius`方法。
- en: This fixes our last problem, and leads us to a test that we can now compile
    and run. Yes you will have red Lint errors, but these are not "compile" errors,
    and so the tests can still run. (AndroidStudio's cleverness is too damn high.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们之前的问题，并引导我们进行一个现在可以编译和运行的测试。是的，你将会看到红色的Lint错误，但这些并不是"编译"错误，因此测试仍然可以运行。（AndroidStudio的智能程度实在是太高了。）
- en: 'Surprisingly, or not, when we run the tests, they will fail with an exception:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，当我们运行测试时，它们会因为异常而失败：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That is because we updated all of our Java files to include our newly created
    `EditNumber` class, but forgot to change the layout XML.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们更新了所有的Java文件以包含我们新创建的`EditNumber`类，但忘记了更改布局XML。
- en: 'Let''s proceed to update our UI definition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新我们的UI定义：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That is, we replace the original `EditText` class by `com.blundell.tut.EditNumber,`
    which is a View extending the original `EditText` class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们用扩展原始`EditText`类的`com.blundell.tut.EditNumber`视图替换了原来的`EditText`类。
- en: Now, we run the tests again, and we discover that all tests pass.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次运行测试，发现所有测试都通过了。
- en: But wait a minute; we haven't implemented any conversion or any handling of
    values in the new `EditNumber` class, and all tests passed with no problem. Yes,
    they passed because we don't have enough restrictions in our system and the ones
    in place, simply cancel themselves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但等一下；我们在新的`EditNumber`类中还没有实现任何转换或处理值的方法，所有测试都顺利通过了。是的，它们通过了，因为我们的系统没有足够的限制，现有的限制仅仅相互抵消了。
- en: Before going further, let's analyze what just happened. Our test invoked the
    `fahrenheitInput.setText ("32.5")` method to set the temperature entered in the
    **Fahrenheit** field, but our `EditNumber` class doesn't do anything when text
    is entered, and the functionality is not implemented. So, the **Celsius** field
    remains empty.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们分析一下刚才发生了什么。我们的测试调用了`fahrenheitInput.setText("32.5")`方法来设置**华氏度**字段输入的温度，但我们的`EditNumber`类在输入文本时什么也不做，功能尚未实现。因此，**摄氏度**字段保持为空。
- en: The value for `expectedC`—the expected temperature in Celsius, is calculated
    invoking `TemperatureConverter.fahrenheitToCelsius(f)`, but this is an empty method.
    In this case because we knew the return type of the method we made it return to
    a constant `0`. So, `expectedC` becomes `0`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`expectedC`的值——预期的摄氏度温度，是通过调用`TemperatureConverter.fahrenheitToCelsius(f)`计算的，但这是一个空方法。在这种情况下，因为我们知道方法的返回类型，所以我们让它返回一个常数`0`。因此，`expectedC`变成了`0`。'
- en: Then, the actual value for the conversion is obtained from the UI. In this case
    invoking `getNumber()` from `EditNumber`. But this method was automatically generated,
    and to satisfy the restriction imposed by its signature, it must return a value,
    namely `0`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从用户界面获取转换的实际值。在这种情况下，从`EditNumber`调用`getNumber()`。但这个方法是自动生成的，为了满足其签名所施加的限制，它必须返回一个值，即`0`。
- en: The delta value is again `0`, as calculated by `Math.abs(expectedC` `–` `actualC)`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Δ值再次为`0`，由`Math.abs(expectedC - actualC)`计算得出。
- en: And finally our assertion `assertTrue(msg,` `delta` `<` `0.005)` is `true,`
    because `delta=0` satisfies the condition, and the test passes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的断言`assertTrue(msg, delta < 0.005)`为`true`，因为`delta=0`满足了条件，测试通过。
- en: So, is our methodology flawed, as it cannot detect a simple situation like this?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的方法有缺陷吗，因为它无法检测到这种情况？
- en: No, not at all, the problem here is that we don't have enough restrictions,
    and they are satisfied by the default values used by auto-generated methods. One
    alternative could be to throw exceptions at all of the auto-generated methods,
    something like `RuntimeException("not` `yet` `implemented")` to detect its use
    when not implemented. We will be adding enough restrictions in our system to easily
    trap this *double zero* condition.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不，完全不是，这里的问题是我们的限制不够，而这些限制被自动生成方法使用的默认值满足了。一种替代方法可能是对所有自动生成的方法抛出异常，比如`RuntimeException("尚未实现")`，以检测在未实现时使用它的情况。我们将在系统中增加足够的限制，以便轻松捕捉这种*双重零*条件。
- en: The TemperatureConverter unit tests
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 温度转换器的单元测试
- en: It seems, from our previous experience, that the default conversion implemented
    always returns `0`, so we need something more robust. Otherwise, our converter
    will only be returning a valid result, when the parameter takes the value of 32F
    (32F == 0C).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前经验来看，似乎默认实现的转换总是返回`0`，因此我们需要更健壮的东西。否则，我们的转换器只有在参数取32F（32F == 0C）的值时才会返回有效的结果。
- en: The `TemperatureConverter` class is a utility class not related with the Android
    infrastructure, so a standard unit test will be enough to test it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemperatureConverter` 类是一个与 Android 基础架构无关的实用类，因此一个标准的单元测试就足以测试它。'
- en: As this is the first core test we are going to write, we need to do some setup.
    Firstly, from the project view; in your project structure create a `test` folder
    under `/core/src` by selecting **New** | **Directory** and using the name `test`.
    Inside this, create a `java` folder by selecting **New** | **Directory,** and
    using the name `java`. With Gradle being magic, it will now understand that this
    is a place you want to add tests, and the folder should turn green (green means
    that the folder is a part of the test classpath). Now add a new package, technically
    it is not new because we are going to use `com.blundell.tut` again, by selecting
    **New** | **Package** | and using the name `com/blundell/tut`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们即将编写的第一个核心测试，我们需要进行一些设置。首先，从项目视图开始；在你的项目结构中，通过选择 **新建** | **目录** 并使用名称
    `test` 在 `/core/src` 下创建一个 `test` 文件夹。在这个文件夹内，通过选择 **新建** | **目录** 并使用名称 `java`
    创建一个 `java` 文件夹。由于 Gradle 的神奇之处，它会明白这是你想要添加测试的地方，文件夹应该会变成绿色（绿色表示该文件夹是测试类路径的一部分）。现在添加一个新的包，从技术上来说并不是新的，因为我们将再次使用
    `com.blundell.tut`，通过选择 **新建** | **包** 并使用名称 `com/blundell/tut`。
- en: 'Now. we create our tests in our new folder and package. We create our tests
    by selecting **New** | **Java Class**, and calling it `TemperatureConverterTests`.
    Your project should now look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们新的文件夹和包中创建我们的测试。我们通过选择 **新建** | **Java 类** 并将其命名为 `TemperatureConverterTests`
    来创建测试。你的项目现在应该看起来像这样：
- en: '![The TemperatureConverter unit tests](img/00029.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![温度转换器单元测试](img/00029.jpeg)'
- en: 'Let''s make our first test, inside of `TemperatureConverterTests,` press *Ctrl*
    + *Enter* to bring up the **Generate** menu, as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第一个测试，在 `TemperatureConverterTests` 内，按 *Ctrl* + *Enter* 弹出 **生成** 菜单，如下面的截图所示：
- en: '![The TemperatureConverter unit tests](img/00030.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![温度转换器单元测试](img/00030.jpeg)'
- en: 'Selecting the **Test Method** test, then **JUnit4** will generate us a template
    method of a test that we want, name it `testFahrenheitToCelsius()`. Remember this
    shortcut as it''s handy whenever creating a new test. Once you''ve generated this
    test, you''ll notice we have compile errors on the JUnit 4 imported lines of code.
    Oops! we forgot to add the JUnit library to the test classpath of our core module.
    Open up the build file in `/core/build.gradle,` and add the JUnit dependency.
    Your core `build.gradle` will now look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **测试方法** 测试，然后选择 JUnit4 将为我们生成我们想要的测试模板方法，将其命名为 `testFahrenheitToCelsius()`。记住这个快捷方式，因为它在创建新测试时非常有用。一旦你生成了这个测试，你会注意到我们在
    JUnit 4 导入的代码行上有编译错误。哎呀！我们忘记将 JUnit 库添加到我们核心模块的测试类路径中。打开 `/core/build.gradle`
    文件，并添加 JUnit 依赖。你的核心 `build.gradle` 现在应该看起来像这样：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice, here we have jumped from JUnit3 to JUnit4 the main difference being
    we can now use annotations to tell our test runner, which of the methods in the
    class are tests. Therefore, technically we don't need to start the methods with
    `test` as in `testFooBar()` anymore, but we will for our own sanity when swopping
    between the two (Android JUnit4 support is coming soon!).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们从 JUnit3 跳到了 JUnit4，主要区别在于我们现在可以使用注解来告诉我们的测试运行器，类中的哪些方法是测试方法。因此，从技术上讲，我们不再需要像
    `testFooBar()` 那样以 `test` 开头的方法名，但为了在我们两者之间切换时保持清醒，我们还是会这样做（Android 对 JUnit4 的支持即将到来！）。
- en: 'Do a project sync by selecting **Project Sync,** and we are compiling and ready
    to code. Let''s start writing the test:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择 **项目同步** 来进行项目同步，我们现在可以编译并准备编码。让我们开始编写测试：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Creating a conversion table with values for different temperature conversion,
    we know from other sources, would be a good way to drive this test:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有不同温度转换值的转换表，我们知道从其他来源驱动这个测试是一个好方法：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run tests in the core module, we can right click on the file in the project
    view, and select **Run**. As the screenshot also shows, you can use the shortcut
    *Cmd* + *Shift* + *F10*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要在核心模块中运行测试，我们可以右键点击项目视图中的文件，并选择 **运行**。正如截图也显示的那样，你可以使用快捷键 *Cmd* + *Shift*
    + *F10*：
- en: '![The TemperatureConverter unit tests](img/00031.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![温度转换器单元测试](img/00031.jpeg)'
- en: 'When this test runs, we verify that it fails, giving us this trace:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试运行时，我们验证它失败，并给我们留下这条轨迹：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See how fast those core tests ran! Aim for moving as much of your application
    logic into your core module as you can, so you can take advantage of this speed
    when doing Test-driven Development.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些核心测试运行得多快！尽量将应用程序逻辑移到核心模块中，这样在进行测试驱动开发时，你可以利用这个速度。
- en: 'Well, this was something we were expecting as our conversion always returns
    `0`. Implementing our conversion, we discover that we need some `ABSOLUTE_ZERO_F`
    constant:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是我们预料之中的事情，因为我们的转换总是返回`0`。实现我们的转换时，我们发现我们需要一个`ABSOLUTE_ZERO_F`常量：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Absolute zero, is the theoretical temperature at which entropy would reach its
    minimum value. To be able to reach this absolute zero state, according to the
    laws of thermodynamics, the system should be isolated from the rest of the universe.
    Thus, it is an unreachable state. However, by international agreement, absolute
    zero is defined as 0K on the Kelvin scale, and as -273.15°C on the Celsius scale
    or to -459.67°F on the Fahrenheit scale.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对零度是熵达到最小值的理论温度。根据热力学定律，要达到这个绝对零度的状态，系统应该与宇宙的其余部分隔离。因此，这是一个无法达到的状态。然而，按照国际协议，绝对零度定义为开尔文量表上的0K，摄氏量表上的-273.15°C，或者华氏量表上的-459.67°F。
- en: 'We are creating a custom exception, `InvalidTemperatureException`, to indicate
    a failure providing a valid temperature to the conversion method. This exception
    doesn''t know anything about Android, and so can also sit in our core module.
    Create it by extending `RuntimeException`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个自定义异常`InvalidTemperatureException`，以指示在转换方法中提供有效温度失败。这个异常与Android无关，因此也可以放在我们的核心模块中。通过扩展`RuntimeException`来创建它：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Running the core tests again, we discover that `testFahrenheitToCelsius` succeeds.
    Therefore, we move back to our Android tests, and running these show us such that
    `testFahrenheitToCelsiusConversion` test fails. This tells us, that now the converter
    class correctly handles conversions, but there are still some problems with the
    UI handling this conversion.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行核心测试，我们发现`testFahrenheitToCelsius`测试成功了。因此，我们回到Android测试，运行这些测试发现`testFahrenheitToCelsiusConversion`测试失败了。这告诉我们，现在转换器类正确处理了转换，但UI处理这个转换仍然存在一些问题。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't despair about running two separate test classes. It is common for you
    to be selective about what tests to run; this is partly a learnt skill when doing
    TDD. However, if you so wish, you can write custom test runners that will run
    all of your tests. Also, using Gradle to run `build connectedAndroidTest` will
    run all your tests at once, which is advised whenever you consider you have completed
    a feature, or want to commit to your upstream version control.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不必对运行两个单独的测试类感到绝望。对你来说，选择运行哪些测试是常见的；这在进行TDD时部分是学习到的技能。但是，如果你愿意，可以编写自定义测试运行器来运行所有的测试。此外，使用Gradle运行`build
    connectedAndroidTest`将一次性运行所有测试，这建议在你认为完成了一个功能或想要提交到上游版本控制时执行。
- en: A closer look at the `testFahrenheitToCelsiusConversion` failure trace reveals
    that there's something still returning `0,` when it shouldn't.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看`testFahrenheitToCelsiusConversion`失败的追踪信息，可以发现有些地方在不应返回`0`的情况下仍然返回了`0`。
- en: This reminds us that we are still lacking a proper `EditNumber` implementation.
    Before proceeding to implement the mentioned methods, let's create the corresponding
    tests to verify what we are implementing is correct.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们，我们仍然缺少一个合适的`EditNumber`实现。在继续实现上述方法之前，让我们创建相应的测试来验证我们正在实现的内容是否正确。
- en: The EditNumber tests
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`EditNumber`测试'
- en: From the previous chapter, we can now determine that the best base class for
    our custom View tests is `AndroidTestCase`, as we need a mock `Context` class
    to create the custom View, but we don't need system infrastructure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一章可以确定，我们自定义视图测试的最佳基类是`AndroidTestCase`，因为我们需要一个模拟的`Context`类来创建自定义视图，但我们不需要系统基础结构。
- en: Create the tests for `EditNumber`, let's call it `EditNumberTests,` and extend
    `AndroidTestCase`. Reminder, this is under the app module in the `androidTest`
    path.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`EditNumber`的测试，我们称之为`EditNumberTests`，并扩展`AndroidTestCase`。提醒一下，这位于应用模块下的`androidTest`路径中。
- en: 'We need to add the constructors to reflect the pattern we identified before
    with the given name pattern:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加构造函数以反映我们之前识别的给定名称模式：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next step is to create the fixture. In this case, this is a simple `EditNumber`
    class that we will be testing:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建测试夹具。在这种情况下，这是一个简单的`EditNumber`类，我们将对其进行测试：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The mock context is obtained from the protected field `mContext` ([http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext](http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext)),
    available in the `AndroidTestCase` class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟上下文是从`AndroidTestCase`类中受保护的字段`mContext`获取的（[http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext](http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext)）。
- en: At the end of the `setUp` method, we set `editNumber` as a focusable View, meaning
    it will be able to gain focus, as it will be participating in a bunch of tests
    simulating UIs that may need to request its focus explicitly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp`方法的最后，我们将`editNumber`设置为可聚焦的视图，这意味着它将能够获得焦点，因为它将参与许多模拟可能需要显式请求其焦点的UI的测试。
- en: 'Next, we test that the required `clear()` functionality is implemented correctly
    in the `testClear()` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试`testClear()`方法中所需`clear()`功能的正确实现：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running the test we verify that it fails:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，我们验证它确实失败了：
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We need to implement `EditNumber.clear()` correctly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要正确实现`EditNumber.clear()`。
- en: 'This is a simple case, so just by adding this implementation to `EditNumber,`
    we satisfy the test:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的案例，只需将此实现添加到`EditNumber`中，我们就可以满足测试：
- en: '[PRE34]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the test and proceed. We are going to add a new method to `EditNumber.`
    Here, we already have `getNumber(), and` we are adding `setNumber()` so that we
    can use it later on. Now let''s complete the `testSetNumber()` implementation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并继续。我们将在`EditNumber`中添加一个新方法。这里，我们已经有了`getNumber()`，我们现在添加`setNumber()`以便稍后使用。现在让我们完成`testSetNumber()`实现的编写：
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Which fails unless we implement `EditNumber.setNumber()`, similar to this implementation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们实现了类似于以下实现的`EditNumber.setNumber()`，否则会失败：
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are using a constant, `DEFAULT_FORMAT`, to hold the desired format to convert
    the numbers. This can be later converted to a property that could also be specified
    in the XML layout definition of the field.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个常量`DEFAULT_FORMAT`来保存转换数字所需的格式。这可以稍后转换为属性，也可以在字段的XML布局定义中指定。
- en: 'The same goes for the `testGetNumber()` and `getNumber()` pair:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`testGetNumber()`和`getNumber()`这一对：
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And the `getNumber()` method is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNumber()`方法如下所示：'
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These tests succeed, so run your other tests to see where we are up to; I did
    this on the command line running the `gradlew build cAT` command. This runs all
    of the tests we have written so far; but `testFahrenheitToCelsiusConversion()`
    is failing. We have a lot of well tested code, take a step back, and reflect.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试成功了，所以运行你的其他测试来看我们进行到哪一步；我在命令行中运行了`gradlew build cAT`命令来做到这一点。这运行了我们到目前为止编写的所有测试；但`testFahrenheitToCelsiusConversion()`失败了。我们已经有很多经过良好测试的代码，退一步，反思一下。
- en: 'Here are our Android test results:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们Android测试的结果：
- en: '![The EditNumber tests](img/00032.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber测试](img/00032.jpeg)'
- en: 'Here are our core Java test results:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们核心的Java测试结果：
- en: '![The EditNumber tests](img/00033.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber测试](img/00033.jpeg)'
- en: With `testFahrenheitToCelsiusConversion()` if you closely analyze the test case,
    can you can discover where the problem is.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细分析`testFahrenheitToCelsiusConversion()`测试用例，你就能发现问题所在。
- en: Got it?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了吗？
- en: 'Our test method is expecting the conversion to happen automatically when the
    focus changes, as was specified in our list of requirements: "when one temperature
    is entered in one field, the other one is automatically updated with the conversion".'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试方法期望当焦点发生变化时自动进行转换，正如我们需求列表中指定的那样：“在一个字段中输入一个温度时，另一个字段会自动更新为转换后的值”。
- en: Remember, we don't have buttons or anything else to convert temperature values,
    so the conversion is to be done automatically, once the values are entered.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们没有按钮或任何其他东西来转换温度值，所以一旦输入了值，转换应该是自动进行的。
- en: This leads us back to our `TemperatureConverterActivity` class, and the way
    it handles the conversions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们回到了`TemperatureConverterActivity`类，以及它处理转换的方式。
- en: The TemperatureChangeWatcher class
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TemperatureChangeWatcher类
- en: One way of implementing the required behavior of constantly updating the other
    temperature value, is once the original has changed is through a `TextWatcher`.
    From the documentation, we can understand that a `TextWatcher` is an object of
    a type that is attached to an `Editable`; its methods will be called, when the
    text is changed ([http://developer.android.com/reference/android/text/TextWatcher.html](http://developer.android.com/reference/android/text/TextWatcher.html)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 实现不断更新另一个温度值所需行为的一种方式，是在原始值发生变化时通过`TextWatcher`。从文档中，我们可以理解`TextWatcher`是附加到`Editable`的类型的一个对象；当文本更改时，将调用其方法（[http://developer.android.com/reference/android/text/TextWatcher.html](http://developer.android.com/reference/android/text/TextWatcher.html)）。
- en: It seems that is what we need.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是我们需要的。
- en: 'We implement this class as an inner class of `TemperatureConverterActivity`.
    The idea behind this is, because we act directly on the Views of the Activity,
    having it as an inner class shows this relationship, and keeps it obvious, should
    someone think of changing this Activity''s layout. If you implement the minimum
    `TextWatcher,` your Activity will look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个类实现为`TemperatureConverterActivity`的内部类。这样做的想法是，因为我们直接作用于Activity的Views，将其作为内部类显示了这种关系，并且如果有人想要更改此Activity的布局，这会使关系变得清晰。如果你实现了最小的`TextWatcher`，你的Activity将如下所示：
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And now this is our code, after some additions to the recently created class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对最近创建的类进行一些添加后的代码如下：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will be using the same `TemperatureChangeWatcher` implementation for both
    fields, Celsius and Fahrenheit; therefore we keep a reference to the fields used
    as source and destination, as well as the operation needed to update their values.
    To specify this operation, we are introducing `enum,` which is pure Java and so
    can go into the core module:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的`TemperatureChangeWatcher`实现，用于摄氏度和华氏度这两个字段；因此我们保留了作为源和目标字段以及更新它们值的操作的引用。为了指定此操作，我们引入了`enum`，它是纯Java，因此可以放入核心模块中：
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This operation is specified in the creation factory methods, and the destination
    and source `EditNumber` are selected accordingly. This way we can use the same
    watcher for different conversions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作在创建工厂方法中指定，并根据需要选择源和目标`EditNumber`。这样我们可以为不同的转换使用相同的观察者。
- en: The method of the `TextWatcher` interface we are interested in, is `onTextChanged`.
    This will be called any time the text changes. At the beginning, we avoid potential
    loops, checking who has focus, and returning if the conditions are not met.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的`TextWatcher`接口的方法是`onTextChanged`。只要文本发生变化，就会调用它。起初，我们避免潜在的循环，检查谁具有焦点，并在条件不满足时返回。
- en: We also set the destination field as an empty string, if the source is empty.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源为空，我们也应将目标字段设置为空字符串。
- en: Finally, we try to set the resulting value of invoking the corresponding conversion
    method to set the destination field. We flag the error as necessary, avoiding
    showing premature errors, when the conversion was invoked with a partially entered
    number.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试将调用相应转换方法得到的结果值设置到目标字段。我们根据需要标记错误，避免在转换被部分输入的数字调用时显示过早的错误。
- en: 'We need to set the listener on the input fields in `TemperatureConverterActivity.onCreate()`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`TemperatureConverterActivity.onCreate()`中设置输入字段的监听器：
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To be able to run the tests, we should compile them. To compile, we need to
    at least define the `celsiusToFahrenheit()` method, which is not yet defined.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行测试，我们应该编译它们。要编译，我们至少需要定义尚未定义的`celsiusToFahrenheit()`方法。
- en: More TemperatureConverter tests
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多温度转换器测试
- en: We need to implement `celsiusToFahrenheit,` and as usual we start from the test.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`celsiusToFahrenheit`，像往常一样，我们从测试开始。
- en: 'This is fairly equivalent to the other conversion method `fahrenheitToCelsius,`
    and we can use the infrastructure we devised while creating this test:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他转换方法`fahrenheitToCelsius`相当等效，我们可以使用在创建此测试时设计的基础架构：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use the conversion table to exercise the method through different conversions,
    and we verify that the error is less than a predefined delta.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用转换表通过不同的转换来练习该方法，并验证误差小于预定义的增量。
- en: 'Then, the correspondent conversion implementation in the `TemperatureConverter`
    class is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`TemperatureConverter`类中的相应转换实现如下：
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, all the tests are passing but we are still not testing all the common conditions.
    What I mean by this is that we have been checking the happy path so far. You should
    check whether errors and exceptions are correctly generated, besides all the normal
    cases we created so far.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有测试都通过了，但我们仍然没有测试所有常见条件。我的意思是，到目前为止我们只检查了正常路径。你应该检查是否正确生成了错误和异常，除了我们到目前为止创建的所有正常情况。
- en: 'Create this test to check the correct generation of exceptions, when a temperature
    below absolute zero is used in a conversion:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个测试，以检查在转换中使用绝对零度以下的温度时，是否正确生成了异常：
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this test, we decrement the absolute zero temperature, to obtain an even
    smaller value, and then we attempt the conversion. We wrote this test in our core
    module, and therefore used JUnit4, which allows us to use annotations to assert
    that we expect an exception to be thrown. If you wanted to do the same thing in
    JUnit3, you would have to use a try catch block, and fail the test if the code
    did not enter the catch block:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们递减绝对零度温度，以获得更小的值，然后尝试转换。我们在核心模块中编写了此测试，因此使用了JUnit4，它允许我们使用注解来断言我们期望抛出异常。如果你想在JUnit3中做同样的事情，你不得不使用try
    catch块，并且如果代码没有进入catch块，则测试失败：
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In a similar manner, we test for the exception being thrown, when the attempted
    conversion involves a temperature in Celsius, that is lower than the absolute
    zero.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们测试当尝试转换涉及低于绝对零的摄氏度温度时，是否抛出了异常。
- en: The InputFilter tests
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入过滤器测试
- en: 'Another error requirement could be: We want to filter the input that is received
    by the conversion utility, so no garbage reaches this point.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误要求可能是：我们希望过滤掉转换工具接收到的输入，这样不会有垃圾到达这个点。
- en: 'The `EditNumber` class already filters valid input, and generates exceptions
    otherwise. We can verify this condition by creating a new test in `TemperatureConverterActivityTests`.
    We choose this class because we are sending keys to the entry fields, just as
    a real user would do:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditNumber`类已经过滤了有效输入，否则将生成异常。我们可以通过在`TemperatureConverterActivityTests`中创建一个新测试来验证这个条件。我们选择这个类，因为我们是像真实用户一样向输入字段发送键：'
- en: '[PRE47]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This test requests the focus onto the Celsius field using the pattern reviewed
    previously. This allows us to run parts of a test in the UI thread, and send key
    input to the view. The keys sent are an invalid sequence containing more than
    one period, which is not accepted for a well-formed decimal number. It is expected
    that when the filter is in place, this sequence will be filtered, and only the
    valid characters reach the field. Asserting that the value returned by `celsiusInput.getNumber(),`
    is what we expect after filtering.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用之前回顾的模式，请求将焦点移到摄氏度字段。这允许我们在UI线程中运行测试的一部分，并向视图发送键输入。发送的键是一个包含多个点的无效序列，这对于一个格式良好的十进制数是不被接受的。预期当过滤器启用时，这个序列将被过滤，只有有效字符到达字段。断言`celsiusInput.getNumber()`返回的值，在过滤后是我们所期望的。
- en: 'To implement this filter, we need to add `InputFilter` to `EditNumber`. Because
    this should be added to all of the constructors, we create an additional `init()`method,
    which we invoke from each. To achieve our goal we use an instance of `DigitsKeyListener,`
    accepting digits, signs, and decimal points as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个过滤器，我们需要向`EditNumber`添加`InputFilter`。因为应该将其添加到所有构造函数中，所以我们创建了一个额外的`init()`方法，从每个构造函数中调用它。为了实现我们的目标，我们使用了`DigitsKeyListener`的实例，接受数字、符号和十进制点如下：
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This `init` method is invoked from each constructor, so that if this view is
    used programmatically or from XML, we still have our filter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`init`方法从每个构造函数中调用，这样如果这个视图是程序化使用或从XML中使用，我们仍然有我们的过滤器。
- en: Running the tests again, we can verify that all have passed, and now everything
    is green again.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试，我们可以验证所有测试都已通过，现在一切又都变绿了。
- en: Viewing our final application
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看我们的最终应用程序
- en: Well done! We now have our final application that satisfies all the requirements.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在我们有了满足所有要求的应用程序。
- en: 'In the following screenshot we are showing one of these requirements, which
    is the detection of an attempt to convert a temperature below the absolute zero
    temperature in Celsius (-1000.00C):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们展示了这些要求中的一个，即检测尝试转换低于摄氏度绝对零温度(-1000.00C)的温度的企图：
- en: '![Viewing our final application](img/00034.jpeg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![查看我们的最终应用程序](img/00034.jpeg)'
- en: The UI respects the guidelines provided; the temperatures can be converted by
    entering them in the corresponding unit field.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: UI遵循提供的指南；可以通过在相应单位字段中输入温度来进行转换。
- en: 'To recap, this is the list of requirements that we have implemented:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，这是我们已实现的需求列表：
- en: The application converts temperatures from Celsius to Fahrenheit, and vice versa
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以在摄氏度和华氏度之间转换温度
- en: The user interface presents two fields to enter the temperatures, one for Celsius
    and the other for Fahrenheit
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面提供了两个输入温度的字段，一个用于摄氏度，另一个用于华氏度
- en: When one temperature is entered in one field, the other one is automatically
    updated with the conversion
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个字段中输入一个温度时，另一个字段会自动更新为转换后的温度
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有错误，应该向用户显示，可能使用相同的字段
- en: Some space in the user interface should be reserved for the on-screen keyboard,
    to ease the application operation when several conversions are entered
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面中应保留一些空间用于屏幕键盘，以便在输入多个转换时简化应用程序的操作
- en: Entry fields should start empty
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段应从空开始
- en: Values entered are decimal values with two digits after the point
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的值是小数点后两位的十进制值
- en: Digits are right aligned
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字右对齐
- en: What is more important is that we can now be certain that the application not
    only satisfies the requirements, but also has no evident problems or bugs. We
    took every step by analyzing the test results, and fixing the problems at their
    first appearance. This will ensure that any individual bug, once discovered, tested
    and fixed, will not resurface again.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们现在可以确信应用程序不仅满足了需求，而且没有明显的问题或错误。我们通过分析测试结果，一步步解决问题，确保任何发现的错误一旦经过测试和修复，就不会再次出现。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We presented Test-driven Development introducing its concepts, and applying
    them step-by-step in a potential real-life problem.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了测试驱动开发，解释了其概念，并在一个潜在的实际问题中逐步应用它们。
- en: We started with a concise list of requirements, describing the temperature converter
    application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简洁的需求列表开始，描述了温度转换应用程序。
- en: We implemented every test followed by the code that satisfies it. In this manner,
    we implemented the application behavior as well as its presentation, conducting
    tests to verify that the UI we designed follows the specifications.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照测试代码的顺序实现了每一个测试，以此满足需求。通过这种方式，我们实现了应用程序的行为及其展示，进行测试以确保我们设计的UI遵循规范。
- en: Having the tests in place, lead us to analyze the different possibilities we
    have in running them. Evolving from the previous chapter, now our continuous integration
    machine can run the tests to guarantee any changes from the team will still result
    in a well-tested application.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了测试，我们分析了运行它们的不同可能性。在上一章的基础上，现在我们的持续集成机器可以运行测试，以确保团队的任何更改仍然会产生一个经过良好测试的应用程序。
- en: The next chapter introduces Behavior-driven Development, and continues our aim
    for bug-free well-tested code, this time with a focus upon behavior and agreement,
    on what a requirement means throughout the team.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍行为驱动开发，并继续我们的目标：无错误的、经过良好测试的代码，这次的重点是行为和团队间的共识，即需求在整个团队中的意义。
