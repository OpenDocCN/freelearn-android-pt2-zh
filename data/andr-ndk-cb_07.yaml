- en: Chapter 7. Other Android NDK API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 其他Android NDK API
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Programming with the jnigraphics library in Android NDK
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK中的jnigraphics库进行编程
- en: Programming with the dynamic linker library in Android NDK
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK中的动态链接库进行编程
- en: Programming with the zlib compression library in Android NDK
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK中的zlib压缩库进行编程
- en: Programming audio with the OpenSL ES audio library in Android NDK
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK中的OpenSL ES音频库进行音频编程
- en: Programming with the OpenMAX AL multimedia library in Android NDK
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android NDK中的OpenMAX AL多媒体库进行编程
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: In the previous three chapters, we have covered Android NDK OpenGL ES API ([Chapter
    4](ch04.html "Chapter 4. Android NDK OpenGL ES API"), *Android NDK OpenGL ES API*),
    Native Application API ([Chapter 5](ch05.html "Chapter 5. Android Native Application
    API"), *Android Native Application API*), and Multithreading API ([Chapter 6](ch06.html
    "Chapter 6. Android NDK Multithreading"), *Android NDK Multithreading*). This
    is the last chapter on Android NDK API illustration, and we will cover a few more
    libraries, including the `jnigraphics` library, dynamic linker library, `zlib`
    compression library, OpenSL ES Audio library, and OpenMAX AL multimedia library.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们已经涵盖了Android NDK OpenGL ES API（[第4章](ch04.html "Chapter 4. Android NDK
    OpenGL ES API")，*Android NDK OpenGL ES API*）、Native Application API（[第5章](ch05.html
    "Chapter 5. Android Native Application API")，*Android Native Application API*）和Multithreading
    API（[第6章](ch06.html "Chapter 6. Android NDK Multithreading")，*Android NDK Multithreading*）。这是关于Android
    NDK API说明的最后一章，我们将介绍更多库，包括`jnigraphics`库、动态链接库、`zlib`压缩库、OpenSL ES音频库和OpenMAX
    AL多媒体库。
- en: We first introduce two small libraries, `jnigraphics` and dynamic linker, which
    only have a few API functions and are easy to use. We then describe `zlib` compression
    library, which can be used to compress and decompress data in `.zlib` and `.gzip`
    formats. The OpenSL ES audio library and OpenMAX AL multimedia library are two
    relatively new APIs available on newer versions of Android. The API functions
    in these two libraries are not frozen yet and still evolving. Because the source
    compatibility is not a goal of the library development on Android, as stated in
    the NDK OpenSL ES and OpenMAX AL documentation, future versions of these two libraries
    may require us to update our code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍两个小型库，`jnigraphics`和动态链接器，它们的API函数较少，易于使用。然后我们描述`zlib`压缩库，该库可用于以`.zlib`和`.gzip`格式压缩和解压数据。OpenSL
    ES音频库和OpenMAX AL多媒体库是两个相对较新的API，在Android的新版本上可用。这两个库中的API函数尚未冻结，仍在发展中。正如NDK OpenSL
    ES和OpenMAX AL文档所述，由于Android上的库开发并不追求源代码兼容性，因此这两个库的未来版本可能需要我们更新代码。
- en: Also, note that OpenSL ES and OpenMAX AL are fairly complex libraries with lots
    of API functions. We can only introduce the basic usage of these two libraries
    with simple examples. Interested readers should refer to the library documentation
    for more details.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，OpenSL ES和OpenMAX AL是相当复杂的库，拥有大量的API函数。我们只能通过简单示例介绍这两个库的基本用法。感兴趣的读者应查阅库文档以获取更多详细信息。
- en: Programming with the jnigraphics library in Android NDK
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android NDK中的jnigraphics库进行编程
- en: The `jnigraphics` library provides a C-based interface for native code to access
    the pixel buffers of Java bitmap objects, which is available as a stable native
    API on Android 2.2 system images and higher. This recipe discusses how to use
    the `jnigraphics` library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`jnigraphics`库提供了一个基于C的接口，使本地代码能够访问Java位图对象的像素缓冲区，该接口在Android 2.2系统映像及更高版本上作为一个稳定的本地API提供。本节讨论如何使用`jnigraphics`库。'
- en: Getting ready…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Readers are expected to know how to create an Android NDK project. We can refer
    to the *Writing a Hello NDK program* recipe of [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK* for detailed instructions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该知道如何创建一个Android NDK项目。我们可以参考[第1章](ch01.html "Chapter 1. Hello NDK")《Hello
    NDK》中的*编写一个Hello NDK程序*一节获取详细说明。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps describe how to create a simple Android application which
    demonstrates the usage of the `jnigraphics` library:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建一个简单的Android应用，该应用演示了`jnigraphics`库的使用方法：
- en: Create an Android application named `JNIGraphics`. Set the package name as `cookbook.chapter7.JNIGraphics`.
    Refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*
    for more detailed instructions.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`JNIGraphics`的Android应用。将包名设置为`cookbook.chapter7.JNIGraphics`。更多详细说明请参考[第2章](ch02.html
    "Chapter 2. Java Native Interface")《Java Native Interface》中的*加载本地库和注册本地方法*一节。
- en: Right-click on the project **JNIGraphics**, select **Android Tools** | **Add
    Native Support**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目**JNIGraphics**，选择**Android Tools** | **Add Native Support**。
- en: Add two Java files named `MainActivity.java` and `RenderView.java` in the `cookbook.chapter7.JNIGraphics`
    package. The `RenderView.java` loads the `JNIGraphics` native library, calls the
    native `naDemoJniGraphics` method to process a bitmap, and finally display the
    bitmap. The `MainActivity.java` files creates a bitmap, passes it to the `RenderView`
    class, and sets the `RenderView` class as its content view.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter7.JNIGraphics`包中添加两个名为`MainActivity.java`和`RenderView.java`的Java文件。`RenderView.java`加载`JNIGraphics`本地库，调用本地`naDemoJniGraphics`方法处理位图，并最终显示位图。`MainActivity.java`文件创建一个位图，将其传递给`RenderView`类，并将`RenderView`类设置为它的内容视图。
- en: 'Add `mylog.h` and `JNIGraphics.cpp` files under the `jni` folder. The `mylog.h`
    contains the Android native `logcat` utility functions, while the `JNIGraphics.cpp`
    file contains the native code to process the bitmap with the `jnigraphics` library
    functions. A part of the code in the `JNIGraphics.cpp` file is shown as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加`mylog.h`和`JNIGraphics.cpp`文件。`mylog.h`包含Android本地`logcat`实用函数，而`JNIGraphics.cpp`文件包含使用`jnigraphics`库函数处理位图的本地代码。`JNIGraphics.cpp`文件中的部分代码如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹中添加一个`Android.mk`文件，内容如下：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build and run the Android project. We can enable code to remove different components
    from the bitmap. The following screenshots show the original picture and the ones
    with red, green, and blue component removed respectively:![How to do it...](img/1505_07_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目。我们可以启用代码从位图中移除不同的组件。以下屏幕截图分别显示了原始图片以及移除了红色、绿色和蓝色组件的图片：![如何操作...](img/1505_07_01.jpg)
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: In our sample project, we modified the bitmap passed to the native `naDemoJniGraphics`
    function by setting one of its RGB components to zero.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们通过将位图传递给本地`naDemoJniGraphics`函数的一个RGB组件设置为0来修改位图。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `jnigraphics` library is only available for Android API level 8 (Android
    2.2, Froyo) and higher.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`jnigraphics`库仅适用于Android API级别8（Android 2.2，Froyo）及更高版本。'
- en: 'The following steps should be followed to use the `jnigraphics` library:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`jnigraphics`库应遵循以下步骤：
- en: Include the `<android/bitmap.h>` header in the source code where we use the
    `jnigraphics` API.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`jnigraphics`API的源代码中包含`<android/bitmap.h>`头文件。
- en: Link to the `jnigraphics` library by including the following line in the `Android.mk`
    file.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Android.mk`文件中包含以下行以链接到`jnigraphics`库。
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the source code, call `AndroidBitmap_getInfo` to retrieve the information
    about a bitmap object. The `AndroidBitmap_getInfo` function has the following
    prototype:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码中，调用`AndroidBitmap_getInfo`函数来获取关于位图对象的信息。`AndroidBitmap_getInfo`函数具有以下原型：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function accepts a pointer to the `JNIEnv` structure, a reference to the
    bitmap object, and a pointer to the `AndroidBitmapInfo` structure. If the call
    is successful, the data structure pointed by `info` will be filled.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数接受指向`JNIEnv`结构的指针、位图对象的引用以及指向`AndroidBitmapInfo`结构的指针。如果调用成功，`info`指向的数据结构将被填充。
- en: 'The `AndroidBitmapInfo` is defined as follows:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AndroidBitmapInfo`的定义如下：'
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`width` and `height` indicate the pixel width and height of the bitmap. `stride`
    refers to the number of bytes to skip between rows of the pixel buffer. The number
    must be no less than the width in bytes. In most cases, `stride` is the same as
    `width`. However, sometimes pixel buffer contains paddings so stride can be bigger
    than bitmap `width`.'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`width`和`height`表示位图的像素宽度和高度。`stride`指的是像素缓冲区行之间跳过的字节数。该数字不得小于宽度字节。在大多数情况下，`stride`与`width`相同。然而，有时像素缓冲区包含填充，所以`stride`可能比位图`width`大。'
- en: The `format` is the color format, which can be `ANDROID_BITMAP_FORMAT_RGBA_8888`,
    `ANDROID_BITMAP_FORMAT_RGB_565`, `ANDROID_BITMAP_FORMAT_RGBA_4444`, `ANDROID_BITMAP_FORMAT_A_8`,
    or `ANDROID_BITMAP_FORMAT_NONE` as defined in the `bitmap.h` header file.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`format`是颜色格式，可以是`bitmap.h`头文件中定义的`ANDROID_BITMAP_FORMAT_RGBA_8888`、`ANDROID_BITMAP_FORMAT_RGB_565`、`ANDROID_BITMAP_FORMAT_RGBA_4444`、`ANDROID_BITMAP_FORMAT_A_8`或`ANDROID_BITMAP_FORMAT_NONE`。'
- en: In our example, we used `ANDROID_BITMAP_FORMAT_RGBA_8888` as the bitmap format.
    Therefore, every pixel takes 4 bytes.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`ANDROID_BITMAP_FORMAT_RGBA_8888`作为位图格式。因此，每个像素占用4个字节。
- en: 'Lock the pixel address by calling the `AndroidBitmap_lockPixels` function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`AndroidBitmap_lockPixels`函数锁定像素地址：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the call succeeds, the `*addrPtr` pointer will point to the pixels of the
    bitmap. Once the pixel address is locked, the memory for the pixels will not move
    until the pixel address is unlocked.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果调用成功，`*addrPtr` 指针将指向位图的像素。一旦像素地址被锁定，在像素地址被解锁之前，像素的内存不会移动。
- en: Manipulate the pixel buffer in the native code.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地代码中操作像素缓冲区。
- en: 'Unlock the pixel address by calling `AndroidBitmap_unlockPixels`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `AndroidBitmap_unlockPixels` 来解锁像素地址：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this function must be called if the `AndroidBitmap_lockPixels` function
    succeeds.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，如果 `AndroidBitmap_lockPixels` 函数调用成功，则必须调用此函数。
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `jnigraphics` functions return `ANDROID_BITMAP_RESUT_SUCCESS`, which has
    a value of `0`, upon success. They return a negative value upon failure.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jnigraphics` 函数在成功时返回 `ANDROID_BITMAP_RESUT_SUCCESS`，其值为 `0`。失败时返回负值。'
- en: There's more…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Recall that we used the `jnigraphics` library to load textures in the *Mapping
    texture to 3D objects with OpenGL ES 1.x API* recipe in [Chapter 4](ch04.html
    "Chapter 4. Android NDK OpenGL ES API"), *Android NDK OpenGL ES API*. We can revisit
    the recipe for another example of how we use the `jnigraphics` library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在[第4章](ch04.html "第4章. Android NDK OpenGL ES API")，*Android NDK OpenGL ES
    API* 的*使用OpenGL ES 1.x API将纹理映射到3D对象*示例中使用了 `jnigraphics` 库来加载纹理。我们可以重新访问该示例，了解我们如何使用
    `jnigraphics` 库的另一个例子。
- en: Programming with the dynamic linker library in Android NDK
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android NDK中使用动态链接库进行编程
- en: Dynamic loading is a technique to load a library into memory at runtime, and
    execute functions or access variables defined in the library. It allows the app
    to start without these libraries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 动态加载是一种在运行时将库加载到内存中，并执行库中定义的函数或访问变量的技术。它允许应用程序在没有这些库的情况下启动。
- en: We have seen dynamic loading in almost every recipe of this book. When we call
    the `System.loadLibrary` or `System.load` function to load the native libraries,
    we are using dynamic loading.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的几乎每个示例中，我们都看到了动态加载。当我们调用 `System.loadLibrary` 或 `System.load` 函数来加载本地库时，我们就是在使用动态加载。
- en: Android NDK has provided the dynamic linker library to support dynamic loading
    in NDK, since Android 1.5\. This recipe discusses the dynamic linker library functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Android 1.5起，Android NDK就提供了动态链接库以支持NDK中的动态加载。本示例讨论动态链接库函数。
- en: Getting ready...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Readers are expected to know how to create an Android NDK project. You can refer
    to the *Writing a Hello NDK program* recipe of [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK* for detailed instructions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 期望读者知道如何创建一个Android NDK项目。你可以参考[第1章](ch01.html "第1章. Hello NDK")的*编写一个Hello
    NDK程序*示例，*Hello NDK* 以获取详细说明。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps describe how to create an Android application using the
    dynamic linking library to load the math library and compute the square root of
    2.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何使用动态链接库创建一个Android应用程序，以加载数学库并计算2的平方根。
- en: Create an Android application named `DynamicLinker`. Set the package name as
    `cookbook.chapter7.dynamiclinker`. Refer to the *Loading native libraries and
    registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java Native
    Interface"), *Java Native Interface* for more detailed instructions.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DynamicLinker` 的Android应用程序。将包名设置为 `cookbook.chapter7.dynamiclinker`。更多详细说明请参考[第2章](ch02.html
    "第2章. Java Native Interface")，*Java Native Interface* 的*加载本地库和注册本地方法*示例。
- en: Right-click on the `DynamicLinker` project, select **Android Tools** | **Add
    Native Support**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `DynamicLinker` 项目，选择 **Android Tools** | **Add Native Support**。
- en: Add a Java file named `MainActivity.java` under the `cookbook.chapter7.dynamiclinker`
    package. This Java file simply loads the native `DynamicLinker` library and calls
    the native `naDLDemo` method.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cookbook.chapter7.dynamiclinker` 包下添加一个名为 `MainActivity.java` 的Java文件。这个Java文件简单加载了本地
    `DynamicLinker` 库，并调用了本地 `naDLDemo` 方法。
- en: Add the `mylog.h` and `DynamicLinker.cpp` files under the `jni` folder. A part
    of the code in the `OpenSLESDemo.cpp` file is shown in the following code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加 `mylog.h` 和 `DynamicLinker.cpp` 文件。`OpenSLESDemo.cpp` 文件中的一部分代码在以下代码中显示。
- en: '`naDLDemo` loads the `libm.so` library, obtains the address of the `sqrt` function
    and calls the function with input argument `2.0`:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`naDLDemo` 加载了 `libm.so` 库，获取了 `sqrt` 函数的地址，并以输入参数 `2.0` 调用该函数：'
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加一个 `Android.mk` 文件，内容如下：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目，使用以下命令监控 `logcat` 输出：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A screenshot of the `logcat` output is shown as follows:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`logcat`输出的屏幕截图如下所示：'
- en: '![How to do it...](img/1505_07_05.jpg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_07_05.jpg)'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'In order to build with dynamic loading library `libdl.so`, we must add the
    following line to the `Android.mk` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用动态加载库`libdl.so`进行构建，我们必须在`Android.mk`文件中添加以下行：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following functions are defined in the `dlfcn.h` header file by the Android
    dynamic linking library:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数在`dlfcn.h`头文件中由Android动态链接库定义：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `dlopen` function loads the library dynamically. The first argument indicates
    the library name, while the second argument refers to the loading mode, which
    describes how `dlopen` resolves the undefined symbols. When an object file (for
    example, shared library, executable file, and so on) is loaded, it may contain
    references to symbols whose addresses are not known until another object file
    is loaded (such symbols are referred to as undefined symbols). These references
    need to be resolved before they can be used to access the symbols. The following
    two modes determine when the resolving happens:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlopen`函数动态加载库。第一个参数指示库名称，而第二个参数指的是加载模式，描述了`dlopen`如何解析未定义的符号。当一个对象文件（例如共享库、可执行文件等）被加载时，它可能包含对符号的引用，这些符号的地址在另一个对象文件被加载之前是未知的（这类符号被称为未定义符号）。在使用这些引用访问符号之前，需要解析这些引用。以下两种模式决定了解析何时发生：'
- en: '`RTLD_NOW`: When the object file is loaded, the undefined symbols are resolved.
    This means the resolving occurs before the `dlopen` function returns. This may
    be a waste if resolving is performed but the references are never accessed.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTLD_NOW`：当对象文件被加载时，未定义的符号将被解析。这意味着解析在`dlopen`函数返回之前发生。如果执行了解析但从未访问过引用，这可能是浪费。'
- en: '`RTLD_LAZY`: The resolving can be performed after the `dlopen` function returns,
    that is, the undefined symbols are resolved when the code is executed.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTLD_LAZY`：解析可以在`dlopen`函数返回后执行，即当代码执行时解析未定义的符号。'
- en: 'The following two modes determine the visibility of the symbols in the loaded
    object. They can be ORed with the previously mentioned two modes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种模式决定了已加载对象中符号的可见性。它们可以与前面提到的两种模式进行OR运算：
- en: '`RTLD_LOCAL`: The symbols will not be available for another object'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTLD_LOCAL`：符号对另一个对象不可用'
- en: '`RTLD_GLOBAL`: The symbols will be available for subsequently loaded objects'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTLD_GLOBAL`：符号将对随后加载的对象可用'
- en: The `dlopen` function returns a handle upon success. The handle should be used
    for the subsequent calls to `dlsym` and `dlclose`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlopen`函数在成功时返回一个句柄。该句柄应用于后续对`dlsym`和`dlclose`的调用。'
- en: The `dlclose` function simply decrements the reference count of the loaded library
    handle. If the reference count is reduced to zero, the library will be unloaded.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlclose`函数只是减少了加载库句柄的引用计数。如果引用计数减少到零，将卸载库。'
- en: The `dlerror` function returns a string to describe the most recent error occurred
    while calling `dlopen`, `dlsym`, or `dlclose` since the last call to `dlerror`.
    It returns `NULL` if no such error occurred.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlerror`函数返回一个字符串，以描述自上次调用`dlerror`以来在调用`dlopen`、`dlsym`或`dlclose`时发生的最新错误。如果没有发生此类错误，它将返回`NULL`。'
- en: The `dlsym` function returns the memory address of a given symbol of the loaded
    dynamic library referred by the input argument handle. The returned address can
    be used to access the symbol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlsym`函数返回输入参数句柄所引用的已加载动态库中给定符号的内存地址。返回的地址可以用来访问该符号。'
- en: 'The `dladdr` function takes an address and tries to return more information
    about the address and library through the `info` argument of the `DI_info` type.
    The `DI_info` data structure is defined as shown in the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`dladdr`函数接收一个地址，并尝试通过`DI_info`类型的`info`参数返回有关该地址和库的更多信息。`DI_info`数据结构定义如下代码片段所示：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`dli_fname` indicates the path of the shared object referred by the input argument
    `addr`. The `dli_fbase` is the address where the shared object is loaded. `dli_sname`
    indicates the name of the nearest symbol with address lower than `addr`, and `dli_saddr`
    is the address of symbol named by `dli_sname`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`dli_fname`表示输入参数`addr`引用的共享对象的路径。`dli_fbase`是共享对象加载的地址。`dli_sname`表示地址低于`addr`的最近符号的名称，而`dli_saddr`是名为`dli_sname`的符号的地址。'
- en: In our example, we demonstrated the usage of the first four functions. We load
    the math library by `dlopen`, obtain the address of the `sqrt` function by `dlsym`,
    check the error by `dlerror`, and close the library by `dlclose`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们演示了前四个函数的用法。我们通过 `dlopen` 加载数学库，通过 `dlsym` 获取 `sqrt` 函数的地址，通过 `dlerror`
    检查错误，并通过 `dlclose` 关闭库。
- en: For more details on the dynamic loading library, refer to [http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html](http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html)
    and [http://linux.die.net/man/3/dlopen](http://linux.die.net/man/3/dlopen).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关动态加载库的更多详细信息，请参考 [http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html](http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html)
    和 [http://linux.die.net/man/3/dlopen](http://linux.die.net/man/3/dlopen)。
- en: Programming with the zlib compression library in Android NDK
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android NDK 中使用 zlib 压缩库进行编程
- en: '`zlib` is a widely-used, lossless data compression library, which is available
    for Android 1.5 system images or higher. This recipe discusses the basic usage
    of the `zlib` functions.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`zlib` 是一个广泛使用的、无损的数据压缩库，适用于 Android 1.5 系统镜像或更高版本。本食谱讨论了 `zlib` 函数的基本用法。'
- en: Getting ready...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中...
- en: Readers are expected to know how to create an Android NDK project. We can refer
    to the *Writing a Hello NDK program* recipe of [Chapter 1](ch01.html "Chapter 1. Hello
    NDK"), *Hello NDK* for detailed instructions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 期望读者知道如何创建一个 Android NDK 项目。我们可以参考 [第1章](ch01.html "第1章. Hello NDK") 的 *编写一个
    Hello NDK 程序* 食谱，*Hello NDK* 以获取详细说明。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to create a simple Android application which
    demonstrates the usage of `zlib` library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建一个简单的 Android 应用程序，该程序演示了 `zlib` 库的用法：
- en: Create an Android application named `ZlibDemo`. Set the package name as `cookbook.chapter7.zlibdemo`.
    Refer to the *Loading native libraries and registering native methods* recipe
    of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*
    for more detailed instructions.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ZlibDemo` 的 Android 应用程序。将包名设置为 `cookbook.chapter7.zlibdemo`。有关更详细的说明，请参考
    [第2章](ch02.html "第2章. Java Native Interface") 的 *加载本地库和注册本地方法* 食谱，*Java Native
    Interface*。
- en: Right-click on the project **ZlibDemo**, select **Android Tools** | **Add Native
    Support**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目 **ZlibDemo** 上右键点击，选择 **Android Tools** | **添加本地支持**。
- en: Add a Java file named `MainActivity.java` in the `cookbook.chapter7.zlibdemo`
    package. The `MainActivity.java` file loads the `ZlibDemo` native library, and
    calls the native methods.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cookbook.chapter7.zlibdemo` 包中添加一个名为 `MainActivity.java` 的 Java 文件。`MainActivity.java`
    文件加载 `ZlibDemo` 本地库，并调用本地方法。
- en: Add `mylog.h`, `ZlibDemo.cpp`, and `GzFileDemo.cpp` files under the `jni` folder.
    The `mylog.h` header file contains the Android native `logcat` utility functions,
    while `ZlibDemo.cpp` and `GzFileDemo.cpp` files contain code for compression and
    decompression. A part of the code in `ZlibDemo.cpp` and `GzFileDemo.cpp` is shown
    in the following code.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加 `mylog.h`、`ZlibDemo.cpp` 和 `GzFileDemo.cpp` 文件。`mylog.h` 头文件包含了
    Android 本地的 `logcat` 实用功能函数，而 `ZlibDemo.cpp` 和 `GzFileDemo.cpp` 文件包含了压缩和解压缩的代码。`ZlibDemo.cpp`
    和 `GzFileDemo.cpp` 的一部分代码在以下代码中展示。
- en: '`ZlibDemo.cpp` contains the native code to compress and decompress data in
    memory.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ZlibDemo.cpp` 包含了在内存中压缩和解压缩数据的本地代码。'
- en: '`compressUtil` compresses and decompress data in memory.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`compressUtil` 在内存中压缩和解压缩数据。'
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`naCompressAndDecompress` generates data for compression and calls the `compressUtil`
    function to compress and decompress the generated data:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`naCompressAndDecompress` 生成压缩数据并调用 `compressUtil` 函数来压缩和解压缩生成的数据：'
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`GzFileDemo.cpp` contains the native code to compress and decompress the data
    in file.'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GzFileDemo.cpp` 包含了本地代码，用于压缩和解压缩文件中的数据。'
- en: '`writeToFile` writes a string to a `gzip` file. Compression is applied at writing:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`writeToFile` 函数将字符串写入到 `gzip` 文件中。在写入时会应用压缩：'
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`readFromFile` reads data from the `gzip` file. Decompression is applied at
    reading:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`readFromFile` 从 `gzip` 文件中读取数据。在读取时会应用解压缩：'
- en: '[PRE16]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add an `Android.mk` file under the `jni` folder with the following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加一个 `Android.mk` 文件，内容如下：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Enable the `naCompressAndDecompress` function and disable the `naGzFileDemo`
    function, build and run the application. We can monitor the `logcat` output with
    the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 `naCompressAndDecompress` 函数并禁用 `naGzFileDemo` 函数，构建并运行应用程序。我们可以使用以下命令监控
    `logcat` 输出：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `logcat` output screenshot is shown as follows:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`logcat` 输出的屏幕截图如下所示：'
- en: '![How to do it...](img/1505_07_06.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_07_06.jpg)'
- en: 'Enable the `naGzFileDemo` function and disable the `naCompressAndDecompress`
    function, build and run the application. The `logcat` output is shown in the following
    screenshot:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用 `naGzFileDemo` 函数并禁用 `naCompressAndDecompress` 函数，构建并运行应用程序。`logcat` 输出在以下屏幕截图中显示：
- en: '![How to do it...](img/1505_07_07.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_07_07.jpg)'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `zlib` library provides compression and decompression functions for both
    in-memory data and files. We demonstrated both use cases. In the `ZlibDemo.cpp`
    file, we created two data buffers, one with repeated bytes, and the other with
    random bytes. We compress and decompress the data with the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`zlib` 库为内存数据和文件提供压缩和解压缩功能。我们演示了这两种用例。在 `ZlibDemo.cpp` 文件中，我们创建了两个数据缓冲区，一个包含重复的字节，另一个包含随机的字节。我们按照以下步骤压缩和解压缩数据：'
- en: 'Compute the upper bound on the compressed size. This is done by the following
    function:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算压缩后大小的上限。这是通过以下函数完成的：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function returns the maximum size of the compressed data after calling the
    `compress` or `compress2` function on `sourceLen` bytes of source data.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数返回在 `sourceLen` 字节的源数据上调用 `compress` 或 `compress2` 函数后压缩数据的最大大小。
- en: Allocate the memory for storing the compressed data.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为存储压缩数据分配内存。
- en: 'Compress the data. This is done by the following function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩数据。这是通过以下函数完成的：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function accepts five input arguments. `source` and `sourceLen` refer to
    the source data buffer and source data length. `dest` and `destLen` indicate the
    data buffer for storing the compressed data and size of this buffer. The value
    of `destLen` must be at least the value returned by `compressBound` when the function
    is called. When the function is returned, `destLen` is set to the actual size
    of the compressed data. The last input argument `level` can be a value between
    0 and 9, where 1 gives best speed and 9 gives best compression. In our example,
    we set the value as 6 to compromise between speed and compression.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数接受五个输入参数。`source` 和 `sourceLen` 指的是源数据缓冲区和源数据长度。`dest` 和 `destLen` 指示用于存储压缩数据的数据缓冲区和这个缓冲区的大小。`destLen`
    的值必须在调用函数时至少为 `compressBound` 返回的值。当函数返回时，`destLen` 被设置为压缩数据的实际大小。最后一个输入参数 `level`
    可以在0到9之间取值，其中1表示最快的速度，9表示最佳的压缩率。在我们的示例中，我们将其值设置为6，以在速度和压缩之间取得平衡。
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also use the compress function to compress the data, which does not have
    the level input argument. Instead, it assumes a default level, which is equivalent
    to 6.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以使用压缩函数来压缩数据，该函数没有级别输入参数。相反，它假设一个默认级别，相当于6。
- en: 'Decompress the data. This is done by using the `uncompress` function:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩数据。这是通过使用 `uncompress` 函数完成的：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The input arguments have the same meaning as the `compress2` function.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入参数与 `compress2` 函数的含义相同。
- en: Compare the decompressed data with the original data. This is just a simple
    check.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解压缩的数据与原始数据比较。这只是简单的检查。
- en: By default, these functions use the `zlib` format for the compressed data.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，这些函数使用 `zlib` 格式来处理压缩数据。
- en: This library also supports reading and writing files in the `gzip` format. This
    is demonstrated in `GzFileDemo.cpp`. The usage of these functions is similar to
    the `stdio` functions for file reading and writing.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个库还支持以 `gzip` 格式读写文件。这在 `GzFileDemo.cpp` 中有演示。这些函数的使用类似于 `stdio` 文件读写函数。
- en: 'The steps we followed to write compressed data to a `gzip` file and then read
    the uncompressed data from it are shown as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循的步骤将压缩数据写入 `gzip` 文件，然后从中读取未压缩数据，如下所示：
- en: 'Open a `gzip` file for writing. This is done by the following function:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 `gzip` 文件以供写入。这是通过以下函数完成的：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function accepts a filename and open mode, and returns a `gzFile` object
    on success. The mode is similar to the `fopen` function, but with an optional
    compression level. In our example, we called the `gzopen` with `w6` to specify
    the compression level as 6.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数接受一个文件名和打开模式，并在成功时返回一个 `gzFile` 对象。该模式类似于 `fopen` 函数，但有一个可选的压缩级别。在我们的示例中，我们用
    `w6` 调用 `gzopen` 以指定压缩级别为6。
- en: 'Write data to a `gzip` file. This is done by the following function:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据写入 `gzip` 文件。这是通过以下函数完成的：
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function writes uncompressed data into the compressed file. The input argument
    `file` refers to the compressed file, `buf` refers to the uncompressed data buffer,
    and `len` indicates the number of bytes to write. The function returns the actual
    number of uncompressed data written.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将未压缩数据写入压缩文件中。输入参数`file`指的是压缩文件，`buf`指的是未压缩数据缓冲区，而`len`表示要写入的字节数。函数返回实际写入的未压缩数据数量。
- en: 'Close the `gzip` file. This is done by the following function:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`gzip`文件。这是通过以下函数完成的：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Calling this function will flush all pending output and close the compressed
    file.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用此函数将刷新所有挂起的输出并关闭压缩文件。
- en: Open the file for reading. We passed `r6` to the `gzopen` function.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件以供读取。我们向`gzopen`函数传递了`r6`。
- en: Read data from the compressed file. This is done by the `gzread` function.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从压缩文件中读取数据。这是通过`gzread`函数完成的。
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function reads `len` number of bytes from file into `buf`. It returns the
    actual number of bytes read.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数从文件中读取`len`个字节到`buf`中。它返回实际读取的字节数。
- en: Note
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `zlib` library supports two compression formats, `zlib` and `gzip`. `zlib`
    is designed to be compact and fast, so it is best for use in memory and on communication
    channels. On the other hand, `gzip` is designed for single file compression on
    a filesystem, which has a larger header for maintaining the directory information,
    and uses a slower check method than `zlib`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`zlib`库支持两种压缩格式，`zlib`和`gzip`。`zlib`旨在紧凑且快速，因此最适合在内存和通信通道中使用。另一方面，`gzip`专为文件系统上的单个文件压缩设计，它有一个更大的头部来维护目录信息，并且比`zlib`使用更慢的校验方法。'
- en: 'In order to use the `zlib` library, we must include the `zlib.h` header file
    in our source code and add the following line to `Android.mk` to link to the `libz.so`
    library:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`zlib`库，我们必须在源代码中包含`zlib.h`头文件，并在`Android.mk`中添加以下行以链接到`libz.so`库：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Recall in the *Managing assets at Android NDK* recipe in [Chapter 5](ch05.html
    "Chapter 5. Android Native Application API"), *Android Native Application AP*
    , we compiled the `libpng` library, which requires the `zlib` library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第5章](ch05.html "第5章. Android Native Application API")中的*管理Android NDK的资产*一节，*Android
    Native Application API*，我们编译了`libpng`库，它需要`zlib`库。
- en: We only covered a few functions provided by the `zlib` library. For more information,
    you can refer to the `zlib.h` and `zconf.h` header files in the `platforms/android-<version>/arch-arm/usr/include/`
    folder. Detailed documentation for the `zlib` library can be found at [http://www.zlib.net/manual.html](http://www.zlib.net/manual.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只介绍了`zlib`库提供的一些函数。更多信息，您可以参考`platforms/android-<version>/arch-arm/usr/include/`文件夹中的`zlib.h`和`zconf.h`头文件。`zlib`库的详细文档可以在[http://www.zlib.net/manual.html](http://www.zlib.net/manual.html)找到。
- en: Programming audio with the OpenSL ES audio library in Android NDK
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android NDK中的OpenSL ES音频库进行音频编程
- en: OpenSL ES is an application level audio library in C. Android NDK native audio
    APIs are based on the OpenSL ES 1.0.1 standard with Android specific extensions.
    The API is available for Android 2.3 or higher and some features are only supported
    on Android 4.0 or higher. The API functions in this libraries are not frozen yet
    and are still evolving. Future versions of this library may require us to update
    our code. This recipe introduces OpenSL ES APIs in the context of Android.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES是一个C语言级别的应用程序音频库。Android NDK原生音频API基于OpenSL ES 1.0.1标准，并带有Android特定的扩展。该API适用于Android
    2.3或更高版本，某些功能仅在Android 4.0或更高版本上支持。此库中的API函数尚未冻结，仍在发展中。此库的未来版本可能需要我们更新代码。本节在Android环境下介绍OpenSL
    ES API。
- en: Getting ready...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Before we start coding with OpenSL ES, it is essential to understand some basics
    of the library. OpenSL ES stands for **Open Sound Library** for embedded systems,
    which is a cross-platform, royalty-free, C language application level API for
    developers to access audio functionalities of embedded systems. The library specification
    defines features like audio playback and recording, audio effects and controls,
    2D and 3D audio, advanced MIDI, and so on. Based on the features supported, OpenSL
    ES defines three profiles, including phone, music, and game.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用OpenSL ES编码之前，了解这个库的一些基本知识是至关重要的。OpenSL ES代表嵌入式系统的**开放声音库**，它是一个跨平台、免版税、使用C语言的应用程序级别API，供开发者访问嵌入式系统的音频功能。该库规范定义了如音频播放和录制、音频效果和控制、2D和3D音频、高级MIDI等功能。根据支持的功能，OpenSL
    ES定义了三个配置文件，包括电话、音乐和游戏。
- en: However, the Android native audio API does not conform to any of the three profiles,
    because it does not implement all features from any of the profiles. In addition,
    Android implements some features specific to Android, such as the Android buffer
    queue. For a detailed description of what is supported on Android, we can refer
    to the OpenSL ES for Android documentation available with Android NDK under the
    `docs/opensles/` folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Android原生音频API并不符合这三个配置文件中的任何一个，因为它没有实现任何配置文件中的所有功能。此外，Android实现了一些特定于Android的功能，例如Android缓冲队列。关于在Android上支持的功能的详细描述，我们可以参考随Android
    NDK提供的`docs/opensles/`文件夹下的OpenSL ES for Android文档。
- en: 'Although OpenSL ES API is implemented in C, it adopts an object-oriented approach
    by building the library based on objects and interfaces:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OpenSL ES API是用C语言实现的，但它通过基于对象和接口构建库，采用了面向对象的方法：
- en: '**Object**: An object is an abstraction of a set of resources and their states.
    Every object has a type assigned at its creation, and the type determines the
    set of tasks the object can perform. It is similar to the class concept in C++.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：对象是一组资源和它们状态的抽象。每个对象在创建时都会分配一个类型，而类型决定了对象可以执行的任务集合。这类似于C++中的类概念。'
- en: '**Interface**: An interface is an abstraction of a set of features an object
    can provide. These features are exposed to us as a set of methods and the type
    of each interface determines the exact set of features exposed. In the code, the
    type of an interface is identified by the interface ID.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：接口是一组对象可以提供的特性的抽象。这些特性以一组方法和每种接口类型的精确特性集合的形式暴露给我们。在代码中，接口类型通过接口ID来识别。'
- en: 'It is important to note that an object does not have actual representation
    in code. We change the object''s states and access its features through interfaces.
    An object can have one or more interface instances. However, no two instances
    of a single object can be the same type. In addition, a given interface instance
    can only belong to one object. This relationship can be illustrated as shown in
    the following diagram:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，对象在代码中没有实际的表现形式。我们通过接口改变对象的状态和访问其特性。一个对象可以有一个或多个接口实例。然而，一个单一对象的两个实例不能是同一类型。此外，给定的接口实例只能属于一个对象。这种关系可以如下所示的关系图进行说明：
- en: '![Getting ready...](img/1505_07_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪...](img/1505_07_11.jpg)'
- en: As shown in the diagram, Object 1 and Object 2 have different types and therefore
    expose different interfaces. Object 1 has three interface instances, all with
    different types. While Object 2 has another two interface instances with different
    types. Note that Interface 2 of Object 1 and Interface 4 of Object 2 have the
    same type, which means both Object 1 and Object 2 support the features exposed
    through interfaces of Interface Type B.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，对象1和对象2具有不同的类型，因此暴露了不同的接口。对象1有三个接口实例，所有实例类型都不同。而对象2有另外两个不同类型的接口实例。注意对象1的接口2和对象2的接口4具有相同的类型，这意味着对象1和对象2都支持通过Interface
    Type B的接口暴露的特性。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to create a simple Android application using
    the native audio library to record and play audio:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何使用原生音频库创建一个简单的Android应用程序以录制和播放音频：
- en: Create an Android application named `OpenSLESDemo`. Set the package name as
    `cookbook.chapter7.opensles`. Refer to the *Loading native libraries and registering
    native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java Native Interface"),
    *Java Native Interface* for more detailed instructions.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`OpenSLESDemo`的Android应用程序。将包名设置为`cookbook.chapter7.opensles`。更多详细说明请参考[第2章](ch02.html
    "第2章. Java Native Interface")的*加载本地库和注册本地方法*部分，*Java Native Interface*。
- en: Right-click on the project **OpenSLESDemo**, select **Android Tools** | **Add
    Native Support**.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目**OpenSLESDemo**，选择**Android Tools** | **Add Native Support**。
- en: Add a Java file named `MainActivity.java` in the `cookbook.chapter7.opensles`
    package. This Java file simply loads the native library `OpenSLESDemo` and calls
    the native methods to record and play audio.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter7.opensles`包中添加一个名为`MainActivity.java`的Java文件。这个Java文件仅加载本地库`OpenSLESDemo`，并调用本地方法来录制和播放音频。
- en: Add `mylog.h`, `common.h`, `play.c`, `record.c`, and `OpenSLESDemo.cpp` files
    in the `jni` folder. A part of the code in the `play.c`, `record.c`, and `OpenSLESDemo.cpp`
    files is shown in the following code snippet.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹中添加`mylog.h`、`common.h`、`play.c`、`record.c`和`OpenSLESDemo.cpp`文件。`play.c`、`record.c`和`OpenSLESDemo.cpp`文件中的一部分代码在以下代码片段中展示。
- en: '`record.c` contains the code to create an audio recorder object and record
    the audio.'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`record.c`包含创建音频录音器对象并录制音频的代码。'
- en: '`createAudioRecorder` creates and realizes an audio player object and obtains
    the record and buffer queue interfaces:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`createAudioRecorder`创建并实现一个音频播放器对象，并获得录音和缓冲队列接口：'
- en: '[PRE27]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`startRecording` enqueues the buffer to store the recording audio and set the
    audio object state as recording:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`startRecording`将缓冲区入队以存储录音音频，并将音频对象状态设置为录音状态：'
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Every time the buffer queue is ready to accept a new data block, the `bqRecorderCallback`
    callback method is invoked. This happens when a buffer is filled with audio data:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当缓冲队列准备好接受新的数据块时，就会调用`bqRecorderCallback`回调方法。这发生在缓冲区填满音频数据时：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`play.c` contains the code to create an audio player object and play the audio.'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`play.c`包含创建音频播放器对象并播放音频的代码。'
- en: '`createBufferQueueAudioPlayer` creates and realizes an audio player object
    which plays audio from the buffer queue:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`createBufferQueueAudioPlayer`创建并实现一个从缓冲队列播放音频的音频播放器对象：'
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`startPlaying` fills the buffer with data from the `test.cpm` file and starts
    playing:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`startPlaying`从`test.cpm`文件填充缓冲区数据并开始播放：'
- en: '[PRE31]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`bqPlayerCallback` every time the buffer queue is ready to accept a new buffer,
    this callback method is invoked. This happens when a buffer has finished playing:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`bqPlayerCallback`每次缓冲队列准备好接受新的缓冲区时，都会调用这个回调方法。这发生在缓冲区播放完毕时：'
- en: '[PRE32]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`OpenSLESDemo.cpp` contains the code to create the OpenSL ES engine object,
    free the objects, and register the native methods:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OpenSLESDemo.cpp`文件包含创建OpenSL ES引擎对象、释放对象以及注册本地方法的代码：'
- en: '`naCreateEngine` creates the engine object and outputs the mix object.'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`naCreateEngine`创建引擎对象并输出混合对象。'
- en: '[PRE33]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Add the following permissions to the `AndroidManifest.xml` file.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加以下权限。
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹中添加一个`Android.mk`文件，内容如下：
- en: '[PRE35]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Build and run the Android project, and use the following command to monitor
    the `logcat` output:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Android项目，并使用以下命令监控`logcat`输出：
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The application GUI is shown in the following screenshot:![How to do it...](img/1505_07_08.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用的GUI如下截图所示：![如何操作...](img/1505_07_08.jpg)
- en: We can start the audio recording by clicking on the **Record** button. The recording
    will last for 15 seconds. The `logcat` output will be as shown in the following
    screenshot:![How to do it...](img/1505_07_09.jpg)
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过点击**录音**按钮开始音频录音。录音将持续15秒。`logcat`输出将如下截图所示：![如何操作...](img/1505_07_09.jpg)
- en: 'Once the recording is finished. There will be a `/sdcard/test.pcm` file created
    at the Android device. We can click on the **Play** button to play the audio file.
    The `logcat` output will be as shown in the following screenshot:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录音完成后，将在Android设备上创建一个`/sdcard/test.pcm`文件。我们可以点击**播放**按钮来播放音频文件。`logcat`输出将如下截图所示：
- en: '![How to do it...](img/1505_07_10.jpg)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1505_07_10.jpg)'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This sample project demonstrates how to use OpenSL ES Audio library. We will
    first explain some key concepts and then describe how we used the recording and
    playback API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例项目展示了如何使用OpenSL ES音频库。我们首先解释一些关键概念，然后描述我们是如何使用录音和播放API的。
- en: Object creation
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象创建
- en: 'An object does not have an actual representation in code and the creation of
    an object is done through interface. Every method which creates an object returns
    a `SLObjectInf` interface, which can be used to perform the basic operations on
    the object and access other interfaces of the object. The steps for object creation
    is described as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在代码中没有实际的表现形式，对象的创建是通过接口完成的。每个创建对象的方法都返回一个`SLObjectInf`接口，该接口可用于执行对象的基本操作并访问对象的其它接口。对象创建的步骤如下所述：
- en: Create an engine object. The engine object is the entry point of OpenSL ES API.
    Creating an engine object is done with the global function `slCreateEngine()`,
    which returns a `SLObjectItf` interface.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个引擎对象。引擎对象是OpenSL ES API的入口点。创建引擎对象是通过全局函数`slCreateEngine()`完成的，该函数返回一个`SLObjectItf`接口。
- en: Realize the engine object. An object cannot be used until it is realized. We
    will discuss this in detail in the following section.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现引擎对象。在对象被实现之前，不能使用该对象。我们将在下一节详细讨论这一点。
- en: Obtain the `SLEngineItf` interface of the engine object through the `GetInterface()`
    method of the `SLObjectItf` interface.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`SLObjectItf`接口的`GetInterface()`方法获取引擎对象的`SLEngineItf`接口。
- en: Call the object creation method provided by the `SLEngineItf` interface. A `SLObjectItf`
    interface of the newly created object is returned upon success.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`SLEngineItf`接口提供的对象创建方法。成功后，将返回新创建对象的`SLObjectItf`接口。
- en: Realize the newly created object.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现新创建的对象。
- en: Manipulate the created objects or access other interfaces through the `SLObjectItf`
    interface of the object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对象的`SLObjectItf`接口操作创建的对象或访问其他接口。
- en: After you are done with the object, call the `Destroy()` method of the `SLObjectItf`
    interface to free the object and its resources.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成对象操作后，调用`SLObjectItf`接口的`Destroy()`方法来释放对象及其资源。
- en: In our sample project, we created and realized the engine object, and obtained
    the `SLEngineItf` interface at the `naCreateEngine` function of `OpenSLESDemo.cpp`.
    We then called the `CreateAudioRecorder()` method, exposed by the `SLEngineItf`
    interface, to create an audio recorder object at `createAudioRecorder` function
    of `record.c`. In the same function, we also realized the audio recorder object
    and accessed a few other interfaces of the object through the `SLObjectItf` interface
    returned at object creation. After we are finished with the recorder object, we
    called the `Destroy()` method to free the object and its resources, as shown in
    the `naShutdown` function of `OpenSLESDemo.cpp`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们在`OpenSLESDemo.cpp`的`naCreateEngine`函数中创建了并实现了引擎对象，并获得了`SLEngineItf`接口。然后，我们调用了`SLEngineItf`接口暴露的`CreateAudioRecorder()`方法，在`record.c`的`createAudioRecorder`函数中创建了一个音频录音对象。在同一个函数中，我们还实现了录音对象，并通过对象创建时返回的`SLObjectItf`接口访问了对象的其他几个接口。完成录音对象后，我们调用了`Destroy()`方法来释放对象及其资源，如`OpenSLESDemo.cpp`中的`naShutdown`函数所示。
- en: 'One more thing to take note of on object creation is the interface request.
    An object creation method normally accepts three parameters related to interfaces,
    as shown in the `CreateAudioPlayer` method of the `SLEngineItf` interface as shown
    in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象创建时需要注意的另一件事是接口请求。对象创建方法通常接受与接口相关的三个参数，如`SLEngineItf`接口的`CreateAudioPlayer`方法所示，以下代码片段展示了这一点：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last three input arguments are related to interfaces. The `numInterfaces`
    argument indicates the number of interfaces we request to access. `pInterfaceIds`
    is an array of the `numInterfaces` interface IDs, which indicates the interface
    types the object should support. `pInterfaceRequired` is an array of `SLboolean`,
    specifying whether the requested interface is optional or required. In our audio
    player example, we called the `CreateAudioPlayer` method to request three types
    of interfaces (`SLAndroidSimpleBufferQueueItf`, `SLEffectSendItf`, and `SLVolumeItf`
    indicated by `SL_IID_BUFFERQUEUE`, `SL_IID_EFFECTSEND`, and `SL_IID_VOLUME` respectively).
    Since all elements of the `req` array are `true`, all the interfaces are required.
    If the object cannot provide any of the interfaces, the object creation will fail:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个输入参数与接口相关。`numInterfaces`参数表示我们请求访问的接口数量。`pInterfaceIds`是一个包含`numInterfaces`接口ID的数组，表示对象应该支持的接口类型。`pInterfaceRequired`是一个`SLboolean`数组，指定请求的接口是可选的还是必需的。在我们的音频播放器示例中，我们调用了`CreateAudioPlayer`方法来请求三种类型的接口（分别由`SL_IID_BUFFERQUEUE`、`SL_IID_EFFECTSEND`和`SL_IID_VOLUME`表示的`SLAndroidSimpleBufferQueueItf`、`SLEffectSendItf`和`SLVolumeItf`）。由于`req`数组中的所有元素都是`true`，因此所有接口都是必需的。如果对象无法提供任何接口，对象创建将失败：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that an object can have implicit and explicit interfaces. The implicit
    interfaces are available for every object of the type. For example, the `SLObjectItf`
    interface is an implicit interface for all objects of all types. It is not necessary
    to request the implicit interfaces in the object creation method. However, if
    we want to access some explicit interfaces, we must request them in the method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个对象可以具有隐式和显式接口。隐式接口对类型的每个对象都是可用的。例如，`SLObjectItf`接口是所有类型所有对象的隐式接口。在对象创建方法中，不需要请求隐式接口。然而，如果我们想要访问一些显式接口，必须在方法中请求它们。
- en: For more information on interfaces refer to *Section 3.1.6*, *The Relationship
    Between Objects and Interfaces* in the *OpenSL ES 1.0.1 Specification* document.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有关接口的更多信息，请参考*OpenSL ES 1.0.1 Specification*文档中的*第3.1.6节*，*对象与接口之间的关系*。
- en: Changing states of objects
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变对象的状态
- en: The object creation method creates an object and puts it in an unrealized state.
    At this state, the resources of the object have not been allocated, therefore
    it is not usable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对象创建方法创建一个对象并将其置于未实现状态。在这种状态下，对象的资源尚未分配，因此无法使用。
- en: We will need to call the `Realize()` method of the `SLObjectItf` interface of
    the object to cause the object to transit to the realized state, where the resources
    are allocated and the interfaces can be accessed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用对象的`SLObjectItf`接口的`Realize()`方法，使对象过渡到实现状态，在该状态下分配资源并且可以访问接口。
- en: Once we are done with the object, we call the `Destroy()` method to free the
    object and its resources. This call internally transfers the object through the
    unrealized stage, where the resources are freed. Therefore, the resources are
    freed first before the object itself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了对象操作，我们调用`Destroy()`方法来释放对象及其资源。这个调用内部将对象转移到未实现阶段，在该阶段释放资源。因此，在释放对象本身之前，首先释放资源。
- en: In this recipe, we illustrate the recording and playback APIs with our sample
    project.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用我们的示例项目展示了录制和播放API。
- en: Use and build with OpenSL ES Audio library
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用和构建OpenSL ES音频库
- en: 'In order to call the API functions, we must add the following lines to our
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用API函数，我们必须向我们的代码中添加以下行：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we are using Android-specific features as well, we should include another
    header:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们也使用安卓特有的功能，我们应该包含另一个头文件：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `Android.mk` file, we must add the following line to link to the native
    OpenSL ES Audio library:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Android.mk`文件中，我们必须添加以下行以链接到本地OpenSL ES音频库：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: OpenSL ES audio recording
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenSL ES音频录制
- en: 'Because the MIME data format and the `SLAudioEncoderItf` interface are not
    available for the audio recorder on Android, we can only record audio in the PCM
    format. Our example demonstrates how to record audio in the PCM format and save
    the data into a file. This can be illustrated using the following diagram:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为MIME数据格式和`SLAudioEncoderItf`接口对安卓上的音频录音机不可用，我们只能以PCM格式录制音频。我们的示例展示了如何以PCM格式录制音频并将数据保存到文件中。这可以用以下图示说明：
- en: '![OpenSL ES audio recording](img/1505_07_12.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![OpenSL ES音频录制](img/1505_07_12.jpg)'
- en: At the `createAudioRecorder` function of `record.c`, we create and realize an
    audio recorder object. We set the audio input as data source, and an Android buffer
    queue as data sink. Note that we registered the `bqRecorderCallback` function
    as the callback function for buffer queue. Whenever the buffer queue is ready
    for a new buffer, the `bqRecorderCallback` function will be called to save the
    buffer data to the `test.cpm` file and enqueue the buffer again for recording
    new audio data. At the `startRecording` function, we start the recording.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`record.c`的`createAudioRecorder`函数中，我们创建并实现了音频录音对象。我们将音频输入设置为数据源，将安卓缓冲队列设置为数据接收端。注意，我们注册了`bqRecorderCallback`函数作为缓冲队列的回调函数。每当缓冲队列准备好新的缓冲区时，将调用`bqRecorderCallback`函数将缓冲区数据保存到`test.cpm`文件中，并将缓冲区重新入队以录制新的音频数据。在`startRecording`函数中，我们开始录音。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The callback functions in OpenSL ES are executed from internal non-application
    threads. The threads are not managed by Dalvik VM and therefore they cannot access
    JNI. These threads are critical to the integrity of the OpenSL ES implementation,
    so the callback functions should not block or perform any heavy-processing tasks.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES中的回调函数是从内部非应用程序线程执行的。这些线程不由Dalvik VM管理，因此它们无法访问JNI。这些线程对OpenSL ES实现至关重要，因此回调函数不应该阻塞或执行任何繁重的处理任务。
- en: In case we need to perform heavy tasks when the callback function is triggered,
    we should post an event for another thread to process such tasks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当回调函数被触发时我们需要执行繁重任务，我们应该发布一个事件给另一个线程来处理这些任务。
- en: This also applies to the OpenMAX AL library that we are going to cover in next
    recipe. More detailed information can be obtained from the NDK OpenSL ES documentation
    at the `docs/opensles/` folder.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于我们将在下一个食谱中介绍的OpenMAX AL库。更详细的信息可以从NDK OpenSL ES文档的`docs/opensles/`文件夹中获得。
- en: OpenSL ES audio playback
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenSL ES音频播放
- en: 'Android OpenSL ES library provides lots of features for audio playback. We
    can play encoded audio files, including mp3, aac, and so on. Our example shows
    how to play the PCM audio. This can be illustrated as shown in the following diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓的OpenSL ES库为音频播放提供了许多功能。我们可以播放编码的音频文件，包括mp3、aac等。我们的示例展示了如何播放PCM音频。这可以如下所示图示：
- en: '![OpenSL ES audio playback](img/1505_07_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![OpenSL ES音频播放](img/1505_07_13.jpg)'
- en: We created and realized the engine object and the output mix object in the `naCreateEngine`
    function in `OpenSLESDemo.cpp`. The audio player object is created in the `createBufferQueueAudioPlayer`
    function of `play.c` with an Android buffer queue as data source and the output
    mix object as data sink. The `bqPlayerCallback` function is registered as the
    callback method through a `SLAndroidSimpleBufferQueueItf` interface. Whenever
    the player finishes playing a buffer, the buffer queue is ready for new data and
    the callback function `bqPlayerCallback` will be invoked. The method reads data
    from the `test.pcm` file into the buffer and enqueues it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `OpenSLESDemo.cpp` 的 `naCreateEngine` 函数中创建了引擎对象和输出混合对象。在 `play.c` 的 `createBufferQueueAudioPlayer`
    函数中创建了音频播放器对象，以 Android 缓冲队列作为数据源和输出混合对象作为数据接收器。通过 `SLAndroidSimpleBufferQueueItf`
    接口注册了 `bqPlayerCallback` 函数作为回调方法。每当播放器播放完一个缓冲区，缓冲队列就准备好接收新数据，此时会调用回调函数 `bqPlayerCallback`。该方法从
    `test.pcm` 文件读取数据到缓冲区并将其入队。
- en: In the `startPlaying` function, we read the initial data into the buffer and
    set the player state to `SL_PLAYSTATE_PLAYING`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `startPlaying` 函数中，我们将初始数据读取到缓冲区，并将播放器状态设置为 `SL_PLAYSTATE_PLAYING`。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OpenSL ES is a complex library with a more than 500 page long specification.
    The specification is a good reference when developing applications with OpenSL
    ES and it is available with the Android NDK.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES 是一个复杂的库，其规范超过 500 页。在开发 OpenSL ES 应用程序时，规范是一个很好的参考，它可以通过 Android NDK
    获得。
- en: The Android NDK also comes with a native-audio example, which demonstrates usage
    of a lot more OpenSL ES functions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 还附带了一个本地音频示例，演示了更多 OpenSL ES 函数的使用。
- en: Programming with the OpenMAX AL multimedia library in Android NDK
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android NDK 中使用 OpenMAX AL 多媒体库进行编程
- en: OpenMAX AL is an application-level multimedia library in C. Android NDK multimedia
    APIs are based on the OpenMAX AL 1.0.1 standard with Android-specific extensions.
    The API is available for Android 4.0 or higher. We should note that the API is
    evolving and the Android NDK team mentioned that the future version of OpenMAX
    AL API may require developers to change their code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMAX AL 是一个用 C 语言编写的应用层多媒体库。Android NDK 多媒体 API 基于 OpenMAX AL 1.0.1 标准，并带有
    Android 特定的扩展。该 API 可用于 Android 4.0 或更高版本。需要注意的是，API 正在不断发展，Android NDK 团队提到，未来版本的
    OpenMAX AL API 可能会要求开发者更改他们的代码。
- en: Getting ready...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Before we start coding with the OpenMAX AL library, it is important to understand
    some basics about the library. We will briefly describe the library in the following
    text.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 OpenMAX AL 库进行编程之前，了解一些关于库的基础知识是很重要的。我们将在以下文本中简要描述该库。
- en: OpenMAX AL refers to the Application Layer interface of the **Open Media Acceleration**
    (**OpenMAX**) library. It is a royalty-free, cross-platform, C-language application
    level API for developers to create multimedia applications. Its main features
    include media recording, media playback, media controls (for example, brightness
    control), and effects. Compared to OpenSL ES library, OpenMAX AL provides features
    for both video and audio, but it lacks certain audio features like 3D audio and
    audio effects which OpenSL ES can provide. Some applications may need to use both
    libraries.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMAX AL 指的是 **Open Media Acceleration**（**OpenMAX**）库的应用层接口。它是一个免版税、跨平台、使用
    C 语言的 应用层 API，供开发者创建多媒体应用程序。其主要特性包括媒体记录、媒体播放、媒体控制（例如，亮度控制）和效果。与 OpenSL ES 库相比，OpenMAX
    AL 提供了视频和音频的功能，但它缺少 OpenSL ES 可以提供的某些音频功能，如 3D 音频和音频效果。某些应用程序可能需要同时使用这两个库。
- en: OpenMAX AL defines two profiles, namely media playback and media player/recorder.
    Android does not implement all features required by either profile, therefore
    the OpenMAX AL library in Android does not conform either profile. In addition,
    Android implements some features specific to Android.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMAX AL 定义了两个配置文件，分别是媒体播放和媒体播放器/记录器。Android 并没有实现这两个配置文件所需的所有功能，因此 Android
    中的 OpenMAX AL 库不符合任何一个配置文件。此外，Android 还实现了一些特定于 Android 的功能。
- en: The main features provided by Android OpenMAX AL implementation is the ability
    to process the MPEG-2 transport stream. We can demultiplex the stream, decode
    the video and audio, and render them as audio output or to the phone screen. This
    library allows us to have complete control over the media data before it is passed
    for presentation. For example, we can call OpenGL ES functions to apply graphics
    effect on video data before rendering it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Android OpenMAX AL 实现提供的主要功能是处理 MPEG-2 传输流的能力。我们可以对流进行解复用，解码视频和音频，并将它们作为音频输出或渲染到手机屏幕。这个库允许我们在将媒体数据传递以供展示之前完全控制它。例如，我们可以在渲染视频数据之前调用
    OpenGL ES 函数以应用图形效果。
- en: For a detailed description of what is supported on Android, we can refer to
    the OpenMAX AL for Android documentation available with the Android NDK under
    the `docs/openmaxal/` folder.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Android 支持的内容，我们可以参考随 Android NDK 提供的 OpenMAX AL for Android 文档，位于 `docs/openmaxal/`
    文件夹中。
- en: The design of OpenMAX AL library is similar to OpenSL ES library. They both
    adopt an object-oriented approach and the fundamental concepts including objects
    and interfaces are the same. Readers should refer to the previous recipe for a
    detailed explanation on these concepts.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMAX AL 库的设计与 OpenSL ES 库类似。它们都采用面向对象的方法，基本概念包括对象和接口都是相同的。读者应参考之前的食谱以获取这些概念的详细解释。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps describe how to create a simple Android video playback
    application using the OpenMAX AL functions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何使用 OpenMAX AL 函数创建一个简单的 Android 视频播放应用程序：
- en: Create an Android application named `OpenMAXSLDemo`. Set the package name as
    `cookbook.chapter7.openmaxsldemo`. Refer to the *Loading native libraries and
    registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java Native
    Interface"), *Java Native Interface* for more detailed instructions.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `OpenMAXSLDemo` 的 Android 应用程序。将包名设置为 `cookbook.chapter7.openmaxsldemo`。有关更详细的说明，请参考
    [第2章](ch02.html "第2章。Java本地接口")，*Java本地接口*中的*加载本地库和注册本地方法*食谱。
- en: Right-click on the project **OpenMAXSLDemo**, select **Android Tools** | **Add
    Native Support**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目 **OpenMAXSLDemo**，选择 **Android Tools** | **添加本地支持**。
- en: Add a Java file named `MainActivity.java` in the package `cookbook.chapter7.openmaxsldemo`.
    This Java file loads the native library `OpenMAXSLDemo`, sets the view, and calls
    the native methods to play the video.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包 `cookbook.chapter7.openmaxsldemo` 中添加一个名为 `MainActivity.java` 的 Java 文件。这个
    Java 文件加载本地库 `OpenMAXSLDemo`，设置视图，并调用本地方法来播放视频。
- en: Add the `mylog.h` and `OpenMAXSLDemo.c` files in the `jni` folder. A part of
    the code in `OpenMAXSLDemo.c` is showed in the following code snippet.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹中添加 `mylog.h` 和 `OpenMAXSLDemo.c` 文件。`OpenMAXSLDemo.c` 的一部分代码在以下代码片段中显示。
- en: '`naCreateEngine` creates and realizes the engine object and the output mix
    object.'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`naCreateEngine` 创建并实现引擎对象和输出混合对象。'
- en: '[PRE42]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`naCreateStreamingMediaPlayer` creates and realizes a media player object with
    the data source and data sink. It obtains the buffer queue interface and registers
    the `AndroidBufferQueueCallback` function as the callback function. The callback
    function will be invoked after a buffer is processed:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`naCreateStreamingMediaPlayer` 创建并实现具有数据源和数据接收器的媒体播放器对象。它获取缓冲队列接口，并将 `AndroidBufferQueueCallback`
    函数注册为回调函数。回调函数将在处理完缓冲区后被调用：'
- en: '[PRE43]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`AndroidBufferQueueCallback` is the callback function registered to refill
    the buffer with media data or handle commands:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AndroidBufferQueueCallback` 是注册的回调函数，用于用媒体数据重新填充缓冲区或处理命令：'
- en: '[PRE44]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add an `Android.mk` file in the `jni` folder with the following content:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹中添加一个 `Android.mk` 文件，内容如下：
- en: '[PRE45]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use the `NativeMedia.ts` video file available in the `samples/native-media/`
    directory for testing. The following command can be used to put the video file
    into the `/sdcard/` directory of the testing Android device:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `samples/native-media/` 目录中可用的 `NativeMedia.ts` 视频文件进行测试。以下命令可以将视频文件放入测试
    Android 设备的 `/sdcard/` 目录中：
- en: '[PRE46]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Build and start the Android application. We can see the GUI as shown in the
    following screenshot:![How to do it...](img/1505_07_14.jpg)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并启动 Android 应用程序。我们可以看到如下截图所示的 GUI：![如何操作...](img/1505_07_14.jpg)
- en: We can press **Play** to start playing the video.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以按下 **播放** 开始播放视频。
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used the OpenMAX AL library to implement a simple video player.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们使用了 OpenMAX AL 库来实现一个简单的视频播放器。
- en: 'Use and build with the OpenMAX AL multimedia library:'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenMAX AL 多媒体库进行构建和使用：
- en: 'In order to call the API functions, we must add the following line to our code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用 API 函数，我们必须在代码中添加以下行：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we are also using Android-specific features, we should include another header:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们也在使用 Android 特定的功能，我们应该包含另一个头文件：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `Android.mk` file, we must add the following line to link to the OpenMAX
    AL multimedia library:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Android.mk` 文件中，我们必须添加以下行以链接到 OpenMAX AL 多媒体库：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: OpenMAX AL video playback
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenMAX AL 视频播放
- en: 'Our sample project that is a simplified version of the native media project
    comes with the Android NDK. The following diagram illustrates how the application
    works:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例项目是随 Android NDK 一起提供的原生媒体项目的简化版本。下图说明了应用程序的工作原理：
- en: '![OpenMAX AL video playback](img/1505_07_15.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![OpenMAX AL 视频播放](img/1505_07_15.jpg)'
- en: In our code, we created and realized the engine and output mix objects at `naCreateEngine`
    function. At the `naCreateStreamingMediaPlayerfunction` function, we created and
    realized the media player object with the audio data sink set as output mix, video
    data sink set as native display, and data source set as the Android buffer queue.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，在 `naCreateEngine` 函数中创建并实现了引擎和输出混合对象。在 `naCreateStreamingMediaPlayerfunction`
    函数中，我们创建并实现了媒体播放器对象，将音频数据接收器设置为输出混合，视频数据接收器设置为本地显示，数据源设置为 Android 缓冲队列。
- en: When a buffer is consumed, the callback function `AndroidBufferQueueCallback`
    is invoked, where we refill the buffer with data from the `NativeMedia.ts` file
    and enqueue it to the buffer queue.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个缓冲区被消耗时，会调用回调函数 `AndroidBufferQueueCallback`，我们在其中用 `NativeMedia.ts` 文件中的数据重新填充缓冲区，并将其加入缓冲队列。
- en: There's more....
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: OpenMAX AL is a complex library. The specification is a good reference when
    developing applications with OpenMAX AL and it is available with the Android NDK.
    The Android NDK also comes with a native-media example, which is a good example
    of how to use the API.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMAX AL 是一个复杂的库。在开发具有 OpenMAX AL 的应用程序时，规范是一个很好的参考，并且它随 Android NDK 一起提供。Android
    NDK 还附带了一个原生媒体示例，这个示例很好地展示了如何使用 API。
