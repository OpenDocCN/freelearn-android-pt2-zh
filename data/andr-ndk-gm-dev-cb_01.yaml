- en: Chapter 1. Establishing a Build Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 建立构建环境
- en: '|   | *Some LinkedIn profiles say developing with a particular IDE is a skill.**No!
    Development without any IDE is the skill!* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *一些LinkedIn个人资料说使用特定IDE进行开发是一种技能。**不！不使用任何IDE进行开发才是真正的技能！** |   |'
- en: '|   | --*Sergey Kosarevsky* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*谢尔盖·科萨列夫斯基* |'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Installing Android development tools on Windows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装Android开发工具
- en: Installing Android development tools on Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上安装Android开发工具
- en: Creating an application template manually
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建应用程序模板
- en: Adding native C++ code to your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你的应用程序添加本地C++代码
- en: Switching NDK toolchains
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换NDK工具链
- en: Supporting multiple CPU architectures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种CPU架构
- en: Basic rendering with OpenGL ES
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenGL ES进行基本渲染
- en: Going cross platform
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台开发
- en: Unifying the cross-platform code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一跨平台代码
- en: Linking and source code organization
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接与源代码组织
- en: Signing release Android applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名发布Android应用程序
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: This chapter explains how to install and configure Android NDK on Microsoft
    Windows or Ubuntu/Debian Linux, and how to build and run your first application
    on an Android-based device. We will learn how to set-up different compilers and
    **toolchains** that come with Android NDK. In addition, we show how to setup the
    GCC toolchain for Windows to build your projects. The rest of the chapter is devoted
    to cross-platform development using C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何在Microsoft Windows或Ubuntu/Debian Linux上安装和配置Android NDK，以及如何在基于Android的设备上构建和运行你的第一个应用程序。我们将学习如何设置不同的编译器和随Android
    NDK提供的**工具链**。此外，我们还将展示如何设置Windows上的GCC工具链以构建你的项目。本章的其余部分致力于使用C++进行跨平台开发。
- en: Installing Android development tools on Windows
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装Android开发工具
- en: To start developing games for Android you will need some essential tools to
    be installed on your system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始为Android开发游戏，你需要在系统上安装一些基本工具。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Here is the list of all the prerequisites you will need to start developing
    games for Android:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开始为Android开发游戏所需的所有先决条件列表：
- en: Android SDK at [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android SDK位于[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)。
- en: Note
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This book is based on the Android SDK rev. 22.3 and tested with Android API
    Level 19.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书基于Android SDK修订版22.3，并使用Android API Level 19进行测试。
- en: Android NDK at [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)
    (we used Android NDK r9b).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android NDK位于[http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)（我们使用的是Android
    NDK r9b）。
- en: Apache Ant at [http://ant.apache.org](http://ant.apache.org). This is a Java
    command-line tool which may be unfamiliar to C++ developers. It's purpose is to
    build Java applications, and since every Android application has a Java wrapper,
    this tool will help us to pack them into archives ready for deployment (these
    are called `.apk` packages, which stands for **Android Package**).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Ant位于[http://ant.apache.org](http://ant.apache.org)。这是一个Java命令行工具，C++开发者可能不太熟悉。它的目的是构建Java应用程序，由于每个Android应用程序都有一个Java包装器，因此此工具将帮助我们打包成部署就绪的存档（这些被称为`.apk`包，代表**Android
    Package**）。
- en: Java SE Development Kit at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE开发工具包位于[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)。
- en: Former versions of SDK/NDK for Windows required a **Cygwin** environment, a
    Linux-like environment for Windows, to be installed. Up-to-date versions of these
    tools can run natively on Windows without any intermediate layer. We will focus
    on the Cygwin-less environment and will do all of the development without IDE.
    You heard it right, we will just use the command line. All the examples in this
    book were written and debugged on a Windows PC.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的Windows SDK/NDK需要安装**Cygwin**环境，这是一种类似于Linux的Windows环境。最新版本的这些工具可以在Windows上本机运行，无需任何中间层。我们将重点介绍无Cygwin环境，并且将在不使用IDE的情况下进行所有开发。你没听错，我们将仅使用命令行。本书中的所有示例都是在Windows
    PC上编写和调试的。
- en: To compile native Windows applications presented in this book, you will need
    a decent C++ compiler, such as the MinGW package with a GCC toolchain. Using Microsoft
    Visual Studio is also possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译本书中介绍的本地Windows应用程序，你需要一个像样的C++编译器，例如带有GCC工具链的MinGW包。使用Microsoft Visual Studio也是可行的。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Minimalist GNU for Windows** (**MinGW**) is a minimalist development environment
    for Windows applications using a port of **GNU Compiler Collection** (**GCC**).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows的最小化GNU**（**MinGW**）是一个使用**GNU编译器集合**（**GCC**）端口的Windows应用程序的最小开发环境。'
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Android SDK and NDK should be installed into folders that do not contain any
    whitespaces in their names.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android SDK和NDK应安装到名称中不包含任何空格的文件夹中。
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This requirement comes from the limitations of scripts in Android SDK. There
    is a nice discussion on StackOverflow which explains some reasons behind these
    limitations at [http://stackoverflow.com/q/6603194/1065190](http://stackoverflow.com/q/6603194/1065190).
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个要求源于Android SDK中脚本的限制。StackOverflow上有一个很好的讨论，解释了这些限制背后的部分原因，请见[http://stackoverflow.com/q/6603194/1065190](http://stackoverflow.com/q/6603194/1065190)。
- en: 'Other tools can be installed to their default locations. We used the following
    paths in our Windows 7 system:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他工具可以安装到它们的默认位置。我们在Windows 7系统上使用了以下路径：
- en: '| Tools | Path |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 路径 |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Android SDK | `D:\android-sdk-windows` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Android SDK | `D:\android-sdk-windows` |'
- en: '| Android NDK | `D:\ndk` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Android NDK | `D:\ndk` |'
- en: '| Apache Ant | `D:\ant` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Apache Ant | `D:\ant` |'
- en: '| Java Development Kit | `C:\Program Files\Java\jdk1.6.0_33` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Java开发工具包 | `C:\Program Files\Java\jdk1.6.0_33` |'
- en: All tools have pretty decent GUI installers (see the following image, that shows
    the Android SDK Manager from SDK R21) so you don't have to use the command line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工具都有相当不错的GUI安装程序（请看以下图片，展示了SDK R21的Android SDK管理器），所以你不必使用命令行。
- en: '![How to do it...](img/7785_02_1.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/7785_02_1.jpg)'
- en: For the Windows environment, you need the MinGW GCC toolchain. The easy to install
    all-in-one package can be found at [http://www.equation.com](http://www.equation.com),
    in the **Programming Tools** section, **Fortran, C, C++** subsection. Alternatively,
    you can download the official installer from [http://www.mingw.org](http://www.mingw.org).
    We will use the one from [www.equation.com](http://www.equation.com)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows环境，你需要MinGW GCC工具链。易于安装的一体化软件包可以在[http://www.equation.com](http://www.equation.com)的**编程工具**部分，**Fortran,
    C, C++**子部分找到。或者，你也可以从[http://www.mingw.org](http://www.mingw.org)下载官方安装程序。我们将使用来自[www.equation.com](http://www.equation.com)的版本。
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'You need to set some environment variables to let the tools know where the
    files are located. The `JAVA_HOME` variable should point to the Java Development
    Kit folder. The `NDK_HOME` variable should point to the Android NDK installation
    folder, and `ANDROID_HOME` should point to the Android SDK folder (note the double
    backslash). We used the following environment variable values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要设置一些环境变量，让工具知道文件的位置。`JAVA_HOME`变量应指向Java开发工具包文件夹。`NDK_HOME`变量应指向Android NDK安装文件夹，而`ANDROID_HOME`应指向Android
    SDK文件夹（注意双反斜杠）。我们使用了以下环境变量值：
- en: '`JAVA_HOME=D:\Java\jdk1.6.0_23`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`JAVA_HOME=D:\Java\jdk1.6.0_23`'
- en: '`NDK_HOME=D:\ndk`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`NDK_HOME=D:\ndk`'
- en: '`ANDROID_HOME=D:\\android-sdk-windows`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANDROID_HOME=D:\\android-sdk-windows`'
- en: 'The final configuration looks similar to the one shown in the following screenshot,
    which shows the Windows **Environment Variables** dialog box:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最终配置类似于以下截图所示，展示了Windows的**环境变量**对话框：
- en: '![There''s more...](img/7785_02_2.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多内容...](img/7785_02_2.jpg)'
- en: After MinGW has been successfully installed, you should also add the `bin` folder
    from its installation folder to the `PATH` environment variable. For example,
    if MinGW is installed to `C:\MinGW`, then `PATH` should contain the `C:\MinGW\bin`
    folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装MinGW成功后，你还需要将其安装文件夹中的`bin`文件夹添加到`PATH`环境变量中。例如，如果MinGW安装在`C:\MinGW`，那么`PATH`应该包含`C:\MinGW\bin`文件夹。
- en: Installing Android development tools on Linux
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装Android开发工具
- en: Installation of the basic tools on Linux is as easy as it was with their Windows
    counterpart. In this recipe, we will see how to install the basic Android development
    tools on *nix systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上安装基本工具与在Windows上一样简单。在本教程中，我们将看到如何在*nix系统上安装基本的Android开发工具。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We assume you already have an Ubuntu/Debian system with the `apt` package manager.
    Refer to [http://wiki.debian.org/Apt](http://wiki.debian.org/Apt) for details.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经有一个带有`apt`包管理器的Ubuntu/Debian系统。详情请参考[http://wiki.debian.org/Apt](http://wiki.debian.org/Apt)。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps to install the required basic tools:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来安装所需的基本工具：
- en: 'Make sure you are using the latest version of the packages for your OS by running
    the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，确保你为你的操作系统使用了最新版本的软件包：
- en: '[PRE0]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install OpenJDK 6+:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装OpenJDK 6+：
- en: '[PRE1]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install the Apache Ant build automation tool:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Apache Ant构建自动化工具：
- en: '[PRE2]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Download the official Android SDK from [http://developer.android.com](http://developer.android.com).
    There is a bigger package next to it, with the ADT plugin for the Eclipse IDE.
    However, since we do all of our development from the command line, we won''t need
    it. Run the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://developer.android.com](http://developer.android.com)下载官方的Android SDK。旁边有一个更大的包，其中包含Eclipse
    IDE的ADT插件。然而，由于我们所有的开发都是通过命令行进行的，所以我们不需要它。运行以下命令：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Unpack the downloaded .`tgz` file (the actual version might vary, 22.2.1 is
    the latest version as of October 2013):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的`.tgz`文件（实际版本可能有所不同，截至2013年10月，22.2.1是最新版本）：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Use `~/<sdk>/tools/android` to install the latest Platform Tools and all of
    the SDKs—just like in the Windows case.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`~/<sdk>/tools/android`安装最新的Platform Tools和所有SDKs——就像在Windows情况下一样。
- en: Failure to do so will result in an error while trying to use the Ant tool when
    building any application for the Android.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果不这样做，在尝试使用Ant工具构建任何Android应用程序时将出现错误。
- en: 'Get the official Android NDK from [http://developer.android.com](http://developer.android.com):'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://developer.android.com](http://developer.android.com)获取官方的Android NDK：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unpack the downloaded NDK `.tgz` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的NDK `.tgz`文件：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set the `NDK_ROOT` environment variable to your Android NDK directory (for
    example, `~/android-ndk-r9b` in our case):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NDK_ROOT`环境变量设置为你的Android NDK目录（例如，在我们的情况下是`~/android-ndk-r9b`）：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is useful to put this line and the `JAVA_HOME` definition to `/etc/profile`
    or `/etc/environment`, if these settings are applicable to all the users of the
    system.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这些设置适用于系统的所有用户，将这行和`JAVA_HOME`的定义放到`/etc/profile`或`/etc/environment`中是有用的。
- en: In case you are running a 64-bit system, you must ensure that you have the 32-bit
    Java runtime installed also.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行的是64位系统，你必须确保你也安装了32位的Java运行时。
- en: 'Run the following command to install the libraries. Failure to do so may lead
    to errors with `adb` and `aapt` tools:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以安装库。如果不这样做可能会导致`adb`和`aapt`工具出现错误：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a nice one-liner script that helps you automatically detect the OpenJDK
    home directory. It essentially resolves the link `/usr/bin/javac` to the full
    path and returns the directory part of the path.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很好的单行脚本可以帮助你自动检测OpenJDK的主目录。它本质上解析了`/usr/bin/javac`链接到完整路径，并返回路径的目录部分。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating an application template manually
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建应用程序模板
- en: First of all, we are going to create a basic template for our applications.
    Every Android application that is to be built via Android SDK, should contain
    a predefined directory structure and the configuration `.xml` files. This can
    be done using Android SDK tools and IDEs. In this recipe, we will learn how to
    do it manually. We will use these files later on as the very starting point for
    all our examples.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的应用程序创建一个基本模板。通过Android SDK构建的每个Android应用程序都应该包含预定义的目录结构和配置`.xml`文件。这可以使用Android
    SDK工具和IDE完成。在本教程中，我们将学习如何手动完成。我们稍后会把这些文件作为所有示例的起点。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let us set up the directory structure of our project (see the following screenshot):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置项目的目录结构（见下截图）：
- en: '![Getting ready](img/7785_02_3.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/7785_02_3.jpg)'
- en: This is a typical structure for any Android project. We will create all the
    required files manually rather than using Android tools.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一般Android项目的典型结构。我们将手动创建所有必需的文件，而不是使用Android工具。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Place the Java `Activity` code into the `App1\src\com\packtpub\ndkcookbook\app1\App1Activity.java
    file`, which should look as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将Java `Activity`代码放入`App1\src\com\packtpub\ndkcookbook\app1\App1Activity.java`文件中，其内容应如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The localizable application name should go to `App1\res\values\strings.xml`.
    The string parameter `app_name` is used in the `AndroidManifest.xml` file to specify
    the user-readable name of our application, as seen in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可本地化的应用程序名称应放入`App1\res\values\strings.xml`。在`AndroidManifest.xml`文件中，字符串参数`app_name`用于指定我们应用程序的用户可读名称，如下代码所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we need to write more scripts for Apache Ant and the Android SDK build system.
    They are necessary to build the `.apk` package of your application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为Apache Ant和Android SDK构建系统编写更多脚本。它们是构建应用程序的`.apk`包所必需的。
- en: 'The following is the `App1/project.properties` file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`App1/project.properties`文件：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need two more files for Ant. The following is `App1/AndroidManifest.xml`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为Ant准备两个文件。以下是`App1/AndroidManifest.xml`：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our examples require at least OpenGL ES 2\. Let Android know about it:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的示例至少需要OpenGL ES 2。让Android知道这一点：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a full-screen application in a landscape screen orientation:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个横屏方向的全屏应用程序：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second file is `App1/build.xml`:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个文件是`App1/build.xml`：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'With all the listed files in place, we can now build the project and install
    it on an Android device by carrying out the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有列出的文件就位后，我们现在可以构建项目并将其安装在Android设备上，具体步骤如下：
- en: 'From the `App1` folder run:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`App1`文件夹运行：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The tail of the output from the previous command should look like:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前命令输出的末尾应如下所示：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And the built debug `.apk` package is in `bin/App1-debug.apk`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建的调试`.apk`包位于`bin/App1-debug.apk`。
- en: 'To install the app, run:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装应用，请运行：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to connect your device through a USB and turn USB Debugging on
    in Android settings before running this command.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行此命令之前，不要忘记通过USB连接设备并在Android设置中打开USB调试。
- en: 'You should see the output from `adb`, similar to the following commands:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到来自`adb`的输出，类似于以下命令：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The application can now be started from your Android launcher (named `App1`).
    You will see just a black screen. You can exit the application using the **BACK**
    button.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可以从您的Android启动器（名为`App1`）启动。您将看到一个黑色屏幕。您可以使用**返回**按钮退出应用程序。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Don't forget to put the application icon into `App1\res\drawable\icon.png`.
    Refer to the book's code bundle if you want to build the app quickly, or put your
    own icon there. 72 x 72 32-bit will do just fine. You can find the official Android
    icons guidelines at [http://developer.android.com/design/style/iconography.html](http://developer.android.com/design/style/iconography.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将应用图标放入`App1\res\drawable\icon.png`。如果您想快速构建应用程序，可以参考本书的代码包，或者放置自己的图标。72
    x 72 32位即可。您可以在[http://developer.android.com/design/style/iconography.html](http://developer.android.com/design/style/iconography.html)找到官方的Android图标指南。
- en: The official documentation on the `AndroidManifest.xml` file can be found at
    [http://developer.android.com/guide/topics/manifest/manifest-intro.html](http://developer.android.com/guide/topics/manifest/manifest-intro.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`AndroidManifest.xml`文件的官方文档可以在[http://developer.android.com/guide/topics/manifest/manifest-intro.html](http://developer.android.com/guide/topics/manifest/manifest-intro.html)找到。
- en: 'Furthermore, you can update your applications without uninstalling the previous
    version using the `adb -r` command-line switch in the following way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用以下方式通过`adb -r`命令行开关更新应用程序，而无需卸载之前的版本：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Otherwise, before installing a new version of your application you will have
    to uninstall the existing one using the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，在安装应用程序的新版本之前，您必须使用以下命令卸载现有版本：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: '*Signing release Android applications*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*签名发布Android应用程序*'
- en: Adding native C++ code to your application
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的应用程序添加本地C++代码
- en: Let us expand our minimalistic Java template, which was discussed in the previous
    recipe, so we can create a placeholder for our native C++ code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展之前食谱中讨论的最小化Java模板，以便为我们的本地C++代码创建一个占位符。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to copy all the files from our `App1` project to save time while creating
    the initial project files. This recipe will focus on the changes to be made to
    the `App1` project in order to add the C++ code to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`App1`项目中的所有文件复制过来，以便在创建初始项目文件时节省时间。这个食谱将重点介绍需要修改`App1`项目以添加C++代码的内容。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps to create a placeholder for our C++ code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤为我们的C++代码创建占位符：
- en: 'Add the `jni/Wrappers.cpp` file with the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包含以下代码的`jni/Wrappers.cpp`文件：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to change our `Activity` class from the previous recipe to make use
    of the native code we just added in the preceding section, through the following
    code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改前一个食谱中的`Activity`类，以便通过以下代码利用我们在上一节中添加的本机代码：
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we load the native library named `libApp2.so`. Note the omitted `lib`
    prefix and `.so` extension:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里我们加载名为`libApp2.so`的本机库。注意省略的`lib`前缀和`.so`扩展名：
- en: '[PRE25]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Tell the NDK build system how to treat the `.cpp` file. Create the `jni/Android.mk`
    file. The `Android.mk` file is used by the Android NDK build system to find out
    how to treat the source code of your project:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉NDK构建系统如何处理`.cpp`文件。创建`jni/Android.mk`文件。`Android.mk`文件由Android NDK构建系统使用，以了解如何处理项目的源代码：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the `ifeq ($(TARGET_ARCH),x86)` section. Here we specify architecture-specific
    compiler flags for floating point support on ARMv7\. This will give you hardware
    floating-point support on the ARM architecture and a warnings-free log on the
    x86 Android target architecture..
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `ifeq ($(TARGET_ARCH),x86)` 部分。在这里，我们为 ARMv7 上的浮点支持指定了架构特定的编译器标志。这将在 ARM
    架构上为您提供硬件浮点支持，并在 x86 Android 目标架构上提供无警告的日志。
- en: 'Paste the following code into the `jni/Application.mk` file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码粘贴到 `jni/Application.mk` 文件中：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First of all, we need to compile the native code. From the root of your `App2`
    project, run the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要编译本地代码。从 `App2` 项目的根目录运行以下命令：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now proceed to the `.apk` creation as in the previous recipe by running the
    following command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像上一个食谱一样，通过运行以下命令开始创建 `.apk`：
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Your `libApp2.so` native shared library will be packed into the `App2-debug.apk`
    package. Install and run it. It will output a `Hello World!` string into the device
    log.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的 `libApp2.so` 本地共享库将被打包进 `App2-debug.apk` 文件中。安装并运行它，它将在设备日志中输出 `Hello World!`
    字符串。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use the `adb` command to view the device log. A nice clean formatted
    log with timestamps can be created using the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `adb` 命令查看设备日志。使用以下命令可以创建一个带有时间戳的整洁格式化日志：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The actual output from your device will look similar to the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的设备实际输出的内容将类似于以下命令：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Switching NDK toolchains
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换 NDK 工具链
- en: A toolchain is a set of tools that are used to build your project. A toolchain
    usually consists of a compiler, an assembler, and a linker. Android NDK comes
    with different toolchains—GCC and Clang—of different versions. It has a convenient
    and simple way to switch between them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是一组用于构建项目的工具。工具链通常包括编译器、汇编器和链接器。Android NDK 提供了不同版本的 GCC 和 Clang 不同的工具链。它有一种方便简单的方式来切换它们。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Look through the list of the available toolchains before proceeding. You can
    find all the available toolchains in the `$(NDK_ROOT)/toolchains/` folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续操作之前，请查看可用的工具链列表。您可以在 `$(NDK_ROOT)/toolchains/` 文件夹中找到所有可用的工具链。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The parameter `NDK_TOOLCHAIN_VERSION` in `Application.mk` corresponds to one
    of the available toolchains. In NDK r9b, you can switch between three GCC versions—4.6,
    and 4.7, which are marked as deprecated and will be removed from the next NDK
    releases, and 4.8\. And two Clang versions—Clang3.2, which is also marked as deprecated,
    and Clang3.3\. The default toolchain in the NDK r9b is still GCC 4.6.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk` 中的参数 `NDK_TOOLCHAIN_VERSION` 对应于可用的工具链之一。在 NDK r9b 中，您可以在三个
    GCC 版本之间切换—4.6 和 4.7（已被标记为不推荐使用，并将在下一个 NDK 版本中移除），以及 4.8。还有两个 Clang 版本—Clang3.2（也已标记为不推荐使用）和
    Clang3.3。NDK r9b 中的默认工具链仍然是 GCC 4.6。'
- en: Starting from the NDK r8e, you can just specify `clang` as the value of `NDK_TOOLCHAIN_VERSION`.
    This option will select the most recent version of the available Clang toolchain.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从 NDK r8e 开始，您只需将 `clang` 指定为 `NDK_TOOLCHAIN_VERSION` 的值。此选项将选择可用的最新 Clang 工具链版本。
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The toolchains are discovered by the `$(NDK_ROOT)/build/core/init.mk` script,
    so you can define your own toolchain in a folder named `<ABI>-<ToolchainName>`
    and use it in `Application.mk`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是由 `$(NDK_ROOT)/build/core/init.mk` 脚本发现的，因此您可以在名为 `<ABI>-<ToolchainName>`
    的文件夹中定义自己的工具链，并在 `Application.mk` 中使用它。
- en: Supporting multiple CPU architectures
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多种 CPU 架构
- en: Android NDK supports different CPU architectures such as ARMv5TE and ARMv7-based
    devices, x86, and MIPS (big-endian architecture). We can create **fat** binaries
    that can run on any of the supported platforms.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 支持不同的 CPU 架构，例如基于 ARMv5TE 和 ARMv7 的设备、x86 和 MIPS（大端架构）。我们可以创建能在任何支持平台上运行的**胖**二进制文件。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Find out the architecture of your Android-based device. You can do it using
    the `adb` command as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查找基于 Android 的设备的架构。您可以使用以下 `adb` 命令进行操作：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the two approaches to pick an appropriate set of CPU architectures:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是选择适当 CPU 架构集的两种方法：
- en: 'By default, the NDK will generate the code for ARMv5TE-based CPUs. Use the
    parameter `APP_ABI` in `Application.mk` to select a different architecture, for
    example (use only one line from the following list):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，NDK 将为基于 ARMv5TE 的 CPU 生成代码。在 `Application.mk` 中使用参数 `APP_ABI` 选择不同的架构，例如（从以下列表中选择一行）：
- en: '[PRE34]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can specify multiple architectures to create a fat binary that will run
    on any of them through the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以指定多个架构，通过以下命令创建一个胖二进制文件，以便在任何架构上运行：
- en: '[PRE35]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The main pitfall of the fat binaries is the resulting `.apk` size, as separate
    native code versions are compiled for each of the specified architectures. If
    your application heavily uses third-party libraries, the package size can become
    an issue. Plan your deliverables wisely.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 胖二进制的主要缺点是生成的`.apk`大小，因为为每个指定的架构编译了单独的本地代码版本。如果你的应用程序大量使用第三方库，那么包大小可能会成为问题。请明智地规划你的交付物。
- en: Basic rendering with OpenGL ES
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenGL ES的基本渲染
- en: Let us add some graphics to our sample Android application `App2`. Here, we
    show how to create an off-screen bitmap, and then copy it to the screen using
    the OpenGL ES Version 2 or 3 available on your Android device.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为示例Android应用程序`App2`添加一些图形。在这里，我们展示了如何创建一个离屏位图，然后使用你Android设备上可用的OpenGL ES版本2或3将其复制到屏幕上。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the `App3` sample in the book's downloadable code bundle for the full
    source code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整源代码，请参考书中可下载代码包中的`App3`示例。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We assume that the reader is somewhat familiar with OpenGL and the **GL Shading
    Language** (**GLSL**). Refer to [http://www.opengl.org/documentation](http://www.opengl.org/documentation)
    for the desktop OpenGL, and [http://www.khronos.org/opengles](http://www.khronos.org/opengles)
    for the mobile OpenGL ES documentation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者对OpenGL和**GL着色语言**（**GLSL**）有一定的了解。有关桌面OpenGL的文档，请参考[http://www.opengl.org/documentation](http://www.opengl.org/documentation)，有关移动OpenGL
    ES的文档，请参考[http://www.khronos.org/opengles](http://www.khronos.org/opengles)。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We need to write a simple vertex and fragment GLSL shader that will render
    our framebuffer on the screen using OpenGL ES. Let''s put them directly into `jni/Wrappers.cpp`
    as strings. The following code shows the vertex shader:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写一个简单的顶点和片段GLSL着色器，它将使用OpenGL ES在屏幕上渲染我们的帧缓冲区。我们将它们直接作为字符串放入`jni/Wrappers.cpp`中。以下代码显示了顶点着色器：
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The fragment shader is as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器如下：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will also need the following helper function to load our shaders into OpenGL
    ES:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要以下帮助函数来将着色器加载到OpenGL ES中：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We will not go into all the details about the OpenGL ES programming here, and
    will instead focus on a minimal application (`App3`) that should initialize the
    `GLView` in Java; create fragment and vertex programs, create and fill the vertex
    array consisting of two triangles that form a single quadrilateral, and then render
    them with a texture, which is updated from `g_FrameBuffer` contents. This is it—just
    draw the offscreen framebuffer. The following is the code to draw the full-screen
    quad textured with the offscreen buffer content:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会详细介绍OpenGL ES编程的所有细节，而是专注于一个最小的应用程序（`App3`），它应该在Java中初始化`GLView`；创建片段和顶点程序，创建并填充由两个三角形组成的单一四边形的顶点数组，然后用纹理渲染它们，该纹理是从`g_FrameBuffer`内容更新的。就是这样——只需绘制离屏帧缓冲区。以下代码展示了用离屏缓冲区内容绘制全屏四边形的纹理：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These attribute variables are declared in a vertex shader. See the value of
    `g_vShaderStr[]` in the preceding code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性变量在顶点着色器中声明。请参考前面代码中的`g_vShaderStr[]`的值。
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also need a few JNI callbacks. The first one handles the surface size changes,
    as seen in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些JNI回调。第一个处理表面大小变化，如下代码所示：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Disable mip-mapping through the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码禁用纹理映射：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second callback does the actual frame rendering:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个回调实际执行帧渲染：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Invoke our frame rendering callback through the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码调用我们的帧渲染回调：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Going cross platform
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台开发
- en: The main idea is the possibility of cross-platform development in What You See
    (on a PC) is What You Get (on a device), when most of the application logic can
    be developed in a familiar desktop environment like Windows, and it can be built
    for Android using the NDK whenever necessary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是在 What You See (在PC上) is What You Get (在设备上) 的跨平台开发可能性，当大部分应用程序逻辑可以在像Windows这样的熟悉桌面环境中开发，并且必要时可以使用NDK为Android构建。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To perform what we just discussed, we have to implement some sort of abstraction
    on top of the NDK, POSIX, and Windows API. Such an abstraction should feature
    at least the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们刚才讨论的内容，我们必须在NDK、POSIX和Windows API之上实现某种抽象。这种抽象至少应该具备以下特点：
- en: '**Ability to render buffer contents on the screen**: Our framework should provide
    the functions to build the contents of an off-screen framebuffer (a 2D array of
    pixels) to the screen (for Windows we refer to the window as "the screen").'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能够在屏幕上渲染缓冲区内容**：我们的框架应该提供函数，将离屏framebuffer（一个2D像素数组）的内容构建到屏幕上（对于Windows，我们将窗口称为“屏幕”）。'
- en: '**Event handling**: The framework must be able to process the multi-touch input
    and virtual/physical key presses (some Android devices, such as the Toshiba AC
    100, or the Ouya console, and other gaming devices, have physical buttons), timing
    events, and asynchronous operation completions.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**：框架必须能够处理多点触控输入以及虚拟/物理按键按下（一些Android设备，如东芝AC 100，或者Ouya游戏机以及其他游戏设备具有物理按钮），定时事件以及异步操作完成。'
- en: '**Filesystem, networking, and audio playback**: The abstraction layers for
    these entities need a ton of work to be done by you, so the implementations are
    presented in [Chapter 3](ch03.html "Chapter 3. Networking"), *Networking*, [Chapter
    4](ch04.html "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual
    Filesystem*, and [Chapter 5](ch05.html "Chapter 5. Cross-platform Audio Streaming"),
    *Cross-platform Audio Streaming*.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统、网络和音频播放**：这些实体的抽象层需要你完成大量工作，因此实现在[第3章](ch03.html "第3章. 网络编程")，*网络编程*，[第4章](ch04.html
    "第4章. 组织虚拟文件系统")，*组织虚拟文件系统*，以及[第5章](ch05.html "第5章. 跨平台音频流")，*跨平台音频流*中介绍。'
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'Let us proceed to write a minimal application for the Windows environment,
    since we already have the application for Android (for example, `App1`). A minimalistic
    Windows GUI application is the one that creates a single window and starts the
    event loop (see the following example in `Win_Min1/main.c`):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续为Windows环境编写一个最小应用程序，因为我们已经有了Android的应用程序（例如，`App1`）。一个最小化的Windows GUI应用程序是指创建单一窗口并启动事件循环的应用程序（见以下`Win_Min1/main.c`中的示例）：
- en: '[PRE45]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The entry point is different from Android. However, its purpose remains the
    same— to initialize surface rendering and invoke callbacks:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入口点与Android不同。但其目的依然不变——初始化表面渲染并调用回调：
- en: '[PRE46]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The size of the window client area is predefined as `ImageWidth` and `ImageHeight`
    constants. However, the WinAPI function `CreateWindowA()` accepts not the size
    of the client area, but the size of the window, which includes caption, borders,
    and other decorations. We need to adjust the window rectangle to set the client
    area to the desired size through the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口客户区的尺寸预定义为`ImageWidth`和`ImageHeight`常量。然而，WinAPI函数`CreateWindowA()`接受的并非客户区的尺寸，而是包括标题栏、边框和其他装饰的窗口尺寸。我们需要通过以下代码调整窗口矩形，以将客户区设置为期望的尺寸：
- en: '[PRE47]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the offscreen device context and the bitmap, which holds our offscreen
    framebuffer through the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下代码创建离屏设备上下文和位图，该位图保存我们的离屏framebuffer：
- en: '[PRE48]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After the application''s window is created, we have to run a typical message
    loop:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序窗口后，我们必须运行一个典型的消息循环：
- en: '[PRE49]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This program only handles the window destruction event and does not render
    anything. Compilation of this program is done with a single command as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序只处理窗口销毁事件，并不渲染任何内容。编译此程序只需以下单一命令：
- en: '[PRE50]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To render a framebuffer on the screen, we need to create a so-called device
    context with an associated bitmap, and add the `WM_PAINT` event handler to the
    window function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上渲染一个framebuffer，我们需要创建一个所谓的设备上下文以及相关的位图，并在窗口函数中添加`WM_PAINT`事件处理程序。
- en: To handle the keyboard and mouse events, we add the `WM_KEYUP` and `WM_MOUSEMOVE`
    cases to the `switch` statement in the previous program. Actual event handling
    is performed in the externally provided routines `OnKeyUp()` and `OnMouseMove()`,
    which contain our game logic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理键盘和鼠标事件，我们在之前程序的`switch`语句中添加了`WM_KEYUP`和`WM_MOUSEMOVE`的情况。实际的事件处理在外部提供的例程`OnKeyUp()`和`OnMouseMove()`中执行，这些例程包含了我们的游戏逻辑。
- en: 'The following is the complete source code of the program (some omitted parts,
    similar to the previous example, are omitted). The functions `OnMouseMove()`,
    `OnMouseDown()`, and `OnMouseUp()` accept two integer arguments that store the
    current coordinates of the mouse pointer. The functions `OnKeyUp()` and `OnKeyDown()`
    accept a single argument—the pressed (or released) key code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序完整的源代码（省略的部分与之前的示例相似）。函数`OnMouseMove()`、`OnMouseDown()`和`OnMouseUp()`接受两个整数参数，用于存储鼠标指针的当前坐标。函数`OnKeyUp()`和`OnKeyDown()`接受一个参数——按下的（或释放的）键码：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the following code, we store our global RGBA framebuffer:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们存储全局RGBA帧缓冲区：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We do all OS-independent frame rendering in this callback. We draw a simple
    XOR pattern ([http://lodev.org/cgtutor/xortexture.html](http://lodev.org/cgtutor/xortexture.html))
    into the framebuffer as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个回调中完成所有与操作系统无关的帧渲染。我们绘制一个简单的XOR图案（[http://lodev.org/cgtutor/xortexture.html](http://lodev.org/cgtutor/xortexture.html)）到帧缓冲区中，如下所示：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following code shows the `WinAPI` window function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`WinAPI`窗口函数：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Transfer the `g_FrameBuffer` to the bitmap through the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码将`g_FrameBuffer`传输到位图：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And copy it to the window surface through the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过以下代码将其复制到窗口表面：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since our project contains a make file the compilation can be done via a single
    command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目包含一个make文件，因此可以通过单个命令完成编译：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Running this program should produce the result as shown in the following screenshot,
    which shows the **Win_Min2** example running on Windows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序应产生如下截图所示的结果，显示了在Windows上运行的**Win_Min2**示例：
- en: '![How it works…](img/7785_02_4.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/7785_02_4.jpg)'
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The main difference between the Android and Windows implementation of a main
    loop can be summarized in the following way. In Windows, we are in control of
    the main loop. We literally declare a loop, which pulls messages from the system,
    handles input, updates the game state, and render s the frame (marked green in
    the following figure). Each stage invokes an appropriate callback from our portable
    game (denoted with blue color in the following figure). On the contrary, the Android
    part works entirely differently. The main loop is moved away from the native code
    and lives inside the **Java Activity** and **GLSurfaceView** classes. It invokes
    the JNI callbacks that we implement in our wrapper native library (shown in red).
    The native wrapper invokes our portable game callbacks. Let''s summarize it in
    the following way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓和Windows对主循环的实现主要区别可以概括如下。在Windows中，我们控制主循环。我们声明一个循环，从系统中获取消息，处理输入，更新游戏状态，并渲染帧（在以下图中以绿色标记）。每个阶段调用我们可移植游戏中的适当回调（以下图中以蓝色表示）。相反，安卓部分的工作方式完全不同。主循环从本地代码中移出，并存在于**Java
    Activity**和**GLSurfaceView**类中。它调用我们在封装本地库中实现的JNI回调（以下图中以红色显示）。本地封装器调用我们的可移植游戏回调。以下是这样总结的：
- en: '![There''s more…](img/7785_02_05.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/7785_02_05.jpg)'
- en: The rest of the book is centered on this kind of architecture and the game functionality
    will be implemented inside these portable **On...()** callbacks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 书的其余部分以此类架构为中心，游戏功能将在这些可移植**On...()**回调中实现。
- en: There is yet another important note. Responding to timer events to create animation
    can be done on Windows with the `SetTimer()` call and the `WM_TIMER` message handler.
    We get to that in [Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"),
    *Porting Common Libraries,* when we speak about rigid body physics simulations.
    However, it is much better to organize a fixed time-step main loop, which is explained
    later in the book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的注意事项。对定时器事件做出响应以创建动画，在Windows上可以通过`SetTimer()`调用和`WM_TIMER`消息处理程序来完成。我们在[第2章](ch02.html
    "第2章.移植公共库")，*移植公共库*中讨论刚体物理模拟时会涉及到这一点。然而，组织一个固定时间步长主循环会更好，这在本书的后面会解释。
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 6](ch06.html "Chapter 6. Unifying OpenGL ES 3 and OpenGL 3"), *Unifying
    OpenGL ES 3 and OpenGL 3*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章.统一OpenGL ES 3和OpenGL 3")，*统一OpenGL ES 3和OpenGL 3*'
- en: The recipe *Implementing the main loop* in [Chapter 8](ch08.html "Chapter 8. Writing
    a Match-3 Game"), *Writing a Match-3 Game*
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章.编写消除类游戏")，*编写消除类游戏*中的食谱*实现主循环*'
- en: Unifying the cross-platform code
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一跨平台代码
- en: Right now, we have two different versions of a simple program (`Win_Min2` and
    `App3`). Let us see how to unify the common parts of the code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个简单程序的两个不同版本（`Win_Min2`和`App3`）。让我们看看如何统一代码的公共部分。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In Android, the application initialization phase is different, and since we
    use a mixed Java plus C++ approach, the entry points will be different. In C++,
    we are tied to, `int main()` or `DWORD WinMain()` functions; whereas in Android
    it is up to us to choose which JNI function we may call from our Java starter
    code. Event handling and rendering the initialization code are also quite different,
    too. To do so, we mark sections of the code with pre-processor definitions and
    put the different OS code into different files—`Wrappers_Android.h` and `Wrappers_Windows.h`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，应用程序初始化阶段是不同的，由于我们采用了混合Java和C++的方法，入口点也会有所不同。在C++中，我们依赖于`int main()`或`DWORD
    WinMain()`函数；而在Android中，我们可以从Java启动代码中调用我们选择的JNI函数。事件处理和初始化代码的渲染也有很大差异。为此，我们使用预处理器定义标记代码部分，并将不同操作系统的代码放入不同的文件中——`Wrappers_Android.h`和`Wrappers_Windows.h`。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We use the standard macros to detect the OS for which the program is being
    compiled: Windows-targeted compilers provide the `_WIN32` symbol definition, and
    the `__linux__` macro is defined on any Linux-based OS, including Android. However,
    the `__linux__` defination is not enough, since some of the APIs are missing in
    Android. The macro `ANDROID` is a non-standard macro and we pass the `-DANDROID`
    switch to our compiler to identify the Android target in our C++ code. To make
    this for every source file, we modify the `CFLAGS` variable in the `Android.mk`
    file.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标准宏来检测程序正在编译的目标操作系统：针对Windows的编译器提供`_WIN32`符号定义，而任何基于Linux的操作系统（包括Android）都会定义`__linux__`宏。然而，`__linux__`的定义还不够，因为Android中缺少一些API。`ANDROID`是一个非标准宏，我们向编译器传递`-DANDROID`开关，以便在我们的C++代码中识别Android目标。为了对每个源文件执行此操作，我们修改了`Android.mk`文件中的`CFLAGS`变量。
- en: 'Finally, when we write the low-level code, the detection looks like the following
    code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们编写低级代码时，检测看起来如下面的代码所示：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For example, to make an entry point look the same for both the Android and
    Windows versions, we write the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了使Android和Windows版本的入口点看起来相同，我们编写以下代码：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Later we will replace the `int main()` definition with the `APP_ENTRY_POINT()`
    macro.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将用`APP_ENTRY_POINT()`宏替换`int main()`的定义。
- en: There's more...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To detect more operating systems, compilers, and CPU architectures, it is useful
    to check out a list of predefined macros at [http://predef.sourceforge.net](http://predef.sourceforge.net).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测更多的操作系统、编译器和CPU架构，查看一下[http://predef.sourceforge.net](http://predef.sourceforge.net)上预定义的宏列表会很有帮助。
- en: Linking and source code organization
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接和源代码组织
- en: In the previous recipes, we learned how to create basic wrappers that allow
    us to run our application on Android and Windows. However, we used an ad-hoc approach
    since the amount of source code was low and fit into a single file. We have to
    organize our project source files in a way suitable for building the code for
    larger projects in Windows and Android.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们学习了如何创建基本的包装器，以允许我们的应用程序在Android和Windows上运行。然而，由于源代码量较少且适合放在单个文件中，我们采用了临时方法。我们必须以适合在Windows和Android上构建大型项目代码的方式组织我们的项目源文件。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Recall the folder structure of the `App3` project. We have the `src` and `jni`
    folders inside our `App2` folder. The `jni/Android.mk`, `jni/Application.mk`,
    and `build.xml` files specify the Android build process. To enable the Windows
    executable creation, we add a file named `Makefile`, which references the `main.cpp`
    file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下`App3`项目的文件夹结构。我们在`App2`文件夹中拥有`src`和`jni`文件夹。`jni/Android.mk`、`jni/Application.mk`和`build.xml`文件指定了Android构建过程。为了启用Windows可执行文件的创建，我们添加了一个名为`Makefile`的文件，该文件引用了`main.cpp`文件。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following is the content of `Makefile`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Makefile`的内容：
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The idea is that when we add more and more OS-independent logic, the code resides
    in `.cpp` files, which do not reference any OS-specific headers or libraries.
    For the first few chapters, this simple framework that delegates frame rendering
    and event handling to portable OS-independent functions (`OnDrawFrame()`, `OnKeyUp()`
    and so on) is enough.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加越来越多的与操作系统无关的逻辑时，代码位于`.cpp`文件中，这些文件不引用任何特定于操作系统的头文件或库。对于前几章，这个简单的框架足够了，它将帧渲染和事件处理委托给可移植的、与操作系统无关的函数（`OnDrawFrame()`、`OnKeyUp()`等）。
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All of our examples from the subsequent chapters are buildable for Windows from
    the command line using a single `make all` command. Android native code is buildable
    with a single `ndk-build` command. We will use this convention throughout the
    rest of the book.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节中的所有示例都可以通过命令行在 Windows 上使用单个 `make all` 命令进行构建。Android 原生代码也可以通过单个 `ndk-build`
    命令构建。我们将在本书的其余部分使用这个约定。
- en: Signing release Android applications
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名发布 Android 应用程序
- en: Now we can create a cross-platform application, debug it on a PC, and deploy
    it to Android devices. We cannot, however, upload it on Google Play because it
    is not (yet) signed properly with the release key.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个跨平台应用程序，在 PC 上进行调试，并将其部署到 Android 设备上。然而，我们还不能将其上传到 Google Play，因为它还没有（尚未）使用发布密钥正确签名。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A detailed explanation of the signing procedure on Android is given in the developer
    manual at [http://developer.android.com/tools/publishing/app-signing.html](http://developer.android.com/tools/publishing/app-signing.html).
    We will focus on the signing from the command line and automating the entire process
    via batch files.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Android 上签名过程的详细说明在开发者手册中有提供，地址是 [http://developer.android.com/tools/publishing/app-signing.html](http://developer.android.com/tools/publishing/app-signing.html)。我们将专注于从命令行进行签名，并通过批处理文件自动化整个流程。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First of all, we need to rebuild the project and create a release version of
    the `.apk` package. Let''s do it with our `App2` project:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要重新构建项目，并创建 `.apk` 包的发布版本。让我们用 `App2` 项目来完成这个操作：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should see a lot of text output from `Ant`, which ends with something like
    the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到来自 `Ant` 的很多文本输出，最后类似以下命令：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let us generate a self-signed release key using `keytool` from the JDK through
    the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 JDK 中的 `keytool` 通过以下命令生成一个自签名的发布密钥：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Fill out all the fields necessary for the key, as in the following command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 填写创建密钥所需的所有字段，如下面的命令所示：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we are ready to proceed with the actual application signing. Use the `jarsigner`
    tool from the JDK through the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进行实际的应用程序签名。使用 JDK 中的 `jarsigner` 工具通过以下代码进行操作：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This command is interactive, and it will require the user to enter the keystore
    password and the key password. However, we can provide passwords in a batch file
    in the following way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令是交互式的，它将要求用户输入密钥库密码和密钥密码。然而，我们可以通过以下方式在批处理文件中提供密码：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Passwords should match what you entered while creating your release key and
    keystore.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 密码应与创建发布密钥和密钥库时输入的信息相匹配。
- en: 'There is one more step left before we can safely publish our `.apk` package
    on Google Play. Android applications can access uncompressed content within `.apk`
    using `mmap()` calls. Yet, `mmap()` may imply some alignment restrictions on the
    underlying data. We need to align all uncompressed data within `.apk` on 4-byte
    boundaries. Android SDK has the `zipalign` tool to do it, as seen in the following
    command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够安全地在 Google Play 上发布 `.apk` 包之前，还有一步需要完成。Android 应用程序可以使用 `mmap()` 调用访问
    `.apk` 中的未压缩内容。然而，`mmap()` 可能会对底层数据施加一些对齐限制。我们需要将 `.apk` 中的所有未压缩数据按照 4 字节边界对齐。Android
    SDK 提供了 `zipalign` 工具来完成这个任务，如下面的命令所示：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now our `.apk` is ready to be published.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `.apk` 已经准备好发布。
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](ch02.html "Chapter 2. Porting Common Libraries"), *Porting Common
    Libraries*'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章. 移植通用库")，*移植通用库*'
