- en: Chapter 4. XamSnap - A Cross-Platform App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. XamSnap - 一个跨平台应用
- en: The best way to truly learn a programming skill, in my opinion, is to take on
    a simple project that requires you to exercise that skill. This gives new developers
    a project where they can focus on the concepts they are trying to learn without
    the overhead of fixing bugs or following customer requirements. To increase our
    understanding of Xamarin and cross-platform development, let's develop a simple
    app called XamSnap for iOS and Android.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，真正学会一项编程技能的最佳方式是接受一个需要运用该技能的简单项目。这给新开发者提供了一个可以专注于他们试图学习的概念的项目，而无需处理修复错误或遵循客户需求的负担。为了加深我们对
    Xamarin 和跨平台开发的理解，让我们为 iOS 和 Android 开发一个名为 XamSnap 的简单应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Our sample application concept
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的示例应用概念
- en: The Model layer of our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用的模型层
- en: Mocking a web service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟网络服务
- en: The ViewModel layer of our application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用的 ViewModel 层
- en: Writing unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Starting our sample application concept
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我们的示例应用概念
- en: 'The concept is simple: a simple clone of the popular chat application, Snapchat.
    There are several popular applications like this in the Apple App Store, probably
    due to the cost of text messaging and support for devices such as the iPod Touch
    or iPad. This should be a neat real-world example that could be useful for users,
    and will cover specific topics in developing applications for iOS and Android.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念很简单：流行的聊天应用 Snapchat 的一个简单克隆。由于短信成本和诸如 iPod Touch 或 iPad 等设备的支持，Apple App
    Store 中有几个这样的流行应用。这应该是一个对用户可能有用且涵盖为 iOS 和 Android 开发应用的具体主题的实用现实示例。
- en: 'Before starting with the development, let''s list the set of screens that we''ll
    need:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发之前，让我们列出我们需要的一组界面：
- en: '**Login / sign up**: This screen will include a standard login and sign-up
    process for the user.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录/注册**：这个界面将包括用户的标准化登录和注册过程。'
- en: '**List of conversations**: This screen will include a button to start a new
    conversation.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对话列表**：这个界面将包括一个启动新对话的按钮。'
- en: '**List of friends**: This screen will provide a way to add new friends when
    we start a new conversation.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**好友列表**：这个界面将提供一种在开始新对话时添加新好友的方法。'
- en: '**Conversation**: This screen will have a list of messages between you and
    another user, and an option to reply.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对话**：这个界面将展示你与其他用户之间的消息列表，并提供回复选项。'
- en: '**Camera**: In addition to text messages, Snapchat has the ability to send
    photos. We will add the option to use the device''s camera or photo library for
    sending photos.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**：除了文本消息，Snapchat 还具有发送照片的功能。我们将添加使用设备相机或照片库发送照片的选项。'
- en: 'So a quick wireframe layout of the application would help us grasp a better
    understanding of the layout of the app. The following figure shows the set of
    screens to be included in your app:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个快速的应用程序线框布局可以帮助我们更好地理解应用程序的布局。下图展示了应用中应包含的一组屏幕：
- en: '![Starting our sample application concept](img/image00211.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![启动我们的示例应用概念](img/image00211.jpeg)'
- en: Developing our model layer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的模型层
- en: Since we have a good idea of what the application is, the next step is to develop
    the business objects or model layer of this application. Let's start out by defining
    a few classes that would contain the data to be used throughout the app. It is
    recommended, for the sake of organization, to add these to a `Models` folder in
    your project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对应用有了很好的了解，下一步就是开发这个应用的商业对象或模型层。让我们首先定义几个类，这些类将包含整个应用中使用的数据。为了组织方便，建议将这些类添加到项目中的
    `Models` 文件夹中。
- en: 'Let''s begin with a class representing a user. The class can be created as
    follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表示用户的类开始。该类可以按以下方式创建：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pretty straightforward so far; let''s move on to create classes representing
    a conversation and a message as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止非常直观；接下来，我们按照以下方式创建表示对话和消息的类：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we are using strings as identifiers for the various objects; this
    will simplify our integration with a backend running as an Azure Function in later
    chapters. `UserName` is the value that would be set by the application to change
    the user that the object is associated with.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将字符串用作各种对象的标识符；这将简化我们与在后续章节中作为 Azure Function 运行的后端的集成。`UserName` 是应用程序设置的值，用于更改与对象关联的用户。
- en: 'Now let''s go ahead and set up our solution by performing the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续执行以下步骤来设置我们的解决方案：
- en: Start by creating a new solution as a new **Multiplatform | App | Single View
    App** project for iOS and Android.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建一个新的解决方案开始，作为iOS和Android的**多平台 | 应用 | 单视图应用**项目。
- en: Name the project `XamSnap` and make sure **Use Portable Class Library** is selected.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`XamSnap`，并确保已选择**使用可移植类库**。
- en: You could also choose to use a **Shared Project** for this project, but I've
    chosen to use a portable class library instead.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以选择为这个项目使用**共享项目**，但我更倾向于使用可移植类库。
- en: Click **Create** to create your solution in the designated directory.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**，在指定目录中创建你的解决方案。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just as in previous chapters, the steps for Visual Studio are a bit different.
    You will need to create a solution as a Portable Class Library, and *then* add
    the iOS and Android projects. Do not forget to add a reference to the PCL in both
    the iOS and Android projects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的章节一样，Visual Studio的步骤略有不同。你需要创建一个作为可移植类库的解决方案，并*然后*添加iOS和Android项目。不要忘记在iOS和Android项目中都添加对PCL的引用。
- en: Writing a mock web service
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模拟网络服务。
- en: Many times when developing a mobile application, you may need to begin the development
    of your application before the real backend web service is available. To prevent
    the development from halting entirely, a good approach would be to develop a mock
    version of the service. This is also helpful when you need to write unit tests,
    or are waiting on another team to develop the backend for your app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发移动应用时，你可能需要在真正的后端网络服务可用之前就开始开发你的应用。为了防止开发完全停滞，一个好的方法可能是开发一个服务的模拟版本。这在需要编写单元测试，或者等待另一个团队为你的应用开发后端时也很有帮助。
- en: 'First, let''s break down the operations our app will perform against a web
    server. The operations are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分解一下我们的应用将对网络服务器执行的操作。操作如下：
- en: Login with a username and password.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户名和密码登录。
- en: Register a new account.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个新账户。
- en: Get the user's list of friends.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的朋友列表。
- en: Add friends by their usernames.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过他们的用户名添加朋友。
- en: Get a list of the existing conversations for the user.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的现有会话列表。
- en: Get a list of messages in a conversation.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取会话中的消息列表。
- en: Send a message.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送消息。
- en: 'Now let''s define an interface that offers a method for each scenario. The
    method is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个接口，为每个场景提供一个方法。方法如下：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you see, we're simplifying any asynchronous communication with a web service
    by leveraging the **TPL** (**Task Parallel Library**) from the .NET base class
    libraries.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过利用.NET基类库中的**TPL**（**任务并行库**）简化了与网络服务的任何异步通信。
- en: Since communicating with a web service can be a lengthy process, it is always
    a good idea to use the `Task<T>` class for these operations. Otherwise, you could
    inadvertently run a lengthy task on the user interface thread, which would prevent
    user inputs during the operation. `Task` is definitely needed for web requests,
    since users could easily be using a cellular Internet connection on iOS and Android,
    and it will give us the ability to use the `async` and `await` keywords down the
    road.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与网络服务通信可能是一个漫长的过程，因此使用`Task<T>`类进行这些操作总是一个好主意。否则，你可能无意中在用户界面线程上运行一个耗时的任务，这将导致在操作期间无法接收用户输入。对于网络请求来说，`Task`绝对是必需的，因为用户可能正在iOS和Android上使用蜂窝网络连接，这将使我们能够以后使用`async`和`await`关键字。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are not familiar with async/await for simplified asynchronous programming
    in C#, it would be helpful to review the subject on MSDN at: [https://msdn.microsoft.com/en-us/library/mt674882.aspx](https://msdn.microsoft.com/en-us/library/mt674882.aspx)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉C#中用于简化异步编程的async/await，查看MSDN上的相关主题会很有帮助：[https://msdn.microsoft.com/en-us/library/mt674882.aspx](https://msdn.microsoft.com/en-us/library/mt674882.aspx)
- en: 'Now let''s implement a **fake** service that implements this interface. Place
    classes such as `FakeWebService` in the `Fakes` folder of the project. Let''s
    start with the class declaration and the first method of the interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现一个实现了此接口的**伪**服务。将如`FakeWebService`这样的类放在项目的`Fakes`文件夹中。让我们从类声明和接口的第一个方法开始：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We started off with a `SleepDuration` property to store a number in milliseconds.
    This is used to simulate an interaction with a web server, which can take some
    time. It is also useful for changing the `SleepDuration` value in different situations.
    For example, you might want to set this to a small number when writing unit tests
    so that the tests execute quickly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`SleepDuration`的属性开始，用于存储毫秒数。这用于模拟与Web服务器的交互，这可能需要一些时间。在不同情况下更改`SleepDuration`值也很有用。例如，在编写单元测试时，你可能希望将此值设置得较小，以便测试快速执行。
- en: Next, we implemented a simple `Sleep` method to return a task that introduces
    a delay of a number of milliseconds. This method will be used throughout the fake
    service to cause a delay on each operation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了一个简单的`Sleep`方法，该方法返回一个引入了若干毫秒延迟的任务。这个方法将在伪服务中用于在每个操作上造成延迟。
- en: Finally, the `Login` method merely used an `await` call on the `Sleep` method
    and returned a new `User` object with the appropriate `Name`. For now, any username
    or password combination will work; however, you may wish to write some code here
    to check specific credentials.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Login`方法只是在`Sleep`方法上使用了`await`调用，并返回了一个具有适当`Name`的新`User`对象。目前，任何用户名或密码组合都可以使用；但是，你可能希望在这里编写一些代码来检查特定的凭据。
- en: 'Now, let''s implement a few more methods to continue our `FakeWebService` class
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式继续实现`FakeWebService`类的几个更多方法：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each of these methods, we kept in mind exactly the same pattern as the `Login`
    method. Each method will delay and return some sample data. Feel free to mix up
    the data with your own values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些方法中的每一个，我们都遵循了与`Login`方法完全相同的模式。每个方法都将延迟并返回一些示例数据。请随意用你自己的值混合这些数据。
- en: 'Now, let''s implement the `GetConversations` method required by the interface
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实现接口所需的`GetConversations`方法：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Basically, we just create a new array of the `Conversation` objects with arbitrary
    IDs. We also make sure to match up the `UserName` values with what we used on
    the `User` objects so far.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只是创建了一个新的`Conversation`对象数组，这些对象的ID是任意的。我们还确保将`UserName`值与我们到目前为止在`User`对象上使用的值相匹配。
- en: 'Next, let''s implement `GetMessages` to retrieve a list of messages as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式实现`GetMessages`以获取消息列表：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, we are adding some arbitrary data here, and mainly making sure that
    `UserId` and `ConversationId` match our existing data so far.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在这里添加了一些任意数据，主要确保`UserId`和`ConversationId`与我们到目前为止的现有数据相匹配。
- en: 'And finally, we will write one more method to send a message as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将再编写一个如下所示发送消息的方法：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most of these methods are very straightforward. Note that the service doesn't
    have to work perfectly; it should merely complete each operation successfully
    with a delay. Each method should also return test data of some kind to be displayed
    in the UI. This will give us the ability to implement our iOS and Android applications
    while filling in the web service later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的大多数都非常直接。请注意，服务不必完美无缺；它应该只是在延迟后成功地完成每个操作。每个方法还应返回某种测试数据以在UI中显示。这将使我们能够在填充Web服务的同时实现我们的iOS和Android应用程序。
- en: 'Next, we need to implement a simple interface for persisting application settings.
    Let''s define an interface named `ISettings` as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为持久化应用程序设置实现一个简单的接口。让我们按照以下方式定义一个名为`ISettings`的接口：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are making `ISettings` synchronous, but you might want to set up the `Save`
    method to be asynchronous and return `Task` if you plan on storing settings in
    the cloud. We don't really need this with our application since we will only be
    saving our settings locally.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使`ISettings`同步，但如果你计划将设置存储在云端，你可能想要将`Save`方法设置为异步并返回`Task`。由于我们的应用程序只会在本地保存设置，所以实际上我们并不需要这样做。
- en: 'Later on, we''ll implement this interface on each platform using Android and
    iOS APIs. For now, let''s just implement a fake version that will be used later
    when we write unit tests. Implement the interface with the following lines of
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将在每个平台上使用Android和iOS API实现此接口。现在，让我们仅实现一个伪版本，稍后在编写单元测试时使用。使用以下代码行实现接口：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the fake version doesn't actually need to do anything; we just need
    to provide a class that will implement the interface and not throw any unexpected
    errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，伪版本实际上不需要执行任何操作；我们只需要提供一个实现接口的类，并且不抛出任何意外的错误。
- en: 'This completes the Model layer of the application. Here is a final class diagram
    of what we have implemented so far:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了应用程序的模型层。以下是我们到目前为止实现的最终类图：
- en: '![Writing a mock web service](img/image00212.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![编写一个模拟网络服务](img/image00212.jpeg)'
- en: Writing the ViewModel layer
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写ViewModel层
- en: Now that we have our model layer implemented, we can move on to write the ViewModel
    layer. The ViewModel will be responsible for presenting each operation to the
    UI and offering properties to be filled out by the View layer. Other common responsibilities
    of this layer are input validation and simple logic to display busy indicators.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经实现了模型层，现在可以继续编写ViewModel层了。ViewModel负责将每个操作呈现给UI，并提供由视图层填充的属性。这一层的其他常见职责包括输入验证和显示忙碌指示器的简单逻辑。
- en: At this point, it would be a good idea to include the `ServiceContainer` class
    from the previous chapter in our `XamSnap` PCL project, as we will be using it
    through our ViewModels to interact with the Model layer. We will be using it as
    a simple option to support dependency injection and Inversion of Control; however,
    you may use another library of your preference for this.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，将上一章中的`ServiceContainer`类包含到我们的`XamSnap` PCL项目中会是一个好主意，因为我们将会通过ViewModels与模型层交互时使用它。我们将用它作为一个简单的选项来支持依赖注入和控制反转；然而，你也可以选择你偏好的另一个库来实现这一点。
- en: 'Normally, we start off by writing a base class for all the ViewModel layers
    within our project. It''s a good place to put some parts of the code that are
    used by all the subclasses, for example: notification changes, methods, or commonly
    used interfaces.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们首先为项目中所有ViewModel层编写一个基类。这是一个放置所有子类使用的代码部分的好地方，例如：通知变更、方法或常用的接口。
- en: 'Place the following code snippet in a new `ViewModels` folder within your project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中的新`ViewModels`文件夹中放置以下代码片段：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `BaseViewModel` class is a great place to place any common functionality
    that you plan on reusing throughout your application. For this app, we only need
    to implement a way to indicate if the ViewModel layer is busy. We provided a property
    and an event that the UI will be able to subscribe to and display a wait indicator
    on the screen. We also added some fields for the services that will be needed.
    Another common feature that could be added would be validation for user inputs;
    however, we don't really need it for this application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseViewModel`类是放置你打算在应用程序中重复使用的任何公共功能的好地方。对于这个应用，我们只需要实现一种方法来指示ViewModel层是否忙碌。我们提供了一个属性和一个事件，UI将能够订阅并在屏幕上显示等待指示器。我们还添加了一些需要的服务字段。另一个可能添加的常见功能是对用户输入的验证；然而，这个应用程序并不真正需要它。'
- en: Implementing our LoginViewModel class
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的LoginViewModel类
- en: Now that we have a base class for all of the ViewModel layers, we can implement
    ViewModel for the first screen in our application, the **Login** screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经为所有的ViewModel层创建了一个基类，我们可以实现应用程序第一个屏幕的ViewModel，即**登录**屏幕。
- en: 'Now let''s implement a `LoginViewModel` class as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按照以下方式实现一个`LoginViewModel`类：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this class, we implemented the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们实现了以下功能：
- en: We subclassed `BaseViewModel` to get access to `IsBusy` and the fields containing
    common services
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继承了`BaseViewModel`，以获取`IsBusy`和包含公共服务的字段
- en: We added the `UserName` and `Password` properties to be set by the View layer
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`UserName`和`Password`属性，由视图层设置
- en: We added a `User` property to be set when the log in process is completed
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`User`属性，以在登录过程完成后设置
- en: We implemented a `Login` method to be called from View, with validation on `UserName`
    and `Password` properties
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了一个从视图调用的`Login`方法，对`UserName`和`Password`属性进行验证
- en: We set `IsBusy` during the call to the `Login` method on `IWebService`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在调用`IWebService`上的`Login`方法期间设置`IsBusy`
- en: We set the `User` property by awaiting the result from `Login` on the web service
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过等待网络服务的`Login`方法的结果来设置`User`属性
- en: Basically, this is the pattern that we'll follow for the rest of the ViewModels
    in the application. We provide properties for the View layer to be set by the
    user's input, and methods to call for various operations. If it is a method that
    could take some time, such as a web request, you should always return `Task` and
    use the `async` and `await` keywords.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这是我们将在应用程序的其余ViewModel中遵循的模式。我们为视图层提供由用户输入设置的属性，以及调用各种操作的方法。如果这是一个可能需要一些时间的方法，比如网络请求，你应当始终返回`Task`，并使用`async`和`await`关键字。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we used a `try` and `finally` block for setting `IsBusy` back to `false`.
    This will ensure it gets reset properly even when an exception is thrown. We plan
    on handling the error in the View layer, so we can display a native popup to the
    user displaying a message.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`try`和`finally`块来将`IsBusy`设置回`false`。这将确保即使在抛出异常时也能正确重置。我们计划在View层处理错误，这样我们就可以向用户显示本地弹窗，并显示一条消息。
- en: Implementing our RegisterViewModel class
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的RegisterViewModel类
- en: Since we have finished writing our `ViewModel` class to log in, we will now
    need to create one for the user's registration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了用于登录的`ViewModel`类的编写，我们现在需要创建一个用于用户注册的类。
- en: 'Let''s implement another ViewModel to register a new user:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现另一个ViewModel来注册新用户：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These properties will handle inputs from the user. Next, we need to add a `Register`
    method as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将处理用户的输入。接下来，我们需要按照以下方式添加一个`Register`方法：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `RegisterViewModel` class is very similar to the `LoginViewModel` class,
    but it has an additional `ConfirmPassword` property for the UI to set. A good
    rule to follow for when to split up the ViewModel layer's functionality is to
    always create a new class when the UI has a new screen. This helps to keep your
    code clean and somewhat follow the **single responsibility principle**for your
    classes. The **SRP** states that a class should only have a single purpose or
    responsibility. We'll try to follow this concept to keep our classes small and
    organized, which can be more important than usual when sharing code across platforms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterViewModel`类与`LoginViewModel`类非常相似，但它增加了一个`ConfirmPassword`属性，以便UI设置。关于何时拆分ViewModel层的功能，一个好的规则是：当UI有新屏幕时，始终创建一个新类。这有助于保持代码整洁，并在一定程度上遵循类的**单一职责原则（SRP）**。**SRP**指出，一个类应该只有一个目的或责任。我们将尝试遵循这一概念，使我们的类保持小而有序，这在跨平台共享代码时尤为重要。'
- en: Implementing our FriendViewModel class
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的FriendViewModel类
- en: Next on the list is a ViewModel layer to work with a user's friend list. We
    will need a method to load a user's friend list and add a new friend.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是处理用户朋友列表的ViewModel层。我们需要一个方法来加载用户的朋友列表并添加新朋友。
- en: 'Now let''s implement the `FriendViewModel` as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按照以下方式实现`FriendViewModel`：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we''ll need a method to load friends. This method is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一种加载朋友列表的方法。该方法如下：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we''ll need a method to add a new friend, and then update the list
    of friends contained locally:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个添加新朋友并更新本地朋友列表的方法：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, this class is fairly straightforward. The only thing new here is that
    we added some logic to update the list of friends and sort them within our client
    application and not the server. You could also choose to reload the complete list
    of friends if you have a good reason to do so.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个类相当直接。这里唯一的新东西是，我们添加了一些逻辑，在客户端应用程序中更新朋友列表并对其进行排序，而不是在服务器上。如果你有充足的理由，也可以选择重新加载整个朋友列表。
- en: Implementing our MessageViewModel class
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的MessageViewModel类
- en: Our final required ViewModel layer will be handling messages and conversations.
    We need to create a way to load conversations and messages, and send a new message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要的ViewModel层将处理消息和对话。我们需要创建一种加载对话和消息的方法，并发送新消息。
- en: 'Let''s start implementing our `MessageViewModel` class as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始按照以下方式实现我们的`MessageViewModel`类：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let''s implement a method to retrieve a list of conversations as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式实现获取对话列表的方法：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we need to retrieve a list of messages within a conversation. We
    will need to pass the conversation ID to the service as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要获取对话中的消息列表。我们需要将对话ID传递给服务，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to write some code to send a message and update the local
    list of messages as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一些代码来发送消息并更新本地消息列表，如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This concludes the ViewModel layer of our application and the entirety of the
    shared code used on iOS and Android. For the `MessageViewModel` class, you could
    have also chosen to put `GetConversations` and `Conversations` properties in their
    own class, since they could be considered as a separate responsibility, but it
    is not really necessary.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们应用程序的ViewModel层以及iOS和Android上使用的所有共享代码。对于`MessageViewModel`类，你也可以选择将`GetConversations`和`Conversations`属性放在它们自己的类中，因为它们可以被认为是一个单独的责任，但这并不是绝对必要的。
- en: 'Here is the final class diagram of our ViewModel layer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的ViewModel层的最终类图：
- en: '![Implementing our MessageViewModel class](img/image00213.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的MessageViewModel类](img/image00213.jpeg)'
- en: Writing unit tests
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Since all the code we've written so far is not dependent on the user interface,
    we can easily write unit tests against our classes. This step is generally taken
    after the first implementation of a `ViewModel` class. Proponents of **Test Driven
    Development** (**TDD)** would recommend writing tests first and implementing things
    afterward, so choose which method is best for you. In either case, it is a good
    idea to write tests against your shared code before you start using them from
    the View layer, so you catch bugs before they hold up your development on the
    UI.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们迄今为止编写的所有代码都不依赖于用户界面，我们可以轻松地针对我们的类编写单元测试。这一步通常在`ViewModel`类的首次实现之后进行。**测试驱动开发**（**TDD**）的倡导者会建议先编写测试，然后再实现功能，所以选择最适合你的方法。无论如何，在从视图层开始使用它们之前，针对共享代码编写测试是一个好主意，这样你可以在它们阻碍UI开发之前捕捉到错误。
- en: Xamarin projects take advantage of an open source testing framework called **NUnit**.
    It was originally derived from a Java testing framework called **JUnit**, and
    is the de-facto standard for unit testing C# applications. Xamarin Studio provides
    several project templates for writing tests with **NUnit**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin项目利用了一个名为**NUnit**的开源测试框架。它最初源自一个名为**JUnit**的Java测试框架，是进行C#应用程序单元测试的事实标准。Xamarin
    Studio提供了几个使用**NUnit**编写测试的项目模板。
- en: Setting up a new project for unit tests
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个用于单元测试的新项目
- en: 'Let''s set up a new project for unit tests by performing the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下步骤为单元测试设置一个新项目：
- en: Add a new **NUnit Library** **Project** to your solution, found under the **Other
    | .Net** section in Xamarin Studio. If using Visual Studio, create a .NET class
    library and add the NUnit NuGet package.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio的**其他 | .Net**部分，向你的解决方案中添加一个新的**NUnit库**项目。如果使用Visual Studio，则创建一个.NET类库并添加NUnit
    NuGet包。
- en: Name the project as `XamSnap.Tests` to keep things consistent.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`XamSnap.Tests`以保持一致性。
- en: Right-click on the project references and choose **Edit References**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目引用上右键点击，选择**编辑引用**。
- en: Under the **Projects** tab, add a reference to **XamSnap**, your existing portable
    class library.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**选项卡下，向**XamSnap**添加一个引用，这是你现有的可移植类库。
- en: 'Now, open the `Test.cs` file and notice the following required attributes that
    make up a unit test using NUnit:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`Test.cs`文件，注意以下构成使用NUnit单元测试的必要属性：
- en: '`using NUnit.Framework`: This attribute is the main statement to be used to
    work with NUnit'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using NUnit.Framework`：这个属性是使用NUnit时要使用的主要语句。'
- en: '`[TestFixture]`: This decorates a class to indicate that the class has a list
    of methods for running tests'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TestFixture]`：这个属性装饰一个类，表示该类有一系列用于运行测试的方法。'
- en: '`[Test]`: This decorates a method to indicate a test'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Test]`：这个属性装饰一个方法，表示这是一个测试。'
- en: 'In addition to the required C# attributes, there are several others that are
    useful for writing tests and they are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必要的C#属性之外，还有其他几个在编写测试时很有用的属性，如下所示：
- en: '`[TestFixtureSetUp]`: This decorates a method that runs before all the tests
    contained within a text fixture class.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TestFixtureSetUp]`：这个属性装饰一个方法，该方法在测试固件类中包含的所有测试之前运行。'
- en: '`[SetUp]`: This decorates a method that runs before each test in a test fixture
    class.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[SetUp]`：这个属性装饰一个方法，该方法在测试固件类中的每个测试前运行。'
- en: '`[TearDown]`: This decorates a method that runs after each test in a test fixture
    class.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TearDown]`：这个属性装饰一个方法，该方法在测试固件类中的每个测试后运行。'
- en: '`[TestFixtureTearDown]`: This decorates a method that runs after all the tests
    in a text fixture class have been completed.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[TestFixtureTearDown]`：这个属性装饰一个方法，该方法在测试固件类中的所有测试完成后运行。'
- en: '`[ExpectedException]`: This decorates a method that is intended to throw an
    exception. It is useful to test cases that are supposed to fail.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ExpectedException]`：这个属性装饰一个预期会抛出异常的方法。它用于测试那些应该失败的用例。'
- en: '`[Category]`: This decorates a test method and can be used to organize different
    tests; for example, you might categorize fast and slow tests.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Category]`：这个属性装饰一个测试方法，可以用来组织不同的测试；例如，你可能将快速测试和慢速测试进行分类。'
- en: Writing assertions
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写断言
- en: The next concept to learn about writing tests with NUnit is learning how to
    write **assertions**. An assertion is a method that will throw an exception if
    a certain value is not true. It will cause a test to fail and give a descriptive
    explanation as to what happened. NUnit has a couple of different sets of APIs
    for assertions; however, we will use the more readable and fluent version of the
    APIs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要学习的概念是使用 NUnit 编写测试时如何编写**断言**。断言是一个方法，如果某个值不是真的，它将抛出一个异常。这将导致测试失败，并给出发生情况的描述性解释。NUnit
    有几组不同的断言 API；然而，我们将使用更易读、更流畅的 API 版本。
- en: 'The basic syntax of fluent-style API is using the `Assert.That` method. The
    following example shows the this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅风格 API 的基本语法是使用 `Assert.That` 方法。以下示例展示了这一点：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Likewise, you can assert the opposite:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以断言相反的情况：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or any of the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者以下任意一项：
- en: Assert.That(myVariable, Is.GreaterThan(0));
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.That(myVariable, Is.GreaterThan(0));`'
- en: Assert.That(myBooleanVariable, Is.True);
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.That(myBooleanVariable, Is.True);`'
- en: Assert.That(myObject, Is.Not.Null);
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert.That(myObject, Is.Not.Null);`'
- en: Feel free to explore the APIs. With code completion in Xamarin Studio, you should
    be able to discover useful static members or methods on the `Is` class to use
    within your tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自由探索 APIs。在 Xamarin Studio 中，有了代码补全功能，你应该能够发现 `Is` 类中有用的静态成员或方法，以便在测试中使用。
- en: 'Before we begin writing specific tests for our application, let''s write a
    static class and method to create a global setup to be used throughout our tests;
    you can rewrite `Test.cs` as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们应用程序编写特定的测试之前，让我们编写一个静态类和方法，以创建在整个测试中使用的全局设置；你可以将 `Test.cs` 重写如下：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We'll use this method throughout our tests to set up fake services in our Model
    layer. Additionally, this replaces the existing services so that our tests execute
    against new instances of these classes. This is a good practice in unit testing
    to guarantee that no old data is left behind from a previous test. Also notice
    that we set `SleepDuration` to `0`. This will make our tests run very quickly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试中使用此方法来设置模型层中的假服务。此外，这会替换现有的服务，以便我们的测试针对这些类的新实例执行。这是单元测试中的一个好习惯，以确保之前的测试没有留下旧数据。还要注意，我们将
    `SleepDuration` 设置为 `0`。这将使我们的测试运行得非常快。
- en: 'Begin by creating a `ViewModels` folder in your test''s project and adding
    a class named `LoginViewModelTests` as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在测试项目中创建一个名为 `ViewModels` 的文件夹，并添加一个名为 `LoginViewModelTests` 的类，如下所示：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice our use of a `SetUp` method. We recreate the objects used in every test
    to make sure that no old data is left over from the previous test runs. Another
    point to note is that you must return a `Task` when using `async`/`await` in a
    test method. Otherwise, NUnit would not be able to know when a test completes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了 `SetUp` 方法。我们重新创建每个测试中使用的对象，以确保之前的测试运行没有留下旧数据。另一点需要注意的是，当在测试方法中使用 `async`/`await`
    时，你必须返回一个 `Task`。否则，NUnit 将无法知道测试何时完成。
- en: 'To run the test, use the NUnit menu found docked to the right of Xamarin Studio
    by default. Go ahead and run the test by using the **Run Test** button that has
    a gear icon; you should get a successful result similar to what is shown in the
    following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请使用默认停靠在 Xamarin Studio 右侧的 NUnit 菜单。使用带有齿轮图标的**运行测试**按钮来运行测试；你应该会得到一个类似以下截图所示的成功结果：
- en: '![Writing assertions](img/image00214.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![编写断言](img/image00214.jpeg)'
- en: 'You can also view the **Test Results** pane, which will show extended details
    if a test fails; as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看**测试结果**窗格，如果测试失败，它会显示扩展的详细信息；如下面的截图所示：
- en: '![Writing assertions](img/image00215.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![编写断言](img/image00215.jpeg)'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If using Visual Studio, you will need to install the **NUnit Test Adapter**
    extension from the Visual Studio gallery. You can find this option under the **Tools
    | Extensions and Updates** menu. The unit test runner in Visual Studio is just
    as intuitive as Xamarin Studio; however, it only supports MsTest out of the box.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Visual Studio，你将需要从 Visual Studio 库安装 **NUnit 测试适配器** 扩展。你可以在 **工具 | 扩展和更新**
    菜单下找到此选项。Visual Studio 中的单元测试运行器与 Xamarin Studio 一样直观；然而，它默认只支持 MsTest。
- en: 'To see what happens when a test fails, go ahead and modify your test to assert
    against an incorrect value as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看测试失败时会发生什么，请继续修改你的测试，按照以下方式针对错误值进行断言：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will get a very descriptive error in the **Test Results** pane, as shown
    in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在**测试结果**窗格中得到一个非常详细的错误，如下面的截图所示：
- en: '![Writing assertions](img/image00216.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![编写断言](img/image00216.jpeg)'
- en: 'Now let''s implement another test for the `LoginViewModel` class; let''s make
    sure we get the appropriate outcome if the username and password is blank. The
    test is implemented as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`LoginViewModel`类实现另一个测试；确保如果用户名和密码为空，我们能得到适当的结果。测试实现如下：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we run the test as is, we will get an exception and the test will fail.
    Since we expect an exception to occur, we can decorate the method to make the
    test pass only if an exception occurs, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样运行测试，将会捕获到一个异常，测试将失败。由于我们预期会发生异常，我们可以通过以下方式装饰该方法，使得只有当异常发生时测试才能通过：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that in our view model a generic `Exception` type is thrown if a **field
    is blank**. You can also change the type of expected exception in cases where
    it is a different exception type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的视图模型中，如果**字段为空**，则会抛出一个通用的`Exception`类型异常。在预期异常类型不同的情况下，你也可以更改预期异常的类型。
- en: More tests are included with the sample code along with this book. It is recommended
    to write tests against each public operation on each `ViewModel` class. Additionally,
    write tests for any validation or other important business logic. I would also
    recommend writing tests against the Model layer; however, it is not needed in
    our project yet since we only have fake implementations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 随书附带的示例代码中包含了更多测试。建议针对每个`ViewModel`类上的每个公共操作编写测试。此外，针对任何验证或其他重要的业务逻辑编写测试。我还建议针对模型层编写测试；然而，在我们的项目中还不需要，因为我们只有假的实现。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went over the concept for a sample application that we will
    be building throughout this book called XamSnap. We also implemented the core
    business objects for the application in the Model layer. Since we do not have
    a server to support this application yet, we implemented a fake web service. This
    gives us the flexibility to move forward with the app without building a server
    application. We also implemented the ViewModel layer. This layer will expose operations
    in a simple way to the View layer. Finally, we wrote tests covering the code we've
    written so far using NUnit. Writing tests against shared code in a cross-platform
    application can be very important, as it is the backbone of more than one application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了一个示例应用程序的概念，这个应用程序将在整本书中构建，名为XamSnap。我们还为应用程序在模型层实现了核心业务对象。由于我们还没有服务器来支持这个应用程序，我们实现了一个假的网络服务。这使得我们可以在不构建服务器应用程序的情况下继续开发应用程序。我们还实现了视图模型层。这一层将向视图层以简单的方式暴露操作。最后，我们使用NUnit编写了覆盖我们至今为止编写的代码的测试。在跨平台应用程序中对共享代码编写测试可能非常重要，因为它是多个应用程序的支柱。
- en: After completing this chapter, you should have completed the shared library
    for our cross-platform application in its entirety. You should have a very firm
    grasp on our application's architecture and its distinct Model and ViewModel layers.
    You should also have a good understanding on how to write fake versions of parts
    of your application that you may not be ready to implement quite yet. In the next
    chapter, we will implement the iOS version of XamSnap.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之后，你应该已经完整地完成了我们跨平台应用程序的共享库。你应该对应用程序的架构以及其独特的模型层和视图模型层有一个非常牢固的理解。你还应该了解如何编写应用程序部分可能还未能实现的假的版本。在下一章中，我们将实现XamSnap的iOS版本。
