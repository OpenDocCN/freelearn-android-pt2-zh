- en: Chapter 3. Material Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 材料模式
- en: So far in this book we have looked at how to represent objects and collections
    of objects by using design patterns to create them and the card view to display
    them. Before we can start to put together a working application, we need to consider
    how a user will input their selections. There are numerous ways to gather information
    from the user on a mobile device, such as menus, buttons, icons, and dialogs.
    Android layouts generally have an application bar (previously known as the action
    bar) that usually sits at the top of the screen just under the status bar and
    layouts that implement material design, very often employ a sliding navigation
    drawer to provide access to an app's top-level functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这部分，我们探讨了如何通过使用设计模式来创建对象和对象集合，以及如何使用卡片视图来展示它们。在我们开始构建一个可工作的应用程序之前，我们需要考虑用户将如何输入他们的选择。在移动设备上有许多方式可以从用户那里收集信息，比如菜单、按钮、图标和对话框。安卓布局通常有一个应用栏（以前称为操作栏），它通常位于屏幕顶部，紧挨着状态栏，而实现材料设计的布局，通常会采用滑动导航抽屉来提供对应用顶级功能的访问。
- en: As is often the case, the use of the support libraries, and in particular the
    **design library**, makes implementing material patterns such as the navigation
    bar remarkably easy, and material design contains visual patterns of its own that
    help encourage best UI practices. In this chapter, we will see how to implement
    the **app-bar**, the **navigation view**, and explore some of the visual patterns
    that material design provides. We will conclude with a quick look at the **singleton
    pattern**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用支持库，尤其是**设计库**，可以非常容易地实现如导航栏这样的材质模式，材料设计本身包含了一些视觉模式，有助于促进最佳的UI实践。在本章中，我们将学习如何实现**应用栏**、**导航视图**，并探索材料设计提供的一些视觉模式。最后，我们还将快速了解一下**单例模式**。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何进行以下操作：
- en: Replace the action bar with an app-bar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用应用栏替换操作栏
- en: Add action icons with the Asset Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资产工作室添加操作图标
- en: Apply app-bar actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用应用栏操作
- en: Control the app-bar at runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时控制应用栏
- en: Use a drawer layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽屉布局
- en: Add menus and sub-menus
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加菜单和子菜单
- en: Apply ratio keylines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用比例关键线
- en: Include a drawer listener
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个抽屉监听器
- en: Add fragments to an app
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用中添加片段
- en: Manage the fragment back stack
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理片段回退栈
- en: The app-bar
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用栏
- en: Android applications have always contained a toolbar at the top of the screen.
    This was traditionally used to provide a title along with access to a top-level
    menu, and was called the action bar. Since Android 5 (API level 21) and the inception
    of material design, it has been possible to replace this with the far more flexible
    app-bar. The app bar allows us to set its color, place it anywhere on the screen,
    and include a wider range of content than its predecessor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用一直以来都在屏幕顶部包含一个工具栏。传统上，这被用来提供一个标题以及访问顶级菜单，被称为操作栏。自从安卓5（API级别21）和材料设计的出现，这就可以用更灵活的应用栏来替代。应用栏允许我们设置其颜色，将其放置在屏幕的任何位置，并包含比其前身更广泛的内容。
- en: 'Most Android Studio templates use themes that include the old action bar as
    default, and the first thing we will need to do is remove the old version. To
    see how we remove the old action bar and replace it with a customized app-bar,
    follow these steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Android Studio模板使用的主题默认包含旧的操作栏，我们首先需要做的就是移除旧版本。要了解如何移除旧的操作栏并用定制的应用栏替换它，请按照以下步骤操作：
- en: Start a new Android project using an empty activity template and set your material
    theme using the theme editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用空活动模板启动一个新的安卓项目，并通过主题编辑器设置你的材料主题。
- en: 'Open the `styles.xml` file and edit the `style` definition to match the one
    here:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`styles.xml`文件，并编辑`style`定义以匹配这里的定义：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a new XML file alongside `activity_main.xml` and call it `toolbar.xml`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`旁边创建一个新的XML文件，并将其命名为`toolbar.xml`。
- en: 'Complete it like so:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成如下操作：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, add the following element to the `activity_main.xml` file:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`activity_main.xml`文件中添加以下元素：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, edit the margin values in the `dimens.xml` file as seen here:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像这样编辑`dimens.xml`文件中的边距值：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This toolbar is like any other ViewGroup in that it sits inside the root layout,
    so unlike the original action bar, it is not flush against the edges of the screen.
    This is why we needed to adjust the layout margins. Later, we will employ the
    CoordinatorLayout, which will automate much of this for us, but for now it is
    useful to see how it all works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具栏与其他任何ViewGroup一样，位于根布局内，因此与原始操作栏不同，它并不紧贴屏幕边缘。这就是为什么我们需要调整布局边距的原因。稍后，我们将使用CoordinatorLayout，它会自动完成其中许多工作，但现在了解其工作原理是有用的。
- en: 'The toolbar is now positioned and shaded like the original but has none of
    the content or functions. This can be done in the Java element of the activity
    by editing the `onCreate()` method like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏现在虽然位置和阴影与原始工具栏类似，但并没有内容和功能。这可以在活动的Java元素中通过编辑`onCreate()`方法来实现：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate an error. This is because there are two possible libraries
    that could be imported here. Press **Alt + Enter** and select the support version
    of the Toolbar like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个错误。这是因为这里可能导入两个库。按下**Alt + Enter**并选择如下所示的支持版本的Toolbar：
- en: '![The app-bar](img/image_03_001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![应用栏](img/image_03_001.jpg)'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To save time when working with Java, change the settings so that Java libraries
    are automatically imported when included in code. This is done from the **File**
    | **Settings** menu with **Editor** | **General** | **Auto Import**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在处理Java时节省时间，更改设置以便在代码中包含Java库时自动导入。这可以通过**文件** | **设置**菜单中的**编辑器** | **常规**
    | **自动导入**来完成。
- en: 'Testing the project on an emulator running API 20 or lower will immediately
    demonstrate one of the shortfalls of the AppCompat theme; despite declaring a
    color for our status bar `with colorPrimaryDark`, which works perfectly on API
    21 and higher, here it is still black:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行API 20或更低版本的模拟器上测试项目，会立即展示AppCompat主题的一个缺点；尽管我们为状态栏`with colorPrimaryDark`声明了一个颜色，这在API
    21及更高版本上完美运行，但在这里它仍然是黑色：
- en: '![The app-bar](img/image_03_002.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![应用栏](img/image_03_002.jpg)'
- en: However, this and the absence of natural-looking shadows is a small price to
    pay considering the number of people we can now reach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑到我们现在能够触及的受众数量，这种做法以及缺少自然阴影的代价是微不足道的。
- en: Now that we have replaced the old-fashioned action bar with a toolbar and set
    it as the app bar (sometimes called a primary toolbar) we can take a closer look
    at how it works and how to apply material-compliant action icons using the Asset
    Studio.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经用工具栏替换了过时的操作栏，并将其设置为应用栏（有时称为主工具栏），我们可以更仔细地了解其工作原理以及如何使用Asset Studio应用符合材质设计规范的行动图标。
- en: Image assets
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像资源
- en: 'It is quite possible to include text menus in the app-bar, but due to the limited
    space, it is more normal to use icons. Android Studio provides access to a collection
    of material icons via its Asset Studio. The following steps demonstrate how to
    do this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用栏中包含文本菜单是可能的，但由于空间有限，通常使用图标更为常见。Android Studio通过其Asset Studio提供了一组材质图标的访问。以下步骤将展示如何操作：
- en: From the drawable folder's menu in the project explorer, select **New | Image
    Asset**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中，从drawable文件夹的菜单选择**新建 | 图像资源**。
- en: Then select **Action Bar and Tab Icons** as the **Asset Type** and then click
    on the **Clipart** icon and select an icon from the collection of clip art:![Image
    assets](img/image_03_003.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择**操作栏和标签图标**作为**资源类型**，接着点击**剪贴画**图标，从剪贴画集中选择一个图标：![图像资源](img/image_03_003.jpg)
- en: This image must be trimmed, with 0% padding.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这张图片需要修剪，且填充为0%。
- en: Choose a theme depending on whether your toolbar background color is light or
    dark.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据工具栏背景颜色是浅色还是深色选择一个主题。
- en: Provide a suitable name and click on **Next**:![Image assets](img/image_03_004.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个合适的名称并点击**下一步**：![图像资源](img/image_03_004.jpg)
- en: Tip
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A much larger collection of material icons can be downloaded from the following
    URL: [https://design.google.com/icons](https://design.google.com/icons)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以从以下URL下载更多材质图标集合：[https://design.google.com/icons](https://design.google.com/icons)
- en: The asset studio automatically creates icons for us across four screen densities
    and places them in the correct folders so that they are deployed on the appropriate
    devices. It even applies the required **54% opaque black** that material design
    uses for icons. All we have to do to include these in our app bar is to add an
    icon property to the appropriate menu item. Later, we will use a navigation drawer
    to provide top-level access, but to see how to use an app-bar, we will add a search
    function. The icon we chose for this is called `ic_action_search`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 资产工作室自动为我们跨四种屏幕密度创建图标，并将它们放置在正确的文件夹中，以便它们能够部署在适当的设备上。它甚至应用了材料设计用于图标所需的**54%不透明黑色**。要在我们的应用栏中包含这些，只需在适当的菜单项中添加一个图标属性。稍后，我们将使用导航抽屉提供顶级访问，但要了解如何使用应用栏，我们将添加一个搜索功能。我们为此选择的图标叫做
    `ic_action_search`。
- en: Applying actions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用操作
- en: 'Action icons are kept in the drawable folders and can be included in our action
    bar by including `items` within menu XML files. Depending on which template you
    used when first creating the project, you may have to add a new directory, `res/menu`,
    and a file called `main.xml` or `menu_main.xml` or whatever you choose as a **New
    | Menu resource file**. Actions can be added like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 操作图标保存在可绘制文件夹中，并且可以通过在菜单XML文件中包含 `items` 来包含在我们的操作栏中。根据您最初创建项目时使用的模板，您可能需要添加一个新目录
    `res/menu` 和一个名为 `main.xml` 或 `menu_main.xml` 的文件，或者您选择作为 **新建 | 菜单资源文件** 的其他名称。可以像这样添加操作：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the preceding example uses a reference to a string resource, and
    so must be accompanied by a definition in the `strings.xml` file like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例使用了对字符串资源的引用，因此必须在 `strings.xml` 文件中伴有如下定义：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Menu items are automatically included in the app bar, with the title being taken
    from the `string name="app_name"` definition in the strings file. When constructed
    in this fashion, these components are positioned according to material guidelines.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项会自动包含在应用栏中，其标题取自字符串文件中的 `string name="app_name"` 定义。以这种方式构建时，这些组件会根据材料设计指南进行定位。
- en: 'To see this in action, follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际效果，请按照以下步骤操作：
- en: 'Open the main Java activity and add this field:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开主Java活动并添加这个字段：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then add these lines to the `onCreate()` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将这些行添加到 `onCreate()` 方法中：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, add the following method to the activity:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在活动中添加以下方法：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We should now be able to see our new toolbar on a device or emulator:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够在设备或模拟器上看到我们的新工具栏：
- en: '![Applying actions](img/image_03_005.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![应用操作](img/image_03_005.jpg)'
- en: Being able to add any view we like to a toolbar makes it far more effective
    than the old action bar. We can have more than one at a time and they can even
    be placed elsewhere by applying layout gravity properties. The toolbar even comes
    with its own methods as we saw previously with the title and subtitle. We can
    also add icons and logos with these methods, but before we do so, it would be
    a good idea to explore app bar best practice according to material design guidelines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将我们喜欢的任何视图添加到工具栏，这使得它比旧的操作栏更有效。我们可以同时拥有多个，并且通过应用布局重力属性，它们甚至可以被放置在其他地方。正如之前所见，工具栏还带有自己的方法，可以通过这些方法添加图标和标志，但在这样做之前，根据材料设计指南探索应用栏的最佳实践会是一个好主意。
- en: App bar structure
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用栏结构
- en: Although the techniques we have applied here conform to material guidelines
    without us having to do very much other than ensure its height, there will still
    be times when we are replacing the action bar with a custom toolbar layout, and
    we will need to know how to space and position the components. These are slightly
    different for tablets and desktops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这里应用的技术符合材料设计指南，我们除了确保其高度外不需要做很多工作，但在用自定义工具栏布局替换操作栏时，我们仍需要知道如何间隔和定位组件。这些在平板电脑和桌面上略有不同。
- en: Phones
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手机
- en: 'There are just a few simple structural rules to remember when it comes to app
    bars. These cover margins, padding, width, height, and positioning, and they differ
    across platforms and screen orientation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用栏方面，只需记住一些简单的结构规则。这些规则涵盖了边距、填充、宽度、高度和定位，并且在不同平台和屏幕方向上有所不同。
- en: The `layout_height` of an app bar in portrait mode is `56 dp` and `48 dp` in
    landscape.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用栏在纵向模式下的 `layout_height` 为 `56 dp`，在横向模式下为 `48 dp`。
- en: App bars fill either the screen width or the width of their containing column.
    They cannot be divided into two. They have a `layout_width` of `match_parent`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用栏填充屏幕宽度或其包含列的宽度。它们不能被分成两个部分。它们的 `layout_width` 为 `match_parent`。
- en: An app bar has an `elevation``2 dp` greater than the sheet of material it controls.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用栏的 `elevation` 比它控制的材质纸张高 `2 dp`。
- en: The exception to the preceding rule is if a card or dialog has its own toolbar,
    then the two can share the same elevation.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一条规则的例外情况是，如果卡片或对话框有自己的工具栏，那么两者可以共享相同的阴影高度。
- en: App bars have padding of exactly `16 dp`. This means the contained icons must
    have no padding or margins of their own and therefore share edges with this margin:![Phones](img/image_03_006.jpg)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用栏的填充恰好为 `16 dp`。这意味着包含的图标不能有自己的填充或边距，因此与这个边距共享边缘：![手机](img/image_03_006.jpg)
- en: The title text takes its color from your theme's primary text color and icons
    from secondary text.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题文本的颜色取自您主题的主文本颜色，图标则取自辅助文本颜色。
- en: The title should be positioned `72 dp` from the left of the toolbar and `20
    dp` from the bottom. This applies even when the toolbar is expanded:![Phones](img/image_03_007.jpg)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题应位于工具栏左侧 `72 dp` 和底部 `20 dp` 的位置。即使工具栏展开时也适用此规则：![手机](img/image_03_007.jpg)
- en: The Title's text size is set with `android:textAppearance="?android:attr/textAppearanceLarge"`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题文本大小通过 `android:textAppearance="?android:attr/textAppearanceLarge"` 进行设置。
- en: Tablets
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平板电脑
- en: 'When constructing app bars for tablets and desktops, the rules are identical,
    with the following exceptions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在为平板电脑和桌面构建应用栏时，规则相同，以下是一些例外：
- en: The toolbar height is always `64 dp`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具栏的高度始终为 `64 dp`。
- en: The title is indented by `80 dp` and does not move down when the bar is expanded.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题向内缩进 `80 dp`，并且在工具栏展开时不会向下移动。
- en: The app bar's padding is `24 dp`, with the exception of the top, where it is
    `20 dp`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用栏的填充为 `24 dp`，顶部除外，那里是 `20 dp`。
- en: We have succeeded in constructing an app bar according to material guidelines,
    but action icons are of no use if they do not perform an action. In essence, when
    an app-bar assumes action bar functionality, it is really simply an access point
    to a menu. We will return to menus and dialogs later, but for now we will take
    a quick look at how toolbars can be manipulated at runtime with Java code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经按照材质设计指南构建了一个应用栏，但如果没有执行操作，操作图标是没有用的。本质上，当应用栏承担操作栏功能时，它实际上只是一个菜单的访问点。我们稍后会回到菜单和对话框，但现在我们将快速了解一下如何使用
    Java 代码在运行时操作工具栏。
- en: The changes that have been made to the old action bar make it an easy and intuitive
    view to place global actions. The space, however, is limited, and for a more complex
    and graphical navigation component, we can turn to the sliding drawer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对旧操作栏所做的更改使其成为一个放置全局操作的简单直观视图。然而，空间有限，对于更复杂和图形化的导航组件，我们可以转向滑动抽屉。
- en: The navigation drawer
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航抽屉
- en: 'Although it is possible to have sliding drawers appear from either side of
    the screen, the navigation drawer should always be on the left and should have
    a higher elevation than all other views apart from the status and navigation bars.
    Think of the navigation drawer as a permanent fixture that spends most of its
    time hidden just off the edge of the screen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以让抽屉从屏幕的任一侧滑出，但导航抽屉应始终位于左侧，并且其阴影高度应高于除状态栏和导航栏之外的所有其他视图。将导航抽屉视为一个大部分时间隐藏在屏幕边缘之外的固定装置：
- en: '![The navigation drawer](img/image_03_008.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![导航抽屉](img/image_03_008.jpg)'
- en: Prior to the design library, components such as the navigation view had to be
    constructed from other views, and although the library vastly simplifies this
    process and saves us having to implement many material principles by hand, there
    are still several guidelines that we need to be aware of. The best way to appreciate
    these is by building a navigation sliding drawer from scratch. This will involve
    creating the layouts, applying material guidelines regarding component ratios,
    and connecting all this together with code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计库之前，必须使用其他视图构建如导航视图之类的组件，尽管库极大地简化了这一过程，并使我们不必手动实现许多材质原则，但仍有一些指南需要我们注意。了解这些的最佳方式是从头开始构建一个导航滑动抽屉。这将涉及创建布局，应用关于组件比例的材质设计指南，并通过代码将所有这些连接起来。
- en: Drawer construction
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽屉构建
- en: 'You will no doubt have noticed when setting up projects that Android Studio
    provides a **Navigation Drawer Activity** template. This creates much of the structure
    we might need and saves quite a bit of work. Once we have decided what features
    our sandwich building app will have, we will use this template. However, it is
    far more instructive to put one together from scratch to see how it works, and
    with this in mind, we will create a drawer layout that requires icons that can
    easily be found via the Asset Studio:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你在设置项目时无疑已经注意到，Android Studio 提供了一个 **Navigation Drawer Activity** 模板。这为我们创建了很多可能需要的内容，并节省了大量工作。一旦我们决定了我们的三明治制作应用将具有哪些功能，我们将使用这个模板。然而，从头开始构建一个更有教育意义，可以看到它是如何工作的，基于这个想法，我们将创建一个需要通过
    Asset Studio 轻松找到图标的抽屉布局：
- en: Open an Android Studio project with a minimum SDK level of 21 or higher and
    provide it with your own customized colors and theme.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个最低 SDK 级别为21或更高的 Android Studio 项目，并提供你自己的自定义颜色和主题。
- en: 'Add the following line to your `styles.xml` file:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `styles.xml` 文件中添加以下行：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Make sure you have the following dependency compiled:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经编译了以下依赖项：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you are not using the same project we used in the previous section, set up
    an app-bar layout called `toolbar.xml`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有使用前一部分中的同一个项目，请设置一个名为 `toolbar.xml` 的 app-bar 布局。
- en: 'Open `activity_main` and replace the code with the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main` 并用以下代码替换：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the root layout here is the **DrawerLayout** as provided by
    the support library. Note the `fitsSystemWindows` property; this is what makes
    the drawer extend up to the top of the screen under the status bar. Having set
    the `statusBarColor` to `android:color/transparent` in the style, the drawer is
    now visible through the status bar.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里的根布局是由支持库提供的 **DrawerLayout**。注意 `fitsSystemWindows` 属性；这就是使得抽屉延伸到状态栏下方的屏幕顶部的原因。在样式中将
    `statusBarColor` 设置为 `android:color/transparent`，抽屉现在可以通过状态栏看到。
- en: This effect is not available on devices running Android versions older than
    5.0 (API 21), even with AppCompat, and this will alter the apparent aspect ratio
    of the header and clip any images. To counter this, create an alternative `styles.xml`
    resource that does not set the `fitsSystemWindows` property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用 AppCompat，这个效果在运行 Android 5.0（API 21）以下版本的设备上也是不可用的，这将改变标题的显示宽高比并裁剪任何图片。为了解决这个问题，创建一个不设置
    `fitsSystemWindows` 属性的替代 `styles.xml` 资源。
- en: The rest of the layout consists of a LinearLayout and the **NavigationView**
    itself. The linear layout contains our app bar and an empty **FrameLayout**. FrameLayouts
    are the simplest of layouts, containing only a single item and generally used
    as a placeholder, which in this case will contain content based on the user's
    selection from the navigation menu.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 布局的其余部分包括一个 LinearLayout 和 **NavigationView** 本身。这个线性布局包含我们的应用栏和一个空的 **FrameLayout**。FrameLayout
    是最简单的布局，只包含单个条目，通常用作占位符，在这种情况下，它将根据用户从导航菜单中的选择来包含内容。
- en: 'As can be seen from the preceding code, we will need a layout file for the
    header and a menu file for the drawer itself. The `header.xml f`ile should be
    created in the `layout` directory and look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码可以看出，我们需要一个用于标题的布局文件和一个用于抽屉本身的菜单文件。`header.xml` 文件应该在 `layout` 目录中创建，并如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will need to add the following value to the `dimens.xml` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要向 `dimens.xml` 文件中添加以下值：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you will see, we will need an image for the header. Here, it is called `header_background`
    and should have an aspect ratio of 4:3.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要一张用作标题的图片。这里称它为 `header_background`，它的宽高比应该是4:3。
- en: 'If you test this layout on devices with different screen densities, you will
    very soon see that this aspect ratio is not maintained. This can be easily countered
    in a similar way to the manner that we manage image resources, by using configuration
    qualifiers. To do this, follow the simple steps outlined here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个布局在不同的屏幕密度设备上进行测试，你很快就会发现这个宽高比没有得到保持。我们可以通过类似管理图像资源的方式，使用配置限定符来轻松解决这个问题。为此，请按照这里概述的简单步骤操作：
- en: Create new directories for each density range with names such as `values-ldpi`,
    `values-mdpi`, and so on up to `values-xxxhdpi`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个密度范围创建新的目录，其名称如 `values-ldpi`、`values-mdpi` 等，直至 `values-xxxhdpi`。
- en: Make a copy of the `dimens.xml` file in each folder.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个文件夹中复制一份 `dimens.xml` 文件。
- en: Set the value of `header_height` in each file to match that screen density.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个文件中设置 `header_height` 的值，以匹配该屏幕密度。
- en: 'The menu file is called `menu_drawer.xml` and should be placed in the `menu`
    directory, which you may need to create as well. Each item has an associated icon,
    and these can all be found in the Asset Studio. The code itself should match the
    following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单文件名为`menu_drawer.xml`，应放置在`menu`目录中，你可能需要创建这个目录。每个项目都有一个关联的图标，这些都可以在资源工作室中找到。代码本身应与以下内容相匹配：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Most of the metrics of sliding drawers and navigation views such as margins
    and text sizes are taken care of for us thanks to the design library. However,
    the size, position, and color of text on a drawer header are not. Despite sharing
    a background, the text should be thought of as a 56-dp high component in its own
    right. It should have an internal padding of 16-dp and an 8-dp spacing between
    the lines. This, along with the correct text color, size, and weight can be derived
    from the preceding code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计库，滑动抽屉和导航视图的大部分度量标准（如边距和文本大小）都为我们处理好了。然而，抽屉标题上的文本大小、位置和颜色并没有。尽管共享背景，但文本应该被认为是一个本身高度为56-dp的组件。它应该有16-dp的内部填充和8-dp的行间距。这，加上正确的文本颜色、大小和权重可以从前面的代码中得出。
- en: Ratio keylines
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比例关键线
- en: 'When an element such as a sliding drawer fills the entire height of a screen
    and is divided into vertical segments, as our drawer is, between header and content,
    then these divisions can occur only at certain points known as ratio keylines.
    These points are determined by the ratio between the width of the element and
    how far from the top the division occurs. There are six such ratios allowed in
    material layouts, and they are defined as width to height (`width:height`) and
    are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素（如滑动抽屉）填满整个屏幕的高度，并被分为垂直段时，如我们的抽屉在标题和内容之间，那么这些分段只能在某些点发生，这些点称为比例关键线。这些点由元素的宽度和距离顶部发生分割的比例决定。在材料布局中有六种这样的比例，它们定义为宽高比（`width:height`），如下所示：
- en: '16:9'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '16:9'
- en: '3:2'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3:2'
- en: '4:3'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4:3'
- en: '1:1'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1:1'
- en: '3:4'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3:4'
- en: 2:3![Ratio keylines](img/image_03_009.jpg)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2:3![比例关键线](img/image_03_009.jpg)
- en: In the example here, a 4:3 ratio was chosen, and the width of the drawer is
    256 dp. We could also have produced a header with a 16:9 ratio and set the `layout_height`
    at 144 dp.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，选择了4:3的比例，抽屉的宽度为256 dp。我们还可以制作一个具有16:9比例的标题，并将`layout_height`设置为144 dp。
- en: 'Ratio keylines only relate to the distance from the top of the containing element;
    you cannot have one 16:9 view below another. However, you can place another view
    beneath this if it extends from the bottom of the top view down to another of
    the ratio keylines:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 比例关键线仅与包含元素的顶部距离有关；你不能在一个16:9视图下方再放置另一个。但是，如果另一个视图从顶部视图的底部延伸到另一条比例关键线，你可以在其下方放置另一个视图：
- en: '![Ratio keylines](img/image_03_010.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![比例关键线](img/image_03_010.jpg)'
- en: Activating the drawer
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活抽屉
- en: 'All that remains now is to implement some code in Java to get the layout working.
    This is done through a listener callback method that is called when the user interacts
    with the drawer. The following steps demonstrate how this is achieved:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是用Java实现一些代码，让布局工作。这是通过监听回调方法实现的，当用户与抽屉交互时调用。以下步骤演示了如何实现这一点：
- en: 'Open the MainActivity file and add the following lines in the `onCreate()`
    method to replace the action bar with our toolbar:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开MainActivity文件，并在`onCreate()`方法中添加以下行，用我们的工具栏替换动作栏：
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Beneath this, add these lines to configure the drawer:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之下，添加以下行来配置抽屉：
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, add this code to set up the navigation view:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加此代码来设置导航视图：
- en: '[PRE19]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Activating the drawer](img/image_03_011.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![激活抽屉](img/image_03_011.jpg)'
- en: The preceding Java code allows us to view our drawer on a device or emulator
    but does very little when a navigation item is selected. What we really need to
    do is to actually be taken to another part of the app. This is very simply achieved,
    and we will come to it in a moment. First, there are one or two points in the
    preceding code that require a mention.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Java代码允许我们在设备或模拟器上查看抽屉，但在选择导航项时几乎不起作用。我们真正需要做的是实际上跳转到应用程序的另一部分。这很容易实现，我们稍后会介绍。首先，在前面代码中有一两点需要提一下。
- en: The line beginning `ActionBarDrawerToggle` is what causes the hamburger that
    opens the drawer to appear on the app bar, although you can of course open it
    with an inward swipe from the left of the screen. The two string arguments, `openDrawer`
    and `closeDrawer`, are for reasons of accessibility and are read out for users
    who are unable to see the screen clearly. They should say something like Navigation
    drawer opening and Navigation drawer closing. The two callback methods `onDrawerOpened()`
    and `onDrawerClosed()` were left empty here, but demonstrate where these events
    can be intercepted.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `ActionBarDrawerToggle` 开头的这行代码是导致应用栏上出现打开抽屉的汉堡包图标的代码，当然，你也可以从屏幕左侧向内滑动来打开它。两个字符串参数
    `openDrawer` 和 `closeDrawer` 是出于可访问性考虑的，它们会被读给那些看不清屏幕的用户听，应该表述为类似“导航抽屉打开”和“导航抽屉关闭”。两个回调方法
    `onDrawerOpened()` 和 `onDrawerClosed()` 在这里留空了，但它们展示了可以拦截这些事件的位置。
- en: The call to `drawerLayout.closeDrawers()` is essential, as otherwise the drawer
    would remain open. Here, we used the debugger to test the output, but ideally
    what we want is for the menu to direct us to another part of the application.
    This is not a difficult task and also provides a good opportunity to introduce
    one of the SDK's most useful and versatile classes, the **fragment**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `drawerLayout.closeDrawers()` 是必不可少的，因为否则抽屉将保持打开状态。在这里，我们使用了调试器来测试输出，但理想情况下我们希望菜单能引导我们到应用的其他部分。这并不是一个困难的任务，同时也提供了一个很好的机会来介绍
    SDK 中最有用和多功能的类之一，即**碎片**。
- en: Adding fragments
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加碎片
- en: From what we have learned so far, it would be safe to imagine that separate
    activities would be used for apps with more than one function, and although this
    is often the case it can be an expensive drain on resources and activities always
    fill the entire screen. Fragments operate like mini-activities, in that they have
    both Java and XML definitions and many of the same callbacks and functionality
    that activities do. Unlike activities, fragments are not top level components
    and must reside within a host activity. The advantage of this is that we can have
    more than one fragment per screen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前所学到的知识，可以想象为具有多个功能的 apps 会使用单独的活动，尽管这通常是情况，但它们可能会成为资源的昂贵消耗，并且活动总是占据整个屏幕。碎片就像迷你活动，它们既有
    Java 也有 XML 定义，并且具有与活动相同的许多回调和功能。与活动不同，碎片不是顶级组件，必须驻留在宿主活动中。这种做法的优点是我们可以拥有一个屏幕上的多个碎片。
- en: 'To see how to do this, create a new Java class called something like `ContentFragment`
    and complete it as follows, making sure you import the `android.support.v4.app.Fragment`
    rather than the standard version:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何做到这一点，请创建一个新的 Java 类，比如叫 `ContentFragment`，然后按照以下步骤完成它，确保导入的是 `android.support.v4.app.Fragment`
    而不是标准版本：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As for the XML element, create a layout file called `content.xml` and place
    whatever views and widgets you choose inside. All that is needed now is the Java
    code to call it when a navigation item is selected.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 XML 元素，创建一个名为 `content.xml` 的布局文件，并在其中放置你选择的任意视图和小部件。现在需要的只是当选择导航项时调用它的 Java
    代码。
- en: 'Open the `MainActivity.Java` file and replace one of the Debug calls in the
    `switch` statement with this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.Java` 文件，并在 `switch` 语句中用以下内容替换一个 Debug 调用：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The example we have built here is solely to demonstrate the basic anatomy of
    drawer layouts and navigation views. Clearly, to add any real functionality, we
    would need a fragment for each item in our menu, and the line `transaction.addToBackStack(null);`
    is actually redundant unless we do so. Its function is to ensure that the order
    a user accesses each fragment is recorded by the system in the same way it records
    which activities are used, so that when they press the back key they will return
    to the previous fragment. Without it, they would be returned to the previous application
    and the container activity would be destroyed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的示例只是为了演示抽屉布局和导航视图的基本结构。显然，要添加任何实际的功能，我们需要为菜单中的每个项都准备一个碎片，除非这样做，否则 `transaction.addToBackStack(null);`
    这行代码实际上是多余的。它的功能是确保系统以记录使用哪个活动的方式记录用户访问每个碎片的顺序，这样当用户按下返回键时，他们将返回到上一个碎片。如果没有它，他们将被返回到上一个应用，而容器活动将被销毁。
- en: Right handed drawers
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 右手抽屉
- en: 'As a top-level navigation component, the sliding drawer should only ever slide
    in from the left and should follow the metrics outlined earlier. However, it is
    very easy to have drawers that slide in from the right, and for many secondary
    functions this can be desirable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为顶级导航组件，滑动抽屉应该只从左侧滑入，并遵循之前概述的度量标准。然而，要实现从右侧滑入的抽屉非常容易，对于许多次要功能来说，这可能是有吸引力的：
- en: '![Right handed drawers](img/image_03_012.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![右手侧抽屉](img/image_03_012.jpg)'
- en: 'Making a sliding drawer appear from the right is simply a matter of setting
    layout gravity, for example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让滑动抽屉从右侧出现仅是设置布局重力的问题，例如：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unlike the traditional navigation view, which should never be wider than the
    screen width minus the height of the primary app-bar, a right-handed drawer can
    extend across the entire screen.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的导航视图不同，它不应比屏幕宽度减去主应用栏的高度更宽，而右手侧抽屉可以延伸到整个屏幕。
- en: The whole of this chapter has been about UI design, and we have not come across
    any design patterns. We could have used patterns here but chose to concentrate
    on the mechanics of Android UIs. We will see later in the book how useful the
    facade pattern can be to simplify coding a complex menu or layout.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容一直关于UI设计，我们还没有遇到过任何设计模式。我们本可以在这里使用设计模式，但选择专注于Android UI的机制。我们将在本书的后面看到，门面模式对于简化复杂菜单或布局的编码非常有用。
- en: One design pattern that could be introduced almost anywhere is the singleton.
    This is because it can be used almost anywhere and its purpose is to provide a
    global instance of an object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以在任何地方引入的一个设计模式是单例模式。这是因为它几乎可以在任何地方使用，其目的是提供一个对象的全球实例。
- en: The singleton pattern
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式。
- en: 'The singleton is easily the simplest of patterns, but it is also one of the
    most controversial. Many developers think it entirely unnecessary and that declaring
    a class as static performs the same function with less fuss. Although it is true
    that the singleton is widely overused when a static class would be the cleaner
    choice, there are certainly times when one is preferable to the other:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式无疑是所有模式中最简单的一个，但同时也是最具争议的一个。许多开发者认为它完全没必要，认为将一个类声明为静态可以达到相同的功能，而且更为简单。尽管单例模式确实在许多本可以使用静态类的情况下被过度使用，但确实存在一些场合，单例模式比静态类更为合适：
- en: Use a static class when you want a function performed on a variable you pass
    to it, for example, calculating the discount value on a price variable
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要对一个传递给它的变量执行函数时，使用静态类，例如，计算价格变量的折扣值。
- en: Use a singleton pattern when you want a complete object, but only one, and you
    want that object to be available to any part of the program, for example, an object
    representing the individual user currently logged into an app
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要一个完整的对象，但只有一个，并且希望这个对象可以被程序的任何部分访问时，使用单例模式，例如，代表当前登录应用的个人用户的对象。
- en: 'The class diagram for the singleton is, as you would imagine, remarkably simple,
    as you can see here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的类图，正如你所想象的，非常简单，正如你在这里看到的：
- en: '![The singleton pattern](img/image_03_013.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![单例模式](img/image_03_013.jpg)'
- en: As the preceding diagram suggests, the following example will assume we only
    have one user logged into our app at any one time and are going to create a singleton
    object that we can reach from any part of our code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图表所示，以下示例假设我们一次只登录一个用户到我们的应用，并且我们将创建一个可以从代码任何部分访问的单例对象。
- en: Android Studio provides for singleton creation under the project explorer's
    **New** menu, so we can start there. There are only two steps to this demonstration;
    they are as follows.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio在项目资源管理器的**新建**菜单下提供了单例创建功能，因此我们可以从这里开始。这个演示只有两个步骤，如下所示。
- en: 'Add this class to your project:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个类添加到你的项目中：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Test the pattern by adding code like the following to the activity:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向活动中添加如下代码来测试这个模式：
- en: '[PRE24]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The singleton can be extremely useful, but it is easy to apply it unnecessarily.
    It is very handy when tasks are asynchronous, such as filing systems, and when
    we want access to its contents from anywhere in the code, such as the user name
    in the preceding example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式可能非常有用，但很容易不必要地使用它。在异步任务时非常有用，如文件系统，并且当我们希望从代码的任何地方访问其内容时，比如前面示例中的用户名。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Whatever the purpose of an app, users need a familiar way to access it functions.
    The app-bar and navigation drawer are not only easily understood by the user,
    but provide great flexibility.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 无论应用的目的如何，用户需要一种熟悉的方式来访问它的功能。应用栏和导航抽屉不仅容易被用户理解，而且提供了极大的灵活性。
- en: In this chapter, we have seen how to apply two of the most significant input
    mechanisms available on Android devices and the material patterns that govern
    their appearance. The SDK, and in particular the design library, make coding these
    structure both simple and intuitive. Although different from the design patterns
    we have met so far, material patterns serve a similar function and guide us towards
    better practice.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何在安卓设备上应用两种最重要的输入机制以及控制它们外观的材料设计模式。"SDK，尤其是设计库，使得编写这些结构既简单又直观。尽管与迄今为止我们遇到的设计模式不同，但材料设计模式发挥着类似的功能，并指导我们走向更好的实践。
- en: The next chapter continues to look into layout design and explores the tools
    available to us when it comes to putting entire layouts together and how we manage
    to develop for a wide variety of screen shapes and sizes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节将继续探讨布局设计，并研究在组合整个布局时我们可以使用的工具，以及我们如何设法开发适应各种屏幕形状和大小的应用。
