- en: Chapter 1. Activities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 活动
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节包括以下食谱：
- en: Declaring an activity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个活动
- en: Starting a new activity with an intent object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图对象启动新活动
- en: Switching between activities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动之间切换
- en: Passing data to another activity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向另一个活动传递数据
- en: Returning a result from an activity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从活动中返回结果
- en: Saving an activity's state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存活动状态
- en: Storing persistent activity data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储持久活动数据
- en: Understanding the activity lifecycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解活动生命周期
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: The Android SDK provides a powerful tool to program mobile devices, and the
    best way to master such a tool is to jump right in. Though you can read this book
    from beginning to end, as it is a cookbook, it is specifically designed to allow
    you to jump to specific tasks and get the results immediately.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK提供了一个强大的工具来编程移动设备，掌握这个工具的最佳方式是直接开始。虽然你可以从头到尾阅读这本书，因为这是一本食谱，但它特别设计成允许你跳转到特定任务并立即获得结果。
- en: '**Activities** are the fundamental building block of most Android applications
    as the activity class provides the interface between the application and screen.
    Most Android applications will have at least one activity, if not several (but
    they are not required). A background service application will not necessarily
    require an activity if there is no user interface.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动**是大多数Android应用的基本构建块，因为活动类提供了应用与屏幕之间的接口。大多数Android应用至少会有一个活动，如果不是几个（但并非必须）。如果后台服务应用没有用户界面，则不一定需要活动。'
- en: This chapter explains how to *declare* and *launch* activities within an application
    and how to manage several activities at once by sharing data between them, requesting
    results from them, and calling one activity from within another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节解释如何在应用程序中*声明*和*启动*活动，以及如何通过在它们之间共享数据、从它们请求结果和从一个活动内部调用另一个活动来同时管理多个活动。
- en: This chapter also briefly explores the **intent** object, which is often used
    in conjunction with activities. Intents can be used to transfer data between activities
    in your own application, as well as in external applications, such as those included
    with the Android operating system (a common example would be to use an intent
    to launch the default web browser).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节还简要探讨了通常与活动结合使用的**意图**对象。意图可以用于在您自己的应用程序中的活动之间传输数据，以及在外部应用程序中，如Android操作系统（一个常见的例子是使用意图启动默认的网页浏览器）。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To begin developing Android applications, head over to the **Android Studio**
    page to download the new Android Studio IDE and the **Android SDK** bundle:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始开发Android应用程序，请访问**Android Studio**页面下载新的Android Studio IDE和**Android SDK**捆绑包：
- en: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)'
- en: Declaring an activity
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个活动
- en: Activities and other application components, such as **services**, are declared
    in the `AndroidManifest` XML file. Declaring an activity is how we tell the system
    about our activity and how it can be requested. For example, an application will
    usually indicate that at least one activity should be visible as a desktop icon
    and serve as the main entry point to the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和其他应用组件，如**服务**，是在`AndroidManifest` XML文件中声明的。声明活动是我们告诉系统关于我们的活动以及如何请求它的方式。例如，一个应用通常会指出至少有一个活动应该作为桌面图标可见，并作为进入应用的主要入口。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Android Studio is the new tool used to develop Android applications, replacing
    the now-deprecated **Eclipse ADT** solution. Android Studio will be used for all
    the recipes shown in this book, so if you have not already installed it, visit
    the Android Studio website (the link has been provided earlier) to install the
    IDE and the SDK bundle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio是新的用于开发Android应用程序的工具，取代了现在已弃用的**Eclipse ADT**解决方案。本书将使用Android
    Studio展示所有食谱，因此如果你还没有安装它，请访问Android Studio网站（链接已提供）以安装IDE和SDK捆绑包。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this first example, we''ll guide you through creating a new project. Android
    Studio provides a **Quick Start** wizard, which makes the process extremely easy.
    Follow these steps to get started:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，我们将指导你创建一个新项目。Android Studio提供了一个**快速入门**向导，使得这个过程非常简单。按照以下步骤开始：
- en: Launch Android Studio, which brings up the **Welcome to Android Studio** dialog.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Android Studio，会出现**欢迎使用Android Studio**对话框。
- en: Click on the **Start a new Android Studio project** option.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始一个新的Android Studio项目**选项。
- en: Enter an application name; for this example, we have used `DeclareAnActivity`.
    Click on **Next**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入应用程序名称；对于此示例，我们使用了`DeclareAnActivity`。点击**下一步**。
- en: On the **Add an Activity to Mobile** dialog, click on the **Blank Activity**
    button, and then click on **Next**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**将活动添加到移动设备**对话框中，点击**空白活动**按钮，然后点击**下一步**。
- en: On the **Target Android Devices** dialog, chose **Android 6.0 (API 23)** as
    the minimum SDK (for this example, it really doesn't matter which API level you
    chose, as activities have existed since API level 1, but choosing the latest release
    is considered to be the best practice). Click on **Next**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目标Android设备**对话框中，选择**Android 6.0（API 23）**作为最低SDK（对于此示例，你选择哪个API级别其实并不重要，因为自从API级别1以来就已经存在活动，但选择最新版本被认为是最佳实践）。点击**下一步**。
- en: Since we chose the **Blank Activity** option earlier, the **Customize the Activity**
    dialog is shown. You can leave the defaults as provided, but note the default
    activity name is `MainActivity`. Click on **Finish**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们之前选择了**空白活动**选项，所以会显示**自定义活动**对话框。你可以保留提供的默认设置，但注意默认的活动名称是`MainActivity`。点击**完成**。
- en: After finishing the wizard, Android Studio will create the project files. For
    this recipe, the two files that we will examine are `MainActivity.java` (which
    corresponds to the activity name mentioned in Step 6) and `AndroidManifest.xml`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完成向导后，Android Studio将创建项目文件。对于此示例，我们将要检查的两个文件是`MainActivity.java`（对应于第6步中提到的活动名称）和`AndroidManifest.xml`。
- en: 'If you take a look at the `MainActivity.java` file, you will realize that it''s
    pretty basic. This is because we chose the **Blank Activity** option (in Step
    4). Now look at the `AndroidManifest.xml` file. This is where we actually declare
    the activity. Within the `<application>` element is the `<activity>` element:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`MainActivity.java`文件，你会发现它非常基础。这是因为我们选择了**空白活动**选项（在第4步）。现在看看`AndroidManifest.xml`文件。这里是我们实际声明活动的地方。在`<application>`元素内是`<activity>`元素：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When viewing this `xml` within Android Studio, you may notice that the label
    element shows the actual text as defined in the `strings.xml` resource file. This
    is just a small example of enhancements in the new IDE.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中查看此`xml`时，你可能会注意到标签元素显示了`strings.xml`资源文件中定义的实际文本。这是新IDE中增强功能的一个小例子。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Declaring an activity is a simple matter of declaring the `<activity>` element
    and specifying the name of the activity class with the `android:name` attribute.
    By adding the `<activity>` element to the **Android Manifest**, we are specifying
    our intention to include this component within our application. Any activities
    (or any other component for that matter) that are not declared in the manifest
    will not be included in the application. Attempting to access or utilize an undeclared
    component will result in an exception being thrown at runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个活动只需简单声明`<activity>`元素，并使用`android:name`属性指定活动类的名称。将`<activity>`元素添加到**Android
    Manifest**中，我们是在表明意图将此组件包含在应用程序内。任何未在清单中声明的活动（或其他任何组件）都不会被包含在应用程序中。尝试访问或使用未声明的组件将在运行时抛出异常。
- en: In the preceding code, there is another attribute—`android:label`. This attribute
    indicates the title shown on the screen as well as the icon label if this is the
    Launcher activity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，还有一个属性—`android:label`。此属性表示屏幕上显示的标题以及如果这是启动器活动的话图标标签。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a complete list of available application attributes, take a look at this
    resource:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用应用程序属性的全部列表，请查看以下资源：
- en: '[http://developer.android.com/guide/topics/manifest/activity-element.html](http://developer.android.com/guide/topics/manifest/activity-element.html)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/guide/topics/manifest/activity-element.html](http://developer.android.com/guide/topics/manifest/activity-element.html)'
- en: Starting a new activity with an intent object
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图对象启动新活动
- en: The Android application model can be seen as a service-oriented one, with activities
    as components and intents as the messages sent between them. Here, an intent is
    used to start an activity that displays the user's call log, but intents can be
    used to do many things and we will encounter them throughout this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序模型可以看作是一种面向服务的模型，活动作为组件，意图作为它们之间传递的消息。这里，一个意图用于启动显示用户通话记录的活动，但意图可以用作很多事情，我们将在本书中多次遇到它们。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To keep things simple, we are going to use an intent object to start one of
    Android's built-in applications rather than create a new one. This only requires
    a very basic application, so start a new Android project with Android Studio and
    call it `ActivityStarter`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，我们将使用一个意图对象来启动Android的一个内置应用程序，而不是创建一个新的应用程序。这只需要一个非常基础的应用程序，因此用Android
    Studio启动一个新的Android项目，并将其命名为`ActivityStarter`。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Again, to keep the example simple so that we can focus on the task at hand,
    we will create a function to show an intent in action and call this function from
    a button on our activity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让示例简单，以便我们专注于手头的任务，我们将创建一个函数来展示一个意图操作，并从活动中的按钮调用这个函数。
- en: 'Once your new project is created in Android Studio, follow these steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建新项目后，请按照以下步骤操作：
- en: 'Open the `MainActivity.java` class and add the following function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`类，并添加以下函数：
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While you are typing this code, Android Studio will give this warning on View
    and intent: **Cannot resolve symbol ''Intent''**.'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你输入这段代码时，Android Studio会对View和意图给出这个警告：**无法解析符号'Intent'**。
- en: 'This means that you need to add the library reference to the project. You can
    do this manually by entering the following code in the `import` section:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着你需要将库引用添加到项目中。你可以通过在`import`部分手动输入以下代码来实现这一点：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alternatively, just click on the words (in the red font), hit *Alt* + *Enter*,
    and let Android Studio add the library reference for you.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，只需点击红色字体的文字，按*Alt* + *Enter*，让Android Studio为你添加库引用。
- en: 'Open the `activity_main.xml` file and add the following XML:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，并添加以下XML代码：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![How to do it...](img/05057_01_01.jpg)'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/05057_01_01.jpg)'
- en: Now it's time to run the application and see the intent in action. You will
    need to either create an Android emulator (in Android Studio, go to **Tools |
    Android | AVD Manager**) or connect a physical device to your computer.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是运行应用程序并查看意图操作的时候了。你需要创建一个Android模拟器（在Android Studio中，转到**工具 | Android | AVD管理器**）或者将一个物理设备连接到你的电脑。
- en: When you press the **Launch Browser** button, you will see the default web browser
    open with the URL specified.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你按下**启动浏览器**按钮时，你会看到默认的网页浏览器打开，并显示指定的URL。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Though simple, this app demonstrates much of the power behind the Android OS.
    The intent object is just a message object. Intents can be used to communicate
    across your application's components (such as services and broadcast receivers)
    as well as with other applications on the device (as we did in this recipe).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个应用很简单，但它展示了Android操作系统背后的许多强大功能。意图对象只是一个消息对象。意图可以用于在应用程序的组件之间（如服务和广播接收器）以及与其他设备上的应用程序进行通信（正如本例中所做的那样）。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To test on a physical device, you may need to install drivers for your device
    (the drivers are specific to the hardware manufacturer). You will also need to
    enable Developer Mode on your device. Enabling Developer Mode varies according
    to the Android OS version. If you do not see the Developer Mode option in your
    device settings, open the **About Phone** option and begin tapping **Build Number**.
    After three taps, you should see a **Toast** message telling you that you are
    on your way to be a developer. Four more taps will enable the option.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在物理设备上测试，你可能需要为你的设备安装驱动程序（驱动程序针对硬件制造商是特定的）。你还需要在设备上启用开发者模式。启用开发者模式根据Android操作系统版本而有所不同。如果你在设备设置中看不到开发者模式选项，打开**关于手机**选项，并开始点击**构建号**。点击三次后，你应该会看到一个**Toast**消息，告诉你正在成为开发者的路上。再点击四次将启用该选项。
- en: 'In this recipe, we created an intent object by specifying `ACTION_VIEW` as
    what we want to do (our intention). You may have noticed that when you typed `Intent`
    and then the period, Android Studio provided a pop-up list of possibilities (this
    is the autocomplete feature), like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们通过指定`ACTION_VIEW`作为我们想要执行的操作（我们的意图）来创建一个意图对象。你可能已经注意到，当你输入`Intent`然后输入句点时，Android
    Studio提供了一个弹出式可能性的列表（这是自动完成功能），如下所示：
- en: '![How it works...](img/05057_01_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/05057_01_02.jpg)'
- en: '`ACTION_VIEW`, along with a URL in the data, indicates that the intention is
    to view the website, so the default browser is launched (different data could
    launch different apps). In this example, our intent is just to view the URL, so
    we call the intent with just the `startActivity()` method. There are other ways
    to call the intent depending on our needs. In the *Returning a result from an
    activity* recipe, we will use the `startActivityForResult()` method.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACTION_VIEW`与数据中的URL一起，表示意图是查看网站，因此会启动默认浏览器（不同的数据可能会启动不同的应用）。在这个例子中，我们的意图只是查看URL，所以我们仅使用`startActivity()`方法调用意图。根据我们的需求，还有其他调用意图的方法。在*从活动中返回结果*的食谱中，我们将使用`startActivityForResult()`方法。'
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: It's very common for Android users to download their favorite apps for web browsing,
    taking photos, text messaging, and so on. Using intents, you can let your app
    utilize your user's favorite apps instead of trying to reinvent all of this functionality.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android用户来说，下载他们喜欢的网页浏览、拍照、发短信等应用是非常常见的。使用意图，您可以允许您的应用利用用户喜欢的应用，而不是试图重新发明所有这些功能。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To start an activity from a menu selection, refer to the *Handling menu selections*
    recipe in [Chapter 4](ch04.html "Chapter 4. Menus"), *Menus*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 若要从菜单选择启动一个活动，请参考[第4章](ch04.html "第4章. 菜单")中的*处理菜单选择*部分，*菜单*。
- en: Switching between activities
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在活动之间切换
- en: Often we will want to activate one activity from within another activity. Although
    this is not a difficult task, it will require a little more setting up to be done
    than the previous recipes as it requires two activities. We will create two activity
    classes and declare them both in the manifest. We'll also create a button, as
    we did in the previous recipe, to switch to the activity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会在一个活动内部激活另一个活动。尽管这不是一个困难的任务，但它需要比之前的食谱更多的设置，因为它需要两个活动。我们将创建两个活动类，并在清单中声明它们。我们还将创建一个按钮，就像在之前的食谱中所做的那样，以切换到活动。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll create a new project in Android Studio, just as we did in the previous
    recipes, and call this one `ActivitySwitcher`. Android Studio will create the
    first activity, `ActivityMain`, and automatically declare it in the manifest.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Android Studio中创建一个新项目，就像在之前的食谱中所做的那样，并将这个项目命名为`ActivitySwitcher`。Android
    Studio将创建第一个活动`ActivityMain`，并在清单中自动声明。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Since the Android Studio New Project wizard has already created the first activity,
    we just need to create the second activity. Open the **ActivitySwitcher** project
    and navigate to **File** | **New** | **Activity** | **Blank** **Activity**, as
    shown in this screenshot:![How to do it...](img/05057_01_03.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Android Studio新项目向导已经创建了第一个活动，我们只需要创建第二个活动。打开**ActivitySwitcher**项目，并按照此截图所示导航至**文件**
    | **新建** | **活动** | **空白活动**：![如何操作...](img/05057_01_03.jpg)
- en: In the **Customize the Activity** dialog, you can leave the default **Activity
    Name** as it is, which is `Main2Activity`, or change it to `SecondActivity`, as
    shown here:![How to do it...](img/05057_01_04.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**自定义活动**对话框中，您可以保留默认的**活动名称**，即`Main2Activity`，或者像这里显示的那样更改为`SecondActivity`：![如何操作...](img/05057_01_04.jpg)
- en: 'Open the `MainActivity.java` file and add the following function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件，并添加以下函数：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, open the `activity_main.xml` file located in the `\res\layout` folder
    and add the following XML to create the button:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开位于`\res\layout`文件夹中的`activity_main.xml`文件，并添加以下XML代码来创建按钮：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can actually run the code at this point and see the second activity come
    up. We''re going to go further and add a button to `SecondActivity` to close it,
    which will bring us back to the first activity. Open the `SecondActivity.java`
    file and add this function:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，您现在可以运行代码，并看到第二个活动出现。我们将会更进一步，在`SecondActivity`中添加一个按钮来关闭它，这将带我们回到第一个活动。打开`SecondActivity.java`文件，并添加此函数：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, add the **Close** button to the `SecondActivity` layout. Open the
    `activity_second.xml` file and add the following `<Button>` element just after
    the `<TextView>` element that was generated automatically:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`SecondActivity`布局中添加**关闭**按钮。打开`activity_second.xml`文件，并在自动生成的`<TextView>`元素之后添加以下`<Button>`元素：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the application on your device or emulator and see the buttons in action.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备或模拟器上运行应用程序，并查看按钮的实际效果。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The real work of this exercise is in the `onClickSwitchActivity()` method from
    Step 3\. This is where we declare the second activity for the intent using `SecondActivity.class`.
    We went one step further by adding the close button to the second activity to
    show a common real-world situation—launching a new activity, then closing it,
    and returning to the original calling activity. This behavior is accomplished
    in the `onClickClose()` function. All it does is call `finish()`, but that tells
    the system that we're done with the activity. Finish doesn't actually return us
    to the calling activity or any specific activity for that matter; it just closes
    the current activity and relies on the **back stack**. If we want a specific activity,
    we can again use the intent object (we just change the class name while creating
    the intent).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的真正工作在于第3步中的 `onClickSwitchActivity()` 方法。在这里，我们使用 `SecondActivity.class`
    为意图声明第二个活动。我们通过在第二个活动中添加关闭按钮，展示了常见的实际场景——启动一个新活动，然后关闭它，并返回到原始调用活动。这种行为是在 `onClickClose()`
    函数中实现的。它所做的只是调用 `finish()`，但这告诉系统我们已经完成了活动。实际上，`finish()` 并没有返回到调用活动或任何特定的活动；它只是关闭当前活动并依赖于**回退栈**。如果我们想要一个特定的活动，可以再次使用意图对象（在创建意图时只需更改类名）。
- en: This activity switching does not make a very exciting application. Our activity
    does nothing but demonstrate how to switch from one activity to another, which
    of course will form a fundamental aspect of almost any application that we develop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种活动切换并不能构成一个令人兴奋的应用程序。我们的活动除了演示如何从一个活动切换到另一个活动之外，什么也不做，这当然将成为我们开发几乎所有应用程序的基本方面。
- en: 'If we had manually created the activities, we would need to add them to the
    manifest. By using these steps, Android Studio has already taken care of the XML.
    To see what Android Studio did, open the `AndroidManifest.xml` file and look at
    the `<application>` element:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手动创建活动，我们需要将它们添加到清单中。通过使用这些步骤，Android Studio 已经处理了 XML。要查看 Android Studio
    的操作，请打开 `AndroidManifest.xml` 文件并查看 `<application>` 元素：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One thing to note in the preceding autogenerated code is that the second activity
    does not have the `<intent-filter>` element. The main activity is generally the
    entry point when starting the application. That's why `MAIN` and `LAUNCHER` are
    defined—so that the system will know which activity to launch when the application
    starts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面自动生成的代码中需要注意的是，第二个活动没有 `<intent-filter>` 元素。主活动通常是在启动应用程序时的入口点。这就是为什么定义了
    `MAIN` 和 `LAUNCHER` ——以便系统知道在应用程序启动时应该启动哪个活动。
- en: See also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To learn more about embedding widgets such as the Button, visit [Chapter 3](ch03.html
    "Chapter 3. Views, Widgets, and Styles"), *Views, Widgets, and Styles*.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关嵌入如 Button 之类的控件的更多信息，请访问 [第3章](ch03.html "第3章. 视图、控件和样式")，*视图、控件和样式*。
- en: Passing data to another activity
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据传递给另一个活动
- en: The intent object is defined as a messaging object. As a message object, its
    purpose is to communicate with other components of the application. In this recipe,
    we'll show you how to pass information with the intent and how to get it out again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 意图对象被定义为消息对象。作为消息对象，其目的是与应用程序的其他组件进行通信。在这个食谱中，我们将向您展示如何使用意图传递信息以及如何再次获取它。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will pick up from where the previous one ended. We will call this
    project `SendData`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将从上一个食谱结束的地方开始。我们将这个项目称为 `SendData`。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since this recipe is building on the previous recipe, most of the work is already
    done. We''ll add an `EditText` element to the main activity so that we have something
    to send to `SecondActivity`. We''ll use the (autogenerated) `TextView` view to
    display the message. Here are the complete steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此食谱基于上一个食谱，因此大部分工作已经完成。我们将在主活动中添加一个 `EditText` 元素，以便我们有一些内容发送到 `SecondActivity`。我们将使用（自动生成的）`TextView`
    视图来显示消息。以下是完整的步骤：
- en: 'Open `activity_main.xml`, remove the existing `<TextView>` element, and add
    the following `<EditText>` element:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml`，移除现有的 `<TextView>` 元素，并添加以下 `<EditText>` 元素：
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<Button>` element that we created in the previous recipe doesn't change.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在上一个食谱中创建的 `<Button>` 元素没有变化。
- en: 'Now, open the `MainActivity.java` file and change the `onClickSwitchActivity()`
    method as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainActivity.java` 文件，并按如下所示更改 `onClickSwitchActivity()` 方法：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, open the `activity_second.xml` file and modify the`<TextView>` element
    to include the ID attribute:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `activity_second.xml` 文件，并修改 `<TextView>` 元素以包含 ID 属性：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last change is to edit the second activity to look for this new data and
    display it on the screen. Open `SecondActivity.java` and edit `onCreate()` as
    follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个改变是编辑第二个活动以查找这个新的数据并在屏幕上显示它。打开`SecondActivity.java`文件，并按以下方式编辑`onCreate()`：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now run the project. Type some text on the main activity and press **Launch
    Second Activity** to see it send the data.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行项目。在主活动中输入一些文本，然后按下**启动第二个活动**以查看它发送的数据。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As expected, the intent object is doing all the work. We created an intent just
    as in the previous recipe and then added some extra data. Did you notice the `putExtra()`
    method call? In our example, we used the already defined `Intent.EXTRA_TEXT` as
    the identifier, but we didn't have to. We can use any key we want (you've seen
    this concept before if you're familiar with name/value pairs).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，意图对象正在完成所有工作。我们像在之前的食谱中一样创建了一个意图，然后添加了一些额外的数据。你注意到`putExtra()`方法调用了吗？在我们的例子中，我们使用了已经定义的`Intent.EXTRA_TEXT`作为标识符，但我们并不一定要这么做。我们可以使用我们想要的任何键（如果你熟悉名称/值对，你之前应该已经见过这个概念）。
- en: The key point about using name/value pairs is that you have to use the same
    name to get the data back out. That's why we used the same key identifier when
    we read the extra data with `getStringExtra()`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称/值对的关键点在于，你必须使用相同的名称来获取数据。这就是为什么我们在使用`getStringExtra()`读取额外数据时使用相同的键标识符。
- en: 'The second activity was launched with the intent that we created, so it''s
    simply a matter of getting the intent and checking for the data sent along with
    it. We do this in `onCreate()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个活动是用我们创建的意图启动的，所以只需获取意图并检查随它发送的数据。我们在`onCreate()`中进行这项操作：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We aren't limited to just sending `String` data. The intent object is very flexible
    and already supports basic data types. Go back to Android Studio and click on
    the `putExtra` method. Then hit *Ctrl* and the *Spacebar*. Android Studio will
    bring up the autocomplete list so that you can see the different data types that
    you can store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于发送`String`数据。意图对象非常灵活，并且已经支持基本数据类型。回到 Android Studio，点击`putExtra`方法。然后按下*Ctrl*和*空格键*。Android
    Studio 将会弹出自动完成列表，这样你就可以看到你可以存储的不同数据类型了。
- en: Returning a result from an activity
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从活动中返回结果
- en: Being able to start one activity from another is all well and good, but we will
    often need to know how the called activity has fared in its task or even which
    activity has been called. The `startActivityForResult()` method provides the solution.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从一个活动启动另一个活动是很好的，但我们经常需要知道被调用的活动在任务中的表现，甚至需要知道哪个活动被调用了。`startActivityForResult()`方法提供了这个解决方案。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Returning a result from an activity is not very different from the way we just
    called the activity in the previous recipes. You can either use the project from
    the previous recipe, or start a new project and call it `GettingResults`. Either
    way, once you have a project with two activities and the code needed to call the
    second activity, you're ready to begin.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从活动中返回结果与我们在之前的食谱中调用活动的方式并没有太大不同。你可以使用之前食谱中的项目，或者开始一个新项目并将其命名为`GettingResults`。无论如何，一旦你有一个带有两个活动以及调用第二个活动所需代码的项目，你就可以开始了。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are only a few changes needed to get the results:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 获取结果只需要进行少量更改：
- en: 'First of all, open `MainActivity.java` and add the following constant to the
    class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`MainActivity.java`并将以下常量添加到类中：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, change the way the intent is called by modifying the `onClickSwitchActivity()`
    method to expect a result:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过修改`onClickSwitchActivity()`方法以期待一个结果来改变调用意图的方式：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add this new method to receive the result:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加这个新方法以接收结果：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, modify `onClickClose` in `SecondActivity.java` to set the return value
    as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`SecondActivity.java`中修改`onClickClose`以设置返回值，如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, getting the results back is relatively straightforward. We just
    call the intent with `startActivityForResult`, so it knows that we want a result.
    We set up the `onActivityResult()` callback handler to receive the results. Finally,
    we make sure that the second activity returns a result with `setResult()` before
    closing the activity. In this example, we are just setting a result with a static
    value. We just display what we receive to demonstrate the concept.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，获取结果回来相对简单。我们只需使用`startActivityForResult`调用意图，这样它就知道我们想要一个结果。我们设置`onActivityResult()`回调处理程序以接收结果。最后，我们确保在关闭活动之前，第二个活动使用`setResult()`返回一个结果。在这个例子中，我们只是用静态值设置一个结果。我们仅显示我们收到的内容以演示这个概念。
- en: It's good practice to check the result code to make sure that the user didn't
    cancel the action. It's technically an integer, but the system uses it as a boolean
    value. Check for either `RESULT_OK` or `RESULT_CANCEL` and proceed accordingly.
    In our example, the second activity doesn't have a cancel button, so why bother
    to check? What if the user hits the back button? The system will set the result
    code to `RESULT_CANCEL` and the intent to null, which will cause our code to throw
    an exception.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果码以确保用户没有取消操作是一个好习惯。它从技术上来说是一个整数，但系统将其作为布尔值使用。检查`RESULT_OK`或`RESULT_CANCEL`并根据情况进行处理。在我们的示例中，第二个活动没有取消按钮，那么为什么要检查呢？如果用户点击了返回按钮怎么办？系统会将结果码设置为`RESULT_CANCEL`，并将意图设置为null，这将导致我们的代码抛出异常。
- en: We made use of the **Toast** object, which is a convenient pop-up **message**
    that can be used to unobtrusively notify the user. It also functions as a handy
    method for debugging as it doesn't need a special layout or screen space.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了**Toast**对象，这是一种便捷的弹出式**消息**，可以用来不打扰地通知用户。它还作为一种方便的调试方法，因为它不需要特殊的布局或屏幕空间。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Besides the result code, `onActivityResults()` also includes a **Request Code**.
    Are you wondering where that came from? It is simply the integer value that was
    passed with the `startActivityForResult()` call, which takes this form:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结果码，`onActivityResults()`还包括一个**请求码**。你可能想知道这是从哪里来的？它只是与`startActivityForResult()`调用一起传递的整数值，形式如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We didn't check the request code because we knew we had only one result to handle—but
    in trivial applications with several activities, this value can be used to identify
    where the request originated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有检查请求码，因为我们知道只有一个结果需要处理——但在有多个活动的小型应用程序中，这个值可以用来识别请求的来源。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If `startActivityForResult()` is called with a negative request code, it will
    behave exactly as if it were a call to `startActivity()`—that is, it will not
    return a result.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用负请求码调用`startActivityForResult()`，它将表现得就像调用`startActivity()`一样——也就是说，它不会返回结果。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To learn more about creating new activity classes, refer to the *Switching between
    activities* recipe
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关创建新的活动类的更多信息，请参考*在活动之间切换*的食谱。
- en: For more information about Toasts, check out the *Making a Toast* recipe in
    [Chapter 7](ch07.html "Chapter 7. Alerts and Notifications"), *Alerts and Notifications*
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解更多关于 Toasts 的信息，请查看[第7章](ch07.html "第7章.警报和通知")中的*制作 Toast*食谱，*警报和通知*
- en: Saving an activity's state
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存活动状态
- en: The mobile environment is very dynamic, with users changing tasks much more
    often than on desktops. With generally fewer resources on a mobile device, it
    should be expected that your application will be interrupted at some point. It's
    also very possible that the system will shut down your app completely to give
    additional resources to the task at hand. It's the nature of mobiles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 移动环境非常动态，用户更换任务比在桌面上更频繁。由于移动设备通常资源较少，可以预期你的应用程序在某个时刻会被中断。系统完全关闭你的应用程序以提供更多资源给当前任务也是非常可能的。这是移动设备的天性。
- en: A user might start typing something in your app, be interrupted by a phone call,
    or switch over to another app to send a text message, and by the time they get
    back to your app, the system may have closed it down completely to free up the
    memory. To provide the best user experience, you need to expect such behavior
    and make it easier for your user to resume from where they left off. The good
    thing is that the Android OS makes this easier by providing callbacks to notify
    your app of state changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会在你的应用中开始输入内容，被电话呼叫打断，或者切换到另一个应用发送短信，等到他们回到你的应用时，系统可能已经完全关闭它以释放内存。为了提供最佳用户体验，你需要预期这种行为，并让用户更容易从离开的地方继续。好消息是，Android操作系统通过提供回调来通知你的应用程序状态变化，从而简化了这一过程。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Simply rotating your device will cause the OS to destroy and recreate your activity.
    This might seem a bit heavy-handed, but it's done for good reason—it's very common
    to have different layouts for portrait and landscape, so this ensures that your
    app is using the correct resources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 只需旋转设备，操作系统就会销毁并重新创建你的活动。这可能看起来有些过激，但这样做是有原因的——通常需要为纵向和横向提供不同的布局，这样可以确保你的应用程序使用正确的资源。
- en: In this recipe, you'll see how to handle the `onSaveInstanceState()` and `onRestoreInstanceState()`
    callbacks to save your application's state. We will demonstrate this by creating
    a counter variable and increment it each time the **Count** button is pressed.
    We will also have an `EditText` and a `TextView` widget to see their default behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将看到如何处理 `onSaveInstanceState()` 和 `onRestoreInstanceState()` 回调来保存应用程序的状态。我们将通过创建一个计数器变量，并在每次按下
    **计数** 按钮时增加它来演示这一点。我们还将有一个 `EditText` 和一个 `TextView` 小部件，以观察它们默认的行为。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and name it `StateSaver`. We need only
    a single activity, so the autogenerated main activity is sufficient. However,
    we will need a few widgets, including `EditText`, `Button`, and `TextView`. Their
    layout (in `activity_main.xml`) will look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目，并将其命名为 `StateSaver`。我们只需要一个活动，所以自动生成的MainActivity就足够了。但是，我们需要一些小部件，包括
    `EditText`、`Button` 和 `TextView`。它们的布局（在 `activity_main.xml` 中）将如下所示：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following set of steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'To keep track of the counter, we need to add a global variable to the project,
    along with a key for saving and restoring. Add the following code to the `MainActivity.java`
    class:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪计数器，我们需要在项目中添加一个全局变量，以及用于保存和恢复的键。在 `MainActivity.java` 类中添加以下代码：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then add the code needed to handle the button press; it increments the counter
    and displays the result in the `TextView` widget:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加处理按钮按下的代码；它增加计数器并在 `TextView` 小部件中显示结果：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To receive notifications of application state change, we need to add the `onSaveInstanceState()`
    and `onRestoreInstanceState()` methods to our application. Open `MainActivity.java`
    and add the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了接收应用程序状态变化的通知，我们需要在应用程序中添加 `onSaveInstanceState()` 和 `onRestoreInstanceState()`
    方法。打开 `MainActivity.java` 文件，并添加以下内容：
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program and try changing the orientation to see how it behaves (if you're
    using the emulator, *Ctrl* + *F11* will rotate the device).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，尝试改变方向，看看它的表现（如果你使用模拟器，*Ctrl* + *F11* 将旋转设备）。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All activities go through multiple states during their lifetime. By setting
    up callbacks to handle the events, we can have our code save important information
    before the activity is destroyed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有活动在其生命周期中都会经历多个状态。通过设置回调来处理事件，我们可以在活动被销毁之前让代码保存重要信息。
- en: Step 3 is where the actual saving and restoring occurs. The system sends a **Bundle**
    (a data object that also uses name/value pairs) to the methods. We use the `onSaveInstanceState()`
    callback to save the data and pull it out in the `onRestoreInstanceState()` callback.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步是实际保存和恢复状态发生的地方。系统会向这些方法发送一个 **Bundle**（一个数据对象，也使用名称/值对）。我们使用 `onSaveInstanceState()`
    回调来保存数据，并在 `onRestoreInstanceState()` 回调中取出。
- en: But wait! Did you try typing text in the `EditText` view before rotating the
    device? If so, you'd have noticed that the text was also restored, but we don't
    have any code to handle that view. By default, the system will automatically save
    the state, provided it has a unique ID (not all views automatically have their
    state saved, such as the `TextView`, but we can manually save it if we want).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！你在旋转设备之前尝试在 `EditText` 视图中输入文本了吗？如果是，你会注意到文本也被恢复了，但我们没有任何代码来处理这个视图。默认情况下，系统会自动保存状态，前提是它有一个唯一的ID（并非所有视图都会自动保存状态，比如
    `TextView`，但如果我们想要，可以手动保存）。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that if you want Android to automatically save and restore the state of
    a view, it must have a unique ID (specified with the `android:id=` attribute in
    the layout). Beware; not all view types automatically save and restore the state
    of a view.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你希望Android自动保存和恢复视图的状态，该视图必须有一个唯一的ID（在布局中使用 `android:id=` 属性指定）。注意，并非所有视图类型都会自动保存和恢复视图的状态。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `onRestoreInstanceState()` callback is not the only place where the state
    can be restored. Look at the signature of `onCreate()`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRestoreInstanceState()` 回调不是唯一可以恢复状态的地方。看看 `onCreate()` 的签名：'
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Both methods receive the same `Bundle` instance named `savedInstanceState`.
    You could move the restore code to the `onCreate()` method and it would work the
    same. But one catch is that the `savedInstanceState` bundle will be null if there
    is no data, such as during the initial creation of the activity. If you want to
    move the code from the `onRestoreInstanceState()` callback, just check to make
    sure that the data is not null, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法接收同一个名为`savedInstanceState`的`Bundle`实例。你可以将恢复代码移动到`onCreate()`方法中，效果是一样的。但需要注意的是，如果没有数据，比如在活动初次创建时，`savedInstanceState`包将为空。如果你想从`onRestoreInstanceState()`回调中移动代码，只需确保数据不是空的，如下所示：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Storing persistent activity data* recipe will introduce persistent storage.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储持久活动数据*的菜谱将介绍持久存储。'
- en: Take a look at [Chapter 6](ch06.html "Chapter 6. Working with Data"), *Working
    with Data*, for more examples on Android activities.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请查看[第6章](ch06.html "第6章.数据处理")，*数据处理*，了解更多关于Android活动的例子。
- en: The *Understanding the activity lifecycle* recipe explains the Android Activity
    Lifecycle.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解活动生命周期*的菜谱解释了Android活动的生命周期。'
- en: Storing persistent activity data
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储持久活动数据
- en: Being able to store information about our activities on a temporary basis is
    very useful, but more often than not, we will want our application to remember
    information across multiple sessions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在临时基础上存储关于我们活动的信息非常有用，但通常我们希望应用程序能够跨多个会话记住信息。
- en: Android supports SQLite, but that could be a lot of overhead for simple data,
    such as the user's name or a high score. Fortunately, Android also provides a
    lightweight option for these scenarios, with `SharedPreferences`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持SQLite，但对于简单的数据来说，这可能会带来很多开销，比如用户的名字或高分。幸运的是，Android还提供了`SharedPreferences`这样的轻量级选项，适用于这些场景。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can either use the project from the previous recipe or start a new project
    and call it `PersistentData` (in a real-world application, you'll likely be doing
    both anyway). In the previous recipe, we saved `mCounter` in the session state.
    In this recipe, we'll add a new method to handle `onPause()` and save `mCounter`
    to `SharedPreferences`. We'll restore the value in `onCreate()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用上一个菜谱的项目，或者启动一个新项目并称之为`PersistentData`（在实际应用中，你可能无论如何都会这样做）。在之前的菜谱中，我们将`mCounter`保存在会话状态中。在这个菜谱中，我们将添加一个新方法来处理`onPause()`并将`mCounter`保存到`SharedPreferences`中。我们将在`onCreate()`中恢复该值。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have only two changes to make, and both are in `MainActivity.java`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需做两个更改，都在`MainActivity.java`文件中：
- en: 'Add the following `onPause()` method to save the data before the activity closes:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动关闭之前，添加以下`onPause()`方法以保存数据：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then add the following code at the end of `onCreate()` to restore the counter:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`onCreate()`的最后添加以下代码以恢复计数器：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program and try it out.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并尝试一下。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see, this is very similar to saving state data, because it also uses
    name/value pairs. Here, we just stored an `int`, but we can just as easily store
    one of the other primitive data types. Each data type has equivalent getters and
    setters, for example, `SharedPreferences.getBoolean()` or `SharedPreferences.setString()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这与保存状态数据非常相似，因为它也使用名称/值对。这里，我们只存储了一个`int`，但我们同样可以轻松地存储其他基本数据类型。每种数据类型都有相应的获取器和设置器，例如，`SharedPreferences.getBoolean()`或`SharedPreferences.setString()`。
- en: Saving our data requires the services of `SharedPreferences.Editor`. This is
    evoked with `edit()` and accepts `remove()` and `clear()` procedures as well as
    setters such as `putInt()`. Note that we must conclude any storing that we do
    here with the `commit()` statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们的数据需要`SharedPreferences.Editor`的服务。这是通过`edit()`调用的，接受`remove()`和`clear()`过程以及如`putInt()`的设置器。请注意，我们必须在这里用`commit()`语句结束任何存储操作。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'There is a slightly more sophisticated variant of the `getPreferences()` accessor:
    `getSharedPreferences()`. It can be used to store multiple preference sets.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPreferences()`访问器的稍微复杂一点的变体是`getSharedPreferences()`。它可以用来存储多个偏好设置。'
- en: Using more than one preference file
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个偏好文件
- en: 'Using `getSharedPreferences()` is no different from using its counterpart,
    but it allows for more than one preference file. It takes the following form:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getSharedPreferences()`与使用其对应的方法没有区别，但它允许使用不止一个偏好文件。它的形式如下：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `name` is the file. The `mode` can be either `MODE_PRIVATE`, `MODE_WORLD_READABLE`,
    or `MODE_WORLD_WRITABLE` and describes the file's access levels.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name` 是文件。`mode` 可以是 `MODE_PRIVATE`、`MODE_WORLD_READABLE` 或 `MODE_WORLD_WRITABLE`，描述了文件的访问级别。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 6](ch06.html "Chapter 6. Working with Data"), *Working with Data*,
    for more examples on data storage'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章.数据处理")，*数据处理*，更多关于数据存储的示例'
- en: Understanding the activity lifecycle
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解活动生命周期
- en: The Android OS is a dangerous place for an activity. The demand for resources
    on a battery-operated platform is managed quite ruthlessly by the system. Our
    activities can be dumped from memory when it's running low, without even a moment's
    notice and along with any data they contain. Therefore, it is essential to understand
    the activity lifecycle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个活动来说，Android操作系统是一个充满危险的地方。系统对电池供电平台上的资源需求管理非常严格。当内存不足时，我们的活动可能会被从内存中清除，不会有任何预兆，同时包含的任何数据也会丢失。因此，理解活动生命周期至关重要。
- en: 'The following diagram shows the stages through which an activity passes during
    its lifetime:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了活动在其生命周期内经历的各个阶段：
- en: '![Understanding the activity lifecycle](img/05057_01_05.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![理解活动生命周期](img/05057_01_05.jpg)'
- en: Along with the stages, the diagram also shows the methods that can be overridden.
    As you can see, we've already utilized most of these methods in the preceding
    recipes. Hopefully, getting the big picture will help in your understanding.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阶段，图表还显示了可以覆盖的方法。如您所见，在之前的食谱中我们已经利用了这些方法中的大部分。希望了解全局情况将有助于您的理解。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio with a **Blank Activity**, and call it
    `ActivityLifecycle`. We will use the (autogenerated) `TextView` method to display
    the state information.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个带有 **空白活动** 的新项目，并将其命名为 `ActivityLifecycle`。我们将使用（自动生成）的
    `TextView` 方法来显示状态信息。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To see the application move through the various stages, we will create methods
    for all the stages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察应用程序经历各个阶段的过程，我们将为所有阶段创建方法：
- en: 'Open `activity_main.xml` and add an ID to the autogenerated `TextView`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并为自动生成的 `TextView` 添加一个ID：
- en: '[PRE28]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The remaining steps will be in `MainActivity.java`. Add the following global
    declaration:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的步骤将在 `MainActivity.java` 中进行。添加以下全局声明：
- en: '[PRE29]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Modify the `onCreate()` method to save `TextView` and set the initial text:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `onCreate()` 方法以保存 `TextView` 并设置初始文本：
- en: '[PRE30]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following methods to handle the remaining events:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法来处理剩余的事件：
- en: '[PRE31]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the application and observe what happens when the activity is interrupted
    by pressing the Back and Home keys. Try other actions, such as task switching,
    to see how they impact your application.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，观察当活动被按下返回和主页键中断时会发生什么。尝试其他操作，比如任务切换，看看它们对应用程序的影响。
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Our activity can exist in one of these three states: **active**, **paused**,
    or **stopped**. There is also a fourth state, **destroyed**, but we can safely
    ignore it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动可以处于这三种状态之一：**active**、**paused** 或 **stopped**。还有一种第四状态，**destroyed**，但我们可以安全地忽略它：
- en: An activity is in the `active` state when its interface is available for the
    user. It persists from `onResume()` until `onPause()`, which is brought about
    when another activity comes to the foreground. If this new activity does not entirely
    obscure our activity, then ours will remain in the `paused` state until the new
    activity is finished or dismissed. It will then immediately call `onResume()`
    and continue.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当活动的界面可供用户使用时，活动处于 `active` 状态。它从 `onResume()` 持续到 `onPause()`，这是当另一个活动进入前台时触发的。如果这个新活动没有完全遮盖我们的活动，那么我们的活动将保持
    `paused` 状态，直到新活动完成或消失。然后它会立即调用 `onResume()` 并继续。
- en: When a newly started activity fills the screen or makes our activity invisible,
    then our activity will enter the `stopped` state, and the resumption will always
    invoke a call to `onRestart()`.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新启动的活动填满屏幕或使我们的活动不可见时，我们的活动将进入 `stopped` 状态，恢复时总会调用 `onRestart()`。
- en: When an activity is in either the `paused` or `stopped` state, the operating
    system can (and will) remove it from the memory when the memory is low or when
    other applications demand it.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当活动处于 `paused` 或 `stopped` 状态时，操作系统可以在内存不足或其他应用程序需要时将其从内存中移除。
- en: 'It is worth noting that we never actually see the results of the `onDestroy()`
    method, as the activity is removed by this point. If you want to explore these
    methods further, then it is well worth employing `Activity.isFinishing()` to see
    whether the activity is really finishing before `onDestroy()` is executed, as
    seen in the following snippet:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，我们实际上从未看到 `onDestroy()` 方法的实际结果，因为此时活动已被移除。如果你想进一步探索这些方法，那么使用 `Activity.isFinishing()`
    来查看在 `onDestroy()` 执行之前活动是否真的在结束，是非常值得的，如下面的代码段所示：
- en: '[PRE32]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When implementing these methods, always call the superclass before doing any
    work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些方法时，请在进行任何操作之前调用超类。
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Shutting down an activity
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭一个活动
- en: To shut down an activity, directly call its `finish()` method, which in turn
    calls `onDestroy()`. To perform the same action from a child activity, use `finishFromChild(Activity
    child)`, where `child` is the calling subactivity.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭一个活动，直接调用它的 `finish()` 方法，这又会进而调用 `onDestroy()`。要从子活动执行相同操作，请使用 `finishFromChild(Activity
    child)`，其中 `child` 是调用子活动。
- en: It is often useful to know whether an activity is being shut down or merely
    paused, and the `isFinishing(boolean)` method returns a value that indicates which
    of these two states the activity is in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 了解活动是正在关闭还是仅仅暂停，通常很有用，`isFinishing(boolean)` 方法返回的值可以指示活动处于这两种状态中的哪一种。
