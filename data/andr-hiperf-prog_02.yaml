- en: Chapter 2. Efficient Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。高效调试
- en: Every developer becomes familiar with the word "bug" early on, and the relationship
    will last for their entire professional career. A **bug** is an error or flaw
    in a software system that provokes an unexpected and incorrect result.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者在早期都会熟悉“bug”这个词，并且这种关系将贯穿他们的整个职业生涯。一个**bug**是软件系统中的一个错误或缺陷，会导致一个意外和不正确的结果。
- en: There is some discussion about the etymology of the word. It was originally
    intended to describe technical malfunctions in hardware systems and the first
    reference to its usage comes from Thomas Edison. Grace Hopper, a computer pioneer,
    apparently traced in 1946 the malfunctioning of the computer Mark II to a moth
    that was trapped inside the relay. This physical bug ended up representing not
    only physical bugs trapped inside machines and causing malfunctions, but also
    logical bugs or software errors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个词的词源有一些讨论。它最初是用来描述硬件系统中的技术故障，第一次使用这个词的引用来自托马斯·爱迪生。计算机先驱格蕾丝·霍珀（Grace Hopper）在1946年追踪到计算机Mark
    II的故障是由一只被困在继电器中的飞蛾引起的。这个物理bug最终不仅代表了困在机器内引起故障的物理bug，也代表了逻辑bug或软件错误。
- en: '**Debugging** is, in this context, the process of finding bugs or malfunctions
    in a software system. Debugging involves numerous factors, including reading logs,
    memory dumping and analysis, profiling, and system monitoring. During the development
    stage, or when a bug is detected in a production system, a developer will debug
    the software application to detect the flaw and proceed to fix it.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，**调试**是寻找软件系统中的bug或故障的过程。调试包括众多因素，如阅读日志、内存转储和分析、性能分析以及系统监控。在开发阶段，或者在生成系统中检测到bug时，开发者将调试软件应用程序以检测缺陷并继续修复它。
- en: If you are an Android developer, Google has provided a big set of tools that
    we can use to debug our application. This book will be based on the Android Studio
    suite and the official SDK from Google—notwithstanding other external tools that
    can also be helpful in the process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个安卓开发者，谷歌提供了一套丰富的工具，我们可以用来调试我们的应用程序。本书将基于Android Studio套件和谷歌的官方SDK进行编写——尽管在过程中还有其他外部工具也可能很有帮助。
- en: Android Debug Bridge
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓调试桥
- en: '**Android Debug Bridge**, more widely known as **ADB**, is a core tool for
    Android. It is included in the Android SDK, in the folder/platform tools. If you
    go to this folder and call the command `adb`, you will see on the screen a list
    of the available options.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**安卓调试桥**，更广为人知的是**ADB**，是Android的一个核心工具。它包含在Android SDK的/platform-tools文件夹中。如果你进入这个文件夹并调用`adb`命令，你将在屏幕上看到可用的选项列表。'
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you haven't done this by now, this is a productivity tip that will pay off
    in probably the first minute working with ADB. Add to your `PATH` environmental
    variable the location where you have stored your Android SDK. From this moment,
    you will be able to call all the tools included within that folder from any part
    of your system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还没有这样做，这是一个可以提高生产力的技巧，可能在你使用ADB的第一分钟就会得到回报。将你的Android SDK存储位置添加到你的`PATH`环境变量中。从这一刻起，你将能够从系统的任何部分调用该文件夹内包含的所有工具。
- en: 'With `adb`, we can perform multiple operations, including displaying devices,
    taking screenshots, or connecting to and disconnecting from different devices.
    It is not the purpose of this book to give a thorough review of each operation
    of a tool, but here, we present a list of the most common and useful functionalities
    of `adb`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`adb`，我们可以执行多种操作，包括显示设备、截图或者连接和断开与不同设备的连接。本书的目的不是详尽地审查一个工具的每一项操作，但在这里，我们列出了一些`adb`最常见和有用的功能：
- en: '| # | Command | Description |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| # | 命令 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | `adb logcat *:E&#124;D&#124;I` | Starts `logcat` in the console, filtering
    by errors, debug messages, or information messages |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `adb logcat *:E&#124;D&#124;I` | 在控制台中启动`logcat`，通过错误、调试信息或信息消息进行过滤 |'
- en: '| 2 | `adb devices` | Lists all the devices attached and connected to `adb`
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `adb devices` | 列出所有连接到`adb`的设备 |'
- en: '| 3 | `adb kill-server``adb start-server` | Kills and restarts the `adb` server.
    A useful message when `adb` gets stuck or suffers from a malfunction |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `adb kill-server``adb start-server` | 杀死并重启`adb`服务器。当`adb`出现卡顿或功能异常时，这是一个有用的消息
    |'
- en: '| 4 | `adb shell` | Starts a remote shell in the target device or emulator
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `adb shell` | 在目标设备或模拟器上启动一个远程shell |'
- en: '| 5 | `adb bugreport` | Prints all the content of `dumpsys`, `dumpstate`, and
    `logcat` to the screen |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `adb bugreport` | 将`dumpsys`、`dumpstate`和`logcat`的所有内容打印到屏幕上 |'
- en: '| 6 | `adb help` | Prints a list with all the executable commands of `adb`
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `adb help` | 打印`adb`所有可执行命令的列表 |'
- en: 'One interesting fact with `adb` is that, being a command-line tool, it can
    be used for scripting and be included in **Continuous Integration** (**CI**) systems
    such as Jenkins. By using the `adb` shell we can execute any command in the device.
    Let''s think, for example, of a useful script that takes a screenshot of the device''s
    screen:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`adb`一个有趣的事实是，作为一个命令行工具，它可以用于脚本编写并包含在如Jenkins等**持续集成**（**CI**）系统中。通过使用`adb`
    shell，我们可以执行设备上的任何命令。例如，考虑一个有用的脚本，它能够截取设备屏幕的截图：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are many possibilities with `adb` that we will explore in this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将探索`adb`的许多可能性。
- en: Dalvik Debug Monitor Server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dalvik调试监控服务器
- en: '**Dalvik Debug Monitor Server** is also known as **DDMS**. This utility runs
    on top of `adb`, and provides a graphical interface with a big set of functionalities,
    including thread and heap information, logcat, SMS/call simulation, location data,
    and more. This is how DDMS looks when it starts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dalvik调试监控服务器**也称为**DDMS**。这个工具在`adb`之上运行，并提供了一个具有大量功能的图形界面，包括线程和堆信息、logcat、短信/电话模拟、位置数据等。以下是DDMS启动时的样子：'
- en: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_01.jpg)'
- en: 'The screen has different sections:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕有不同的部分：
- en: The top-left section shows the active devices and the different processes running
    on the device.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左上部分显示了活动设备和设备上运行的不同进程。
- en: The top-right section shows a variety of options, the default option being the
    file explorer. At the bottom, **LogCat** is shown.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右上部分展示了各种选项，默认选项为文件资源管理器。在底部，显示了**LogCat**。
- en: 'There are more available options in the DDMS, so let''s explore them in detail.
    First, the section we saw on the top-left side:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS中还有更多可用的选项，让我们详细探索它们。首先，我们之前看到的左上部分：
- en: The ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_24.jpg) icon starts
    debugging the selected process.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_24.jpg)图标开始调试选定的进程。'
- en: The ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_25.jpg) icon will
    update the heap every time the GC is triggered for the selected process (more
    information on this later).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_25.jpg)图标将在每次为选定进程触发GC时更新堆。'
- en: The next icon, ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_26.jpg),
    dumps HPROF in a file. **HPROF** is a binary format that contains the snapshot
    of an application heap. There are some tools to visualize them, such as jhat.
    Later on, we will show an example of how to convert this file and visualize it.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个图标，![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_26.jpg)，将HPROF转储到文件中。**HPROF**是一种二进制格式，包含应用程序堆的快照。有一些工具可以可视化它们，例如jhat。稍后，我们将展示如何转换此文件并将其可视化的示例。
- en: The ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_27.jpg) option
    will cause a garbage collection in our application (useful for the previous entry).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_27.jpg)选项将触发我们应用程序的垃圾回收（对前一个条目很有用）。'
- en: The ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_28.jpg) icon updates
    the threads in DDMS. When we are dealing with multithreaded applications, this
    will come in very handy.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_28.jpg)图标更新DDMS中的线程。在处理多线程应用程序时，这将非常方便。'
- en: With the ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_29.jpg) icon
    we can start profiling threads and displaying accurate information about them.
    A full example will be shown later.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_29.jpg)图标，我们可以开始分析线程并显示有关它们的准确信息。稍后将展示一个完整的示例。
- en: To stop a process running, we can use the ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_30.jpg)
    icon.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止正在运行的进程，我们可以使用![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_30.jpg)图标。
- en: To take a screenshot of the application, the ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_31.jpg)
    icon will do the trick.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要对应用程序进行截图，可以使用![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_31.jpg)图标来实现。
- en: With ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_32.jpg), we can
    get a snapshot of the view hierarchy and send it to the UI automator.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_32.jpg)，我们可以获取视图层次结构的快照并将其发送到UI自动化工具。
- en: The ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_33.jpg) option
    captures a system-wide trace with the help of Android's systrace.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_33.jpg)选项利用Android的systrace捕获系统范围的跟踪。'
- en: The ![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_34.jpg) icon starts
    capturing OpenGL traces.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![Dalvik Debug Monitor Server](img/Insert_Image_B04666_02_34.jpg) 图标用于开始捕获OpenGL跟踪信息。'
- en: Capturing and analyzing thread information
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获和分析线程信息
- en: Now we want to see how we can deal with thread debugging. The traditional approach
    of setting breakpoints and waiting until a thread is called will not work well
    here, since a multithreaded application might have several threads running at
    the same time and independently of each other. Hence, we want to visualize and
    access them independently.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何处理线程调试。传统的设置断点并等待线程被调用的方法在这里效果不佳，因为多线程应用程序可能有多个线程同时运行且相互独立。因此，我们希望能够独立地可视化和访问它们。
- en: 'Select a process on the left-hand side of the list and click the ![Capturing
    and analyzing thread information](img/Insert_Image_B04666_02_28.jpg) icon. If
    now you click in the threads section on the right-hand side, you will see how
    this section has been updated with information regarding the threads of the current
    process:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表左侧选择一个进程，并点击 ![捕获和分析线程信息](img/Insert_Image_B04666_02_28.jpg) 图标。如果你现在点击右侧的线程部分，你会看到这个部分已经用当前进程的线程信息进行了更新：
- en: '![Capturing and analyzing thread information](img/Insert_Image_B04666_02_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![捕获和分析线程信息](img/Insert_Image_B04666_02_02.jpg)'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Some developers are confused about what processes and threads are, so just
    in case: a process provides the required resources to execute a program (virtual
    address space, executable code, security context, and so on). A process is the
    instance of execution of a process (also referred to as a task in some contexts).
    Several processes can be associated with the same program, and they disappear
    when the machine is rebooted. A thread is a subset of a process. A process can
    be composed of multiple threads, and multiple threads exploit parallelism in multiprocessor
    systems. All the threads in the same process share a space address and a stack
    or file descriptor, among other things.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者对于进程和线程是什么感到困惑，以防万一：进程提供了执行程序所需的资源（虚拟地址空间、可执行代码、安全上下文等）。进程是执行进程的实例（在某些上下文中也称为任务）。同一个程序可以有多个进程与之关联，且这些进程在机器重启时会消失。线程是进程的一个子集。一个进程可以由多个线程组成，多个线程在多处理器系统中利用并行性。同一进程中的所有线程共享一个地址空间和堆栈或文件描述符，以及其他内容。
- en: 'We can see different information on the screen for each thread: each of them
    has an ID, a thread ID (Tid), a status, a utime (cumulative time spent executing
    user code, in "jiffies", usually 10 ms), stime (cumulative time spent executing
    system code, also in jiffies), and a name. If we click on one of the processes,
    we will visualize the stack trace of the process in the section immediately below
    it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在屏幕上看到每个线程的不同信息：它们都有一个ID、线程ID（Tid）、状态、utime（累计执行用户代码的时间，通常以“jiffies”，即10毫秒为单位）、stime（累计执行系统代码的时间，也是以jiffies为单位）以及一个名称。如果我们点击其中一个进程，我们将在紧随其下的部分可视化该进程的堆栈跟踪。
- en: 'We have already mentioned that threads can be profiled. This is typically used
    to debug memory leaks. Before we start profiling, keep in mind a few considerations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到线程可以被分析。这通常用于调试内存泄漏。在开始分析之前，请记住以下几点：
- en: Devices under API Level 7 (Android 2.1) will need to have an SD card, since
    the profiling will be saved there
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API级别低于7（Android 2.1）的设备需要有一个SD卡，因为分析数据将保存在那里。
- en: Devices above API Level 7 do not need to have an SD card
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API级别7以上的设备不需要有SD卡。
- en: 'Click the ![Capturing and analyzing thread information](img/Insert_Image_B04666_02_29.jpg)
    icon. On Android devices over API Level 19 (Android 4.4), you will be prompted
    to choose the sampling frequency, if you prefer trace-based profiling. When this
    is activated, DDMS will be capturing information about the selected process, so
    you just need to interact with your application. When you are ready, click again
    on the icon (which now will look like ![Capturing and analyzing thread information](img/Insert_Image_B04666_02_35.jpg))
    to stop the profiler and dump the obtained information. A screen such as the following
    will appear:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 ![捕获和分析线程信息](img/Insert_Image_B04666_02_29.jpg) 图标。在API级别19（Android 4.4）以上的Android设备上，如果你选择基于跟踪的分析，系统会提示你选择采样频率。激活后，DDMS将捕获有关所选进程的信息，你只需与应用程序进行交互。准备好后，再次点击图标（此时图标将变为
    ![捕获和分析线程信息](img/Insert_Image_B04666_02_35.jpg)）以停止分析器并转储获取的信息。会出现如下屏幕：
- en: '![Capturing and analyzing thread information](img/Insert_Image_B08951_02_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![捕获并分析线程信息](img/Insert_Image_B08951_02_03.jpg)'
- en: Each row represents the execution of an individual thread, increasing the time
    as we move to the right-hand side. The execution of each method is displayed in
    a different color.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每行代表一个独立线程的执行，随着向右移动，时间增加。每个方法的执行以不同的颜色显示。
- en: In the bottom section of this new screen is a profile panel. This table shows
    the inclusive and exclusive CPU time, in percentage and in absolute values. Exclusive
    time means the time we have spent in the method, and inclusive time is the time
    we have spent in the method and in all the functions being called. The calling
    methods are hereby called parents, and the methods are called children.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新界面的底部部分是一个分析面板。这个表格显示了包括和排除CPU时间，以百分比和绝对值表示。排除时间是指我们在方法中花费的时间，而包括时间是我们在方法及其所有被调用函数中花费的时间。因此，调用方法被称为父方法，而方法被称为子方法。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is a well-known issue with the profiler: the VM reuses thread IDs. If
    a thread stops and another starts, they may get the same ID. This can result in
    confusing data, so make sure you are handling threads properly when profiling.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器有一个众所周知的问题：虚拟机复用线程ID。如果一个线程停止而另一个开始，它们可能会得到相同的ID。这可能导致混淆数据，因此在分析时请确保你正确处理线程。
- en: Heap analysis and visualization
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆分析和可视化
- en: 'We have learned how to debug threads using DDMS. Now we will learn how to properly
    analyze the memory heap of an application: that is, the portion of memory where
    the allocated memory resides. This is very important when it comes to debugging
    memory leaks.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用DDMS来调试线程。现在我们将学习如何正确分析应用程序的内存堆：即已分配内存所在的内存部分。在调试内存泄漏时，这非常重要。
- en: 'Let''s use a heap dump to track down the problem. Click the ![Heap analysis
    and visualization](img/Insert_Image_B04666_02_26.jpg) icon to dump the HPROF file
    and choose where you want to save the file. Now run `hprof-conv` over the file.
    `hprof-conv` is an Android utility that converts the `.hprof` file from the Dalvik
    format to the J2SE HPROF format, so it can be opened with standard tools. It can
    be found under `/platform-tools`. To run it, you need to type the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用堆转储来追踪问题。点击 ![堆分析和可视化](img/Insert_Image_B04666_02_26.jpg) 图标来转储HPROF文件，并选择你想要保存文件的位置。现在对文件运行
    `hprof-conv` 命令。`hprof-conv` 是一个Android实用工具，它将 `.hprof` 文件从Dalvik格式转换为J2SE HPROF格式，这样就可以使用标准工具打开它。你可以在
    `/platform-tools` 目录下找到它。要运行它，你需要输入以下命令：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you will have a file that can be understood by some standard tools. In order
    to read the file, we will use MAT, a standalone version downloadable from [http://www.eclipse.org/mat/downloads.php](http://www.eclipse.org/mat/downloads.php).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将拥有一个可以被一些标准工具理解的文件。为了读取这个文件，我们将使用MAT，这是一个可以从 [http://www.eclipse.org/mat/downloads.php](http://www.eclipse.org/mat/downloads.php)
    下载的独立版本。
- en: 'MAT is a very complex and powerful tool. Click on **File** and open **Heap
    Dump**. You will end up in a screen similar to the following one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MAT是一个非常复杂且强大的工具。点击 **文件** 并打开 **堆转储**。你将进入一个与以下类似的界面：
- en: '![Heap analysis and visualization](img/Insert_Image_B04666_02_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![堆分析和可视化](img/Insert_Image_B04666_02_04.jpg)'
- en: If we click on one of the groups we will display a set of options. A particularly
    interesting one is **Histogram**. In the histogram, it is possible to see classes
    filtered by the number of instances, the total amount of memory used, or the total
    amount of memory alive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击其中一个组，将显示一组选项。其中一个特别有趣的是 **直方图**。在直方图中，可以按实例数量、使用的总内存量或存活的总内存量过滤类。
- en: 'If we right-click on one of the classes and select the **List objects** option
    and then with incoming references, a list of the classes presented in the heap
    will be produced. This can be ordered by usage later on. By picking one up we
    can display the chains of references keeping the object alive. We cannot know
    per se if that means there is a memory leak or not, but a programmer with knowledge
    of the domain can identify whether one of the values should not be alive anymore:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们右键点击其中一个类，并选择 **列出对象** 选项以及其引用，将在堆中生成一个类的列表。稍后可以根据使用情况进行排序。通过选择一个，我们可以显示保持对象存活的引用链。我们本身无法判断这是否意味着存在内存泄漏，但了解该领域的程序员可以确定其中某个值是否不应该再存活：
- en: '![Heap analysis and visualization](img/Insert_Image_B04666_02_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![堆分析和可视化](img/Insert_Image_B04666_02_05.jpg)'
- en: We can also visualize the heap in DDMS. If we select a process and click on
    the ![Heap analysis and visualization](img/Insert_Image_B04666_02_25.jpg) icon,
    the heap section will update with information about all the different data types
    and objects that are currently alive in the application. It is also possible to
    manually provoke a GC in order to update DDMS with the most up-to-date information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在DDMS中可视化堆。如果我们选择一个进程并点击 ![堆分析及可视化](img/Insert_Image_B04666_02_25.jpg)
    图标，堆部分将更新有关应用程序当前所有存活的不同数据类型和对象的信息。还可以手动触发GC，以便DDMS更新最新的信息。
- en: 'It is possible to see here the number of objects of each type, their total
    size (including the values for the smallest and largest object, very useful to
    identify when `OutOfMemoryExceptions` are happening), as well as the median and
    the average size of each object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每种类型的对象数量，它们的总大小（包括最小和最大对象的大小，这对于识别`OutOfMemoryExceptions`发生时非常有用），以及每个对象的中位数和平均大小：
- en: '![Heap analysis and visualization](img/Insert_Image_B04666_02_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![堆分析及可视化](img/Insert_Image_B04666_02_06.jpg)'
- en: Allocation tracker
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配跟踪器
- en: The allocation tracker is a tool provided by Android that records an app's memory
    allocations and lists all allocated objects for the profiling cycle with their
    call stack, size, and allocating code. This goes further than the memory heap
    and allows us to identify individual pieces of memory being created. It is good
    to identify places in the code that might be allocating memory inefficiently and
    to identify objects of the same type that are being allocated and deallocated
    over a short period of time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分配跟踪器是Android提供的一个工具，它记录应用程序的内存分配，并列出配置周期内所有已分配对象的调用堆栈、大小和分配代码。这比内存堆更进一步，允许我们识别正在创建的单独内存片段。它有助于识别可能低效分配内存的代码位置，以及在同一时间段内被分配和释放的相同类型的对象。
- en: 'To start using the allocation tracker tool, select your process on the left-hand
    side, select the **Allocation Tracker** section in the pane on the right, and
    then click on the **Stop Tracking** button. A similar window to the following
    one will open:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用分配跟踪器工具，请在左侧选择您的进程，在右侧窗格中选择**分配跟踪器**部分，然后点击**停止跟踪**按钮。将打开一个类似于以下窗口的界面：
- en: '![Allocation tracker](img/Insert_Image_B04666_02_07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![分配跟踪器](img/Insert_Image_B04666_02_07.jpg)'
- en: The amount of information can be overwhelming, and there is, therefore, a filter
    at the bottom where you can specify which information you want to get. If you
    click on one of the rows, the location of the allocated object will be printed
    on the screen. Note that in our particular case, we are displaying information
    about an object contained in the Google Maps API and the classes are named with
    a letter. That means that the code has been obfuscated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 信息量可能非常大，因此底部有一个过滤器，您可以指定想要获取哪些信息。如果您点击其中一行，分配对象的位置将在屏幕上打印出来。请注意，在我们的特定情况下，我们显示的是关于Google
    Maps API中包含的对象的信息，类名以字母表示。这意味着代码已经被混淆。
- en: Using ProGuard to obfuscate code is a basic security mechanism. ProGuard does
    not only optimize the code and get rid of the boilerplate, but also makes it very
    hard for a hypothetical attacker to take a look at our code and, eventually, play
    with it. In addition, each row represents a memory allocation event. Each column
    represents information about the allocation, such as the object type, the thread,
    and its size.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ProGuard混淆代码是一种基本的安全机制。ProGuard不仅优化代码，去除冗余，还使潜在的攻击者难以查看我们的代码，最终无法对其进行操作。此外，每一行代表一个内存分配事件。每一列代表有关分配的信息，例如对象类型、线程及其大小。
- en: Network usage
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络使用情况
- en: In Android 4.0, the **Data Usage** feature in **Settings** enables long-term
    monitoring of how an application uses network resources. Starting with Android
    4.0.3, it is possible to monitor an application using network resources in real
    time. It is possible as well to distinguish traffic sources by applying a tag
    to network sockets before use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 4.0中，**设置**中的**数据使用情况**功能可以长期监控应用程序如何使用网络资源。从Android 4.0.3开始，可以实时监控应用程序的网络资源使用情况。还可以通过在使用前为网络套接字应用标签来区分流量来源。
- en: 'To display the network usage of an application, select a process from the left-hand
    side. Then move to the **Network Statistics** tab and click on the **Start** button.
    You can select the tracking speed: every 100, 250, or 500 ms. Then, interact with
    your application. A similar screen to the following one will be displayed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示应用程序的网络使用情况，请从左侧选择一个进程。然后移至**网络统计**标签页，点击**开始**按钮。你可以选择跟踪速度：每100、250或500毫秒。然后，与你的应用程序进行交互。将显示与以下类似的屏幕：
- en: '![Network usage](img/Insert_Image_B04666_02_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![网络使用情况](img/Insert_Image_B04666_02_08.jpg)'
- en: The bottom of the screen displays the network information by **Tag**, and collected
    by **Total**. It is possible to see the number of bytes and packages being sent
    and received in total, as well as a graphical representation of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕底部按**标签**显示网络信息，并通过**总计**收集。可以查看总共发送和接收的字节和包的数量，以及它们的图形表示。
- en: 'If you haven''t done it yet, it is a good idea to set tags on a per-thread
    basis with the help of the `TrafficStats` class. The `setThreadStatsTag()` function
    will establish a tag identifier. The `tagSocket()` and `untagSocket()` functions
    will manually tag individual sockets. Here''s a typical example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，建议使用`TrafficStats`类在每个线程上设置标签。`setThreadStatsTag()`函数将建立一个标签标识符。`tagSocket()`和`untagSocket()`函数将手动标记单个套接字。以下是一个典型的例子：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Emulator Control
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟器控制
- en: 'The last tab in the DDMS is the so-called **Emulator Control**. By selecting
    one of our adb devices and starting it, a tab with some additional options will
    be shown:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS的最后一个标签页是所谓的**模拟器控制**。通过选择我们的adb设备之一并启动它，将显示带有一些附加选项的标签页：
- en: '![Emulator Control](img/Insert_Image_B04666_02_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![模拟器控制](img/Insert_Image_B04666_02_09.jpg)'
- en: 'With the emulator control, we can modify our phone network in several ways:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器控制，我们可以以多种方式修改手机网络：
- en: It is possible to select a different configuration for the data and voice (home
    network, roaming, not found, denied, and so on)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以选择不同的数据与语音配置（如家庭网络、漫游、未找到、被拒绝等）
- en: The speed and latency of the Internet connection can be defined
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义互联网连接的速度和延迟
- en: It is possible to simulate an incoming phone call or an incoming SMS from a
    defined phone number
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以模拟来自特定电话号码的来电或短信
- en: We can send fake locations to our emulator. This can be done either manually
    or by uploading a GPX/KML file
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以向模拟器发送虚假位置信息。这可以手动完成，也可以通过上传GPX/KML文件完成
- en: System status
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统状态
- en: 'The last section of the DDMS is the **System Information** tab. Here, it is
    possible to find out up to three different information categories: the CPU load,
    memory usage at the current time, and the frame render time (this one is especially
    important when benchmarking and debugging video games):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS的最后部分是**系统信息**标签页。在这里，可以找到最多三个不同的信息类别：CPU负载、当前时间的内存使用情况以及帧渲染时间（在进行游戏基准测试和调试时，这个尤其重要）：
- en: '![System status](img/Insert_Image_B04666_02_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![系统状态](img/Insert_Image_B04666_02_10.jpg)'
- en: Debugging the UI
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI调试
- en: 'We have focused until now on memory, threading, and the system aspects of Android.
    There is a more visual aspect that can also dramatically improve the performance
    of our application: the **user interface** (**UI**). Android provides a tool called
    **Hierarchy Viewer** to debug and optimize any UI designed for Android. **Hierarchy
    Viewer** provides a visual representation of the hierarchy of layouts of an application
    with information about the performance of each node that can be found on the layout.
    It provides a so-called **Pixel Perfect** window with magnified information of
    the display, in case a close look at pixels is required.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止关注的是Android的内存、线程和系统方面。还有一个更直观的方面也可以显著提高我们应用程序的性能：即**用户界面**（**UI**）。Android提供了一个名为**层次查看器**的工具，用于调试和优化为Android设计的任何UI。**层次查看器**提供了应用程序布局层次的可视化表示，并带有关于可以在布局中找到的每个节点的性能信息。它提供了一个所谓的**像素完美**窗口，其中包含放大显示信息，以便在需要仔细查看像素时使用。
- en: To run **Hierarchy Viewer**, we need first to connect our device or emulator.
    Note that, for security reasons, only devices running a developer version of the
    Android system will work with **Hierarchy Viewer**. When it has been connected,
    launch the `hierarchyviewer` program from the `/tools` directory. If you have
    not yet set up this directory as part of your system `PATH`, this is a very good
    moment to do it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行**层次查看器**，我们首先需要连接我们的设备或模拟器。请注意，出于安全原因，只有运行开发版本Android系统的设备才能与**层次查看器**一起工作。连接后，从`/tools`目录启动`hierarchyviewer`程序。如果你还没有把这个目录作为系统`PATH`的一部分，现在是设置的好时机。
- en: 'You will see a screen similar to the following one. For each device connected
    to the system, you will see a list of the attached running processes. Select one
    of the processes, and click on **Load View Hierarchy**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个类似下面的屏幕。对于连接到系统的每个设备，你将看到一个附加的运行进程列表。选择一个进程，并点击**加载视图层次**：
- en: '![Debugging the UI](img/Insert_Image_B04666_02_11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![调试UI](img/Insert_Image_B04666_02_11.jpg)'
- en: 'A new screen with the actual **Hierarchy Viewer** is opened. The **Hierarchy
    Viewer** looks as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的屏幕，显示实际的**层次查看器**。**层次查看器**如下所示：
- en: '![Debugging the UI](img/Insert_Image_B04666_02_12.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![调试UI](img/Insert_Image_B04666_02_12.jpg)'
- en: '**Hierarchy Viewer** contains the following elements:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**层次查看器**包含以下元素：'
- en: In the upper right side, the **Tree Overview** provides a bird's eye view of
    the `ViewHierarchy` application.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右上角，**树状图概览**提供了对`ViewHierarchy`应用的鸟瞰视角。
- en: The **TreeView** can be dragged and zoomed with the help of the mouse. When
    we click on an item, this item is highlighted, and we can access its properties.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树视图**可以通过鼠标拖动和缩放。当我们点击一个项目时，这个项目会被高亮显示，我们可以访问其属性。'
- en: The **Properties** pane, under the **TreeView**, provides a summary of all the
    properties of the view.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**树视图**下面的**属性**窗格，提供了视图所有属性的摘要。
- en: The **Layout** view shows a wireframe of the layout. The outline of the view
    that has been currently selected is red. If we click on an outline it will be
    selected, and the properties will be accessible in the **Properties** pane.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**视图显示了一个布局的线框图。当前选中的视图轮廓是红色的。如果我们点击一个轮廓，它将被选中，并且在**属性**窗格中可以访问其属性。'
- en: Profiling with Hierarchy Viewer
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用层次查看器进行性能分析
- en: '**Hierarchy Viewer** provides a powerful profiler to analyze and optimize the
    application. To proceed with the profiling, click the ![Profiling with Hierarchy
    Viewer](img/Insert_Image_B04666_02_36.jpg) icon, **Profile Node**. If the hierarchy
    of your view is quite large, it might take some time until it is initialized.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**层次查看器**提供了一个强大的分析器，用于分析和优化应用程序。要进行性能分析，请点击![使用层次查看器进行性能分析](img/Insert_Image_B04666_02_36.jpg)图标，选择**分析节点**。如果你的视图层次很大，可能需要一些时间才能初始化。'
- en: 'At this point, all the views in your hierarchy will get three dots:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你的层次中的所有视图都将出现三个点：
- en: The left dot represents the **Draw** process of the rendering pipeline
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左边的点代表渲染管道的**绘制**过程
- en: The middle dot represents the **Layout** phase
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的点代表**布局**阶段
- en: The right dot represents the **Execute** phase![Profiling with Hierarchy Viewer](img/Insert_Image_B04666_02_13.jpg)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右边的点代表**执行**阶段![使用层次查看器进行性能分析](img/Insert_Image_B04666_02_13.jpg)
- en: 'Each dot color within a view has a different meaning:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视图内的每个点颜色有不同的含义：
- en: A green dot means that the view is rendering faster than at least half of the
    other views. Generally, a green color can be seen as a high-performing view.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色点表示该视图的渲染速度至少比其他视图的一半快。通常，绿色可以被视为高性能视图。
- en: A yellow dot means that the view is rendering faster than the bottom half of
    the views in the hierarchy. This is only relative, but yellow colors might require
    us to take a look at the view.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色点表示该视图的渲染速度比层次中下半部分的视图快。这是相对的，但黄色可能需要我们查看这个视图。
- en: Red means the view is among the slowest half of views. Generally, we want to
    take a look at these values.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色意味着视图是层次中最慢的一半。通常，我们想要查看这些值。
- en: 'How can we interpret the result after applying the **Hierarchy Viewer** profiler?
    The most important thing to note is that the profiler is always measuring in relative
    terms, that is, against our own layout. That could mean that a node is always
    red, but not necessarily slow if the application is performing well. The other
    extreme also applies: a node could be green, but the performance could be a disaster
    if the entire application is not responsive.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用**层次查看器**探查器后，我们如何解释结果？最重要的一点是，探查器总是在相对的条件下进行测量，即针对我们自己的布局。这意味着一个节点可能总是红色，但如果应用程序运行良好，它不一定就是慢的。相反的情况也适用：一个节点可能是绿色，但如果整个应用程序没有响应，性能可能就是灾难性的。
- en: The **Hierarchy Viewer** applies a process called rasterization to acquire information.
    Rasterization, which might sound familiar to developers from a graphic programming
    background, such as videogame development, is the process of taking a graphic
    primitive (for instance, a circle) and transforming it into pixels on the screen.
    This is usually done by the GPU, but in this case, since we are dealing with software
    rasterization, it is done by the CPU. This also contributes to the relative correctness
    of the input of the **Hierarchy Viewer**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**层次查看器**应用了一个称为栅格化的过程来获取信息。对于有图形编程背景的开发者来说，如视频游戏开发，栅格化可能听起来很熟悉，它是将图形基元（例如，一个圆）转换为屏幕上的像素的过程。这通常由GPU完成，但在这个情况下，由于我们处理的是软件栅格化，所以由CPU完成。这也使得**层次查看器**的输入相对准确。'
- en: 'There are some rules to be applied in order to identify problems with **Hierarchy
    Viewer**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别**层次查看器**的问题，需要应用一些规则：
- en: Red dots in leaf nodes or view groups with only a small number of children,
    might be pointing out a problem.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶子节点或只有少数子节点的视图组中的红点可能指向一个问题。
- en: If a view group has many children and a red dot for the measure phase, take
    a look at the individual children.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个视图组有很多子节点，且在测量阶段有红点，请查看各个子节点。
- en: A root view with red dots does not necessarily mean there is a problem. This
    can happen often, since this is the parent for all the present views.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有红点的根视图不一定意味着有问题。这种情况经常发生，因为这是所有当前视图的父视图。
- en: Systrace
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Systrace
- en: Systrace is a tool included in the Google SDK to analyze the performance of
    an application. It captures and displays the execution time from your application
    on the kernel level (capturing information such as CPU scheduler, application
    threads, and disk activity). After the analysis has been completed, it generates
    an HTML file with all the information compiled.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Systrace是Google SDK中包含的一个工具，用于分析应用程序的性能。它从内核级别捕获并显示应用程序的执行时间（捕获的信息如CPU调度程序、应用程序线程和磁盘活动）。分析完成后，它会生成一个包含所有编译信息的HTML文件。
- en: 'To make it work, click the **Systrace** button in the DDMS view (![Systrace](img/Insert_Image_B04666_02_33.jpg)).
    A screen such as the following will appear:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，请点击DDMS视图中的**Systrace**按钮 (![Systrace](img/Insert_Image_B04666_02_33.jpg))。会出现如下屏幕：
- en: '![Systrace](img/Insert_Image_B04666_02_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Systrace](img/Insert_Image_B04666_02_14.jpg)'
- en: 'On this screen, we can input a few parameters for Systrace:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们可以为Systrace输入一些参数：
- en: Destination where the file will be stored as an HTML file.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标文件将存储为HTML文件的路径。
- en: 'Trace duration: the default value is 5 seconds. 30 seconds is a good value
    to cope with a good amount of information.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪持续时间：默认值为5秒。30秒是一个能获取足够信息的好值。
- en: 'Trace buffer size: how big the buffer should be for tracing.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪缓冲区大小：跟踪时缓冲区应该有多大。
- en: We can select the process from which we will enable the application traces,
    so normally we will select our own application here.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择将启用应用程序跟踪的进程，因此通常我们在这里选择自己的应用程序。
- en: We need to select some of the tags that we would like to interact with from
    the list.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要从列表中选择一些我们想要与之交互的标签。
- en: 'When everything has been selected, press the **OK** button and interact for
    a while with your application. When the systracing has finished, an HTML file
    will be stored in the location you provided. This file looks as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切选择完毕后，按下**确定**按钮，与应用程序进行一段时间的交互。当systracing完成后，将在您提供的位置存储一个HTML文件。这个文件看起来如下：
- en: '![Systrace](img/Insert_Image_B04666_02_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Systrace](img/Insert_Image_B04666_02_15.jpg)'
- en: Android device debug options
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓设备调试选项
- en: When we are debugging an Android device, we need to activate developer mode.
    This mode is hidden by default, and we need to activate it manually if we need
    to connect the device to ADB or to use some of its options. Android's creators
    did a good job at hiding this option.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调试Android设备时，需要激活开发者模式。默认情况下此模式是隐藏的，如果需要将设备连接到ADB或使用其某些选项，我们需要手动激活它。Android的创造者们很好地隐藏了这个选项。
- en: Let's see how we can activate this option to have a better understanding of
    Android debugging, and how can we play with the different debug configurations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何激活这个选项以更好地了解Android调试，以及我们如何玩转不同的调试配置。
- en: As mentioned, the developer options in the device are really hidden by default.
    The purpose for this is very likely to make it only available to advanced users
    and not to normal users. A casual person will not need to access the features
    in this section; doing so might options that could harm the device.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，设备中的开发者选项默认是隐藏的。这样做的原因很可能是为了使其仅供高级用户使用，而不是普通用户。普通用户无需访问此部分的功能；这样做可能会激活可能损坏设备的选项。
- en: 'In standard ROMs we need to go to the **About** section, scroll down until
    we see the **Build number** entry, and then tap five times in quick succession.
    A small dialog will be displayed saying that we are now a developer:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准ROM中，我们需要进入**关于**部分，向下滚动直到看到**版本号**条目，然后快速连续点击五次。会显示一个小对话框，告诉我们现在已成为开发者：
- en: '![Android device debug options](img/Insert_Image_B04666_02_16.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Android设备调试选项](img/Insert_Image_B04666_02_16.jpg)'
- en: 'Due to custom ROM customization, it might be a little bit different on some
    other devices. Here are a few popular manufacturers and how the debugging options
    can be activated:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定制ROM的个性化，其他一些设备上的设置可能会有所不同。以下是一些知名制造商以及如何激活调试选项的说明：
- en: '**Samsung**: **Settings** | **About device** | **Build number**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三星**：**设置** | **关于设备** | **版本号**'
- en: '**LG**: **Settings** | **About phone** | **Software information** | **Build
    number**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LG**：**设置** | **关于手机** | **软件信息** | **版本号**'
- en: '**HTC**: **Settings** | **About** | **Software information** | **More** | **Build
    number**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTC**：**设置** | **关于** | **软件信息** | **更多** | **版本号**'
- en: 'When the developer option has been activated, we will see (this might vary
    in different manufacturers) an option called **Developer options** in the **System**
    section. If we click on it, the options will be displayed. We need to activate
    the switch for **Developer options**, and we will have access to the entire set:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 激活开发者选项后，我们将会看到（不同制造商可能会有所不同）在**系统**部分名为**开发者选项**的选项。如果我们点击它，将显示选项。我们需要激活**开发者选项**的开关，这样我们就可以访问整个设置：
- en: '![Android device debug options](img/Insert_Image_B04666_02_17.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Android设备调试选项](img/Insert_Image_B04666_02_17.jpg)'
- en: 'Again, options might vary from each manufacturer to the next. However, this
    is a comprehensive list of the default options in Android:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每个制造商的选项可能会有所不同。然而，以下是Android中的默认选项的全面列表：
- en: '**Take a bug report**: This option will collect information about the current
    state of the device and send it as an e-mail. It might take some time, since a
    lot of information might be collected.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取错误报告**：此选项将收集关于设备当前状态的信息，并将其作为电子邮件发送。这可能需要一些时间，因为可能会收集大量信息。'
- en: '**Desktop backup password**: This sets up a password for full desktop backups,
    which by default are not password-protected.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桌面备份密码**：这为完整的桌面备份设置一个密码，默认情况下这些备份是没有密码保护的。'
- en: '**Stay awake**: The device will stay awake continuously while it is being charged,
    which is very handy for debugging.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持唤醒**：设备在充电时将一直保持唤醒状态，这对于调试来说非常方便。'
- en: '**Always stay awake**: Similar to the previous one, but in this case the device
    will always be awake regardless of whether it is being charged or not. It can
    be dangerous if the developer forgets to activate it, since the device will be
    awake even after developing.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总是保持唤醒**：与上一个类似，但在这种情况下，无论设备是否在充电，设备都将保持唤醒状态。如果开发者忘记激活它，这可能会很危险，因为即使在开发后，设备也会保持唤醒状态。'
- en: '**HDCP checking**: **HDCP** stands for **High-bandwidth Digital Content Protection**.
    We can set up this option to never check for digital protection, to always check
    for digital protection, and to do so only in the case of DRM content.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HDCP检查**：**HDCP**代表**高带宽数字内容保护**。我们可以设置此选项为从不检查数字保护，总是检查数字保护，以及仅在DRM内容情况下检查。'
- en: '**Enable Bluetooth HCI snoop log**: When this option is activated, all HCI
    Bluetooth packages will be saved in a file.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用蓝牙HCI嗅探日志**：激活此选项后，所有HCI蓝牙包将被保存在一个文件中。'
- en: '**Process stats**: This section contains geeky stats about the device''s processes.
    It displays the background applications that have been running for the last two
    hours, as well as some particular information for them (such as average/maximum
    RAM usage, runtime, and running services):![Android device debug options](img/Insert_Image_B04666_02_18.jpg)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程统计**：此部分包含关于设备进程的极客统计数据。它显示了过去两小时一直在后台运行的应用程序，以及它们的一些特定信息（例如平均/最大RAM使用量、运行时间和运行中的服务）：![Android设备调试选项](img/Insert_Image_B04666_02_18.jpg)'
- en: '**USB debugging**: This enables the device to debug applications with ADB when
    the USB is connected. This should be the first option to be activated by a developer.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB调试**：当连接USB时，此选项允许设备使用ADB调试应用程序。这应该是开发者首先激活的选项。'
- en: '**Bug report shortcut**: This option shows a button in the power menu that
    can be pressed in order to take a bug report.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误报告快捷方式**：此选项在电源菜单中显示一个按钮，可以按此按钮来获取错误报告。'
- en: '**Allow mock locations**: Locations can be mocked when this option has been
    activated.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许模拟位置**：激活此选项后，可以模拟位置信息。'
- en: '**Enable view attribute inspection**: By activating this option, we will be
    able to view the attribute inspection in the Android system manager.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用视图属性检查**：激活此选项后，我们能够在Android系统管理器中查看属性检查。'
- en: '**Select debug app**: Through this option we are able to select the application
    to be debugged, without having to type long `adb` commands.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择调试应用**：通过此选项，我们能够选择要调试的应用程序，无需输入冗长的`adb`命令。'
- en: '**Wait for debugger**: This option attaches the app being debugged (selected
    in the previous option) to the debugger.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待调试器**：此选项将正在调试的应用（在上一个选项中选择）附加到调试器。'
- en: '**Verify apps over USB**: This option is deactivated by default, unless the
    USB debugging option is active. Any content being installed manually will be verified
    to avoid the installation of malware.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过USB验证应用**：此选项默认是禁用的，除非USB调试选项处于激活状态。手动安装的任何内容都将被验证，以避免安装恶意软件。'
- en: '**Wireless display certification**: Use this option to help with the certification
    of the Alliance Wi-Fi Display specification.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无线显示认证**：使用此选项帮助认证Alliance Wi-Fi Display规范。'
- en: '**Enable Wi-Fi verbose logging**: This option enables a more comprehensive
    log for all Wi-Fi operations.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用Wi-Fi详细日志记录**：此选项为所有Wi-Fi操作启用更全面的日志记录。'
- en: '**Aggressive WiFi to cellular handover**: This option artificially reduces
    the Wi-Fi **Received Signal Strength Indication** (**RSSI**) to encourage the
    Wi-Fi state machine to decide to switch the connection.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积极的Wi-Fi到蜂窝网络切换**：此选项人为地降低Wi-Fi的**接收信号强度指示**（**RSSI**），以鼓励Wi-Fi状态机决定切换连接。'
- en: '**Always allow Wi-Fi roam scans**: Android devices already connected to a Wi-Fi
    network by default do not roam when a stronger SSID is available. With this option
    activated, the device will permanently roam for a new Wi-Fi.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终允许Wi-Fi漫游扫描**：默认情况下，已经连接到Wi-Fi网络的Android设备在遇到更强的SSID时不会漫游。激活此选项后，设备将永久性地寻找新的Wi-Fi。'
- en: '**Logger buffer sizes**: This option alters the size of each logger buffer
    (by default, this is 256 K).'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录器缓冲区大小**：此选项改变每个记录器缓冲区的大小（默认为256 K）。'
- en: '**Show touches**: Each time there is interaction with the screen, there will
    be visual feedback if this option is activated.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示触摸**：如果激活此选项，每次与屏幕互动时都会有视觉反馈。'
- en: '**Pointer location**: This is similar to the previous one: the pointer will
    be located on the screen with two perpendicular lines. At the top of the screen,
    there will be numerical information.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针位置**：这与上一个类似：指针将在屏幕上用两条垂直线标出。在屏幕顶部，将显示数字信息。'
- en: '**Show surface updates**: When the screen is being updated, the entire surface
    will flash (not recommended for epileptics).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示表面更新**：当屏幕更新时，整个表面会闪烁（不建议癫痫患者使用）。'
- en: '**Show layout bounds**: This is one of the most useful options when we are
    debugging layouts. Once this is enabled, you should see all of the bounding areas
    of your views displayed in vibrant blue and purple:![Android device debug options](img/Insert_Image_B04666_02_19.jpg)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示布局边界**：在调试布局时，这是最有用的选项之一。激活后，你应该能看到所有视图边界的活泼蓝色和紫色显示：![Android设备调试选项](img/Insert_Image_B04666_02_19.jpg)'
- en: '**Force RTL layout direction**: This forces the layout directions from right
    to left instead of the default left to right. Some users might like them right
    to left, but for certain languages (such as Arabic or Hebrew), this is how the
    layouts will automatically be set up. We can use this mode to test that our applications
    behave properly under this configuration.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制RTL布局方向**：这将强制布局方向从右至左，而不是默认的左至右。一些用户可能喜欢从右至左的布局，但对于某些语言（如阿拉伯语或希伯来语），布局会自动设置为这种方式。我们可以使用此模式来测试应用程序在此配置下的行为是否正常。'
- en: '**Window animation scale**: You can select the animation speed of each window
    (between 0.5x and 10x) or deactivate it.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口动画缩放**：您可以设置每个窗口的动画速度（介于0.5倍和10倍之间）或取消激活。'
- en: '**Transition animation scale**: You can select the animation speed of each
    transition (between 0.5x and 10x) or deactivate it.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡动画缩放**：您可以设置每个过渡的动画速度（介于0.5倍和10倍之间）或取消激活。'
- en: '**Animator animation scale**: You can select the animation speed for each animator
    (between 0.5x and 10x) or deactivate it.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画师动画缩放**：您可以设置每个动画师的动画速度（介于0.5倍和10倍之间）或取消激活。'
- en: '**Simulate secondary displays**: This setting allows developers to simulate
    a different screen size in a secondary display.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟辅助显示**：此设置允许开发人员模拟辅助显示的不同屏幕尺寸。'
- en: '**Force GPU rendering**: Uses hardware 2D rendering. This can either make your
    app look great or kill the performance. Use it for debugging purposes only.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制GPU渲染**：使用硬件2D渲染。这可以使你的应用程序看起来很棒，也可能降低性能。仅用于调试目的。'
- en: '**Show GPU view updates**: Every element being drawn with GPU hardware will
    be overlaid with a red square.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示GPU视图更新**：每个使用GPU硬件绘制的元素都将被一个红色方块覆盖。'
- en: '**Show hardware layers updates**: This option indicates any time when the hardware
    layers are being updated.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示硬件层更新**：此选项指示硬件层更新的任何时间。'
- en: '**Debug GPU overdraw**: Visualizes overdraw with a code of colors in elements,
    depending on how often they are being drawn: This can be used to research where
    an app might be doing more rendering work than necessary. The screen will begin
    to display a big set of colors, but do not panic! We can easily read what they
    mean:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试GPU过度绘制**：使用颜色代码可视化元素的过度绘制，具体取决于它们被绘制的频率：这可以用来研究应用程序可能进行不必要的渲染工作的地方。屏幕将开始显示大量颜色，但不要惊慌！我们可以轻松地读懂它们的含义：'
- en: '**True color**: The true color means that there has been no overdraw during
    the execution'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实色彩**：真实色彩意味着在执行过程中没有发生过度绘制。'
- en: '**Blue**: An overdrawn did happen once'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色**：发生了单次过度绘制。'
- en: '**Green**: There was an overdraw twice in the context of the application'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：在应用程序的上下文中发生了两次过度绘制。'
- en: '**Pink**: The overdraw happened three times'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粉色**：过度绘制发生了三次。'
- en: '**Red**: There was an overdraw four or more times'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：发生了四次或更多次的过度绘制。'
- en: '![Android device debug options](img/Insert_Image_B04666_02_20.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Android设备调试选项](img/Insert_Image_B04666_02_20.jpg)'
- en: '**Force 4x MSAA**: Enables 4x **MSAA** (stands for **Multi Sample Anti Aliasing**).
    This will make your application faster and will also improve the image quality.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制4x MSAA**：启用4x **MSAA**（即**多采样抗锯齿**）。这将使你的应用程序运行更快，同时提高图像质量。'
- en: '**Disable HW overlays**: With a hardware overlay, each application gets its
    own portion of video memory, getting rid of the need to check for collisions and
    clipping. This option will disable hardware overlays.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用硬件覆盖**：使用硬件覆盖，每个应用程序都获得自己的视频内存部分，无需检查碰撞和剪辑。此选项将禁用硬件覆盖。'
- en: '**Simulate color space**: With this option, we can force Android to simulate
    the screen in only a certain combination of colors (for example, monochrome, red-green,
    red-yellow, and so on).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟色彩空间**：使用此选项，我们可以强制Android仅模拟特定颜色组合的屏幕（例如，单色、红绿色、红黄色等）。'
- en: '**Use NuPlayer (experimental)**: NuPlayer is a video player for supporting
    online video content. It has a lot of bugs, so is disabled by default. With this
    option NuPlayer will be activated.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用NuPlayer（实验性）**：NuPlayer是一个支持在线视频内容的视频播放器。它有很多错误，因此默认情况下是禁用的。启用此选项后，NuPlayer将被激活。'
- en: '**Disable USB audio routing**: This option disables the automatic redirection
    of USB audio routing to external peripherals.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用USB音频路由**：此选项禁用了USB音频路由自动重定向到外部外围设备。'
- en: '**Strict mode enabled**: StrictMode is a developer mode that detects problems
    that a developer might be having, and then notifies them so they can be fixed.
    StrictMode typically catches actions such as network accesses in incorrect threads.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用严格模式**：StrictMode 是一种开发者模式，它可以检测开发者可能遇到的问题，并通知他们以便修复。StrictMode 通常会捕获如在错误线程中进行网络访问等操作。'
- en: '**Show CPU usage**: This option, when activated, overlays information about
    the CPU usage at the top of the screen.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示 CPU 使用情况**：激活此选项后，会在屏幕顶部叠加有关 CPU 使用情况的信息。'
- en: '**Profile GPU rendering**: This tool, when it has been activated, provides
    a visual representation of the speed and rhythm of rendering UI frames. This is
    only available from Android 4.1\. In the following screen, we see an example of
    the **Profile GPU rendering** tool, and here we have some instructions about how
    to understand it:![Android device debug options](img/Insert_Image_B04666_02_21.jpg)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析 GPU 渲染**：当激活这个工具时，它会提供 UI 帧的速度和节奏的视觉表示。这仅从 Android 4.1 开始可用。在下面的屏幕中，我们看到了一个
    **分析 GPU 渲染** 工具的例子，这里有一些关于如何理解它的说明：![Android 设备调试选项](img/Insert_Image_B04666_02_21.jpg)'
- en: The horizontal axis represents the elapsed time, and the vertical axis is the
    time per frame in milliseconds.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平轴表示经过的时间，垂直轴表示每帧的时间（以毫秒为单位）。
- en: Each vertical bar corresponds with one rendered frame. The taller the bar, the
    longer it needed to be rendered.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个垂直条形图对应一个渲染的帧。条形越高，渲染所需的时间就越长。
- en: The green line represents 16 milliseconds. Every time a frame crosses the green
    line your application is missing a frame, which may lead to the user perceiving
    it as stuttering images.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色线条代表 16 毫秒。每次帧超过绿色线条，你的应用程序就会丢失一帧，这可能导致用户感觉到图像出现卡顿。
- en: 'Each of the color lines has a meaning: the blue section of the bar represents
    the time used to create and update the view''s display lists. If this part of
    the bar is tall, there may be a lot of custom view drawing or a lot of work in
    the `onDraw` methods.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种颜色的线条都有其含义：条形图的蓝色部分表示用于创建和更新视图显示列表的时间。如果这部分条形很高，可能存在大量的自定义视图绘制或者在 `onDraw`
    方法中有很多工作。
- en: The purple section is the time spent transferring resources to the render thread
    (only from Android 4.1). The red section of the bar represents the time spent
    by Android's 2D renderer sending commands to OpenGL in order to draw and redraw
    display lists.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紫色部分是花费在将资源传输到渲染线程上的时间（仅限 Android 4.1）。条形图的红色部分表示 Android 的 2D 渲染器发送命令到 OpenGL
    以绘制和重绘显示列表所花费的时间。
- en: The orange section represents the time the CPU waits until the GPU is finished.
    If this bar is too long, the GPU is spending too much time performing operations.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙色部分表示 CPU 等待 GPU 完成的时间。如果这个条形太长，说明 GPU 在执行操作上花费了太多时间。
- en: '**Enable OpenGL traces**: Enables tracing OpenGL in a log file of your choice.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用 OpenGL 跟踪**：允许在您选择的日志文件中跟踪 OpenGL。'
- en: '**Don''t keep activities**: This setting closes every application as soon as
    you leave its main view. There''s no need to say that one must be careful with
    this since it will alter the state of every application.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不保留活动**：这个设置会在你离开主视图时立即关闭每个应用程序。不用说，必须小心使用这个设置，因为它会改变每个应用程序的状态。'
- en: '**Background process limit**: With this option, we can limit the number of
    background processes that will be running in parallel.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台进程限制**：使用此选项，我们可以限制同时运行的后台进程的数量。'
- en: '**Show all ANRs**: Every ANR will be displayed when the application is being
    blocked by an *Application Not Responding* error, even if this is happening in
    the background.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示所有 ANR**：当应用程序因 *应用程序无响应* 错误而受阻时，即使这在后台发生，也会显示每个 ANR。'
- en: Android Instant Run
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Instant Run
- en: At the time of writing, Google released Android Studio 2.2 Preview. This is
    (as the name suggests) the second major version of Android Studio, and it comes
    with many fixes, performance improvements, and an awesome tool called **Android
    Instant Run**. This tool allows us to perform changes in the code and display
    them instantly in our device or emulator. This is a priceless feature when we
    are debugging, since we do not need to recompile the application, start it again,
    and reconnect it to `adb`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，谷歌发布了 Android Studio 2.2 预览版。这（正如其名所示）是 Android Studio 的第二个主要版本，它包含了许多修复、性能改进以及一个名为
    **Android Instant Run** 的强大工具。这个工具允许我们在代码中进行更改，并立即在我们的设备或模拟器中显示这些更改。当我们进行调试时，这是一个无价的功能，因为我们不需要重新编译应用程序，再次启动它，并重新连接到
    `adb`。
- en: 'To activate this option, we need to go to **Preferences**, then look for **Build,
    Execution, Deployment** | **Instant Run**. Check **Enable Instant Run to hot swap
    code/resource changes on deploy (default enabled)**; if you are running the right
    version of the Gradle plugin, you will be able to activate it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活此选项，我们需要进入**首选项**，然后查找**构建、执行、部署** | **立即运行**。勾选**启用立即运行以在部署时热交换代码/资源更改（默认启用）**；如果你运行的是正确版本的
    Gradle 插件，你将能够激活它：
- en: '![Android Instant Run](img/Insert_Image_B04666_02_22.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Android 立即运行](img/Insert_Image_B04666_02_22.jpg)'
- en: 'To run an application, select **Run** so Android Studio operates normally.
    Now comes the interesting part: after you have performed edits or modifications
    on your source code, clicking **Run** once more will only deploy the changes to
    the device or emulator.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，选择**运行**以使 Android Studio 正常运行。现在有趣的部分来了：在对源代码进行编辑或修改之后，再次点击**运行**将只将更改部署到设备或模拟器。
- en: 'At the moment, there are a few operations that are not supported by **Instant
    Run**:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，**立即运行**不支持以下几项操作：
- en: Add, remove, or change annotations
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、移除或更改注解
- en: Add, remove, or change an instance field
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、移除或更改实例字段
- en: Add, remove, or change a static field
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、移除或更改静态字段
- en: Add or remove a static method signature
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或移除静态方法签名
- en: Change a static method signature
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改静态方法签名
- en: Add or remove an instance method
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或移除实例方法
- en: Change an instance method signature
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改实例方法签名
- en: Changing which parent class the current class inherits from
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改当前类继承的父类
- en: Change the list of implemented interfaces
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改实现的接口列表
- en: Changing the static initializer of a class
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改类的静态初始化器
- en: Add, remove, or change a string (allowed, but requires a restart of the hosting
    activity)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、移除或更改字符串（允许，但需要重新启动宿主活动）
- en: GPU profiler
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU 分析工具
- en: The GPU profiler is also an experimental tool included in Android Studio 2.0\.
    This tool aims to help us understand what has caused a particular problem in a
    rendering outcome, and to inspect the GPU's state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 分析工具也是 Android Studio 2.0 中包含的一个实验性工具。这个工具旨在帮助我们理解导致渲染结果中特定问题的原因，并检查 GPU
    的状态。
- en: The GPU debugging tools (where the GPU profiler is included) are not installed
    by default. To do this, we need to install them from the SDK tools section of
    the SDK manager.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 调试工具（其中包括 GPU 分析工具）默认情况下未安装。为此，我们需要从 SDK 管理器的 SDK 工具部分进行安装。
- en: To use this profiler within our application, we need to load the trace library
    in our application. We can do this either in our Java code or in our C++ code
    (something that makes sense, if we consider that a lot of the code used for graphics
    runs in C++ due to its better performance). Regardless of which method you use,
    you need to copy the library into your project to be loaded. The libraries will
    be located in `<sdkDir>/extras/android/gapid/android/<abi>/libgapii.so`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用此分析工具，我们需要在应用程序中加载跟踪库。我们可以在 Java 代码或 C++ 代码中执行此操作（考虑到许多用于图形的代码因性能更佳而运行在
    C++ 中，这是有意义的）。无论你使用哪种方法，都需要将库复制到项目中以便加载。库位于 `<sdkDir>/extras/android/gapid/android/<abi>/libgapii.so`。
- en: We also need to copy some other relevant folders into the `jniLibs` directory.
    This can be found in `<projectDir>/app/src/main/jniLibs`. If it doesn't already
    exist, you should create it (there will be an introduction to the NDK and how
    to deal with native code in future chapters). Like the SDK manager folder, `jniLibs`
    should contain one folder for each ABI that you plan to support. If you don't
    know which ABIs you plan to support, you can copy all of the folders. Your final
    project directory structure should look like `<projectDir>/app/src/main/jniLibs/<abi>/libgappii.so`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将一些其他相关文件夹复制到 `jniLibs` 目录中。可以在 `<projectDir>/app/src/main/jniLibs` 中找到它。如果它尚不存在，你应该创建它（在后续章节中会有介绍
    NDK 以及如何处理本地代码的内容）。与 SDK 管理器文件夹一样，`jniLibs` 应该包含你计划支持的每个 ABI 的一个文件夹。如果你不知道你计划支持哪些
    ABI，可以复制所有文件夹。最终的项目目录结构应该如下所示：`<projectDir>/app/src/main/jniLibs/<abi>/libgappii.so`。
- en: 'In order to load the library in native code, we need to create a code snippet
    similar to the following one:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地代码中加载库，我们需要创建一个类似于以下代码段的代码：
- en: '[PRE3]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to load it into the main class, the following code snippet must be
    used:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其加载到主类中，必须使用以下代码段：
- en: '[PRE4]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: Detailed steps to download the code bundle are mentioned in the *Preface* of
    this book. The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Android-High-Performance-Programming](https://github.com/PacktPublishing/Android-High-Performance-Programming).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本书*前言*中提到了下载代码包的详细步骤。本书的代码包也托管在GitHub上，地址为[https://github.com/PacktPublishing/Android-High-Performance-Programming](https://github.com/PacktPublishing/Android-High-Performance-Programming)。我们还有其他丰富的书籍和视频代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)查看。请查看！
- en: Running a trace
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行跟踪
- en: When we have added the trace library to our application, it will block on startup
    until it can connect to the trace receiver of Android Studio. That means you need
    to remove the trace library when you are done with the profiler, since it will
    lead to a useless render.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中添加了跟踪库时，它将在启动时阻塞，直到能够连接到Android Studio的跟踪接收器。这意味着当你完成分析器的工作后，需要移除跟踪库，因为它会导致无用的渲染。
- en: In order to start a trace, just run and deploy your application. A blank screen
    will first be prompted while it is waiting for the trace receiver to connect.
    To enable it, go to the CPU/GPU tab of the DDMS, and click on the red trace button,
    which you can find on the left side of the GPU tab (![Running a trace](img/Insert_Image_B04666_02_37.jpg)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始跟踪，只需运行并部署你的应用程序。首先会提示一个空白屏幕，等待跟踪接收器连接。要启用它，请转到DDMS的CPU/GPU标签页，并点击GPU标签页左侧的红色跟踪按钮（![Running
    a trace](img/Insert_Image_B04666_02_37.jpg)）。
- en: When the tracing starts, the application unlocks and we can interact with it.
    When we are done with the tracing, we need to click on the trace button again
    to stop the tracing process. When the file has been written, it will be opened.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 开始跟踪后，应用程序将解锁，我们可以与之交互。完成跟踪后，我们需要再次点击跟踪按钮以停止跟踪过程。文件写入后，它将被打开。
- en: '![Running a trace](img/Insert_Image_B04666_02_23.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Running a trace](img/Insert_Image_B04666_02_23.jpg)'
- en: ClassyShark
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClassyShark
- en: 'ClassyShark is a standalone Android diagnosing tool developed by Boris Farber,
    Developer Advocate at Google. ClassyShark serves as an Android executable browser,
    and is a valuable tool to navigate through Android classes and their internals:
    class interfaces and members, dependencies, dex structure and counts, and so on.
    ClassyShark has been released under the Apache 2.0 license, and it can be freely
    downloaded from [https://github.com/google/android-classyshark](https://github.com/google/android-classyshark).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ClassyShark是由谷歌的开发者倡导者Boris Farber开发的一款独立的Android诊断工具。ClassyShark可以作为Android可执行文件浏览器，是浏览Android类及其内部结构（类接口和成员、依赖关系、dex结构和计数等）的有价值工具。ClassyShark已根据Apache
    2.0许可发布，可以从[https://github.com/google/android-classyshark](https://github.com/google/android-classyshark)免费下载。
- en: ClassyShark is a useful tool when it comes to analyzing the inner content of
    an Android APK, and diagnoses problems early that might happen due to multidex
    or dexing problems, dependencies and sub-libraries being added, circular dependencies,
    and problems with native code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析Android APK内部内容时，ClassyShark是一个有用的工具，它可以早期诊断由于多dex或dexing问题、添加的依赖关系和子库、循环依赖以及本地代码问题可能发生的问题。
- en: Getting started
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'In order to get started with ClassyShark, the fastest way is to download the
    last `.jar` from the GitHub site (as the time of writing this book, version 6.6
    can be downloaded from the following URL: [https://github.com/google/android-classyshark/releases](https://github.com/google/android-classyshark/releases)).
    Download the latest version and then run it from the console with the following
    command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用ClassyShark，最快的方法是从GitHub网站下载最新的`.jar`文件（在撰写本书时，可以从以下URL下载6.6版本：[https://github.com/google/android-classyshark/releases](https://github.com/google/android-classyshark/releases)）。下载最新版本，然后从控制台使用以下命令运行：
- en: '[PRE5]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will start the application. You will be prompted with a screen like the
    following one:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序。你会看到一个如下面的屏幕：
- en: '![Getting started](img/Insert_Image_B04666_02_38.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Getting started](img/Insert_Image_B04666_02_38.jpg)'
- en: It is now time to open a sample APK to see its composition and start using ClassyShark.
    Click on the ![Getting started](img/Insert_Image_B04666_02_40.jpg) icon and a
    screen to select an APK will be displayed. Select an APK from one of your projects
    (if you have been using Android Studio, they are generally in the `build/output/apk`
    folder). For this purpose, any APK file will be valid.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是打开一个示例APK来查看其组成并开始使用ClassyShark的时候了。点击![入门](img/Insert_Image_B04666_02_40.jpg)图标，将显示一个选择APK的屏幕。从你的项目中选择一个APK（如果你使用的是Android
    Studio，它们通常在`build/output/apk`文件夹中）。为此，任何APK文件都是有效的。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to automate ClassyShark or you feel more comfortable with the command
    line, it is also possible to open the APK directly by running the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自动化ClassyShark，或者你更习惯于命令行，也可以通过运行以下命令直接打开APK：
- en: '[PRE6]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you have opened the file, you will be able to see something similar to
    the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件后，你将能够看到类似于以下截图的内容：
- en: '![Getting started](img/Insert_Image_B04666_02_39.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/Insert_Image_B04666_02_39.jpg)'
- en: On the left side, we can see a tree structure with the folders and the resources
    of the APK file (including all the files inside `classes.dex`).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧，我们可以看到一个包含APK文件文件夹和资源的树状结构（包括`classes.dex`内的所有文件）。
- en: 'On the right side we can see a summary of the source code composition for the
    APK:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧，我们可以看到APK源代码组成的摘要：
- en: The number of classes
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的数量
- en: The number of strings
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的数量
- en: How many fields are declared within the APK
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: APK内声明了多少个字段
- en: The number of methods in the APK
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: APK中的方法数量
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The number of limits is a particularly important upper limit when an application
    is being developed. In particular, we can reference a large number of methods
    on an APK, but we can only call the first 65,536\. There is no more space for
    invocation instructions. This was for some time a cause of controversy and discussion
    about how could it be solved, and most of the solutions have an impact on the
    performance of the application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 限制数量在应用程序开发时尤其是一个重要的上限。特别是，我们可以引用APK上的大量方法，但我们只能调用前65,536个。再也没有空间存放调用指令了。这个问题曾一度引发了争议和讨论，关于如何解决它，大多数解决方案都会影响应用程序的性能。
- en: 'If we navigate through the `classes.dex` file, we will see all the source code
    belonging to the APK (please refer to classes that have been obfuscated with ProGuarded),
    including the source code of libraries such as Android Support, third-party libraries,
    and so on. So, to make it interesting, try selecting one of the classes belonging
    to your own application, and then click on it. You should be able to display a
    dialog similar to the following one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们浏览`classes.dex`文件，将看到属于APK的所有源代码（请参考被ProGuard混淆的类），包括像Android Support、第三方库等库的源代码。为了使它更有趣，尝试选择属于您自己应用程序的一个类，然后点击它。你应该能够显示一个类似于以下对话框：
- en: '![Getting started](img/Insert_Image_B04666_02_41.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/Insert_Image_B04666_02_41.jpg)'
- en: Note that all the fields, methods, and constructors of the files are being displayed
    here. For all the graphics and stats aficionados, clicking on the **Methods count**
    tab displays an interactive pie chart. Clicking on any of the sections of the
    pie chart will display a subsection. We can also expand on the tree of each of
    the groups. This way, we can easily track many issues with ClassyShark, such as
    missing libraries, references to methods from other sub libraries, and so on.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里展示了所有文件的字段、方法和构造函数。对于所有图形和统计信息的爱好者，点击**方法计数**标签会显示一个交互式饼图。点击饼图上的任何部分，将展示一个子部分。我们还可以展开每个组的树状结构。这样，我们可以轻松地追踪ClassyShark中的许多问题，例如缺少库，引用来自其他子库的方法等。
- en: '![Getting started](img/Insert_Image_B04666_02_42.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/Insert_Image_B04666_02_42.jpg)'
- en: 'We have previously mentioned the 65 K limit in Android. One of the common solutions
    to this problem is multidexing: that means including several `.dex` files so each
    of them contains under 65 K methods. While this solves the limit problem, it can
    lead to some performance problems.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了Android的65 K限制。这个问题的常见解决方案之一是使用multidexing：这意味着包含几个`.dex`文件，每个文件包含不超过65
    K的方法。虽然这解决了限制问题，但它可能导致一些性能问题。
- en: 'With ClassyShark, we can accurately find out in which of the `.dex` files a
    method has been included. When several `.dex` files have been included, all of
    them will be displayed, as in the following screenshot (from the I/O schedule
    application):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ClassyShark，我们可以准确地确定一个方法被包含在哪个`.dex`文件中。当包含多个`.dex`文件时，它们都将被显示出来，如下面的截图（来自I/O调度应用程序）所示：
- en: '![Getting started](img/Insert_Image_B04666_02_43.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![开始](img/Insert_Image_B04666_02_43.jpg)'
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Debugging an Android application is a science that a developer needs to be able
    to master. Most debugging tools have a learning curve in order to be able to play
    with them efficiently, and to know which one needs to be used in a particular
    situation. Android provides a set of tools that take some time to get to know,
    and due to the particular nature of Android as a mobile platform, some tools require
    specific knowledge of debugging, such as threading and memory management.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Android应用程序是一门科学，开发者需要掌握。大多数调试工具都有一个学习曲线，以便能够有效地使用它们，并了解在特定情况下需要使用哪个工具。Android提供了一套工具，需要一些时间来熟悉，由于Android作为一个移动平台的特殊性，一些工具需要具备特定的调试知识，如线程和内存管理。
- en: After reading this chapter, the user will be aware of all the problems that
    can happen when we are developing an Android application (ANRs, memory leaks,
    incorrect threading, and so on) and which tool must be used in order to analyze
    it, and then solve it. Using advanced techniques, such as profiling, will help
    us to find bugs, memory leaks, and incorrect threading on our application; these
    things cannot be easily seen by merely using the application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章节后，用户将了解到在开发Android应用程序时可能遇到的全部问题（如ANRs、内存泄漏、错误的线程处理等），以及必须使用哪些工具来进行分析并解决问题。使用高级技术，如性能分析，将帮助我们找到程序中的错误、内存泄漏和错误的线程处理；这些仅通过使用应用程序是无法轻易发现的。
