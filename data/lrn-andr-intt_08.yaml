- en: Chapter 8. Broadcasting Intents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 广播意图
- en: In the previous chapter, we learned about intent filters and how these filters
    provide information about different activities, services, and so on, to the Android
    OS. We also discussed how intent filters work and how they match the coming intent
    object with attributes. This chapter also provides information on action, data,
    and category tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了意图过滤器以及这些过滤器如何向安卓操作系统提供有关不同活动、服务等的信息。我们还讨论了意图过滤器的工作原理以及它们如何将到来的意图对象与属性相匹配。本章还提供了关于动作、数据和类别测试的信息。
- en: Intents are the asynchronous way of sending messages between different components
    of the Android OS. So far, we have only learned to send and receive those messages,
    that is, the intents from one component to another component. But in each of the
    examples we discussed, we had the information about the receiver of the intent,
    such as which activity or service will receive the intent and will use the data
    embedded in the intent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是安卓操作系统不同组件之间异步发送消息的方式。到目前为止，我们只学会了如何从一个组件向另一个组件发送和接收这些消息，即意图。但在我们讨论的每个示例中，我们都有关于意图接收者的信息，比如哪个活动或服务将接收意图并使用嵌入在意图中的数据。
- en: In this chapter, we will be extending our knowledge of sending intents to multiple
    broadcast receivers. We will learn how intents are broadcasted by the Android
    OS and how these broadcast intents are received.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展有关向多个广播接收器发送意图的知识。我们将学习安卓操作系统如何广播意图，以及这些广播意图是如何被接收的。
- en: 'This chapter includes the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节包括以下主题：
- en: Broadcasting in the Android OS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安卓操作系统中的广播
- en: Broadcast intents in the Android OS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓操作系统中的广播意图
- en: System broadcasts in the Android OS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓操作系统中的系统广播
- en: Using the different system broadcasts of the Android OS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安卓操作系统的不同系统广播
- en: Detecting the battery-low broadcast
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测电池电量低广播
- en: Detecting the screen `On`/`Off` broadcast
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测屏幕`开启`/`关闭`广播
- en: Detecting the cell phone reboot completed broadcast
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测手机重启完成广播
- en: Sending/receiving custom broadcast intents
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送/接收自定义广播意图
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The concept of intents and the structure of intents, as discussed in [Chapter
    2](ch02.html "Chapter 2. Introduction to Android Intents"), *Introduction to Android
    Intents* and [Chapter 3](ch03.html "Chapter 3. Intent and Its Categorization"),
    *Intents and Its Categorization* are the prerequisites for understanding this
    chapter and the further chapters. If you don't have the basic concepts of these
    things, we would recommend that you read [Chapter 3](ch03.html "Chapter 3. Intent
    and Its Categorization"), *Intents and Its Categorization* and [Chapter 4](ch04.html
    "Chapter 4. Intents for Mobile Components"), *Intents for Mobile Components* in
    order to move forward.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解本章及后续章节，需要掌握[第二章](ch02.html "第二章 安卓意图简介")*安卓意图简介*和[第三章](ch03.html "第三章 意图及其分类")*意图及其分类*中讨论的意图概念和意图结构。如果你对这些基础概念不熟悉，我们建议你阅读[第三章](ch03.html
    "第三章 意图及其分类")*意图及其分类*和[第四章](ch04.html "第四章 移动组件的意图")*移动组件的意图*，以便继续学习。
- en: Broadcasting in the Android OS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在安卓操作系统中的广播
- en: Any smartphone running Android OS has a lot of services and actions being executed
    at a particular time. These services and actions can be in the foreground or in
    the background. So the question that comes in our mind here is what these services
    and actions are actually doing. The answer is very simple. These services and
    actions are looking or listening for some events to occur, or performing some
    long operation in the background, or communicating with other components of Android
    OS, and so on. You might be wondering how these components listen for the occurrence
    of any event or how they communicate with other components, especially in background
    when user can't interact with the application directly. In the Android OS, these
    types of tasks are achieved by broadcasting. The Android OS continuously broadcasts
    the information about different actions, such as whether power has been connected
    and Wi-Fi has been turned on. We, the developers, use this broadcast information
    in our apps to make our apps more interactive and smart. In the next section,
    we will see how the Android OS broadcasts different information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运行Android操作系统的智能手机在特定时间都有很多服务和动作在执行。这些服务和动作可能在前景或后台运行。那么这里我们可能会想，这些服务和动作实际在做什么呢？答案非常简单。这些服务和动作在等待某些事件的发生，或在后台执行一些长时间的操作，或与Android操作系统的其他组件进行通信等等。你可能会想知道这些组件如何在事件发生时进行监听，或者它们如何在后台与其他组件进行通信，尤其是当用户不能直接与应用程序交互时。在Android操作系统中，这类任务是通过广播来完成的。Android操作系统不断地广播有关不同动作的信息，例如是否连接了电源和是否开启了Wi-Fi。我们作为开发者，在我们的应用程序中使用这些广播信息，使我们的应用程序更具互动性和智能。在下一节中，我们将了解Android操作系统如何广播不同的信息。
- en: The broadcast intents
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播意图
- en: The broadcast intents are the `Intent` objects that are broadcasted via a method
    call to the `sendBroadcast()`, `sendStickyBroadcast()`, or `sendOrderedBroadcast()`
    methods of any `Activity` class. These broadcast intents provide a messaging and
    event system between different application components. Also, these intents are
    used by the Android OS to notify interested applications about system events such
    as low battery or whether headphones have been plugged in. To create an instance
    of the broadcast intent, we must include an action string in it. An action stringis
    used to identify the broadcast intent, and it is unique. This action string typically
    uses the Java package name format.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 广播意图是通过调用任何`Activity`类的`sendBroadcast()`、`sendStickyBroadcast()`或`sendOrderedBroadcast()`方法来广播的`Intent`对象。这些广播意图为不同的应用程序组件之间提供了一个消息和事件系统。此外，Android操作系统还使用这些意图来通知感兴趣的应用程序关于系统事件，比如电量低或者是否插入了耳机。要创建广播意图的实例，我们必须在其中包含一个动作字符串。动作字符串用于标识广播意图，它是唯一的。这个动作字符串通常使用Java包名格式。
- en: 'In the following code snippet, we will create an instance of the broadcast
    intent and broadcast it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将创建一个广播意图的实例并将其广播出去：
- en: '![The broadcast intents](img/9639_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![广播意图](img/9639_08_01.jpg)'
- en: You can see in the preceding code that there is no special class named `BroadcastIntent`.
    It is an ordinary `Intent` object. We have used these `Intent` objects in methods
    such as `startActivity()` or `startService()`. This time we have passed these
    `Intent` objects in the `sendBroadcast()` method of the `Activity` class. We have
    set its action string by calling the `setAction()` method. As discussed earlier,
    we have used the package-name format in the `setAction()` method. To broadcast
    any intent, we have used the `sendBroadcast()` method. This method broadcasts
    any given intent. Remember that this method call is asynchronous and will return
    immediately. You can't get any results from any receiver and receivers also can't
    abort any broadcast intent. The interested receivers match the action string of
    intent with their action string, and if matched, those receivers are executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中可以看到，并没有一个名为`BroadcastIntent`的特殊类。它只是一个普通的`Intent`对象。我们曾在`startActivity()`或`startService()`等方法中使用过这些`Intent`对象。这次我们将这些`Intent`对象传递给了`Activity`类的`sendBroadcast()`方法。我们通过调用`setAction()`方法来设置其动作字符串。如前所述，在`setAction()`方法中我们使用了包名格式。为了广播任何意图，我们使用了`sendBroadcast()`方法。这个方法可以广播任何给定的意图。记住，这个方法调用是异步的，会立即返回。你不能从任何接收器中得到任何结果，接收器也不能中止任何广播意图。感兴趣的接收器会将意图的动作字符串与它们自己的动作字符串匹配，如果匹配，这些接收器将被执行。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From now on, we will use the keywords **broadcast** or **broadcasts** instead
    of **broadcast intent** in the whole chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在本章中我们将使用关键词**广播**或**广播们**，而不是**广播意图**。
- en: Built-in broadcasts in Android systems
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android系统内置的广播
- en: The Android OS contains different types of broadcasts. The Android OS keeps
    broadcasting these intents to notify other applications about the various changes
    in the system. For example, when a device's battery gets low, the Android OS broadcasts
    an intent containing low-battery information; applications and services that are
    interested in this information receive it and perform actions accordingly. These
    broadcasts are predefined in the Android OS and we can listen for those intents
    in our application to make our apps more interactive and responsive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Android OS包含不同类型的广播。Android OS不断广播这些意图，以通知其他应用程序系统中的各种变化。例如，当设备电量低时，Android
    OS会广播包含低电量信息的意图；对这一信息感兴趣的应用程序和服务在接收到后会执行相应的操作。这些广播在Android OS中是预定义的，我们可以在应用程序中监听这些意图，使我们的应用更具交互性和响应性。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the list of all possible broadcasts in a text file named `broadcast_actions.txt`.
    This file is stored in the `SDK` folder under the `Android` folder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为`broadcast_actions.txt`的文本文件中找到所有可能的广播列表。该文件存储在`Android`文件夹下的`SDK`文件夹中。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following table shows a list of some of the Android OS broadcasts with
    the description of their actions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了一些Android OS广播及其行为描述的列表：
- en: '| Broadcast intent action | Description |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 广播意图动作 | 描述 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `android.intent.action.ACTION_POWER_CONNECTED` | This intent is broadcasted
    when a mobile phone is connected to a power source. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.ACTION_POWER_CONNECTED` | 当手机连接到电源时，会广播此意图。 |'
- en: '| `android.intent.action.ACTION_POWER_DISCONNECTED` | This intent is broadcasted
    when a mobile phone is disconnected from any power source. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.ACTION_POWER_DISCONNECTED` | 当手机从任何电源断开时，会广播此意图。 |'
- en: '| `android.intent.action.BATTERY_LOW` | This intent is broadcasted when a mobile
    phone''s battery gets low. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.BATTERY_LOW` | 当手机电量低时，会广播此意图。 |'
- en: '| `android.intent.action.BOOT_COMPLETED` | This intent is broadcasted when
    a mobile phone''s booting completes. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.BOOT_COMPLETED` | 当手机启动完成时，会广播此意图。 |'
- en: '| `android.intent.action.DEVICE_STORAGE_LOW` | This intent is broadcasted when
    a mobile phone''s device storage gets low. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.DEVICE_STORAGE_LOW` | 当手机设备存储空间不足时，会广播此意图。 |'
- en: '| `android.intent.action.NEW_OUTGOING_CALL` | This intent is broadcasted when
    a new outgoing call starts. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.NEW_OUTGOING_CALL` | 当新的外拨电话开始时，会广播此意图。 |'
- en: '| `android.intent.action.SCREEN_OFF` | This intent is broadcasted when a mobile''s
    screen is turned on. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.SCREEN_OFF` | 当手机屏幕关闭时，会广播此意图。 |'
- en: '| `android.intent.action.SCREEN_ON` | This intent is broadcasted when a mobile''s
    screen is turned off. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `android.intent.action.SCREEN_ON` | 当手机屏幕打开时，会广播此意图。 |'
- en: '| `android.net.wifi.WIFI_STATE_CHANGED` | This intent is broadcasted when the
    WIFI state of a mobile phone is changed. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `android.net.wifi.WIFI_STATE_CHANGED` | 当手机的WIFI状态改变时，会广播此意图。 |'
- en: '| `android.media.VIBRATE_SETTING_CHANGED` | This intent is broadcasted when
    the vibrate settings of a mobile phone are changed. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `android.media.VIBRATE_SETTING_CHANGED` | 当手机的振动设置改变时，会广播此意图。 |'
- en: '| `android.provider.Telephony.SMS_RECEIVED` | This intent is broadcasted when
    a mobile phone receives an SMS. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `android.provider.Telephony.SMS_RECEIVED` | 当手机收到短信时，会广播此意图。 |'
- en: As we can see in the preceding table, the Android OS keeps informing different
    applications about various changes in the device's state by sending broadcasts.
    We can listen for these changes or broadcasts and can perform our custom actions
    to make our apps responsive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们前面的表格中所看到的，Android OS通过发送广播，不断通知不同的应用程序关于设备状态的多种变化。我们可以监听这些变化或广播，并执行自定义操作，使我们的应用更具响应性。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might have observed that some of the preceding intents, such as `android.provider.Telephony.SMS_RECEIVED`,
    are not included in the list in the `SDK` folder. Such intents are not supported
    in Android and are subject to change in any other future platform releases. Developers
    should be cautious when using these unsupported, hidden features in their apps.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，一些前面的意图，如`android.provider.Telephony.SMS_RECEIVED`，并不包含在`SDK`文件夹中的列表中。这些意图在Android中不受支持，并可能在任何未来的平台版本中有所变动。开发者在他们的应用中使用这些不受支持的隐藏功能时应谨慎。
- en: Until now, we have only talked about broadcasts but we haven't still used them
    in practical examples. In the next section, we will develop some examples, in
    which we will listen for some Android OS's predefined broadcasts and perform actions
    accordingly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了广播，但还没有在实际例子中使用它们。在下一节中，我们将开发一些示例，在这些示例中，我们将监听一些Android操作系统的预定义广播，并根据情况进行操作。
- en: Detecting the low-battery state of a device
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测设备的低电量状态
- en: In this section, we will implement a small application which will show an alert
    message when the phone's battery gets low. Now, let's get started with the development
    of our first example. But, in order to start this example, you need to build an
    Android project. You can use the Android Studio or Eclipse IDE (as per your convenience),
    but make sure that in the case of Eclipse, you have correctly installed JDK, ADT,
    and Android SDK along with their compatibility. If you don't know the difference
    between these IDEs, you can refer to [Chapter 1](ch01.html "Chapter 1. Understanding
    Android"), *Understanding Android*, of this book. Following those steps will help
    you to create a complete Android project with some predefined files and folders.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个当手机电量低时会显示警报消息的小应用程序。现在，让我们开始第一个示例的开发。但是，为了开始这个示例，你需要构建一个Android项目。你可以使用Android
    Studio或Eclipse IDE（根据你的方便），但如果是Eclipse，请确保你已经正确安装了JDK、ADT和Android SDK及其兼容性。如果你不知道这些IDE之间的区别，可以参考本书的[第1章](ch01.html
    "第1章. 理解Android")《理解Android》。按照这些步骤将帮助你创建一个带有一些预定义文件和文件夹的完整Android项目。
- en: 'After creating an empty Android project, we have to modify two files: one main
    activity file and a manifest file. Also, we have added a receiver file as well.
    Let''s look at these files in details now.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的Android项目后，我们需要修改两个文件：一个主活动文件和一个清单文件。同时我们也添加了一个接收器文件。现在，让我们详细看看这些文件。
- en: The BatteryLowReceiver.java file
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BatteryLowReceiver.java文件
- en: 'As we are developing a Battery Low alert app, the first thing we have to do
    is to detect the low battery. For that purpose, we would have to create a `BroadcastLowReceiver`
    class, which will listen to the Battery Low broadcast. The following code shows
    the implementation of the receiver file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发一个低电量警报应用，我们首先要做的是检测低电量。为此，我们需要创建一个`BroadcastLowReceiver`类，它将监听低电量广播。以下代码显示了接收器文件的实现：
- en: '![The BatteryLowReceiver.java file](img/9639_08_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![BatteryLowReceiver.java文件](img/9639_08_02.jpg)'
- en: As seen in the preceding code, we have extended our class from the `BroadcastReceiver`
    class and have overridden the `onReceive()` method. This method will be called
    when any broadcast is received. The first thing we have to do is to check whether
    this intent is the Battery Low intent or some other broadcast. To do so, we check
    the action string of the intent with the standard Android action which is `Intent.ACTION_BATTERY_LOW`.
    If the result is `true`, that means the device's battery is low, and we have to
    perform our custom action.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们从`BroadcastReceiver`类扩展了我们的类，并覆盖了`onReceive()`方法。当接收到任何广播时，将调用此方法。我们首先要做的是检查这个意图是否是低电量意图或其他广播。为此，我们检查意图的动作字符串是否与标准的Android动作`Intent.ACTION_BATTERY_LOW`相匹配。如果结果为`true`，则意味着设备的电量低，我们需要执行自定义操作。
- en: Next, we create a thread in which we pass an anonymous `Runnable` object. We
    override the `run()` method, and in this method, we create an instance of `AlertDialog`
    using the `AlertDialog.Builder` interface. We set the details, such as the title
    and the message of the alert, and then we display it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个线程，在其中传递一个匿名`Runnable`对象。我们覆盖了`run()`方法，在这个方法中，我们使用`AlertDialog.Builder`接口创建一个`AlertDialog`实例。我们设置详细信息，比如警报的标题和消息，然后显示它。
- en: You might be wondering why we have created a thread to show the alert. We could
    have shown alert without doing it in any thread. Well, it must be noted that broadcast
    receivers run for a very small amount of time. It is approximately about 4 milliseconds.
    Developer should be very careful when performing operations in receivers. It is
    a good practice to perform operations such as creating alerts and starting activities
    and services in threads from broadcast receivers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇为什么我们要创建一个线程来显示警报。我们本可以在不使用线程的情况下显示警报。需要注意的是，广播接收器运行的时间非常短，大约只有4毫秒。开发者在在接收器中执行操作时应该非常小心。从广播接收器中创建线程来执行创建警报、启动活动和服务的操作是一种良好的实践。
- en: Now, our `BatteryLowReceiver` class is ready. But, how is this receiver triggered
    and how can this class receive the Battery Low broadcasts from the Android OS?
    The answers to these questions are explained in the next section. Let's see our
    activity file now in detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `BatteryLowReceiver` 类已经准备好了。但是，这个接收器是如何被触发的，这个类如何从 Android 操作系统中接收低电量广播呢？这些问题将在下一节中解释。现在让我们详细看看我们的活动文件。
- en: The BatteryLowActivity.java class
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BatteryLowActivity.java 类
- en: 'This class represents our main activity of the application which means that
    whenever an application is launched, this activity will be started first. The
    following code shows the implementation of our activity file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表了应用程序的主要活动，这意味着每当应用程序启动时，这个活动将首先被启动。以下代码展示了我们活动文件的实现：
- en: '![The BatteryLowActivity.java class](img/9639_08_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![BatteryLowActivity.java 类](img/9639_08_03.jpg)'
- en: As always, we extended our class from the `Activity` class. Then, we have overridden
    the `onCreate()` method of our activity. We created an instance of `IntentFilter`
    and passed the `Intent.ACTION_BATTERY_LOW` action string in its constructor. You
    can read more about intent filters in [Chapter 7](ch07.html "Chapter 7. Intent
    Filters"), *Intent Filters*. After that, we created an instance of our `BatteryLowReceiver`
    class. Finally, we call our `registerReceiver()` method and pass our receiver
    and filter objects in it. This method tells the Android OS that our application
    is interested in the Battery Low broadcast. This is how we can listen to the Battery
    Low broadcast. One thing to be noted here is that when you call the `registerReceiver()`
    method, it is the developer's responsibility to call the `unregisterReceiver()`
    method too, when an application is not interested in listening to the Battery
    Low broadcast. If the developer doesn't unregister it, this application, no matter
    whether it is opened or closed, will listen for the Battery Low broadcast and
    take an action accordingly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们从 `Activity` 类扩展了我们的类。然后，我们覆盖了活动的 `onCreate()` 方法。我们创建了一个 `IntentFilter`
    实例，并在其构造函数中传递了 `Intent.ACTION_BATTERY_LOW` 动作字符串。你可以在[第7章](ch07.html "第7章. 意图过滤器")，*意图过滤器*中了解更多关于意图过滤器的信息。之后，我们创建了
    `BatteryLowReceiver` 类的一个实例。最后，我们调用 `registerReceiver()` 方法，并在其中传递我们的接收器和过滤器对象。这个方法告诉
    Android 操作系统，我们的应用程序对低电量广播感兴趣。这样我们就可以监听低电量广播。这里需要注意的是，当调用 `registerReceiver()`
    方法时，开发人员有责任在应用程序不再对低电量广播感兴趣时调用 `unregisterReceiver()` 方法。如果开发人员没有注销它，无论应用程序是打开还是关闭，它都会监听低电量广播并相应地采取行动。
- en: 'This can be bad for the memory and the optimization of our application. We
    can call the `unregisterReceiver()` method in the `onDestroy()`, `onPause()`,
    or `onStop()` callbacks of our `Activity` class, as in the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这对内存和应用程序的优化可能是有害的。我们可以在 `Activity` 类的 `onDestroy()`、`onPause()` 或 `onStop()`
    回调中调用 `unregisterReceiver()` 方法，如下面的代码片段所示：
- en: '![The BatteryLowActivity.java class](img/9639_08_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![BatteryLowActivity.java 类](img/9639_08_04.jpg)'
- en: The AndroidManifest.xml file
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AndroidManifest.xml 文件
- en: 'Developers can also register a receiver in the `AndroidManifest.xml` file as
    well. The advantage of registering receivers in the manifest file is that developers
    don''t have to unregister them manually by calling the `unregisterReceiver()`
    method. The Android OS takes care of these receivers on its own, and the developer
    doesn''t have to worry about it anymore. The following is the code implementation
    of our `AndroidManifest.xml` file which registers our Battery Low receiver in
    it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员也可以在 `AndroidManifest.xml` 文件中注册接收器。在清单文件中注册接收器的优点是，开发人员无需通过调用 `unregisterReceiver()`
    方法手动注销它们。Android 操作系统会自行处理这些接收器，开发人员无需再为此担心。下面是我们 `AndroidManifest.xml` 文件的代码实现，其中注册了我们的低电量接收器：
- en: '![The AndroidManifest.xml file](img/9639_08_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml 文件](img/9639_08_05.jpg)'
- en: You can see in the preceding code that we have used the `<receiver>` tag in
    our `<application>` tag to register our broadcast receiver. We have inserted the
    whole package name of `BatteryLowReceiver`, as the name of receiver in the `android:name`
    attribute of the `<receiver>` tag. As we set the intent-filter action in our activity
    file by creating an instance of the `IntentFilter` class, we are embedding the
    `<intent-filter>` tag with the action name set to `android.intent.action.BATTERY_LOW`.
    This intent filter will tell the Android OS that the receiver is interested in
    the low-battery state information of the device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到我们在`<application>`标签内使用了`<receiver>`标签来注册我们的广播接收器。我们在`<receiver>`标签的`android:name`属性中插入了`BatteryLowReceiver`的完整包名，作为接收器的名称。正如我们在活动文件中通过创建`IntentFilter`类实例来设置意图过滤器动作一样，我们在`<intent-filter>`标签内嵌入了动作名为`android.intent.action.BATTERY_LOW`的意图过滤器。这个意图过滤器将告诉Android操作系统，接收器对设备的低电量状态信息感兴趣。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It must be noted that developers should register receivers by only one method;
    either from their activities by calling the `registerReceiver()` method or from
    their `AndroidManifest.xml` files. It is a good practice to use the `AndroidManifest.xml`
    file to register `BroadcastReceiver` of the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应注意，注册接收器应该只采用一种方法；要么从活动中调用`registerReceiver()`方法，要么从他们的`AndroidManifest.xml`文件中注册。使用`AndroidManifest.xml`文件来注册应用程序的`BroadcastReceiver`是一个好习惯。
- en: 'When we run our application, we will see a blank screen because we haven''t
    set any layout for our activity. But when mobile phone gets low on battery, an
    alert box will be shown in our phone. The following screenshot shows an alert
    box from our `BatteryLowReceiver` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们会看到一个空白屏幕，因为我们没有为活动设置任何布局。但是当手机电量低时，手机上会显示一个警告框。以下截图展示了来自我们`BatteryLowReceiver`类的警告框：
- en: '![The AndroidManifest.xml file](img/9639_08_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_08_06.jpg)'
- en: Detecting the screen on/off state of a phone
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测手机的屏幕开启/关闭状态
- en: 'Almost in all Android phones, we have seen a very interesting feature while
    attending a phone call; we can see that the screen goes on or off. In addition
    to this, you might have observed that when you bring your phone near your ear,
    the screen turns off, and when you take it away from your ear and hold it in your
    hand, the screen automatically turns on. This is an interesting behavior of smartphones.
    Let''s say that we want to develop an application in which whenever the screen
    turns on, we want to turn on the speaker mode so that other people with us can
    hear and participate in the phone conversation. And when we put it on our ear
    again and the screen turns off, we want to turn speaker mode off. The following
    figure shows the concept of this application:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在所有的Android手机中，我们在接听电话时都注意到了一个非常有趣的功能；我们可以看到屏幕会开启或关闭。此外，您可能已经观察到，当您将手机靠近耳朵时，屏幕会关闭，而当你从耳朵旁移开并手持手机时，屏幕会自动开启。这是智能手机的有趣行为。假设我们想要开发一个应用程序，每当屏幕开启时，我们都想开启扬声器模式，以便与我们在一起的其他人可以听到并参与电话对话。而当我们再次将其放在耳朵上，屏幕关闭时，我们想要关闭扬声器模式。下图展示了这个应用程序的概念：
- en: '![Detecting the screen on/off state of a phone](img/9639_08_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![检测手机的屏幕开启/关闭状态](img/9639_08_07.jpg)'
- en: Now, let's develop such an application in the following example. Let's start
    from creating an Android project in your favorite IDE. Then, we will have to first
    detect whether the screen has been turned on or off. To detect this, we will implement
    our custom `BroadcastReceiver` class. Let's implement our broadcast receiver class
    in next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下示例中开发这样的应用程序。首先从您喜欢的IDE中创建一个Android项目。然后，我们首先需要检测屏幕是否已开启或关闭。为了检测这一点，我们将实现我们自定义的`BroadcastReceiver`类。让我们在下一节中实现我们的广播接收器类。
- en: The ScreenOnOffReceiver.java file
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ScreenOnOffReceiver.java`文件'
- en: 'The ScreenOnOffReceiver.java file represents our custom broadcast receiver
    for detecting the screen on/off state of the phone. The following code implementation
    shows our screen on/off detecting receiver:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScreenOnOffReceiver.java`文件表示我们用于检测手机屏幕开启/关闭状态的定制广播接收器。以下代码实现展示了我们的屏幕开启/关闭检测接收器：'
- en: '![The ScreenOnOffReceiver.java file](img/9639_08_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![ScreenOnOffReceiver.java文件](img/9639_08_08.jpg)'
- en: 'As in the previous example, we are extending our `ScreenOnOffReceiver` class
    from the `BroadcastReceiver` class and overriding the `onReceive()` method. This
    method will be called when any broadcast intent is received by our application.
    Our application first checks whether it is screen on/off intent or not by comparing
    the intent action with the `Intent.ACTION_SCREEN_ON` or `Intent.ACTION_SCREEN_OFF`
    constants. Remember, in the previous example we were listening for only a single
    broadcast intent. However in this example, we are listening for two broadcast
    intents: one for screen on and other for screen off.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们的`ScreenOnOffReceiver`类从`BroadcastReceiver`类扩展而来，并覆盖了`onReceive()`方法。当我们的应用程序接收到任何广播意图时，将调用此方法。我们的应用程序首先通过将意图动作与`Intent.ACTION_SCREEN_ON`或`Intent.ACTION_SCREEN_OFF`常量进行比较，来检查它是否是屏幕开启/关闭的意图。记住，在之前的示例中，我们只监听一个广播意图。然而在本例中，我们监听两个广播意图：一个用于屏幕开启，另一个用于屏幕关闭。
- en: In Android phones, the screen turns on/off not only during calls. It also becomes
    on/off when the phone is locked/unlocked. So before setting our speaker on/off,
    we have to check whether we are currently in a call or not. We can detect it by
    checking the mode of `AudioManager`. If the mode is `AudioManager.MODE_IN_CALL`,
    that means we are currently in any incoming or outgoing call conversation. Once
    we are confirmed about the call mode status, then we can set the speaker on/off.
    We are using the `AudioManager.setSpeakerphoneOn(boolean)` method for this purpose.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android手机中，屏幕不仅在通话期间会开启/关闭。当手机锁定/解锁时，屏幕也会开启/关闭。因此，在设置我们的扬声器开启/关闭之前，我们必须检查当前是否正在通话。我们可以通过检查`AudioManager`的模式来检测它。如果模式是`AudioManager.MODE_IN_CALL`，那就意味着我们当前正处于来电或去电的通话中。一旦我们确认了通话模式状态，那么我们就可以设置扬声器的开启/关闭。我们使用`AudioManager.setSpeakerphoneOn(boolean)`方法来实现这一目的。
- en: 'Until now, we have implemented our receivers. But we haven''t registered these
    receivers. Remember from our previous example, we used two approaches to register
    our custom broadcast receivers: one from the activity class by using the `registerReceiver()`
    method and the other from the `AndroidManifest.xml` file. Let''s choose the latter
    approach of the `AndroidManifest.xml` file to register our receivers.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了我们的接收器。但我们还没有注册这些接收器。记得在前一个示例中，我们使用了两种方法来注册我们的自定义广播接收器：一种是从活动类中使用`registerReceiver()`方法，另一种是从`AndroidManifest.xml`文件中。让我们选择后者，即使用`AndroidManifest.xml`文件来注册我们的接收器。
- en: The AndroidManifest.xml file
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: 'As in the previous example, we will register our `ScreenOnOffReceiver` broadcast
    receiver in this manifest file. It should be noted that in the previous example
    of the Battery Low application, we registered our receiver for only one filter,
    which was the low-battery state of the phone. However, in this example, we are
    listening for two state filters: screen on and screen off. But, we have implemented
    only one broadcast receiver. So, let''s see how we can register one receiver with
    two intent filters in the following code implementation of the `AndroidManifest.xml`
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，我们将在该清单文件中注册我们的`ScreenOnOffReceiver`广播接收器。需要注意的是，在之前电池电量低的应用示例中，我们只为一个过滤器注册了接收器，即手机的低电量状态。然而，在本例中，我们监听两个状态过滤器：屏幕开启和屏幕关闭。但我们只实现了一个广播接收器。下面让我们看看如何在以下`AndroidManifest.xml`文件的代码实现中，用两个意图过滤器注册一个接收器：
- en: '![The AndroidManifest.xml file](img/9639_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_08_09.jpg)'
- en: 'You can see in the preceding code that we have put the `<receiver>` tag in
    our `<application>` tag to register our receiver. Also, it should be noted that
    this time we have used the `<intent-filter>` tag twice with two different actions
    embedded in it: one for `android.intent.action.SCREEN_ON` and the other for `android.intent.action.SCREEN_OFF`.
    You can read more about multiple intent filters in [Chapter 7](ch07.html "Chapter 7. Intent
    Filters"), *Intent Filters*. These two intent filters along with the receiver
    embedded in our `AndroidManifest.xml` file registers our `ScreenOnOffReceiver`
    broadcast receiver with the Android OS to listen to the screen-on and screen-off
    state changes of the mobile phone.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到，我们在`<application>`标签内放置了`<receiver>`标签，以注册我们的接收器。同时，需要注意的是，这次我们两次使用了`<intent-filter>`标签，其中嵌入了两种不同的动作：一个是`android.intent.action.SCREEN_ON`，另一个是`android.intent.action.SCREEN_OFF`。你可以在[第7章](ch07.html
    "第7章.意图过滤器")《意图过滤器》中了解更多关于多个意图过滤器的内容。这两个意图过滤器连同我们在`AndroidManifest.xml`文件中嵌入的接收器一起，将我们的`ScreenOnOffReceiver`广播接收器注册到Android操作系统中，监听手机屏幕开启和关闭状态的变化。
- en: Detecting the cell phone's reboot-completed state
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测手机的重启完成状态
- en: Many android applications run services in the background when running multiple
    tasks and operations. For example, a weather application keeps checking the weather
    after a fixed time interval by using a background service. But have you ever wondered
    that when you reboot your cell phone or your battery dies and your phone is rebooted,
    then how these services start running again after reboot? Well, we will see how
    this can be done in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安卓应用程序在执行多项任务和操作时会在后台运行服务。例如，一个天气应用会通过后台服务在固定时间间隔后持续检查天气情况。但你有没有想过，当你重启手机或电池耗尽导致手机重启后，这些服务是如何在重启后再次开始运行的？在本节中，我们将了解如何实现这一点。
- en: When an Android phone is rebooted successfully, the Android OS broadcasts an
    intent notifying other applications that the reboot is completed. Then those applications
    start their background services again. In this section, we will create an application
    that will listen to the reboot-completed broadcast, and we will start our test
    service from it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当一部安卓手机成功重启后，安卓操作系统会广播一个意图，通知其他应用程序重启已完成。然后这些应用程序会再次启动它们的后台服务。在本节中，我们将创建一个监听重启完成广播的应用程序，并从中启动我们的测试服务。
- en: Let's create an empty Android project in any IDE such as Eclipse or Android
    Studio. As always, we will first implement our broadcast receiver class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在任何IDE（如Eclipse或Android Studio）中创建一个空的安卓项目。像往常一样，我们首先实现我们的广播接收器类。
- en: The PhoneRebootCompletedReceiver.java file
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhoneRebootCompletedReceiver.java文件
- en: 'The PhoneRebootCompletedReceiver.java class represents our reboot-completed
    broadcast receiver file. The following code shows the implementation of the file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneRebootCompletedReceiver.java类表示我们的重启完成广播接收器文件。以下代码展示了该文件的实现：
- en: '![The PhoneRebootCompletedReceiver.java file](img/9639_08_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![PhoneRebootCompletedReceiver.java文件](img/9639_08_10.jpg)'
- en: You can see in the preceding code that we haven't done anything new. We have
    extended our class from the `BroadcastReceiver` class. Then, we check for the
    `Intent.ACTION_BOOT_COMPLETED` action of the intent. If it is `true`, we start
    our temporary service by calling the `Context.startService()` method. Now, let's
    see what the `TempService` class does, in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到，我们没有做任何新的操作。我们的类是从`BroadcastReceiver`类扩展而来的。然后，我们检查意图的`Intent.ACTION_BOOT_COMPLETED`动作是否为真。如果是，我们通过调用`Context.startService()`方法来启动我们的临时服务。现在，让我们在下一节中看看`TempService`类的作用。
- en: The TempService.java file
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TempService.java文件
- en: The TempService.java class represents our service which will start when the
    Android system booting is completed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TempService.java类表示我们将在安卓系统启动完成后开始运行的服务。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Android 3.0, the user needs to have started the application at least once
    before the application can receive the `android.intent.action.BOOT_COMPLETED`
    broadcast.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 3.0中，用户至少需要启动一次应用程序，之后应用程序才能接收到`android.intent.action.BOOT_COMPLETED`的广播。
- en: 'The following code shows the implementation of our `TempService` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们`TempService`类的实现：
- en: '![The TempService.java file](img/9639_08_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![TempService.java文件](img/9639_08_11.jpg)'
- en: 'Like any usual service class, we have extended our class from `Service`. We
    have overridden two methods: `onBind()` and `onStartCommand()`. In the `onStartCommand()`
    method, we will display a toast by calling the `Toast.makeText()` method with
    the "**Service started**" text. When our phone''s booting is complete, this toast
    will be displayed. We can implement our custom operations here in this method.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何常规服务类一样，我们的类是从`Service`扩展而来的。我们重写了两个方法：`onBind()`和`onStartCommand()`。在`onStartCommand()`方法中，我们将通过调用`Toast.makeText()`方法并传入"**Service
    started**"文本来显示一个提示框。当我们的手机启动完成后，将显示这个提示框。我们可以在该方法中实现我们自己的自定义操作。
- en: Now, all that we are left with is to inform the Android OS that our application
    is interested in listening out for the Boot Completed broadcast. As in the previous
    applications, we will register our receiver in the `AndroidManifest.xml` file.
    Let's see this in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要通知安卓操作系统，我们的应用程序想要监听Boot Completed广播。与之前的程序一样，我们将在`AndroidManifest.xml`文件中注册我们的接收器。下一节我们将看到这一点。
- en: The AndroidManifest.xml file
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: 'The AndroidManifest.xml file informs the Android OS that our application is
    interested in listening for the Boot Completed broadcast. The following code shows
    the implementation of the manifest file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件通知安卓操作系统我们的应用程序想要监听Boot Completed广播。以下代码展示了该清单文件的实现：
- en: '![The AndroidManifest.xml file](img/9639_08_12.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml 文件](img/9639_08_12.jpg)'
- en: Almost everything is the same as in the previous example applications. We have
    registered our receiver using the `<receiver>` tag nested in the `<application>`
    tag with the intent filter of the `android.intent.action.BOOT_COMPLETED` action.
    We have also registered `TempService` by using the `<service>` tag nested within
    the `<application>` tag. It must be noted that the Boot Completed broadcast requires
    users to grant the `android.permission.RECEIVE_BOOT_COMPLETED` permission. We
    can ask the user to grant this permission by adding the `<uses-permission>` tag
    with the `android:name` attribute set to `android.permission.RECEIVE_BOOT_COMPLETED`.
    This is how we can start our custom services when a phone is rebooted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例应用几乎相同。我们使用 `<application>` 标签内的 `<receiver>` 标签注册了我们的接收器，并带有 `android.intent.action.BOOT_COMPLETED`
    动作的意图过滤器。我们还通过使用 `<application>` 标签内的 `<service>` 标签注册了 `TempService`。必须注意，Boot
    Completed 广播需要用户授予 `android.permission.RECEIVE_BOOT_COMPLETED` 权限。我们可以通过添加 `android:name`
    属性设置为 `android.permission.RECEIVE_BOOT_COMPLETED` 的 `<uses-permission>` 标签，请求用户授予此权限。这样，当手机重启时，我们就可以启动自定义服务了。
- en: Sending and receiving custom broadcasts
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收自定义广播
- en: Until now, we have been only receiving broadcasts. And all those intents we
    have experimented with are the Android System broadcasts. In this section, we
    will talk about custom broadcasts. We will see how we can send our own custom
    broadcasts to other applications and how other applications can listen for our
    custom broadcast intents.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只接收广播。我们实验过的所有意图都是 Android 系统广播。在本节中，我们将讨论自定义广播。我们将了解如何向其他应用程序发送我们自己的自定义广播，以及其他应用程序如何监听我们的自定义广播意图。
- en: In the next section, we will create an example that will send custom broadcasts
    to other applications. Let's create the activity and layout file for the application
    now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个示例，该示例将向其他应用程序发送自定义广播。现在让我们为应用程序创建活动和布局文件。
- en: The activity_main.xml layout file
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: activity_main.xml 布局文件
- en: 'The activity_main.xml file represents the layout file of our activity. The
    following code shows the implementation of the manifest file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: activity_main.xml 文件表示我们活动的布局文件。以下代码展示了清单文件的实现：
- en: '![The activity_main.xml layout file](img/9639_08_13.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![activity_main.xml 布局文件](img/9639_08_13.jpg)'
- en: As you can see in the layout file, we have placed a button with the ID, `btnSendBroadcastIntent`.
    We will use this button in our activity file to send the broadcast to other applications.
    Let's see the activity file now.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在布局文件中所见，我们放置了一个带有 ID `btnSendBroadcastIntent` 的按钮。我们将在活动文件中使用此按钮向其他应用程序发送广播。现在让我们看看活动文件。
- en: The MainActivity.java file
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MainActivity.java 文件
- en: 'The `MainActivity.java` file is the main launcher point of our application.
    This activity will use the `activity_main.xml` layout file as its visual part.
    The following code shows the implementation of the file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity.java` 文件是我们应用程序的主要启动点。此活动将使用 `activity_main.xml` 布局文件作为其视觉部分。以下代码展示了文件的实现：'
- en: '![The MainActivity.java file](img/9639_08_14.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![MainActivity.java 文件](img/9639_08_14.jpg)'
- en: You can see in the preceding code that we have obtained the `Button` object
    from our layout file by calling the `findViewById()` method. Then we set its `OnClickListener()`
    method, and in the overridden `onClick()` method, we perform our main operation
    of sending broadcasts to other applications. We create an `Intent` object and
    set its action string by calling the `Intent.setAction()` method. It should be
    noted that we have defined our own custom action value this time as the `com.packt.CustomBroadcast`
    string. We should follow the package-naming convention when we create our own
    custom broadcast receivers. Finally, we use that intent for broadcasting by calling
    the `sendBroadcast()` method of the `Activity` class. This is how our custom broadcast
    intent is sent to the Android OS and other applications. Now, all of the applications
    and receivers that are listening for this type of broadcast will receive it, and
    hence, can perform their custom operations. In the next section, we will implement
    our custom broadcast receiver class which will receive this type of intent and
    display a toast to notify the user.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从前面的代码中看到，我们通过调用`findViewById()`方法从我们的布局文件中获取了`Button`对象。然后我们设置了它的`OnClickListener()`方法，并在重写的`onClick()`方法中执行了我们的主要操作，即向其他应用程序发送广播。我们创建了一个`Intent`对象，并通过调用`Intent.setAction()`方法设置其动作字符串。需要注意的是，这次我们定义了自己的自定义动作值，即`com.packt.CustomBroadcast`字符串。创建自己的自定义广播接收器时，我们应该遵循包命名约定。最后，我们使用该意图进行广播，通过调用`Activity`类的`sendBroadcast()`方法。这就是我们的自定义广播意图发送到Android操作系统和其他应用程序的方式。现在，所有监听这种类型广播的应用程序和接收器都将接收到它，因此可以执行它们的自定义操作。在下一节中，我们将实现我们的自定义广播接收器类，它将接收这种类型的意图，并通过显示提示来通知用户。
- en: The CustomReceiver.java file
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CustomReceiver.java文件
- en: 'The CustomReceiver.java file represents our custom broadcast-receiver class,
    which will receive our custom broadcast. This class can be in this application
    or any other application which is interested in listening for this custom type
    of broadcast. Like all of the previous examples, this class will be the same and
    extended from the `BroadcastReceiver` class. The only difference between the previous
    examples and this example is that we were using the Android OS''s standard predefined
    constant action strings to detect the System broadcasts, but in this example,
    we are listening for our own custom broadcasts with custom action strings set.
    The following code shows the implementation of the file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: CustomReceiver.java文件代表我们的自定义广播接收器类，它将接收我们的自定义广播。这个类可以在这个应用程序中，也可以在任何其他想要监听这种自定义类型广播的应用程序中。与之前的所有示例一样，这个类将相同，并且从`BroadcastReceiver`类扩展而来。与之前示例的唯一区别在于，我们之前使用的是Android操作系统的标准预定义常量动作字符串来检测系统广播，但在这个示例中，我们正在监听具有自定义动作字符串设置的自定义广播。以下是文件实现的代码：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see in the preceding code that we haven't done anything new which you
    aren't already familiar with. We have derived our class from `BroadcastReceiver`
    and overridden the `onReceive()` method. We then compared the action string of
    the intent with our own custom string of the `com.packt.CustomBroadcast` action.
    If it is `true`, we will display a toast saying `Broadcast Intent Detected`. We
    can perform our custom operations here in this method. Finally, we have to register
    this receiver so that the Android OS can notify our application about the broadcast.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，我们并没有做任何你还不熟悉的新操作。我们的类是从`BroadcastReceiver`派生出来的，并重写了`onReceive()`方法。然后我们将意图的action字符串与我们的自定义字符串`com.packt.CustomBroadcast`动作进行比较。如果为`true`，我们将显示一个提示“检测到广播意图”。我们可以在该方法中执行自定义操作。最后，我们必须注册这个接收器，以便Android操作系统可以通知我们的应用程序关于广播的信息。
- en: The AndroidManifest.xml file
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: 'As always, the AndroidManifest.xml tells the Android OS that our application
    is listening for custom broadcasts. The following code shows the implementation
    of the file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，AndroidManifest.xml告诉Android操作系统我们的应用程序正在监听自定义广播。以下是文件实现的代码：
- en: '![The AndroidManifest.xml file](img/9639_08_16.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml文件](img/9639_08_16.jpg)'
- en: 'You can see that we have registered our custom broadcast receiver in the same
    way as we have registered the receivers for Android System broadcasts. Now, when
    we run this application, we will see a button named **Send Broadcast Intent**.
    When we tap on the button, our custom broadcast will be broadcasted in the Android
    OS. As we have also created a receiver of this custom intent, so we will also
    receive this intent. On receiving the intent, our custom receiver will display
    a toast. The following screenshot shows the execution of this application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们以与注册Android系统广播接收器相同的方式注册了我们的自定义广播接收器。现在，当我们运行这个应用程序时，我们会看到一个名为**发送广播意图**的按钮。当我们点击这个按钮时，我们的自定义广播将在Android操作系统中广播。由于我们也为此自定义意图创建了一个接收器，因此我们也将接收到这个意图。在接收到意图时，我们的自定义接收器将显示一个提示消息。以下屏幕截图展示了这个应用程序的执行情况：
- en: '![The AndroidManifest.xml file](img/9639_08_17.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![AndroidManifest.xml 文件](img/9639_08_17.jpg)'
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed about broadcasts. We also saw the different Android
    OS's System broadcast intents such as Battery Low, Power Connected and Boot Completed.
    Also, we saw how these broadcasts are received by registering our custom receivers
    and how we can perform our own custom operations in those receivers. Finally,
    we learned about sending our own custom broadcasts and receiving those custom
    intents as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了广播。我们还了解了Android操作系统的不同系统广播意图，例如电量低、电源连接和开机完成。我们也学习了如何通过注册自定义接收器来接收这些广播，以及如何在那些接收器中执行我们自己的自定义操作。最后，我们学习了如何发送我们自己的自定义广播以及接收这些自定义意图。
- en: 'In the next chapter, we will explore two special types of intents: `IntentService`
    and `PendingIntent.` Also, we will learn how these intents are used and what can
    be achieved by these intents.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索两种特殊的意图类型：`IntentService`和`PendingIntent`。我们还将学习如何使用这些意图以及通过这些意图可以实现什么功能。
