- en: Chapter 6. Building a Chronotherm for Home Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 为智能家居构建Chronotherm电路
- en: For many decades now it has been possible, even easy, to control home devices
    such as lights, thermostats, and appliances with automatic and remote controls.
    On the one hand, these automation devices save effort and energy, but on the other
    hand, even modest adjustments are inconvenient to final users because they need
    a good knowledge of the system to make any changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，控制家庭设备如灯光、恒温器和电器已经变得可能，甚至简单，通过自动和远程控制。一方面，这些自动化设备节省了人力和能源，但另一方面，即使是微小的调整对最终用户来说也不方便，因为他们需要对系统有很好的了解才能进行任何更改。
- en: During the last few years, people were reluctant to adopt **home automation**
    technologies because of a lack of a standard or an easy-to-customize solution.
    Nowadays, things are changing and prototyping boards such as UDOO, play a great
    role during the design and the building of **DIY** (**Do It Yourself**) automated
    devices. Best of all, thanks to open source projects, these platforms are easy
    to extend and can be controlled by different devices, such as personal computers
    with web browsers, mobile phones, and tablets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，由于缺乏标准或易于定制的解决方案，人们不愿采用**智能家居**技术。如今，情况正在发生变化，UDOO等原型开发板在设计及构建**DIY**（**自己动手做**）自动化设备时发挥着重要作用。更妙的是，由于开源项目，这些平台易于扩展，并且可以被不同的设备控制，如个人电脑上的网络浏览器、手机和平板电脑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the advantages of home automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索智能家居的优势
- en: Building a chronotherm circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个chronotherm电路
- en: Sending data and receiving commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据与接收指令
- en: Writing the Chronotherm Android application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Chronotherm安卓应用程序
- en: Home automation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能家居
- en: 'The term *home automation* is quite generic and may have a lot of different
    meanings: a timer controlling ambient lights, an intelligent system that takes
    actions in response to events coming from the outside, or a programmable device
    responsible for accomplishing repetitive tasks.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “智能家居”这个词相当通用，可能有多种不同的含义：控制环境灯光的定时器，响应来自外部的各种事件做出动作的智能系统，或者负责完成重复任务的编程设备。
- en: These are all valid examples of home automation as they share the same key concept
    making us able to manage house work and activities even when we are not at home.
    Home-automated devices usually operate on public or private networks to communicate
    with each other, as well as with other kinds of devices such as smartphones or
    tablets, taking commands or exchanging information about their status. But what
    happens when we need to automate simple appliances or electronic components such
    as light bulbs? A common solution to address this problem is by developing a sort
    of **Control System** device, physically connected to the appliances we want to
    manage; being the Control System, a home-automated device, we can use it to drive
    the behavior of every appliance it is connected to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是智能家居的有效示例，因为它们共享同一个关键概念，使我们即使不在家也能管理家务和活动。智能家居设备通常在公共或私人网络上运行，以相互通信，以及与其他类型的设备如智能手机或平板电脑进行通信，接收指令或交换它们的状态信息。但当我们需要自动化简单的电器或电子元件，如灯泡时，该怎么办？解决这个问题的常见方法是通过开发一种**控制系统**设备，物理连接到我们想要管理的电器上；由于控制系统是一种智能家居设备，我们可以使用它来驱动它所连接的每个电器的行为。
- en: If we manage to get enough experience in the home-automation field, the chances
    are that we will be able to develop and build a high-end system for our own house,
    flexible enough to be easily extended without any further knowledge.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在智能家居领域积累足够的经验，我们有可能开发并构建一个高端系统，用于我们自己的房子，这个系统足够灵活，可以轻松扩展，而不需要进一步的知识。
- en: Building a chronotherm circuit
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个chronotherm电路
- en: A chronotherm is mainly composed of a *Control Unit,* that has the responsibility
    to check whether the environment temperature is below a preconfigured setpoint,
    and in this case, turn on the boiler to warm up the room. This behavior is quite
    simple, but without any further logic isn't so useful. Indeed, we can extend this
    behavior adding the *time* parameter to the chronotherm logic. In this way, users
    can define a temperature setpoint for each hour of the day, making the temperature
    check smarter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 温控器主要由一个*控制单元*组成，负责检查环境温度是否低于预配置的设定点，如果是，则打开锅炉加热房间。这种行为很简单，但没有进一步的逻辑就不太有用。实际上，我们可以通过向温控器逻辑中添加*时间*参数来扩展此行为。这样，用户可以为每天每小时定义一个温度设定点，使温度检查更加智能。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that in this prototype the Control Unit is the onboard Arduino is an
    implementation detail to simplify the overall design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型中，控制单元是板载Arduino，这是一个简化整体设计的实现细节。
- en: 'This is how a traditional chronotherm works and to realize it, we should:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是传统温控器的工作原理，为了实现它，我们应该：
- en: Build the circuit with a temperature sensor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建带有温度传感器的电路
- en: Implement the microcontroller logic to check the users' setpoints with the current
    temperature
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现微控制器逻辑，以检查用户的设定点与当前温度
- en: 'Unfortunately, the second part is not so easy because the users'' setpoints
    should be stored in the microcontroller, and for this reason, we can delegate
    this task to our Android application saving settings in the microSD card. This
    approach decouples responsibilities in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，第二部分并不容易，因为用户的设定点应该存储在微控制器中，因此我们可以将这项任务委托给我们的安卓应用程序，通过在microSD卡中保存设置来实现。这种方法以下列方式解耦责任：
- en: 'Arduino sketch:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino草图：
- en: Collects data from a temperature sensor
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从温度传感器收集数据
- en: Sends the detected temperature to Android
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检测到的温度发送到安卓
- en: Expects an Android command to start or stop the boiler
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期待一个安卓命令来启动或停止锅炉
- en: 'Android application:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓应用程序：
- en: Manages user's interactions
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户交互
- en: Implements user's settings to store temperature setpoints for each hour of the
    day
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用户设置，以存储每天每小时的温度设定点
- en: Reads the temperature sent by the microcontroller
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取微控制器发送的温度
- en: Implements the logic to choose whether the boiler should be turned on or off
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现逻辑以选择是否应该打开或关闭锅炉
- en: Sends a command to the microcontroller to start or stop the boiler
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微控制器发送命令以启动或停止锅炉
- en: With this plan, we can rely on the Android user interface components to easily
    implement a lean and usable interface, while avoiding the complexity of the settings
    storage layer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个计划，我们可以依赖安卓用户界面组件轻松实现简洁且易用的界面，同时避免设置存储层的复杂性。
- en: 'To start building the prototype, we need to plug into our breadboard a temperature
    sensor, such as the *TMP36*, to obtain the following circuit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建原型，我们需要在我们的面包板上插入一个温度传感器，如*TMP36*，以获得以下电路：
- en: '![Building a chronotherm circuit](img/1942OS_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![构建温控器电路](img/1942OS_06_01.jpg)'
- en: 'The following is a step-wise procedure to get the components connected, as
    shown in the preceding schema:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接组件的逐步操作过程，如前图所示：
- en: Put the TMP36 sensor on the right part of the breadboard.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TMP36传感器放在面包板的右侧部分。
- en: Connect the UDOO +3.3V pin to the positive line of the power bus. Be sure not
    to connect the +5V power pin because it may damage the analog input pins during
    future connections.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOO的+3.3V引脚连接到电源总线的正极。确保不要连接+5V电源引脚，因为未来连接时可能会损坏模拟输入引脚。
- en: Connect the UDOO ground to the negative line of the power bus.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UDOO的地线连接到电源总线的负极。
- en: Connect the left terminal of the TMP36 sensor to the positive line of the power
    bus.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TMP36传感器的左端连接到电源总线的正极。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When using packaged sensors, we can deduce the orientation looking at the flat
    part. Use this approach to find the left and the right terminal.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用封装传感器时，我们可以通过观察平整的部分来判断方向。使用这种方法来找到左端和右端。
- en: Connect the right terminal of the TMP36 sensor to the negative line of the power
    bus.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TMP36传感器的右侧终端连接到电源总线的负极。
- en: Connect the middle terminal of the TMP36 sensor to the analog input A0.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TMP36传感器的中间终端连接到模拟输入A0。
- en: This packaged sensor is really simple to use and it doesn't require any other
    components or voltage dividers to provide the voltage variation to the microcontroller.
    Now we should proceed managing the boiler ignition from our circuit. For the sake
    of the prototype, we're going to replace the boiler actuator with a simple LED,
    like we did in [Chapter 2](ch02.html "Chapter 2. Know Your Tools"), *Know your
    Tools*. This will keep our circuit simpler.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个封装的传感器非常容易使用，它不需要任何其他组件或电压分压器来为微控制器提供电压变化。现在我们应该继续从我们的电路管理锅炉点火。为了原型的需要，我们将用简单的LED替换锅炉执行器，就像我们在[第2章](ch02.html
    "第2章.了解你的工具")，*了解你的工具*中所做的那样。这将使我们的电路更简单。
- en: 'We can add an LED to the breadboard to achieve the following schema:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在面包板上添加一个LED，以实现以下原理图：
- en: '![Building a chronotherm circuit](img/1942OS_06_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个计时恒温电路](img/1942OS_06_02.jpg)'
- en: 'The following is the procedure of connecting the components, as shown in the
    preceding schema:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是按照前述原理图连接组件的步骤：
- en: Put the LED on the left-hand side of the breadboard.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED放在面包板的左侧。
- en: Connect the LED longer terminal (anode) to the UDOO digital pin 12.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED较长的终端（阳极）连接到UDO数字引脚12。
- en: Connect the LED smaller terminal (cathode) to the negative line of the power
    bus, using a 220 Ohm resistor.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个220欧姆的电阻，将LED较小的终端（阴极）连接到电源总线的负线上。
- en: 'With this circuit, we have all the components required to collect data from
    the environment and to simulate a boiler ignition. Now we need to open the Arduino
    IDE and start a new sketch. The first goal is to retrieve and convert the detected
    temperature into a convenient unit of measurement. To achieve this goal, we have
    to perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个电路，我们拥有了从环境中收集数据和模拟锅炉点火所需的所有组件。现在我们需要打开Arduino IDE并开始一个新的草图。第一个目标是将检测到的温度检索并转换成方便的计量单位。为了实现这个目标，我们需要执行以下步骤：
- en: 'Define these object-like macros and variables at the top of the sketch:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的顶部定义这些类似对象宏和变量：
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We define the `SENSOR` object to represent the analog pin A0 while the `BOILER`
    object is related to our digital pin 12\. We also declare a `reading` variable
    that we use later to store the current detected temperature. The `TEMPERATURE_POLL_PERIOD`
    macro represents how many seconds the microcontroller waits between readings and
    before it notifies the Android application with the detected temperature.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了`SENSOR`对象来表示模拟引脚A0，而`BOILER`对象与我们的数字引脚12相关联。我们还声明了一个`reading`变量，稍后用来存储当前检测到的温度。`TEMPERATURE_POLL_PERIOD`宏表示微控制器在两次读数之间等待的秒数，以及它通知Android应用程序检测到的温度之前等待的秒数。
- en: 'In the `setup()` function, add the pin mode declaration and open the serial
    communication as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，添加引脚模式声明并打开串行通信，如下所示：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the bottom of the sketch, create the `convertToCelsius()`function as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在草图的底部，按照以下方式创建`convertToCelsius()`函数：
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this function, we expect a sensor reading and return its representation in
    *Celsius degrees*. To achieve this, we're using a little math to figure out what
    the real detected voltage is. Because the analog to digital converters of the
    UDOO microcontroller provide values in the range [0-1023], but we want to calculate
    the range from 0 to 3.3V, we should divide the value by 1024.0 and then multiply
    the result by 3.3.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们期望一个传感器读数，并以*摄氏度*的形式返回它的表示。为此，我们使用了一些数学计算来确定实际检测到的电压是多少。因为UDO微控制器的模数转换器提供的值范围是[0-1023]，但我们想要计算从0到3.3V的范围，所以我们应该将值除以1024.0，然后将结果乘以3.3。
- en: We use the voltage in the Celsius conversion because if we read the TMP36 datasheet,
    we find that every 10 millivolts of change from the sensor is equivalent to a
    temperature change of 1 Celsius degree and this is why we multiply the value by
    100\. We also need to subtract the voltage by 0.5 because this sensor handles
    temperatures below 0 degrees, and 0.5 is the chosen offset.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在摄氏度转换中使用电压，因为如果我们阅读TMP36的数据表，我们会发现传感器每10毫伏的变化相当于1摄氏度的温度变化，这就是我们为什么将值乘以100。我们还需要从电压中减去0.5，因为此传感器可以处理0度以下的温度，而0.5是选择的偏移量。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This function easily converts TMP36 readings into Celsius degrees. If you want
    to use another unit of measurement, such as Fahrenheit, or if you use a different
    sensor or thermistor, you have to change this implementation.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数可以将TMP36的读数轻松转换为摄氏度。如果你想使用其他计量单位，比如华氏度，或者你使用的是其他传感器或热敏电阻，那么你需要改变这个实现方式。
- en: 'In the main `loop()` function, read the analog signal from the sensor and use
    the `loop()` function to print the converted result:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`loop()`函数中，从传感器读取模拟信号并使用`loop()`函数打印转换后的结果：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we upload the sketch and open the serial monitor, we''ll notice the current
    room temperature. Indeed, if we put our finger around the sensor, we will see
    an increase in the previously detected temperature immediately. The following
    screenshot is an example of the sketch output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们上传草图并打开串行监视器，我们会注意到当前的室温。实际上，如果我们把手指放在传感器周围，我们会立即看到之前检测到的温度升高。以下屏幕截图是草图输出的一个示例：
- en: '![Building a chronotherm circuit](img/1942OS_06_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![构建恒温器电路](img/1942OS_06_03.jpg)'
- en: Sending data and receiving commands
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送数据和接收命令
- en: 'The next step is to enable the ADK communication as usual, and we need to add
    the *accessory descriptor* code at the top of the sketch as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是像往常一样启用ADK通信，并且我们需要在草图顶部添加*配件描述符*代码，如下所示：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have to send the detected float temperature back to the Android application,
    like we did in [Chapter 5](ch05.html "Chapter 5. Managing Interactions with Physical
    Components"), *Managing Interactions with Physical Components*. To load the buffer
    with a float number and send the value through the internal bus, we have to add
    a `writeToAdk()` helper function with the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将检测到的浮点温度发送回Android应用程序，就像我们在[第5章](ch05.html "第5章. 管理与物理组件的交互")，*管理与物理组件的交互*中所做的那样。为了将缓冲区加载一个浮点数并通过内部总线发送该值，我们需要添加一个`writeToAdk()`辅助函数，代码如下：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding function expects a float temperature converted from the sensor
    reading. We use the `sprintf()` function call to fill a temporary buffer and then
    use the `memcpy()` function to replace the ADK buffer content with the `tempBuffer`
    variable. When the loading is done, we send the buffer contents to the Android
    application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数期望从传感器读数转换而来的浮点温度。我们使用`sprintf()`函数调用填充一个临时缓冲区，然后使用`memcpy()`函数用`tempBuffer`变量替换ADK缓冲区内容。加载完成后，我们将缓冲区内容发送到Android应用程序。
- en: 'During the main `loop()` function, we also need to listen to any commands sent
    by Android that describe the need to turn on or off the boiler. For this reason,
    we need to create an executor function like we did in [Chapter 2](ch02.html "Chapter 2. Know
    Your Tools"), *Know your Tools*. Then, we have to read commands from the ADK and
    pass the result to the executor. To achieve this, we need to perform the following
    steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`loop()`函数中，我们还需要监听Android发送的任何命令，这些命令描述了需要打开或关闭锅炉的需求。因此，我们需要像在[第2章](ch02.html
    "第2章. 了解你的工具")，*了解你的工具*中所做的那样创建一个执行器函数。然后，我们需要从ADK读取命令并将结果传递给执行器。为此，我们需要执行以下步骤：
- en: 'Add the `executor()` function that reads a command and turns the external device
    on or off:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`executor()`函数，该函数读取一个命令并打开或关闭外部设备：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the `executeFromAdk()` function that reads a command from the ADK and passes
    that command to the preceding `executor()` function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`executeFromAdk()`函数，该函数从ADK读取命令并将其传递给前面的`executor()`函数：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we take a look at the plan defined at the beginning of the chapter, we have
    all the required components for the Arduino sketch, so we can put everything together
    in the main `loop()` function using the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看本章开始时定义的计划，我们拥有Arduino草图所需的所有组件，因此我们可以使用以下代码在主`loop()`函数中将所有内容组合在一起：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the ADK is ready, we read the sensor value and write its Celsius degrees
    conversion in the ADK buffer. We then expect a command from the ADK and, if it's
    available, we execute that command turning the boiler on or off. Now that the
    sketch is completed, we can proceed writing the Chronotherm Android application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当ADK准备就绪时，我们读取传感器值，并将其摄氏度转换写入ADK缓冲区。然后我们期望从ADK接收一个命令，如果命令可用，我们就执行该命令，打开或关闭锅炉。现在草图完成了，我们可以继续编写Chronotherm
    Android应用程序。
- en: Managing the chronotherm through Android
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Android管理恒温器
- en: When we're building physical applications through the UDOO platform, we have
    to bear in mind that we can make use of Android components and services to enhance
    the quality of our projects. Moreover, Android UI elements are more user-friendly
    and maintainable than the hardware counterpart. For this reason, we will create
    a software component to manage temperature setpoints instead of the use of potentiometers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过UDOO平台构建物理应用程序时，要牢记我们可以利用Android组件和服务来提升项目质量。此外，与硬件相比，Android的用户界面元素更加用户友好且易于维护。因此，我们将创建一个软件组件来管理温度设定点，而不是使用电位计。
- en: To begin the application prototyping, open Android Studio and start a new application
    named **Chronotherm** with Android API 19\. During the bootstrap process, choose
    a **Blank Activity** called *Overview*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始应用程序原型设计，请打开Android Studio并启动一个名为**Chronotherm**的新应用程序，使用Android API 19。在引导过程中，选择一个名为*Overview*的**空白活动**。
- en: Setting up the ADK Toolkit
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置ADK工具包
- en: 'Before we proceed with the application layout, we need to configure the ADKToolkit
    for internal communication. Remember to follow these reminders to achieve the
    correct configuration:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始应用程序布局之前，需要配置ADKToolkit以实现内部通信。请遵循以下提示以完成正确的配置：
- en: Add the *ADKToolkit* library dependency in the `app/build.gradle` file.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`文件中添加*ADKToolkit*库依赖。
- en: Sync your Gradle configuration.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步你的Gradle配置。
- en: 'Create the accessory filter file `usb_accessory_filter.xml` under `res/xml/`
    with the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml/`目录下创建配件过滤器文件`usb_accessory_filter.xml`，包含以下代码：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add the *USB accessory support* option requirement and the *USB accessory intent
    filter* option in the `AndroidManifest.xml` file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加*USB配件支持*选项要求和*USB配件意图过滤器*选项。
- en: In the `Overview.java` class file, declare the `AdkManager` object at the top
    of the class.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Overview.java`类文件中，在类的顶部声明`AdkManager`对象。
- en: Add the `AdkManager` object initialization inside the `onCreate()` method of
    the `Overview` activity class.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Overview`活动类的`onCreate()`方法中添加`AdkManager`对象初始化。
- en: Override the `onResume()` activity callback to start the ADK connection when
    the activity is opening. In this project, we don't close the ADK connection in
    the `onPause()` callback because we will use two different activities and the
    connection should remain active.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onResume()`活动回调，在活动打开时启动ADK连接。在这个项目中，我们在`onPause()`回调中不关闭ADK连接，因为我们将使用两个不同的活动，并且连接应该保持活动状态。
- en: With the ADK communication up and running, we may proceed and write the Chronotherm
    user interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在ADK通信启动并运行后，我们可以继续编写Chronotherm用户界面。
- en: Designing the Android user interface
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Android用户界面
- en: 'The next step is designing the Chronotherm application''s user interface to
    handle the proper feedback together with setpoints management. We will achieve
    these requirements writing two different Android activities with the following
    responsibilities:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设计Chronotherm应用程序的用户界面，以处理设定点管理以及适当的反馈。我们将通过编写两个不同职责的Android活动来实现这些要求：
- en: An *Overview* activity showing the current time, the detected temperature, and
    the current boiler status. It should include a widget showing the user's setpoints
    for each hour of the day. These setpoints are used to decide whether to turn the
    boiler on or off.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*Overview*活动，显示当前时间、检测到的温度和当前锅炉状态。它应该包括一个小组件，显示用户每天每个小时的设定点。这些设定点用于决定是否打开或关闭锅炉。
- en: A *Settings* activity used to change the current setpoints for each hour of
    the day. This activity should use the same widget of the `Overview` activity to
    represent the temperature setpoints.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*Settings*活动，用于更改每天每个小时的当前设定点。这个活动应该使用与`Overview`活动相同的组件来表示温度设定点。
- en: We begin the implementation starting with the `Overview` activity and the temperature
    setpoints widget.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Overview`活动以及温度设定点小组件开始实现。
- en: Writing the Overview activity
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Overview活动
- en: 'This activity should provide all details regarding the current status of the
    Chronotherm application. All the required components are summarized in the following
    mock-up that defines the order in which the components will be created:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动应提供有关Chronotherm应用程序当前状态的所有详细信息。所有必需的组件在以下模拟图中总结，该图定义了创建组件的顺序：
- en: '![Writing the Overview activity](img/1942OS_06_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![编写Overview活动](img/1942OS_06_04.jpg)'
- en: 'The first step is to update the activity layout, and following the suggestion
    in the preceding mock-up, we should go through the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新活动布局，根据前面草图的建议，我们应该执行以下步骤：
- en: At the top of the layout, we could include a `TextClock` view that shows the
    current system time.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局的顶部，我们可以包含一个显示当前系统时间的`TextClock`视图。
- en: The top bar should provide a feedback for the boiler status. We can add a gray
    `TextView` with the **Active** text that becomes green when the boiler is turned
    on.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶栏应该提供锅炉状态的反馈。我们可以添加一个灰色的`TextView`，带有**Active**文字，当锅炉开启时它会变成绿色。
- en: The `Overview` body must provide the current detected temperature. Because this
    is one of the most important details provided by the Chronotherm application,
    we will emphasize this value making it bigger than other components.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Overview`主体必须提供当前检测到的温度。因为这是Chronotherm应用程序提供的最重要的细节之一，我们将通过使其比其他组件更大来强调这个值。'
- en: Near the room temperature, we will create a widget for the current activated
    schedule through a set of vertical bars that show the user's setpoints for each
    hour of the day. In the `Overview` activity, this widget will remain in read-only
    mode only to provide a quick overview of the active program.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在室内温度附近，我们将通过一系列垂直条形图创建一个小部件，以显示用户每天每个小时的设定点，从而展示当前激活的日程。在`Overview`活动中，这个小部件将保持只读模式，仅用于快速查看激活的程序。
- en: In the activity action bar, we should provide a menu item that opens the `Settings`
    activity. This activity will be used to store setpoints within the Chronotherm
    application.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动操作栏中，我们应该提供一个菜单项，用于打开`Settings`活动。这个活动将用于在Chronotherm应用程序中存储设定点。
- en: 'We begin the `Overview` implementation starting from the top bar and the detected
    temperature components; the following steps are required to achieve the preceding
    layout:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从顶部栏和检测到的温度组件开始实现`Overview`，要实现前面的布局，需要以下步骤：
- en: 'In the `res/values/dimens.xml` file, add the following highlighted resources:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values/dimens.xml`文件中，添加以下高亮资源：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `res/values/styles.xml` file, add the following resources and change
    the `AppTheme parent` attribute as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values/styles.xml`文件中，添加以下资源，并更改`AppTheme parent`属性如下：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To emphasize the current detected temperature, we can create a circle shape
    that should surround the temperature value. To realize it, create the `circle.xml`
    file under `res/drawable/` with the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了强调当前检测到的温度，我们可以创建一个圆形形状来包围温度值。要实现这一点，请在`res/drawable/`目录下创建`circle.xml`文件，并添加以下代码：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now proceed and replace the layout in the `activity_overview.xml` file
    under `res/layout/`, with the following highlighted code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续并在`res/layout/`目录下的`activity_overview.xml`文件中替换布局，使用以下高亮代码：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Place the following code in the preceding `LinearLayout` to create the activity
    top bar, which contains the current system time and the boiler status:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的`LinearLayout`中放置以下代码，以创建包含当前系统时间和锅炉状态的活动顶栏：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to create the activity body. It should contain two different
    items: the first is a `LinearLayout`, where we will inflate the setpoints widget
    using the `LayoutInflater` class in the activity `onCreate()` callback, and the
    second is the current detected temperature surrounded by the circle shape we created
    before. In the root `LinearLayout`, nest the following elements:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建活动主体。它应该包含两个不同的项目：第一个是`LinearLayout`，我们将在活动的`onCreate()`回调中使用`LayoutInflater`类来填充设定点小部件；第二个是被我们之前创建的圆形形状包围的当前检测到的温度。在根`LinearLayout`中，嵌套以下元素：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As last steps, store all the view references in the activity code. At the top
    of the `Overview` class, add the reference for the `temperature` and `boiler_status`
    views views with the highlighted code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后几步，在活动代码中存储所有视图引用。在`Overview`类的顶部，添加`temperature`和`boiler_status`视图的引用，使用以下高亮代码：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `Overview` `onCreate()` callback, get the references with the following
    code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Overview`的`onCreate()`回调中，使用以下代码获取引用：
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These steps provide a partial layout that we will complete adding the setpoints
    widget and the settings menu item.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤提供了一个部分布局，我们将通过添加设定点小部件和设置菜单项来完成它。
- en: Creating a custom UI component
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义UI组件
- en: To keep the user interface lean, usable, and intuitive, we can use a set of
    vertical bars, such as an audio equalizer, so that users can instantly know the
    room temperature trend they want to obtain. Android ships with a built-in component
    called `SeekBar` that we can use to choose a temperature setpoint. Unfortunately,
    this component draws a horizontal bar and isn't provided with its vertical counterpart;
    for this reason, we will extend its default behavior.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持用户界面的精简、可用和直观，我们可以使用一组垂直条，例如音频均衡器，以便用户可以立即了解他们想要获得的房间温度趋势。安卓自带一个名为`SeekBar`的内置组件，我们可以使用它来选择温度设定点。不幸的是，此组件绘制了一个水平条，并且没有提供其垂直对应物；因此，我们将扩展其默认行为。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android API 11 and later adds the `rotate` attribute for each component inside
    the XML. Even if we use a rotation of 270 degrees to obtain a vertical component,
    we will have some issues to correctly place one bar next to another. In this case,
    our initial efforts to customize this component will simplify our work later.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓API 11及更高版本为XML中的每个组件添加了`rotate`属性。即使我们使用270度的旋转来获得一个垂直组件，我们也可能会遇到正确放置一个条旁边另一个条的问题。在这种情况下，我们最初对定制此组件的努力将简化我们后续的工作。
- en: Android offers sophisticated and componentized models for building custom UI
    elements and we can delve into further details at [http://developer.android.com/guide/topics/ui/custom-components.html](http://developer.android.com/guide/topics/ui/custom-components.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓为构建自定义UI元素提供了复杂和组件化的模型，我们可以在[http://developer.android.com/guide/topics/ui/custom-components.html](http://developer.android.com/guide/topics/ui/custom-components.html)深入了解更多细节。
- en: 'The `SeekBar` component''s customization could be organized as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeekBar`组件的自定义可以按以下方式进行组织：'
- en: As a first step, we should create a `TemperatureBar` class implementing the
    vertical sliding behavior. Most of the changes are related to inherit the `SeekBar`
    class while switching the component width with its height.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们应该创建一个实现垂直滑动行为的`TemperatureBar`类。大部分的更改与继承`SeekBar`类有关，同时将组件的宽度与高度进行切换。
- en: The widget needs an XML layout to be programmatically added from our code. For
    this reason, we will create a layout that includes the `TemperatureBar` view,
    the chosen degrees and the hour related to the bar.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小部件需要一个XML布局，以便从我们的代码中程序化地添加。因此，我们将创建一个包含`TemperatureBar`视图、所选度数和与条相关的小时的布局。
- en: When any changes occur to the vertical bar component, the degrees number should
    be updated. In this step, we will create a listener that propagates bar changes
    to the degrees component providing proper feedback to the users.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当垂直条组件发生任何变化时，应更新度数。在这一步中，我们将创建一个监听器，将条的变化传播到度数组件，为用户提供适当的反馈。
- en: Our customized component that includes the `TemperatureBar` class, the degrees
    and hour views, should be programmatically created for each hour of the day. We
    will create a utility class that is responsible for inflating the component layout
    24 times adding the proper listeners.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定制的包含`TemperatureBar`类、度数和小时视图的组件，应该为一天中的每个小时程序化地创建。我们将创建一个工具类，负责将组件布局膨胀24次，并添加适当的监听器。
- en: 'We begin writing the vertical `SeekBar` class that could be realized with the
    following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始编写垂直的`SeekBar`类，可以通过以下步骤实现：
- en: Create a new package in your namespace called `widget`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的命名空间中创建一个名为`widget`的新包。
- en: 'In the newly created package, add the `TemperatureBar` class that extends the
    `SeekBar` class implementation while defining the default class constructors as
    follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的包中，添加一个扩展`SeekBar`类实现的`TemperatureBar`类，同时定义默认的类构造函数，如下所示：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Continue the `TemperatureBar` class implementation, adding the draw and measure
    methods at the bottom of the class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续实现`TemperatureBar`类，并在类的底部添加绘制和测量方法：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first methods, we're switching the widget width with its height so that
    we can use this parameter to provide an accurate measurement of the component
    contents. Then we override the `onDraw()` method called by the Android system
    during component drawing, by applying a translation to the `SeekBar` canvas and
    placing it vertically. As the last step, we call the `onSizeChanged` callback
    once again to resize the component after the canvas translation.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们将小部件的宽度与高度进行切换，以便我们可以使用此参数来提供组件内容的准确测量。然后我们重写由安卓系统在组件绘制期间调用的`onDraw()`方法，通过对`SeekBar`画布应用平移并将其放置在垂直位置。作为最后一步，我们再次调用`onSizeChanged`回调以在画布平移后调整组件的大小。
- en: 'Because we have switched the bar width and height, we need to override the
    `onTouchEvent()` method to use the component height during value calculation.
    At the bottom of the `TemperatureBar()` class, add the following callback:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们已经切换了条宽和高度，我们需要重写`onTouchEvent()`方法，以便在计算值时使用组件高度。在`TemperatureBar()`类的底部，添加以下回调：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the preceding code, we update the component progress every time an `ACTION_DOWN`,
    `ACTION_MOVE`, or `ACTION_UP` method event occurs. We don't need any other behaviors
    for the purpose of this project, so we leave the remaining implementation as it
    is.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们每次在`ACTION_DOWN`、`ACTION_MOVE`或`ACTION_UP`方法事件发生时更新组件进度。由于本项目不需要其他行为，所以我们保留其余实现不变。
- en: 'Now we can proceed writing the XML layout that hosts the preceding component
    with a degrees and hour `TextView`. Through the following steps, we can achieve
    a layout that we will inflate from our utility class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续编写承载前一个组件以及度和小时的`TextView`的XML布局。通过以下步骤，我们可以实现一个从我们的工具类中填充的布局：
- en: 'Add the `bar_height` declaration to the `dimens.xml` file under `res/values/`,
    so we can easily change it in the future if needed:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values/`下的`dimens.xml`文件中添加`bar_height`声明，这样我们可以在需要时轻松地更改它：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `temperature_bar.xml` file under `res/layout/` that contains the
    widget layout. In this file, we should add this `LinearLayout` as the root element:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout/`目录下创建`temperature_bar.xml`文件，其中包含小部件布局。在这个文件中，我们应该将此`LinearLayout`作为根元素添加：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To the preceding `LinearLayout`, include the following components:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向前一个`LinearLayout`中包含以下组件：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always change the `me.palazzetti` namespace occurrences with your own.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 始终将`me.palazzetti`命名空间替换为你的命名空间。
- en: 'Now that we have the temperature bar component and the widget layout, we need
    to create a binding between the `degrees` and the `seekbar` views. Proceed with
    the widget implementation through the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了温度条组件和小部件布局，我们需要创建一个将`degrees`和`seekbar`视图绑定的绑定。通过以下步骤进行小部件实现：
- en: Create the `DegreeListener` class in the `widget` package.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`widget`包中创建`DegreeListener`类。
- en: 'The preceding class should implement the `SeekBar` listener while storing the
    reference for the connected `degrees` view. We use this `TextView` reference to
    propagate the vertical bar value:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个类应该实现`SeekBar`监听器，同时存储连接的`degrees`视图的引用。我们使用这个`TextView`引用来传播垂直条的价值：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Propagate the progress value to the `mDegrees` view, overriding the following
    methods required by the `OnSeekBarChangeListener` interface:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将进度值传播到`mDegrees`视图，覆盖`OnSeekBarChangeListener`接口所需的以下方法：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last missing part is to provide the utility class used to inflate the widget
    layout initializing the `TemperatureBar` class with the `DegreeListener` class.
    The inflate process should be repeated for each hour of the day and it needs the
    reference of the layout in which the widget will be inflated. To complete the
    implementation, go through the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺失的部分是提供一个工具类，用于初始化带有`DegreeListener`类的`TemperatureBar`类来填充小部件布局。该填充过程应针对一天的每个小时重复进行，并且需要引用小部件将被填充的布局。要完成实现，请按照以下步骤操作：
- en: Create the `TemperatureWidget` class in the `widget` package.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`widget`包中创建`TemperatureWidget`类。
- en: 'This class should expose a static `addTo()` method that expects the activity
    context, the parent element, and whether vertical bars should be created in read-only
    mode. In this way, we can use this widget both for visualization and edit. We
    can find the complete implementation in the following code snippet:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类应该公开一个静态的`addTo()`方法，该方法需要活动上下文、父元素以及是否应以只读模式创建垂直条。这样，我们可以将此小部件用于可视化和编辑。我们可以在以下代码片段中找到完整的实现：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At the top of the class, we're defining the generated bar's number. In the `addTo()`
    method, we inflate the `temperature_bar` layout to create an instance of the bar
    object. Then, we get all the references of `time`, `degrees`, and `seekbar` objects
    so that we can set initial values and create the `DegreeListener` class with the
    `degrees TextView` binding. We proceed adding the widget to the `parent` node,
    filling the `bars` array with the currently created bar. As the last step, we
    return this array so that it can be used from the caller activity.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在类的顶部，我们定义了生成的条形数的数量。在`addTo()`方法中，我们填充`temperature_bar`布局以创建条形对象的实例。然后，我们获取`time`、`degrees`和`seekbar`对象的所有引用，以便我们可以设置初始值并创建带有`degrees
    TextView`绑定的`DegreeListener`类。我们继续将小部件添加到`parent`节点，用当前创建的条形填充`bars`数组。最后一步，我们返回这个数组，以便调用活动可以使用它。
- en: Finishing the Overview activity
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成概览活动
- en: 'The setpoints widget is now completed and we can proceed with the last steps
    inflating temperature bars during the activity creation. We will also add the
    action to start the `Settings` activity in the activity menu. To complete the
    `Overview` class, follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 设置点小部件现在已完成，我们可以继续在活动创建期间填充温度条。我们还将添加在活动菜单中启动`Settings`活动的操作。要完成`Overview`类，请按照以下步骤操作：
- en: 'Inflate the setpoints widget in the `Overview` `onCreate()` callback by adding
    the highlighted code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Overview`的`onCreate()`回调中通过添加高亮代码来填充设置点小部件：
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Handle the action bar menu to start the `Settings` activity, changing the `onOptionsItemSelected()`
    method as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理操作栏菜单以启动`Settings`活动，按照以下方式更改`onOptionsItemSelected()`方法：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Settings` activity is not available at the moment and we will create it
    in the next section.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Settings`活动目前不可用，我们将在下一节中创建它。'
- en: 'We''ve completed the `Overview` class layout and the following screenshot is
    the obtained result:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`Overview`类的布局，以下是获得的结果截图：
- en: '![Finishing the Overview activity](img/1942OS_06_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![完成概览活动](img/1942OS_06_05.jpg)'
- en: Writing the Settings activity
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写设置活动
- en: The next step before implementing the logic of our chronotherm, is to create
    the `Settings` activity that can be used to change the temperature setpoints during
    the day. To bootstrap a new activity, click on **File** from the window menu and
    choose **New** to open the context menu. There, choose **Activity** and then **Blank
    Activity**. This will open a new window and we can write `Settings` in the **Activity
    Name** and then click on **Finish**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们的温控逻辑之前，下一步是创建一个`Settings`活动，以便在白天更改温度设置点。要启动新活动，请从窗口菜单中选择**文件**，然后选择**新建**以打开上下文菜单。在那里，选择**活动**，然后选择**空白活动**。这将打开一个新窗口，我们可以在**活动名称**中填写`Settings`，然后点击**完成**。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even if we can use the built-in settings template with synchronized preferences,
    we're using a blank activity to keep this part as easy as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们可以使用带有同步首选项的内置设置模板，我们还是使用空白活动以尽可能简化这部分内容。
- en: 'We start designing the activity layout with the following mock-up, showing
    all the required components:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下草图开始设计活动布局，展示所有必需的组件：
- en: '![Writing the Settings activity](img/1942OS_06_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![编写设置活动](img/1942OS_06_06.jpg)'
- en: 'The first required step is to update the activity layout and, following the
    suggestion in the previous mock-up, we should:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要更新活动布局，根据之前草图的建议，我们应该：
- en: Add a **Save** button that will call an activity method to save the selected
    setpoints from the temperature widgets.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**保存**按钮，该按钮将调用活动方法，保存从温度小部件中选择的设置点。
- en: Inflate the temperature widget used during the setpoints selection.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择设置点期间，填充使用的温度小部件。
- en: 'To achieve the preceding layout, update the `activity_settings.xml` file under
    `res/layout/` with the following changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的布局，更新`res/layout/`下的`activity_settings.xml`文件，进行以下更改：
- en: 'Replace the root layout element with the following `LinearLayout`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`LinearLayout`替换根布局元素：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding layout, add the widget placeholder and the **Save** button:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的布局中，添加小部件占位符和**保存**按钮：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can complete the activity adding the widget initialization in the `Settings`
    class through the following steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`Settings`类中进行以下步骤，添加小部件初始化来完成活动：
- en: 'Add the highlighted variable at the top of `Settings` class:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Settings`类顶部添加高亮变量：
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `onCreate()` method of the `Settings` class, add the highlighted code
    to inflate the setpoints widget:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Settings`类的`onCreate()`方法中，添加高亮代码以填充设置点小部件：
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we upload the Android application again, we can use the menu options to
    open the `Settings` activity, which presents itself as shown in the following
    screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次上传Android应用程序，可以使用菜单选项打开`Settings`活动，如下截图所示：
- en: '![Writing the Settings activity](img/1942OS_06_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![编写Settings活动](img/1942OS_06_07.jpg)'
- en: The Chronotherm application's interface is completed and we can proceed managing
    the storage layer for the user's settings.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Chronotherm应用程序的界面已完成，我们可以继续处理用户设置存储层的管理。
- en: Managing user's setpoints
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理用户的设定点
- en: The Chronotherm application's activities provide the required user interface
    components to show and change the user's setpoints. To let them work, we should
    implement the logic to save persistent application data. Based on our needs, we
    can use the `SharedPreferences` class to store primitive data in key-value pairs
    to provide setpoint values for the entire application. In this project, we will
    use the setpoint hour as the key and the chosen temperature as the value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Chronotherm应用程序的活动提供了必要的用户界面组件，以显示和更改用户的设定点。为了让它们工作，我们应该实现保存持久应用程序数据的逻辑。根据我们的需求，我们可以使用`SharedPreferences`类以键值对的形式存储基本数据，为整个应用程序提供设定点值。在这个项目中，我们将使用设定点小时作为键，选择的温度作为值。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: '`SharedPreferences` class is a storage option provided by the Android framework.
    If in other projects we need a different storage, we may take a look at Android''s
    official documentation at [developer.android.com/guide/topics/data/data-storage.html](http://developer.android.com/guide/topics/data/data-storage.html).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences`类是Android框架提供的一种存储选项。如果在其他项目中我们需要不同的存储方式，可以查看Android官方文档：[developer.android.com/guide/topics/data/data-storage.html](http://developer.android.com/guide/topics/data/data-storage.html)。'
- en: Reading setpoints from the Overview activity
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Overview活动中读取设定点
- en: 'We begin with the `Overview` activity implementing a method that reads stored
    setpoints and updates the temperature bar values. We can proceed with the following
    steps reading the user''s preferences during the activity creation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`Overview`活动中实现一个方法，该方法读取存储的设定点并更新温度条数值。在活动创建期间，我们可以通过以下步骤读取用户的偏好设置：
- en: 'For each bar, we set the progress with the stored value. We use `0` as the
    default when no settings are found. This implementation requires the following
    code that we should add in the `Overview` class:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个进度条，我们使用存储的值来设置进度。当没有找到设置时，我们使用`0`作为默认值。这个实现需要以下代码，我们应该将其添加到`Overview`类中：
- en: '[PRE33]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We open the application's preferences and update each bar using the hour of
    the day as a key. The related hour is indirectly represented by the `i` loop counter.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们打开应用程序的偏好设置，并使用一天中的小时作为键来更新每个条形图。相关的小时由`i`循环计数器间接表示。
- en: 'Call the preceding method from the `onResume()` activity callback, adding the
    highlighted code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`onResume()`活动回调中调用前面的方法，并添加高亮显示的代码：
- en: '[PRE34]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Through these steps, we've completed setpoints management in the `Overview`
    activity and we will proceed working with the `Settings` activity.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们在`Overview`活动中完成了设定点的管理，并将继续处理`Settings`活动。
- en: Writing setpoints from the Settings activity
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Settings活动中写入设定点
- en: 'In the `Settings` activity, we should implement the logic to store the users
    setpoints when they click on the **Save settings** button. Moreover, when the
    activity is created, we must load the previously stored setpoints so that we can
    present the current schedule to the users before they start changing their preferences.
    To implement these functionalities, we may proceed with the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Settings`活动中，当用户点击**保存设置**按钮时，我们应该实现存储用户设定点的逻辑。此外，当活动创建时，我们必须加载先前存储的设定点，以便在用户开始更改偏好设置之前，向他们展示当前的时间表。为实现这些功能，我们可以按照以下步骤进行：
- en: Like we did in the `Overview` activity, we need to load setpoint values and
    update temperature bars. Because we've already implemented this functionality,
    we can simply copy and paste the `readPreferences()` method as is from the `Overview`
    class to the `Settings` class.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与在`Overview`活动中所做的一样，我们需要加载设定点值并更新温度条。因为我们已经实现了这个功能，所以可以直接从`Overview`类将`readPreferences()`方法复制粘贴到`Settings`类中。
- en: 'Add the following code at the bottom of the `Settings` class to store the selected
    setpoints:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Settings`类的底部添加以下代码以存储选定的设定点：
- en: '[PRE35]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After we've retrieved and stored all setpoints using a background commit, we
    close the current activity.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用后台提交检索并存储所有设定点之后，我们关闭当前活动。
- en: 'In the `activity_settings.xml` layout file under `res/layout/`, update the
    save button so that it will call the preceding method on click, as you can see
    in the following highlighted code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout/`下的`activity_settings.xml`布局文件中，更新保存按钮，使其在点击时调用前面的方法，如以下高亮代码所示：
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This was the last step to implement the Chronotherm application interface and
    settings management. Now we can proceed implementing the required logic to read
    the detected temperature and to turn the boiler on or off.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现Chronotherm应用程序接口和设置管理的最后一步。现在我们可以继续实现读取检测到的温度以及开启或关闭锅炉所需的逻辑。
- en: Interacting with Arduino
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Arduino交互
- en: 'Our application is ready to receive temperature data checking whether the boiler
    should be activated or not. The overall design is to use the `ExecutorService`
    class that runs a periodical scheduled thread and it should:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已准备好接收温度数据，检查是否应激活锅炉。整体设计是使用`ExecutorService`类，该类运行周期性的计划任务线程，并且应该：
- en: Read the detected temperature from ADK.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ADK读取检测到的温度。
- en: Update the boiler status checking whether the temperature is below the current
    selected setpoint.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新锅炉状态，检查温度是否低于当前选择的设定点。
- en: Send the temperature to the main thread so that it can update the `temperature`
    `TextView`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将温度发送到主线程，以便它可以更新`temperature` `TextView`。
- en: Send the command to Arduino to turn the boiler on or off. This task should be
    done only if the current boiler status has changed from the previous task execution.
    In this case, it should also send the boiler status to the main thread so that
    it can update the related `TextView`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Arduino发送命令以开启或关闭锅炉。此任务应仅在当前锅炉状态自上一次任务执行以来发生变化时执行。在这种情况下，它还应将锅炉状态发送到主线程，以便它可以更新相关的`TextView`。
- en: 'Before we proceed with thread implementation, we should provide a Java interface
    that exposes the required methods to update the activity''s user interface. We
    can fulfill this with the following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始线程实现之前，我们应该提供一个Java接口，它公开了更新活动用户界面所需的必要方法。我们可以通过以下步骤完成此操作：
- en: 'Create a new Java interface called `OnDataChangeListener` and add the following
    code snippet:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`OnDataChangeListener`的新Java接口，并添加以下代码片段：
- en: '[PRE37]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the preceding interface to the `Overview` class using the highlighted code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用高亮代码将前面的接口添加到`Overview`类：
- en: '[PRE38]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the interface by writing the code that updates the current temperature
    and the boiler status TextViews:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写更新当前温度和锅炉状态`TextViews`的代码来实现接口：
- en: '[PRE39]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can proceed implementing the scheduled thread, following the overall
    design explained previously:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续实现先前解释的整体设计的计划任务线程：
- en: Create a new package in your namespace called `adk`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的命名空间中创建一个名为`adk`的新包。
- en: In the `adk` package, add a new class named `DataReader`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`adk`包中，添加一个名为`DataReader`的新类。
- en: 'At the top of the class, add the following declarations:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，添加以下声明：
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We define the polling time for the scheduled thread and the message types used
    in the main thread handler to identify a temperature or a boiler update. We store
    the references for the `AdkManager` instance, the activity context, and the caller
    activity that implements the previous interface. Then we define the `ExecutorService`
    implementation that we will use to create short-lived threads for sensor readings.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了计划任务的轮询时间以及主线程处理器中使用的消息类型，以识别温度或锅炉更新。我们保存了`AdkManager`实例、活动上下文以及实现前一个接口的调用活动引用。然后，我们定义了将用于创建短生命周期的线程以读取传感器数据的`ExecutorService`实现。
- en: 'Implement the `DataReader` constructor to set the message handler when the
    main thread receives messages from the sensor thread:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现设置消息处理器的`DataReader`构造函数，当主线程从传感器线程接收到消息时：
- en: '[PRE41]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We store all the required references and then we define the main thread handler.
    Within the handler, we use the `OnDataChangeListener` callbacks to update the
    temperature or the boiler status in the view, according to the message type.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们保存所有必要的引用，然后定义主线程处理器。在处理器内部，我们使用`OnDataChangeListener`回调根据消息类型在视图中更新温度或锅炉状态。
- en: 'At the bottom of the `DataReader` constructor, add the following `Runnable`
    method implementation that realizes the overall design previously defined:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataReader`构造函数的底部，添加以下实现了先前定义的整体设计的`Runnable`方法：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this implementation, we create the `isBelowSetpoint()` method that checks
    whether the temperature is below the chosen setpoint for the current hour. We
    retrieve this value from the application's shared preferences.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个实现中，我们创建了一个`isBelowSetpoint()`方法，用于检查当前小时的温度是否低于所选的设定点。我们从应用程序的共享偏好设置中获取这个值。
- en: 'Add a method to the `DataReader` class to start the scheduler that spawns short-lived
    threads periodically as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DataReader`类添加一个方法，以定期创建短生命周期的线程来启动调度程序，如下所示：
- en: '[PRE43]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `stop()` method at the bottom of the class to stop the scheduler from
    spawning new threads through the `shutdown()` executor''s method:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的底部添加`stop()`方法，通过执行器的`shutdown()`方法停止调度程序创建新线程：
- en: '[PRE44]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we should go back to the `Overview` class to start and stop the scheduler
    within the activity lifecycle. Add the `DataReader` declaration at the top of
    the `Overview` class:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该回到`Overview`类中，在活动生命周期内开始和停止调度程序。在`Overview`类的顶部添加`DataReader`声明：
- en: '[PRE45]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Initialize the `DataReader` instance in the `onCreate()` callback through the
    following highlighted code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`回调中初始化`DataReader`实例，通过以下突出显示的代码：
- en: '[PRE46]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Start and stop the reading scheduler in the `onResume()` and `onPause()` activity''s
    callbacks, as you can see in the highlighted code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onResume()`和`onPause()`活动的回调中开始和停止读取调度程序，如突出显示的代码所示：
- en: '[PRE47]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The communication between UDOO and Android is up and running and the logic
    of our chronotherm is ready to activate and deactivate the boiler. Now, we can
    upload the Android application again, add some temperature settings, and start
    playing with the prototype. We''ve completed our prototype and the last missing
    task is to update the application version in the `app/build.gradle` file with
    a `0.1.0` version, as you can see in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: UDOO和Android之间的通信已经运行起来，我们恒温器的逻辑已经准备好激活和关闭锅炉。现在，我们可以再次上传Android应用程序，添加一些温度设置，并开始玩原型。我们已经完成了原型，最后缺少的任务是在`app/build.gradle`文件中将应用程序版本更新为`0.1.0`版本，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Improving the prototype
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进原型
- en: During this chapter we've made different design decisions making the chronotherm
    easier to implement. While this application is good proof of concept for home
    automation, we have to bear in mind that many things should be done to improve
    the quality and reliability of the prototype. This application is a classical
    scenario with a **Human-Machine Interface (HMI)** and a **Control System** implemented
    respectively, with an Android application and an Arduino microcontroller. In such
    scenarios, a driving principle of automation design is that the control unit should
    be capable of making *reasonable and safe decisions* even in the absence of the
    HMI part.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做出了不同的设计决策，使恒温器的实现更加容易。尽管这个应用程序对于家庭自动化来说是一个很好的概念验证，但我们必须牢记，还需要做很多事情来提高原型的质量和可靠性。这个应用程序是一个经典场景，分别用Android应用程序和Arduino微控制器实现了**人机界面（HMI）**和**控制系统**。在这种场景中，自动化设计的一个基本原则是，即使在没有HMI部分的情况下，控制单元也应该能够做出*合理且安全的决策*。
- en: In our case, we've decoupled responsibilities delegating the decision to turn
    the boiler on or off to the Android application. While this isn't a mission-critical
    system, with this design, we may risk that if the Android application crashes,
    the boiler remains turned on forever. A better decoupling would be using the HMI
    only for showing feedback and storing the user's setpoints, while the decision
    to change the boiler status remains in the control unit. This means that instead
    of sending on or off commands to Arduino, we should send the current setpoint
    that will be stored in the microcontroller's memory. In this way, the control
    unit could make safe choices according to the last received setpoint.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们解耦了责任，将打开或关闭锅炉的决定委托给Android应用程序。虽然这不是一个任务关键的系统，但这样的设计可能会导致如果Android应用程序崩溃，锅炉可能会永远保持开启状态。更好的解耦方式是只使用HMI显示反馈和存储用户的设定点，而改变锅炉状态的决定仍然留在控制单元中。这意味着，我们不应该向Arduino发送开或关的命令，而应该发送当前的设定点，该设定点将存储在微控制器的内存中。这样，控制单元可以根据最后收到的设定点做出安全的选择。
- en: Another improvement that we may take into account as an exercise is to implement
    a **hysteresis logic**. Our chronotherm is designed to turn the boiler on or off,
    respectively, when the detected temperature exceeds or is below the chosen setpoint.
    This behavior should be improved because with such design, when the temperature
    is stabilized around the setpoint, the chronotherm will start to turn the boiler
    on and off very frequently. We can find useful details and suggestions about applying
    hysteresis logic in control systems at [http://en.wikipedia.org/wiki/Hysteresis#Control_systems](http://en.wikipedia.org/wiki/Hysteresis#Control_systems).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以作为练习考虑的改进是实施**滞后逻辑**。我们的恒温器设计为在检测到的温度超过或低于选定设定点时分别开启或关闭锅炉。这种行为应该得到改进，因为在这种设计中，当温度稳定在设定点周围时，恒温器将开始频繁地开启和关闭锅炉。我们可以在[控制系统的滞后逻辑应用](http://en.wikipedia.org/wiki/Hysteresis#Control_systems)中找到有关详细信息和建议。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the land of home automation and how UDOO can be
    used to work out some daily tasks. You learned about the advantages of using smart
    objects that are capable of solving place and time problems when you aren't at
    home. Then, we planned a chronotherm prototype to control our living room temperature
    through a sensor. To make the device fully automated, we designed a use case where
    users can decide temperature setpoints for each hour of the day.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了智能家居领域以及如何使用UDOO解决一些日常任务。你了解了使用智能对象的优势，这些对象能够在你不在家时解决地点和时间问题。然后，我们规划了一个恒温器原型，通过传感器控制我们的客厅温度。为了使设备完全自动化，我们设计了一个用例，用户可以决定每天每个小时的温度设定点。
- en: At the beginning, we built the application circuit using a temperature sensor
    and an LED to simulate the boiler. We started programming the Android user interface
    customizing a regular UI component to fit our needs better. We started writing
    the overview activity that showed the current time, the boiler status, the current
    room temperature, and the widget with chosen setpoints for the whole day. We continued
    with the settings activity used to store the chronotherm temperature schedule.
    As the last step, we wrote a scheduled thread that reads the environment temperature
    and turns the boiler on or off, matching the detected temperature with the current
    setpoint.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们使用温度传感器和LED构建了应用电路，模拟了锅炉。我们开始编写Android用户界面程序，自定义常规UI组件以更好地满足我们的需求。我们开始编写概述活动，显示当前时间、锅炉状态、当前室温以及全天选择的设定点的小部件。接着，我们继续编写设置活动，用于存储恒温器温度计划。作为最后一步，我们编写了一个计划任务线程，读取环境温度并根据检测到的温度与当前设定点匹配来开启或关闭锅炉。
- en: In the next chapter, we will extend this prototype with new functionalities
    to enhance the human interaction thanks to a powerful set of Android APIs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用一系列强大的Android API扩展此原型，增加新功能以增强人与设备的交互。
