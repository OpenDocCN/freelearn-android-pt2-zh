- en: Chapter 10. Getting More From AndEngine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 从AndEngine获取更多内容
- en: 'This chapter will cover additional recipes that have a more specific application
    than those in previous chapters. These recipes include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍比前几章更具体应用的附加食谱。这些食谱包括：
- en: Loading all textures from a folder
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件夹加载所有纹理
- en: Using textured meshes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理网格
- en: Applying a sprite-based shadow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用基于精灵的阴影
- en: Creating a physics-based moving platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于物理的移动平台
- en: Creating a physics-based rope bridge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于物理的绳索桥梁
- en: Loading all textures from a folder
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件夹加载所有纹理
- en: When creating a game that has a large amount of textures, loading each texture
    individually can become tedious. Creating a method to load and retrieve textures
    in such a game can be not only timesaving during development, but also reduce
    the overall loading times during runtime. In this recipe, we will create a way
    to load a large amount of textures using only a single line of code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个包含大量纹理的游戏时，逐个加载每个纹理可能会变得繁琐。在这种游戏中创建加载和检索纹理的方法不仅可以节省开发时间，还可以减少运行时的整体加载时间。在本食谱中，我们将创建一种使用单行代码加载大量纹理的方法。
- en: Getting ready...
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: 'First, create a new activity class named `TextureFolderLoadingActivity` that
    extends the `BaseGameActivity` class. Next, create a folder named `FolderToLoad`
    in the `assets/gfx/` folder. Finally, place five images in the `assets/gfx/FolderToLoad/`
    folder with the names: `Coin1`, `Coin5`, `Coin10`, `Coin50`, and `Coin100`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`TextureFolderLoadingActivity`的新活动类，继承自`BaseGameActivity`类。接下来，在`assets/gfx/`文件夹中创建一个名为`FolderToLoad`的文件夹。最后，将五张图片放入`assets/gfx/FolderToLoad/`文件夹中，分别命名为：`Coin1`、`Coin5`、`Coin10`、`Coin50`和`Coin100`。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to fill our `TextureFolderLoadingActivity` activity class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤填写我们的`TextureFolderLoadingActivity`活动类：
- en: 'Place the following, simple code in our activity to make it functional:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的活动中放置以下简单的代码使其功能化：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, place this `ArrayList` variable and `ManagedStandardTexture` class inside
    of the activity:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将这个`ArrayList`变量和`ManagedStandardTexture`类放在活动内：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, add the next two methods to the activity class to allow us to load a
    texture by passing only the `TextureOptions` parameter and the filename:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将下面两个方法添加到活动类中，以便我们通过只传递`TextureOptions`参数和文件名来加载纹理：
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now insert the following method that allows us to load all of the textures
    within either one folder or multiple folders:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，插入以下方法，允许我们加载单个或多个文件夹内的所有纹理：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, place the following methods into the activity to let us unload all `ManagedStandardTexture`
    classes or retrieve a texture by its short filename:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，将以下方法放入活动中，让我们可以卸载所有的`ManagedStandardTexture`类或通过其短文件名检索纹理：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have all of our methods in the activity, place the following line
    of code in the `onCreateResources()` method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们的活动类中已经有了所有方法，请在`onCreateResources()`方法中放置以下代码行：
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, add the following code to the `onPopulateScene()` method to show how
    we can retrieve a loaded texture by name:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onPopulateScene()`方法中添加以下代码，以展示我们如何通过名称检索已加载的纹理：
- en: '[PRE6]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step one, we set up our `TextureFolderLoadingActivity` activity class by
    implementing the standard, overridden `BaseGameActivity` methods that most AndEngine
    games use. For more information on setting up an activity for use with AndEngine,
    see the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们通过实现大多数AndEngine游戏使用的标准覆盖`BaseGameActivity`方法来设置我们的`TextureFolderLoadingActivity`活动类。有关为AndEngine设置活动更多信息，请参见[第1章](ch01.html
    "第1章. AndEngine游戏结构")中的*了解生命周期*食谱，*AndEngine游戏结构*。
- en: In step two, we create an `ArrayList` variable of `ManagedStandardTexture` objects,
    which is defined directly following the definition of the `ArrayList` variable.
    `ManagedStandardTextures` are simple containers that hold a pointer to an `ITextureRegion`
    region and a string variable that represents the `ITextureRegion` object's name.
    The `ManagedStandardTexture` class also includes a method to unload `ITextureRegion`
    and prepare the variables to be removed from memory upon the next garbage collection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们创建一个`ManagedStandardTexture`对象的`ArrayList`变量，这个定义紧跟在`ArrayList`变量的定义之后。`ManagedStandardTextures`是简单的容器，它持有一个指向`ITextureRegion`区域的指针和一个表示`ITextureRegion`对象名称的字符串变量。`ManagedStandardTexture`类还包括一个卸载`ITextureRegion`的方法，并准备在下次垃圾收集时从内存中移除这些变量。
- en: 'The third step includes two methods, `getTextureRegion()` and `loadAndManageTextureRegion()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步包括两个方法，`getTextureRegion()`和`loadAndManageTextureRegion()`：
- en: The `getTextureRegion()` method calls the `loadAndManageTextureRegion()` method
    and returns the recently-loaded texture from the `ArrayList` variable named `loadedTextures`
    defined in step two.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTextureRegion()`方法调用了`loadAndManageTextureRegion()`方法，并从第二步中定义的名为`loadedTextures`的`ArrayList`变量返回最近加载的纹理。'
- en: The `loadAndManageTextureRegion()` method creates an `AssetBitmapTextureAtlasSource`
    source named `cSource`, which is only used to pass the texture's width and height
    in the following definition of the `BitmapTextureAtlas` object, `TextureToLoad`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadAndManageTextureRegion()`方法创建了一个名为`cSource`的`AssetBitmapTextureAtlasSource`源，它仅用于在以下`BitmapTextureAtlas`对象`TextureToLoad`的定义中传递纹理的宽度和高度。'
- en: The `TextureRegion` object, `TextureRegionToLoad`, is created by calling the
    `BitmapTextureAtlasTextureRegionFactory` object's `createFromAsset()` method.
    `TextureToLoad` is then loaded, and the `TextureRegionToLoad` object is added
    to the `loadedTextures` `ArrayList` variable by creating a new `ManagedStandardTexture`
    class. For more information on textures, see the *Different types of textures*
    recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine
    Game Structure*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextureRegion`对象`TextureRegionToLoad`是通过调用`BitmapTextureAtlasTextureRegionFactory`对象的`createFromAsset()`方法创建的。然后加载`TextureToLoad`，并通过创建一个新的`ManagedStandardTexture`类，将`TextureRegionToLoad`对象添加到`loadedTextures`
    `ArrayList`变量中。有关纹理的更多信息，请参见[第1章](ch01.html "第1章. AndEngine游戏结构")中的*不同类型的纹理*食谱，*AndEngine游戏结构*。'
- en: In step four, we create a method that parses the list of files in each folder
    passed in the `pFolderPaths` array and loads the image files as textures with
    the `TextureOptions` parameter being applied to each image. The `listFileNames`
    string array holds the list of files in each of the `pFolderPaths` folders, and
    the `curFilePath` and `curFileExtension` variables are used to store the filepaths
    and their relative extensions for use in determining which files are AndEngine-supported
    images. The first `for` loop simply runs the parsing and loading process for each
    folder path given. The `getAssets().list()` method throws an `IOException` exception
    and thus needs to be enclosed in a `try-catch` block. It is used to retrieve a
    list of all of the files within the passed `String` parameter. The second `for`
    loop sets `curFilePath` to the current `i` value's folder path concatenated with
    the current filename from the `listFileNames` array. Next, the `curFileExtension`
    string variable is set to the `curFilePath` variable's last index of ".", to return
    the extension, using the `substring()` method. Then, we check to make sure that
    the current file's extension is equal to one that is supported by AndEngine and
    call the `loadAndManageTextureRegion()` method if `true`. Finally, we catch the
    `IOException` exception by sending a message to the log and printing a `StackTrace`
    message from the `IOException` exception.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们创建了一个方法，该方法解析通过`pFolderPaths`数组传递的每个文件夹中的文件列表，并使用`TextureOptions`参数将图像文件加载为纹理。`listFileNames`字符串数组保存了`pFolderPaths`文件夹中每个文件夹的文件列表，`curFilePath`和`curFileExtension`变量用于存储文件路径及其相对扩展名，以便确定哪些文件是AndEngine支持的图像。第一个`for`循环简单地对每个给定的文件夹路径执行解析和加载过程。`getAssets().list()`方法抛出`IOException`异常，因此需要将其包含在`try-catch`块中。它用于获取通过传递的`String`参数中的所有文件列表。第二个`for`循环将`curFilePath`设置为当前`i`值的文件夹路径与`listFileNames`数组中的当前文件名拼接而成。接下来，`curFileExtension`字符串变量被设置为`curFilePath`变量的最后一个"。"索引，以返回扩展名，使用`substring()`方法。然后，我们检查以确保当前文件的扩展名等于AndEngine支持的扩展名，并在为`true`时调用`loadAndManageTextureRegion()`方法。最后，我们通过向日志发送消息并打印来自`IOException`异常的`StackTrace`消息来捕获`IOException`异常。
- en: 'The fifth step includes two methods, `unloadAllTextures()` and `getLoadedTextureRegion()`,
    that assist our managing of the textures loaded by our previous methods:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步包括两个方法，`unloadAllTextures()`和`getLoadedTextureRegion()`，它们协助我们管理通过我们之前的方法加载的纹理：
- en: The `unloadAllTextures()` method runs through all `ManagedStandardTextures`
    in the `loadedTextures` `ArrayList` object and unloads them using the `removeFromMemory()`
    method before removing them from `loadedTextures` and requesting a garbage collection
    from the system
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unloadAllTextures()`方法遍历`loadedTextures` `ArrayList`对象中的所有`ManagedStandardTextures`，并使用`removeFromMemory()`方法卸载它们，在从`loadedTextures`中移除它们并请求系统进行垃圾回收之前。'
- en: The `getLoadedTextureRegion()` method checks every `ManagedStandardTexture`
    in the `loadedTextures` variable against the `pName` string parameter and returns
    the current `ManagedStandardTexture` class' `ITextureRegion` region if the names
    are equal, or `null` if no match is made
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLoadedTextureRegion()`方法检查`loadedTextures`变量中的每个`ManagedStandardTexture`，与`pName`字符串参数进行对比，如果名称相等，则返回当前`ManagedStandardTexture`类的`ITextureRegion`区域，否则如果没有匹配，则返回`null`。'
- en: Step six calls the `loadAllTextureRegionsInFolders()` method from inside the
    `onCreateResources()` activity method by passing a `BILINEAR` `TextureOption`
    parameter and the asset folder path of our `FolderToLoad` folder. For more information
    on `TextureOptions`, see the *Applying options to our textures* recipe in [Chapter
    1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第六步通过传递一个`BILINEAR` `TextureOption`参数和我们的`FolderToLoad`文件夹的资产文件夹路径，从`onCreateResources()`活动方法内部调用`loadAllTextureRegionsInFolders()`方法。有关`TextureOptions`的更多信息，请参见[第1章](ch01.html
    "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的*向我们的纹理应用选项*食谱。
- en: In our final step, we attach five sprites to our scene inside of the `onPopulateScene()`
    activity method. Each of the sprite constructors calls the `getLoadedTextureRegion()`
    method and passes the respective short name of the sprite's image file. The locations
    of each of the sprites place them in a horizontal line across the screen. The
    display of our sprites with textures loaded all at once should look similar to
    the following image. For more information on creating sprites, see the *Adding
    sprites to a layer* recipe in [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们在`onPopulateScene()`活动方法内部将五个精灵附加到我们的场景中。每个精灵构造函数都调用`getLoadedTextureRegion()`方法，并传递精灵图像文件的相应简称。每个精灵的位置将它们放置在屏幕上的一条水平线上。一次性加载纹理的精灵显示应类似于以下图像。有关创建精灵的更多信息，请参见[第2章](ch02.html
    "第2章. 使用实体")，*使用实体*中的*向层中添加精灵*食谱。
- en: '![How it works...](img/8987OS_10_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_10_01.jpg)'
- en: See also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的*理解生命周期*。
- en: '*Different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的*不同类型的纹理*。
- en: '*Applying options to our textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的*向我们的纹理应用选项*。
- en: '*Adding sprites to a layer* in [Chapter 2](ch02.html "Chapter 2. Working with
    Entities"), *Working with Entities*.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")，*使用实体*中的*向层中添加精灵*。
- en: Using textured meshes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理网格
- en: '**Textured meshes**, which are simply triangulated polygons with a texture
    applied, are becoming more popular in mobile games because they allow for the
    creation and manipulation of non-rectangular shapes. Having the ability to work
    with textured meshes often creates an extra layer of game mechanics that were
    previously too costly to implement. In this recipe, we will learn how to create
    a textured mesh from a predetermined set of triangles.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理网格**，即简单应用了纹理的三角剖分多边形，在移动游戏中越来越受欢迎，因为它们允许创建和非矩形形状的操作。具有处理纹理网格的能力通常创建了一个额外的游戏机制层，这些机制以前实现起来成本过高。在本食谱中，我们将学习如何从一组预定的三角形创建纹理网格。'
- en: Getting ready...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: First, create a new activity class named `TexturedMeshActivity` that extends
    `BaseGameActivity`. Next, place a seamless-tiling texture named `dirt.png` with
    the dimensions 512 x 128 in the `assets/gfx/` folder of our project. Finally,
    import the `TexturedMesh.java` class from the code bundle into our project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`TexturedMeshActivity`的新活动类，继承自`BaseGameActivity`。接下来，将一个名为`dirt.png`的无缝拼接纹理，尺寸为512
    x 128，放在我们项目的`assets/gfx/`文件夹中。最后，将代码包中的`TexturedMesh.java`类导入到我们的项目中。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build our `TexturedMeshActivity` activity class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的`TexturedMeshActivity`活动类：
- en: 'Place the following code in our activity to give us a standard AndEngine activity:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的活动中放置以下代码，以获得一个标准的AndEngine活动：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet to the `onPopulateScene()` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onPopulateScene()`方法中添加以下代码片段：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step one, we prepare our `TexturedMeshActivity` class by inserting into it
    the standard, overridden `BaseGameActivity` methods that most AndEngine games
    use. For more information on setting up an activity for use with AndEngine, see
    the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们准备`TexturedMeshActivity`类，通过插入大多数AndEngine游戏使用的标准的重写`BaseGameActivity`方法。有关使用AndEngine设置活动的更多信息，请参见[第1章](ch01.html
    "第1章. AndEngine游戏结构")，*Understanding the life cycle*部分。
- en: In step two, we first define `texturedMeshT`, a `BitmapTextureAtlas` object,
    with the final parameter of the constructor being a `REPEATING_BILINEAR` `TextureOption`
    parameter to create a texture that will tile seamlessly within the triangles that
    make up our textured mesh. For more information on `TextureOptions`, see the *Applying
    options to our textures* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们首先定义了`texturedMeshT`，这是一个`BitmapTextureAtlas`对象，构造函数的最后一个参数是`REPEATING_BILINEAR`
    `TextureOption`，用于创建一个在构成我们纹理网格的三角形中无缝平铺的纹理。有关`TextureOptions`的更多信息，请参见[第1章](ch01.html
    "第1章. AndEngine游戏结构")，*Applying options to our textures*部分。
- en: 'After creating the `texturedMeshTR` `ITextureRegion` object and loading our
    `texturedMeshT` object, we define an array of float variables that specify the
    relative and consecutive x and y positions of each of the vertices of each triangle
    that make up our textured mesh. See the following image for a better idea of how
    the vertices of a triangle are used in a textured mesh:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`texturedMeshTR` `ITextureRegion`对象并加载了我们的`texturedMeshT`对象之后，我们定义了一个浮点数数组，用于指定构成我们纹理网格的每个三角形的每个顶点的相对连续的x和y位置。以下图片将更好地展示如何在纹理网格中使用三角形的顶点：
- en: '![How it works...](img/8987OS_10_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_10_02.jpg)'
- en: 'Next, we create the `meshBufferData` float array and set its size to the vertex
    size of the `TexturedMesh` class multiplied by the number of vertices in the `meshTriangleVertices`
    array—one vertex occupies two indices in the array, `X` and `Y`, so we must divide
    the length by `2`. Then, for each of the vertices in the `meshTriangleVertices`
    array, we apply the vertex''s position to the `meshBufferData` array. Finally,
    we create the `TexturedMesh` object, named `starTexturedMesh`. The parameters
    of the `TexturedMesh` constructor are the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`meshBufferData`浮点数组，并将其大小设置为`TexturedMesh`类的顶点大小乘以`meshTriangleVertices`数组中的顶点数——一个顶点在数组中占用两个索引，`X`和`Y`，因此我们必须将长度除以`2`。然后，对于`meshTriangleVertices`数组中的每个顶点，我们将顶点的位置应用到`meshBufferData`数组中。最后，我们创建名为`starTexturedMesh`的`TexturedMesh`对象。`TexturedMesh`构造函数的参数如下：
- en: The first two parameters of the constructor are the x and y location of `400f`,
    `225f`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的前两个参数是`400f`，`225f`的x和y位置。
- en: The next two parameters are the `meshBufferData` buffer data and the number
    of vertices, `12`, that we placed in the `meshBufferData` array
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个参数是`meshBufferData`缓冲数据和我们在`meshBufferData`数组中放置的顶点数，`12`。
- en: The final three parameters of the `TexturedMesh` constructor are `DrawMode`
    of `Triangles`, `ITextureRegion` for the mesh, and our `VertexBufferObjectManager`
    object.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TexturedMesh`构造函数的最后三个参数是`Triangles`的`DrawMode`、网格的`ITextureRegion`和我们`VertexBufferObjectManager`对象。'
- en: For more information on creating `Meshes`, from which the `TexturedMesh` class
    is derived, see the *Applying primitives to a layer* recipe in [Chapter 2](ch02.html
    "Chapter 2. Working with Entities"), *Working with Entities*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建`Meshes`的更多信息，从中派生出`TexturedMesh`类，请参见[第2章](ch02.html "第2章. 使用实体")，*Applying
    primitives to a layer*部分。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见以下内容
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中，了解生命周期，即*Understanding
    the life cycle*。
- en: '*Applying options to our textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中，我们讨论了如何将选项应用到我们的纹理中，即*Applying
    options to our textures*。
- en: '*Applying primitives to a layer* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 使用实体")，*Working with Entities*中，我们讨论了如何将图元应用到图层，即*Applying
    primitives to a layer*。
- en: Applying a sprite-based shadow
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用基于精灵的阴影
- en: The addition of shadows to a game can increase the visual depth and give the
    game a more appealing appearance. Simply placing a sprite with a shadow texture
    below an object is a fast and efficient way to handle shadow creation. In this
    chapter, we will be learning how to do that while keeping the shadow properly
    aligned with its parent object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中添加阴影可以增加视觉深度，使游戏更具吸引力。简单地在对象下方放置一个带有阴影纹理的精灵是一种快速有效的处理阴影创建的方法。在本章中，我们将学习如何保持阴影与其父对象正确对齐的同时完成这一工作。
- en: Getting ready...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: First, create a new activity class named `SpriteShadowActivity` that extends
    `BaseGameActivity` and implements `IOnSceneTouchListener`. Next, place a shadow
    image with a size of 256 x 128 and named `shadow.png` into the `assets/gfx/` folder.
    Finally, place a character image of size 128 x 256 and named `character.png` into
    the `assets/gfx/` folder.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`SpriteShadowActivity`的新活动类，该类继承自`BaseGameActivity`并实现`IOnSceneTouchListener`。接下来，将大小为256
    x 128且名为`shadow.png`的阴影图像放入`assets/gfx/`文件夹中。最后，将大小为128 x 256且名为`character.png`的角色图像放入`assets/gfx/`文件夹中。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build our `SpriteShadowActivity` activity class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的`SpriteShadowActivity`活动类：
- en: 'Place the following standard AndEngine activity code in our activity class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的活动类中放入以下标准的AndEngine活动代码：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, place these variables in our activity to give us specific control over
    the shadow:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的活动中放置这些变量，以便我们具体控制阴影：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now place the following method in our activity to make the shadow''s alpha
    inversely proportional to the distance of the character from the shadow:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下方法放入我们的活动中，使阴影的alpha值与角色与阴影的距离成反比：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Insert the following code snippet into the `onSceneTouchEvent()` method:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSceneTouchEvent()`方法中插入以下代码片段：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, fill the `onPopulateScene()` method with the following snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用以下代码片段填充`onPopulateScene()`方法：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step one, we set up our `SpriteShadowActivity` activity class by implementing
    the standard, overridden `BaseGameActivity` methods that most AndEngine games
    use. For more information on setting up an activity for use with AndEngine, see
    the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们通过实现大多数AndEngine游戏使用的标准覆盖`BaseGameActivity`方法来设置我们的`SpriteShadowActivity`活动类。有关使用AndEngine设置活动的更多信息，请参见[第1章](ch01.html
    "第1章. AndEngine游戏结构")中的*了解生命周期*部分，*AndEngine游戏结构*。
- en: 'The following image shows how this recipe places our shadow sprite in relation
    to the character sprite:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这个方法是如何将我们的阴影精灵放置在角色精灵的关系位置上的：
- en: '![How it works...](img/8987OS_10_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_10_03.jpg)'
- en: 'In step two, we define several constants that will control how the shadow sprite,
    `shadowSprite`, is aligned to the character sprite, `characterSprite`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们定义了几个常量，这些常量将控制阴影精灵`shadowSprite`与角色精灵`characterSprite`的对齐方式：
- en: The first two constants, `CHARACTER_START_X` and `CHARACTER_START_Y`, set the
    initial position of `characterSprite`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个常量`CHARACTER_START_X`和`CHARACTER_START_Y`设置了`characterSprite`的初始位置。
- en: The next two constants, `SHADOW_OFFSET_X` and `SHADOW_OFFSET_Y`, control the
    distance on the x and y axis as to how far the shadow will be initially positioned
    in relation to the character sprite
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个常量`SHADOW_OFFSET_X`和`SHADOW_OFFSET_Y`控制了阴影与角色精灵在x和y轴上的初始位置距离。
- en: The `SHADOW_OFFSET_X` constant is also used to update the shadow sprite's position
    when the character sprite is moved
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHADOW_OFFSET_X`常量也用于在移动角色精灵时更新阴影精灵的位置。'
- en: 'The next four constants control how, and to what level, the `shadowSprite`
    sprite''s alpha will be controlled:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个常量控制了`shadowSprite`精灵的alpha值如何被控制以及控制到什么程度：
- en: '`SHADOW_MAX_ALPHA` and `SHADOW_MIN_ALPHA` set the absolute minimum and maximum
    alpha, which is changed according to the character''s distance on the y axis from
    the shadow. The further the distance, the lower the alpha of the `shadowSprite`
    sprite will be until the minimum level is reached.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHADOW_MAX_ALPHA`和`SHADOW_MIN_ALPHA`设置了alpha值的绝对最大和最小值，这会根据角色与阴影在y轴上的距离而改变。距离越远，`shadowSprite`的alpha值越低，直至达到最低水平。'
- en: The `SHADOW_MAX_ALPHA_HEIGHT` constant represents the maximum distance of the
    character from the shadow that the `shadowSprite` sprite's alpha will be affected
    before defaulting to `SHADOW_MIN_ALPHA`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHADOW_MAX_ALPHA_HEIGHT`常量表示角色与阴影的距离在影响`shadowSprite`的alpha值之前，可以达到的最大距离，之后默认为`SHADOW_MIN_ALPHA`。'
- en: The `SHADOW_MIN_ALPHA_HEIGHT` constant represents the minimum distance of the
    character from the shadow that the shadow's alpha should change. If `SHADOW_MIN_ALPHA_HEIGHT`
    is greater than `0`, the shadow's alpha will be at its maximum while the character's
    distance from the shadow is below `SHADOW_MIN_ALPHA_HEIGHT`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHADOW_MIN_ALPHA_HEIGHT` 常量表示角色距离阴影的最小距离，该距离会影响阴影的透明度变化。如果 `SHADOW_MIN_ALPHA_HEIGHT`
    大于 `0`，当角色距离阴影低于 `SHADOW_MIN_ALPHA_HEIGHT` 时，阴影的透明度将处于最大值。'
- en: The remaining constants are calculated automatically from the previous set.
    `SHADOW_START_X` and `SHADOW_START_Y` represent the starting position of the `shadowSprite`
    sprite. They are calculated by adding the shadow's offset values to the character's
    starting position. The `CHARACTER_SHADOW_Y_DIFFERENCE` constant represents the
    initial starting distance between the character and the shadow on the y axis.
    The `SHADOW_ALPHA_HEIGHT_DIFFERENCE` constant represents the difference between
    the minimum and maximum heights and acts to modulate the shadow's alpha at runtime.
    The final constant, `SHADOW_ALPHA_DIFFERENCE`, represents the difference between
    the minimum and maximum alpha levels of the `shadowSprite` sprite. Similar to
    the `SHADOW_ALPHA_HEIGHT_DIFFERENCE` constant, it is used at runtime to determine
    the alpha level of the shadow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的常量会从之前的集合中自动计算得出。`SHADOW_START_X` 和 `SHADOW_START_Y` 代表 `shadowSprite` 图像的起始位置。它们是通过将阴影的偏移值加到角色的起始位置来计算的。`CHARACTER_SHADOW_Y_DIFFERENCE`
    常量表示角色与阴影在y轴上的初始起始距离。`SHADOW_ALPHA_HEIGHT_DIFFERENCE` 常量表示最小高度和最大高度之间的差，用于在运行时调节阴影的透明度。最后的常量
    `SHADOW_ALPHA_DIFFERENCE` 表示 `shadowSprite` 图像的最小和最大透明度水平之间的差。与 `SHADOW_ALPHA_HEIGHT_DIFFERENCE`
    常量类似，它在运行时用于确定阴影的透明度水平。
- en: The final two variables in step two, `shadowSprite` and `characterSprite`, represent
    the shadow and character in our scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中的最后两个变量 `shadowSprite` 和 `characterSprite` 分别代表我们场景中的阴影和角色。
- en: In the third step, we create a method that will update the shadow's alpha. We
    call the `shadowSprite.setAlpha()` method with the `MathUtils.bringToBounds()`
    method as the parameter. The `MathUtils.bringToBounds()` method takes a minimum
    and maximum value and ensures that the third value is within that range. We pass
    the `SHADOW_MIN_ALPHA` and `SHADOW_MAX_ALPHA` constants as the first two parameters
    of the `bringToBounds()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们创建一个方法来更新阴影的透明度。我们调用 `shadowSprite.setAlpha()` 方法，并以 `MathUtils.bringToBounds()`
    方法作为参数。`MathUtils.bringToBounds()` 方法接受一个最小值和最大值，确保第三个值在这个范围内。我们将 `SHADOW_MIN_ALPHA`
    和 `SHADOW_MAX_ALPHA` 常量作为 `bringToBounds()` 方法的头两个参数传递。
- en: The third parameter is the algorithm for determining the alpha of the shadow
    based on the distance of the `characterSprite` sprite from the `shadowSprite`
    sprite. The algorithm starts by subtracting the `CHARACTER_SHADOW_Y_DIFFERENCE`
    constant from the character's position on the y axis. This gives us the current
    ceiling of the y value that affects the shadow's alpha. Next, we subtract the
    shadow's starting position on the y axis to get the current, ideal distance of
    the character from the shadow. Next, we divide that distance by `SHADOW_ALPHA_HEIGHT_DIFFERENCE`
    to get the unit ratio of constrained-distance to alpha and multiply the ratio
    by the `SHADOW_ALPHA_DIFFERENCE` constant to get the unit ratio of constrained-distance
    to constrained-alpha. Currently, our ratio is inverted and will increase the alpha
    with distance, which opposes our goal of decreasing alpha as the character moves
    further, so we subtract it from the `SHADOW_MAX_ALPHA` constant to give us a proper
    ratio that decreases alpha as distance increases. Completing the algorithm, we
    then use the `bringToBounds()` method to ensure that the alpha value produced
    by the algorithm is constrained within the range of `SHADOW_MIN_ALPHA` to `SHADOW_MAX_ALPHA`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是基于 `characterSprite` 图像与 `shadowSprite` 图像之间的距离确定阴影透明度的算法。该算法首先从角色的y轴位置减去
    `CHARACTER_SHADOW_Y_DIFFERENCE` 常量。这为我们提供了当前影响阴影透明度的y值的上限。接下来，我们从y轴上的阴影起始位置减去该值，以得到当前角色与阴影的理想距离。然后，我们将该距离除以
    `SHADOW_ALPHA_HEIGHT_DIFFERENCE`，以得到约束距离到透明度的单位比率，并将该比率乘以 `SHADOW_ALPHA_DIFFERENCE`
    常量，以得到约束距离到约束透明度的单位比率。目前，我们的比率是倒置的，随着距离的增加会提高透明度，这与我们随着角色移动更远而降低透明度的目标相反，因此我们从
    `SHADOW_MAX_ALPHA` 常量中减去它，以得到随着距离增加而降低透明度的正确比率。完成算法后，我们使用 `bringToBounds()` 方法确保算法产生的透明度值被限制在
    `SHADOW_MIN_ALPHA` 到 `SHADOW_MAX_ALPHA` 的范围内。
- en: Step four sets the position of the `characterSprite` sprite when the screen
    is first touched, or if the touch is moved, by checking the touch event's `isActionDown()`
    and `isActionMove()` properties. The `setPosition()` method, in this case, simply
    sets the x value to the touched x value and the x value to the touched y value
    or the character's starting y value, whichever is greater.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步通过检查触摸事件的 `isActionDown()` 和 `isActionMove()` 属性，设置在屏幕首次触摸或触摸移动时 `characterSprite`
    精灵的位置。在这种情况下，`setPosition()` 方法简单地将x值设置为触摸的x值，将y值设置为触摸的y值或角色的起始y值，以较大者为准。
- en: 'In the final step, we load the `TextureRegions`, `characterTextureRegion`,
    and `shadowTextureRegion` objects, for the character and shadow. For more information
    on `TextureRegions`, see the *Different types of textures* recipe in [Chapter
    1](ch01.html "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*.
    Then, we create the `shadowSprite` and `characterSprite` sprites using their starting
    constants as the positions in the constructors. For `characterSprite`, we override
    the `setPosition()` method to also set the `shadowSprite` sprite''s position with
    the x offset applied and then call the `updateShadowAlpha()` method to set the
    proper alpha for the shadow after the character has moved. Finally, we attach
    the `shadowSprite` and `characterSprite` sprites to our scene and call the `updateShadowAlpha()`
    method to set the initial alpha of the shadow. The following image shows how the
    shadow''s alpha level is changed in relation to the distance from the character:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们加载 `TextureRegions`、`characterTextureRegion` 和 `shadowTextureRegion`
    对象，用于角色和阴影。关于 `TextureRegions` 的更多信息，请参见[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中的*不同类型的纹理*食谱。然后，我们使用它们的起始常量作为构造函数中的位置创建
    `shadowSprite` 和 `characterSprite` 精灵。对于 `characterSprite`，我们重写 `setPosition()`
    方法，也设置偏移x后的 `shadowSprite` 精灵的位置，然后调用 `updateShadowAlpha()` 方法，以在角色移动后为阴影设置适当的alpha值。最后，我们将
    `shadowSprite` 和 `characterSprite` 精灵附加到我们的场景中，并调用 `updateShadowAlpha()` 方法设置阴影的初始alpha值。以下图片显示了阴影的alpha级别如何相对于角色距离的变化而改变：
- en: '![How it works...](img/8987OS_10_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_10_04.jpg)'
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中了解*生命周期*。
- en: '*Different types of textures* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中了解*不同类型的纹理*。
- en: Creating a physics-based moving platform
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于物理的移动平台
- en: Most platform-style games have some sort of moving platform, which challenges
    the player to land with accurate timing. From a developer's standpoint, the platform
    is simply a physics-enabled body that moves from one location to another. In this
    recipe, we will see how to create a horizontally-moving platform.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平台风格的游戏都有某种移动平台，这挑战玩家以准确的时机着陆。从开发者的角度来看，平台只是一个从一处移动到另一处的物理启用的物体。在本教程中，我们将了解如何创建一个水平移动的平台。
- en: Getting ready...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Create a new activity class named `MovingPhysicsPlatformActivity` that extends
    `BaseGameActivity`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `MovingPhysicsPlatformActivity` 的新活动类，该类继承自 `BaseGameActivity`。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build our `MovingPhysicsPlatformActivity` activity class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的 `MovingPhysicsPlatformActivity` 活动类：
- en: 'Insert the following code snippet into our activity to make it functional:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的活动中插入以下代码段以使其功能正常：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code snippet to the `onPopulateScene()` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onPopulateScene()` 方法中添加以下代码段：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Insert the following code directly below the preceding code in the `onPopulateScene()`
    method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onPopulateScene()` 方法中的前一行代码下面直接插入以下代码：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finish the `onPopulateScene()` method and our activity by placing the following
    code after the preceding code to create a physics-enabled box that rests on the
    platform:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onPopulateScene()` 方法中完成我们的活动，通过在前一行代码之后放置以下代码来创建一个在平台上休息的物理启用的盒子：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the first step, we prepare our `MovingPhysicsPlatformActivity` class by
    inserting into it the standard, overridden `BaseGameActivity` methods that most
    AndEngine games use. For more information on setting up an activity for use with
    AndEngine, see the *Understanding the life cycle* recipe in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*. The following
    image shows how our platform moves on a single axis, in this case to the right,
    while keeping the box on top of it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们准备`MovingPhysicsPlatformActivity`类，通过向其中插入大多数AndEngine游戏使用的标准覆盖`BaseGameActivity`方法。关于如何为AndEngine设置活动的更多信息，请参见[第1章](ch01.html
    "第1章. AndEngine游戏结构")中的*了解生命周期*一节，*AndEngine游戏结构*。以下图片展示了我们的平台如何在单轴上移动，在本例中是向右移动，同时保持上面的盒子：
- en: '![How it works...](img/8987OS_10_05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_10_05.jpg)'
- en: In step two, we first create a `FixedStepPhysicsWorld` object and register it
    as an update handler with our scene. Then, we create a `Rectangle` object, named
    `platformRect`, that will represent our moving platform and place it near the
    center of the screen. Next, we set the color of the `platformRect` rectangle to
    black using the `setColor()` method with a value of `0f` for the red, green, and
    blue float parameters. We then create a fixture definition for the platform. Notice
    that the friction is set to `1f` to prevent objects on it from sliding too much
    while it is moving.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们首先创建一个`FixedStepPhysicsWorld`对象，并将其注册为场景的更新处理器。然后，我们创建一个名为`platformRect`的`Rectangle`对象，它将代表我们的移动平台，并将其放置在屏幕中心附近。接下来，我们使用`setColor()`方法将`platformRect`矩形的颜色设置为黑色，红色、绿色和蓝色的浮点参数值为`0f`。然后，我们为平台创建一个固定装置定义。注意，摩擦力设置为`1f`，以防止物体在平台移动时滑动过多。
- en: 'Next, we create the `Body` object, named `platformBody`, for the platform.
    Then, we register a `PhysicsConnector` class to connect the `platformRect` rectangle
    to the `platformBody` body. After attaching `platformRect` to our scene, we declare
    and set the variables that will control the moving platform:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为平台创建一个名为`platformBody`的`Body`对象。然后，我们注册一个`PhysicsConnector`类，将`platformRect`矩形连接到`platformBody`对象。将`platformRect`附加到我们的场景后，我们声明并设置将控制移动平台的变量：
- en: The `platformRelativeMinX` and `platformRelativeMaxX` variables represent how
    far to the left and right that the platform will move from its starting location
    in scene units.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platformRelativeMinX`和`platformRelativeMaxX`变量表示平台从其起始位置向左和向右移动的场景单位距离。'
- en: The `platformVelocity` variable represents the speed in meters per second for
    our physics platform body.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platformVelocity`变量表示我们物理平台物体的速度，单位为每秒米。'
- en: The next two variables, `platformMinXWorldCoords` and `platformMaxXWorldCoords`,
    represent the absolute position of the `platformRelativeMinX` and `platformRelativeMaxX`
    variables and are calculated from the platform's initial x position scaled by
    the default `PIXEL_TO_METER_RATIO_DEFAULT`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个变量`platformMinXWorldCoords`和`platformMaxXWorldCoords`表示`platformRelativeMinX`和`platformRelativeMaxX`变量的绝对位置，并从平台的初始x位置按默认的`PIXEL_TO_METER_RATIO_DEFAULT`比例计算得出。
- en: Finally, we set the initial velocity of our `platformBody` body to the `platformVelocity`
    variable to make the body actively mobile as soon as the scene is first drawn.
    For more information on creating physics simulations, see the *Introduction to
    the Box2D physics extension* and the *Understanding different body types* recipes
    in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"), *Applications
    of Physics*.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将`platformBody`的初始速度设置为`platformVelocity`变量，以使物体在场景首次绘制时立即主动移动。关于创建物理模拟的更多信息，请参见[第6章](ch06.html
    "第6章. 物理应用")中的*Box2D物理扩展介绍*和*了解不同的物体类型*一节。
- en: The third step registers a new `IUpdateHandler` handler with our scene. In the
    `onUpdate()` method, we test if the platform's location is beyond the absolute
    bounds that we previously defined, `platformMinXWorldCoords` and `platformMaxXWorldCoords`.
    Depending on which absolute bound is reached, we set the location of the `platformBody`
    body to the reached bound and set its velocity to move away from the boundary.
    For more information on conditional update handlers, see the *Update handlers
    and conditionals* recipe in [Chapter 7](ch07.html "Chapter 7. Working with Update
    Handlers"), *Working with Update Handlers*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步，我们向场景注册一个新的`IUpdateHandler`处理器。在`onUpdate()`方法中，我们测试平台的位置是否超出了之前定义的绝对边界`platformMinXWorldCoords`和`platformMaxXWorldCoords`。根据达到的绝对边界，我们将`platformBody`的位置设置到达到的边界，并将其速度设置为远离边界。关于条件更新处理器的更多信息，请参见[第7章](ch07.html
    "Chapter 7. Working with Update Handlers")中的*更新处理器与条件*部分。
- en: In step four, we create and attach a box body to rest on the platform. For more
    information on creating a physics-enabled box, see the *Understanding different
    body types* recipe in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"),
    *Applications of Physics*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们创建并附加一个盒子物体，使其在平台上休息。关于如何创建具有物理效果的盒子，请参考[第6章](ch06.html "Chapter 6.
    Applications of Physics")中的*了解不同的物体类型*部分。
- en: See also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "Chapter 1. AndEngine Game Structure")中了解*生命周期*。
- en: '*Introduction to the Box2D physics extension* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "Chapter 6. Applications of Physics")中查看*Box2D物理扩展介绍*。
- en: '*Understanding different body types* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "Chapter 6. Applications of Physics")中了解*不同的物体类型*。
- en: '*Update handlers and conditionals* in [Chapter 7](ch07.html "Chapter 7. Working
    with Update Handlers"), *Working with Update Handlers*.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "Chapter 7. Working with Update Handlers")中查看*更新处理器与条件*。
- en: Creating a physics-based rope bridge
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于物理的绳索桥梁
- en: With the Box2D physics extension, creating complex physics-enabled elements
    is simple. One example of such a complex element is a rope bridge that reacts
    to collisions. In this recipe, we will see how to implement a method that creates
    a rope bridge tailored to specific parameters that control the bridge's size and
    physical properties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Box2D物理扩展，创建复杂的物理效果元素很简单。一个这样的复杂元素例子就是能对碰撞做出反应的绳索桥梁。在本教程中，我们将看到如何实现一个根据特定参数创建绳索桥梁的方法，这些参数控制着桥梁的大小和物理属性。
- en: Getting ready...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Create a new activity class named `PhysicsBridgeActivity` that extends `BaseGameActivity`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`PhysicsBridgeActivity`的新活动类，该类继承自`BaseGameActivity`。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build our `PhysicsBridgeActivity` activity class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的`PhysicsBridgeActivity`活动类：
- en: 'Place the following code in our activity to give us a standard AndEngine activity:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的活动中放置以下代码，以获得标准的AndEngine活动：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, place the following, incomplete method in our activity. This method will
    facilitate the creation of our bridge:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的活动中放置以下不完整的方法。这个方法将有助于我们创建桥梁：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Insert the following code inside of the `for` loop of the `createBridge()`
    method above:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述`createBridge()`方法中的`for`循环内插入以下代码：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, add the following code inside of our `onPopulateScene()` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`onPopulateScene()`方法内添加以下代码：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In step one, we set up our `PhysicsBridgeActivity` activity class by implementing
    the standard, overridden `BaseGameActivity` methods that most AndEngine games
    use. For more information on setting up an activity for use with AndEngine, see
    the *Understanding the life cycle* recipe in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*. The following image shows what our
    physics-enabled bridge looks like with a physics-enabled square resting on it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们通过实现大多数AndEngine游戏使用的标准覆盖`BaseGameActivity`方法来设置`PhysicsBridgeActivity`活动类。关于如何为AndEngine设置活动，请参考[第1章](ch01.html
    "Chapter 1. AndEngine Game Structure")中的*了解生命周期*部分。以下图片展示了我们带有物理效果的桥梁，以及一个带有物理效果的方块在其上休息的样子：
- en: '![How it works...](img/8987OS_10_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_10_06.jpg)'
- en: In the second step, we implement the beginning of a method, named `createBridge()`,
    that will create our physics-enabled bridge. The first parameter, `pGroundBody`,
    is the ground `Body` object to which the bridge will be attached. The second parameter,
    `pLeftHingeAnchorPoint`, represents the x and y location of the upper-left side
    of the bridge. The third parameter, `pRightHingeAnchorPointX`, represents the
    x location of the right-hand side of the bridge. The next three parameters, `pNumSegments`,
    `pSegmentsWidth`, and `pSegmentsHeight`, represent how many segments the bridge
    will consist of and the width and height of each segment. The `pSegmentDensity`,
    `pSegmentElasticity`, and `pSegmentFriction` parameters will be directly passed
    to a fixture definition that will be applied to the segments of the bridge. For
    more information on fixture definitions, see the *Introduction to the Box2D physics
    extension* recipe in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"),
    *Applications of Physics*. The next two parameters, `pScene` and `pPhysicsWorld`,
    tell our method what the bridge segment rectangles and bridge segment bodies should
    be attached to. The final parameter is our `VertexBufferObjectManager` object
    and will be passed to the rectangles that represent each segment of our bridge.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们实现了一个名为`createBridge()`的方法的开头，该方法将创建具有物理效果的桥。第一个参数`pGroundBody`是桥将附加到的地面`Body`对象。第二个参数`pLeftHingeAnchorPoint`表示桥左上侧的x和y位置。第三个参数`pRightHingeAnchorPointX`表示桥右侧的x位置。接下来的三个参数`pNumSegments`、`pSegmentsWidth`和`pSegmentsHeight`表示桥将由多少个桥段组成以及每个桥段的宽度和高度。`pSegmentDensity`、`pSegmentElasticity`和`pSegmentFriction`参数将直接传递给一个夹具定义，该定义将应用于桥的桥段。有关夹具定义的更多信息，请参见[第6章](ch06.html
    "第6章. 物理应用")，*物理应用*中的*Box2D物理扩展介绍*食谱。接下来的两个参数`pScene`和`pPhysicsWorld`告诉我们的方法桥段矩形和桥段实体应该附加到什么上。最后一个参数是我们的`VertexBufferObjectManager`对象，它将被传递给表示我们桥每个段的矩形。
- en: The first two variables, `BridgeSegments` and `BridgeSegmentsBodies`, defined
    in the `createBridge()` method, are arrays that will hold the segment rectangles
    and segment bodies. They are defined to have a length passed by the `pNumSegments`
    parameter. The next variable, `BridgeSegmentFixtureDef`, is the fixture definition
    that each segment of the bridge will have. The `BridgeWidthConstant` variable
    represents the width of the bridge, calculated by finding the difference between
    the left and right anchors added to the width of a single segment of the bridge.
    The last variable, `BridgeSegmentSpacing`, represents how much space should be
    between each segment and is determined by dividing the width of the bridge by
    one more than the number of segments, and subtracting from that the half-width
    of the segments. We then create a `for` loop that will create and position the
    number of segments passed in the `pNumSegments` parameter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createBridge()`方法中定义的前两个变量，`BridgeSegments`和`BridgeSegmentsBodies`，是用于保存桥段矩形和桥段实体的数组。它们的长度由`pNumSegments`参数传递定义。下一个变量，`BridgeSegmentFixtureDef`，是每个桥段将拥有的夹具定义。`BridgeWidthConstant`变量表示桥的宽度，通过计算左侧和右侧锚点加上桥的单个桥段宽度之差得出。最后一个变量，`BridgeSegmentSpacing`，表示每个桥段之间应有的空间，通过将桥的宽度除以桥段数量加一，然后减去桥段半宽度得出。然后我们创建一个`for`循环，该循环将根据`pNumSegments`参数传递的数量创建并定位桥段。
- en: In the third step, we fill the previously created `for` loop. First, we create
    the current segment's rectangle, `BridgeSegments[i]`, that will act as the visual
    representation of the segment. We place it on the x axis using the `BridgeWidthConstant`
    variable divided by one more than the number of segments, and multiply that by
    the current segment number before adding the left hinge's x position, `pLeftHingeAnchorPoint[0]`
    and the amount of spacing between the segments, `BridgeSegmentSpacing`. For the
    y axis position of the current segment's rectangle, we place it at the left hinge's
    y position minus the segments' height divided by `2f` to make it flush with the
    hinge position.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们填充之前创建的`for`循环。首先，我们创建当前桥段的矩形`BridgeSegments[i]`，它将作为桥段的视觉表示。我们将其放置在x轴上，使用`BridgeWidthConstant`变量除以桥段数量加一，然后乘以当前桥段编号，并加上左侧铰链的x位置`pLeftHingeAnchorPoint[0]`和桥段之间的间距`BridgeSegmentSpacing`。对于当前桥段矩形的y轴位置，我们将其放置在左侧铰链的y位置减去桥段高度除以`2f`的位置，使其与铰链位置平齐。
- en: Next, we set the color of each segment to a light orange, `0.97f` red, `0.75f`
    green, and `0.54f` blue. After attaching the `Rectangle` object to the passed
    scene, we create the current segment's body by passing the segment's rectangle
    and a `BodyType` value of `Dynamic` to the standard `PhysicsFactory.CreateBoxBody()`
    method. We then set the linear damping to `1f` to smoothen the rhythmic movements
    caused by a collision. Next, we register a `PhysicsConnector` class to connect
    the current segment's rectangle to the current segment's body.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将每个段落的颜色设置为浅橙色，红色`0.97f`，绿色`0.75f`，蓝色`0.54f`。将`Rectangle`对象附加到传递的场景后，通过将段落的矩形和`BodyType`值`Dynamic`传递给标准的`PhysicsFactory.CreateBoxBody()`方法来创建当前段落的刚体。然后，我们将线性阻尼设置为`1f`，以平滑由碰撞引起的节奏性运动。接下来，我们注册一个`PhysicsConnector`类，将当前段落的矩形连接到当前段落的刚体。
- en: Now that we have established a position and created corresponding rectangles
    and bodies for each segment, we create a `RevoluteJointDef` object, `revoluteJointDef`,
    to attach each segment to the bridge via a revolute joint. We test to see if the
    current segment is the first and, if so, attach the segment to the ground `Body`
    object instead of a previous segment. For the first bridge segment, the definition
    of the `Vector2 anchorPoint` places the `RevoluteJointDef` definition's anchor
    at an x location of the segment's x value, `BridgeSegmentsBodies[i].getWorldCenter().x`,
    minus the segment spacing, `BridgeSegmentSpacing`, divided by `2`, plus the segment
    width, `pSegmentsWidth`, divided by `2`, and scaled to the `PIXEL_TO_METER_RATIO_DEFAULT`
    default. The y location of the first segment's anchor point is simply the current
    segment's y value, `BridgeSegmentsBodies[i].getWorldCenter().y`. For the remaining
    segments, the anchor point's x location is computed by averaging the x position
    of the current segment with the x position of the previous segment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经为每个段落建立了位置并创建了相应的矩形和刚体，我们创建一个`RevoluteJointDef`对象`revoluteJointDef`，通过旋转关节将每个段落连接到桥梁。我们测试当前段落是否是第一个，如果是，则将段落连接到地面`Body`对象，而不是前一个段落。对于第一个桥梁段落，`Vector2
    anchorPoint`的定义将`RevoluteJointDef`定义的锚点放置在段落的x值`BridgeSegmentsBodies[i].getWorldCenter().x`减去段落间距`BridgeSegmentSpacing`除以`2`，加上段落宽度`pSegmentsWidth`除以`2`，并缩放到`PIXEL_TO_METER_RATIO_DEFAULT`默认值的位置。第一个段落锚点的y位置简单地是当前段落的y值`BridgeSegmentsBodies[i].getWorldCenter().y`。对于其余的段落，通过计算当前段落的x位置与上一个段落的x位置的均值来确定锚点的x位置。
- en: Then, `revoluteJointDef` is initialized using the `initialize()` method with
    the first body either set to the ground body, `pGroundBody`, if the current segment
    is the first, or the previous segment's body, `BridgeSegmentsBodies[i-1]`, if
    the current segment is not the first. The second body of `revoluteJointDef` is
    set to the current segment's body, and, after exiting the `if` statement, the
    joint is created with the `pPhysicsWorld` object's `createJoint()` method. We
    then test if the current segment will be the last created and, if so, create another
    revolute joint to attach the segment to the ground body to the right-hand side
    of the segment using a similar anchor point x location formula as for the first
    segment. For more information on physics simulations, see the *Introduction to
    the Box2D physics extension* and the *Understanding different body types* recipes
    in [Chapter 6](ch06.html "Chapter 6. Applications of Physics"), *Applications
    of Physics*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`initialize()`方法初始化`revoluteJointDef`，第一个刚体设置为地面刚体`pGroundBody`，如果当前段落是第一个；如果不是第一个，则设置为前一段的刚体`BridgeSegmentsBodies[i-1]`。`revoluteJointDef`的第二个刚体设置为当前段落的刚体，并在退出`if`语句后，使用`pPhysicsWorld`对象的`createJoint()`方法创建关节。然后我们测试当前段落是否将是最后一个创建的，如果是，则使用与第一个段落相似的锚点x位置公式，在段落的右侧创建另一个旋转关节，将段落连接到地面刚体。有关物理模拟的更多信息，请参见[第6章](ch06.html
    "第6章. 物理应用")，*物理应用*中的*Box2D物理扩展介绍*和*了解不同的刚体类型*食谱。
- en: In the final step, we first create a `FixedStepPhysicsWorld` object inside of
    the `onPopulateScene()` method and register it as an update handler with our scene.
    Then, we create a ground body to which our bridge will be attached. Next, we create
    our bridge by calling the `createBridge()` method. We pass `groundBody` as the
    first parameter, a position of `0f,240f` to represent the mid-left side of the
    screen as the left anchor point, and an x position representing the right-hand
    side of the screen as the right anchor point. We then pass an integer of `16`
    as the number of segments to create and a segment width and height of `40f` and
    `10f`. Next, we pass a segment density of `4f`, a segment elasticity of `0.1f`,
    a segment friction of `0.5f`, our scene to which the segment rectangles will be
    attached, our physics world, and our `VertexBufferObjectManager` object. Now that
    our bridge is created, we create a simple box body to show that the bridge reacts
    to collisions properly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们首先在`onPopulateScene()`方法内部创建一个`FixedStepPhysicsWorld`对象，并将其注册为场景的更新处理器。然后，我们创建一个地面物体，我们的桥梁将附着在上面。接下来，我们通过调用`createBridge()`方法来创建桥梁。我们传递`groundBody`作为第一个参数，一个表示屏幕左中部的位置`0f,240f`作为左锚点，以及代表屏幕右侧的x位置作为右锚点。然后，我们传递一个整数`16`作为要创建的段数，以及一个段宽和高度为`40f`和`10f`。接下来，我们传递一个段密度`4f`，一个段弹性`0.1f`，一个段摩擦`0.5f`，我们的场景，将段矩形将附着其上，我们的物理世界，以及我们的`VertexBufferObjectManager`对象。现在我们的桥梁已经创建好了，我们创建了一个简单的盒子物体，以显示桥梁能够正确地反应碰撞。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding the life cycle* in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 AndEngine游戏结构")，*AndEngine游戏结构*中了解*生命周期*。
- en: '*Introduction to the Box2D physics extension* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章 应用物理")，*应用物理*中介绍*Box2D物理扩展*。
- en: '*Understanding different body types* in [Chapter 6](ch06.html "Chapter 6. Applications
    of Physics"), *Applications of Physics*.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章 应用物理")，*应用物理*中理解*不同的物体类型*。
