- en: Chapter 7. Physics – Falling Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 物理现象——下落物体
- en: '*There are many variations on how to incorporate a physics engine using display
    objects. So far, we have worked on removing objects with collisions, moving objects
    through the stage area, and launching objects by applying force against gravity,
    just to name a few. Now, we will explore another mechanism that allows gravity
    to control the environment. The next game we''ll create deals with falling physical
    objects.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*关于如何使用显示对象整合物理引擎，有许多不同的方法。到目前为止，我们已经研究了移除碰撞物体、通过舞台区域移动物体以及通过施加力对抗重力来发射物体等方法，仅举几例。现在，我们将探索另一种允许重力控制环境的机制。我们接下来要创建的游戏涉及下落的物理物体。*'
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Work with more physics bodies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与更多物理实体合作
- en: Customize the body construction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制身体构建
- en: Track the objects caught
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪被捕捉的物体
- en: Work with postcollisions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理碰撞后的事件
- en: Create falling objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建下落的物体
- en: Here's to creating another fun, simple game in this chapter. Let's get cracking!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，让我们再创建一个有趣简单的游戏。开始行动吧！
- en: Creating our new game – Egg Drop
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的新游戏——蛋落
- en: Every step taken so far has taught us more about game development on iOS/Android
    devices. In this new segment, our game will include sound effects, which will
    enhance the sensory experience in our games.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止的每一步都教会了我们更多关于iOS/Android设备上的游戏开发知识。在这个新的环节中，我们的游戏将包含音效，这将增强游戏中的感官体验。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that you are using the latest stable build of Corona SDK.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的是Corona SDK的最新稳定版本。
- en: The new game that we will create is called Egg Drop. The player controls the
    main character, which is a lumberjack with a frying pan. During game play, eggs
    start falling from the sky, and it is the lumberjack's job to catch the eggs in
    his frying pan and not let them hit the ground. Every egg caught earns 500 points.
    The player starts with three lives. When an egg fails to hit the frying pan and
    hits the ground, a life is lost. When all three lives are gone, the game is over.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的新游戏叫做蛋落。玩家控制主角，一个拿着平底锅的伐木工。在游戏过程中，蛋从天空中开始下落，伐木工的工作是用他的平底锅接住鸡蛋，不让它们掉到地上。每个被接住的蛋可以获得500分。玩家开始时有三个生命值。当一个蛋没有击中平底锅而是掉到地上时，就会失去一个生命值。当所有三个生命值都失去时，游戏结束。
- en: When starting the new game project, be sure to grab the `Egg` `Drop` file from
    the `Chapter` `7` folder. You can download the project files accompanying this
    book from the Packt Publishing website at [http://www.packtpub.com/](http://www.packtpub.com/).
    It contains all the necessary files that are built out for you, such as the `build.settings`,
    `config.lua`, and audio files, and the art assets needed for the game. You'll
    then have to create a brand new `main.lua` file in the project folder before you
    start coding.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新的游戏项目时，请确保从`Chapter 7`文件夹中获取`Egg` `Drop`文件。你可以从Packt Publishing网站[http://www.packtpub.com/](http://www.packtpub.com/)下载本书附带的工程文件。其中包含了为你构建的所有必要文件，比如`build.settings`、`config.lua`、音频文件以及游戏所需的艺术资源。然后你需要在项目文件夹中创建一个新的`main.lua`文件，再开始编码。
- en: '![Creating our new game – Egg Drop](img/9343OT_07_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的新游戏——蛋落](img/9343OT_07_01.jpg)'
- en: Starting variables
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始变量
- en: This will be our first full game setup, which will be filled with notable Corona
    SDK features. We'll combine our base knowledge of what we have learned so far
    with variables, display objects, the physics engine, touch/accelerometer events,
    and audio. Many of Corona's APIs are easy to use and understand. This shows the
    fast learning curve with Corona just by having basic to no knowledge of programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们第一个完整的游戏设置，其中充满了显著的Corona SDK特性。我们将把我们迄今为止学到的关于变量、显示对象、物理引擎、触摸/加速度计事件和音频的基础知识结合起来。Corona的许多API都易于使用和理解。这表明即使只有基本的编程知识甚至没有编程知识，也能快速学习Corona。
- en: Time for action – setting up the variables
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——设置变量
- en: 'Let''s get started with introducing the variables we''ll be using to create
    our game. There will be a combination of display objects and integers to keep
    count; we also need to preload the main sound effects used during game play. Follow
    the steps to declare all the required variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始介绍我们将要用来创建游戏的变量。将会有显示对象和整数的组合来进行计数；我们还需要预加载游戏过程中使用的主要音效。按照步骤声明所有必需的变量：
- en: 'Hide the status bar and add in the `display.newGroup()` group called `gameGroup`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏状态栏并在`display.newGroup()`组中添加名为`gameGroup`的组：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Include the external modules in the game:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏中包含外部模块：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add in the display objects:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加显示对象：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add in the variables:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加变量：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the egg boundaries and density:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建鸡蛋的边界和密度：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Setup the accelerometer and audio:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置加速度计和音频：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We continued creating a similar set up of our variables, like we did in the
    Panda Star Catcher game. It's more efficient to organize them by separating groups,
    display objects, audio, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续创建类似于Panda Star Catcher游戏中变量的设置。通过将它们按组别、显示对象、音频等分类组织，效率会更高。
- en: Many of the variables displayed have designated integers that fulfill the goals
    of game play. This includes values such as `gameLives` `=` `3` and `eggCount`
    `=` `0`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的许多变量都有指定的整数，以满足游戏玩法的目标。这包括像`gameLives` `=` `3`和`eggCount` `=` `0`这样的值。
- en: Controlling the main character
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制主角
- en: Accelerometer events work best within the main scope of the game. It enables
    you to view the full real estate of the game environment, without having to interact
    with touches on the screen. Necessary touch events would make sense for user interface
    buttons such as pause, menu, play, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计事件最好在游戏的主要范围内工作。它使你能够查看游戏环境的全部，而不必与屏幕上的触摸交互。必要的触摸事件对于像暂停、菜单、播放等用户界面按钮来说是有意义的。
- en: Time for action – moving the character
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——移动角色
- en: 'Eggs will be falling in all different areas of the screen from the sky. Let''s
    prepare our main character to move through all the potential areas on the screen:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 鸡蛋将从天空的不同区域掉落到屏幕上。让我们准备让主角移动到屏幕上所有潜在的区域：
- en: 'Set up a new local function called `moveChar()` with an `event` parameter:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`moveChar()`的新本地函数，并带有`event`参数：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add in the accelerometer movement for the character:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为角色添加加速度计移动：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create character boundaries where it moves on the screen. This enables the
    character to stay within the game screen and not go past the offscreen boundaries:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建角色在屏幕上移动的边界。这使得角色能够保持在游戏屏幕内，不会超出屏幕外的边界：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: To make the accelerometer movement work with a device, we have to use `yGravity`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让加速度计移动与设备一起工作，我们必须使用`yGravity`。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Accelerometer events are based on portrait scale when `xGravity` and `yGravity`
    are used accordingly. When display objects are designated for the landscape mode,
    the `xGravity` and `yGravity` values are switched to compensate for the events
    to work properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当相应地使用`xGravity`和`yGravity`时，加速度计事件基于竖屏比例。当显示对象被指定为横屏模式时，`xGravity`和`yGravity`的值会交换，以补偿事件正常工作。
- en: Notice that the code in step 3 keeps the `charObject` display object from going
    past any wall border boundaries.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第3步的代码中，防止了`charObject`显示对象越过任何墙边界。
- en: Have a go hero – adding touch events
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手英雄——添加触摸事件
- en: The character is currently controlled by the accelerometer. Another option to
    control the character is through a touch event. Try replacing the event listener
    with `"touch"` and using event parameters so that the touch event works properly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 角色目前由加速度计控制。控制角色的另一个选项是通过触摸事件。尝试将事件监听器替换为`"touch"`，并使用事件参数，以便触摸事件正常工作。
- en: If you remember how we incorporated the paddle movement with Breakout in [Chapter
    3](ch03.html "Chapter 3. Building Our First Game – Breakout"), *Building Our First
    Game – Breakout* and [Chapter 4](ch04.html "Chapter 4. Game Controls"), *Game
    Controls*, for the simulator, it should be very similar.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们在[第3章](ch03.html "第3章. 打造我们的第一款游戏 – Breakout")，*打造我们的第一款游戏 – Breakout*和[第4章](ch04.html
    "第4章. 游戏控制")，*游戏控制*中是如何将挡板移动与Breakout游戏结合在一起的，对于模拟器来说，这个过程应该非常相似。
- en: Updating the score
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新得分
- en: When the score is updated, it refers to our text display objects and translates
    the value from the number into a string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新得分时，它会引用我们的文本显示对象，并将数值转换为字符串。
- en: 'Here is an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous example, you will notice that we set a value of `100` to `gameScore`.
    In the following lines for `scoreText`, `gameScore` is used to concatenate the
    "`Score:` " string and the value of `gameScore`. Doing so displays the value of
    `gameScore` in a string format by `scoreText`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，你会注意到我们将值`100`设置给了`gameScore`。在接下来的`scoreText`行中，使用了`gameScore`来连接"`Score:`
    "字符串和`gameScore`的值。这样做可以通过`scoreText`以字符串格式显示`gameScore`的值。
- en: Time for action – setting the score
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——设置得分
- en: 'Who doesn''t like some friendly competition? We''re familiar with scoreboards
    from the games we made in the previous chapters. So, we are not strangers to tracking
    the score. Perform the following steps to set the score:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不喜欢友好的竞争呢？我们对前面章节中制作的游戏的计分板很熟悉。因此，我们对跟踪得分并不陌生。执行以下步骤来设置得分：
- en: 'Create a local function called `setScore()` with a parameter called `scoreNum`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setScore()`的局部函数，它有一个名为`scoreNum`的参数：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the variables to count the score:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置变量以计算得分：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Have the score updated when points are earned in game play and close the function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在游戏玩法中获得分数时更新得分，并关闭函数：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*What just happened?*'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: When `setScore(scoreNum)` is called within any function, it will refer to all
    the methods using the `gameScore` variable. Assuming `gameScore` `=` `0` at the
    start of the application, the value increments to what `gameScore` is set to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当在任何函数内调用`setScore(scoreNum)`时，它将引用使用`gameScore`变量的所有方法。假设在应用程序开始时`gameScore`
    `=` `0`，则该值会增加到`gameScore`设置的数量。
- en: 'In `scoreText.text` `=` `"Score: " .. gameScore`, `"Score: "` is the string
    that displays on the device during game play. The `gameScore` variable takes the
    current value given to the variable and displays it as a string.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '在`scoreText.text` `=` `"Score: " .. gameScore`中，`"Score: "`是在游戏过程中在设备上显示的字符串。`gameScore`变量获取赋予变量的当前值并将其显示为字符串。'
- en: Displaying the game environment
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示游戏环境
- en: A logical setting for your display objects helps the player envision the relationship
    between the main character and the environment. Since our main character is a
    lumberjack, it would make sense to have him set in a forest or an area focused
    entirely on nature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为显示对象设置逻辑环境可以帮助玩家想象主角与环境之间的关系。由于我们的主角是伐木工人，将他在一个森林或完全专注于自然的环境中设置是有意义的。
- en: Time for action – drawing the background
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——绘制背景
- en: 'In this section, we''ll fill the screen with our environment display objects.
    This includes our background and ground objects, and we can also add physical
    elements to our ground so that we can designate collision events for it. To draw
    the background, perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将屏幕用环境显示对象填充。这包括我们的背景和地面对象，我们还可以为地面添加物理元素，以便我们可以为其指定碰撞事件。要绘制背景，请执行以下步骤：
- en: 'Create a local function called `drawBackground()`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`drawBackground()`的局部函数：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add in the background image:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加背景图像：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add in the ground elements and create the ground physical boundary. Close the
    function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加地面元素并创建地面物理边界。关闭函数：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `background` and `ground` display objects are placed in the function called
    `drawBackground()`. The `display.newImageRect()`function is used since we are
    incorporating dynamic scaling on some of our images. The ground display object
    has a customized physical shape that is not of the same size as the original display
    object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`background`和`ground`显示对象被放置在名为`drawBackground()`的函数中。由于我们对一些图像进行了动态缩放，因此使用了`display.newImageRect()`函数。地面显示对象有一个自定义的物理形状，其大小与原始显示对象不同。'
- en: Our `background` object is centered to the dimensions of the device screen area
    and inserted in `gameGroup`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`background`对象被居中到设备屏幕区域的尺寸中，并插入到`gameGroup`。
- en: The `ground` display object is placed near the bottom of the display area. It
    is assigned a name through `ground.myName` `=` `"ground"`. We'll use the name
    `"ground"` later on to determine collision events. A customized physical boundary
    is made for the ground through `groundShape`. This allows the body of the ground
    to affect the assigned dimensions of the display object. When `physics.addBody()`
    is initialized, we used `groundShape` as the shape parameter. Next, `ground` is
    set to `gameGroup` as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ground`显示对象被放置在显示区域的底部附近。通过`ground.myName` `=` `"ground"`为其分配一个名称。我们将在后面使用名称`"ground"`来确定碰撞事件。通过`groundShape`为地面创建了一个自定义的物理边界。这使得地面的主体可以影响显示对象的指定尺寸。当初始化`physics.addBody()`时，我们使用了`groundShape`作为形状参数。接下来，将`ground`也设置为`gameGroup`。'
- en: Displaying the heads-up display
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示抬头显示器
- en: In gaming, the **heads-up** **display** (**HUD**) is the method used to relay
    information visually to the player. In many games, the common features displayed
    are health/lives, time, weapons, menus, maps, and so on. This keeps your player
    alert to what is currently happening during game play. When it comes to tracking
    your lives, you want to be informed how many are left before your character runs
    out of chances to continue playing and the game ends.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，**抬头显示**（**HUD**）是用于视觉上向玩家传递信息的方法。在许多游戏中，常见的信息包括健康/生命值、时间、武器、菜单、地图等。这使玩家在游戏过程中对当前发生的事情保持警惕。在跟踪生命值时，你希望知道在角色用完继续游戏的机会之前还剩下多少生命值。
- en: Time for action – designing the HUD
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——设计HUD
- en: 'While trying to make the player''s gaming experience an enjoyable one, it''s
    important that the information displayed is relevant to the game and placed strategically,
    so that it doesn''t interfere with the main gaming area. So, to design the HUD,
    perform the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们希望玩家的游戏体验愉快，但显示的信息必须与游戏相关，并且要策略性地放置，以免干扰主要游戏区域。因此，在设计HUD时，请执行以下步骤：
- en: 'Create a new local function called `hud()`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `hud()` 的新本地函数：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Display the text for the eggs that are caught during game play:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示在游戏过程中捕获的鸡蛋的文本：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add in text to track the lives:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加跟踪生命值的文本：
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add in text for the score and close the function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加分数的文本并关闭函数：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Time for action – designing the HUD](img/9343OT_07_02.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——设计HUD](img/9343OT_07_02.jpg)'
- en: '*What just happened?*'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'The `eggText` display object can be found near the bottom-right corner of the
    screen. It''s still in view to the user while in game play and stays out of the
    main focus at the same time. Notice that `eggText = display.newText( "Caught:
    " .. eggCount, 0, 0, "Arial", 45 )` will refer to `eggCount` when the value is
    updated.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`eggText` 显示对象可以在屏幕的右下角找到。它在游戏过程中对用户仍然可见，同时又不占据主要焦点。注意 `eggText = display.newText(
    "Caught: " .. eggCount, 0, 0, "Arial", 45 )` 将在值更新时引用 `eggCount`。'
- en: The `livesText` display object setup is similar to `eggText`. It is placed near
    the top-right corner of the screen. The placement for this object is rather prominent
    because of its importance in the game. It's in an area that is noticeable from
    the background and allows the player to refer to during the game. The `livesText`
    display object decrements the number when `gameLives` is updated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`livesText` 显示对象的设置与 `eggText` 类似。它被放置在屏幕的右上角附近。由于这个对象在游戏中非常重要，它的位置相当突出。它位于一个可以从背景中注意到并且在游戏中可以参考的区域。当
    `gameLives` 更新时，`livesText` 显示对象会减少数字。'
- en: The initial setup for `scoreText` starts in the `hud()` function. It is placed
    in the top-left corner of the screen, opposite to `livesText`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoreText` 的初始设置在 `hud()` 函数中开始。它被放置在屏幕的左上角，与 `livesText` 相对。'
- en: Creating the game lives
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏生命值
- en: If there are no consequences in a game, then there is no sense of urgency to
    complete the main objectives. To keep a player engaged during game play, introducing
    elements that add some challenging aspects will keep the competitiveness and excitement
    going. Adding consequences in a game creates tension for the player and gives
    them more motivation to stay alive.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏中没有后果，那么完成主要目标就没有紧迫感。为了保持玩家在游戏中的参与度，引入一些具有挑战性的元素将保持竞争性和兴奋感。在游戏中添加后果为玩家创造紧张感，并给他们更多保持生存的动力。
- en: Time for action – counting the lives
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——计算生命值
- en: 'Tracking the lives left in the game keeps the player updated on how much sooner
    it will be till the game is over. To count the remaining lives in the game, perform
    the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪游戏中的剩余生命值，让玩家了解游戏结束还有多久。为了计算游戏中剩余的生命值，请执行以下步骤：
- en: 'Set up the function called `livesCount()`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个名为 `livesCount()` 的函数：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Display the text for lives every time the number is decremented:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次生命值减少时，显示生命值的文本：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*What just happened?*'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `livesCount()` function is a separate function that updates `gameLives`.
    It makes sure that you're aware that `gameLives = gameLives – 1`. This decreases
    the set value instantiated in the beginning of the code. When `gameLives` changes
    values, it displays the update through `livesText`. The `print` statement is used
    towards the end of the function to track the count in the terminal window.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`livesCount()`函数是一个单独的函数，用于更新`gameLives`。它确保你注意到`gameLives = gameLives – 1`。这减少了代码开始时实例化的设定值。当`gameLives`的值发生变化时，它通过`livesText`显示更新。在函数末尾使用`print`语句，在终端窗口中跟踪计数。'
- en: When `gameLives < 1`, the `callGameOver()` function will be called and show
    the game over element of the game.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当`gameLives < 1`时，将调用`callGameOver()`函数，并显示游戏结束元素。
- en: Have a go hero – adding images for the game lives
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手试试看——为游戏生命值添加图像
- en: Currently, the game uses display text on screen to show how many lives are left
    during game play. A way to make the HUD display more appealing is by creating/adding
    small icons that correlate with the game, such as eggs or a frying pan.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，游戏在屏幕上使用显示文本来显示游戏进行期间还剩下多少生命值。使HUD显示更具吸引力的方法之一是创建/添加与游戏相关的小图标，例如鸡蛋或煎锅。
- en: Three separate display objects need to be created and placed in an orderly fashion
    so that when a life is taken away, the alpha of the object is reduced to 0.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建三个独立的显示对象，并有序地放置，以便当生命值被扣除时，对象的透明度降低到0.5。
- en: A method needs to be created so that all the three display objects are affected
    when the game lives are reduced to zero.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个方法，以便当游戏生命值降至零时，所有三个显示对象都会受到影响。
- en: Introducing the main character
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍主角
- en: Our main character will be animated for every action applied during game play.
    We will also create a complex body construction since the focus of its collision
    points will be on the object the character is holding, and not on their entire
    body.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主角将在游戏过程中对每个应用的动作进行动画处理。我们还将创建一个复杂的身体构造，因为其碰撞点的焦点将放在角色持有的物体上，而不是整个身体。
- en: Complex body construction
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂身体构造
- en: It is also possible to construct a body from multiple elements. Each body element
    is specified as a separate polygon shape with its own physical properties.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以从多个元素构建身体。每个身体元素都是一个单独的多边形形状，具有自己的物理属性。
- en: Since collision polygons in Box2D must be convex, any game object with a concave
    shape must be constructed by appending multiple body elements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Box2D中的碰撞多边形必须是凸面，因此任何具有凹形状的游戏对象都必须通过附加多个身体元素来构建。
- en: 'The constructor for a complex body is the same as the simple polygon body constructor,
    except that it has more than one body element listed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂身体的构造函数与简单多边形身体的构造函数相同，不同之处在于它有不止一个身体元素列表：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Each body element may have its own physical properties, along with a shape
    definition for its collision boundaries. Here is an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个身体元素可能都有自己的物理属性，以及其碰撞边界的形状定义。以下是一个示例：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As in the simpler cases, the `bodyType` attribute is optional and will default
    to `"dynamic",` if not specified.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与更简单的情况一样，`bodyType`属性是可选的，如果没有指定，将默认为`"dynamic"`。
- en: Time for action – creating the character
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——创建角色
- en: 'The main character was created with a sprite sheet and needs to be set up to
    view the animation it provides. Other display images that will make an appearance
    include a cracked egg when a collision to a physical object has been made. To
    create the character, perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 主角是用一个精灵表创建的，需要设置以查看它提供的动画。其他将出现的显示图像包括当与物理对象发生碰撞时出现的破裂鸡蛋。要创建角色，请执行以下步骤：
- en: 'Create a new local function called `createChar()`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`createChar()`的新局部函数：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the sprite sheet for the main character:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为主角创建精灵表：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set the starting position and physical properties for the main character:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置主角的起始位置和物理属性：
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add in the transition image after the egg has made a collision:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在鸡蛋发生碰撞后添加过渡图像：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Time for action – creating the character](img/9343OT_07_03.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手操作——创建角色](img/9343OT_07_03.jpg)'
- en: '*What just happened?*'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The image sheet being referred to is called `sheetData` and takes the first
    `4` frames of animation from `"charSprite.png"`. We created an animation set called
    `"move"`. Every time `"move"` is called, it starts the animation from frame `1`
    and plays `4` frames from the start at `400` milliseconds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所引用的图像集被称为`sheetData`，它从`"charSprite.png"`中获取前`4`帧动画。我们创建了一个名为`"move"`的动画集。每次调用`"move"`时，都会从第`1`帧开始播放，每`400`毫秒播放从开始的前`4`帧。
- en: The main display object is called `charObject` and takes on the characteristics
    of `sheetData`. When it calls `setSequence("move")`, that animation sequence plays
    when the `play()` command is executed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 主显示对象称为`charObject`，它具有`sheetData`的特征。当它调用`setSequence("move")`时，执行`play()`命令时会播放该动画序列。
- en: An important change to the physical body of the character is that its main collision
    point will be directed towards the frying pan used in the animation. Any collision
    detection on the character's body will not be read. The `charObject` display object
    is given a name called `"character"`, which will be used to detect the collision
    with the falling egg.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对角色物理身体的一个重要更改是，它的主要碰撞点将指向动画中使用的煎锅。角色身体上的任何碰撞检测都不会被读取。`charObject`显示对象被赋予一个名为`"character"`的名字，这将用于检测与掉落鸡蛋的碰撞。
- en: We have also placed the fried egg in this function, to prepare it for the collision.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这个函数中放置了煎蛋，为碰撞做准备。
- en: Adding postcollisions
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加后碰撞
- en: We want to make sure that when an object has interacted with another, an event
    type occurs right after. At the instance of a postcollision, we can confirm the
    collision force between two objects. This helps us determine that the object that
    was destroyed was completed with a set amount of force.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要确保当一个对象与另一个对象交互后，紧接着就会发生一个事件类型。在碰撞后的瞬间，我们可以确认两个对象之间的碰撞力。这有助于我们确定被销毁的对象是受到一定力量的完全撞击。
- en: Collision handling
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞处理
- en: Be careful about how you handle the Box2D physics engine. It will crash during
    a collision if Corona code attempts to modify objects still involved in the collision,
    since Box2D is still working out iterated mathematics on them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意您处理 Box2D 物理引擎的方式。如果 Corona 代码在碰撞过程中尝试修改仍在碰撞中的对象，Box2D 将会崩溃，因为 Box2D 仍在对它们进行迭代数学计算。
- en: For crash-proof collision detection, do not have collisions occur immediately.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止碰撞检测时立即发生崩溃，不要让碰撞立即发生。
- en: Do not modify/create/destroy physics objects during a collision, in order to
    prevent crashing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在碰撞过程中，请勿修改/创建/销毁物理对象，以防止程序崩溃。
- en: If you need to modify/create/destroy an object as a result of a collision, your
    collision handler should set a flag or add a time delay so that the change can
    occur later, with `timer.performWithDelay()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在碰撞后修改/创建/销毁一个对象，您的碰撞处理程序应设置一个标志或添加一个时间延迟，以便稍后使用`timer.performWithDelay()`进行更改。
- en: Body properties
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚体属性
- en: Many of the native Box2D methods have been made into simpler dot properties
    for display objects. The following examples show that a body, `newBody`, has been
    created using one of the constructor methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 许多原生的 Box2D 方法已经被简化为显示对象的点属性。以下示例显示，一个名为`newBody`的刚体是使用其中一个构造方法创建的。
- en: body.isAwake
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.isAwake
- en: This is a Boolean for the current awake state. By default, all bodies automatically
    *go* *to* *sleep* when there is no interaction with them for a couple of seconds.
    Bodies stop simulating until some kind of collision or other interaction wakes
    them up.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示当前唤醒状态的布尔值。默认情况下，当所有刚体在几秒钟内没有交互时，它们会自动*进入* *休眠*状态。刚体停止模拟，直到某种碰撞或其他交互唤醒它们。
- en: 'Here is an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: body.isBodyActive
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.isBodyActive
- en: This is a Boolean for the active state of a body. Inactive bodies are not destroyed,
    but they are removed from the simulation and cease to interact with other bodies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示刚体激活状态的布尔值。非激活状态的刚体不会被销毁，但它们会从模拟中移除，并停止与其他刚体的交互。
- en: 'Here is an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: body.isBullet
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.isBullet
- en: This is a Boolean for a body that is treated like a *bullet*. Bullets are subject
    to continuous collision detection. The default is `false`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将刚体视为*子弹*的布尔值。子弹将受到连续碰撞检测。默认值为`false`。
- en: 'Here is an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: body.isSensor
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.isSensor
- en: This is a Boolean property that sets the `isSensor` property across all elements
    in the body. A sensor passes through other objects instead of bouncing off them,
    but detects some collision. This property acts across all body elements and will
    override any `isSensor` settings on the elements themselves.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔属性，用于设置整个物体中的`isSensor`属性。传感器可以穿过其他物体而不是反弹，但能检测到一些碰撞。这个属性作用于所有物体元素，并将覆盖元素本身的任何`isSensor`设置。
- en: 'Here is an example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: body.isSleepingAllowed
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.isSleepingAllowed
- en: This is a Boolean for a body that is allowed to go to sleep. A body that is
    awake is useful in cases such as tilt gravity, since sleeping bodies do not respond
    to changes in global gravity. The default is `true`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔值，用于设置一个物体是否允许进入休眠状态。醒着的物体在比如倾斜重力的情况下很有用，因为休眠的物体不会对全球重力变化做出反应。默认值为`true`。
- en: 'Here is an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: body.isFixedRotation
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.isFixedRotation
- en: This is a Boolean for a body whose rotation should be locked, even if the body
    is about to load or subjected to off-center forces. The default is `false`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔值，用于设置一个物体的旋转是否应该被锁定，即使物体即将加载或受到偏心力的作用。默认值为`false`。
- en: 'Here is an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: body.angularVelocity
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.angularVelocity
- en: This is the value of the current rotational velocity in degrees per second.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前旋转速度的值，单位为每秒度数。
- en: 'Here is an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: body.linearDamping
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.linearDamping
- en: This is the value for how much the linear motion of a body is damped. This is
    the rate of decrease of angular velocity over time. The default is zero.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于控制物体线性运动阻尼的值。这是角速度随时间减少的速率。默认值为零。
- en: 'Here is an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: body.angularDamping
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.angularDamping
- en: This is the value for how much the rotation of a body should be damped. The
    default is zero.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于控制物体旋转阻尼的值。默认值为零。
- en: 'Here is an example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: body.bodyType
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: body.bodyType
- en: 'This is a string value for the type of physical body being simulated. The available
    values are `"static"`, `"dynamic"`, and `"kinematic"`, which are explained here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串值，用于设置模拟的物理物体的类型。可用的值有`"static"`、`"dynamic"`和`"kinematic"`，具体解释如下：
- en: '`static` bodies don''t move or interact with each other. Examples of static
    objects would include the ground or the walls of a maze.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`（静止）物体不会移动也不会相互影响。静止物体的例子包括地面或迷宫的墙壁。'
- en: '`dynamic` bodies are affected by gravity and collisions with other body types.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic`（动态）物体受重力影响，也会与其他类型的物体发生碰撞。'
- en: '`kinematic` objects are affected by forces but not by gravity. Bodies that
    are draggable objects should be set to `"kinematic"` for the duration of the drag
    event.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kinematic`（运动学）物体受力影响但不受重力影响。那些可拖动的物体在拖动事件期间应该被设置为`"kinematic"`。'
- en: The default body type is `"dynamic"`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的物体类型是`"dynamic"`。
- en: 'Here is an example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Time for action – creating the egg collision
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建鸡蛋碰撞
- en: 'We have handled collisions in the previous sample games we created. Handling
    postcollisions requires the introduction of force to execute the completion of
    a postcollision event:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的示例游戏中已经处理过碰撞。处理碰撞后的事件需要引入力来完成碰撞后的动作：
- en: 'Create a new local function called `onEggCollision()` with two parameters called
    `self` and `event`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`onEggCollision()`的新局部函数，它有两个参数，分别名为`self`和`event`：
- en: '[PRE38]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create an `if` statement when the force is greater than `1` and include `not`
    `self.isHit`. Add in the `eggCaughtSound` sound effect:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当力大于`1`时创建一个`if`语句，并包含`not` `self.isHit`。加入`eggCaughtSound`音效：
- en: '[PRE39]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make `self` invisible and inactive, and replace it with the `friedEgg` display
    object:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`self`变得不可见且不活跃，并用`friedEgg`显示对象替换它：
- en: '[PRE40]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a function that transitions the `friedEgg` display object and fades
    it off the stage by using the `onComplete` command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，通过使用`onComplete`命令将`friedEgg`显示对象过渡并使其在舞台上淡出：
- en: '[PRE41]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using `if` `event.other.myName == "character"`, update `eggCount` when the
    main character catches the eggs. Also, update `gameScore` by `500` points for
    every collision. If the egg hits the ground, use `elseif event.other.myName ==
    "ground"` and decrement the lives using `livesCount()`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if event.other.myName == "character"`，当主角接住鸡蛋时更新`eggCount`。并且，每次碰撞增加`gameScore`
    `500`分。如果鸡蛋掉到地上，使用`elseif event.other.myName == "ground"`并通过`livesCount()`减少生命值：
- en: '[PRE42]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Time for action – creating the egg collision](img/9343OT_07_04.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——创建鸡蛋碰撞](img/9343OT_07_04.jpg)'
- en: '*What just happened?*'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Using `onEggCollision( self, event )`, we set up the function with an `if` statement
    for `event.force > 1 and not self.isHit`. When both statements return `true`,
    the sound effect for the egg plays. The initial egg falling from the sky is removed
    from the scene upon collision and replaced by the `friedEgg` display object in
    the same location, using `friedEgg.x = self.x; friedEgg.y = self.y`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `onEggCollision( self, event )` 函数，我们通过 `if` 语句设置条件为 `event.force > 1` 且
    `not self.isHit`。当两个语句都返回 `true` 时，播放鸡蛋的声音效果。碰撞发生后，从天空中落下的初始鸡蛋从场景中移除，并在同一位置使用
    `friedEgg` 显示对象替换，通过 `friedEgg.x = self.x; friedEgg.y = self.y` 实现。
- en: The `fadeEgg()`function makes the newly replaced egg object appear in `50` milliseconds
    by `transition.to( eggCrack, { time=50, alpha=1.0, onComplete=fadeCrack } )` and
    then with the `onComplete` command, it returns the object to an invisible state
    with `transition.to( eggCrack, { time=500, alpha=0 } )`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`fadeEgg()` 函数通过 `transition.to( eggCrack, { time=50, alpha=1.0, onComplete=fadeCrack
    } )` 在 `50` 毫秒内使新替换的鸡蛋对象出现，然后通过 `onComplete` 命令，使用 `transition.to( eggCrack, {
    time=500, alpha=0 } )` 将对象返回到不可见状态。'
- en: When the name `"character"` is called from `event.other.myName`, every collision
    assigned to that name increments `eggCount + 1`. Therefore, `eggText` is updated
    with the `eggCount` value. The `setScore( newScore )` statement increments the
    score by `500` with every collision made to `"character"`. When a collision is
    made to `"ground"`, the `livesCount()` function is called, which subtracts life
    by `1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `event.other.myName` 调用 `"character"` 名称时，分配给该名称的每次碰撞都会使 `eggCount + 1`。因此，`eggText`
    使用 `eggCount` 的值进行更新。`setScore( newScore )` 语句在每次与 `"character"` 发生碰撞时将分数增加 `500`。当与
    `"ground"` 发生碰撞时，调用 `livesCount()` 函数，该函数将生命值减去 `1`。
- en: Making the display objects fall
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使显示对象下落
- en: We will apply the main asset (egg object) by learning how to add physical objects
    to the scene and have them fall in random areas in the game. The physics engine
    will take into account a dynamic physics body that we will create for the egg
    display object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习如何将物理对象添加到场景中，并让它们在游戏中的随机区域下落，来应用主要资源（鸡蛋对象）。物理引擎将考虑我们为鸡蛋显示对象创建的动态物理体。
- en: Time for action – adding the egg object
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加鸡蛋对象
- en: 'Imagine a world, full of falling eggs. It''s not entirely too realistic, but
    in this game, we''re creating this element. At least, we''ll be making sure that
    both gravity and real-world physics will be applied. To add the egg object, perform
    the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个充满下落鸡蛋的世界。这并不完全现实，但在这个游戏中，我们将创建这个元素。至少，我们将确保重力和现实世界物理被应用。要添加鸡蛋对象，请执行以下步骤：
- en: 'Create a new local function called `eggDrop()`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `eggDrop()` 的新本地函数：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add in the `egg` display object properties:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `egg` 显示对象的属性：
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add in the `postCollision` event for the `egg` display object:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `egg` 显示对象添加 `postCollision` 事件：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Time for action – adding the egg object](img/9343OT_07_05.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——添加鸡蛋对象](img/9343OT_07_05.jpg)'
- en: '*What just happened?*'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have set the `egg` value for `x` with `240 + mRand( 120 )`. The `mRand` function
    is equal to `math.random`, which will allow the egg to appear in randomized places
    in an area of `120` pixels, starting at 50 in the *x* direction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `240 + mRand( 120 )` 设置了 `egg` 的 `x` 值。`mRand` 函数等于 `math.random`，这将允许鸡蛋在从
    *x* 方向的 50 开始的 `120` 像素区域内随机位置出现。
- en: It is vital to make sure that `egg.isHit = false` for the collision event to
    apply correctly. The physics body is set to `"dynamic"` so that it reacts to gravity
    and makes the object fall. There is a customized density and shape made for the
    egg we have created, which was already made at the beginning of the code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在碰撞事件正确应用时 `egg.isHit = false` 是至关重要的。物理体设置为 `"dynamic"` 以便它对重力作出反应并使对象下落。我们创建的鸡蛋有一个自定义的密度和形状，这在代码开始时就已经设置好了。
- en: The last important detail for the collision to work is adding `egg` to the `onEggCollision()`
    function with `egg.postCollision = onEggCollision` and then making the event listener
    use the `"postCollision"` event with `egg:addEventListener( "postCollision", egg
    )`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让碰撞生效，最后一个重要的细节是使用 `egg.postCollision = onEggCollision` 将 `egg` 对象添加到 `onEggCollision()`
    函数中，然后让事件监听器通过 `egg:addEventListener( "postCollision", egg )` 使用 `"postCollision"`
    事件。
- en: Time for action – making the egg drop
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使鸡蛋降落
- en: 'We''re going to execute the timer for the eggs, so that they can start dropping
    on the screen. To make the egg drop, perform the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行鸡蛋的计时器，以便它们可以开始在屏幕上降落。要使鸡蛋降落，请执行以下步骤：
- en: 'Create a local function called `eggTimer()` and use `timer.performWithDelay`
    to drop an egg every 1 second (`1000` milliseconds) repeatedly. Use `eggDrop()`
    to activate the drop:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`eggTimer()`的局部函数，并使用`timer.performWithDelay`每1秒（1000毫秒）重复投放一个鸡蛋。使用`eggDrop()`来激活下落：
- en: '[PRE46]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Within the first `if` statement in the `onEggCollision()` function, cancel
    the timer using the `timerID` and `startDrop` variables. Add the `if` `gameLives
    < 1` statement then to stop the eggs from falling:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onEggCollision()`函数的第一个`if`语句内，使用`timerID`和`startDrop`变量取消计时器。然后添加`if gameLives
    < 1`语句以停止鸡蛋下落：
- en: '[PRE47]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*What just happened?*'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In order for the eggs to start dropping from the sky, we created a function
    called `eggTimer()`. It activates the `eggDrop()` function by letting an egg drop
    after `1000` milliseconds (1 second) every time infinitely using `startDrop =
    timer.performWithDelay( 1000, eggDrop, 0 )`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让鸡蛋从天空中开始下落，我们创建了一个名为`eggTimer()`的函数。它通过`startDrop = timer.performWithDelay(
    1000, eggDrop, 0 )`每隔1000毫秒（1秒）无限次地激活`eggDrop()`函数，让一个鸡蛋下落。
- en: Backtracking to `onEggCollision()`, we want to check whether `gameLives` has
    reached less than `1`. When this statement is true, the eggs will stop dropping.
    This is done using `timer.cancel( startDrop )`. The `timerID` we set in `eggTimer()`
    is `startDrop`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`onEggCollision()`，我们要检查`gameLives`是否已经小于`1`。当这个语句为真时，鸡蛋将停止下落。这是通过`timer.cancel(
    startDrop )`实现的。我们在`eggTimer()`中设置的`timerID`就是`startDrop`。
- en: Ending the game play
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束游戏玩法
- en: Every start of a game always has an ending, whether it is a simple *You* *Win*
    or *You* *Lose* or just a *Game* *Over*; all these give closure to the player.
    It's important to notify a player of such events, so that they can reflect on
    the achievements earned.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏的开始总有一个结局，无论是简单的*胜利*或*失败*，还是仅仅是一个*游戏结束*；所有这些都给玩家一个结束感。通知玩家这些事件很重要，这样他们才能反思所获得的成就。
- en: Time for action – calling game over
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——调用游戏结束
- en: 'We will make sure that when a game over display screen pops up, any of our
    display objects that are currently in motion stop moving, and the event listeners
    are deactivated. Aside from the visual display of our game over screen, we''ll
    be adding a sound notification that will also help to trigger the event. To end
    the game, perform the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将确保当游戏结束显示屏幕弹出时，当前正在移动的任何显示对象停止移动，并且事件监听器被停用。除了我们的游戏结束屏幕的视觉显示外，我们还将添加一个声音通知，这将帮助触发事件。要结束游戏，请执行以下步骤：
- en: 'Create a new local function called `callGameOver()` and place it after the
    `setScore()` function and before the `drawBackground()` function:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`callGameOver()`的新局部函数，并将其放在`setScore()`函数之后，`drawBackground()`函数之前：
- en: '[PRE48]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Introduce the sound effects when the game over display pops up. Have `gameIsActive`
    set to `false` and pause the physics in the game:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏结束显示弹窗时引入声音效果。将`gameIsActive`设置为`false`并在游戏中暂停物理效果：
- en: '[PRE49]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a shade that overlays the current background:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个覆盖当前背景的阴影：
- en: '[PRE50]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Display the game over window and reiterate the final score:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示游戏结束窗口并重申最终得分：
- en: '[PRE51]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Have the score display on the game over screen:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏结束屏幕上显示得分：
- en: '[PRE52]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Time for action – calling game over](img/9343OT_07_06.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——调用游戏结束](img/9343OT_07_06.jpg)'
- en: '*What just happened?*'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Our `gameOver()` function triggers our `gameOverSound` sound effect that we
    preloaded at the beginning of our code. We made sure no events, such as the motion
    from the accelerometer, are disabled through `gameIsActive = false`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`gameOver()`函数触发了我们在代码开始时预加载的`gameOverSound`声音效果。我们确保通过`gameIsActive = false`禁用任何事件，比如加速度计的运动。
- en: The elements of our display objects appear at this point in time with `shade`,
    `gameOverScreen`, and `scoreText`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们的显示对象元素会出现在`shade`、`gameOverScreen`和`scoreText`中。
- en: If you notice, `scoreText` disappears when game play has ended by `scoreText.isVisible
    = false` and then reappears in a different area of the screen, using `timer.performWithDelay(
    0, function() scoreText.isVisible = true; end, 1 )`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，当游戏玩法结束时，`scoreText`通过`scoreText.isVisible = false`消失，然后在屏幕的另一区域使用`timer.performWithDelay(
    0, function() scoreText.isVisible = true; end, 1 )`重新出现。
- en: Starting the game
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始游戏
- en: We will activate all the remaining functions and have them run accordingly.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将激活所有剩余的函数，并让它们相应地运行。
- en: Time for action – activating the game
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——激活游戏
- en: 'With all the game play elements set in place, it is time to get the application
    started by using the following steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所有游戏玩法元素设置好后，是时候通过以下步骤启动应用程序了：
- en: 'Create a new local function called `gameActivate()` and insert `gameIsActive
    = true`. Place the function above the `moveChar()` function:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`gameActivate()`的新局部函数，并插入`gameIsActive = true`。将此函数放在`moveChar()`函数上方：
- en: '[PRE53]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Initialize all the game actions by making a new function called `gameStart()`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`gameStart()`的新函数来初始化所有游戏动作：
- en: '[PRE54]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Start the physics property and set the gravity for the falling object:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动物理属性并为下落物体设置重力：
- en: '[PRE55]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Activate all the functions instantiated. Add an event listener for the `charObject`,
    using the `"accelerometer"` event for the `moveChar()` function:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活所有实例化的函数。为`charObject`添加事件监听器，使用`"accelerometer"`事件监听`moveChar()`函数：
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Instantiate the `gameStart()` function and return the `gameGroup` group:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`gameStart()`函数并返回`gameGroup`组：
- en: '[PRE57]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*What just happened?*'
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: If you remember, in the beginning of our code, we set `gameIsActive = false`.
    We will now change this status through the `gameActivate()` function and make
    `gameIsActive = true`. We made the `gameStart()` function apply all the initial
    game play elements. This includes the start of the physics engine and gravity.
    At the same time, we took the remainder of all the functions and initialized them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在我们的代码开始时，我们设置了`gameIsActive = false`。现在我们将通过`gameActivate()`函数改变这个状态，使`gameIsActive
    = true`。我们让`gameStart()`函数应用所有初始游戏元素。这包括物理引擎和重力的启动。同时，我们取所有函数的余数并初始化它们。
- en: Once all the functions are activated, `gameGroup` needs to be returned so that
    all the display objects appear during the game play.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有函数被激活，需要返回`gameGroup`，以便在游戏进行时显示所有显示对象。
- en: To make sure that your physical object boundaries for your display objects are
    in the right place, use `physics.setDrawMode( "hybrid" )` in the `gameStart()`
    function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的显示对象的物理对象边界位于正确位置，在`gameStart()`函数中使用`physics.setDrawMode( "hybrid" )`。
- en: Pop quiz – animating the graphics
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验 - 动画图形
- en: Q1\. What retrieves or sets the text string of a text object?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1. 什么可以检索或设置文本对象的文本字符串？
- en: '`object.text`'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object.text`'
- en: '`object.size`'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object.size`'
- en: '`object:setTextColor()`'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`object:setTextColor()`'
- en: None of the above
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Q2\. What function converts any argument into a string?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2. 什么函数将任何参数转换成字符串？
- en: '`tonumber()`'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tonumber()`'
- en: '`print()`'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print()`'
- en: '`tostring()`'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tostring()`'
- en: '`nil`'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nil`'
- en: Q3\. What body type is affected by gravity and collisions with the other body
    types?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 问题3. 哪种体型受到重力和与其他体型碰撞的影响？
- en: dynamic
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态
- en: kinematic
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动力学
- en: static
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态
- en: None of the above
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The game play construction of our application is now completed. Now that we're
    familiar with a variety of ways to use the physics engine, it goes to show the
    ease of using Box2D for designing other games that involve physics bodies.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的游戏玩法构建现在已完成。现在我们熟悉了使用物理引擎的各种方式，这表明使用Box2D设计涉及物理体的其他游戏是多么容易。
- en: 'We now have a better idea of:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对以下内容有了更好的了解：
- en: Applying the uses of dynamic and static physics bodies
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用动态和静态物理体的使用
- en: Constructing a customized shape for the physical properties of our display objects
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的显示对象的物理属性构建自定义形状
- en: Tracking the number of objects caught using values from variables that are given
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定变量的值跟踪捕获的对象数量
- en: Using postcollisions to switch out images
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后碰撞来切换图像
- en: In the next chapter, we will complete the gaming experience by creating versatile
    menu screens by using the Composer API. You will also learn how to add the pause
    action, save high scores, and understand more about data saving and unloading
    files.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用Composer API创建多功能菜单屏幕来完成游戏体验。你还将学习如何添加暂停动作，保存高分以及了解有关数据保存和卸载文件更多信息。
- en: Using Corona SDK has helped us design and develop games in a minimal amount
    of time. Let's continue adding the final touches to our game!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Corona SDK帮助我们以最少的时间设计和开发游戏。让我们继续为我们的游戏添加最后的润色！
