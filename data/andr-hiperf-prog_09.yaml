- en: Chapter 9. Native Coding in Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. Android中的本地编码
- en: The **Native Development Kit** (from now on, **NDK**) is a toolset provided
    by Google to allow developers using native code languages (typically, C and C++)
    on the application. This can allow us to perform tasks that are computationally
    intense with a more optimized language, or to access third-party libraries to
    better operate in some tasks (for example, we could use OpenCV to access and operate
    with images, instead of the native and not very efficient Java API).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地开发工具包**（从现在开始，**NDK**）是谷歌提供的一套工具，允许开发者使用本地代码语言（通常是C和C++）在应用程序上。这可以让我们使用更优化的语言执行计算密集型任务，或者访问第三方库以更好地执行某些任务（例如，我们可以使用OpenCV来访问和操作图像，而不是本地效率不高的Java
    API）。'
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The NDK can be a powerful tool, but we advise the reader to evaluate whether
    it will add a benefit to your project. In many cases, NDK is not required, and
    a developer should never choose the toolset just because he/she feels more comfortable
    using it. Besides, using NDK will certainly add complexity to our project in terms
    of the structure and files to be handled.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NDK可能是一个强大的工具，但我们建议读者评估它是否会为你的项目带来好处。在许多情况下，并不需要NDK，开发者不应仅仅因为自己更熟悉就选择这个工具集。此外，使用NDK无疑会增加我们项目在结构和需要处理的文件方面的复杂性。
- en: 'Using NDK in Android can certainly bring benefits, but some pitfalls must be
    considered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中使用NDK确实能带来好处，但也必须考虑一些陷阱：
- en: Code complexity increases. In addition to our Java (or Kotlin, or the language
    of choice) framework, now we have another language that needs to be debugged.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂性增加。除了我们的Java（或Kotlin，或选择的任何语言）框架外，现在我们还需要调试另一种语言。
- en: There is no more automatic garbage collector when NDK is being used. The responsibility
    of performing all the memory management is now entirely reliant on the native
    code.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NDK时不再有自动垃圾收集器。执行所有内存管理的责任现在完全依赖于本地代码。
- en: If we are developing Java code that needs to be at some point ported into other
    platforms, this will be harder with NDK. One solution being used is to compile
    the files into all the possible operating systems, and then choose them depending
    on compilation time. As you might imagine, this increases the complexity of our
    code dramatically.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们开发的Java代码需要移植到其他平台，使用NDK将更加困难。正在使用的一个解决方案是将文件编译到所有可能的操作系统，然后在编译时选择它们。可以想象，这大大增加了我们代码的复杂性。
- en: Getting started – setting up NDK in our system
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门——在系统中设置NDK
- en: Android Studio supports, from version 1.3 RC1, the Native Development Kit. Although
    still limited, it is still functional and will provide most of its users enough
    features and stability to carry on using it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从1.3 RC1版本开始，Android Studio支持本地开发工具包（NDK）。尽管仍然有限制，但它仍然可用，并将为大多数用户提供足够的功能和稳定性以继续使用。
- en: To set up NDK, we first need to download it into our system. At the time of
    writing this book, the latest version of NDK can be downloaded from [http://developer.android.com/ndk/downloads/index.html](http://developer.android.com/ndk/downloads/index.html).
    If a prospective reader cannot find NDK in this location, we encourage them to
    search Google for the location of its latest version.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置NDK，我们首先需要将其下载到我们的系统中。在撰写本书时，最新版本的NDK可以从[http://developer.android.com/ndk/downloads/index.html](http://developer.android.com/ndk/downloads/index.html)下载。如果潜在读者在这个位置找不到NDK，我们鼓励他们通过Google搜索其最新版本的位置。
- en: 'When NDK has been downloaded, uncompress the ZIP file and move it to a location
    of your choice. The folder will contain something similar to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完NDK后，解压ZIP文件并将其移动到你选择的位置。该文件夹将包含类似于以下内容的东西：
- en: '![Getting started – setting up NDK in our system](img/4666_09_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![入门——在系统中设置NDK](img/4666_09_01.jpg)'
- en: 'Each package here contains some different data files:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的每个包都包含一些不同的数据文件：
- en: The `build` folder contains all the tools and packages that are necessary to
    actually build with the NDK toolset.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`文件夹包含使用NDK工具集实际构建所需的所有工具和包。'
- en: The `ndk-build` is the script we will call to use NDK.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndk-build`是我们将调用来使用NDK的脚本。'
- en: '`platforms` include the required tools that we will use for each different
    version of the Android SDK.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platforms`包含我们将用于每个不同版本的Android SDK的必要工具。'
- en: '`python-packages` includes the source in Python scripts.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-packages`包含Python脚本中的源代码。'
- en: The `sources` folder includes the source files.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sources`文件夹包含源文件。'
- en: In `toolchains`, we will find the toolchains required to build already existing
    programs. More on this later in this chapter.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `toolchains` 中，我们将找到构建现有程序所需的工具链。关于这方面的更多信息将在本章后面介绍。
- en: It is generally recommended to add the location of the NDK folder to the `PATH`
    environmental variable, so it can be easily accessed later on. This can be done
    easily, depending on the operating system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议将NDK文件夹的位置添加到 `PATH` 环境变量中，以便稍后可以轻松访问。根据操作系统，这可以轻松完成。
- en: 'On Mac, type `sudo nano /etc/paths` in the console. You will see something
    similar to what appears in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，在控制台中输入 `sudo nano /etc/paths`。你会看到类似于下面截图所示的内容：
- en: '![Getting started – setting up NDK in our system](img/4666_09_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![入门——在我们的系统中设置NDK](img/4666_09_02.jpg)'
- en: You need to add to this screen the location where NDK has been downloaded. After
    adding it, close the console and open it again. If you type `echo $PATH`, the
    content of the line you added will be also written, in addition to the previously
    existing ones.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在这个屏幕上添加NDK下载位置。添加后，关闭控制台并重新打开。如果你输入 `echo $PATH`，除了之前存在的行内容外，你添加的行内容也会被显示。
- en: In Windows, you need to add it via a control panel or system settings. Additionally,
    it is also possible to add it directly from the console by typing `set PATH=%PATH%;C:\new\folder`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，你需要通过控制面板或系统设置来添加它。此外，也可以直接从控制台通过输入 `set PATH=%PATH%;C:\new\folder`
    来添加。
- en: In order to use NDK, we also need the standard Android SDK. If the reader has
    reached this chapter, we assume that this point is in order, and the Android SDK
    has already been successfully installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用NDK，我们还需要标准的Android SDK。如果读者已经阅读到这一章，我们假设这一点已经就绪，并且Android SDK已经成功安装。
- en: JNI
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JNI
- en: '**JNI** stands for **Java Native Interface**. JNI allows libraries and software
    written in other languages to access the Java code that is running in the **Java
    Virtual Machine** (**JVM**). This is not something Android-related, but a programming
    framework that has existed and been used previously in the Java world.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**JNI** 代表 **Java Native Interface**。JNI允许用其他语言编写的库和软件访问在 **Java Virtual Machine**
    (**JVM**) 中运行的Java代码。这不是与Android相关的内容，而是在Java世界中已经存在并使用过的编程框架。'
- en: 'JNI needs files to be declared into either C or C++—it can even connect to
    Objective-C files. This is what an example in C looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JNI需要将文件声明为C或C++——它甚至可以连接到Objective-C文件。下面是C语言的一个示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Observing the file, we can see that after the return type, `jstring`, which
    is equivalent to a string, there is structure with the word `Java`, the package
    name, the class name, and the method name. An object, `JNIEnv`, is always passed
    as a parameter, as well as `jobject`—this is required to make the framework interface
    with Java. The function, written in C, just returns a string. This will be very
    useful to store tokens or keys that we want to hide from the eyes of a prospective
    cracker.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 观察文件，我们可以看到在返回类型 `jstring`（相当于字符串）之后，有一个以单词 `Java` 开头的结构，包括包名、类名和方法名。`JNIEnv`
    对象始终作为参数传递，以及 `jobject` ——这是使框架与Java接口的必要条件。用C编写的函数只返回一个字符串。这对于存储我们希望从潜在破解者眼中隐藏的令牌或密钥将非常有用。
- en: Initial concepts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始概念
- en: 'Before we start creating our first native application, we would like to introduce
    some initial concepts to the reader, to ensure easier understanding:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建第一个本地应用程序之前，我们希望向读者介绍一些初始概念，以便更容易理解：
- en: '**ndk-build**: This file is the shell script in charge of invoking the NDK
    build. Automatically, this script checks that the system and the application is
    right, is generating the binaries that will be used, and copying them to our project
    structure. Being a shell script, it can be called with a few extra parameters:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ndk-build**：这个文件是负责调用NDK构建的shell脚本。自动地，这个脚本检查系统和应用程序是否正确，生成将被使用的二进制文件，并将它们复制到我们的项目结构中。作为一个shell脚本，它可以带有一些额外的参数：'
- en: '`clean`: This parameter makes the script clean all the binaries that have been
    previously generated'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clean`：这个参数会让脚本清除之前生成的所有二进制文件'
- en: '`–B`: Using the `–B` option, we force the system to perform a rebuild'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–B`：使用 `–B` 选项，我们强制系统进行重新构建'
- en: '`V=1`: This releases the build and also displays build commands'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V=1`：这会释放构建并显示构建命令'
- en: '`NDK_DEBUG=X`: If we use `1`, the build will be debuggable; if we use `0`,
    we will be forcing a release build'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NDK_DEBUG=X`：如果我们使用 `1`，构建将是可调试的；如果我们使用 `0`，我们将强制进行发布构建'
- en: '`NDK_LOG=X`: Using `1`, NDK will log all the messages that are generated during
    the build'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NDK_LOG=X`：使用`1`，NDK将记录构建过程中产生的所有消息。'
- en: Keep in mind that all the parameters can be partially combined (for instance,
    you could use `B V=1` if you want to force a rebuild and display all the build
    commands). This scripting comes in very handy when we are automating our builds
    to be done from a CI server, since we will not need to manually specify any build
    type anymore.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，所有参数都可以部分组合（例如，如果您想强制重建并显示所有构建命令，可以使用`B V=1`）。当我们自动化构建以从CI服务器完成时，这种脚本非常有用，因为我们不再需要手动指定任何构建类型。
- en: '**Application Binary Interface** (**ABI**): An ABI definition specifies how
    the code will interact against the system. When the compiled files are generated,
    you will see that there are different files per architecture created. Each file
    is created against one of those definitions.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序二进制接口**（**ABI**）：ABI定义指定了代码如何与系统交互。当编译生成的文件时，您会看到针对每种架构都创建了不同的文件。每个文件都是根据这些定义之一创建的。'
- en: Creating our first HelloWorld-JNI
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个HelloWorld-JNI
- en: 'Let´s create a project with Android Studio with a minimal setup. In order to
    do so, navigate to **Project** | **New** | **New Project**. Create the most minimalistic
    setup available—typically just a project; do not add `Activity` from the beginning.
    This adds a lot of boilerplate code that we do not need at this moment. When the
    project has been created, add a new `Activity` by right-clicking on your source
    folder, and clicking on **New** | **Java Class**. Name the class `Main Activity`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Android Studio创建一个最小配置的项目。为此，导航到**Project** | **New** | **New Project**。创建可用的最简约配置——通常只是一个项目；一开始不要添加`Activity`。这会添加很多我们此刻不需要的样板代码。创建项目后，通过在源文件夹上右键点击，选择**New**
    | **Java Class**来添加一个新的`Activity`。将类命名为`MainActivity`：
- en: '![Creating our first HelloWorld-JNI](img/4666_09_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的第一个HelloWorld-JNI](img/4666_09_03.jpg)'
- en: 'When the file has been created, add this very basic code for `Activity`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件创建完成后，为`Activity`添加以下基础代码：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And remember to add it to the `AndroidManifest.xml` as well as your default
    activity:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并记得将其添加到`AndroidManifest.xml`以及您的默认活动中：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to create the JNI files. This will be comprised of two main
    files. Create a folder called `jni` in the root level of the application. We are
    going to add the following files:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建JNI文件。这包括两个主要文件。在应用程序的根目录下创建一个名为`jni`的文件夹。我们将添加以下文件：
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important that the activity matches the name of the native method. The
    opposite case can lead to problems when NDK is being used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 活动名称与本地方法名称相匹配非常重要。相反的情况可能导致在使用NDK时出现问题。
- en: '`HelloWorld-jni.c`:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld-jni.c`：'
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Android.mk`:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android.mk`：'
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What is the `Android.mk` file? This file specifies to Android the location and
    naming of our resources. Here we specify the modules and the files we are going
    to use, as well as where we can locate them. This file must be in all the projects
    using NDK in order to work.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Android.mk`文件是什么？这个文件告诉Android我们的资源的定位和命名。在这里，我们指定了将要使用的模块和文件，以及它们的存放位置。在使用NDK的所有项目中都必须有这个文件才能正常工作。'
- en: '`Application.mk`:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.mk`：'
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This file specifies against which architecture we are building. In this example,
    we build for all of them, but we could decide to build only against certain architectures
    (armeabi, armeabi-v7a, mips, x86, and so on). We could eventually add the API
    level we are using:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件指定了我们正在构建的目标架构。在这个例子中，我们为所有架构构建，但我们也可以决定只针对特定的架构（armeabi, armeabi-v7a, mips,
    x86等）构建。我们最终还可以添加我们正在使用的API级别：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the prospective reader has probably started to guess, the purpose is to read
    some information provided by our C file and paint it into the screen by using
    NDK and JNI. With all those things set up, let's make some changes in our `MainActivity`
    class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的读者可能已经开始猜测的那样，我们的目的是读取由C文件提供的信息，并通过使用NDK和JNI将其渲染到屏幕上。完成所有设置后，让我们在`MainActivity`类中进行一些更改。
- en: 'First, let''s add the following lines:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加以下几行：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will statically load the library we specify in the function, `loadLibrary()`.
    It must be exactly the one that has been provided in the `Android.mk` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将静态加载我们在`loadLibrary()`函数中指定的库，必须与`Android.mk`文件中提供的完全一致。
- en: 'Now we need to create our native method that has been defined in our `.c` file.
    This needs to be a public method declared within `Activity`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建在我们的`.c`文件中定义的本地方法。这需要在`Activity`中声明一个公共方法：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As a last step, and in order to display the value that has been read using
    JNI, we will create a simple `TextView` and inflate it in our application. This
    `TextView` field will read the value using the function, `stringFromJNI()`, and
    display it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，为了显示使用JNI读取的值，我们将创建一个简单的`TextView`并在我们的应用程序中填充它。这个`TextView`字段将使用`stringFromJNI()`函数读取值并将其显示出来：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When all these steps have been performed, go to the root folder of your project
    and type `ndk-build`. You should get an output similar to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些步骤后，进入项目的根目录并输入`ndk-build`。你应该得到类似于以下的输出：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is a common problem when using NDK, and it is a message similar to `Android
    NDK: Your APP_BUILD_SCRIPT points to an unknown file: /route/to/Android.mk`. This
    can be easily solved by exporting into the environmental variable, `NDK_PROJECT_PATH`,
    the path where your project is located:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '使用NDK时有一个常见问题，就是类似`Android NDK: Your APP_BUILD_SCRIPT points to an unknown
    file: /route/to/Android.mk`的消息。通过将你的项目所在路径导出到环境变量`NDK_PROJECT_PATH`中，可以轻松解决这个问题：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Please keep this in mind if you need to do it programmatically.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要以编程方式完成这个操作，请记住这一点。
- en: 'There is one last step to be performed: when `ndk-build` finishes, it creates
    a folder called `libs` in the root folder. You need to manually move the content
    of this folder into a new directory in your app module, `src/main/jniLibs`. You
    can also achieve this easily using some scripting in your Gradle file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要执行最后一步：当`ndk-build`完成后，在根目录下会创建一个名为`libs`的文件夹。你需要手动将这个文件夹的内容移动到应用模块中的新目录`src/main/jniLibs`。你也可以通过在Gradle文件中使用一些脚本轻松完成这一操作：
- en: '![Creating our first HelloWorld-JNI](img/4666_09_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的第一个HelloWorld-JNI](img/4666_09_04.jpg)'
- en: 'If you have correctly followed all the steps of the chapter until now and you
    compile the application, you should be able to display a screen similar to the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照本章的步骤正确操作，并且编译了应用程序，你应该能够显示一个类似于以下的屏幕：
- en: '![Creating our first HelloWorld-JNI](img/4666_09_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的第一个HelloWorld-JNI](img/4666_09_05.jpg)'
- en: Congratulations! You have created your first application with JNI and NDK.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经使用JNI和NDK创建了你的第一个应用程序。
- en: Creating a native activity with Android NDK
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android NDK创建本地活动
- en: In the following section, we are going to study how an application can be done
    entirely using native C code, without any Java code being required at all. Please
    note that this is done more for study purposes, as there are not many practical
    cases where developing a purely native application will be useful. However, it
    will serve as a good example of interaction between the different layers and the
    Android operational system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何完全使用本地C代码来完成一个应用程序，无需任何Java代码。请注意，这样做更多的是为了学习目的，因为完全使用本地应用程序开发的实际案例并不多。然而，这将作为一个不同层次之间以及与Android操作系统交互的好例子。
- en: 'Since we are not using Java code, we need to specify in the `AndroidManifest.xml`
    file that our project will contain no Java code. This is done using the following
    lines:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用Java代码，我们需要在`AndroidManifest.xml`文件中指定我们的项目将不包含Java代码。这是通过使用以下几行来完成的：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Applications using only native code are first supported from the API level
    9 onwards. At the time of writing this book, this should not be a problem, since
    the versions comprising under API Level 9 ranked under 0.1% of the total. However,
    due to the nature of the NDK, you might be using this only for legacy or old devices:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别9开始，仅使用本地代码的应用程序首次得到支持。在撰写这本书的时候，这应该不是问题，因为低于API级别9的版本占总量的0.1%以下。然而，由于NDK的性质，你可能只会将其用于遗留或旧设备：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lastly, we need to include a metadata value in the `AndroidManifest.xml` file
    called `android.app.lib_name`. This value needs to be equal to the `LOCAL MODULE`
    value you include in the `Android.mk` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`AndroidManifest.xml`文件中包含一个名为`android.app.lib_name`的元数据值。这个值需要与你包含在`Android.mk`文件中的`LOCAL
    MODULE`值相等：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Android.mk` file will look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`文件看起来可能像这样：'
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Android.mk` in this file has been extended compared with the one we used in
    the previous version. Note the following fields:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前版本中使用的文件相比，这个文件中的`Android.mk`已经扩展了。请注意以下字段：
- en: '`LOCAL_LDLIBS`: This is a list of additional linker flags to be used within
    the current NDK application.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_LDLIBS`：这是当前NDK应用程序中要使用的附加链接器标志列表。'
- en: '`LOCAL_STATIC_LIBRARIES`: This is a list of the local static libraries needed
    to be called. In this case, we will call the `android_native_app_glue`. This special
    library is required every time we are trying to create a native activity in order
    to manage its life cycle and the rest of the properties.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_STATIC_LIBRARIES`：这是需要调用的本地静态库列表。在这种情况下，我们将调用 `android_native_app_glue`。每次尝试创建原生活动以管理其生命周期和其他属性时，都需要这个特殊的库。'
- en: 'The `.c` file we will be using in this example is slightly more complex than
    the one we have used previously. First, there are a few more includes that need
    to be added to the application:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用的 `.c` 文件比之前使用的要复杂一些。首先，需要向应用程序添加一些额外的包含指令：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is a main function that serves as an entry point to the native application.
    This function receives, by default, an object of the type `android_app`, which
    reflects the status of the application at a given instant. Based on this state,
    the application handles it as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个主函数，作为进入原生应用程序的入口点。这个函数默认接收一个 `android_app` 类型的对象，它反映了应用程序在给定时刻的状态。基于这个状态，应用程序如下处理：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The application provides a main loop as well. It will check the current and
    previous state and the output of the sensors, and paint on the screen:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序还提供了一个主循环。它将检查当前和之前的状态以及传感器的输出，并在屏幕上绘制：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you compile, you will paint on the screen a purely native activity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译，你将在屏幕上绘制一个纯粹的原生活动。
- en: Debugging NDK
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 NDK
- en: Debugging source code developed with NDK is not as straightforward as debugging
    code that has been developed with the standard Android Java DK, but there are
    tools available for this platform. Android Studio provides, since version 1.3,
    some built-in tools to debug applications with JNI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NDK 开发的源代码的调试并不像使用标准的 Android Java DK 开发的代码那样直接，但这个平台上有可用的工具。从 1.3 版本开始，Android
    Studio 提供了一些内置工具来调试带有 JNI 的应用程序。
- en: 'In order to prepare an application to be debugged, we need to modify our `build.gradle`
    script. As an example, take the `HelloWorldJNI` we have written previously. Open
    the `build.gradle` file of the `app` module and add the following lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备一个要被调试的应用程序，我们需要修改我们的 `build.gradle` 脚本。以我们之前编写的 `HelloWorldJNI` 为例。打开 `app`
    模块的 `build.gradle` 文件，并添加以下几行：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A new configuration for debugging needs to be created. In order to achieve
    it, navigate to **Edit Configurations**, and select **New Android Native** in
    the drop-down menu:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个新的调试配置。为了实现它，请导航到 **编辑配置**，并在下拉菜单中选择 **新建 Android 原生**：
- en: '![Debugging NDK](img/4666_09_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![调试 NDK](img/4666_09_06.jpg)'
- en: 'When the configuration is released in the Android Native setup, Android Studio
    will automatically identify the application as a native (or hybrid) application,
    and start the native debugger automatically. To check this out, go to the C file
    you are using to paint content on the screen, and establish a breakpoint in this
    function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Android 原生设置中发布配置时，Android Studio 会自动识别应用程序为原生（或混合）应用程序，并自动启动原生调试器。要查看这一点，请转到你用来在屏幕上绘制内容的
    C 文件，并在该函数中设置一个断点：
- en: '![Debugging NDK](img/4666_09_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![调试 NDK](img/4666_09_07.jpg)'
- en: 'This will stop the application when the content is going to be painted. Now
    execute the application by clicking on the **Debug** icon, ![Debugging NDK](img/4666_09_08.jpg),
    rather than the start icon. Now a few things will vary in comparison with the
    execution of a normal application. First, you will see that the environment is
    trying to connect a native debugger rather than the standard one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在内容即将被绘制时停止应用程序。现在通过点击 **调试** 图标，![调试 NDK](img/4666_09_08.jpg)，而不是启动图标来执行应用程序。现在与普通应用程序的执行相比，会有一些不同之处。首先，你会看到环境正在尝试连接原生调试器，而不是标准的调试器：
- en: '![Debugging NDK](img/4666_09_09.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![调试 NDK](img/4666_09_09.jpg)'
- en: 'And when the application has finally been started, the execution will stop
    at the breakpoint, and a new screen will be available in the debugging section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序最终启动后，执行将在断点处停止，调试部分将出现一个新的屏幕：
- en: '![Debugging NDK](img/4666_09_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![调试 NDK](img/4666_09_10.jpg)'
- en: The new debugging screen is really interesting. Here we have access to all the
    native variables that are being declared or instantiated (for instance, the `JNIEnv`
    variable that we are using in the function conveys a lot of information about
    our environment and the debugging section that can be used).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 新的调试屏幕非常有趣。在这里，我们可以访问所有正在声明或实例化的本地变量（例如，我们在函数中使用的`JNIEnv`变量包含了很多关于我们的环境和可用的调试部分的信息）。
- en: Android.mk
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android.mk
- en: 'We have already seen some basic possibilities that the `Android.mk` file offers
    us. In reality, this file is similar to a GNU makefile: it describes the sources
    and shared libraries to the build system.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了`Android.mk`文件提供的一些基本可能性。实际上，这个文件类似于GNU makefile：它向构建系统描述了源文件和共享库。
- en: In the `Android.mk` file, we can group all our resources into modules. Modules
    are static libraries, standalone executables, or shared libraries. The concept
    is also similar to the modules within Android Studio, which should be familiar
    to the reader by now. The same source can be used in different modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Android.mk`文件中，我们可以将所有资源分组到模块中。模块可以是静态库、独立可执行文件或共享库。这个概念与Android Studio中的模块相似，读者现在应该已经熟悉了。相同的源代码可以用于不同的模块。
- en: 'We have seen the following line in the previous script:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一个脚本中看到了以下这行内容：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This value is automatically provided by the build system. This points to an
    internal makefile that it is in charge of cleaning many of the locals variables
    used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值由构建系统自动提供。它指向一个负责清理许多本地变量的内部makefile。
- en: 'We need to add the modules later on:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后需要添加这些模块：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For the file to work properly, modules need to have a unique name and not have
    special characters or spaces.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使文件正常工作，模块需要具有唯一的名称，并且不能有特殊字符或空格。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NDK will automatically append the prefix `lib` to your module when it is being
    compiled, and add the extension `.so`. In the proposed example, the resulting
    file will be `libexample-module.so`. However, if you add the prefix `lib` to the
    `Android.mk` file, this prefix will not be added when the `.so` file is generated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译时，NDK会自动为你的模块添加前缀`lib`，并添加后缀`.so`。在所提供的示例中，生成的文件将是`libexample-module.so`。但是，如果你在`Android.mk`文件中添加了前缀`lib`，那么在生成`.so`文件时将不会添加此前缀。
- en: 'Specifying the files to be included within the module is always done with the
    following line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要在模块中包含的文件始终使用以下这行：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you need to include different files within the same module, you should delimitate
    them using spaces, exactly as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在同一模块中包含不同的文件，你应该使用空格分隔它们，如下所示：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: More variables in NDK
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NDK中的更多变量
- en: NDK defines a few variables that can be automatically used in the `Android.mk`
    file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: NDK定义了一些可以在`Android.mk`文件中自动使用的变量。
- en: TARGET_PLATFORM
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TARGET_PLATFORM
- en: 'This variable defines the target platform to be used by the build system:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量定义了构建系统要使用的目标平台：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The target is always used in the format `android-xx`. Not all the platform
    types are supported by NDK. It''s a good idea to check on the NDK website which
    ones are supported. At the time of writing this book (1Q2016), this is the list
    of the supported platforms:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目标始终以`android-xx`的格式使用。NDK并不支持所有的平台类型。最好检查NDK网站以了解哪些平台是受支持的。在撰写本书时（2016年第一季度），以下是受支持的平台列表：
- en: '| Supported NDK API level | Equivalent Android release |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 支持的NDK API级别 | 相当于的Android版本 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 3 | 1.5 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.5 |'
- en: '| 4 | 1.6 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1.6 |'
- en: '| 5 | 2.0 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2.0 |'
- en: '| 8 | 2.2 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2.2 |'
- en: '| 9 | 2.3 to 3.0.x |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 2.3至3.0.x |'
- en: '| 12 | 3.1.x |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 3.1.x |'
- en: '| 13 | 3.2 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 3.2 |'
- en: '| 14 | 4.0 to 4.0.2 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 4.0至4.0.2 |'
- en: '| 15 | 4.0.3 to 4.0.4 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 4.0.3至4.0.4 |'
- en: '| 16 | 4.1 and 4.1.1 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 4.1和4.1.1 |'
- en: '| 17 | 4.2 and 4.2.2 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 4.2和4.2.2 |'
- en: '| 18 | 4.3 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 4.3 |'
- en: '| 19 | 4.4 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 4.4 |'
- en: '| 21 | 4.4W and 5.0 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 4.4W和5.0 |'
- en: TARGET_ARCH
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TARGET_ARCH
- en: 'This variable specifies the architecture that will be used to build NDK. It
    could contain values such as `x86` or `arm`. The value of this variable is taken
    from the `APP_ABI` file, which is specified in the `Android.mk` file. At the time
    of writing this book, this is the list of supported architectures and their names:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量指定了用于构建NDK的架构。它可能包含如`x86`或`arm`等值。此变量的值取自`APP_ABI`文件，该文件在`Android.mk`文件中指定。在撰写本书时，以下是支持的架构及其名称列表：
- en: '| Architecture | Name to be used |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | 要使用的名称 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ARMv5TE | armeabi |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| ARMv5TE | armeabi |'
- en: '| ARMv7 | armeabi-v7a |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| ARMv7 | armeabi-v7a |'
- en: '| ARMv8 AArch64 | arm64-v8a |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| ARMv8 AArch64 | arm64-v8a |'
- en: '| i686 | x86 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| i686 | x86 |'
- en: '| x86-64 | x86_64 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| x86-64 | x86_64 |'
- en: '| mips32 (r1) | mips |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| mips32 (r1) | mips |'
- en: '| mips64 (r6) | mips64 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| mips64 (r6) | mips64 |'
- en: '| All of them | all |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| All of them | 所有 |'
- en: TARGET_ABI
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TARGET_ABI
- en: 'This variable can be very handy when we want to specify at the same time the
    Android API level and the ABI. We can easily do it, as for example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要同时指定Android API级别和ABI时，这个变量会非常有用。我们可以轻松地这样做，例如：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: NDK macros
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NDK宏
- en: 'Macros are small functions that contain a particular functionality. A few of
    them are defined by default by NDK. To call them, you must use the following syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是包含特定功能的小型函数。其中一些默认由NDK定义。要调用它们，你必须使用以下语法：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are a few of the default macros specified in the NDK:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是NDK中指定的几个默认宏：
- en: '`my-dir`: This macro returns the current path of the `Android.mk` file. It
    can be very useful when, initially, you want to set up `LOCAL_PATH` in the script:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-dir`：这个宏返回`Android.mk`文件的当前路径。当你最初想在脚本中设置`LOCAL_PATH`时，它非常有用：'
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When this macro is executed, it returns as a list all the `Android.mk` makefiles
    that have been found in the folder returned by `my-dir`.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行此宏时，它会以列表形式返回找到的所有`Android.mk` makefile，这些文件位于`my-dir`返回的文件夹中。
- en: By using this command, we can provide a better line of sub hierarchies and a
    better organization of the package structure.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此命令，我们可以提供更好的子层次结构行和包结构的更好组织。
- en: '`parent-makefile`: This returns the path where the parent makefile can be found.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent-makefile`：这返回父makefile可以找到的路径。'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The command `grand-parent-makefile` also exists, and it returns, as obviously
    inferred, the path of the grandparent.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`grand-parent-makefile`命令也存在，它返回，顾名思义，是祖父路径。'
- en: '`this-makefile`: This macro returns the path of the current makefile.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this-makefile`：这个宏返回当前makefile的路径。'
- en: Application.mk
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Application.mk
- en: 'The `Application.mk` file is also an existing file in our sample project. It
    describes the native modules required by the app, and is generally located under
    the `yourProject/jni` folder. As with the `Android.mk` file, there are a few variables
    that we can include here and will increase the functionality of this file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk`文件也是我们示例项目中存在的文件。它描述了应用程序所需的本地模块，通常位于`yourProject/jni`文件夹下。与`Android.mk`文件一样，这里我们可以包含一些变量，这将增加此文件的功能性：'
- en: '`APP_OPTIM`: This is a very useful variable that can be used to decide the
    optimization level when the application modules are being built. It can be defined
    as `release` or `debug`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_OPTIM`：这是一个非常有用的变量，可以用来决定在构建应用程序模块时的优化级别。它可以被定义为`release`或`debug`。'
- en: Basically, when the modules are compiled in the `release` mode, they are very
    efficient and provide little information for debugging. The `debug` mode, on the
    other hand, contains a bunch of useful information for debugging but is not very
    efficient for being distributed. The default mode is `release`.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基本上，当模块在`release`模式下编译时，它们非常高效，提供的调试信息很少。另一方面，`debug`模式包含了一堆有用的调试信息，但不适合分发。默认模式是`release`。
- en: Some of the optimization that takes place in the release mode is the naming
    of variables. They can be renamed and shortened (here you can think of the same
    optimization taking place when applying ProGuard to our APKs), but obviously it
    will not be possible to debug them later when the application is running. There
    is additionally some code reordering and reorganization that will make the code
    more efficient but lead to incorrect information when the application is being
    debugged.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在发布模式下进行的某些优化包括变量的命名。它们可以被重命名和缩短（你可以想到在应用ProGuard时也会进行相同的优化），但显然，在应用程序运行时，将无法对它们进行调试。此外，还有一些代码重排和重组织会使代码更高效，但在调试应用程序时会提供错误的信息。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you include the `android:debuggable` tag in your `AndroidManifest.xml`, the
    default value of this variable will set to `debug` rather than `release`. You
    will need to override this value to change its default value.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在`AndroidManifest.xml`中包含了`android:debuggable`标签，这个变量的默认值将被设置为`debug`而不是`release`。你需要重写这个值以改变其默认设置。
- en: '`APP_CFLAGS`: C/C++ compilers can use special values when the applications
    are being compiled, in order to change procedures or to specify particular values
    that need to be considered within the app. This can be handled in NDK with this
    variable. For example, see the following line:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_CFLAGS`：C/C++编译器在编译应用程序时可以使用特殊值，以改变程序或指定应用程序中需要考虑的特定值。这可以在NDK中使用此变量处理。例如，请看以下行：'
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will add the `mcpu` flag with the value `cortex-a9` to the compilation
    of the module.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在模块编译时添加 `mcpu` 标志，值为 `cortex-a9`。
- en: '`APP_CPPFLAGS:` This value is only specified for C++ files. The previous one,
    `APP_CFLAGS`, works for both languages.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_CPPFLAGS:` 这个值仅针对C++文件指定。前一个值 `APP_CFLAGS` 适用于两种语言。'
- en: '`APP_LDFLAGS`: This variable contains a set of linker flags that are passed
    to the linker each time this is executed. This will obviously only make sense
    each time the linker is being executed, so it will only affect the shared libraries.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_LDFLAGS`: 这个变量包含一组链接器标志，每次执行时都会传递给链接器。这显然只有在每次执行链接器时才有意义，因此它只会影响共享库。'
- en: '`APP_BUILD_SCRIPT:` We have already seen that, by default, the build script
    used is the `Android.mk` file, located in the `/jni` folder. This can be changed
    by defining this variable to point to the location of the right build script.
    This is always understood as a relative location to the absolute NDK path.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_BUILD_SCRIPT:` 我们已经看到，默认情况下，使用的构建脚本是在 `/jni` 文件夹中的 `Android.mk` 文件。通过定义这个变量来指向正确的构建脚本的位置，可以更改此设置。这始终被视为相对于绝对NDK路径的相对位置。'
- en: '`APP_PLATFORM`: With this variable, we can specify the Android version to be
    used, with the format `android-n` (analogous to the table that has been previously
    introduced for the `Android.mk` file).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_PLATFORM`: 通过这个变量，我们可以指定要使用的Android版本，格式为 `android-n`（类似于之前为 `Android.mk`
    文件介绍过的表格）。'
- en: '`APP_ABI:` In this variable, we specify the ABI against which the application
    is building. By default, NDK will build our application against `armeabi`. But
    this can be changed to another value, according to the following table:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_ABI:` 在这个变量中，我们指定应用程序构建的ABI。默认情况下，NDK将构建我们的应用程序针对 `armeabi`。但这可以更改为以下表格中的另一个值：'
- en: '| Set of instructions | Value |'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 指令集 | 值 |'
- en: '| --- | --- |'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ARMv7 based devices | `APP_ABI := armeabi-v7a` |'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 基于ARMv7的设备 | `APP_ABI := armeabi-v7a` |'
- en: '| ARMv8 64 Arch | `APP_ABI := armeabi-v7a` |'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ARMv8 64位架构 | `APP_ABI := armeabi-v7a` |'
- en: '| Intel-32 | `APP_ABI := x86` |'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Intel-32 | `APP_ABI := x86` |'
- en: '| Intel64 | `APP_ABI := x86_64` |'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Intel64 | `APP_ABI := x86_64` |'
- en: '| MIPS32 | `APP_ABI := mips` |'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| MIPS32 | `APP_ABI := mips` |'
- en: '| MIPS64 | `APP_ABI := mips64` |'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| MIPS64 | `APP_ABI := mips64` |'
- en: '| All the supported sets | `APP_ABI := all` |'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 所有支持的集合 | `APP_ABI := all` |'
- en: Note
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The value to include all the different architectures is only supported from
    NDK version 7 onwards.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括所有不同架构的值仅在NDK版本7及以后支持。
- en: 'This can also be combined when required. For example, the following command
    will combine different sets of instructions:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在需要时，这也可能结合使用。例如，以下命令将结合不同的指令集：
- en: '[PRE29]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Including existing libraries
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含现有库
- en: One of the main reasons why NDK is extensively used is to include other already
    existing libraries that provide some set of functionalities in C/C++. Maybe the
    most obvious example is OpenCV, which was originally written in C/C++. Rewriting
    it in Java will not only take time, but on top of that it will not be as efficient
    as its native counterpart.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NDK被广泛使用的主要原因之一是为了包含其他已经存在的库，这些库在C/C++中提供一组功能。最明显的例子可能是OpenCV，它最初是用C/C++编写的。用Java重写它不仅会花费时间，而且效率不会像它的本地对应物那样高。
- en: Alternatively, you might want to create your own libraries and distribute them
    to third-party developers. It could even be possible to create a prebuilt version
    of the libraries that can be directly included in our project, so we speed up
    the build time rather than compiling the library with each build.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能想要创建自己的库并将其分发给第三方开发者。甚至可能创建一个预构建的库版本，可以直接包含在我们的项目中，这样我们就可以加快构建时间，而不是每次构建都编译库。
- en: There are a set of steps we must follow in order to achieve this. First, each
    prebuilt library being used must be declared as a single independent module. This
    is how we achieve it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们必须遵循一系列步骤。首先，每个正在使用的预构建库必须被声明为一个单独的独立模块。这就是我们如何实现它的方法。
- en: 'The module must have a name. It does not strictly need to be the same as the
    prebuilt library, but it needs to contain a name:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 模块必须有一个名称。它不一定要与预构建库相同，但需要包含一个名称：
- en: Go to the `Android.mk` file and set `LOCAL_SRC_FILES` as the path pointing to
    the library that you will be delivering.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `Android.mk` 文件，将 `LOCAL_SRC_FILES` 设置为指向你将要交付的库的路径。
- en: Make sure that the version of the prebuilt library is appropriate for the ABI
    you will be using.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保预构建库的版本适合你将要使用的ABI。
- en: If you are using a `.so` file, you will need to include `PREBUILT_SHARED_LIBRARY`.
    If you are using a `.a` file, you will need to include `PREBUILT_STATIC_LIBRARY`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是`.so`文件，你将需要包含`PREBUILT_SHARED_LIBRARY`。如果你使用的是`.a`文件，你将需要包含`PREBUILT_STATIC_LIBRARY`。
- en: 'To put everything together, let''s see an example of what this file would look
    like:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了把所有内容整合在一起，让我们看看这个文件的样子：
- en: '[PRE30]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That's it. The process is fairly simple and from now on you can pass your own
    application as a library.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这个过程相当简单，从现在起你可以将你的应用程序作为库传递。
- en: 'You are probably wondering how this library, once it has been exported, can
    be referenced from another project. The process is also fairly simple: it just
    needs to be specified as the value of `LOCAL_STATIC_LIBRARIES` or `LOCAL_SHARED_LIBRARIES`.
    For example, let''s say we want to include `libmylibrary.so` in another project.
    We need to use the following `Android.mk` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这个库一旦被导出，如何从另一个项目中引用。这个过程也相当简单：只需要将其指定为`LOCAL_STATIC_LIBRARIES`或`LOCAL_SHARED_LIBRARIES`的值。例如，假设我们想在另一个项目中包含`libmylibrary.so`。我们需要使用以下`Android.mk`文件：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exporting header files
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出头文件
- en: 'When dealing with third-party native libraries, it is very common to be able
    to access headers. For example, in a file using our shared library, we will find
    includes requiring access to our header files:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第三方本地库时，通常能够访问头文件。例如，在使用我们共享库的文件中，我们会发现需要访问我们头文件的包含指令：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, we will need to provide the headers to all the modules. Probably
    the easiest way to achieve this is to use exports in the `Android.mk` file. Look
    at the following code example, taken from an `Android.mk` file requiring some
    headers. As long as the `file.h` file, from the preceding line is within the `include`
    folder, the module will work properly:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要向所有模块提供头文件。实现这一点的最简单方法可能是在`Android.mk`文件中使用exports。看看下面的代码示例，取自一个需要一些头文件的`Android.mk`文件。只要前一行中的`file.h`文件位于`include`文件夹内，模块就能正常工作：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, the reader will be able to construct applications
    using NDK natively or as a hybrid within an Android application. In addition,
    we recommend the reader checks out some other frameworks, particularly OpenCV.
    Learning OpenCV itself can be the subject of an entire book. However, if the reader
    is dealing with heavy image processing, he/she will find this framework very useful.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章节后，读者将能够使用NDK本地或在Android应用程序中以混合方式构建应用程序。此外，我们建议读者查看一些其他框架，特别是OpenCV。学习OpenCV本身可以成为一本书的主题。然而，如果读者正在处理繁重的图像处理，他/她会发现这个框架非常有用。
- en: One of the key points when using NDK is to decide where the correct trade-off
    between complexity and performance lies. Using NDK can be tempting to solve complex
    computational problems, and it should be a clear decision when we are dealing
    with image processing, OpenGL, computer graphics, or animation. It is in fact
    proven that NDK learners tend to overuse it, and include it in most single tasks.
    From an efficiency point of view, this could look like a great idea, but software
    engineering is about handling growing complexity more than anything else. If the
    software keeps growing without any control, future problems of scalability and
    software efficiency will appear.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NDK时的一个关键点是确定复杂性与性能之间的正确权衡。使用NDK解决复杂的计算问题可能很有诱惑力，而且当涉及到图像处理、OpenGL、计算机图形学或动画时，应该明确作出决定。实际上，已经证明NDK学习者往往过度使用它，并将其包含在大多数单一任务中。从效率的角度来看，这似乎是一个很好的想法，但软件工程更多的是关于处理不断增长的复杂性。如果软件不断增长而没有任何控制，未来将出现可扩展性和软件效率的问题。
- en: Remember, not everybody is familiar with NDK, so you are also forcing developers
    to learn a relatively complex technology to deal with mundane issues. The only
    way to acquire knowledge and the trade-offs required in NDK is, in this case,
    experience, since there are no unique cases and they can only be learned from
    previous mistakes and failures. So we encourage you to try it—we are sure you
    will be satisfied.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不是每个人都熟悉NDK，因此你也在迫使开发者学习相对复杂的技术来解决平凡的问题。在这种情况下，获取NDK所需的知识和权衡的唯一方式是经验，因为每个案例都是独一无二的，只能从先前的错误和失败中学习。因此，我们鼓励你尝试一下——我们相信你会满意的。
