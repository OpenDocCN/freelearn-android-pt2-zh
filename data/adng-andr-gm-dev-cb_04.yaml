- en: Chapter 4. Working with Cameras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 使用摄像机
- en: 'This chapter will cover AndEngine''s various camera objects and advanced camera
    control. The topics include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍AndEngine的各种摄像机对象和高级摄像机控制。主题包括：
- en: Introducing the camera object
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入摄像机对象
- en: Limiting the camera area with the bound camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用边界摄像机限制摄像机区域
- en: Taking a closer look with zoom cameras
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩放摄像机更近距离观察
- en: Creating smooth moves with a smooth camera
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平滑摄像机创建平滑移动
- en: Pinch-zoom camera functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捏合缩放摄像机功能
- en: Stitching a background together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拼接背景
- en: Applying a HUD to the camera
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为摄像机应用HUD
- en: Attaching a controller to the display
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控制器附加到显示
- en: Coordinate conversion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标转换
- en: Creating a split screen game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分屏游戏
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: AndEngine includes three types of cameras, not including the base `Camera` object,
    which allow us to control (more specifically) how the camera behaves. Cameras
    can play many different roles in a game, and in some cases, we may find ourselves
    in need of more than one camera. This chapter is going to cover some of the different
    purposes and ways we can use AndEngine's `Camera` objects in order to apply more
    advanced camera functionality into our own games.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine包括三种类型的摄像机，不包括基础的`Camera`对象，这允许我们更具体地控制摄像机的行为。摄像机在游戏中可以扮演许多不同的角色，在某些情况下，我们可能需要不止一个摄像机。这一章将介绍我们可以使用AndEngine的`Camera`对象的不同目的和方式，以便在我们的游戏中应用更高级的摄像机功能。
- en: Introducing the camera object
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入摄像机对象
- en: Cameras can have many purposes when it comes to designing a large-scale game,
    but its main objective is to display a particular area of the game world on the
    device's display. This topic is going to introduce the base `Camera` class, covering
    the general aspects of the camera in order to provide a reference for future camera
    use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计大型游戏时，摄像机可以有许多用途，但它的主要目标是将在游戏世界的特定区域显示在设备的屏幕上。这一主题将介绍基础的`Camera`类，涵盖摄像机的一般方面，以便为将来的摄像机使用提供参考。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Cameras are important in game development as they control what we see on the
    device. Creating our camera is as easy as the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，摄像机的重要性在于它决定了我们在设备上能看到什么。创建我们的摄像机就像下面的代码一样简单：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `WIDTH` and `HEIGHT` values will define the area of the game's scene that
    will be displayed on the device.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIDTH`和`HEIGHT`值将定义游戏场景的区域，该区域将在设备上显示。'
- en: How it works…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It''s important to get to know the main functions of a camera in order to make
    the most of it in our projects. All of the different cameras inherit the methods
    found in this topic. Let''s take a look at some of the most necessary camera methods
    needed for AndEngine development:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解摄像机的主要功能，以便在我们的项目中充分利用它。所有不同的摄像机都继承了本主题中找到的方法。让我们看看在AndEngine开发中一些最必要的摄像机方法：
- en: '**Positioning the camera**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**摄像机定位**：'
- en: 'The `Camera` object follows the same coordinate system as entities. Setting
    the camera''s coordinates to `(0,0)`, for example, will set the center point of
    the camera to the defined coordinates. Additionally, increasing the x value moves
    the camera to the right-hand side and increasing the y value moves the camera
    upward. Decreasing the values will have the opposite effect. In order to relocate
    the camera to center on a defined location, we can call the following method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`对象遵循与实体相同的坐标系。例如，将摄像机的坐标设置为`(0,0)`，将设置摄像机的中心点为定义的坐标。此外，增加x值将摄像机向右移动，增加y值将摄像机向上移动。减少这些值将产生相反的效果。为了将摄像机重新定位到定义的位置中心，我们可以调用以下方法：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code would not have any effect on the default camera position
    (assuming that the `WIDTH` and `HEIGHT` values were used to define the camera's
    width and height). This would set the camera's center to the "center" of our scene,
    which is naturally equal to half the camera `WIDTH` and `HEIGHT` values when the
    `Camera` object is created. The preceding method call could be used in a situation
    where we'd like to reset the camera back to its initial position, which is useful
    in cases where a camera moves during gameplay, but should return to its initial
    position when a user returns to the menu.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对默认的摄像机位置没有任何影响（假设`WIDTH`和`HEIGHT`值用于定义摄像机的宽度和高度）。这将设置摄像机的中心到我们场景的“中心”，当创建`Camera`对象时，这自然等于摄像机`WIDTH`和`HEIGHT`值的一半。在需要将摄像机重置回初始位置的情况下，可以使用前面的方法调用，这在摄像机在游戏过程中移动，但在用户返回菜单时应返回初始位置时很有用。
- en: 'Moving the camera without setting specific coordinates can be achieved through
    the `offsetCenter(x,y)` method, where the `x` and `y` values define the distance
    to offset the camera in scene coordinates. This method adds the specified parameter
    values to the camera''s current position:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不设置特定坐标而移动摄像头可以通过`offsetCenter(x,y)`方法实现，其中`x`和`y`值定义了在场景坐标中偏移摄像头的距离。此方法将指定的参数值添加到摄像头的当前位置：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Additionally, we can obtain the camera''s center x and y coordinates through
    the use of the following methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过以下方法获取摄像头的中心坐标（x和y）：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Adjusting the camera''s width and height**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整摄像头的宽度和高度**：'
- en: 'The camera''s initial width and height can be adjusted via the camera''s `set()`
    method. We can also set the camera''s minimum/maximum x and y values by calling
    methods such as `setXMin()`/`setXMax()` and `setYMin()`/`setYMax()`. The following
    code will cause the camera width to shrink by half, while sustaining the initial
    camera height:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过摄像头的`set()`方法调整摄像头的初始宽度和高度。我们还可以通过调用如`setXMin()`/`setXMax()`和`setYMin()`/`setYMax()`等方法来设置摄像头的最小/最大x和y值。以下代码将使摄像头宽度减半，同时保持初始的摄像头高度：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep in mind that while shrinking the camera width, we lose visibility on the
    pixels and any entities outside of the defined area. Additionally, shrinking or
    extending the camera's width and height may cause entities to appear stretched
    or squeezed. Generally, modifying the camera's width and height are not necessary
    in the development of a typical game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在缩小摄像头宽度的同时，我们会失去在定义区域之外的像素和任何实体的可见性。此外，缩小或扩展摄像头的宽度和高度可能会导致实体看起来被拉伸或压缩。通常，在开发典型游戏时，修改摄像头的宽度和高度并不是必要的。
- en: The `Camera` object also allows us to obtain the camera's current min/max width
    and height values by calling `getXMin()`/`getXMax()` and `getYMin()`/`getYMax()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`对象还允许我们通过调用`getXMin()`/`getXMax()`和`getYMin()`/`getYMax()`获取摄像头的当前最小/最大宽度和高度值。'
- en: '**Visibility checking**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**可见性检查**：'
- en: 'The `Camera` class allows us to check if specific `Entity` objects are visible
    within the camera''s view. `Entity` object subtypes include, but are not limited
    to, the `Line` and `Rectangle` primitives, `Sprite`, and `Text` objects, as well
    as all of their subtypes such as `TiledSprite` and `ButtonSprite` objects and
    more. Visibility checking can be called through the use of the following method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`类允许我们检查特定的`Entity`对象是否在摄像头的视野内可见。`Entity`对象子类型包括但不限于`Line`和`Rectangle`基元，`Sprite`和`Text`对象，以及它们的子类型，如`TiledSprite`和`ButtonSprite`对象等。可以通过以下方法进行可见性检查：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Visibility checks can be very useful for many games in order to re-use objects
    which might leave the camera's view, to name one scenario. This can allow us to
    limit the overall number of objects created in situations where we may have many
    objects being spawned, which eventually leave the camera view. Instead, we can
    re-use objects which leave the camera view.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性检查对于许多游戏来说非常有用，例如，重用可能离开摄像头视野的对象，这样就可以限制在可能产生大量对象并最终离开摄像头视野的情况下创建对象的总数。相反，我们可以重用离开摄像头视野的对象。
- en: '**The chase entity functionality**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**追逐实体功能**：'
- en: 'Often times, games require the camera to follow an `Entity` object as it moves
    around the screen, such as in a side-scroller. We can easily set up our camera
    to follow entities wherever they move in the game world by calling a single method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多游戏中，常常需要摄像头跟随屏幕上的`Entity`对象移动，例如在横向卷轴游戏中。我们可以通过调用一个简单的方法轻松设置摄像头跟随游戏世界中任何地方的实体移动。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code will apply the camera position to the specified entity's
    position on every update to the camera. This ensures that the entity stays in
    the center of the camera at all times.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将在每次更新摄像头时将摄像头位置应用到指定实体的位置上。这确保了实体始终处于摄像头的中心。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：由于原文最后一行只有一个单词"Note"，并没有提供足够的信息来进行翻译，因此在这里保留原文。如果需要进一步的翻译，请提供完整的句子或段落。
- en: In the majority of recipes in this book, we are specifying a camera width of
    800 pixels and a camera height of 480 pixels. However, these values are entirely
    up to the developer and should be defined by the needs of the game. These specific
    values are chosen for this book's recipes due to the fact that they are relatively
    suitable for both small and large screen devices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的多数食谱中，我们指定了800像素的摄像头宽度和480像素的摄像头高度。然而，这些值完全取决于开发者，并且应由游戏的需求来定义。选择这些特定的值是因为它们相对适合小屏幕和大屏幕设备。
- en: Limiting the camera area with the bound camera
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用边界摄像头限制摄像头区域
- en: The `BoundCamera` object allows us to define specific bounds on the camera's
    area, limiting the distance the camera can travel on both the x and y axis. This
    camera is useful in situations where the camera may follow a player, but still
    not exceed the level bounds if the user travels close to a wall.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoundCamera`对象允许我们定义摄像机区域的具体边界，限制摄像机在x轴和y轴上可以移动的距离。当摄像机需要跟随玩家但又不超出关卡边界时（例如用户靠近墙壁时），这种摄像机非常有用。'
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `BoundCamera` object creation requires the same parameters as a regular
    `Camera` object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`BoundCamera`对象需要与普通`Camera`对象相同的参数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BoundCamera` object extends the ordinary `Camera` object, giving us all
    of the original functionality of a camera as described in the *Introducing the
    camera object* recipe, which is given in this chapter. In fact, unless we configure
    a bounded area on the `BoundCamera` object, we are ideally working with a basic
    `Camera` object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoundCamera`对象扩展了普通的`Camera`对象，为我们提供了本章中*摄像机对象介绍*一节描述的所有原始摄像机功能。实际上，除非我们在`BoundCamera`对象上配置了一个有边界的区域，否则我们实际上是在使用基本的`Camera`对象。'
- en: 'Before our camera will apply restrictions to its available movement area, we
    must define the available area in which the camera is free to move:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在摄像机对其可移动区域应用限制之前，我们必须定义摄像机可以自由移动的可用区域：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code will set up the camera bounds starting from position `(0,0)`
    in scene coordinates through to `(3200,480)` since we are multiplying the camera's
    width by four times for the maximum x area, allowing the camera to scroll four
    times the camera's width. The camera will not respond to changes on the y axis
    as the bound height is set to the same value as the camera's height.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将从场景坐标`(0,0)`的位置开始设置摄像机边界，一直到`(3200,480)`，因为我们把摄像机的宽度放大了四倍作为最大x区域，允许摄像机滚动四倍于其宽度。由于边界高度设置为与摄像机高度相同的值，摄像机将不会响应y轴上的变化。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introducing the camera object* given in this chapter.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节提供的*摄像机对象介绍*。
- en: Taking a closer look with zoom cameras
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用缩放摄像机更近距离地观察
- en: AndEngine's `BoundCamera` and `Camera` objects do not support zooming in and
    out by default. If we would like to allow zooming of the camera, we can create
    a `ZoomCamera` object which extends the `BoundCamera` class. This object includes
    all of the functionality of its inherited classes, including creating camera bounds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine的`BoundCamera`和`Camera`对象默认不支持放大和缩小。如果我们想要允许摄像机缩放，可以创建一个扩展了`BoundCamera`类的`ZoomCamera`对象。这个对象包括其继承类所有的功能，包括创建摄像机边界。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `ZoomCamera` object, similar to `BoundCamera`, requires no additional parameters
    to be defined while creating the camera:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZoomCamera`对象与`BoundCamera`类似，在创建摄像机时不需要定义额外的参数：'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In order to apply zoom effects to the camera, we can call the `setZoomFactor(factor)`
    method, where `factor` is the magnification we would like to apply to our `Scene`
    object. Zooming in and out can be achieved with the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向摄像机应用缩放效果，我们可以调用`setZoomFactor(factor)`方法，其中`factor`是我们想要应用到`Scene`对象的放大倍数。通过以下代码可以实现放大和缩小：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When handling the camera's zoom factor, we must know that a factor of `1` is
    equal to the default factor of the `Camera` class. A zoom factor greater than
    `1` will zoom the camera into the scene, while any value less than `1` will zoom
    the camera out.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理摄像机的缩放因子时，我们必须知道`1`的因子等于`Camera`类的默认因子。大于`1`的缩放因子将摄像机向场景内缩放，而任何小于`1`的值将使摄像机向外缩放。
- en: The math involved for handling the zoom factor is very basic. The camera will
    simply divide the zoom factor by our camera's `WIDTH` and `HEIGHT` values, effectively
    causing the camera to "zoom". If our camera's width is `800`, then a zoom factor
    of `1.5f` will zoom the camera inward, ultimately setting the camera's width to
    `533.3333` which will limit the amount of area of the scene that is displayed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缩放因子的数学运算非常基础。摄像机只需将缩放因子除以我们摄像机的`WIDTH`和`HEIGHT`值，有效实现摄像机的“缩放”。如果我们的摄像机宽度是`800`，那么`1.5f`的缩放因子将使摄像机向内缩放，最终将摄像机的宽度设置为`533.3333`，这将限制场景显示的区域面积。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `getMinX()`, `getMaxX()`, `getMinY()`, `getMaxY()`, `getWidth()`, and `getHeight()`
    values returned by the `ZoomCamera` object in a situation where a zoom factor
    (not equal to 1) is applied, will automatically have had their values divided
    by the zoom factor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用了缩放因子（不等于1）的情况下，`ZoomCamera`对象返回的`getMinX()`、`getMaxX()`、`getMinY()`、`getMaxY()`、`getWidth()`和`getHeight()`值会自动被缩放因子除。
- en: There's more…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Enabling bounds on a zoom camera with a factor not equal to 1 will have an effect
    on the total available area the camera is able to pan. Assuming that the bounds
    are set from 0 to 800 for the bounds' minimum and maximum x values, if the camera
    width is equal to 800 there will not be any movement allowed on the x axis. In
    the event we zoom the camera in, the camera's width will decrease, allowing for
    slack in the movement of the camera.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在缩放摄像头中启用不等于1的因子的边界，将对摄像头能够平移的总可用区域产生影响。假设边界的最小和最大x值从0设置为800，如果摄像头宽度等于800，那么在x轴上将不允许有任何移动。如果我们放大摄像头，摄像头的宽度将减小，从而允许摄像头移动时有更多的余地。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the event that a zoom factor is defined which would cause the camera's width
    or height to exceed the camera bounds, the zoom factor would be applied to the
    camera, but there would be no movement allowed on the exceeded axis.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了一个缩放因子，导致摄像头的宽度或高度超出摄像头边界，那么将应用缩放因子到摄像头，但超出轴将不允许移动。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introducing the camera object* given in this chapter.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章中提供的摄像头对象介绍*。'
- en: '*Limiting camera area with the bound camera* given in this chapter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章中提供的限制摄像头区域的边界摄像头*。'
- en: Creating smooth moves with a smooth camera
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平滑摄像头创建平滑移动
- en: The `SmoothCamera` object is the most advanced of the four cameras to choose
    from. This camera allows for all of the different types of camera functionality
    (bounds, zooming, and so on) with an additional option to apply a defined velocity
    to the camera's movement speed upon setting a new position for the camera. The
    result may appear as if the camera "eases" in and out of movement, allowing for
    rather subtle camera movements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmoothCamera`对象是四种可选摄像头中最先进的一个。这个摄像头支持所有不同的摄像头功能类型（边界、缩放等），并新增了一个选项，即在为摄像头设置新位置时，可以给摄像头的移动速度应用一个定义好的速度。这样做的结果是，摄像头在移动时看起来会“平滑”地进入和退出，从而实现相当微妙的摄像头移动。'
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'This camera type is the only one of the four which requires additional parameters
    to be defined in the constructor. These extra parameters include the maximum x
    and y velocities in which the camera can travel and the maximum zoom factor change
    which handles the speed that the camera will zoom in and out. Let''s take a look
    at what this camera creation will look like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种摄像头类型是四种中唯一需要在构造函数中定义额外参数的一个。这些额外的参数包括摄像头可以移动的最大x和y速度以及处理摄像头缩放速度的最大缩放因子变化。让我们看看创建这种摄像头的样子：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we're creating a camera that applies a smooth transitional affect
    to camera movement and zooming. Unlike the other three camera types, rather than
    directly setting the camera center to the defined position with `setCenter(x,y)`,
    the camera uses the `maxVelocityX`, `maxVelocityY`, and `maxZoomFactorChange`
    variables to define how fast the camera will move from point A to point B. Increasing
    the velocities will cause the camera to make faster movements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个摄像头，为摄像头的移动和缩放应用平滑的过渡效果。与其他三种摄像头类型不同，不是直接使用`setCenter(x,y)`将摄像头中心设置到定义的位置，而是使用`maxVelocityX`、`maxVelocityY`和`maxZoomFactorChange`变量来定义摄像头从点A到点B的移动速度。增加速度会使摄像头移动更快。
- en: There are two options, both for camera movement and camera zooming for the `SmoothCamera`
    class. We can allow the camera to move or zoom smoothly by calling the default
    camera methods for these tasks (`camera.setCenter()` and `camera.setZoomFactor()`).
    On the other hand, sometimes we need to reposition our camera immediately. This
    can be done by calling the `camera.setCenterDirect()` and `camera.setZoomFactorDirect()`
    methods respectively. These methods are most commonly used in order to reset the
    position of a smooth camera.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SmoothCamera`类，无论是摄像头移动还是缩放，都有两种选择。我们可以通过调用这些任务的默认摄像头方法（`camera.setCenter()`和`camera.setZoomFactor()`）使摄像头平滑移动或缩放。另一方面，有时我们需要立即重新定位摄像头。这可以通过分别调用`camera.setCenterDirect()`和`camera.setZoomFactorDirect()`方法来实现。这些方法通常用于重置平滑摄像头的位置。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introducing the camera object* given in this chapter.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中提供的*相机对象介绍*。
- en: '*Limiting camera area with the bound camera* given in this chapter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中提到的*限制相机区域的边界相机*。
- en: '*Taking a closer look with zoom cameras* given in this chapter.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中提供的*通过缩放相机近距离观察*。
- en: Pinch-zoom camera functionality
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捏合缩放相机功能
- en: AndEngine includes a small list of "detector" classes which can be used in combination
    with scene touch events. This topic is going to cover the use of the `PinchZoomDetector`
    class in order to allow zooming of the camera by pressing two fingers on the display,
    moving them closer or further apart to adjust the zoom factor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 包含一系列“检测器”类，可以与场景触摸事件结合使用。本主题将介绍如何使用`PinchZoomDetector`类，以便通过在屏幕上按两指，并让它们靠近或分开来调整缩放因子，从而允许相机的缩放。
- en: Getting started…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始操作…
- en: Please refer to the class named `ApplyingPinchToZoom` in the code bundle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`ApplyingPinchToZoom`的类。
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Follow these steps for a walkthrough on setting up the pinch-to-zoom functionality.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作，以设置捏合缩放功能。
- en: 'The first thing we must do is implement the appropriate listeners into our
    class. Since we''ll be working with touch events, we''ll need to include the `IOnSceneTouchListener`
    interface. Additionally, we''ll need to implement the `IPinchZoomDetectorListener`
    interface to handle changes in the camera''s zoom factor pending touch events:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是将适当的监听器实现到我们的类中。由于我们将处理触摸事件，因此需要包含`IOnSceneTouchListener`接口。此外，我们还需要实现`IPinchZoomDetectorListener`接口，以处理相机缩放因子在等待触摸事件时的变化：
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `onCreateScene()` method of the `BaseGameActivity` class, set the `Scene`
    object''s touch listener to the `this` activity since we are letting the `BaseGameActivity`
    class implement the touch listener classes. We will also create and enable the
    `mPinchZoomDetector` object within this method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BaseGameActivity`类的`onCreateScene()`方法中，将`Scene`对象的触摸监听器设置为`this`活动，因为我们让`BaseGameActivity`类实现触摸监听器类。我们还将在此方法中创建并启用`mPinchZoomDetector`对象：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the implemented `onSceneTouchEvent()` method of the `BaseGameActivity` class,
    we must pass the touch events to the `mPinchZoomDetector` object:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BaseGameActivity`类的实现的`onSceneTouchEvent()`方法中，我们必须将触摸事件传递给`mPinchZoomDetector`对象：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will obtain the initial zoom factor of the `ZoomCamera` object when
    the `mPinchZoomDetector` object registers that a user is applying two fingers
    to the display. We will use the `onPinchZoomStarted()` method, which is implemented
    via the `IPinchZoomDetectorListener` interface:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，当`mPinchZoomDetector`对象检测到用户在屏幕上使用两指操作时，我们将获取`ZoomCamera`对象的初始缩放因子。我们将使用通过`IPinchZoomDetectorListener`接口实现的`onPinchZoomStarted()`方法：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we will make changes to the `ZoomCamera` object''s zoom factor in the
    event that a pinching motion is detected on the display. This code will be placed
    in both the `onPinchZoom()` and `onPinchZoomFinished()` methods:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在检测到屏幕上出现捏合动作时，我们将更改`ZoomCamera`对象的缩放因子。这段代码将放在`onPinchZoom()`和`onPinchZoomFinished()`方法中：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we are overriding the scene touch events which take place on
    our scene, passing the touch events to the `PinchZoomDetector` object, which will
    handle the zoom functionality of the `ZoomCamera` object. The following steps
    will guide us through the process of how pinch-zooming works. Because we're working
    with zoom factors in this activity, we'll need to use either a `ZoomCamera` class
    or a `SmoothCamera` class implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，我们覆盖了发生在我们场景上的场景触摸事件，将这些触摸事件传递给`PinchZoomDetector`对象，该对象将处理`ZoomCamera`对象的缩放功能。以下步骤将引导我们了解捏合缩放的工作原理。由于在此活动中我们将使用缩放因子，因此我们需要使用`ZoomCamera`类或`SmoothCamera`类的实现。
- en: In the first two steps for this recipe, we're implementing the required listeners
    and registering them to the `mScene` object and the `mPinchZoomDetector` object.
    Since the `ApplyingPinchToZoom` activity is implementing the listeners, we can
    pass `this`, which represents our `BaseGameActivity` class, to the `mScene` object
    as the touch listener. We can also pass this activity as the pinch detection listener.
    Once the pinch detector is created, we can enable or disable it by calling the
    `setEnabled(pSetEnabled)` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的第一步和第二步中，我们正在实现所需的监听器，并将它们注册到`mScene`对象和`mPinchZoomDetector`对象。由于`ApplyingPinchToZoom`活动正在实现监听器，我们可以将代表我们`BaseGameActivity`类的`this`传递给`mScene`对象作为触摸监听器。我们还可以将此活动作为捏合检测监听器。一旦创建了捏合检测器，我们可以通过调用`setEnabled(pSetEnabled)`方法来启用或禁用它。
- en: In step three, we are passing the `pSceneTouchEvent` object to the `onTouchEvent()`
    method of the pinch detector. Doing so will allow the pinch detector to obtain
    specific touch coordinates which will be used internally to calculate zoom factors
    based on finger positions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们将`pSceneTouchEvent`对象传递给捏合检测器的`onTouchEvent()`方法。这样做可以让捏合检测器获取特定的触摸坐标，这些坐标将在内部用于根据手指位置计算缩放因子。
- en: Upon pressing two fingers on the screen, the pinch detector will fire the code
    snippet displayed in step four. We must obtain the initial zoom factor of the
    camera at this point in order to properly offset the zoom factor when the touch
    coordinates change.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当在屏幕上按下两个手指时，捏合检测器将触发第四步中显示的代码片段。我们必须在此时获取相机的初始缩放因子，以便在触摸坐标改变时正确偏移缩放因子。
- en: The final step involves calculating the offset zoom factor and applying it to
    the `ZoomCamera` object. By multiplying the initial zoom factor by the zoom factor
    change calculated by the `PinchZoomDetector` object, we can successfully offset
    the zoom factor of the camera. Once we've calculated the value for our `newZoomFactor`
    object, we call `setZoomFactor(newZoomFactor)` in order to change the zoom level
    of our camera.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步涉及计算偏移缩放因子并将其应用于`ZoomCamera`对象。通过将初始缩放因子与`PinchZoomDetector`对象计算的缩放因子变化相乘，我们可以成功偏移相机的缩放因子。一旦我们计算了`newZoomFactor`对象的值，我们调用`setZoomFactor(newZoomFactor)`以改变我们相机的缩放级别。
- en: Containing the zoom factor within a specific range is as simple as adding an
    `if` statement, specifying the minimum and/or maximum zoom factors required for
    our needs. In this case, our camera cannot zoom out further than `0.5f` or zoom
    in closer than `1.5f`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将缩放因子限制在特定范围内只需添加一个`if`语句，指定我们需要的最大和/或最小缩放因子即可。在这种情况下，我们的相机不能缩放比`0.5f`更小，或者比`1.5f`更大。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Taking a closer look with zoom cameras* given in this chapter.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章提供了*使用缩放相机近距离观察*的内容。
- en: Stitching a background together
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拼接背景
- en: 'Although AndEngine''s `Scene` object allows us to set a background for the
    scene, this is not always a viable solution for our projects. In order to allow
    panning and zooming of the background, we can stitch together multiple texture
    regions and apply them directly to the scene as sprites. This topic is going to
    cover stitching two 800 x 480 texture regions together in order to create a larger
    pan-able and zoom-able background. The idea behind background stitching is to
    allow for portions of a scene to be displayed in smaller chunks. This gives us
    the opportunity to create smaller texture sizes as to not exceed the 1024 x 1024
    maximum texture size for most devices. Additionally, we can enable culling so
    that segments of the scene are not drawn when they aren''t displayed onscreen
    in order to improve performance. See the following figure for a look at the results:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AndEngine的`Scene`对象允许我们为场景设置背景，但这并不总是我们项目的可行解决方案。为了使背景能够进行平移和缩放，我们可以把多个纹理区域拼接在一起，并将其直接应用到场景中作为精灵。这一主题将要讲述如何将两个800
    x 480的纹理区域拼接在一起，以创建一个更大的可平移和可缩放的背景。背景拼接背后的想法是允许场景的部分以较小的块显示。这为我们提供了创建较小纹理尺寸的机会，以避免超过大多数设备1024
    x 1024的最大纹理尺寸限制。此外，我们可以启用剪裁，以便在屏幕上不显示场景部分时，不绘制它们，以提高性能。以下图展示了结果：
- en: '![Stitching a background together](img/8987OS_04_01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![拼接背景](img/8987OS_04_01.jpg)'
- en: Getting started...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用...
- en: Perform the recipe, *Pinch-zoom camera functionality*, which is given in this
    chapter for an understanding of how pinch-to-zoom works. Additionally, we must
    prepare two separate 800 x 480 images, similar to the previous figure in this
    recipe's introduction, in PNG format, then refer to the class named `StitchedBackground`
    in the code bundle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本章给出的食谱*捏合缩放相机功能*，以了解捏合缩放的工作原理。此外，我们还需要准备两张单独的800 x 480像素的图片，类似于本食谱引言中的前一个图像，以PNG格式保存，然后在代码包中引用名为`StitchedBackground`的类。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Background stitching is a simple concept which involves placing two or more
    sprites directly beside each other, on top of each other, or below each other
    in order to appear to have one single, large sprite. In this recipe, we''re going
    to cover how to do this in order to avoid the dreaded texture bleeding effect.
    Follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 背景拼接是一个简单的概念，它涉及将两个或更多的精灵直接并排放置，重叠放置，或者上下放置，以形成看似拥有一个单一的、大精灵的效果。在本食谱中，我们将介绍如何做到这一点，以避免可怕的纹理溢出效应。按照以下步骤操作：
- en: 'First of all, we need to create our `BuildableBitmapTextureAtlas` and `ITextureRegion`
    objects. It is very important that the texture atlas is the exact same size as
    our image files in order to avoid texture bleeding. Also, we must not include
    any padding or spacing during the build process of the texture atlas. The following
    code will create the left-hand side texture atlas and texture region, however
    the same code will apply for the right-hand side:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的`BuildableBitmapTextureAtlas`和`ITextureRegion`对象。非常重要的一点是，纹理图集的大小必须与我们的图片文件完全相同，以避免纹理溢出。同时，在构建纹理图集的过程中，我们绝不能包含任何填充或间隔。以下代码将创建左侧的纹理图集和纹理区域，同样的代码也适用于右侧：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the texture resources are in place, we can move to the `onPopulateScene()`
    method of the activity where we will create and apply the sprites to the `Scene`
    object:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦纹理资源就位，我们就可以移动到活动的`onPopulateScene()`方法中，在那里我们将创建并将精灵应用到`Scene`对象上：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Background stitching can be used in many different scenarios in order to avoid
    certain problems. These problems range from excessive texture sizes which lead
    to incompatibility on certain devices, static backgrounds which do not respond
    to changes in camera position or zoom factor, and performance issues to name a
    few. In this recipe, we're creating a large background which is created by stitching
    together two `Sprite` objects side-by-side, each representing a different `TextureRegion`
    object. The result is a large background which is double the size of the camera's
    width at 1600 x 480 pixels.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 背景拼接可以在许多不同的场景中使用，以避免某些问题。这些问题包括导致某些设备不兼容的过大纹理尺寸，不响应相机位置或缩放因子变化的静态背景，以及性能问题等。在本食谱中，我们创建了一个大背景，这是通过将两个`Sprite`对象并排放置拼接而成的，每个代表不同的`TextureRegion`对象。结果是形成一个大于相机宽度两倍的大背景，尺寸为1600
    x 480像素。
- en: In most cases when dealing with stitched backgrounds which allow scrolling of
    the scene, we'll need to enable some camera bounds in order to stop updating camera
    position if it attempts to exceed the background's area. We can use a `ZoomCamera`
    object to do this, setting the bounds to the predetermined size of the background.
    Since we're working with two PNG images, each 800 x 480 pixels stitched side-by-side,
    it's safe to say coordinates `(0,0)` to `(1600 x 480)` will suffice for the camera
    bounds.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理允许场景滚动的拼接背景的大多数情况下，我们将需要启用一些相机边界，以防止在相机试图超出背景区域时更新相机位置。我们可以使用`ZoomCamera`对象来实现这一点，将边界设置为背景预定的尺寸。由于我们处理的是两个各为800
    x 480像素的PNG图片并排拼接，可以肯定地说，坐标`(0,0)`到`(1600, 480)`足以作为相机边界。
- en: As stated in step one, there are a few rules we must follow when creating large-scale
    backgrounds with this approach. The image size must be exactly the same as the
    `BuildableBitmapTextureAtlas` texture atlas size! Failing to follow this rule
    will likely cause artifacts to occur between the sprites periodically, which is
    very distracting to the player. This also means that we should not include more
    than one `ITextureRegion` object in a `BuildableBitmapTextureAtlas` object that
    is meant for background stitching. Padding and spacing is also one of the features
    we should avoid in this case. However, following these rules, we are still able
    to apply the `TextureOptions.BILINEAR` texture filtering to the texture atlas
    and it will not cause issues.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一步所述，使用这种方法创建大型背景时，我们必须遵循一些规则。图像大小必须与`BuildableBitmapTextureAtlas`纹理图集大小完全相同！不遵循此规则可能会导致精灵之间周期性地出现伪影，这对玩家来说是非常分散注意力的。这也意味着我们不应该在用于背景拼接的`BuildableBitmapTextureAtlas`对象中包含超过一个`ITextureRegion`对象。在这种情况下，我们还应该避免使用填充和间距功能。然而，遵循这些规则，我们仍然可以对纹理图集应用`TextureOptions.BILINEAR`纹理过滤，并且不会导致问题。
- en: In step two, we continue on to create the `Sprite` objects. There's nothing
    special here; we simply create one `Sprite` object in a given position, then set
    up the next sprite directly beside the first. For backgrounds which are extremely
    large and diverse, this method of stitching textures together can help to dramatically
    reduce the performance cost of an application by allowing us to stop rendering
    smaller segments of a background which are no longer visible. This feature is
    called **culling**. See *Disabling rendering with entity culling* in [Chapter
    8](ch08.html "Chapter 8. Maximizing Performance"), *Maximizing Performance*, for
    more information on how to achieve this.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们继续创建`Sprite`对象。这里没有特别之处；我们只是在给定位置创建一个`Sprite`对象，然后在第一个旁边直接设置下一个精灵。对于极其庞大和多样的背景，将纹理拼接在一起的方法可以帮助显著降低应用程序的性能成本，允许我们停止渲染不再可见的背景较小部分。这个特性称为**剔除**。有关如何实现这一点，请参见[第8章](ch08.html
    "第8章.最大化性能")，*最大化性能*中的*通过实体剔除禁用渲染*。
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见 also（此处的"also"似乎是原文的残留，若不需要翻译请忽略）
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Designing Your Menu*.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章.使用实体工作")，*设计您的菜单*中，介绍*使用精灵让场景生动*。
- en: '*Taking a closer look with zoom cameras* given in this chapter.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节提供*通过缩放相机更近距离观察*。
- en: '*Pinch-zoom camera functionality* in this chapter.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节介绍*捏合缩放相机功能*。
- en: '*Disabling rendering with entity culling* in [Chapter 8](ch08.html "Chapter 8. Maximizing
    Performance"), *Maximizing Performance*.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章.最大化性能")，*最大化性能*中，介绍*通过实体剔除禁用渲染*。
- en: Applying a HUD to the camera
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向相机应用HUD。
- en: A **HUD** (**Heads-Up Display** ) can be a very useful component for even the
    simplest of games. The purpose of the HUD is to contain a set of buttons, text,
    or any other `Entity` object in order to supply the user with an interface. The
    HUD has two key points; the first being that the HUD's children will always be
    visible onscreen, regardless of whether or not the camera changes position. The
    second point is the fact that the HUD's children will always be shown in front
    of the scene's children. In this chapter, we're going to be applying a HUD to
    the camera in order to supply users with an interface during gameplay.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最简单的游戏，**HUD（抬头显示）**也可能是一个非常实用的组件。HUD的目的是包含一组按钮、文本或任何其他`Entity`对象，以便为用户提供界面。HUD有两个关键点：第一，无论相机是否改变位置，HUD的子对象始终会在屏幕上显示；第二，HUD的子对象始终会显示在场景子对象的前面。在本章中，我们将向相机应用HUD，以便在游戏过程中为用户提供界面。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the following code into the `onCreateEngineOptions()` method of any
    `BaseGameActivity` of your choice, substituting the camera type in this code snippet
    if necessary:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码导入您选择的任何`BaseGameActivity`的`onCreateEngineOptions()`方法中，如果需要，请替换此代码片段中的相机类型：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Working with a `HUD` class is generally a very easy task. The usefulness of
    a `HUD` class can range drastically depending on the type of game being created,
    but in any case, there are a few things we must know before deciding to use this
    class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HUD`类通常是一项非常简单的任务。根据所创建的游戏类型，`HUD`类的实用性可能会有很大差异，但无论如何，在决定使用这个类之前，我们必须了解一些事情：
- en: The `HUD` entities will not change positions upon camera movement. Once their
    position is defined, the entity will remain in that position onscreen unless otherwise
    set via `setPosition()`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HUD`实体在相机移动时不会改变位置。一旦定义了它们的位置，实体将保持在该屏幕位置，除非通过`setPosition()`方法进行设置。'
- en: The `HUD` entities will always appear on top of any `Scene` entity, regardless
    of z-index, order of application, or any other scenario.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HUD`实体将始终出现在任何`Scene`实体的顶部，无论z-index、应用顺序或任何其他场景如何。'
- en: Culling should *not* be applied to entities which are to be attached to the
    `HUD` class in any circumstance. Culling affects an `Entity` object on the `HUD`
    class the same way it would affect the `Entity` object on the `Scene` object,
    even though the `Entity` object does not appear to move off-screen. This will
    cause what seems like randomly disappearing `HUD` entities. Just don't do it!
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何情况下都不应将剔除应用于要附加到`HUD`类的实体。剔除以相同的方式影响`HUD`类上的`Entity`对象，就像它会影响`Scene`对象上的`Entity`对象一样，即使`Entity`对象似乎没有移出屏幕。这将导致看似随机消失的`HUD`实体。只是不要这么做！
- en: 'In the code found in the *How to do it...* section, we can see that it''s very
    easy to set up the `HUD` class. Creating and applying the `HUD` object to the
    camera can be done in as little as the following two lines of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何操作...*部分的代码中，我们可以看到设置`HUD`类非常简单。创建并应用`HUD`对象到相机只需以下两行代码即可完成：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From this point, we can treat the `HUD` object as if it were any other layer
    in our game in terms of applying entities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们可以将`HUD`对象视为游戏中任何其他层的实体应用。
- en: Applying a controller to the display
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将控制器应用于显示
- en: Depending on the type of game we are creating, there are many possible solutions
    for player interactivity. AndEngine includes two separate classes, one of which
    simulates a directional control pad called a `DigitalOnScreenControl`, the other
    which simulates a joystick called an `AnalogOnScreenControl`. This topic is going
    to introduce AndEngine's `AnalogOnScreenControl` class, but working with this
    class will give us enough info to use either controller.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们正在创建的游戏类型，玩家互动有许多可能的解决方案。AndEngine 包含两个独立的类，其中一个模拟方向控制板，称为`DigitalOnScreenControl`，另一个模拟摇杆，称为`AnalogOnScreenControl`。本主题将介绍
    AndEngine 的`AnalogOnScreenControl`类，但使用这个类将给我们足够的信息去使用任一控制器。
- en: Getting started...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始吧...
- en: 'This recipe requires two separate assets which will act as the base of the
    controller and the knob of the controller. Before moving on to the *How to do
    it...* section, please include an image called `controller_base.png` and `controller_knob.png`
    to the `assets/gfx` folder in a project of your choice. The images may look something
    like the following figure, with the base being 128 x 128 pixels and the knob being
    64 x 64 pixels:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要两个独立的资源，它们将作为控制器的基础和旋钮。在继续*如何操作...*部分之前，请将名为`controller_base.png`和`controller_knob.png`的图片包含到您选择的项目中的`assets/gfx`文件夹中。这些图片可能看起来像下面的图，基础为128
    x 128像素，旋钮为64 x 64像素：
- en: '![Getting started...](img/8987OS_04_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![开始吧...](img/8987OS_04_02.jpg)'
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once we've got the two necessary assets in place for our controller, we can
    start coding it. First of all, we can start by creating the `ITextureRegion` and
    `BuildableBitmapTextureAtlas` objects that will hold each of the controller's
    assets. No special steps are required for the controller texture atlas or texture
    regions; simply create them as we would for an ordinary sprite. As usual, do this
    in the `onCreateResources()` method of an activity of your choice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为控制器准备好了两个必要的资源，我们就可以开始编码了。首先，我们可以开始创建保存控制器资源的`ITextureRegion`和`BuildableBitmapTextureAtlas`对象。对于控制器纹理图集或纹理区域没有特殊步骤；像创建普通精灵一样创建它们。像往常一样，在您选择的活动中的`onCreateResources()`方法中完成此操作。
- en: 'Once the `ITextureRegion` objects have been coded and are ready for use within
    the activity, we can create the `AnalogOnScreenControl` class in the `onCreateScene()`
    method of our activity object as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`ITextureRegion`对象被编码并准备好在活动内使用，我们可以在活动对象的`onCreateScene()`方法中创建`AnalogOnScreenControl`类，如下所示：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we can see, a few of the parameters are no different from what we would define
    while creating a `Sprite` object. The first five parameters are self-explanatory.
    The sixth parameter `(0.1f)` is the "time between updates" parameter. This value
    controls how often the events within the `onControlChange()` method are fired.
    More CPU-intensive code may benefit from increased time between updates, while
    less complex code may have no problem with a very low update time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一些参数与我们创建`Sprite`对象时定义的参数并无不同。前五个参数是自解释的。第六个参数`(0.1f)`是“更新之间的时间”参数。这个值控制`onControlChange()`方法内的事件被触发的频率。对于CPU密集型代码，增加更新之间的时间可能有益，而对于复杂性较低的代码，非常低的更新时间可能没有问题。
- en: The last parameter we have to include in the controller's constructor is `IanalogOnScreenControlListener`,
    which handles events based on whether the controller was simply clicked or whether
    the controller is pressed and held in an offset position.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器构造函数中必须包含的最后一个参数是`IanalogOnScreenControlListener`，它处理基于控制器是被简单点击还是被按住并保持在一个偏移位置的事件。
- en: As we can see in the `onControlChange()` event, we can obtain the current position
    of the controllers knob via the `pValueX` and `pValueY` variables. These values
    contain the x and y offsets of the controller. In this recipe, we are using the
    x and y offsets of the knob to move the camera's position, also giving us an idea
    of how we can put these variables to use in order to move other entities such
    as a player's sprite.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`onControlChange()`事件中所见，我们可以通过`pValueX`和`pValueY`变量获取控制器旋钮的当前位置。这些值包含了控制器的x和y偏移量。在本示例中，我们使用旋钮的x和y偏移量来移动摄像头的位置，这也让我们了解到如何使用这些变量来移动其他实体，例如玩家的精灵。
- en: Coordinate conversion
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标转换
- en: Coordinate conversion can be very useful in situations where a `Scene` object
    relies on a number of entities to act as base layers for a game's sprites. It's
    not uncommon for games which contain many parents, each with their own set of
    children, to need to obtain a child's position relative to the `Scene` object
    at one point or another. This isn't a problem in situations where each of the
    layers remain at the same (0, 0) coordinates on the scene throughout the entire
    game. On the other hand, when our layers start to move around, child positions
    will move with the parent but their coordinates on the layer will remain the same.
    This topic is going to cover converting scene coordinates to local coordinates
    in order to allow nested entities to be properly positioned on the scene.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景对象依赖于多个实体作为游戏精灵的基础层的场景中，坐标转换可能非常有用。在包含许多父对象，每个父对象都有自己的子对象集合的游戏中，需要获取子对象相对于`Scene`对象的位置是常有的事。在所有层在整个游戏中始终保持相同的（0,
    0）坐标的情况下，这不是问题。另一方面，当我们的层开始移动时，子对象的位置会随父对象移动，但它们在层上的坐标保持不变。本主题将涵盖将场景坐标转换为局部坐标，以允许嵌套实体在场景上正确定位。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Import the following code to the `onCreateScene()` method of any `BaseGameActivity`
    of your choice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码导入你选择的任何`BaseGameActivity`的`onCreateScene()`方法中。
- en: 'The first step in this recipe is to create and apply a `Rectangle` object to
    the `Scene` object. This `Rectangle` object will act as the parent entity to another
    `Rectangle` object. We set its color to blue in order to differentiate between
    the two rectangles when they overlap since the parent `Rectangle` object will
    constantly be moving:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本方法的第一个步骤是创建一个`Rectangle`对象并将其应用到`Scene`对象上。这个`Rectangle`对象将作为另一个`Rectangle`对象的父实体。我们将它的颜色设置为蓝色，以便当两个矩形重叠时可以区分，因为父`Rectangle`对象将不断移动：
- en: '[PRE22]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will add the child `Rectangle` object to the first `Rectangle` object
    we had created. This `Rectangle` object will not move; instead, it will remain
    in the center of the screen while its parent continues to move around. This `Rectangle`
    object will be making use of coordinate conversion in order to hold its position:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将子`Rectangle`对象添加到我们先前创建的第一个`Rectangle`对象中。这个`Rectangle`对象不会移动；相反，它将保持在屏幕中心，而其父对象继续在周围移动。这个`Rectangle`对象将利用坐标转换来保持其位置：
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `onCreateScene()` method above creates a `Scene` object which contains two
    separate `Rectangle` entities. The first `Rectangle` entity will be attached directly
    to the `Scene` object. The second `Rectangle` entity will be attached to the first
    `Rectangle` entity. The first `Rectangle` entity, named `rectangleLayer`, will
    constantly be moving from left to right and right to left. Typically, this would
    cause its child's position to follow the same movement pattern, but in this recipe
    we're using coordinate conversion in order to allow the child `Rectangle` entity
    to remain still as its parent moves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`onCreateScene()`方法创建了一个包含两个独立`Rectangle`实体的`Scene`对象。第一个`Rectangle`实体将直接附加到`Scene`对象上。第二个`Rectangle`实体将附加到第一个`Rectangle`实体上。名为`rectangleLayer`的第一个`Rectangle`实体将会持续地从左向右和从右向左移动。通常，这会导致其子实体的位置跟随相同的移动模式，但在这个示例中，我们使用坐标转换，以允许子`Rectangle`实体在其父实体移动时保持静止。
- en: The `rectangle` object in this recipe includes two variables named `convertToMidSceneX`
    and `convertToMidSceneY`. These variables simply hold the position in `Scene`
    coordinates that we would like to convert the local coordinates to. As we can
    see, their coordinates are defined to the middle of the scene. Within the `onManagedUpdate()`
    method of the `rectangle` object, we then use the `rectangleLayer.convertSceneCoordinatesToLocalCoordinates(convertToMidSceneX,
    convertToMidSceneY)` method, passing the resulting coordinates to a float array.
    What this does is basically asks the `rectangleLayer` object, "Where is position
    x/y on the scene in your opinion?" Since the `rectangleLayer` object is attached
    directly to the `Scene` object, it can easily determine where specific `Scene`
    coordinates are as it relies on the native `Scene` coordinate system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`rectangle`对象包括两个名为`convertToMidSceneX`和`convertToMidSceneY`的变量。这些变量简单地保存了我们想要将局部坐标转换到的`Scene`坐标中的位置。正如我们所看到的，它们的坐标被定义在场景的中间。在`rectangle`对象的`onManagedUpdate()`方法中，我们然后使用`rectangleLayer.convertSceneCoordinatesToLocalCoordinates(convertToMidSceneX,
    convertToMidSceneY)`方法，将结果坐标传递给一个浮点数组。这样做的基本上是询问`rectangleLayer`对象：“在你看来，场景上的位置x/y在哪里？”由于`rectangleLayer`对象直接附加到`Scene`对象，它可以轻松地确定特定`Scene`坐标的位置，因为它依赖于原生的`Scene`坐标系统。
- en: When attempting to access the returned coordinates, we can access `convertedCoordinates[0]`
    to obtain the converted x coordinate and use `convertedCoordinates[1]` to obtain
    the converted y coordinate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试访问返回的坐标时，我们可以通过`convertedCoordinates[0]`获取转换后的x坐标，并使用`convertedCoordinates[1]`获取转换后的y坐标。
- en: On top of converting `Scene` to local `Entity` coordinates, we can also convert
    local `Entity` to `Scene` coordinates, touch event coordinates, camera coordinates,
    and a whole slew of other options. However, once we obtain a basic understanding
    of coordinate conversion, starting with this recipe, the rest of the conversion
    methods will seem very similar to one another.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Scene`坐标转换为局部`Entity`坐标的基础上，我们还可以将局部`Entity`坐标转换为`Scene`坐标、触摸事件坐标、摄像头坐标以及许多其他选项。然而，一旦我们从这个示例开始，对坐标转换有了基本的了解，其余的转换方法将看起来非常相似。
- en: Creating a split screen game
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个分屏游戏
- en: This recipe will introduce the `DoubleSceneSplitScreenEngine` class, most commonly
    used in games which allow multiple players to play their own instance of a game
    on each half of the display. The `DoubleSceneSplitScreenEngine` class allows us
    to provide each half of the device's display with its own `Scene` and `Camera`
    objects, giving us full control over what each half of the display will see.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将介绍`DoubleSceneSplitScreenEngine`类，该类通常用于允许多个玩家在显示器的每一半上玩他们自己的游戏实例的游戏中。`DoubleSceneSplitScreenEngine`类使我们能够为设备的显示器的每一半提供自己的`Scene`和`Camera`对象，从而让我们完全控制显示器每一半将看到的内容。
- en: Getting started…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用…
- en: Please refer to the class named `SplitScreenExample` in the code bundle.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`SplitScreenExample`的类。
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Setting up our game to allow two separate `Scene` objects requires us to take
    a slightly different approach when initially setting up the `BaseGameActivity`
    class. However, once we have set up the separate `Scene` objects, managing them
    is actually very similar to if we were dealing with only one scene, aside from
    the fact that we've only got half of the original display space per scene. Perform
    the following steps to gain an understanding of how to set up the `DoubleSceneSplitScreenEngine`
    class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的游戏支持两个独立的`Scene`对象，我们需要在最初设置`BaseGameActivity`类时采取略有不同的方法。然而，一旦我们设置好了独立的`Scene`对象，管理它们实际上与只处理一个场景非常相似，除了每个场景只有原始显示空间的一半这一点。执行以下步骤以了解如何设置`DoubleSceneSplitScreenEngine`类。
- en: 'The first thing we must take care of is decreasing the `WIDTH` value by half,
    since each camera will require half of the device''s display. Attempting to fit
    800 pixels in width onto each camera will cause noticeable skewing of objects
    on each scene. While we are declaring variables, we will also set up two `Scene`
    objects and two `Camera` objects which will be needed for the `DoubleSceneSplitScreenEngine`
    implementation:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要将`WIDTH`值减半，因为每个相机将需要设备显示的一半空间。试图将800像素的宽度适配到每个相机将导致每个场景上的对象出现明显的扭曲。在声明变量时，我们还将设置两个`Scene`对象和两个`Camera`对象，这些将用于`DoubleSceneSplitScreenEngine`的实现：
- en: '[PRE24]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we will create two separate `SmoothCamera` objects in the `onCreateEngineOptions()`
    method of the `BaseGameActivity` class. These cameras will be used for displaying
    separate views for each half of the display. In this recipe, we''re applying automatic
    zooming in order to show the results of `DoubleSceneSplitScreenEngine`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在`BaseGameActivity`类的`onCreateEngineOptions()`方法中创建两个独立的`SmoothCamera`对象。这些相机将用于为显示的每一半提供独立的视图。在这个示例中，我们应用了自动缩放，以展示`DoubleSceneSplitScreenEngine`的结果：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One more task to take care of in the `onCreateEngineOptions()` method of our
    `BaseGameActivity` class is to create the `EngineOptions` object, passing the
    `mCameraOne` object as the main camera. Additionally, chances are the scenes might
    require simultaneous touch events, so we will enable multitouch as well:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们`BaseGameActivity`类的`onCreateEngineOptions()`方法中还需要处理一个任务，就是创建`EngineOptions`对象，将`mCameraOne`对象作为主相机传递。另外，场景可能需要同时处理触摸事件，因此我们也将启用多点触控：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the fourth step, we will override the `BaseGameActivity` class'' `onCreateEngine()`
    method in order to create a `DoubleSceneSplitScreenEngine` object rather than
    the default `Engine` object:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四步中，我们将覆盖`BaseGameActivity`类的`onCreateEngine()`方法，以创建一个`DoubleSceneSplitScreenEngine`对象，而不是默认的`Engine`对象：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Moving onto the `onCreateScene()` method, we will create the two `Scene` objects,
    set them up how we choose, and finally set each `Scene` object to the `DoubleSceneSplitScreenEngine`
    object:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`onCreateScene()`方法中，我们将创建两个`Scene`对象，按照我们的选择设置它们，并最终将每个`Scene`对象设置到`DoubleSceneSplitScreenEngine`对象中：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that both of our `Camera` objects are set up and both of our `Scene` objects
    are set up and attached to the engine, we can start attaching `Entity` objects
    to each `Scene` object as we see fit, simply by specifying which `Scene` object
    to attach to as usual. This code should be placed within the `onPopulateScene()`
    method of the `BaseGameActivity` class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们的两个`Camera`对象已经设置好了，两个`Scene`对象也已经设置好并附加到引擎上，我们可以开始根据需要将`Entity`对象附加到每个`Scene`对象上，只需像往常一样指定要附加到的`Scene`对象。这段代码应该放在`BaseGameActivity`类的`onPopulateScene()`方法中：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: When working with the `DoubleSceneSplitScreenEngine` class, we can assume that
    our project will need two of everything if we are setting up for a multiplayer
    game. More specifically, we need two `Scene` objects for each half of the screen
    as well as two `Camera` objects. Due to the fact that we are splitting the viewing
    area of each `Camera` object in half, we shall reduce the `WIDTH` value of our
    cameras by half. Camera dimensions of 400 pixels in width by 480 pixels in height
    are reasonable in most cases, which allow us to keep a proper perspective on entities
    as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DoubleSceneSplitScreenEngine`类时，如果我们要为多人游戏进行设置，可以假设我们的项目将需要两套所有的东西。更具体地说，我们需要为屏幕的每一半各设置两个`Scene`对象以及两个`Camera`对象。由于我们将每个`Camera`对象的观看区域一分为二，我们将把相机的`WIDTH`值减半。大多数情况下，400像素宽和480像素高的相机尺寸是合理的，这使我们能够保持实体的适当透视。
- en: In the second step, we are setting up two `SmoothCamera` objects which will
    automatically zoom in and out of their respective scenes in order to supply a
    visual result to this recipe. However, the `DoubleSceneSplitScreenEngine` class
    can use any variation of the `Camera` object, including the most basic type without
    causing any issue.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们设置了两个`SmoothCamera`对象，它们将自动对各自场景进行放大和缩小，以为此食谱提供视觉结果。然而，`DoubleSceneSplitScreenEngine`类可以使用任何`Camera`对象的变体，包括最基本类型而不会导致任何问题。
- en: In the third step, we're continuing on to create the `EngineOptions` object.
    We supply the `mCameraOne` object as the `pCamera` parameter in the `EngineOptions`
    constructor, just as we would in any ordinary instance. Additionally, we are enabling
    multitouch in the `EngineOptions` object in order to allow simultaneous touch
    events to register for each `Scene` object. Ignoring the multitouch setup will
    result in each scene having to wait until the other scene is not being pressed
    down on before it can register touch events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们继续创建`EngineOptions`对象。我们提供了`mCameraOne`对象作为`EngineOptions`构造函数中的`pCamera`参数，就像我们在任何普通实例中所做的那样。此外，我们在`EngineOptions`对象中启用了多点触控，以允许同时为每个`Scene`对象注册触摸事件。忽略多点触控设置将导致每个场景必须等待另一个场景没有被按下时才能注册触摸事件。
- en: In step four, we create the `DoubleSceneSplitScreenEngine` object, passing in
    the `pEngineOptions` parameter created in the previous step as well as the second
    `Camera` object—`mCameraTwo`. At this point in code, we've now got both of our
    cameras registered to the engine; the first was registered within the `EngineOptions`
    object, and the second passed as a parameter to the `DoubleSceneSplitScreenEngine`
    class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们创建了`DoubleSceneSplitScreenEngine`对象，传入上一步创建的`pEngineOptions`参数以及第二个`Camera`对象—`mCameraTwo`。在代码的这个阶段，我们已经将两个摄像头注册到引擎中；第一个是在`EngineOptions`对象中注册的，第二个作为参数传递给`DoubleSceneSplitScreenEngine`类。
- en: Step five includes the `onCreateScene()` method of the `BaseGameActivity` class,
    where we will create and set up each of the two `Scene` objects how we would like.
    At the most basic level, this involves creating the `Scene` objects, enabling
    and setting up or disabling the scene's background, setting the scene's user data
    to store its respective camera, and finally passing the `Scene` object to our
    `mEngine` object. While the second `Scene` object requires us to call the `setSecondScene(mSceneTwo)`
    method on our `mEngine` object, the `mSceneOne` object is passed to the `Engine`
    object as in any `BaseGameActivity`; in the `pOnCreateSceneCallback.onCreateSceneFinished(mSceneOne)`
    method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步包括`BaseGameActivity`类的`onCreateScene()`方法，在这里我们将创建并设置两个`Scene`对象。在最基本的层面上，这涉及到创建`Scene`对象，启用并设置或禁用场景的背景，将场景的用户数据设置为存储其相应的摄像头，并最终将`Scene`对象传递给我们的`mEngine`对象。虽然第二个`Scene`对象需要我们调用`mEngine`对象的`setSecondScene(mSceneTwo)`方法，但`mSceneOne`对象是像在任何`BaseGameActivity`中一样传递给`Engine`对象的；在`pOnCreateSceneCallback.onCreateSceneFinished(mSceneOne)`方法中。
- en: In the sixth step, we are now "out of the woods", so to speak. At this point,
    we are finished setting up the engine, scenes, and cameras and we can now start
    to populate each scene however we'd like. The possibilities are quite extensive
    in terms of what we can do at this point, including using the second scene as
    a mini-map, a view for a multiplayer game, an alternative perspective on the first
    scene, and much more. Selecting which `Scene` object to attach an `Entity` object
    to at this point would be as simple as calling either `mSceneOne.attachChild(pEntity)`
    or `mSceneTwo.attachChild(pEntity)`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六步中，我们可以说已经“走出困境”。在这一点上，我们已经完成了引擎、场景和摄像头的设置，现在可以开始按照我们的喜好填充每个场景。在这一点上，我们可以做的事情的可能性非常广泛，包括将第二个场景用作小地图、多人游戏的视角、对第一个场景的另一种视角等等。此时，选择要附加`Entity`对象的`Scene`对象会非常简单，只需调用`mSceneOne.attachChild(pEntity)`或`mSceneTwo.attachChild(pEntity)`即可。
