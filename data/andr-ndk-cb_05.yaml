- en: Chapter 5. Android Native Application API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. Android本地应用程序API
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating a native activity with the native_activity.h interface
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用native_activity.h接口创建本地活动
- en: Creating a native activity with the Android native app glue
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android本地应用程序胶水创建本地活动
- en: Managing native windows at Android NDK
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android NDK中管理本地窗口
- en: Detecting and handling input events at Android NDK
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android NDK中检测和处理输入事件
- en: Accessing sensors at Android NDK
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android NDK中访问传感器
- en: Managing assets at Android NDK
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android NDK中管理资产
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'Thanks to the Android native application APIs, it is possible to write an Android
    application with pure native code since Android API level 9 (Android 2.3, Gingerbread).
    That is, not a single line of Java code is needed. The Android native APIs are
    defined in several header files under the `<NDK root>/platforms/android-<API level>/arch-arm/usr/include/android/`
    folder. Based on the features provided by the functions defined in these header
    files, they can be grouped as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Android本地应用程序API，从Android API级别9（Android 2.3，姜饼）起，就有可能用纯本地代码编写Android应用程序。也就是说，不需要任何Java代码。Android本地API在`<NDK
    root>/platforms/android-<API level>/arch-arm/usr/include/android/`文件夹下的几个头文件中定义。根据这些头文件中定义的函数提供的功能，它们可以分为以下几类：
- en: 'Activity lifecycle management:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动生命周期管理：
- en: '`native_activity.h`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native_activity.h`'
- en: '`looper.h`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`looper.h`'
- en: 'Windows management:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口管理：
- en: '`rect.h`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rect.h`'
- en: '`window.h`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.h`'
- en: '`native_window.h`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native_window.h`'
- en: '`native_window_jni.h`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native_window_jni.h`'
- en: 'Input (including key and motion events) and sensor events:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入（包括按键和动作事件）和传感器事件：
- en: '`input.h`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input.h`'
- en: '`keycodes.h`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keycodes.h`'
- en: '`sensor.h`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor.h`'
- en: 'Assets, configuration, and storage management:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产、配置和存储管理：
- en: '`configuration.h`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configuration.h`'
- en: '`asset_manager.h`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asset_manager.h`'
- en: '`asset_manager_jni.h`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asset_manager_jni.h`'
- en: '`storage_manager.h`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_manager.h`'
- en: '`obb.h`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obb.h`'
- en: In addition, Android NDK also provides a static library named **native app glue**
    to help create and manage native activities. The source code of this library can
    be found under the `sources/android/native_app_glue/` directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Android NDK还提供了一个名为**本地应用程序胶水**的静态库，以帮助创建和管理本地活动。该库的源代码可以在`sources/android/native_app_glue/`目录下找到。
- en: In this chapter, we will first introduce the creation of a native activity with
    the simple callback model provided by `native_acitivity.h`, and the more complicated
    but flexible two-threaded model enabled by the native app glue library. We will
    then discuss window management at Android NDK, where we will draw something on
    the screen from the native code. Input events handling and sensor accessing are
    introduced next. Lastly, we will introduce asset management, which manages the
    files under the `assets` folder of our project. Note that the APIs covered in
    this chapter can be used to get rid of the Java code completely, but we don't
    have to do so. The *Managing assets at Android NDK* recipe provides an example
    of using the asset management API in a mixed-code Android project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先会介绍使用`native_acitivity.h`提供的简单回调模型创建本地活动，以及本地应用程序胶水库支持的更复杂但灵活的两个线程模型。然后，我们将讨论在Android
    NDK中的窗口管理，我们将在本地代码中在屏幕上绘制内容。接下来介绍输入事件处理和传感器访问。最后，我们将介绍资产管理，它管理我们项目`assets`文件夹下的文件。请注意，本章涵盖的API可以完全摆脱Java代码，但我们不必这样做。《在Android
    NDK中管理资产》一节提供了一个在混合代码Android项目中使用资产管理API的示例。
- en: Before we start, it is important to keep in mind that although no Java code
    is needed in a native activity, the Android application still runs on Dalvik VM,
    and a lot of Android platform features are accessed through JNI. The Android native
    application API just hides the Java world for us.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要牢记，尽管在本地活动中不需要Java代码，但Android应用程序仍然在Dalvik VM上运行，许多Android平台功能是通过JNI访问的。Android本地应用程序API只是为我们隐藏了Java世界。
- en: Creating a native activity with the native_activity.h interface
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用native_activity.h接口创建本地活动
- en: The Android native application API allows us to create a native activity, which
    makes writing Android apps in pure native code possible. This recipe introduces
    how to write a simple Android application with pure C/C++ code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Android本地应用程序API允许我们创建本地活动，这使得用纯本地代码编写Android应用程序成为可能。本节介绍如何使用纯C/C++代码编写简单的Android应用程序。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Readers are expected to have basic understanding of how to invoke JNI functions.
    [Chapter 2](ch02.html "Chapter 2. Java Native Interface"), *Java Native Interface*,
    covers JNI in detail and readers are recommended to read the chapter or at least
    the following recipes before going through the current one:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 期望读者对如何调用 JNI 函数有基本了解。[第2章](ch02.html "第2章。Java本地接口")，*Java Native Interface*
    详细介绍了 JNI，建议在阅读当前部分之前至少阅读该章节或以下内容：
- en: '*Manipulating strings in Android NDK*'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在安卓 NDK 中操作字符串*'
- en: '*Calling instance and static methods in NDK*'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 NDK 中调用实例和静态方法*'
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps to create a simple Android NDK application without a single
    line of Java code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个没有一行 Java 代码的简单安卓 NDK 应用程序的以下步骤：
- en: Create an Android application named `NativeActivityOne`. Set the package name
    as `cookbook.chapter5.nativeactivityone`. Please refer to the *Loading native
    libraries and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `NativeActivityOne` 的安卓应用程序。将包名设置为 `cookbook.chapter5.nativeactivityone`。如果你需要更详细的说明，请参考
    [第2章](ch02.html "第2章。Java本地接口")，*Java Native Interface* 中的 *加载本地库和注册本地方法* 部分。
- en: Right-click on the `NativeActivityOne` project, select **Android Tools** | **Add
    Native Support**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `NativeActivityOne` 项目，选择 **Android Tools** | **添加本地支持**。
- en: 'Change the `AndroidManifest.xml` file as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更改 `AndroidManifest.xml` 文件：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We should ensure that the following are set correctly in the preceding file:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该确保在前一个文件中正确设置以下内容：
- en: The activity name must be set to `android.app.NativeActivity`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动名称必须设置为 `android.app.NativeActivity`。
- en: The value of the `android.app.lib_name` metadata must be set to the native module
    name without the `lib` prefix and `.so` suffix.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.lib_name` 元数据的值必须设置为本地模块名称，不带 `lib` 前缀和 `.so` 后缀。'
- en: '`android:hasCode` needs to be set to `true`, which indicates that the application
    contains code. Note that the documentation in `<NDK root>/docs/NATIVE-ACTIVITY.HTML`
    gives an example of the `AndroidManifest.xml` file with `android:hasCode` set
    to `false`, which will not allow the application to start.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:hasCode` 需要设置为 `true`，表示应用程序包含代码。注意 `<NDK 根目录>/docs/NATIVE-ACTIVITY.HTML`
    中的文档提供了一个将 `android:hasCode` 设置为 `false` 的 `AndroidManifest.xml` 文件示例，这将不允许应用程序启动。'
- en: 'Add two files named `NativeActivityOne.cpp` and `mylog.h` under the `jni` folder.
    The `ANativeActivity_onCreate` method should be implemented in `NativeActivityOne.cpp`.
    The following is an example of the implementation:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加两个名为 `NativeActivityOne.cpp` 和 `mylog.h` 的文件。`ANativeActivity_onCreate`
    方法应该在 `NativeActivityOne.cpp` 中实现。以下是实现的一个示例：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the `Android.mk` file under the `jni` folder:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni` 文件夹下添加 `Android.mk` 文件：
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Build the Android application and run it on an emulator or a device. Start
    a terminal and display the logcat output using the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建安卓应用程序并在模拟器或设备上运行。启动一个终端并使用以下命令显示 logcat 输出：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can use the logcat view at Eclipse to see the logcat output.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 Eclipse 中的 logcat 视图来查看 logcat 输出。
- en: 'When the application starts, you should be able to see the following logcat
    output:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序启动时，你应该能够看到以下 logcat 输出：
- en: '![How to do it…](img/1505_05_01.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_05_01.jpg)'
- en: As shown in the screenshot, a few Android activity lifecycle callback functions
    are executed. We can manipulate the phone to cause other callbacks being executed.
    For example, long pressing the home button and then pressing the back button will
    cause the `onWindowFocusChanged` callback to be executed.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如截图所示，执行了几个安卓活动生命周期回调函数。我们可以操作手机以执行其他回调。例如，长按主页按钮然后按返回按钮将导致 `onWindowFocusChanged`
    回调执行。
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In our example, we created a simple, "pure" native application to output logs
    when the Android framework calls into the callback functions defined by us. The
    "pure" native application is not really pure native. Although we did not write
    a single line of Java code, the Android framework still runs some Java code on
    Dalvik VM.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个简单的“纯”本地应用程序，当安卓框架调用我们定义的回调函数时输出日志。"纯"本地应用程序实际上并不是完全本地化的。尽管我们没有编写一行
    Java 代码，安卓框架仍然在 Dalvik VM 上运行一些 Java 代码。
- en: Android framework provides an `android.app.NativeActivity.java` class to help
    us create a "native" activity. In a typical Java activity, we extend `android.app.Activity`
    and overwrite the activity lifecycle methods. `NativeActivity` is also a subclass
    of `android.app.Activity` and does similar things. At the start of a native activity,
    `NativeActivity.java` will call `ANativeActivity_onCreate`, which is declared
    in `native_activity.h` and implemented by us. In the `ANativeActivity_onCreate`
    method, we can register our callback methods to handle activity lifecycle events
    and user inputs. At runtime, `NativeActivity` will invoke these native callback
    methods when the corresponding events occurred.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Android框架提供了一个`android.app.NativeActivity.java`类，帮助我们创建一个“本地”活动。在一个典型的Java活动中，我们扩展`android.app.Activity`并覆盖活动生命周期方法。`NativeActivity`也是`android.app.Activity`的一个子类，做类似的事情。在本地活动的开始，`NativeActivity.java`将调用`ANativeActivity_onCreate`，这在`native_activity.h`中声明，并由我们实现。在`ANativeActivity_onCreate`方法中，我们可以注册我们的回调方法来处理活动生命周期事件和用户输入。在运行时，`NativeActivity`将在相应事件发生时调用这些本地回调方法。
- en: In a word, `NativeActivity` is a wrapper that hides the managed Android Java
    world for our native code, and exposes the native interfaces defined in `native_activity.h`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`NativeActivity`是一个封装，它为我们的本地代码隐藏了管理的Android Java世界，并公开了`native_activity.h`中定义的本地接口。
- en: '**The ANativeActivity data structure**: Every callback method in the native
    code accepts an instance of the `ANativeActivity` structure. Android NDK defines
    the `ANativeActivity` data structure in `native_acitivity.h` as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ANativeActivity`数据结构**：本地代码中的每个回调方法都接受一个`ANativeActivity`结构的实例。Android NDK在`native_acitivity.h`中定义了`ANativeActivity`数据结构，如下所示：'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The various attributes of the preceding code are explained as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的各种属性解释如下：
- en: '`callbacks`: It is a data structure that defines all the callbacks that the
    Android framework will invoke with the main UI thread.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callbacks`：这是一个定义了Android框架将在主UI线程中调用的所有回调的数据结构。'
- en: '`vm`: It is the application process'' global Java VM handle. It is used in
    some JNI functions.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vm`：它是应用程序进程的全局Java VM句柄。它被用于某些JNI函数中。'
- en: '`env`: It is a `JNIEnv` interface pointer. `JNIEnv` is used through local storage
    data (refer to the *Manipulating strings in Android NDK* recipe in [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, for more details),
    so this field is only accessible through the main UI thread.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：这是一个`JNIEnv`接口指针。`JNIEnv`通过局部存储数据使用（更多详情请参考[第2章](ch02.html "第2章。Java
    Native接口")中的*在Android NDK中操作字符串*食谱，*Java Native接口*），因此这个字段只能通过主UI线程访问。'
- en: '`clazz`: It is a reference to the `android.app.NativeActivity` object created
    by the Android framework. It can be used to access fields and methods in the `android.app.NativeActivity`
    Java class. In our code, we accessed the `toString` method of `android.app.NativeActivity`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clazz`：这是由Android框架创建的`android.app.NativeActivity`对象的引用。它可以用来访问`android.app.NativeActivity`
    Java类中的字段和方法。在我们的代码中，我们访问了`android.app.NativeActivity`的`toString`方法。'
- en: '`internalDataPath`: It is the internal data directory path for the application.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internalDataPath`：它是应用程序的内部数据目录路径。'
- en: '`externalDataPath`: It is the external data directory path for the application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalDataPath`：它是应用程序的外部数据目录路径。'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`internalDataPath` and `externalDataPath` are `NULL` at Android 2.3.x. This
    is a known bug and has been fixed since Android 3.0\. If we are targeting devices
    lower than Android 3.0, then we need to find other ways to get the internal and
    external data directories.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`internalDataPath`和`externalDataPath`在Android 2.3.x版本中是`NULL`。这是一个已知的错误，从Android
    3.0开始已经修复。如果我们针对的是低于Android 3.0的设备，那么我们需要寻找其他方法来获取内部和外部数据目录。'
- en: '`sdkVersion`: It is the Android platform''s SDK version code. Note that this
    refers to the version of the device/emulator that runs the app, not the SDK version
    used in our development.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdkVersion`：这是Android平台的SDK版本号。注意，这指的是运行应用的设备/模拟器的版本，而不是我们开发中使用的SDK版本。'
- en: '`instance`: It is not used by the framework. We can use it to store user-defined
    data and pass it around.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance`：框架不使用它。我们可以用它来存储用户定义的数据并在需要时传递。'
- en: '`assetManager`: It is the a pointer to the app''s instance of the asset manager.
    We will need it to access `assets` data. We will discuss it in more detail in
    the *Managing assets at Android NDK* recipe of this chapter.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assetManager`：这是指向应用程序资源管理器实例的指针。我们需要它来访问`assets`数据。我们将在本章的*在Android NDK中管理资源*食谱中详细讨论它。'
- en: There's more…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: The `native_activity.h` interface provides a simple single thread callback mechanism,
    which allows us to write an activity without Java code. However, this single thread
    approach infers that we must quickly return from our native callback methods.
    Otherwise, the application will become unresponsive to user actions (for example,
    when we touch the screen or press the **Menu** button, the app does not respond
    because the GUI thread is busy executing the callback function).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`native_activity.h`接口提供了一个简单的单线程回调机制，它允许我们编写不涉及Java代码的活动。但是，这种单线程方法意味着我们必须快速从本地回调方法中返回。否则，应用程序将无法响应用户操作（例如，当我们触摸屏幕或按下**菜单**按钮时，应用无法响应，因为GUI线程正忙于执行回调函数）。'
- en: A way to solve this issue is to use multiple threads. For example, many games
    take a few seconds to load. We will need to offload the loading to a background
    thread, so that the UI can display the loading progress and be responsive to user
    inputs. Android NDK comes with a static library named `android_native_app_glue`
    to help us in handling such cases. The details of this library are covered in
    the *Creating a native activity with the Android native app glue* recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用多线程。例如，许多游戏需要几秒钟来加载。我们需要将加载工作放到后台线程中，这样UI就可以显示加载进度并响应用户输入。Android
    NDK附带一个名为`android_native_app_glue`的静态库，以帮助我们处理此类情况。这个库的细节在*使用Android本地应用胶水创建本地活动*的食谱中有所介绍。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A similar problem exists at Java activity. For example, if we write a Java activity
    that searches the entire device for pictures at `onCreate`, the application will
    become unresponsive. We can use `AsyncTask` to search and load pictures in the
    background, and let the main UI thread display a progress bar and respond to user
    inputs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Java活动中也存在类似的问题。例如，如果我们编写一个在`onCreate`中搜索整个设备图片的Java活动，应用程序将会无响应。我们可以使用`AsyncTask`在后台搜索和加载图片，并让主UI线程显示进度条并响应用户输入。
- en: Creating a native activity with the Android native app glue
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android本地应用胶水创建本地活动
- en: The previous recipe described how the interface defined in `native_activity.h`
    allows us to create native activity. However, all the callbacks defined are invoked
    with the main UI thread, which means we cannot do heavy processing in the callbacks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个食谱描述了`native_activity.h`中定义的接口如何让我们创建本地活动。然而，所有定义的回调都是在主UI线程中调用的，这意味着我们不能在回调中进行繁重的处理。
- en: Android SDK provides `AsyncTask`, `Handler`, `Runnable`, `Thread`, and so on,
    to help us handle things in the background and communicate with the main UI thread.
    Android NDK provides a static library named `android_native_app_glue` to help
    us execute callback functions and handle user inputs in a separate thread. This
    recipe will discuss the `android_native_app_glue` library in detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK提供了`AsyncTask`、`Handler`、`Runnable`、`Thread`等，帮助我们后台处理事情并与主UI线程通信。Android
    NDK提供了一个名为`android_native_app_glue`的静态库，以帮助我们在单独的线程中执行回调函数并处理用户输入。本食谱将详细讨论`android_native_app_glue`库。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `android_native_app_glue` library is built on top of the `native_activity.h`
    interface. Therefore, readers are recommended to read the *Creating a native activity
    with the native_activity.h interface* recipe before going through this one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`android_native_app_glue`库是建立在`native_activity.h`接口之上的。因此，建议读者在阅读这个食谱之前先阅读*使用native_activity.h接口创建本地活动*的食谱。'
- en: How to do it…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps create a simple Android NDK application based on the `android_native_app_glue`
    library:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤基于`android_native_app_glue`库创建一个简单的Android NDK应用程序：
- en: Create an Android application named `NativeActivityTwo`. Set the package name
    as `cookbook.chapter5.nativeactivitytwo`. Please refer to the *Loading native
    libraries and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NativeActivityTwo`的Android应用程序。将包名设置为`cookbook.chapter5.nativeactivitytwo`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章. Java Native Interface")中的*加载本地库和注册本地方法*食谱，*Java Native Interface*。
- en: Right-click on the `NativeActivityTwo` project, select **Android Tools** | **Add
    Native Support**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`NativeActivityTwo`项目，选择**Android Tools** | **添加本地支持**。
- en: 'Change the `AndroidManifest.xml` file as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`AndroidManifest.xml`文件如下：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add two files named `NativeActivityTwo.cpp` and `mylog.h` under the `jni` folder.
    `NativeActivityTwo.cpp` is shown as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加两个名为`NativeActivityTwo.cpp`和`mylog.h`的文件。以下是`NativeActivityTwo.cpp`的代码：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the `Android.mk` file under the `jni` folder:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`目录下添加`Android.mk`文件：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Build the Android application and run it on an emulator or device. Start a
    terminal and display the logcat output by using the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Android应用程序并在模拟器或设备上运行。启动一个终端并使用以下命令显示logcat输出：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the application starts, you should be able to see the following logcat
    output and the device screen will shows a black screen:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序启动时，你应该能够看到以下logcat输出，并且设备屏幕将显示一个黑屏：
- en: '![How to do it…](img/1505_05_02.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_05_02.jpg)'
- en: 'On pressing the back button, the following output will be shown:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按下返回键时，将显示以下输出：
- en: '![How to do it…](img/1505_05_03.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_05_03.jpg)'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是…
- en: This recipe demonstrates how the `android_native_app_glue` library is used to
    create a native activity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了如何使用`android_native_app_glue`库创建一个本地活动。
- en: 'The following steps should be followed to use the `android_native_app_glue`
    library:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`android_native_app_glue`库应遵循以下步骤：
- en: Implement a function named `android_main`. This function should implement an
    event loop, which will poll for events continuously. This method will run in the
    background thread created by the library.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个名为`android_main`的函数。这个函数应该实现一个事件循环，持续地轮询事件。这个方法将在库创建的后台线程中运行。
- en: Two event queues are attached to the background thread by default, including
    the activity lifecycle event queue and the input event queue. When polling events
    using the looper created by the library, you can identify where the event is coming
    from, by checking the returned identifier (either `LOOPER_ID_MAIN` or `LOOPER_ID_INPUT`).
    It is also possible to attach additional event queues to the background thread.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，后台线程附带了两个事件队列，包括活动生命周期事件队列和输入事件队列。当使用库创建的looper轮询事件时，你可以通过检查返回的标识符（`LOOPER_ID_MAIN`或`LOOPER_ID_INPUT`）来确定事件来自哪里。也可以将附加的事件队列附加到后台线程。
- en: When an event is returned, the data pointer will point to an `android_poll_source`
    data structure. We can call the process function of this structure. The process
    is a function pointer, which points to `android_app->onAppCmd` for activity lifecycle
    events, and `android_app->onInputEvent` for input events. We can provide our own
    processing functions and direct the corresponding function pointers to these functions.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当返回一个事件时，数据指针将指向一个`android_poll_source`数据结构。我们可以调用这个结构的process函数。这个过程是一个函数指针，对于活动生命周期事件，它指向`android_app->onAppCmd`；对于输入事件，它指向`android_app->onInputEvent`。我们可以提供自己的处理函数，并将相应的函数指针指向这些函数。
- en: In our example, we implement a simple function named `handle_activity_lifecycle_events`
    and point the `android_app->onAppCmd` function pointer to it. This function simply
    prints the `cmd` value and the user data passed along with the `android_app` data
    structure. `cmd` is defined in `android_native_app_glue.h` as an `enum`. For example,
    when the app starts, the `cmd` values are `10`, `11`, `0`, `1`, and `6`, which
    correspond to `APP_CMD_START`, `APP_CMD_RESUME`, `APP_CMD_INPUT_CHANGED`, `APP_CMD_INIT_WINDOW`,
    and `APP_CMD_GAINED_FOCUS` respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们实现了一个名为`handle_activity_lifecycle_events`的简单函数，并将`android_app->onAppCmd`函数指针指向它。这个函数只是简单地打印`cmd`值以及与`android_app`数据结构一起传递的用户数据。`cmd`在`android_native_app_glue.h`中定义为枚举。例如，当应用启动时，`cmd`值为`10`、`11`、`0`、`1`和`6`，分别对应于`APP_CMD_START`、`APP_CMD_RESUME`、`APP_CMD_INPUT_CHANGED`、`APP_CMD_INIT_WINDOW`和`APP_CMD_GAINED_FOCUS`。
- en: '**android_native_app_glue Library Internals**: The source code of the `android_native_app_glue`
    library can be found under the `sources/android/native_app_glue` folder of Android
    NDK. It only consists of two files, namely `android_native_app_glue.c` and `android_native_app_glue.h`.
    Let''s first describe the flow of the code and then discuss some important aspects
    in detail.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**`android_native_app_glue`库内部机制**：你可以在Android NDK的`sources/android/native_app_glue`目录下找到`android_native_app_glue`库的源代码。它仅由两个文件组成，分别是`android_native_app_glue.c`和`android_native_app_glue.h`。我们首先描述代码的流程，然后详细讨论一些重要的方面。'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since the source code for `native_app_glue` is provided, we can modify it if
    necessary, although in most cases it won't be necessary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提供了`native_app_glue`的源代码，我们可以在必要时修改它，尽管在大多数情况下并不需要。
- en: '`android_native_app_glue` is built on top of the `native_activity.h` interface.
    As shown in the following code (extracted from `sources/android/native_app_glue/android_native_app_glue.c`).
    It implements the `ANativeActivity_onCreate` function, where it registers the
    callback functions and calls the `android_app_create` function. Note that the
    returned `android_app` instance is pointed by the `instance` field of the native
    activity, which can be passed to various callback functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`android_native_app_glue`是建立在`native_activity.h`接口之上的。如下代码所示（从`sources/android/native_app_glue/android_native_app_glue.c`提取），它实现了`ANativeActivity_onCreate`函数，在其中注册回调函数并调用`android_app_create`函数。请注意，返回的`android_app`实例由原生活动的`instance`字段指向，可以传递给各种回调函数：'
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `android_app_create` function (shown in the following code snippet) initializes
    an instance of the `android_app` data structure, which is defined in `android_native_app_glue.h`.
    This function creates a unidirectional pipe for inter-thread communication. After
    that, it spawns a new thread (let''s call it **background thread** thereafter)
    to run the `android_app_entry` function with the initialized `android_app` data
    as the input argument. The main thread will wait for the background thread to
    start and then return:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`android_app_create`函数（如下代码片段所示）初始化`android_app`数据结构的一个实例，该结构在`android_native_app_glue.h`中定义。这个函数为线程间通信创建了一个单向管道。之后，它生成一个新的线程（之后我们称之为**后台线程**）以初始化的`android_app`数据作为输入参数运行`android_app_entry`函数。主线程将等待后台线程启动，然后返回：'
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The background thread starts with the `android_app_entry` function (as shown
    in the following code snippet), where a looper is created. Two event queues will
    be attached to the looper. The activity lifecycle events queue is attached to
    the `android_app_entry` function. When the activity''s input queue is created,
    the input queue is attached (to the `android_app_pre_exec_cmd` function of `android_native_app_glue.c`).
    After attaching the activity lifecycle event queue, the background thread signals
    the main thread it is already running. It then calls a function named `android_main`
    with the `android_app` data. `android_main` is the function we need to implement,
    as shown in our sample code. It must run in a loop until the activity exits:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 后台线程从`android_app_entry`函数开始（如下代码片段所示），在其中创建一个循环器。两个事件队列将被附加到循环器上。活动生命周期事件队列被附加到`android_app_entry`函数上。当活动的输入队列被创建时，输入队列被附加（到`android_native_app_glue.c`的`android_app_pre_exec_cmd`函数）。在附加了活动生命周期事件队列之后，后台线程向主线程发出信号，表明它已经在运行。然后它调用名为`android_main`的函数，并传入`android_app`数据。`android_main`是我们需要实现的函数，正如我们的示例代码所示。它必须在一个循环中运行，直到活动退出：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following diagram indicates how the main and background thread work together
    to create the multi-threaded native activity:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了主线程和后台线程如何共同工作以创建多线程原生活动：
- en: '![How it works…](img/1505OT_05_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/1505OT_05_04.jpg)'
- en: We use the activity lifecycle event queue as an example. The main thread invokes
    the callback functions, which simply writes to the write end of the pipe, while
    true loop implemented in the `android_main` function will poll for events. Once
    an event is detected, the function calls the event handler, which reads the exact
    command from the read end of the pipe and handles it. The `android_native_app_glue`
    library implements all the `main thread` stuff and part of the `background thread`
    stuff for us. We only need to supply the polling loop and the event handler as
    illustrated in our sample code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以活动生命周期事件队列为例。主线程调用回调函数，这些函数只是向管道的写端写入数据，而在`android_main`函数中实现的真正循环将轮询事件。一旦检测到事件，该函数就会调用事件处理程序，从管道的读端读取确切的命令并进行处理。`android_native_app_glue`库为我们实现了所有`主线程`的工作以及部分`后台线程`的工作。我们只需要提供轮询循环和事件处理程序，正如我们的示例代码所示。
- en: '**Pipe**: The main thread creates a unidirectional pipe in the `android_app_create`
    function by calling the `pipe` method. This method accepts an array of two integers.
    After the function is returned, the first integer will be set as the file descriptor
    referring to the read end of the pipe, while the second integer will be set as
    the file descriptor referring to the write end of the pipe.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道**：主线程通过在`android_app_create`函数中调用`pipe`方法创建一个单向管道。这个方法接受一个包含两个整数的数组。函数返回后，第一个整数将被设置为代表管道读端的文件描述符，而第二个整数将被设置为代表管道写端的文件描述符。'
- en: A pipe is usually used for **Inter-process Communication** (**IPC**), but here
    it is used for communication between the main UI thread and the background thread
    created at `android_app_entry`. When an activity lifecycle event occurs, the main
    thread will execute the corresponding callback function registered at `ANativeActivity_onCreate`.
    The callback function simply writes a command to the write end of the pipe and
    then waits for a signal from the background thread. The background thread is supposed
    to poll for events continuously and once it detects a lifecycle event, it will
    read the exact event from the read end of the pipe, signal the main thread to
    unblock and handle the events. Because the signal is sent right after receiving
    the command and before actual processing of the events, the main thread can return
    from the callback function quickly without worrying about the possible long processing
    of the events.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 管道通常用于**进程间通信**（**IPC**），但在这里它被用于主UI线程与在`android_app_entry`创建的后台线程之间的通信。当一个活动生命周期事件发生时，主线程将执行在`ANativeActivity_onCreate`注册的相应回调函数。回调函数只是将一个命令写入管道的写入端，然后等待来自后台线程的信号。后台线程应该不断地轮询事件，一旦检测到生命周期事件，它将从管道的读取端读取确切的事件，通知主线程解除阻塞并处理事件。因为信号在收到命令后立即发送，且在实际处理事件之前，主线程可以快速从回调函数返回，而无需担心事件可能需要长时间处理。
- en: Different operating systems have different implementations for the pipe. The
    pipe implemented by Android system is "half-duplex", where communication is unidirectional.
    That is, one file descriptor can only write, and the other file descriptor can
    only read. Pipes in some operating system is "full-duplex", where the two file
    descriptors can both read and write.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统对管道的实现各不相同。安卓系统实现的管道是“半双工”的，即通信是单向的。也就是说，一个文件描述符只能写，另一个文件描述符只能读。某些操作系统中的管道是“全双工”的，两个文件描述符都可以读写。
- en: '**Looper** is an event tracking facility, which allows us to attach one or
    more event queues for an event loop of a thread. Each event queue has an associated
    file descriptor. An **event** is data available on a file descriptor. In order
    to use a looper, we need to include the `android/looper.h` header file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环器**是一个事件跟踪设施，它允许我们为一个线程的事件循环附加一个或多个事件队列。每个事件队列都有一个关联的文件描述符。一个**事件**是在文件描述符上可用的数据。为了使用循环器，我们需要包含`android/looper.h`头文件。'
- en: 'The library attaches two event queues for the event loop to be created by us
    in the background thread, including the activity lifecycle event queue and the
    input event queue. The following steps should be performed in order to use a looper:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该库为我们在后台线程中创建的事件循环附加了两个事件队列，包括活动生命周期事件队列和输入事件队列。为了使用循环器，应按以下步骤操作：
- en: '**Create or obtain a looper associated with the current thread**: This is done
    by the `ALooper_prepare` function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为当前线程创建或获取一个循环器**：这是通过`ALooper_prepare`函数完成的：'
- en: '[PRE12]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function prepares a looper associated with the calling thread and returns
    it. If the looper doesn't exist, it creates one, associates it with the thread,
    and returns it.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数准备与调用线程关联的循环器并返回它。如果循环器不存在，它会创建一个，将其与线程关联，并返回它。
- en: '**Attach an event queue**: This is done by `ALooper_addFd`. The function has
    the following prototype:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**附加一个事件队列**：这是通过`ALooper_addFd`完成的。该函数具有以下原型：'
- en: '[PRE13]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function can be used in two ways. Firstly, if `callback` is set to `NULL`,
    the `ident` set will be returned by `ALooper_pollOnce` and `ALooper_pollAll`.
    Secondly, if `callback` is non-NULL, then the callback function will be executed
    and `ident` is ignored. The `android_native_app_glue` library uses the first approach
    to attach a new event queue to the looper. The input argument `fd` indicates the
    file descriptor associated with the event queue. `ident` is the identifier for
    the events from the event queue, which can be used to classify the event. The
    identifier must be bigger than zero when `callback` is set to `NULL`. `callback`
    is set to `NULL` in the library source code, and `data` points to the private
    data that will be returned along with the identifier at polling.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数有两种使用方式。首先，如果将`callback`设置为`NULL`，则`ident`集合将由`ALooper_pollOnce`和`ALooper_pollAll`返回。其次，如果`callback`非`NULL`，则将执行回调函数，并忽略`ident`。`android_native_app_glue`库采用第一种方法将新的事件队列附加到looper上。输入参数`fd`表示与事件队列相关联的文件描述符。`ident`是事件队列中事件的标识符，可用于分类事件。当`callback`设置为`NULL`时，标识符必须大于零。在库源代码中，`callback`被设置为`NULL`，`data`指向将随标识符一起在轮询时返回的私有数据。
- en: In the library, this function is called to attach the activity lifecycle event
    queue to the background thread. The input event queue is attached using the input
    queue specific function `AInputQueue_attachLooper`, which we will discuss in the
    *Detecting and handling input events at NDK* recipe.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在库中，此函数被调用来将活动生命周期事件队列附加到后台线程。输入事件队列通过特定于输入队列的函数`AInputQueue_attachLooper`进行附加，我们将在*在NDK中检测和处理输入事件*的菜谱中进行讨论。
- en: '**Poll for events**: This can be done by either one of the following two functions:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮询事件**：可以通过以下两个函数之一来完成：'
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These two methods are equivalent when `callback` is set to `NULL` in `ALooper_addFd`.
    They have the same input arguments. `timeoutMillis` specifies the timeout for
    polling. If it is set to zero, then the functions return immediately; if it is
    set to negative, they will wait indefinitely until an event occurs. The functions
    return the identifier (greater than zero) when an event occurs from any input
    queues attached to the looper. In this case, `outFd`, `outEvents`, and `outData`
    will be set to the file descriptor, poll events, and data associated with the
    event. Otherwise, they will be set to `NULL`.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在`ALooper_addFd`中将`callback`设置为`NULL`时，这两种方法是等价的。它们具有相同的输入参数。`timeoutMillis`指定轮询的超时时间。如果设置为0，则函数立即返回；如果设置为负数，它们将无限期等待直到发生事件。当与looper关联的任何输入队列发生事件时，函数将返回标识符（大于零）。在这种情况下，`outFd`、`outEvents`和`outData`将被设置为与事件关联的文件描述符、轮询事件和数据。否则，它们将被设置为`NULL`。
- en: '**Detach event queues**: This is done by the following function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分离事件队列**：这是通过以下函数完成的：'
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It accepts the looper and file descriptor associated with the event queue, and
    detaches the queue from the looper.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它接受与事件队列相关联的looper和文件描述符，并将队列从looper上分离。
- en: Managing native windows at Android NDK
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android NDK中管理原生窗口
- en: The previous recipes in this chapter provided simple examples with the logcat
    output only. This recipe will discuss how to manage the native window at Android
    NDK.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面的菜谱仅提供了带有logcat输出的简单示例。这个菜谱将讨论如何在Android NDK中管理原生窗口。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Readers are recommended to read the following recipes before going through
    this one:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 建议读者在阅读这个菜谱之前阅读以下菜谱：
- en: '*Creating a native activity with the native_activity.h interface*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用native_activity.h接口创建原生活动*'
- en: '*Creating a native activity with the Android native app glue*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Android原生应用胶水创建原生活动*'
- en: Also recall that native window management has been introduced briefly in the
    *Displaying graphics with EGL* recipe in [Chapter 4](ch04.html "Chapter 4. Android
    NDK OpenGL ES API"), *Android NDK OpenGL ES API*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还要回顾一下，在[第4章](ch04.html "第4章。Android NDK OpenGL ES API")，*Android NDK OpenGL
    ES API*中的*使用EGL显示图形*菜谱中简要介绍了原生窗口管理。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps create the sample application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤创建示例应用程序：
- en: Create an Android application named `NativeWindowManagement`. Set the package
    name as `cookbook.chapter5.nativewindowmanagement`. Please refer to the *Loading
    native libraries and registering native methods* recipe of [Chapter 2](ch02.html
    "Chapter 2. Java Native Interface"), *Java Native Interface*, if you want more
    detailed instructions.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NativeWindowManagement`的Android应用程序。将包名设置为`cookbook.chapter5.nativewindowmanagement`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章。Java本地接口")，*Java Native Interface*中的*加载本地库和注册本地方法*的菜谱。
- en: Right-click on the `NativeWindowManagement` project, select **Android Tools**
    | **Add Native Support**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`NativeWindowManagement`项目，选择**Android Tools** | **添加原生支持**。
- en: Update `AndroidManifest.xml`. Please refer to previous recipe or the downloaded
    code for details. Note that the metadata `android.app.lib_name` must have its
    value as `NativeWindowManagement`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AndroidManifest.xml`。具体细节请参考之前的食谱或下载的代码。注意，元数据`android.app.lib_name`的值必须为`NativeWindowManagement`。
- en: 'Add two files named `NativeWindowManagement.cpp` and `mylog.h` under the `jni`
    folder. `NativeWindowManagement.cpp` is modified based on previous recipe. The
    following code snippet shows the updated part:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加两个名为`NativeWindowManagement.cpp`和`mylog.h`的文件。`NativeWindowManagement.cpp`是基于之前食谱修改的。以下代码段显示了更新的部分：
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add the `Android.mk` file under the `jni` folder, which is similar to the one
    used in the previous recipe. You just need to replace the module name as `NativeWindowManagement`
    and the source file as `NativeWindowManagement.cpp`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加`Android.mk`文件，与之前食谱中使用的类似。你只需要将模块名称替换为`NativeWindowManagement`，源文件替换为`NativeWindowManagement.cpp`。
- en: 'Build the Android application and run it on an emulator or device. Start a
    terminal and display the logcat output by using the following command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Android应用程序并在模拟器或设备上运行。启动终端并使用以下命令显示logcat输出：
- en: '[PRE17]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the application starts, we will see the following logcat:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们将看到以下logcat输出：
- en: '![How to do it…](img/1505_05_05.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_05_05.jpg)'
- en: 'The device screen will display a red rectangle at the center of the screen,
    as follows:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设备屏幕将在屏幕中心显示一个红色矩形，如下所示：
- en: '![How to do it…](img/1505_05_06.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/1505_05_06.jpg)'
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The NDK interface for native window management is defined in the `window.h`,
    `rect.h`, `native_window_jni.h`, and `native_window.h` header files. The first
    two simply define some constants and data structures. `native_window_jni.h` defines
    a single function named `ANativeWindow_fromSurface`, which helps us to obtain
    a native window from a Java surface object. We have illustrated this function
    in the *Displaying graphics with EGL* recipe in [Chapter 4](ch04.html "Chapter 4. Android
    NDK OpenGL ES API"), *Android NDK OpenGL ES API*. Here, we focus on the functions
    provided in `native_window.h`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 原生窗口管理的NDK接口在`window.h`、`rect.h`、`native_window_jni.h`和`native_window.h`头文件中定义。前两个只是定义了一些常量和数据结构。`native_window_jni.h`定义了一个名为`ANativeWindow_fromSurface`的单一函数，它帮助我们从一个Java表面对象获取原生窗口。我们在[第4章](ch04.html
    "Chapter 4. Android NDK OpenGL ES API")，*使用EGL显示图形*的食谱中说明了这个函数。这里，我们关注`native_window.h`中提供的函数。
- en: 'Perform the following steps to draw a square on the phone screen:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在手机屏幕上绘制一个正方形：
- en: '**Set the window buffer format and size**:This is done by the `ANativeWindow_setBuffersGeometry`
    function`:`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置窗口缓冲区格式和大小**：这是通过`ANativeWindow_setBuffersGeometry`函数完成的：'
- en: '[PRE18]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function updates the native window buffer associated with the native window
    referred by the window input argument. The window size and format are changed
    according to the rest of the input arguments. Three formats are defined in `native_window.h`,
    including `WINDOW_FORMAT_RGBA_8888`, `WINDOW_FORMAT_RGBX_8888`, and `WINDOW_FORMAT_RGB_565`.
    If the size or the format is set to `0`, then the native window's base value will
    be used.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数更新与输入参数window引用的原生窗口关联的原生窗口缓冲区。根据其余输入参数，窗口大小和格式会发生变化。在`native_window.h`中定义了三种格式，包括`WINDOW_FORMAT_RGBA_8888`、`WINDOW_FORMAT_RGBX_8888`和`WINDOW_FORMAT_RGB_565`。如果大小或格式设置为`0`，则将使用原生窗口的基本值。
- en: '**Lock the window''s next drawing surface**: This is done by the `ANativeWindow_lock`
    function:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**锁定窗口下一次绘图表面**：这是通过`ANativeWindow_lock`函数完成的：'
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After this call is returned, the input argument `outBuffer` will refer to the
    window buffer for drawing.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此调用返回后，输入参数`outBuffer`将引用用于绘图的窗口缓冲区。
- en: '**Clear the buffer**: This is optional. Sometimes we may just want to overwrite
    a part of the window buffer. In our example, we called `memset` to set all the
    data to `0`.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清除缓冲区**：这是可选的。有时我们可能只想覆盖窗口缓冲区的一部分。在我们的示例中，我们调用了`memset`将所有数据设置为`0`。'
- en: '**Draw something to the buffer**: In our example, we first calculate the start
    and end width and height of the rectangle, and then set the red and alpha bytes
    of the rectangle area as `255`. This will show us a red rectangle.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在缓冲区中绘制内容**：在我们的示例中，我们首先计算矩形的开始和结束宽度与高度，然后将矩形区域的红色和alpha字节设置为`255`。这将显示一个红色矩形。'
- en: '**Unlock the window''s drawing surface and post the new buffer to display**:
    This is done with the `ANativeWindow_unlockAndPost` function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解锁窗口的绘图表面并向显示发布新缓冲区**：这是通过`ANativeWindow_unlockAndPost`函数完成的：'
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Detecting and handling input events at Android NDK
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android NDK中检测和处理输入事件
- en: Input events are essential for user interaction in Android apps. This recipe
    discusses how to detect and handle input events in Android NDK.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输入事件对于Android应用中的用户交互至关重要。这个食谱讨论了如何在Android NDK中检测和处理输入事件。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will further develop the example in last recipe. Please read the *Managing
    native windows at Android NDK* recipe before going through this one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步开发上一个食谱中的示例。在阅读这个食谱之前，请先阅读*在Android NDK中管理本地窗口*的食谱。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps create a sample application, which detects and handles
    input events at the native code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将创建一个示例应用程序，该程序在本地代码中检测和处理输入事件：
- en: Create an Android application named `NativeInputs`. Set the package name as
    `cookbook.chapter5.nativeinputs`. Please refer to the *Loading native libraries
    and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NativeInputs`的Android应用程序。将包名设置为`cookbook.chapter5.nativeinputs`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第 2 章. Java Native Interface")，*Java Native Interface*中的*加载本地库和注册本地方法*的食谱。
- en: Right-click on the `NativeInputs` project, select **Android Tools** | **Add
    Native Support.**
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`NativeInputs`项目，选择**Android Tools** | **添加本地支持**。
- en: Update `AndroidManifest.xml`. Please refer to previous recipe or the downloaded
    code for details. Note that the metadata `android.app.lib_name` must have a value
    as `NativeInputs`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AndroidManifest.xml`。具体细节请参考上一个食谱或下载的代码。注意，元数据`android.app.lib_name`的值必须为`NativeInputs`。
- en: 'Add two files named `NativeInputs.cpp` and `mylog.h` under the `jni` folder.
    `NativeInputs.cpp` is modified based on the previous recipe. Let us see a part
    of its code here:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加两个名为`NativeInputs.cpp`和`mylog.h`的文件。`NativeInputs.cpp`是基于上一个食谱修改的。让我们在这里看一部分它的代码：
- en: '`handle_input_events`: This is the event handler method for input events. Note
    that when a motion event with move action (`AINPUT_EVENT_TYPE_MOTION`) is detected,
    we update `app->userData` and set `app->redrawNeeded` to `1`:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_input_events`：这是输入事件的事件处理方法。请注意，当检测到具有移动动作（`AINPUT_EVENT_TYPE_MOTION`）的移动事件时，我们会更新`app->userData`并将`app->redrawNeeded`设置为`1`：'
- en: '[PRE21]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`android_main`: We update the while true loop. When `app->redrawNeeded` is
    set, we redraw the rectangle:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android_main`：我们更新了while true循环。当设置`app->redrawNeeded`时，我们重新绘制矩形：'
- en: '[PRE22]'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Add the `Android.mk` file under the `jni` folder, which is similar to previous
    recipe. We just need to replace the module name as `NativeInputs` and the source
    file as `NativeInputs.cpp`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加`Android.mk`文件，与上一个食谱类似。我们只需要将模块名称替换为`NativeInputs`，将源文件替换为`NativeInputs.cpp`。
- en: Build the Android application and run it on an emulator or device. We can move
    a figure across the screen to see the rectangle moving horizontally:![How to do
    it…](img/1505_05_14.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Android应用程序并在模拟器或设备上运行。我们可以移动屏幕上的图形来观察矩形水平移动：![如何操作…](img/1505_05_14.jpg)
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: This recipe discusses input events handling with the `android_native_app_glue`
    library at Android NDK.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱讨论了在Android NDK中使用`android_native_app_glue`库处理输入事件。
- en: '**Input event queue in android_native_app_glue**: `android_native_app_glue`
    attaches the input event queue for us by default.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**android_native_app_glue中的输入事件队列**：`android_native_app_glue`默认为我们附加了输入事件队列。'
- en: When the input queue is created for an activity, the `onInputQueueCreated` callback
    is called on the main thread, which writes `APP_CMD_INPUT_CHANGED` to the write
    end of the pipe we described in previous recipe. The background thread will receive
    the command and call `AInputQueue_attachLooper` the function to attach the input
    queue to the background thread looper.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当为活动创建输入队列时，主线程会调用`onInputQueueCreated`回调，该回调将`APP_CMD_INPUT_CHANGED`写入我们在上一个食谱中描述的管道的写入端。后台线程将接收命令并调用`AInputQueue_attachLooper`函数，将输入队列附加到后台线程循环器。
- en: When an input event occurs, it will be handled by `process_input` (the function
    pointer `source->process` in the while true loop we called points to `process_input`
    if the event is an input event). Inside `process_input`, `AInputQueue_getEvent`
    is firstly called to retrieve the event. Then, `AInputQueue_preDispatchEvent`
    is called to send the key for pre-dispatching. This could possibly result in it
    being consumed by the current **Input Method Editor** (**IME**) before the app.
    Followed by this is the `android_app->onInputEvent`, which is a function pointer-pointing
    to an event handler provided by us. If no event handler is provided by us, it's
    set to `NULL`. After that, `AInputQueue_finishEvent` is called to indicate that
    event handling is over.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生输入事件时，它将被`process_input`处理（在while true循环中我们调用的`source->process`函数指针指向`process_input`，如果事件是输入事件）。在`process_input`内部，首先调用`AInputQueue_getEvent`来获取事件。然后，调用`AInputQueue_preDispatchEvent`来发送预分派的键。这可能导致它在使用者提供的应用程序之前被当前的**输入法编辑器**（**IME**）消耗掉。接下来是`android_app->onInputEvent`，这是一个指向由我们提供的事件处理器的函数指针。如果我们没有提供事件处理器，它会被设置为`NULL`。之后，调用`AInputQueue_finishEvent`来表示事件处理结束。
- en: Lastly, when the input queue is destroyed, the `onInputQueueDestroyed` callback
    is called on the main thread, which also writes `APP_CMD_INPUT_CHANGED`. The background
    thread will read the command and call a function named `AInputQueue_detachLooper`
    to detach the input queue from the thread looper.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当输入队列被销毁时，主线程会调用`onInputQueueDestroyed`回调，这也会写入`APP_CMD_INPUT_CHANGED`。后台线程将读取命令并调用名为`AInputQueue_detachLooper`的函数，以将输入队列从线程循环器中分离。
- en: '**Event handler**: In the `handle_input_events` function, we first called `AInputEvent_getType`
    to get the input event type. The `android/input.h` header file defines two input
    event types, namely `AINPUT_EVENT_TYPE_KEY` and `AINPUT_EVENT_TYPE_MOTION`. The
    first event type indicates that the input event is a key event, while the second
    one indicates that it is a motion event.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件处理器**：在`handle_input_events`函数中，我们首先调用了`AInputEvent_getType`来获取输入事件类型。`android/input.h`头文件定义了两种输入事件类型，即`AINPUT_EVENT_TYPE_KEY`和`AINPUT_EVENT_TYPE_MOTION`。第一种事件类型表示输入事件是按键事件，而第二种表示它是动作事件。'
- en: 'We called `AKeyEvent_getAction`, `AKeyEvent_getFlags`, and `AKeyEvent_getKeyCode`
    to get the action, flags, and key code of a key event and printed a string to
    describe it. On the other hand, we called `AMotionEvent_getAction` and `AMotionEvent_getX`
    to get the action and the `x` position of a motion event. Note that the `AMotionEvent_getX`
    function requires the second input argument as the pointer index. The pointer
    index is obtained by using the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`AKeyEvent_getAction`、`AKeyEvent_getFlags`和`AKeyEvent_getKeyCode`来获取按键事件的行为、标志和键码，并打印出描述它的字符串。另一方面，我们调用了`AMotionEvent_getAction`和`AMotionEvent_getX`来获取动作事件的行为和`x`位置。注意，`AMotionEvent_getX`函数需要第二个输入参数作为指针索引。通过以下代码获取指针索引：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are a lot more input event functions, which can be found at `andoid/input.h`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`andoid/input.h`中还有更多的输入事件函数。'
- en: Accessing sensors at Android NDK
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android NDK中访问传感器
- en: Many Android devices have built-in sensors to detect and measure motion, orientation,
    and other environmental conditions. It is possible to access sensors in Android
    NDK. This recipe will discuss how to do it in detail.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Android设备内置有传感器，用于检测和测量运动、方向和其他环境条件。在Android NDK中可以访问这些传感器。本食谱将详细讨论如何进行操作。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The example provided in this recipe is based on the sample code in the previous
    two recipes. Readers are recommended to read them first:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱提供的示例基于前两个食谱中的示例代码。建议读者先阅读它们：
- en: '*Managing native windows at Android NDK*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Android NDK中管理原生窗口*'
- en: '*Detecting and handling input events at Android NDK*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Android NDK中检测和处理输入事件*'
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps develop the sample Android application, which demonstrates
    how to access sensors from Android NDK:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤开发了一个示例Android应用程序，演示了如何从Android NDK访问传感器：
- en: Create an Android application named `nativesensors`. Set the package name as
    `cookbook.chapter5.nativesensors`. Please refer to the *Loading native libraries
    and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nativesensors`的Android应用程序。将包名设置为`cookbook.chapter5.nativesensors`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "第2章. Java Native Interface")的*加载原生库和注册原生方法*食谱，*Java Native Interface*。
- en: Right-click on the `nativesensors` project, select **Android Tools** | **Add
    Native Support**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`nativesensors`项目，选择**Android Tools** | **Add Native Support**。
- en: Update `AndroidManifest.xml`. Please refer to previous recipe or the downloaded
    code for details. Note that the metadata `android.app.lib_name` must have a value
    as `nativesensors`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AndroidManifest.xml`。具体细节请参考上一个配方或下载的代码。注意，元数据`android.app.lib_name`的值必须为`nativesensors`。
- en: Add two files named `nativesensors.cpp` and `mylog.h` under the `jni` folder.
    Let's show a part of the code in `nativesensors.cpp`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加两个名为`nativesensors.cpp`和`mylog.h`的文件。让我们展示一下`nativesensors.cpp`中的部分代码。
- en: '`handle_activity_lifecycle_events`: This function handles activity lifecycle
    events. We enable the sensor when the activity is in focus and disable it when
    the activity loses its focus. This saves the battery life by avoiding reading
    sensors when our activity is not in focus:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_activity_lifecycle_events`：此函数处理活动生命周期事件。当活动处于焦点时，我们启用传感器，当活动失去焦点时禁用它。这通过避免在活动未处于焦点时读取传感器来节省电池寿命：'
- en: '[PRE24]'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`android_main`: We continuously poll for events and handle the sensor events
    identified by the `LOOPER_ID_USER` identifier:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android_main`：我们不断地轮询事件，并处理由`LOOPER_ID_USER`标识的传感器事件：'
- en: '[PRE25]'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add the `Android.mk` file under the `jni` folder, which is similar to the one
    used in the previous recipe. We just need to replace the module name as `nativesensors`
    and the source file as `nativesensors.cpp`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下添加`Android.mk`文件，该文件与上一个配方中使用的类似。我们只需要将模块名称替换为`nativesensors`，并将源文件替换为`nativesensors.cpp`。
- en: Build the Android application and run it on an emulator or device. We can shake
    the device to see the rectangle moving horizontally:![How to do it…](img/1505_05_14.jpg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Android应用程序并在模拟器或设备上运行。我们可以摇动设备来观察矩形水平移动：![如何操作…](img/1505_05_14.jpg)
- en: How it works…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In our example, we used the accelerometer sensor to detect phone shaking. Then,
    based on the phone shaking speed, we move the red rectangle to one side of the
    phone screen. Once the rectangle reaches an edge of the phone screen, it starts
    to move to the other edge.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了加速度传感器来检测手机摇动。然后，根据手机摇动的速度，我们将红色矩形移动到手机屏幕的一侧。一旦矩形到达手机屏幕的边缘，它就会开始移动到另一边缘。
- en: The example code provides a simple algorithm to determine whether a shake has
    happened or not. More complex and accurate algorithms exist and can be implemented.
    We can also adjust the `SHAKE_TIMEOUT` and `SHAKE_COUNT_THRESHOLD` constants to
    fine tune the algorithm.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码提供了一个简单的算法来确定是否发生了摇动。存在更复杂和准确的算法，并且可以实施。我们还可以调整`SHAKE_TIMEOUT`和`SHAKE_COUNT_THRESHOLD`常数以微调算法。
- en: 'The important part of the example is how to access sensors. Let''s summarize
    the steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的重要部分是如何访问传感器。让我们总结一下步骤：
- en: '**Get a reference to the sensor manager**: This is done by using the following
    function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取传感器管理器的引用**：这是通过使用以下函数完成的：'
- en: '[PRE27]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Get the default sensor of a given type**: We can also get a list of all available
    sensors. This is done by using the following two functions respectively:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取给定类型的默认传感器**：我们还可以获取所有可用传感器的列表。这是通过分别使用以下两个函数完成的：'
- en: '[PRE28]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The available types are defined in `android/sensor.h`. In our example, we print
    all sensor names and types but only use `ASENSOR_TYPE_ACCELEROMETER`.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可用类型在`android/sensor.h`中定义。在我们的示例中，我们打印出所有传感器名称和类型，但只使用`ASENSOR_TYPE_ACCELEROMETER`。
- en: '**Create a new sensor queue and attach it to the looper of the thread**: This
    is done by using the `ASensorManager_createEventQueue` function as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的传感器队列并将其附加到线程的looper上**：这是通过使用以下`ASensorManager_createEventQueue`函数完成的：'
- en: '[PRE29]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The usage of this function is similar to the usagw of the `ALooper_addFd` function
    in the *Creating a native activity with the Android native app glue* recipe and
    `AInputQueue_attachLooper` in the *Detecting and handling input events at Android
    NDK* recipe. In our example, we set the `ident` as `LOOPER_ID_USER`. Note that
    we may also define a new looper ID by changing the code of `android_native_app_glue.h`
    and setting it here.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数的使用与*使用Android原生应用胶水创建原生活动*配方中的`ALooper_addFd`函数的使用类似，以及*在Android NDK中检测和处理输入事件*配方中的`AInputQueue_attachLooper`。在我们的示例中，我们将`ident`设置为`LOOPER_ID_USER`。请注意，我们还可以通过更改`android_native_app_glue.h`的代码并在此处定义新的looper
    ID。
- en: '**Enable and configure the sensor**:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用并配置传感器**：'
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first function enables the sensor referred by the sensor input argument.
    The second function sets the delivery rate of the events, in microseconds, for
    the sensor referred by the sensor input argument. In our example, we called these
    two functions when the activity gained focus.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数启用由传感器输入参数引用的传感器。第二个函数为引用由传感器输入参数的传感器设置事件传递率，以微秒为单位。在我们的示例中，当活动获得焦点时调用了这两个函数。
- en: '**Poll for events and get the available events from the queue**: The polling
    is done by calling `ALooper_pollOnce`, as shown in the previous recipe. If the
    event identifier returned is `LOOPER_ID_USER`, we know that it is a sensor event
    and we can use the following function to get it:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮询事件并从队列中获取可用事件**：如前一个菜谱所示，通过调用`ALooper_pollOnce`进行轮询。如果返回的事件标识符是`LOOPER_ID_USER`，我们知道这是一个传感器事件，我们可以使用以下函数来获取它：'
- en: '[PRE31]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`count` indicates the maximum number of available events we want to get. In
    our example, we set it to `1`. It is also possible to define an array of `ASensorEvent`
    and get multiple events at one time.'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`count`表示我们想要获取的最大可用事件数。在我们的示例中，我们将其设置为`1`。也可以定义一个`ASensorEvent`数组，一次性获取多个事件。'
- en: '**Handle sensor events**: The sensor event is represented by the `ASensorEvent`
    data structure, which can be found at `android/sensor.h` (the exact path to the
    file is `<Android NDK root dir>/platforms/android-<version>/arch-arm/usr/include/android/sensor.h`).
    In our example, we accessed the acceleration readings at the x, y, and z axes,
    and used the readings to determine if a phone shake has happened.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理传感器事件**：传感器事件由`ASensorEvent`数据结构表示，可以在`android/sensor.h`中找到（该文件的确切路径为`<Android
    NDK根目录>/platforms/android-<版本>/arch-arm/usr/include/android/sensor.h`）。在我们的示例中，我们访问了x、y、z轴上的加速度读数，并使用这些读数来确定是否发生了手机摇晃。'
- en: '**Disable the sensor**: After you are done accessing the sensors, you can disable
    it with the following function:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**禁用传感器**：访问完传感器后，你可以使用以下函数禁用它：'
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Destroy the sensor event queue and free all resources associated with it**:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**销毁传感器事件队列并释放与其相关的所有资源**：'
- en: '[PRE33]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Managing assets at Android NDK
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android NDK中管理资源
- en: Assets provide a way for Android apps to include various types of files, including
    text, image, audio, video, and so on. This recipe discusses how to load asset
    files from Android NDK.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 资源为Android应用提供了一种包含各种类型文件的方式，包括文本、图像、音频、视频等。本菜谱讨论了如何从Android NDK加载资源文件。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will modify the example we developed in the *Mapping texture in OpenGL ES
    1.x* recipe in [Chapter 4](ch04.html "Chapter 4. Android NDK OpenGL ES API"),
    *Android NDK OpenGL ES API*. Readers are suggested to read through the recipe
    or take a look at the code first.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改在[第4章](ch04.html "Chapter 4. Android NDK OpenGL ES API")的*在OpenGL ES 1.x中映射纹理*菜谱中开发的示例，*Android
    NDK OpenGL ES API*。建议读者阅读该菜谱或先查看代码。
- en: How to do it…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps describe how the sample application is developed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何开发示例应用程序：
- en: Create an Android application named `NativeAssets`. Set the package name as
    `cookbook.chapter5.nativeassets`. Please refer to the *Loading native libraries
    and registering native methods* recipe of [Chapter 2](ch02.html "Chapter 2. Java
    Native Interface"), *Java Native Interface*, if you want more detailed instructions.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NativeAssets`的Android应用程序。将包名设置为`cookbook.chapter5.nativeassets`。如果你需要更详细的说明，请参考[第2章](ch02.html
    "Chapter 2. Java Native Interface")的*加载本地库和注册本地方法*菜谱，*Java Native Interface*。
- en: Right-click on the `NativeAssets` project, select **Android Tools** | **Add
    Native Support**.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeAssets`项目上右键点击，选择**Android Tools** | **Add Native Support**。
- en: 'Add three Java files, namely `MyActivity.java`, `MySurfaceView.java`, and `MyRenderer.java`
    under the `cookbook.chapter5.nativeassets` package. The first two files are identical
    to the corresponding files in the *Mapping texture in OpenGL ES 1.x* recipe in
    [Chapter 4](ch04.html "Chapter 4. Android NDK OpenGL ES API"), *Android NDK OpenGL
    ES API*. The last file is slightly changed, where the `naLoadTexture` native method
    signature is updated as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cookbook.chapter5.nativeassets`包下添加三个Java文件，分别为`MyActivity.java`，`MySurfaceView.java`和`MyRenderer.java`。前两个文件与[第4章](ch04.html
    "Chapter 4. Android NDK OpenGL ES API")中的*在OpenGL ES 1.x中映射纹理*菜谱中的对应文件完全相同，*Android
    NDK OpenGL ES API*。最后一个文件略有改动，其中`naLoadTexture`本地方法签名更新如下：
- en: '[PRE34]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `onSurfaceCreated` method, we called the native method by passing a
    Java `AssetManager` instance:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`onSurfaceCreated`方法中，我们通过传递一个Java `AssetManager`实例来调用本地方法：
- en: '[PRE35]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create two folders under the `jni` folder, namely `dice` and `libpng-1.5.`12\.
    In the `libpng-1.5.12` folder, we place the source files of libpng, which can
    be downloaded from [http://sourceforge.net/projects/libpng/files/](http://sourceforge.net/projects/libpng/files/).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`文件夹下创建两个文件夹，分别为`dice`和`libpng-1.5.12`。在`libpng-1.5.12`文件夹中，我们放置了libpng的源文件，可以从[http://sourceforge.net/projects/libpng/files/](http://sourceforge.net/projects/libpng/files/)下载。
- en: 'In the `dice` folder, we add the `Cube.cpp`, `Cube.h`, `mylog.h`, and `DiceG1.cpp`
    files. The first three files are the same as the example in the *Mapping texture
    in OpenGL ES 1.x* recipe in [Chapter 4](ch04.html "Chapter 4. Android NDK OpenGL
    ES API"), *Android NDK OpenGL ES API*. The `DiceG1.cpp` file is updated by adding
    procedures to read `.png` assets files from the `assets` folder. Let''s show a
    part of the updated code:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`dice`文件夹中，我们添加了`Cube.cpp`、`Cube.h`、`mylog.h`和`DiceG1.cpp`文件。前三个文件与[第4章](ch04.html
    "第4章. Android NDK OpenGL ES API")中*在OpenGL ES 1.x中映射纹理*的示例相同，*Android NDK OpenGL
    ES API*。`DiceG1.cpp`文件通过添加从`assets`文件夹读取`.png`资产文件的程序进行了更新。下面是更新代码的一部分：
- en: '`readPng`: It is the callback function used at `png_set_read_fn`. It reads
    the data from the `asset` file:'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readPng`：这是在`png_set_read_fn`中使用的回调函数。它从`asset`文件中读取数据：'
- en: '[PRE36]'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`naLoadTexture`: It reads all the `.png` files under the `assets` top-level
    directory and loads the data to OpenGL for texture mapping:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`naLoadTexture`：它读取`assets`顶级目录下的所有`.png`文件，并将数据加载到OpenGL中进行纹理映射：'
- en: '[PRE37]'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add an `Android.mk` file under `jni`, `jni/dice`, `and jni/libpng-1.5.12` respectively.
    The `Android.mk` file under the `jni` top-level folder is as follows. This simply
    instructs the Android build system to include the `Android.mk` files under each
    sub-directory under the `jni` folder:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni`、`jni/dice`和`jni/libpng-1.5.12`下分别添加一个`Android.mk`文件。`jni`顶级文件夹下的`Android.mk`文件如下。这仅指示Android构建系统包含`jni`文件夹下每个子目录中的`Android.mk`文件：
- en: '[PRE38]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Android.mk` file under the `jni/libpng-1.5.12` folder is as follows. This
    compiles `libpng` as a local static library:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jni/libpng-1.5.12`文件夹下的`Android.mk`文件如下。这将编译`libpng`作为本地静态库：'
- en: '[PRE39]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Android.mk` file under the `jni/dice` folder is as follows:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jni/dice`文件夹下的`Android.mk`文件如下：'
- en: '[PRE40]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Build the Android NDK application and run it on an Android device. The app will
    display a cube textured as a dice; this is the same as what we have seen in [Chapter
    4](ch04.html "Chapter 4. Android NDK OpenGL ES API"), *Android NDK OpenGL ES API*.![How
    to do it…](img/1505_05_15.jpg)
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Android NDK应用程序并在Android设备上运行。该应用程序将显示一个作为骰子的纹理立方体；这与我们在[第4章](ch04.html "第4章.
    Android NDK OpenGL ES API")中*Android NDK OpenGL ES API*看到的相同。![如何操作…](img/1505_05_15.jpg)
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In the example, we load the `.png` files from the `assets` folder and used
    them as OpenGL textures. You can use the following steps to read `assets`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们从`assets`文件夹加载了`.png`文件，并将其用作OpenGL纹理。你可以使用以下步骤读取`assets`：
- en: '**Get a native AAssetManager object from the Java AssetManager object**: This
    is done by the `AAssetManager_fromJava` function, which is defined in `asset_manager_jni.h`.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从Java AssetManager对象获取本地AAssetManager对象**：这是通过`AAssetManager_fromJava`函数完成的，该函数在`asset_manager_jni.h`中定义。'
- en: '**Open an asset directory**: This is done by AAssetManager_openDir.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开资产目录**：这是通过AAssetManager_openDir完成的。'
- en: '[PRE41]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To open the top-level directory "assets", we set dirName to "". For the subdirectories,
    we will need to supply the directory name.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要打开顶级目录"assets"，我们将dirName设置为""。对于子目录，我们需要提供目录名称。
- en: '**Get an asset file name**:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取资产文件名**：'
- en: '[PRE42]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Iterate over the files under the `asset` directory referred by the input argument
    `assetDir`. If all files have been returned or there are no files, `NULL` is returned.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遍历输入参数`assetDir`所引用的`asset`目录下的文件。如果所有文件都已返回或没有文件，则返回`NULL`。
- en: '**Open an asset file**: This is done by using `AAssetManager_open`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开资产文件**：这是通过使用`AAssetManager_open`完成的：'
- en: '[PRE43]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The filename should be set to the `asset` file name, where `mode` can be one
    of the following:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件名应设置为`asset`文件名，其中`mode`可以是以下之一：
- en: '`AASSET_MODE_UNKNOWN`: Not known how the data is to be accessed'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_UNKNOWN`：不知道数据将如何被访问'
- en: '`AASSET_MODE_RANDOM`: Read chunks, and seek forward and backward'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_RANDOM`：读取块，并向前和向后查找'
- en: '`AASSET_MODE_STREAMING`: Read sequentially, with an occasional forward seek'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_STREAMING`：顺序读取，偶尔向前查找'
- en: '`AASSET_MODE_BUFFER`: Attempt to load contents into memory, for fast small
    reads'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_BUFFER`：尝试将内容加载到内存中，以便快速小读取'
- en: '**Read the asset file**: This is done by using `AAsset_read`.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**读取资产文件**：这是通过使用`AAsset_read`完成的。'
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The input argument `buf` refers to the location where the data is placed after
    reading, and `count` indicates the number of bytes we want to read. The actual
    number of bytes read is returned and may differ from `count`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入参数 `buf` 指的是读取后数据放置的位置，而 `count` 表示我们想要读取的字节数。实际读取的字节数将被返回，可能与 `count` 不一致。
- en: '**Close the asset file**: This is done by using the `AAsset_close` function.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭资产文件**：这是通过使用 `AAsset_close` 函数完成的。'
- en: '**Close the asset directory**: This is done by using the `AAssetDir_close`
    function.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭资产目录**：这是通过使用 `AAssetDir_close` 函数完成的。'
- en: There's more…
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: In this example, we built `libpng` as a local static library. This is necessary
    to read the `.png` files, because Android NDK does not provide APIs to access
    `.png` files. We will discuss how to develop Android NDK applications with existing
    libraries in [Chapter 8](ch08.html "Chapter 8. Porting and Using the Existing
    Libraries with Android NDK"), *Porting and Using the Existing*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `libpng` 作为本地静态库构建。这是读取 `.png` 文件所必需的，因为 Android NDK 没有提供访问 `.png`
    文件的 API。我们将在[第8章](ch08.html "第8章. 使用Android NDK移植和使用现有库")，*移植和使用现有库*中讨论如何利用现有库开发Android
    NDK应用程序。
