- en: Chapter 6. Accessing Android Features Using Intents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用意图访问Android功能
- en: In the last chapter, we discussed data transfer using components. We saw how
    to transfer data from one activity to the other, and why we should transfer data
    between different components. We also discussed the various methods of data transfer
    using intents. Android has a lot of components in the system, and intent provides
    an easy interface to make those components communicate with each other. In [Chapter
    4](ch04.html "Chapter 4. Intents for Mobile Components"), *Intents for Mobile
    Components*, we discussed the different Android components that use system hardware
    such as Wi-Fi, Bluetooth, camera, microphone, and so on. We also discussed how
    these components can be utilized using intents and how we can make many different
    applications using Android hardware with no more than few lines of code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了使用组件进行数据传输。我们了解了如何从一个活动向另一个活动传输数据，以及为什么应该在不同的组件之间传输数据。我们还讨论了使用意图进行数据传输的各种方法。Android系统中有很多组件，意图提供了一种简单的接口，使这些组件能够相互通信。[第4章](ch04.html
    "第4章. 移动组件的意图")中，我们讨论了使用系统硬件如Wi-Fi、蓝牙、摄像头、麦克风等的不同的Android组件。我们还讨论了如何使用意图利用这些组件，以及如何使用不超过几行代码的Android硬件开发许多不同的应用程序。
- en: Until now, we have only discussed hardware components and the role of intents
    with those components. This chapter is all about Android software features and
    how we can use those features in our applications using intents as the primary
    interface. Android contains a vast collection of libraries and APIs, by which
    a developer can use different Android features very easily. This chapter will
    walk us through the common Android features, and we will also develop some example
    applications that will show us the use of intents with those features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了硬件组件及意图与这些组件的作用。这一章全是关于Android软件功能以及如何使用意图作为主要接口在我们的应用程序中使用这些功能。Android包含大量的库和API，开发者可以非常容易地使用不同的Android功能。本章将引导我们了解常见的Android功能，并且我们还将开发一些示例应用程序，展示如何与这些功能结合使用意图。
- en: 'This chapter includes the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Features of Android OS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android操作系统的功能
- en: Android features versus components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android功能与组件对比
- en: Common Android OS features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的Android操作系统功能
- en: Android features and intents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android功能和意图
- en: The `<uses-feature>` and `<uses-permission>` tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<uses-feature>`和`<uses-permission>`标签'
- en: Sharing using the SEND action
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SEND动作分享
- en: Sending SMS/MMS using intents
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图发送短信/MMS
- en: Sending data messages using intents
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图发送数据消息
- en: Confirming message delivery
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认消息送达
- en: Receiving SMS
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收短信
- en: Telephony and making calls using intents
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图进行电话通信和拨打电话
- en: Sending notifications using intents
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图发送通知
- en: Some other Android features
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一些Android功能
- en: Tip
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The concepts and structure of intents, as discussed in previous chapters, are
    the prerequisites for understanding this and the following chapters. If you don't
    have the basic concept of these things, we would recommend you to read [Chapter
    3](ch03.html "Chapter 3. Intent and Its Categorization"), *Intents and Its Categorization*
    and [Chapter 4](ch04.html "Chapter 4. Intents for Mobile Components"), *Intents
    for Mobile Components* in order to move forward.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章以及后续章节需要理解意图的概念和结构，这是基本前提。如果你对这些东西的基本概念不了解，我们建议你阅读[第3章](ch03.html "第3章. 意图及其分类")，*意图及其分类*和[第4章](ch04.html
    "第4章. 移动组件的意图")，*移动组件的意图*以便继续深入学习。
- en: Features of Android OS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android操作系统的功能
- en: Android is an open source operating system and middleware framework for smart
    devices such as phones and tablets. The devices contain lots of features and functionalities
    that provide users with a way for an easy lifestyle. These features include hardware
    features such as audio, Bluetooth, camera, network, microphone, GSM, NFC, and
    sensors such as accelerometer, barometer, compass, gyroscope, and Wi-Fi.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android是一个开源的操作系统和智能设备（如手机和平板电脑）的中间件框架。这些设备包含了许多提供用户便捷生活方式的功能和功能。这些功能包括硬件功能，如音频、蓝牙、摄像头、网络、麦克风、GSM、NFC以及诸如加速度计、气压计、指南针、陀螺仪和Wi-Fi等传感器。
- en: Not only does it include hardware components, it also includes software features
    such as app widgets, home screen, input methods, live wallpapers, layouts, storage,
    messaging, multi-language support, browsers, Java support, media support, multi-touch,
    calls, messaging, multitasking, accessibility, external storage, and so on. We
    have already referred to the hardware features as mobile components and discussed
    them in the previous chapters. We will discuss the software features in this chapter
    with practical examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅包括硬件组件，还包括软件特性，如应用小部件、主屏幕、输入法、动态壁纸、布局、存储、消息传递、多语言支持、浏览器、Java支持、媒体支持、多点触控、通话、消息传递、多任务处理、可访问性、外部存储等。我们之前已经将硬件特性称为移动组件，并在前面的章节中进行了讨论。我们将在本章中通过实际示例讨论软件特性。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'We are using two key terms here: components and features. Components such as
    camera, Bluetooth, and so on are the hardware parts of an android phone . The
    feature is the software part of an Android phone, such as an SMS feature, e-mail
    feature, and so on. This chapter is all about software features, their access,
    and their use through intents.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用两个关键词：组件和特性。摄像头、蓝牙等组件是安卓手机的硬件部分。特性是安卓手机的软件部分，如短信特性、电子邮件特性等。本章将介绍软件特性、它们的访问方式以及通过意图使用它们的方式。
- en: Android features versus components
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓特性与组件
- en: Generally, the terms "Android features" and "components" are used interchangeably.
    But for the sake of clarification, we are referring to the keyword *components*
    as a feature that uses hardware and the keyword *features* as an Android feature
    that uses software in its backend. As we discussed in the previous section, Android
    contains lots of components and features that, when ported to any phone, makes
    it a smart phone. Not all the components and features can be used via intents.
    So, we will discuss only those features in detail that can be used by intents.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，“安卓特性”和“组件”这两个词可以互换使用。但为了明确起见，我们将关键词*组件*定义为使用硬件的特性，而将关键词*特性*定义为在后台使用软件的安卓特性。正如我们在上一节中讨论的，安卓包含许多组件和特性，当这些组件和特性被移植到任何手机上时，就使其成为智能手机。并非所有的组件和特性都可以通过意图使用。因此，我们将详细讨论那些可以通过意图使用的特性。
- en: It should be noted that features that use hardware directly or indirectly require
    users to provide permissions to access it. These permissions are provided during
    the application's installation. If the user doesn't provide permissions to the
    application, the application can't access hardware; thus, it can't use that feature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，直接或间接使用硬件的特性需要用户提供访问权限。这些权限在应用程序安装过程中提供。如果用户没有向应用程序提供权限，应用程序将无法访问硬件；因此，它无法使用该特性。
- en: In this chapter, we will learn about those features that use software as backend
    but also require some permissions. We will provide more details about the permissions
    in the following sections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解那些在后台使用软件但还需要一些权限的特性。我们将在以下部分提供有关权限的更多详细信息。
- en: Common Android features
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见安卓特性
- en: Until now, we are only talking about Android features in a general way. In this
    section, we will discuss some of the most common Android features found in Android
    phones and tablets. Each Android device is unique in some way or the other and
    possesses many unique features and components different from other brands and
    phones. But there are some features that are found to be common in all the Android
    phones. Many of these features can be used in our apps irrespective of any specific
    model or phone, and intent is, without any doubt, the most asynchronous and easy
    way to use these features in our applications. Now let's see the Android features
    that are common among many devices and their functionality in a phone.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是以一般方式讨论了安卓特性。在本节中，我们将讨论在安卓手机和平板电脑中常见的一些最常用的安卓特性。每个安卓设备在某些方面都是独一无二的，并且拥有许多与其他品牌和手机不同的独特特性和组件。但是在所有安卓手机中都能找到一些共同的特性。这些特性中的许多可以用于我们的应用程序，无论具体的型号或手机如何，意图无疑是最异步且简单的方式来在应用程序中使用这些特性。现在，让我们看看在许多设备中常见的安卓特性及其在手机中的功能。
- en: Layouts and display
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局和显示
- en: 'Today, smartphones are getting bigger in size, and there are new sets of Android
    devices called tablets that are available. Bigger screens and higher-resolution
    displays have transformed mobiles into multimedia devices. These devices contain
    layout sizes from 240 x 320 to 1268 x 800 pixels and screen sizes from 3 to 11
    inches. These are found in varying device screen densities such as low, medium,
    high, large, extra large, and so on. The following image shows three different
    devices with different resolutions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，智能手机的尺寸越来越大，还有一些新的 Android 设备类型，即平板电脑。更大的屏幕和更高分辨率的显示已经将手机转变为多媒体设备。这些设备拥有从
    240 x 320 到 1268 x 800 像素的布局尺寸和从 3 英寸到 11 英寸的屏幕尺寸。这些设备屏幕密度有所不同，如低、中、高、大、超大等。以下图片展示了三种不同分辨率设备的比较：
- en: '![Layouts and display](img/9639_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![布局和显示](img/9639_06_01.jpg)'
- en: Android devices with different screen sizes
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不同屏幕尺寸的 Android 设备
- en: To display high graphics, Android provides graphic libraries for 2D canvas drawings
    and 3D graphics with OpenGL using OpenGL-ES. A new rendering graphics library
    called RenderScript was introduced after Android Version 3.0\. RenderScript is
    a scripting language for Android OS that allows developers to write high-performance
    graphic rendering and raw computational code. It has been primarily oriented for
    use with parallel data computations like dividing processing across multi-core
    processors such as CPUs, GPUs, or DSPs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示高质量的图形，Android 提供了用于 2D 画布绘图和 3D 图形的图形库，使用 OpenGL-ES 的 OpenGL。在 Android
    3.0 版本之后，引入了一个新的渲染图形库 RenderScript。RenderScript 是一种针对 Android OS 的脚本语言，允许开发者编写高性能图形渲染和原始计算代码。它主要定位于并行数据处理计算，比如在多核处理器（如
    CPU、GPU 或 DSP）之间分配处理。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before Android Version 3.0, which was developed for Android tablets, Android
    rendered its layouts, home screen, and mobile UI using 2D canvas. After RenderScript
    in Android 3.0, Android renders its layouts, home screens, and mobile UI with
    more beautiful and optimized graphics using RenderScript.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 3.0 之前，专为 Android 平板电脑开发的版本，Android 使用 2D 画布来渲染其布局、主屏幕和移动 UI。在 Android
    3.0 引入 RenderScript 之后，Android 使用 RenderScript 以更美观和优化的图形来渲染其布局、主屏幕和移动 UI。
- en: Data storage and retrieval
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据存储与检索
- en: There is no Android device that doesn't use any kind of storage for running.
    For better performance, the device not only needs a volatile memory like RAM for
    the sake of processing and faster access, but it is also going to need a permanent
    storage such as an external SD Card in it. Android devices support data storage
    and retrieval in multiple ways that vary according to the developers and applications
    to be used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有哪种 Android 设备在运行时不需要某种形式的存储。为了更好的性能，设备不仅需要像 RAM 这样的易失性内存以便处理和快速访问，还需要像外部 SD
    卡这样的永久性存储。Android 设备支持多种数据存储和检索方式，这些方式根据开发者和将使用的应用程序而有所不同。
- en: If our applications use large data, the developers can use lightweight relational
    database features for each of their applications using SQLite. Developers can
    use the SQLite database to manage data with secret and efficient storage capability.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序使用大量数据，开发者可以使用 SQLite 轻量级关系数据库功能为每个应用程序提供支持。开发者可以使用 SQLite 数据库来管理具有保密和高效存储能力的数据。
- en: Not only databases, Android devices also provide features for file storage.
    As saving and loading data is essential for almost every application, Android
    provides many different methods to store and retrieve data to make our application
    persistent. File storage is not a good option, but sometimes, developers don't
    have any option other than reading and writing files to handle their application's
    persistent data. And fortunately, Android provides features that let developers
    create, save, and load files on a device's internal or external media, such as
    an SD card. These microSD cards are formatted with the FAT32, Ext3, or Ext4 file
    systems. Not only these file systems, but also some Android devices, mostly tablets,
    support high-capacity storage media such as USB flash drives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅数据库，Android 设备还提供了文件存储功能。由于保存和加载数据对于几乎每个应用程序来说都是至关重要的，Android 提供了多种不同的方法来存储和检索数据，以确保我们应用程序的持久性。文件存储并非最佳选择，但有时，开发者除了读写文件来处理应用程序的持久数据外，别无他法。幸运的是，Android
    提供了功能，让开发者可以在设备的内部或外部媒体上创建、保存和加载文件，比如 SD 卡。这些 microSD 卡采用 FAT32、Ext3 或 Ext4 文件系统格式。不仅有这些文件系统，而且一些
    Android 设备，尤其是平板电脑，支持高容量存储媒体，如 USB 闪存盘。
- en: Apart from storing large or heavy data in databases or disk files, Android provides
    a feature for storing simple application data such as UI state, game scroes, and
    so on. This is achieved using the `SharedPreferences` method. The `SharedPreferences`
    method uses the name/value pair (NVP) mechanism to store the application's lightweight
    data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在数据库或磁盘文件中存储大量或重型数据外，安卓还提供了一个用于存储简单应用程序数据的功能，如UI状态、游戏得分等。这是通过使用`SharedPreferences`方法实现的。`SharedPreferences`方法使用名称/值对（NVP）机制来存储应用程序的轻量级数据。
- en: Connectivity and communication
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和通信
- en: We can't call an Android device a smart phone until there is a connectivity
    feature in it. The technologies supported for connectivity, communication, and
    data transfer include GSM/Edge, IDEN, CDMA, EV-DO, Bluetooth, Wi-Fi, LTE, Near-Field
    Communication (NFC), WiMAX, and so on. Android provides a complete set of libraries
    for communication and connectivity. This allows developers to easily utilize and
    use these features in their applications. For example, through Bluetooth support,
    users can send files, access phone book and voice dialing, and exchange contacts
    between phones.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备连接功能之前，我们不能将一个安卓设备称为智能手机。支持连接、通信和数据传输的技术包括GSM/Edge、IDEN、CDMA、EV-DO、蓝牙、Wi-Fi、LTE、近场通信（NFC）、WiMAX等。安卓提供了一套完整的通信和连接库。这使得开发者可以轻松地在他们的应用程序中使用这些功能。例如，通过蓝牙支持，用户可以发送文件，访问电话簿和语音拨号，以及在不同手机间交换联系人。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Android 3.1 and the later versions, Android contains the native feature of
    connecting keyboard, mouse, and joystick devices with Android phones via Bluetooth
    communication. Before Android 3.1, some third-party applications provided a customized
    way for this purpose.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓3.1及其之后的版本中，安卓包含了通过蓝牙通信将键盘、鼠标和游戏手柄设备与安卓手机连接的原生功能。在安卓3.1之前，一些第三方应用程序为此提供了定制的方法。
- en: Android phones have communication support not only for data transfer but also
    for telephony and messaging. Android contains SMS and MMS for messaging along
    with threaded text messaging and **Android Cloud to Device Messaging** (**C2DM**),
    and the new **Google Cloud Messaging** (**GCM**) is also part of Android Push
    Messaging services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓手机不仅支持数据传输，还支持电话和短信通信。安卓包含了用于短信通信的SMS和MMS，以及线程化文本消息和**安卓云到设备消息传递**（**C2DM**），新的**谷歌云消息传递**（**GCM**）也是安卓推送消息服务的一部分。
- en: For telephony, Android supports calls, but it doesn't have native support for
    video calling (at the time of writing this book); however, some Android devices
    have customized versions of operating systems that allow developers and users
    to make video calls either via UMTS networks (as in Samsung Galaxy S) or over
    IP. Also, Google Hangout, the replacement of Google Talk, is available in Android
    2.3.4 and higher versions. This allows users to make video calls using an Internet
    connection. To use Google Hangout video calling, users need a Google+ account.
    Skype, a third-party tool of Microsoft Corporation, is also used to make video
    calls in Android 2.3 and later versions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电话功能，安卓支持通话，但在撰写本书时并不支持原生视频通话；然而，一些安卓设备定制的操作系统版本允许开发者和用户通过UMTS网络（如三星Galaxy
    S）或IP进行视频通话。此外，谷歌环聊（Google Hangout），取代了谷歌Talk，在安卓2.3.4及更高版本中可用。这允许用户使用互联网连接进行视频通话。要使用谷歌环聊视频通话，用户需要一个谷歌+账户。微软公司的第三方工具Skype也用于在安卓2.3及以后版本中进行视频通话。
- en: Accessibility and multitouch
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性和多点触控
- en: An Android device runs on a fully touch-based interface and contains few hard-
    or soft-touch buttons that vary according to the device. Android devices have
    native support for multi-touch. Multi-touch technology allows developers and users
    to use single touch, tap, double tap, long touch, pinch-zoom gesture, rotate gestures,
    swipe gestures in all directions, and much more. Android's latest version (which
    is Android 4.4 KitKat at the time of writing this book) contains some new touch
    gestures such as tap and long touch gesture, scroll gesture, and so on. Also,
    Samsung introduced touchless gestures that make use of their specific APIs called
    Look API. Through Look API, users can use their phones without touching the screen
    and moving their hands or head in air, and Android will perform the desired functionality.
    For example, moving the head up will scroll the page up, and moving the head down
    will scroll the page down on their phones. Also, many Android device manufacturers,
    such as Samsung, introduced pen features to allow the users to write on their
    phones and use them with pens more easily and accurately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备运行在完全基于触摸的界面上，包含一些硬或软触摸按钮，这些按钮根据设备的不同而有所差异。Android设备原生支持多点触控。多点触控技术允许开发者和用户使用单点触控、轻敲、双击、长按、捏合缩放手势、旋转手势、各个方向的滑动手势等等。Android的最新版本（在撰写本书时是Android
    4.4 KitKat）包含一些新的触摸手势，如轻敲和长按手势、滚动手势等。同时，三星推出了无触摸手势，利用他们特定的API，即Look API。通过Look
    API，用户无需触摸屏幕，只需在空中移动手或头部，Android就会执行所需的功能。例如，头部向上移动将向上滚动页面，头部向下移动将向下滚动页面。此外，许多Android设备制造商，如三星，推出了笔功能，以便用户更轻松、更准确地用笔在手机上书写和使用。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The multi-touch feature was first introduced in the HTC Hero Android phone.
    Before that, the feature was originally disabled at the Linux kernel level due
    to Apple's patents on touch-screen technology at that time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多点触控功能最早是在HTC Hero Android手机中推出的。在那之前，由于当时苹果对触摸屏技术的专利，该功能在Linux内核层面原本是被禁用的。
- en: Along with touch, users can access their phones with a voice or speech recognition
    engine natively introduced in Android phones. Also, Android contains a feature
    called Talkback that allows people with no or low vision to hear what their Android
    phone is doing at a particular time. These people can access their phones using
    voice actions such as calling, texting, navigation, and so on. These voice actions
    were introduced from Android 2.2 onwards. The ability to control hardware is not
    yet (at time of writing this book) available through voice actions in Android.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了触摸操作，用户还可以通过原生引入的语音或语音识别引擎来访问他们的手机。同时，Android包含一个名为Talkback的功能，该功能允许视力不佳的人听到他们的Android手机在特定时间正在进行的操作。这些人可以使用语音操作如拨打电话、发送短信、导航等来访问他们的手机。这些语音操作是从Android
    2.2版本开始引入的。在撰写本书时，通过语音操作控制硬件的能力在Android中尚未实现。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android 4.1 and the later versions provide enhancement over voice actions to
    read answers from Google Knowledge Graph when queried with specific commands only.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.1及其后续版本在语音操作上进行了增强，当使用特定命令查询时，可以读取来自谷歌知识图谱的答案。
- en: Extensive content and media support
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广泛的内容和多媒体支持
- en: An Android device is not less than any computer with high-definition media support.
    Android offers comprehensive APIs for managing images, videos, and audio. The
    formats supported in Android devices include WebM, H.263, H.264, 3GP, MP4, MPEG-4,
    AMR, MP3, MIDI, OGG, WAV, JPEG, PNG, GIF, BMP, and WebP. Not only this, Android
    also provides features for streaming online media using RTP/RTSP protocols, HTML
    progressive downloads such as the HTML5 `<video>` tag, HTTP dynamic streaming
    protocol, and the Adobe Flash Streaming (RTMP) protocol provided by Flash plugins.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备在高清媒体支持方面不亚于任何电脑。Android提供了全面的API来管理图片、视频和音频。Android设备支持的格式包括WebM、H.263、H.264、3GP、MP4、MPEG-4、AMR、MP3、MIDI、OGG、WAV、JPEG、PNG、GIF、BMP和WebP。不仅如此，Android还提供了使用RTP/RTSP协议、HTML渐进式下载（如HTML5
    `<video>`标签）、HTTP动态流媒体协议以及Flash插件提供的Adobe Flash流媒体（RTMP）协议在线流媒体的功能。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: New Android devices support 3D-image capturing. and 3D Video Support as their
    native features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Android设备支持3D图像捕捉和3D视频支持作为其原生功能。
- en: Along with extensive media support, Android also provides playback features,
    controls, players, hard buttons for sound control as with other mobile phones,
    fullscreen playback, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了广泛的多媒体支持外，Android还提供了播放功能、控制选项、播放器、像其他手机一样的声音硬件按钮、全屏播放等。
- en: Android not only has media support but also has content support such as text
    files, word documents, HTML, and so on. The web browsers available in Android
    are based on the open source WebKit layout engine that was first developed by
    Apple Inc. This is coupled with Chrome's V8 JavaScript engine in Android.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓不仅支持多媒体，还支持内容格式，如文本文件、Word文档、HTML等。安卓中可用的网页浏览器基于开源的WebKit布局引擎，该引擎最初由苹果公司开发。这与Chrome的V8
    JavaScript引擎相结合，在安卓系统中使用。
- en: While most Android applications are written in Java natively, Android doesn't
    support Java byte code due to the unavailability of the Java Virtual Machine in
    Android. This Java code is instead compiled in the Dalvik executable and run on
    the Dalvik Virtual Machine, a specialized virtual machine for Android systems.
    The most important thing in Dalvik, which separates it from the Java Virtual Machine,
    is that it is optimized for a low-battery life with limited memory and CPU.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数安卓应用程序原生是用Java编写的，但由于安卓系统中没有Java虚拟机，因此不支持Java字节码。这个Java代码反而被编译成Dalvik可执行文件，在专为安卓系统设计的Dalvik虚拟机上运行。Dalvik最重要的特点是，它与Java虚拟机相比，针对低电量、有限内存和CPU进行了优化。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android browser has got a 100/100 score on Acid3 test in Android 4.0 Version.
    The Acid3 test is a web test page from Web Standards Project that checks a web
    browser's compliance with elements of various web standards such as Document Object
    Model (DOM), JavaScript, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓浏览器在安卓4.0版本中 Acid3 测试得到了100/100的分数。 Acid3 测试是由Web Standards Project提供的网页测试页，用于检查网页浏览器对各种网页标准元素（如文档对象模型（DOM）、JavaScript等）的符合性。
- en: Hardware support
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件支持
- en: An Android device not only provides features of telephony, such as making phone
    calls, sending messages, and so on, but it also has lots of features with new
    hardware components that are used for many different purposes. Android has features
    of video cameras, touchscreens, Global Positioning System (GPS) for location-based
    applications, accelerometers, gyroscopes, barometers, magnetometers, proximity
    sensors, pressure sensors, thermometers, Wi-Fi, Bluetooth, and dedicated gaming
    controls.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备不仅提供了电话功能，如拨打电话、发送短信等，而且还具有许多新硬件组件的多种功能。安卓具有视频摄像头、触摸屏、全球定位系统（GPS）用于基于位置的应用程序、加速度计、陀螺仪、气压计、磁力计、接近传感器、压力传感器、温度计、Wi-Fi、蓝牙和专用的游戏控制功能。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some new Android phones, such as Samsung Galaxy S4, provide new sensors such
    as light and color sensors used to capture touchless gestures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些新的安卓手机，例如三星Galaxy S4，提供了新的传感器，如光和颜色传感器，用于捕捉无需触摸的手势。
- en: With GPS and location-based technology included in Android phones, Android systems
    have got native support for Google Maps, Google's GSM cell-based location technology
    used to determine a device's current position. To make maps more useful for developers
    and users, Android also provides native APIs for forward and reverse geocoding
    support that helps to translate coordinates into address and vice-versa.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓手机包含了GPS和基于位置的技术，因此安卓系统本地支持谷歌地图，以及谷歌基于GSM小区的位置技术，用于确定设备的当前位置。为了使地图对开发者和用户更有用，安卓还提供了本地API，支持正向和反向地理编码，帮助将坐标转换为地址，反之亦然。
- en: Background services and multitasking
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后台服务和多任务处理
- en: Due to limited screen dimensions in Android smart phones, only one application
    becomes visible on the user interface screen. But Android supports applications
    and services running in the background with its multitasking feature. Using background
    services, developers can perform automatic processing that doesn't require any
    user interaction. Some example applications for this feature include generating
    alerts; monitoring messages, statistics, and weather reports; downloading data
    from the Internet; or playing audio files in the background.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安卓智能手机的屏幕尺寸有限，用户界面屏幕上只能显示一个应用程序。但安卓支持多任务功能，可以让应用程序和服务在后台运行。开发者可以利用后台服务执行不需要用户交互的自动处理。这一特性的应用示例包括生成提醒；监控消息、统计和天气预报；从互联网下载数据；或者在后台播放音频文件。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When an Android device gets low on memory, it stops applications with low priority
    in the background. Developers should store the necessary data and state of application
    before going in the background so that on getting stopped, an application can
    restore its state from the saved one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当安卓设备内存不足时，它会停止后台中优先级较低的应用程序。开发者应该在应用程序进入后台之前存储必要的数据和应用程序状态，这样在被停止时，应用程序可以从保存的状态中恢复其状态。
- en: Android also supports the notification feature, a standard traditional approach
    to alert users in their phones. Using Android libraries for notifications, developers
    can make notification alerts that can be audible, vibration supported, or maybe
    LED active. In addition to this, Android also allows developers to set notification
    UI icons, layouts, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓同样支持通知功能，这是一种传统的标准方式，用于在手机中提醒用户。开发者可以使用安卓的通知库来创建可以发出声音、支持震动或者激活LED灯的通知提醒。此外，安卓还允许开发者设置通知界面图标、布局等。
- en: These background applications can be standalone as well as dependent on other
    applications. Android provides features such as intents and content providers
    for inter-application communication methods and mechanisms.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些后台应用程序可以是独立的，也可以依赖于其他应用程序。安卓提供了如意图和内容提供者等特性，用于应用程序间的通信方法和机制。
- en: Enhanced home screen
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的主屏幕
- en: The home screen is like a desktop screen of a computer or laptop. Android users
    get quick links, app shortcuts, and information on their home screen. Android
    provides customizable features for the home screen. Widgets, live folders, and
    live wallpapers make the home screen more interactive and beautiful for users.
    These apps let Android developers create dynamic application components that provide
    a window into your applications or offer useful and timely information directly
    on the home screen. Developers can also provide users with an option to add shortcuts
    on their home screens. These shortcuts will provide users with the necessary information,
    and they won't need to open their apps. For example, we have an app that tells
    us the current time and weather of the day. Now, whenever users want to check
    the time and weather, they have to open the app. So, instead of creating an app
    for this purpose, creating a home screen widget would be much better idea. This
    widget will show the weather and time on the home screen, and users wouldn't have
    to open the app then.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕就像电脑或笔记本电脑的桌面屏幕。安卓用户可以在主屏幕上获得快速链接、应用快捷方式和信息。安卓为主屏幕提供了可定制功能。小部件、活动文件夹和动态壁纸使主屏幕对用户来说更加互动和美观。这些应用程序允许安卓开发者创建动态的应用程序组件，它们可以直接在主屏幕上提供应用程序的窗口或提供有用及时的信息。开发者还可以为用户提供在主屏幕上添加快捷方式的选项。这些快捷方式为用户提供必要的信息，他们无需打开应用程序。例如，我们有一个显示当前时间和天气的应用程序。现在，每当用户想要查看时间和天气时，都需要打开应用。因此，与其为此目的创建应用程序，不如创建一个主屏幕小部件会是一个更好的主意。这个小部件会在主屏幕上显示天气和时间，用户就不需要打开应用程序了。
- en: Other Android features
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓的其他功能
- en: Android developers can develop applications in multiple languages, offering
    the local version of the application to the users. Android provides the feature
    of multilanguage applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发者可以用多种语言开发应用程序，为用户提供应用程序的本地版本。安卓提供了多语言应用程序的特性。
- en: Also, Android supports tethering that allows users to share the network connection
    of a device with other mobile phones and computers. This sharing can be achieved
    via Wi-Fi hot spot or USB tethering.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，安卓支持网络共享功能，允许用户将设备的网络连接分享给其他手机和电脑。这种共享可以通过Wi-Fi热点或USB网络共享来实现。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tethering was introduced in Android 2.2 Version; so, the earlier versions had
    tethering support through third-party applications and manufacturers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 网络共享功能在安卓2.2版本中引入；因此，早期版本通过第三方应用程序和制造商支持网络共享。
- en: Pressing the power and volume-down hard buttons at the same time allows users
    to capture a screenshot of the device. This feature was first introduced in Android
    4.0\. The earlier versions are using third-party applications, but these applications
    need a rooted device as a prerequisite. Developers can also take screenshots using
    the DDMS tool via a PC connection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同时按下电源键和音量减键可以让用户捕获设备的屏幕截图。这个功能最早是在安卓4.0中引入的。早期版本使用第三方应用程序，但这些应用程序需要设备已获得根权限作为前提条件。开发者也可以通过PC连接使用DDMS工具来截图。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rooting any Android device is not allowed, and it breaks all the warranty and
    guarantee deals and can sometimes be a risky procedure for mobiles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任何安卓设备的root操作都是被禁止的，这样做会违反所有的保修和保证协议，有时也可能对手机造成风险操作。
- en: Android features and intents
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓功能和意图
- en: Until now, we have discussed the different features commonly found in Android
    phones and tablets, but we are still unaware of the connection between intents
    and these features. There are some features that can be used via intents and some
    cannot. Simply to remind you, intents are asynchronous messages between different
    applications and the Android system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经讨论了安卓手机和平板电脑中常见的不同功能，但我们仍然不知道意图（intents）与这些功能之间的联系。有些功能可以通过意图使用，而有些则不能。简单提醒一下，意图是不同应用程序与安卓系统之间的异步消息。
- en: 'In this chapter, we will discuss a few features that can be used through intents,
    and see how intents perform various actions. We have divided the features into
    four sections: messaging, telephony, notifications, and alarms. We will develop
    some examples that will use intents and access these features, and we will discuss
    how these features are accessed and the role of intents in them.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些可以通过意图使用的功能，并了解意图是如何执行各种动作的。我们将功能分为四个部分：消息传递、电话、通知和闹钟。我们将开发一些使用意图并访问这些功能的示例，并讨论如何访问这些功能以及意图在其中的作用。
- en: Before we start discussing these example applications, we are going to discuss
    some basic terminology used in Android for the clarification of concepts between
    intents and features. In the next section, we will discuss two different tags,
    `uses-feature` and `uses-permission`, from the `AndroidManifest` file. These tags
    are used to declare some permissions and settings for any Android application.
    Let's see what they are for in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始讨论这些示例应用程序之前，我们将讨论一些在安卓中用于澄清意图和功能之间概念的基本术语。在下一节中，我们将讨论 `AndroidManifest`
    文件中的两个不同标签，`uses-feature` 和 `uses-permission`。这些标签用于声明任何安卓应用程序的一些权限和设置。让我们在下一节中看看它们的作用。
- en: The <uses-feature> and <uses-permission> tags
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<uses-feature>` 和 `<uses-permission>` 标签'
- en: Any Android application, by default, doesn't have the permission to perform
    any operations that impact any other application, system, or the user directly
    or indirectly. This includes reading or writing the user's private data such as
    contacts and messages, reading or writing other applications' files, or any other
    activity. The Android system allows applications to be standalone and sandboxed,
    but in case of sharing data, the applications must explicitly share it with each
    other. To achieve this objective of sharing more easily, Android allows developers
    to declare permissions in their applications for the activities that the app wants
    to perform. Users will be informed about the permissions that allow them to install
    the application on their devices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何安卓应用程序默认情况下都没有权限执行可能直接影响其他应用程序、系统或用户的行为。这包括读取或写入用户的私人数据，如联系人和短信，读取或写入其他应用程序的文件，或任何其他活动。安卓系统允许应用程序独立运行并被沙盒化，但在共享数据的情况下，应用程序必须明确地相互共享。为了更轻松地实现这一共享目标，安卓允许开发者在他们的应用程序中声明所需执行活动的权限。用户将被通知有关允许他们在设备上安装应用程序的权限。
- en: 'Developers need to bear two things in mind regarding permissions: the permissions
    for device capabilities such as accessing camera or hardware and defining custom
    permissions. We will be discussing the first option of accessing device features
    and hardware and granting permissions to the application in this topic. This can
    be achieved using two tags in the manifest file: the `uses-feature` tag and the
    `uses-permission` tag.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要记住关于权限的两件事：设备功能的权限，如访问相机或硬件，以及定义自定义权限。在本主题中，我们将讨论第一种选择，即访问设备功能和硬件，并授予应用程序权限。这可以通过在清单文件中使用两个标签来实现：`uses-feature`
    标签和 `uses-permission` 标签。
- en: 'Firstly, we will talk about the `<uses-feature>` tag. The `<uses-feature>`
    tag lets the developers declare any single hardware or software feature to be
    used by the application. This is declared in the `AndroidManifest` file in the
    `<manifest>` tag of the application, and as the name of tag suggests, this informs
    the application about the dependent entities to be accessed. The following code
    snippet shows the general declaration of the `<uses-feature>` tag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论`<uses-feature>`标签。`<uses-feature>`标签允许开发者声明应用程序将使用的任何单一硬件或软件特性。这将在应用程序的`AndroidManifest`文件的`<manifest>`标签中声明，正如标签名称所暗示的，这会通知应用程序有关要访问的依赖实体。以下代码段展示了`<uses-feature>`标签的一般声明方式：
- en: '![The <uses-feature> and <uses-permission> tags](img/9639_06_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![`<uses-feature>`和`<uses-permission>`标签](img/9639_06_02.jpg)'
- en: 'You can see that there are three attributes in the `<uses-feature>` tag: `name`,
    `required`, and `glEsVersion`. The `android:name` attribute specifies any single
    hardware or software feature used by the application in the form of a string descriptor.
    The `android:required` attribute is quite an important attribute in the `<uses-feature>`
    tag. It is a Boolean value indicating if an application needs the feature that
    is specified in the `android:name` attribute. If the developer declares `android:required="true"`
    for any feature, it means that the application won''t run without the specified
    feature available on the device. If the developer declares `android:required="false"`
    for the feature, it means that the application prefers the feature to be available
    on the device. If the feature is not available, the application won''t work properly
    or may crash when using the feature due to its unavailability. The default for
    this attribute is true. The final attribute in the `<uses-feature>` tag is `android:glEsVersion`.
    This is a version number represented in 16 bits. This attribute specifies the
    OpenGL ES version that the application will use. For example, we are using a camera
    in our application. The following code snippet shows how to declare the permissions
    for a camera in the manifest file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`<uses-feature>`标签中有三个属性：`name`、`required`和`glEsVersion`。`android:name`属性以字符串描述符的形式指定应用程序使用的任何单一硬件或软件特性。`<uses-feature>`标签中的`android:required`属性相当重要。它是一个布尔值，表示应用程序是否需要`android:name`属性中指定的特性。如果开发者对任何特性声明`android:required="true"`，这意味着没有指定特性在设备上可用时，应用程序将无法运行。如果开发者对特性声明`android:required="false"`，这意味着应用程序希望设备上有该特性。如果该特性不可用，应用程序可能无法正常工作，或者在尝试使用不可用的特性时可能会崩溃。此属性的默认值为true。`<uses-feature>`标签中的最后一个属性是`android:glEsVersion`。这是一个16位表示的版本号。此属性指定应用程序将使用的OpenGL
    ES版本。例如，我们的应用程序中使用了摄像头。以下代码段展示了如何在清单文件中为摄像头声明权限：
- en: '![The <uses-feature> and <uses-permission> tags](img/9639_06_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![`<uses-feature>`和`<uses-permission>`标签](img/9639_06_03.jpg)'
- en: You can see in the code that we have used the `android.hardware.camera` string
    for the `android:name` attribute. This string declares the camera feature of Android,
    and other attributes declare that the application requires the camera feature
    and supports the OpenGL ES 1.0 Version for it to work properly. The developer
    must specify each feature used in the application in a separate `<uses-feature>`
    tag; so, if the application requires multiple features, multiple tags should be
    declared in the manifest file. It is a good practice to declare all the features
    used in an application. These declared tags of `<uses-feature>` only provide information,
    and the Android system doesn't check for matching features before the installation
    of the application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中看到，我们使用了`android.hardware.camera`字符串作为`android:name`属性。这个字符串声明了Android的摄像头特性，其他属性声明应用程序需要摄像头特性，并支持OpenGL
    ES 1.0版本以便它能正常工作。开发者必须在应用程序中为每个使用的特性在单独的`<uses-feature>`标签中指定；因此，如果应用程序需要多个特性，应在清单文件中声明多个标签。声明应用程序中使用的所有特性是一个好习惯。这些声明的`<uses-feature>`标签只提供信息，Android系统在应用程序安装前不会检查匹配的特性。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Google Play uses the `<uses-feature>` tag declared in the manifest file to filter
    the application from devices that do not meet its software and hardware requirements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play使用在清单文件中声明的`<uses-feature>`标签，来过滤掉不符合其软件和硬件要求的设备上的应用程序。
- en: The `<uses-feature>` tag was first introduced in API Level 4\. The earlier versions
    simply ignore this tag if an application containing the `<uses-feature>` tag is
    running on lower-version devices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`<uses-feature>`标签最早在API级别4中引入。如果包含`<uses-feature>`标签的应用在低版本设备上运行，早期版本会忽略此标签。'
- en: 'The following tables show a list of a few feature types and name strings for
    hardware and software features respectively. They can be used in the `<uses-feature>`
    tag''s `android:name` attribute:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了硬件和软件特性的一些特性类型和名称字符串。它们可以用于`<uses-feature>`标签的`android:name`属性中：
- en: Hardware features
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件特性
- en: '| Feature type | Feature descriptor (Android name) | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 特性类型 | 特性描述符（Android名称） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Bluetooth | `android.hardware.bluetooth` | This feature allows the application
    to use Bluetooth of the device. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 蓝牙 | `android.hardware.bluetooth` | 此特性允许应用使用设备的蓝牙功能。 |'
- en: '| Camera | `android.hardware.camera` | This feature allows the application
    to use the camera component of the device. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 相机 | `android.hardware.camera` | 此特性允许应用使用设备的相机组件。 |'
- en: '| `android.hardware.camera.flash` | This is subfeature that allows the application
    to use the device''s camera''s flash. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `android.hardware.camera.flash` | 这是一个子特性，允许应用使用设备的相机闪光灯。 |'
- en: '| Location | `android.hardware.location.gps` | This subfeature allows the application
    to use the precise location coordinates obtained from the Global Position System
    (GPS) receiver of the device. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `android.hardware.location.gps` | 此子特性允许应用使用从设备的全球定位系统（GPS）接收器获得的精确位置坐标。
    |'
- en: '| Sensors | `android.hardware.sensor.accelerometer` | This feature allows the
    application to use motion reading from the accelerometer sensor of the device.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 传感器 | `android.hardware.sensor.accelerometer` | 此特性允许应用使用设备加速度传感器的运动读数。 |'
- en: '| `android.hardware.sensor.compass` | This feature allows the application to
    use directional readings from a compass of the device. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `android.hardware.sensor.compass` | 此特性允许应用使用设备指南针的方向读数。 |'
- en: '| `android.hardware.sensor.proximity` | This feature allows the application
    to use the proximity sensor of the device. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `android.hardware.sensor.proximity` | 此特性允许应用使用设备的距离传感器。 |'
- en: '| Screen | `android.hardware.screen.landscape` | This feature sets the application''s
    screen orientation to landscape. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 屏幕 | `android.hardware.screen.landscape` | 此特性将应用屏幕方向设置为横屏。 |'
- en: '| `android.hardware.screen.portrait` | This feature sets the application''s
    screen orientation to portrait. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `android.hardware.screen.portrait` | 此特性将应用屏幕方向设置为竖屏。 |'
- en: '| Touchscreen | `android.hardware.touchscreen.multitouch` | This subfeature
    allows the application to use two-point multi-touch capabilities such as Pinch.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 触摸屏 | `android.hardware.touchscreen.multitouch` | 此子特性允许应用使用两点触控功能，如捏合。 |'
- en: '| Wi-Fi | `android.hardware.wifi` | This feature allows the application to
    use the Wi-Fi component of the device. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Wi-Fi | `android.hardware.wifi` | 此特性允许应用使用设备的Wi-Fi组件。 |'
- en: Software features
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件特性
- en: '| Feature Type | Feature Descriptor (Android name) | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 特性类型 | 特性描述符（Android名称） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| App Widgets | `android.software.app_widgets` | The feature allows the application
    to include app widgets and can be installed on devices having a home screen. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 应用小部件 | `android.software.app_widgets` | 此特性允许应用包含应用小部件，并且可以安装在具有主屏幕的设备上。
    |'
- en: '| Home Screen | `android.software.home_screen` | The feature allows the application
    to behave as a home screen replacement of the device. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 主屏幕 | `android.software.home_screen` | 此特性允许应用作为设备主屏幕的替代。 |'
- en: '| Input Method | `android.software.input_methods` | This feature allows the
    application to provide custom input methods. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 输入法 | `android.software.input_methods` | 此特性允许应用提供自定义输入法。 |'
- en: '| Live Wallpaper | `android.software.live_wallpaper` | This feature allows
    the application to provide live wallpapers. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 动态壁纸 | `android.software.live_wallpaper` | 此特性允许应用提供动态壁纸。 |'
- en: We haven't shown all the features and descriptors in the preceding tables. We
    have only presented some of the most commonly used features. The table shows the
    feature type of each feature, its feature name descriptor to be used in the `android:name`
    tag, and a short description of what the feature will do and how it will affect
    the application in the device.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面表格中并未展示所有特性和描述符。我们只列出了一些最常用的特性。表格展示了每个特性的特性类型，用于`android:name`标签的特性名称描述符，以及特性将如何影响设备中应用的功能的简短描述。
- en: Some features are categorized as hardware features and some as software features.
    Hardware features are the features that use hardware components on the backend.
    To access these hardware components, our application should have the permission
    to access the hardware. It should be noted that the `<uses-feature>` tag is just
    informative, and it only tells the user that the application is using some specific
    feature in the app. It doesn't allow access to the application for using any specific
    feature or component.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特性被归类为硬件特性，一些则为软件特性。硬件特性是使用后端硬件组件的特性。为了访问这些硬件组件，我们的应用程序应具有访问硬件的权限。需要注意的是`<uses-feature>`标签只是提供信息，它只告诉用户应用程序正在使用某些特定功能。它并不允许应用程序使用任何特定功能或组件的访问权限。
- en: 'To allow the application to use any specific component, Android provides another
    tag, `<uses-permission>`. This tag provides access of a component to the application
    if the user allows it at the time of installation. The following code snippet
    shows the syntax for writing the `<uses-permission>` tag in the manifest file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序使用任何特定的组件，安卓提供了另一个标签`<uses-permission>`。如果用户在安装时允许，此标签将提供应用程序访问组件的权限。以下代码片段展示了在清单文件中编写`<uses-permission>`标签的语法：
- en: '![Software features](img/9639_06_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![软件特性](img/9639_06_04.jpg)'
- en: 'The `<uses-permission>` tag requests any specific permission that the application
    must be granted for it to operate properly. Permissions are only granted by the
    user at the time of the installation of the application. Unlike the `<uses-feature>`
    tag, the `<uses-permission>` tag only has a single `android:name` attribute. The
    only attribute of the tag specifies the name of the permission. The name of the
    permission can be defined using the `<permission>` tag (this is beyond the scope
    of the book, and we will not discuss it) or using standard permission names provided
    by the Android system. For example, to allow application to read phone contacts,
    we can write a code snippet like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`<uses-permission>`标签请求应用程序必须获得的任何特定权限，以便它能正常运作。权限仅在应用程序安装时由用户授予。与`<uses-feature>`标签不同，`<uses-permission>`标签只有一个`android:name`属性。该标签的唯一属性指定了权限的名称。权限名称可以使用`<permission>`标签定义（这超出了本书的范围，我们不会讨论），或者使用安卓系统提供的标准权限名称。例如，为了允许应用程序读取电话联系人，我们可以编写如下代码片段：'
- en: '![Software features](img/9639_06_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![软件特性](img/9639_06_05.jpg)'
- en: You can see how we provided a standard permission name from the `android.permission`
    package for reading the contacts of the phone.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们是如何从`android.permission`包提供了一个标准的权限名称，以便读取手机的联系人。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The features declared through the `<uses-feature>` tag are used by Google Play
    to filter the application, and the permissions declared through the `<uses-permission>`
    tag are presented to the user at the time of installation for granting access.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`<uses-feature>`标签声明的特性被谷歌应用市场用来筛选应用程序，而通过`<uses-permission>`标签声明的权限将在安装时向用户展示，以获取访问权限。'
- en: 'Some of the `<uses-feature>` tag name descriptors were added in the API after
    the `<uses-permission>` tag descriptors. Due to this, some applications using
    the `<uses-permission>` tag were able to use specific hardware without the need
    of declaring the `<uses-feature>` tag in the manifest file. To prevent the applications
    from any unexpected issues regarding this mismatch, some permissions are implied
    with some features. Google Play assumes that certain hardware-related permissions
    indicate that the underlying hardware features are required by default. The `<uses-feature>`
    tag allows Google Play to filter the applications in the market and show only
    those applications that the device is capable of running to the user. However,
    the `<uses-permission>` tag performs its duty when a user downloads the application
    and installs it. Before installation, the user is asked to grant access of all
    the permissions specified in the application. The application will only be installed
    when the user grants access. So, for those features that have both the `<uses-feature>`
    and `<uses-permission>` tag name descriptors, it is a good practice to declare
    both in the manifest of the application for it to work properly. The following
    table shows some of the features that are implied by the permissions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `<uses-feature>` 标签名称描述符是在 `<uses-permission>` 标签描述符之后添加到 API 中的。因此，一些使用
    `<uses-permission>` 标签的应用程序能够在不声明清单文件中的 `<uses-feature>` 标签的情况下使用特定硬件。为了防止应用程序因这种不匹配而出现任何意外问题，一些权限与某些功能相关联。Google
    Play 假定某些与硬件相关的权限默认表示需要底层硬件功能。`<uses-feature>` 标签允许 Google Play 在市场上筛选应用程序，只向用户展示设备能够运行的应用程序。然而，当用户下载并安装应用程序时，`<uses-permission>`
    标签执行其职责。在安装之前，会要求用户授予应用程序中指定的所有权限。只有当用户授权时，应用程序才会安装。因此，对于那些既有 `<uses-feature>`
    又有 `<uses-permission>` 标签名称描述符的功能，在应用程序的清单中声明两者是一个好习惯，以确保其正常工作。以下表格展示了一些由权限暗示的功能：
- en: '| Category | <uses-permission> descriptor | <uses-feature> descriptor |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | `<uses-permission>` 描述符 | `<uses-feature>` 描述符 |'
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Bluetooth | `android.permission.BLUETOOTH` | `android.hardware.bluetooth`
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 蓝牙 | `android.permission.BLUETOOTH` | `android.hardware.bluetooth` |'
- en: '| Camera | `android.permission.CAMERA` | `android.hardware.camera` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 摄像头 | `android.permission.CAMERA` | `android.hardware.camera` |'
- en: '| Location | `android.permission.ACCESS_COARSE_LOCATION` | `android.hardware.location``android.hardware.location.network`
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `android.permission.ACCESS_COARSE_LOCATION` | `android.hardware.location``android.hardware.location.network`
    |'
- en: '| `android.permission.ACCESS_FINE_LOCATION` | `android.hardware.location.gps``android.hardware.location`
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `android.permission.ACCESS_FINE_LOCATION` | `android.hardware.location.gps``android.hardware.location`
    |'
- en: '| Microphone | `android.permission.RECORD_AUDIO` | `android.hardware.microphone`
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 麦克风 | `android.permission.RECORD_AUDIO` | `android.hardware.microphone` |'
- en: '| Telephony | `android.permission.CALL_PHONE` | `android.hardware.telephony`
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 电话 | `android.permission.CALL_PHONE` | `android.hardware.telephony` |'
- en: '| `android.permission.PROCESS_OUTGOING_CALLS` | `android.hardware.telephony`
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `android.permission.PROCESS_OUTGOING_CALLS` | `android.hardware.telephony`
    |'
- en: '| `android.permission.READ_SMS` | `android.hardware.telephony` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `android.permission.READ_SMS` | `android.hardware.telephony` |'
- en: '| `android.permission.RECIEVE_SMS` | `android.hardware.telephony` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `android.permission.RECIEVE_SMS` | `android.hardware.telephony` |'
- en: '| `android.permission.SEND_SMS` | `android.hardware.telephony` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `android.permission.SEND_SMS` | `android.hardware.telephony` |'
- en: '| `android.permission.WRITE_SMS` | `android.hardware.telephony` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `android.permission.WRITE_SMS` | `android.hardware.telephony` |'
- en: '| Wi-Fi | `android.permission.ACCESS_WIFI_STATE` | `android.hardware.wifi`
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Wi-Fi | `android.permission.ACCESS_WIFI_STATE` | `android.hardware.wifi`
    |'
- en: You can see in the table that all the features that are implied by permissions
    are hardware features and require hardware components to run the application properly.
    So, it has already been made clear that developer should declare both the `<uses-feature>`
    and `<uses-permission>` tags to filter in Google Play and properly install it
    on the device without creating any hassle for the user and developer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中可以看出，所有由权限暗示的功能都是硬件功能，需要硬件组件才能正常运行应用程序。因此，已经明确指出开发者应该声明 `<uses-feature>`
    和 `<uses-permission>` 标签，以便在 Google Play 中筛选并在设备上正确安装，不会给用户和开发者造成任何麻烦。
- en: Sharing using the SEND action
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SEND 动词分享
- en: Any cell phone's primary purpose is to provide an easy way of communication.
    And like all cell phones, Android smartphones provide an easier way of communication.
    In this era of the Internet and social networking, Android phones have proved
    to be quite productive in sharing and social networks. Android provides features
    such as sharing pictures, status, sending e-mails, social networking such as Facebook,
    Twitter, and so on. Fortunately for developers, all these sharing features can
    be used very easily using a few lines of intents. Intent has proved to be a very
    good way of performing asynchronous communication within Android's components
    and apps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 任何手机的主要目的都是提供一种简单的通信方式。像所有手机一样，Android智能手机提供了一种更简单的通信方式。在这个互联网和社交网络的时代，Android手机在共享和社交网络方面被证明是非常高效的。Android提供了诸如共享图片、状态、发送电子邮件、社交网络（如Facebook、Twitter等）的功能。幸运的是，对于开发者来说，所有这些共享功能都可以通过几行意图代码非常容易地实现。意图被证明是在Android组件和应用程序内部执行异步通信的一个非常好的方式。
- en: In [Chapter 3](ch03.html "Chapter 3. Intent and Its Categorization"), *Intents
    and Its Categorization*, we discussed an example of sharing status using intents.
    We will explain the same `SEND` intent in more detail in this chapter, and see
    how we can share images and text via any medium on the user's choice. When it
    comes to sharing anything on Android phones, the intents with the `SEND` action
    are used a lot. In this section, we will discuss intents with the `SEND` action
    to see what is possible with it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 意图及其分类")中，我们讨论了使用意图共享状态的示例。在本章中，我们将更详细地解释同样的`SEND`意图，并查看如何通过用户选择的任何媒介共享图像和文本。当涉及到在Android手机上共享任何东西时，带有`SEND`动作的意图被广泛使用。在本节中，我们将讨论带有`SEND`动作的意图，以了解它能够实现的功能。
- en: 'To define the intent with the `SEND` action, the following code snippet shows
    the declaration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`SEND`动作定义意图，以下代码段展示了其声明：
- en: '![Sharing using the SEND action](img/9639_06_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_06.jpg)'
- en: 'You can see that we have passed a string constant of `Intent.ACTION_SEND` in
    the constructor of the intent. This string constant tells the Android system that
    the intent is meant to send anything on a device. We can execute the following
    intent by calling the `startActivity()` method as shown in the following code
    snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在意图的构造函数中传递了`Intent.ACTION_SEND`的字符串常量。这个字符串常量告诉Android系统，意图是用来在设备上发送任何东西的。我们可以通过调用以下代码段中显示的`startActivity()`方法来执行以下意图：
- en: '![Sharing using the SEND action](img/9639_06_07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_07.jpg)'
- en: 'Passing the `SEND` intent in the `startActivity()` method will allow the user
    to choose his favorite way of sending by providing a dialog of all the possible
    sharing applications. But if we pass the `SEND` intent in the `startActivity()`
    method without setting the intent type, it will throw a runtime exception. The
    following log shows some lines of the exception thrown at runtime:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startActivity()`方法中传递`SEND`意图将允许用户通过提供所有可能的共享应用程序的对话框，选择他喜欢的发送方式。但是，如果我们没有设置意图类型就在`startActivity()`方法中传递`SEND`意图，它将抛出一个运行时异常。以下日志显示了运行时抛出的一些异常行：
- en: '![Sharing using the SEND action](img/9639_06_08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_08.jpg)'
- en: 'In the log, you can see `"Unable to start activity"` and then `android.content.ActivityNotFoundException`
    is thrown. This exception is thrown when a call to the `startActivity(intent)`
    method or one of its variants fails because an activity cannot be found to execute
    the given intent. Not only the type of exception, but also the log shows the reason
    behind the failure of the activity. It says `"No activity is found to handle the
    intent"`. You might be wondering why Android couldn''t find the suitable activity
    to receive the intent. Recall implicit intents from earlier chapters, Android
    looks for all the possible activities matching the intent type and shows all those
    apps in a dialog. In our case, we haven''t defined any type for the intent except
    its `Intent.ACTION_SEND` action; that''s why we are getting a runtime exception
    of `ActivityNotFoundException`. Let''s set the type of action and see the dialog
    that shows all the possible apps to receive the intent:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，你可以看到`"Unable to start activity"`，然后抛出了`android.content.ActivityNotFoundException`。当调用`startActivity(intent)`方法或其变体失败时，因为找不到执行给定意图的活动，就会抛出此异常。不仅异常类型，而且日志还显示了活动失败的原因。它说`"No
    activity is found to handle the intent"`。你可能想知道为什么Android找不到适合接收意图的活动。回想一下前面的章节中的隐式意图，Android会查找所有可能与意图类型匹配的活动，并在对话框中显示所有这些应用程序。在我们的例子中，除了它的`Intent.ACTION_SEND`动作外，我们没有为意图定义任何类型；这就是为什么我们会得到`ActivityNotFoundException`的运行时异常。让我们设置动作的类型，看看显示所有可能接收意图的应用程序的对话框：
- en: '![Sharing using the SEND action](img/9639_06_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作分享](img/9639_06_09.jpg)'
- en: You can see that we have called the `setType()` method and passed a string of
    the `text/html` type. This method sets an explicit MIME data type of the intent.
    This is used to create intents that only specify type and not the data. These
    are the commonly used implicit intents in Android systems. This method clears
    any data of the intent that was set previously.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到调用了`setType()`方法，并传递了一个`text/html`类型的字符串。这个方法设置了意图的显式MIME数据类型。这通常用于创建只指定类型而不指定数据的意图。这是Android系统中常用的隐式意图。此方法会清除之前设置的任何意图数据。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The MIME type matching in the Android framework is case sensitive. So, you should
    always write your MIME type with lowercase letters. You can also use `normalizeMimeType(String)`
    method to ensure that it is converted to lowercase.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Android框架中的MIME类型匹配是区分大小写的。因此，你应始终使用小写字母书写你的MIME类型。你也可以使用`normalizeMimeType(String)`方法确保它被转换为小写。
- en: 'We have passed `text/html` as the MIME type in method argument. This type tells
    the Android system that all those applications that support the HTML type of data
    and process it can receive this intent. So, in a result, Android pushes all those
    applications in a dialog to let the user choose his/her favorite application.
    The following image shows the dialog for the `text/html` type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法参数中传递了`text/html`作为MIME类型。这个类型告诉Android系统，所有支持HTML类型数据处理的应用程序都可以接收这个意图。因此，结果就是Android会将所有这些应用程序推送到对话框中，让用户选择他/她喜欢的应用程序。以下图片展示了`text/html`类型的对话框：
- en: '![Sharing using the SEND action](img/9639_06_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作分享](img/9639_06_10.jpg)'
- en: You can see that all the apps supporting HTML type content are shown in the
    image, such as **Email**, **Imo Messenger**, and **Skype**. You can see how easy
    it is to share content using the `SEND` intent in Android phones, and the job
    of choosing apps and launching them is left to Android.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到所有支持HTML类型内容的程序都显示在图片中，比如**电子邮件**、**Imo Messenger**和**Skype**。你可以看到在Android手机上使用`SEND`意图分享内容是多么容易，选择应用程序并启动它们的工作留给了Android。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that there is no SMS/MMS-sending application shown in the
    dialog because SMS/MMS are just plain text applications and they support only
    that type of content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到对话框中没有显示短信/彩信发送应用程序，因为短信/彩信只是纯文本应用程序，它们只支持那种类型的内容。
- en: 'On choosing any option from the list, the app will start. As we haven''t set
    any content to be shared, the application will be mostly empty. To set the content
    in the intent, we have to use extras. We will put extras for some information
    such as title, subject, or text. The following code snippet shows how to put some
    extras in the `SEND` intent:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中选择任何选项后，应用将会启动。由于我们没有设置任何要分享的内容，应用程序将基本上是空的。要在意图中设置内容，我们必须使用额外的信息（extras）。我们会为一些信息如标题、主题或文本添加额外的信息。以下代码片段展示了如何在`SEND`意图中添加一些额外的信息：
- en: '![Sharing using the SEND action](img/9639_06_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作分享](img/9639_06_11.jpg)'
- en: 'You can see in the code that after setting the MIME type of intent, we have
    called the `putExtra()` method few times. This method adds extended data to the
    intent. There are two parameters of the function: `name` and `value`. The `name`
    parameter must include a package prefix; for example, the app `com.android.contacts`
    would use names like `com.android.contacts.ShowAll`. We have passed three strings
    for subject, title, and text content of the intent. The names such as `Intent.EXTRA_SUBJECT`,
    `Intent.EXTRA_TITLE`, and `Intent.EXTRA_TEXT` for these types of data are already
    declared in the `Intent` class, and we can access those in a static manner. You
    might be thinking why we have passed the subject if we have passed the title string
    as well. Well, the `SEND` intent is an implicit intent, and Android shows all
    the apps supporting the intent. The user can choose any app as different apps
    are interested in different data. For example, any e-mail application will be
    interested in the Subject, To, and Body strings. And any SMS application will
    only be interested in the To and Body strings. So, for efficient usage of the
    `SEND` intent, you should add all the possible content to share it with every
    application effectively. Let''s take an example of sending an e-mail using the
    `SEND` intent. The following code snippet shows how we can use the `SEND` intent
    to send an e-mail:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中看到，在设置意图的MIME类型之后，我们多次调用了`putExtra()`方法。这个方法向意图中添加扩展数据。该函数有两个参数：`name`和`value`。`name`参数必须包含一个包前缀；例如，应用`com.android.contacts`会使用像`com.android.contacts.ShowAll`这样的名称。我们为意图的主题、标题和文本内容传递了三个字符串。这类数据的名称，如`Intent.EXTRA_SUBJECT`、`Intent.EXTRA_TITLE`和`Intent.EXTRA_TEXT`在`Intent`类中已经声明，我们可以以静态方式访问它们。你可能会想，既然我们已经传递了标题字符串，为什么还要传递主题呢？嗯，`SEND`意图是一个隐式意图，Android显示了所有支持该意图的应用。用户可以选择任何应用，因为不同的应用对不同的数据感兴趣。例如，任何电子邮件应用都会对主题、收件人和正文字符串感兴趣。而任何短信应用只会对收件人和正文字符串感兴趣。因此，为了有效地使用`SEND`意图，你应该添加所有可能的内容，以便有效地与每个应用共享。以下是一个使用`SEND`意图发送电子邮件的示例。以下代码段展示了我们如何使用`SEND`意图来发送电子邮件：
- en: '![Sharing using the SEND action](img/9639_06_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_12.jpg)'
- en: 'Firstly, we have declared our `SEND` intent by passing the `Intent.ACTION_SEND`
    parameter of constructor. Then, we have set the type of intent by the `calling
    setType()` method to the `"text/html"` MIME type. We then add the extra content
    for the e-mail app as shown in the following list:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过传递`Intent.ACTION_SEND`参数给构造函数来声明我们的`SEND`意图。然后，我们通过调用`setType()`方法将意图的类型设置为`"text/html"`
    MIME类型。接下来，我们为电子邮件应用添加额外的内容，如下列表所示：
- en: '`Intent.EXTRA_SUBJECT`: This name constant is used to add the Subject.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_SUBJECT`：此名称常量用于添加主题。'
- en: '`Intent.EXTRA_EMAIL`: This name constant is used to fill an e-mail address
    in the To field.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_EMAIL`：此名称常量用于填充收件人字段中的电子邮件地址。'
- en: '`Intent.EXTRA_CC`: This name constant is used to fill the e-mail address in
    the Cc field.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_CC`：此名称常量用于填充Cc字段的电子邮件地址。'
- en: '`Intent.EXTRA_BCC`: This name constant is used to fill the e-mail address in
    the Bcc field.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intent.EXTRA_BCC`：此常量用于填充Bcc字段的电子邮件地址。'
- en: 'Finally, before calling the `startActivity()` method, we put body of the e-mail
    by the `Intent.EXTRA_TEXT` name constant and pass our text in the value parameter
    of the `putExtra()` method. The `startActivity()` method will show the same dialog
    as shown in the previous image, and on choosing an e-mail application, it will
    show the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`startActivity()`方法之前，我们通过`Intent.EXTRA_TEXT`这个名称常量来设置电子邮件的正文，并在`putExtra()`方法的值参数中传递我们的文本。`startActivity()`方法将显示与之前图像相同的对话框，并在选择电子邮件应用后，显示以下截图：
- en: '![Sharing using the SEND action](img/9639_06_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用SEND动作共享](img/9639_06_14.jpg)'
- en: An e-mail application already filled with content put in intent
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已经使用意图中的内容填充的电子邮件应用
- en: You can see from the image that all the data we put into extras is already filled
    in the e-mail application such as subject, e-mail, text etc. Now, all that the
    users have to do is to tap the **Send** button and the e-mail will be sent. In
    this example application, we have sent an e-mail to one address directly using
    the To field and indirectly by Cc and Bcc to two other addresses. Android allows
    us to add multiple e-mail addresses as well. The name constant `Intent.EXTRA_EMAIL`
    is used for this purpose. We have passed an address in the code; we can also pass
    arrays of strings consisting of e-mail addresses to send the e-mails to.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从图片中可以看出，我们放入extras的所有数据都已自动填充到电子邮件应用中，如主题、电子邮件、文本等。现在，用户只需轻触**发送**按钮，电子邮件就会被发送。在这个示例应用中，我们直接通过To字段向一个地址发送了电子邮件，并通过Cc和Bcc间接向另外两个地址发送。安卓允许我们添加多个电子邮件地址。为此，使用了名称常量`Intent.EXTRA_EMAIL`。我们在代码中传递了一个地址；我们还可以传递包含电子邮件地址的字符串数组，以发送电子邮件。
- en: From this section, we have mostly learned about how the `ACTION_SEND` intent
    is used and how much work we can do with just a few lines of code using this intent.
    If we choose Facebook, Twitter, or any other application from the dialog, we will
    see the same result of sharing data via that app. This is the power of using implicit
    intents to make it general in almost every possible way without doing any hard
    development work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节内容中，我们主要了解到`ACTION_SEND`意图是如何被使用的，以及仅用几行代码就能通过此意图完成多少工作。如果我们从对话框中选择Facebook、Twitter或任何其他应用，我们会看到通过该应用分享数据的相同结果。这就是使用隐式意图的强大之处，几乎在每种可能的情况下都能使其通用，而无需进行任何复杂开发工作。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`ACTION_SEND` is an action of the intent. Like this action, there are other
    actions such as `ACTION_VIEW`, `ACTION_SEARCH` that can be used by passing in
    intents for other purposes in Android.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACTION_SEND`是意图的一个动作。像这个动作一样，还有其他动作，如`ACTION_VIEW`、`ACTION_SEARCH`，可以通过传递意图用于安卓中的其他目的。'
- en: Telephony and making calls using intents
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图进行电话通讯和拨打电话
- en: Not only Android phones, but any phone's primary purpose from the day of invention
    is to provide a way to communicate long-distance conversations. And like all other
    phones, Android phones also provide features for making and receiving calls, checking
    call logs such as missed calls and dialed numbers, storing contacts, editing/modifying/deleting
    contacts, and a lot more. As Android phones lie in the frame of smart phones,
    there is a lot to the call feature. Users can make video calls, record calls,
    conference calls, mobile to computer calls and vice versa, and much more. All
    these features provide a very effective product to users and let the developers
    use these features for more flexibility and productivity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅安卓手机，从发明之日起，所有电话的主要目的都是提供一种远距离交流的方式。与其他所有电话一样，安卓手机也提供了拨打电话和接收电话、检查通话记录（如未接电话和已拨号码）、存储联系人、编辑/修改/删除联系人等功能。由于安卓手机属于智能手机范畴，其通话功能更为丰富。用户可以进行视频通话、录音通话、电话会议、手机与电脑之间的通话等。所有这些功能为用户提供了非常有效的产品，并让开发者能够利用这些功能实现更大的灵活性和生产力。
- en: Android provides many APIs for telephony features for developers. These telephony
    APIs let your applications and developers access the underlying telephony hardware,
    thus making it possible to create custom dialers, integrate call handling or phone
    state monitoring, and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓为开发者提供了许多电话功能的API。这些电话API让你的应用程序和开发者能够访问底层的电话硬件，从而可以创建自定义拨号器，集成呼叫处理或电话状态监控等功能。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Developers cannot customize the in-call screen of the phone due to security
    reasons. The in-call screen is shown when users make any calls or receive any
    incoming calls.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，开发者无法自定义手机的通话界面。当用户拨打电话或接听来电时，会显示通话界面。
- en: As this book is focused on intents, we will only discuss those telephony features
    that can be utilized using intents. From many features like making calls, receiving
    calls, checking the call log, accepting/rejecting calls, and so on, there are
    very few that can be utilized directly and only using intents. Fortunately, making
    calls is one of them. Let's discuss how we can make calls using intents in the
    next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书专注于意图，我们只讨论那些可以使用意图利用的电话功能。在许多功能中，如拨打电话、接收电话、检查通话记录、接听/拒绝电话等，只有少数可以直接且仅通过意图利用。幸运的是，拨打电话就是其中之一。让我们在下一节讨论如何使用意图拨打电话。
- en: Making phone calls using intents
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图拨打电话
- en: There are two methods of making phone calls in Android. Developers can either
    use the APIs provided by Android to make phone calls, or they can only initiate
    phone calls by sending the intent with the necessary information such as the phone
    number. We will explore the method of initiating phone calls later in this section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中拨打电话有两种方法。开发者可以使用Android提供的API来拨打电话，或者仅通过发送包含必要信息（如电话号码）的意图来启动电话拨打。我们将在本节的后面探讨启动电话拨打的方法。
- en: 'In the preceding section, we saw how we can use actions in intents to tell
    the Android system about our intentions. We will be doing the same to make phone
    calls by telling Android about our intentions and the rest of the work is left
    to the system. The following code snippet allows the application to launch the
    dialer with the specified number already dialed, and the user can explicitly make
    a call by pressing the call button in it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们了解了如何使用意图中的动作来告诉Android系统我们的意图。我们将通过告诉Android我们的意图来拨打电话，其余工作留给系统完成。以下代码段允许应用程序启动已预拨指定号码的拨号器，用户可以通过按下其中的拨号按钮明确地拨打电话：
- en: '![Making phone calls using intents](img/9639_06_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图拨打电话](img/9639_06_13.jpg)'
- en: 'You can see that we have done very few changes in the code. We have declared
    a `phoneNumber` string that stores the number we want to dial. You might be wondering
    why we have concatenated a `tel:` prefix in the string. Well, that prefix is used
    in getting the **Universal Resource Identifier** (**URI**), of the number. We
    get this URI by calling the static method `Uri.parse()` of the `Uri` class. This
    method returns the URI, which we pass in turn in the constructor''s other parameter.
    We provide the `DIAL` action by passing `Intent.ACTION_DIAL` in the declaration
    of the intent, and finally, we call the `startActivity(intent)` method as always
    to execute the intent and tell the Android system to process our intentions. The
    following screenshot shows a dialer result of the previously mentioned code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在代码中做了非常少的改动。我们声明了一个`phoneNumber`字符串，用于存储我们想要拨打的号码。你可能会想知道为什么我们在字符串中拼接了一个`tel:`前缀。这个前缀用于获取号码的**通用资源标识符**（**URI**）。我们通过调用`Uri`类的静态方法`Uri.parse()`来获取这个URI。这个方法返回URI，我们反过来将其传递给构造函数的另一个参数。我们通过在意图声明中传递`Intent.ACTION_DIAL`来提供`DIAL`动作，最后，我们像往常一样调用`startActivity(intent)`方法来执行意图，并告诉Android系统处理我们的意图。以下屏幕截图显示了之前提到的代码段的拨号器结果：
- en: '![Making phone calls using intents](img/9639_06_15.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图拨打电话](img/9639_06_15.jpg)'
- en: A dialler screen with a dialled number initiated by starting the DIAL intent
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动DIAL意图来显示一个已拨号码的拨号屏幕
- en: When we run the previous code, the application will start the default dialer
    of the Android phone and will dial the number provided in code in it. It will
    not call the number; it will just dial the number because we used `Intent.ACTION_DIAL`.
    The user can explicitly press the call button of the dialer and make a call.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行之前的代码时，应用程序将启动Android手机的默认拨号器，并在其中拨打代码中提供的号码。它不会打电话；它只会拨号，因为我们使用了`Intent.ACTION_DIAL`。用户可以明确地按下拨号器的拨号按钮并进行通话。
- en: 'If the user doesn''t want to dial the number, it is also possible to directly
    call the number without going to the dialer first. Android provides the `Intent.ACTION_CALL`
    action for this purpose. The following code snippet shows how to make calls directly:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不想拨号，也可以直接调用号码而不先进入拨号界面。Android为此提供了`Intent.ACTION_CALL`动作。以下代码段展示了如何直接拨打电话：
- en: '![Making phone calls using intents](img/9639_06_16.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图拨打电话](img/9639_06_16.jpg)'
- en: 'You can see from the code that everything is the same except the action passed
    in the constructor of the intent. In the last example, we passed `Intent.ACTION_DIAL`
    and in this example we have passed `Intent.ACTION_CALL` to directly make the call.
    When we run this code snippet, the application will start making a call on an
    Android phone. The following screenshot shows the call:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从代码中看出，除了在意图构造函数中传递的动作外，其他都一样。在最后一个示例中，我们传递了`Intent.ACTION_DIAL`，而在这个例子中，我们传递了`Intent.ACTION_CALL`来直接拨打电话。当我们运行这段代码时，应用程序将在Android手机上开始拨打电话。以下屏幕截图显示了通话：
- en: '![Making phone calls using intents](img/9639_06_17.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图拨打电话](img/9639_06_17.jpg)'
- en: An in-call screen shown by starting the `CALL` intent
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动`CALL`意图来显示一个通话中的屏幕
- en: 'This action of `ACTION_CALL` to directly make a phone call requires the user
    to grant permission to the application. The following code snippet shows the permission
    to be placed in the `AndroidManifest` file to enable the app to work perfectly:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ACTION_CALL`直接拨打电话的操作需要用户向应用程序授予权限。以下代码片段展示了需要放在`AndroidManifest`文件中的权限，以使应用程序能够完美运行：
- en: '![Making phone calls using intents](img/9639_06_18.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图拨打电话](img/9639_06_18.jpg)'
- en: 'It should be noted that `ACTION_CALL` cannot make calls to emergency numbers
    using intents; however, using `ACTION_DIAL` it is possible to dial emergency numbers.
    If the user has multiple dialers installed on the phone, the `ACTION_DIAL` action
    will present the list of dialers from which the users can choose a favorite dialer.
    The following screenshot shows the scenario of multiple dialers:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`ACTION_CALL`不能使用意图拨打紧急电话；然而，使用`ACTION_DIAL`可以拨号紧急号码。如果用户在手机上安装了多个拨号器，`ACTION_DIAL`操作将显示拨号器列表，用户可以选择一个喜欢的拨号器。以下截图展示了多个拨号器的场景：
- en: '![Making phone calls using intents](img/9639_06_20.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图拨打电话](img/9639_06_20.jpg)'
- en: Multiple dialers to choose from the dialog
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从对话框中选择多个拨号器
- en: There is very little difference between the `ACTION_DIAL` and `ACTION_CALL`
    intents. The `ACTION_DIAL` intent only dials the number, and the user can explicitly
    call by pressing the call button, but `ACTION_CALL` directly makes the call without
    showing the dialer to the user.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACTION_DIAL`和`ACTION_CALL`意图之间几乎没有区别。`ACTION_DIAL`意图只是拨号，用户可以通过按下拨号按钮明确地拨打电话，但`ACTION_CALL`会直接拨打电话，而不会向用户显示拨号器。'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There can be restrictions on applications on making phone calls directly. So,
    it is a good practice to use `ACTION_DIAL` in the apps unless `ACTION_CALL` is
    required.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序直接拨打电话可能会受到限制。因此，除非需要`ACTION_CALL`，否则在应用中使用`ACTION_DIAL`是一个好习惯。
- en: This is how we use intents to easily make phone calls and use the telephony
    features of Android. In the next section, we will see how we can send SMS, MMS,
    and data messages using intents. Along with sending, we can also confirm the message
    delivery as well as receive messages. Let's now discuss these in detail in the
    next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何通过意图轻松拨打电话并使用Android的通话功能。在下一节中，我们将了解如何使用意图发送短信、彩信和数据消息。除了发送，我们还可以确认消息送达以及接收消息。接下来的一节，我们将详细讨论这些内容。
- en: SMS/MMS using intents
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图发送短信/彩信
- en: In addition to the features of making calls, mobile phones support messaging
    services such as Short Messaging Services (SMS), Multimedia Messaging Services
    (MMS), and lately the data messages. The SMS/MMS features are most widely used
    in phones, and many people prefer it over making calls. Android provides APIs
    and framework that let developers send and receive messages from within their
    applications. Developers can even replace the native SMS application to send and
    receive text messages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拨打电话的功能外，手机还支持短信服务，如短消息服务（SMS）、多媒体消息服务（MMS）以及最近的数据消息。SMS/MMS功能在手机中应用最广泛，许多人更喜欢使用它而不是拨打电话。Android提供了API和框架，让开发人员能够从他们的应用程序中发送和接收消息。开发人员甚至可以替换原生的短信应用程序来发送和接收文本消息。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, there is no API or library for sending MMS
    messages from within your applications, but you can send them using the `ACTION_SEND`
    or `ACTION_SENDTO` intents.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，还没有用于从应用程序内部发送彩信的API或库，但您可以使用`ACTION_SEND`或`ACTION_SENDTO`意图来发送。
- en: This section will walk you through the various actions such as sending SMS,
    sending MMS, sending data messages, confirming message delivery, and receiving
    SMS using intents. We will then brief you about how all these actions are performed
    without using intents and how APIs of Android can be beneficial to us. Let's look
    at our first task of sending SMS messages using intents in the next subsection.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将引导您了解各种操作，如使用意图发送短信、发送彩信、发送数据消息、确认消息送达以及接收短信。然后，我们将简要介绍所有这些操作在不使用意图的情况下是如何执行的，以及Android的API对我们有何帮助。接下来的一小节，我们将看看使用意图发送短信的任务。
- en: Sending SMS using intents
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图发送短信
- en: The best thing about using intents is that it passes the responsibility of our
    requirements to the Android system rather than we creating the full functionality
    from the core. If we use intents in our current case, which is to send an SMS
    to someone, we just have to provide the number to send the message to and the
    message to be sent. The rest is done by Android itself.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用意图的最大优点是它将我们的需求责任传递给了 Android 系统，而不是我们从核心创建完整的功能。如果我们在我们当前的情况下使用意图，即给某人发送短信，我们只需提供要发送消息的号码和要发送的消息。其余的工作由
    Android 自身完成。
- en: 'We have already had plenty of discussions over the same topic of sending something
    or sharing something using intents, and fortunately, there is nothing different
    that we have to absorb here. It''s the same old method of creating an `ACTION_SEND`
    intent and executing it by calling the `startActivity(intent)` method. The following
    code snippet shows the `ACTION_SEND` intent example that we used previously:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用意图发送或分享内容的话题，我们已经进行了很多讨论，幸运的是，这里没有什么是我们需要吸收的新知识。这是我们之前使用的创建`ACTION_SEND`意图并调用`startActivity(intent)`方法执行的老方法。以下代码片段展示了我们之前使用的`ACTION_SEND`意图示例：
- en: '![Sending SMS using intents](img/9639_06_19.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图发送短信](img/9639_06_19.jpg)'
- en: 'Now, if we use this code, it is not useful to us because it doesn''t perform
    our action of sending an SMS. Neither does it show the SMS-supporting applications
    in the chooser dialog, nor does it send any SMS with the data passed in the `EXTRA_TEXT`
    extra. To make use of `ACTION_SEND` for the purpose of sending an SMS, we have
    to take care of some extra things. There are two ways of sending an SMS using
    intents: by the `ACTION_SEND` intent and by the `ACTION_SENDTO` intent. Let''s
    see how we can send an SMS using the `ACTION_SEND` intent.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用这段代码，它对我们来说并不实用，因为它没有执行我们发送短信的动作。它既没有在选择器对话框中显示支持短信的应用，也没有使用`EXTRA_TEXT`额外参数传递的数据发送任何短信。为了使用`ACTION_SEND`发送短信，我们需要注意一些额外的事项。使用意图发送短信有两种方法：通过`ACTION_SEND`意图和通过`ACTION_SENDTO`意图。让我们看看如何使用`ACTION_SEND`意图发送短信。
- en: 'We have to create intent with the `ACTION_SEND` action and then put an extra
    `"sms_body"` with the message embedded in it. Android will ask the user for the
    phone number of the recipient itself. But it still won''t show any SMS support
    applications in the chooser-list dialog because we are still missing the type
    of intent. As SMSes are short text messages, we should set the intent type to
    `"text/html"`, but most SMS applications look for `"image/jpg"` or `"image/png"`
    as the intent type due to no native support for MMS messages. So, after setting
    the intent type to `"image/png"`, we will have the following code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`ACTION_SEND`动作创建意图，并在其中嵌入消息的额外参数`"sms_body"`。Android 会自行向用户询问接收者的电话号码。但由于我们还未指定意图的类型，所以在选择器列表对话框中仍然不会显示任何短信支持应用。由于短信是短文本消息，我们应该将意图类型设置为`"text/html"`，但由于大多数短信应用对彩信（MMS）没有原生支持，它们会寻找`"image/jpg"`或`"image/png"`作为意图类型。因此，将意图类型设置为`"image/png"`后，我们将得到以下代码片段：
- en: '![Sending SMS using intents](img/9639_06_21.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图发送短信](img/9639_06_21.jpg)'
- en: 'When we execute this code, we will see the chooser dialog of various apps including
    SMS support applications, e-mail applications, and so on. When we select any SMS
    application, we will see something similar to following image:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这段代码时，我们会看到包括短信支持应用、电子邮件应用等在内的各种应用的选择器对话框。当我们选择任何短信应用时，我们会看到类似于以下图片的内容：
- en: '![Sending SMS using intents](img/9639_06_22.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图发送短信](img/9639_06_22.jpg)'
- en: Default SMS application shown after sending the SMS intent
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 发送短信意图后显示默认短信应用
- en: You may have already noticed that the text part of the SMS application is already
    filled in with the content we added in the `"sms_body"` extra, and the user is
    typing the number of recipients of the message.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，短信应用中的文本部分已经用我们在`"sms_body"`额外参数中添加的内容填充，用户正在输入消息的接收者数量。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous image shows a default SMS application of the QMobile Noir A10 smartphone.
    Your device will show the SMS application that you have set as default on your
    phone, and it won't be the same as this application for sure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片展示了 QMobile Noir A10 智能手机的默认短信应用。您的设备将显示您设置为手机默认的短信应用，当然，它不会和这个应用相同。
- en: 'This is how we can send an SMS using intents. Now, let''s take our other case
    in which we want to set the number of recipients using coding. For that purpose,
    we have to use the `ACTION_SENDTO` intent instead of the `ACTION_SEND` intent.
    The following code snippet shows the use of the `ACTION_SENDTO` intent:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以使用意图发送短信了。现在，让我们考虑另一个情况，我们希望通过编程设置收件人的数量。为此，我们必须使用`ACTION_SENDTO`意图而不是`ACTION_SEND`意图。以下代码段展示了`ACTION_SENDTO`意图的使用：
- en: '![Sending SMS using intents](img/9639_06_23.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图发送短信](img/9639_06_23.jpg)'
- en: In the preceding code, you can see that we have made a few changes in the code
    that we discussed previously before sending the SMS messages. We have set the
    action to `ACTION_SENDTO` instead of `ACTION_SEND`. Also, we have passed another
    argument of the phone number URI in the constructor of the intent. We have created
    a string for the phone number and concatenated the `"sms:"` tag before the number.
    This tag lets the `Uri` class understand that the string is representing the phone
    number to send the message to and parse it accordingly. You may remember from
    the previous section, we used the `"tel"` tag for making calls to any number using
    intents. When you execute the code, it will ask the application to choose SMS.
    On selecting any SMS supported application, it will send the SMS directly to the
    phone number provided instead of asking the phone number as in the previous example.
    You may have noticed that we haven't set the type of intent in this code snippet.
    It is because when we are using the `ACTION_SENDTO` intent, we don't have to explicitly
    set the type of intent. Android will understand what the developer is trying to
    do from the tags such as `"sms"` or `"tel"` and from actions such as `ACTION_SENDTO`
    or `ACTION_CALL`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到我们在之前发送SMS消息的代码中做了一些更改。我们将动作设置为`ACTION_SENDTO`，而不是`ACTION_SEND`。同时，在意图的构造函数中传递了另一个电话号码URI的参数。我们为电话号码创建了一个字符串，并在号码前拼接了`"sms:"`标签。这个标签让`Uri`类明白该字符串代表要发送消息的电话号码，并相应地解析它。你可能还记得，在上一节中，我们使用`"tel"`标签通过意图拨打任何号码。当你执行代码时，它会要求应用程序选择短信应用。选择任何支持SMS的应用程序后，它会直接将短信发送到提供的电话号码，而不是像上一个示例中那样询问电话号码。你可能已经注意到，在这段代码中我们没有设置意图的类型。这是因为当我们使用`ACTION_SENDTO`意图时，我们不需要明确设置意图的类型。Android会从如`"sms"`或`"tel"`的标签以及如`ACTION_SENDTO`或`ACTION_CALL`的动作中理解开发者试图做什么。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: If you want to use `ACTION_SEND` and set the recipient number explicitly using
    code, Android provides the `"address"` extra to put the string of the number in
    it without having to use any tags such as `"tel"` or `"sms"`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`ACTION_SEND`并明确使用代码设置收件人号码，Android提供了`"address"`额外项，无需使用任何如`"tel"`或`"sms"`的标签，就可以在其中放入号码字符串。
- en: Until now, we have talked about using `ACTION_SEND` and `ACTION_SENDTO` to send
    SMS text messages. In the next section, we will see how we can send multimedia
    messages with pictures embedded in them using intents.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了使用`ACTION_SEND`和`ACTION_SENDTO`发送SMS文本消息。在下一节中，我们将看到如何使用意图发送包含嵌入图片的多媒体消息。
- en: Sending MMS using intents
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图发送MMS
- en: 'The only thing that differs in a text message and multimedia message is the
    rich media embedded in it. MMS messages contain rich media content such as photos,
    videos, and cards, and some text as message for the content. Currently, there
    is no library provided by Android that lets developers send MMS natively, unlike
    SMS. But fortunately, intents make a clear way out for us in order to send an
    MMS. As the real difference defines, we have to add some media in the text message
    intent with its type set to multimedia, such as `"image/png"`, and we have then
    finished sending MMS messages. The following code snippet shows how to send any
    MMS message using intents used for SMS messages:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 文本消息与多媒体消息唯一的区别在于嵌入的富媒体内容。MMS消息包含照片、视频和贺卡等富媒体内容，以及一些作为内容消息的文本。目前，Android没有提供让开发者原生发送MMS的库，与SMS不同。但幸运的是，意图为我们提供了一种明确的方式来发送MMS。正如真正的区别所定义的，我们需要在文本消息意图中添加一些媒体，并将其类型设置为多媒体，如`"image/png"`，然后我们就完成了MMS消息的发送。以下代码段展示了如何使用用于SMS消息的意图发送任何MMS消息：
- en: '![Sending MMS using intents](img/9639_06_24.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图发送MMS](img/9639_06_24.jpg)'
- en: You can see that there are two parts of the code. In the first part, we are
    getting the URI of our required image stored in external storage in the `images`
    folder. In the second part, we are creating intent with `ACTION_SEND`. Then, we
    add our text by using an`"sms_body"` extra and set the type to `"image/png"` to
    make it meaningful for a multimedia message. After that, we attach our media using
    the `Intent.EXTRA_STREAM` extra and pass our image URI as value in it. Finally,
    we execute the intent by calling the `startActivity(intent)` method. The only
    difference was to attach the media URI using the `EXTRA_STREAM` extra, and the
    rest was the same as in the SMS messages. You should also note that we can use
    `ACTION_SENDTO` to specify the recipient number, or we can also add the `"address"`
    extra with the value of the phone number.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到代码有两部分。在第一部分，我们获取了存储在外部存储的`images`文件夹中所需图像的URI。在第二部分，我们使用`ACTION_SEND`创建意图。然后，我们使用`"sms_body"`额外项添加我们的文本，并将类型设置为`"image/png"`，使其对多媒体消息有意义。之后，我们使用`Intent.EXTRA_STREAM`额外项附加我们的媒体，并在其中传递我们的图像URI作为值。最后，我们通过调用`startActivity(intent)`方法执行意图。唯一的区别是使用`EXTRA_STREAM`额外项附加媒体URI，其余与短信中的操作相同。你也应该注意，我们可以使用`ACTION_SENDTO`指定收件人号码，或者我们也可以使用电话号码作为值的`"address"`额外项。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have set the type of `"image/png"` in the previous example. This can only
    send PNG images. For other image formats, we can specify `"images/*"`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们已经设置了`"image/png"`的类型。这只能发送PNG图像。对于其他图像格式，我们可以指定`"images/*"`。
- en: Until now, we have only discussed sending SMS and MMS messages. But are we sure
    that those messages have been delivered successfully? Well, the next section is
    about confirming message delivery and understanding the role of intents in it.
    Let's see how we can confirm the message delivery using intents in the following
    section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了发送短信和彩信。但我们确定这些消息已经成功送达了吗？好吧，下一节是关于确认消息送达和了解意图在其中扮演的角色。让我们在下一节中看看如何使用意图来确认消息的送达。
- en: Confirming message delivery using intents
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图确认消息送达
- en: 'When we use intents to send messages, whether they are SMS or MMS, we just
    can''t track those messages for actions, such as, confirming delivery. The reason
    behind this is the implicit use of intents and relying on the default action of
    the Android system. If we use intents to send messages, it means that we are passing
    our responsibility of sending messages to the Android system. Now, if we want
    to confirm the delivery status of the message, it means that we are asking Android
    about our message. Unfortunately, we lack two things to make it possible: one
    is to tell the Android system about our confirmation of some message and the other
    is that the Android system may not remember what message we are talking about.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用意图发送短信时，无论是短信还是彩信，我们都无法追踪这些消息以执行操作，例如确认送达。背后的原因是隐式地使用意图，并依赖于安卓系统的默认操作。如果我们使用意图发送消息，这意味着我们将发送消息的责任交给了安卓系统。现在，如果我们想要确认消息的送达状态，这意味着我们正在向安卓系统询问我们的消息。不幸的是，要实现这一点，我们缺少两样东西：一是告诉安卓系统我们确认了某条消息，二是安卓系统可能不记得我们谈论的是哪条消息。
- en: In order to make it possible to confirm the delivery, we have to use the native
    API for sending messages manually. It is the job of this API to keep track of
    both the delivery status and the message we are talking about. Also, using this
    API, we can easily send our query, asking the Android system about the delivery
    confirmation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够确认送达，我们必须手动使用原生API发送消息。这个API的任务是跟踪我们正在谈论的消息的送达状态和消息本身。此外，使用这个API，我们可以轻松发送查询，询问安卓系统关于送达确认的信息。
- en: Now, if we are using native APIs for sending messages, we have to think about
    MMS messages. As mentioned earlier, there is still no native support for MMS messages;
    so, we won't be able to track and confirm the delivery of MMS messages, but yes,
    we can confirm the delivery status of SMS messages. In this section, we will talk
    about how we can check the SMS delivery status using the native SMS API and how
    intents are used to achieve our goal.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用原生API发送消息，我们必须考虑彩信。如前所述，对彩信的原生支持仍然不存在；因此，我们将无法追踪和确认彩信的送达，但我们可以确认短信的送达状态。在本节中，我们将讨论如何使用原生短信API检查短信送达状态，以及如何使用意图来实现我们的目标。
- en: 'Intents are an asynchronous way of communication in Android, and they are used
    everywhere. The only change is that they are used to achieve our goals and finish
    the requirements. In a short explanation about confirming the message delivery
    status, we will use the native SMS API called `SmsManager` to send the text message
    using the `SmsManager.sendTextMessage()` method. But to keep track of the message,
    we will use two intents: one for the sent action and one for the delivery action.
    Along with these two intents, we will also create two pending intents: one for
    the sent action and one for the delivery action. Finally, to put all four intents
    in action, we will create two broadcast receivers: one to check the sent action
    and the other to check the delivery action. It may seem quite complex here, but
    it is as easy as a charm. Let''s have a look at the code snippet that declares
    our four intents: two intents and two pending intents:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 意图在Android中是一种异步的通信方式，并且被广泛使用。唯一的变化是，它们被用来实现我们的目标和完成需求。关于确认消息送达状态的简短解释，我们将使用名为`SmsManager`的原生短信API，通过`SmsManager.sendTextMessage()`方法发送文本消息。为了跟踪消息，我们将使用两个意图：一个用于发送动作，另一个用于送达动作。除了这两个意图，我们还将创建两个挂起的意图：一个用于发送动作，另一个用于送达动作。最后，为了执行所有四个意图，我们将创建两个广播接收器：一个检查发送动作，另一个检查送达动作。这里看起来可能相当复杂，但实际上非常简单。让我们看看声明我们四个意图的代码片段：两个意图和两个挂起意图：
- en: '![Confirming message delivery using intents](img/9639_06_25.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图确认消息送达](img/9639_06_25.jpg)'
- en: You can see that we have declared our intents in the usual way in the code.
    The only difference here is that we have used our own custom actions represented
    in strings such as `"sent_sms_action"` or `"delivered_sms_action"`. Then, we have
    created two pending intents using the `getBroadcast()` factory method of the `PendingIntent`
    class. The `getBroadcast()` method will retrieve `PendingIntent` that will perform
    any broadcast, such as calling the `Context.sendBroadcast()` method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在代码中以常规方式声明了我们的意图。这里的唯一区别是，我们使用了代表字符串的自定义动作，如`"sent_sms_action"`或`"delivered_sms_action"`。然后，我们使用`PendingIntent`类的`getBroadcast()`工厂方法创建了两个挂起意图。`getBroadcast()`方法将检索到将执行任何广播的`PendingIntent`，例如调用`Context.sendBroadcast()`方法。
- en: 'So, after creating all four intents, we will now have to create and register
    the broadcast receivers that will put the pending intents in action. The following
    code snippet shows both receivers being implemented:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建完所有四个意图之后，我们现在需要创建并注册广播接收器，这些接收器将执行挂起的意图。以下代码片段展示了两个接收器的实现：
- en: '![Confirming message delivery using intents](img/9639_06_26.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图确认消息送达](img/9639_06_26.jpg)'
- en: 'As seen in the previous code, we have registered two broadcast receivers using
    the `Activity.registerReceiver()` method and passed anonymous objects. The overridden
    method `onReceive()` serves our purpose. One `onReceive()` method is called when
    any message is sent, and the other `onReceive()` method is called when any message
    is delivered. We have put comments to show you where you can use your custom functionality
    in the code. You might be wondering how Android will know that these are the broadcast
    receivers for sent and delivery status. Android will know about it by checking
    the intent filters. You can see that we have passed our custom actions passed
    in intents in the constructors of intent filters, and these filters will filter
    the broadcasts, and the receiver will only receive those broadcasts for which
    it was registered. We have done our core work for confirming the message delivery
    until now. All that''s left now is to put it in action, and here, the `SmsManager`
    API comes handy. We will create an instance of `SmsManager` and call its `sendTextMessage()`
    method to send the message and put all the intents in it, and then we are done.
    The following code snippet shows the `SmsManager` usage code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一段代码所示，我们使用`Activity.registerReceiver()`方法注册了两个广播接收器，并传递了匿名对象。重写的方法`onReceive()`实现了我们的目的。当一个消息被发送时，会调用一个`onReceive()`方法；当一个消息被送达时，会调用另一个`onReceive()`方法。我们在代码中加入了注释，以展示你可以在哪里使用自定义功能。你可能想知道Android如何知道这些是用于发送和送达状态的广播接收器。通过检查意图过滤器，Android会知道这一点。你可以看到，我们在意图过滤器的构造函数中传递了我们在意图中使用的自定义动作，这些过滤器将过滤广播，接收器只接收它注册的广播。到目前为止，我们已经为确认消息送达做了核心工作。现在剩下的就是去执行它，这时`SmsManager`
    API就派上用场了。我们将创建一个`SmsManager`的实例，并调用其`sendTextMessage()`方法来发送消息，并放入所有意图，然后我们就完成了。以下代码片段展示了`SmsManager`的使用代码：
- en: '![Confirming message delivery using intents](img/9639_06_27.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图确认消息送达](img/9639_06_27.jpg)'
- en: 'Remember, the `SmsManager` API uses the `android.permission.SEND_SMS` permission;
    so, don''t forget to add it in your manifest file, as shown in the following code
    snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`SmsManager` API 使用了`android.permission.SEND_SMS`权限；因此，不要忘记在您的清单文件中添加它，如下面的代码片段所示：
- en: '![Confirming message delivery using intents](img/9639_06_28.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图确认消息送达](img/9639_06_28.jpg)'
- en: So, this is how we can confirm the message delivery. We can only confirm the
    delivery status of text messages, and we have to ask the user to grant a `SEND_SMS`
    permission for the purpose. But, if we are using intents, we can only send messages
    and we won't be requiring any permission from the users.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就能确认消息的送达。我们只能确认文本消息的送达状态，并且需要用户授予`SEND_SMS`权限。但是，如果我们使用意图，我们只能发送消息，并且不需要用户任何权限。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android emulator supports sending and receiving SMS messages. This can be accomplished
    by creating multiple instances of emulators and sending text messages to port
    the number of emulators.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓模拟器支持发送和接收短信。这可以通过创建多个模拟器实例并向模拟器的端口号发送短信来实现。
- en: Summarizing the role of intents in confirming the message delivery, intents
    are not performing the core action of confirming message delivery here. They are
    just providing a way of communication by carrying the necessary information such
    as which message's delivery is to be checked and so on. Then, these intents are
    used by broadcast receivers that constantly check for the delivery and sent status.
    Once it is done, they pass the status in our intents and then those intents provide
    us with an update of whether the message has been sent or delivered or not.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 总结意图在确认消息送达中的作用，意图在这里并不是执行确认消息送达的核心动作。它们只是提供了一种通信方式，携带必要的信息，比如哪条消息的送达需要被检查等。然后，这些意图被广播接收器使用，它们不断检查消息的送达和发送状态。一旦完成，它们将状态传递到我们的意图中，然后这些意图为我们提供消息是否已发送或送达的更新。
- en: In the next section, we will be doing almost the same kind of stuff and coding,
    but this time, we will do it to receive messages. After using all these code snippets,
    we can develop our SMS application that can send and receive messages. Let's see
    how we can receive messages and the role of intents behind it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将做几乎相同的事情和编码，但这次，我们将这样做是为了接收消息。使用所有这些代码片段后，我们可以开发出能发送和接收消息的短信应用。让我们看看如何接收消息以及意图在背后的作用。
- en: Receiving SMS messages using intents
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用意图接收短信
- en: Until now, we have talked about sending SMS/MMS messages and the importance
    of intents in these applications. In this section, we will talk about how we can
    listen for incoming messages so that we can use them in our applications. Using
    this feature, we can develop messaging applications. Intents can send messages
    using the `ACTION_SEND` or `ACTION_SENDTO` intents directly, but these don't play
    a direct role in listening for incoming messages and receiving messages. Intents
    are used in the same way as `Broadcast Receiver`, and are used to get the data
    such as sender number, message, message time, and so on. Before we discuss how
    to listen for incoming messages, we have to learn about some classes that are
    used in the following application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们讨论了发送短信/MMS消息以及在应用程序中意图的重要性。在本节中，我们将讨论如何监听传入的消息，以便我们能在应用程序中使用它们。利用这个功能，我们可以开发消息传递应用。意图可以使用`ACTION_SEND`或`ACTION_SENDTO`意图直接发送消息，但这些意图并不直接参与监听传入消息和接收消息。意图与`Broadcast
    Receiver`的使用方式相同，用于获取发送者号码、消息内容、消息时间等信息。在讨论如何监听传入消息之前，我们必须了解一些在以下应用程序中使用的类。
- en: The SmsManager class
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmsManager类
- en: We have already used the `SmsManager` class in the previous subsections for
    confirming message delivery. This class is used to manage SMS operations such
    as sending data, SMS, and PDU messages. We can't instantiate this object using
    a constructor; we can get its instance by calling the static method of `SmsManager.getDefault()`.
    We can use this class to send messages.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们已经使用了`SmsManager`类来确认消息的送达。这个类用于管理如发送数据、短信和PDU消息等SMS操作。我们不能通过构造函数实例化这个对象；我们可以通过调用`SmsManager.getDefault()`静态方法来获取它的实例。我们可以使用这个类来发送消息。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two different classes with the name `SmsManager`: `android.telephony.SmsManager`
    and `android.telephony.gsm.SmsManager`. The later class in the GSM package is
    deprecated in API Level 4 and later versions.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个不同类名为`SmsManager`：`android.telephony.SmsManager`和`android.telephony.gsm.SmsManager`。在GSM包中的后者在API级别4及以后版本中已被弃用。
- en: The SmsMessage object
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmsMessage对象
- en: This class represents a simple SMS message object. On receiving the incoming
    messages, we will get an array of `SmsMessage` objects. This class is used to
    get information such as the message body, message time, and sender number.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表了一个简单的短信消息对象。在接收到来电消息时，我们将得到一个`SmsMessage`对象的数组。这个类用于获取诸如消息正文、消息时间、发送者号码等信息。
- en: Protocol Data Unit (PDU)
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议数据单元（PDU）
- en: A PDU is the industry format for an SMS message. Developers shouldn't worry
    about reading a PDU in detail or understanding the format, because the `SmsManager`
    class of Android reads and writes PDUs and provides methods for the developer
    to use PDUs.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: PDU是短信消息的行业格式。开发者无需担心详细阅读PDU或理解其格式，因为Android的`SmsManager`类会读取和写入PDU，并为开发者提供使用PDU的方法。
- en: 'These classes and concepts will be used in receiving the incoming messages''
    app. Now, let''s discuss how messages are received in Android. When any new SMS
    message is received by any device, a new broadcast intent is fired. The action
    of this intent is `android.provider.telephony.SMS_RECEIVED`. We have to create
    a custom broadcast receiver that will look for this broadcast intent. Whenever
    we get any message, the `onReceive()` method of the broadcast receiver will be
    called. The following code snippet shows the implementation of our custom broadcast
    receiver for incoming messages:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类和概念将在接收来电消息的应用中使用。现在，让我们讨论一下在Android中是如何接收消息的。当任何设备接收到新的短信消息时，会触发一个新的广播意图。这个意图的动作是`android.provider.telephony.SMS_RECEIVED`。我们必须创建一个自定义的广播接收器，它将寻找这个广播意图。每当我们收到任何消息时，广播接收器的`onReceive()`方法将被调用。以下代码段展示了我们为来电消息实现的自定义广播接收器：
- en: '[PRE0]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As always, we have extended our class from `BroadcastReceiver` and overridden
    the `onReceive()` method. This method is called when any incoming message is received
    by the device. We first check whether this intent contains any received messages
    or not. If the intent action is the same as our `SMS_RECEIVED` string literal,
    this means that we have received our message.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们的类从`BroadcastReceiver`扩展而来，并覆盖了`onReceive()`方法。当设备接收到任何来电消息时，会调用这个方法。我们首先检查这个意图是否包含任何收到的消息。如果意图动作与我们的`SMS_RECEIVED`字符串字面量相同，这意味着我们已经收到了消息。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SMS received action `android.provider.Telephony.SMS_RECEIVED` is unsupported
    in Android and is subject to change in any future platform releases. The developer
    should be cautious when using these unsupported hidden methods and attributes
    of Android.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，收到的短信动作`android.provider.Telephony.SMS_RECEIVED`是不被支持的，并且在未来的平台版本中可能会发生变化。开发者在使用这些Android中不被支持的隐藏方法和属性时应谨慎。
- en: 'Once the action is verified after checking and comparing, we have to get the
    message data from the intent and perform our custom actions of the application.
    We first get the extras bundle from the intent by calling the `getExtras()` method
    and then we have passed that bundle in our method called `getMessageData()`. This
    is our custom method, and in this method, we will see how we can get the message
    data from the bundle. The following code implementation shows the method definition:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查并确认动作后，我们必须从意图中获取消息数据并执行应用程序的自定义操作。我们首先通过调用`getExtras()`方法从意图中获取extras bundle，然后我们将这个bundle传递给我们的`getMessageData()`方法。这是我们自定义的方法，在这个方法中，我们将了解如何从bundle中获取消息数据。以下代码实现展示了方法的定义：
- en: '![Protocol Data Unit (PDU)](img/9639_06_30.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![协议数据单元（PDU）](img/9639_06_30.jpg)'
- en: We first checked that our bundle is not a null object. Then we extracted the
    PDUs from the bundle by calling the `get()` method and passing the `"pdus"` key.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查我们的bundle不是一个null对象。然后我们通过调用`get()`方法并传递`"pdus"`键从bundle中提取PDUs。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't know which key to pass in the `get()` method, you can call the
    `Set<String> Bundle.keySet()` method to get all the keys used in the bundle.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不清楚在`get()`方法中应该传递哪个键，你可以调用`Set<String> Bundle.keySet()`方法来获取bundle中使用的所有键。
- en: Recalling PDUs, PDU is the industry format for an SMS message. Once we have
    all the PDU objects in an array, we create an SMS message from those PDUs using
    the `SmsMessage.createFromPdu()` method. After creating all the messages, we are
    traversing through the array and getting the message data such as the message
    body text, message sender number, and message time from it using the `SmsMessage.getMessageBody()`,
    `SmsMessage.getOriginatingAddress()`, and `SmsMessage.getTimestampMillis()` methods.
    Now, we can use these data strings in our applications. It must be noted that
    any large message is broken into many small messages, which is why we are getting
    an array of objects.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾PDU，PDU是短信的行业格式。一旦我们有了数组中的所有PDU对象，我们就可以使用`SmsMessage.createFromPdu()`方法从这些PDU创建短信。创建所有消息后，我们遍历数组，并使用`SmsMessage.getMessageBody()`、`SmsMessage.getOriginatingAddress()`和`SmsMessage.getTimestampMillis()`方法从其中获取消息数据，如消息正文文本、消息发送者号码和消息时间。现在，我们可以将这些数据字符串用于我们的应用程序。需要注意的是，任何长消息都会被分解成许多小消息，这就是为什么我们得到对象数组的原因。
- en: 'This broadcast won''t work until we register it in our application. To register
    it in our application, we have to write the following code in our main activity:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们在应用程序中注册此广播，否则它不会工作。要在我们的应用程序中注册它，我们必须在主活动中编写以下代码：
- en: '![Protocol Data Unit (PDU)](img/9639_06_31.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![协议数据单元（PDU）](img/9639_06_31.jpg)'
- en: 'There is nothing new to discuss here. We are creating an intent filter with
    the `SMS_RECEIVED` action and an instance of our broadcast receiver. Then, we
    are passing both in the `registerReceiver()` method of our activity. The message
    receiver requires the `android.permission.RECEIVE_SMS` permission; so, don''t
    forget to add this line in your manifest file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的讨论内容。我们正在创建一个带有`SMS_RECEIVED`动作和广播接收器实例的意图过滤器。然后，我们将它们都传递给活动的`registerReceiver()`方法。消息接收器需要`android.permission.RECEIVE_SMS`权限；因此，不要忘记在您的清单文件中添加这一行：
- en: '![Protocol Data Unit (PDU)](img/9639_06_32.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![协议数据单元（PDU）](img/9639_06_32.jpg)'
- en: This is how we can receive the incoming messages in our application and use
    them in many different ways. You might be wondering about the role of intents
    in this application. As mentioned earlier, intents are not used in this application
    directly. When any message is received by the device, a broadcast intent is fired.
    We are using that intent to extract data and messages from it, and those messages
    are used in our application. Intents play the role of providing the data about
    messages, after receiving them, in Android devices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以在应用程序中接收来电消息，并以多种不同的方式使用它们。您可能想知道意图在这个应用程序中的作用。如前所述，这个应用程序中没有直接使用意图。当设备收到任何消息时，会触发一个广播意图。我们使用该意图从中提取数据和消息，这些消息在我们的应用程序中使用。在Android设备接收到消息后，意图的作用就是提供关于消息的数据。
- en: 'We can use Android debug tools of the **Dalvik Debug Monitor Server** (**DDMS**)
    panel to simulate incoming messages on our Android emulators. The following screenshot
    shows the **Emulator Control** panel in the DDMS view for simulating messages:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Android调试工具中的**Dalvik调试监控服务器**（**DDMS**）面板，在Android模拟器上模拟来电消息。以下是DDMS视图中用于模拟消息的**模拟器控制**面板的屏幕截图：
- en: '![Protocol Data Unit (PDU)](img/9639_06_33.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![协议数据单元（PDU）](img/9639_06_33.jpg)'
- en: Emulator Control panel in the DDMS view for simulating messages
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在DDMS视图中用于模拟消息的模拟器控制面板
- en: In this section, we learned about sending SMS, MMS, confirming message delivery,
    and receiving incoming messages. We also discussed the importance and use of intents
    in all these applications. In the next section, we will learn about notifications
    and how intents are used in making interactive notifications.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了发送短信、彩信、确认消息送达以及接收来电消息。我们还讨论了在这些应用中使用意图的重要性和方法。在下一节中，我们将学习关于通知的知识，以及如何在制作交互式通知时使用意图。
- en: Notification using intents
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图的通知
- en: 'From traditional phones to smart phones, every mobile phone uses some method
    to notify and alert the users about some event such as receiving messages or calls.
    Like these phones, an Android phone uses a notification system to alert the users.
    A notification is a message displayed out of the application''s normal UI. When
    any new notification is triggered, it is shown in the notification area. The users
    can see notifications from the notification drawer and notification area at any
    time by pulling the drawer downward using the down gesture. The following screenshot
    shows two different examples of notifications in Android:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统手机到智能手机，每款手机都使用某种方式来通知和提醒用户某些事件，如接收短信或电话。与这些手机一样，Android手机使用通知系统来提醒用户。通知是显示在应用程序正常UI之外的消息。当触发任何新的通知时，它会在通知区域显示。用户可以通过向下拉动手势来随时从通知抽屉和通知区域查看通知。以下屏幕截图展示了Android中两种不同通知的示例：
- en: '![Notification using intents](img/9639_06_34.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图的通知](img/9639_06_34.jpg)'
- en: Notifications in Android phones
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Android手机中的通知
- en: Notifications are like channels that alert the users about important events
    as they occur when the user is busy in some other mobile activity such as playing
    a game.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通知就像是在用户忙于其他移动活动（如玩游戏）时，发生重要事件时提醒用户的渠道。
- en: For any developer, a notification is a user interface (UI) element that the
    developer displays outside of the app's normal UI to indicate and notify the user
    that an event has occurred. Then, users can choose to view the notification while
    using other apps and respond to them when they wish. Using a notification is the
    preferred way for invisible application components, such as broadcast receivers
    and services, to alert the user about the occurrence of any event.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何开发者来说，通知是开发者显示在应用正常用户界面（UI）之外的一个用户界面元素，用以指示并告知用户某个事件已经发生。然后，用户可以在使用其他应用时选择查看通知，并在他们希望的时候进行响应。使用通知是让不可见的应用组件（如广播接收器和服务）告知用户任何事件发生的首选方式。
- en: In this section, we will discuss notifications, their layouts, displaying additional
    information in notification layouts, and launching intents. We will learn the
    role of intents and create an example application with a custom notification layout
    and how intents are important in these types of applications. Before we start
    developing our example application, let's discuss some basic concepts used in
    notifications.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论通知、它们的布局、在通知布局中显示附加信息以及启动意图。我们将了解意图的作用，并创建一个具有自定义通知布局的示例应用程序，以及意图在这类应用程序中的重要性。在我们开始开发示例应用程序之前，让我们讨论通知中使用的某些基本概念。
- en: Notification forms
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知形式
- en: Notifications can take different forms like any persistent icon that goes into
    the status bar and can be accessed through the launcher. When this notification
    is selected by the user, any specified intent is triggered when some activity
    or service occurs. Notifications can also be used to turn on the flashing LEDs
    of the device. Also, devices can vibrate or play ringtones on receiving notifications.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通知可以采取不同的形式，例如状态栏中的任何持久图标，可以通过启动器访问。当用户选择此通知时，当发生某些活动或服务时，会触发任何指定的意图。通知还可以用来打开设备的闪烁LED灯。此外，设备在接收到通知时也可以振动或播放铃声。
- en: The NotificationManager class
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NotificationManager类
- en: 'The `NotificationManager` class represents a system service that is used to
    handle the notifications'' system in Android. We can''t instantiate this class,
    but we can get its instance object by calling the `getSystemService()` method
    and passing `Context.NOTIFICATION_SERVICE`. The following code snippet shows how
    to get an instance of the `NotificationManager` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationManager`类代表了一个用于处理Android中通知系统的系统服务。我们不能实例化这个类，但可以通过调用`getSystemService()`方法并传递`Context.NOTIFICATION_SERVICE`来获取它的实例对象。以下代码段展示了如何获取`NotificationManager`类的实例：'
- en: '![The NotificationManager class](img/9639_06_35.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![NotificationManager类](img/9639_06_35.jpg)'
- en: The Notification class
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Notification类
- en: 'The `Notification` class represents any notification in Android. It provides
    APIs that allow developers to set the icon, title, time of notifications, and
    so on. The following code snippet shows us how to create a notification in Android:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notification`类代表了Android中的任何通知。它提供了API，允许开发者设置通知的图标、标题、时间等。以下代码段展示了如何在Android中创建一个通知：'
- en: '![The Notification class](img/9639_06_36.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Notification类](img/9639_06_36.jpg)'
- en: The Notification layout
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知布局
- en: 'Each notification has an icon and ticker text, which is sometimes called status
    text. An icon is displayed when a notification has been launched and the notification
    drawer is closed. The ticker text scrolls along the status bar when a notification
    is fired and then it is set to the notification message text when the notification
    drawer is opened. The following screenshot gives an overview of the different
    aspects of a notification area:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通知都有一个图标和滚动文本，有时称为状态文本。当启动通知且通知抽屉关闭时，会显示图标。当触发通知时，滚动文本会在状态栏中滚动，当打开通知抽屉时，它会被设置为通知信息文本。下面的截图概述了通知区域的不同方面：
- en: '![The Notification layout](img/9639_06_37.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![通知布局](img/9639_06_37.jpg)'
- en: Notification and notification area
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通知和通知区域
- en: You can see from the preceding screenshot that when any notification is fired,
    its ticker text is scrolled through the status bar. After scrolling through the
    entire text, its icon is displayed on the status bar. When a user opens the notification
    drawer by pulling it down, the notification's big icon along with the notification
    title, content text, and timestamp is shown. This is how any notification is fired
    in Android.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从前面的截图中看到，当触发任何通知时，其滚动文本会在状态栏中滚动。滚动完整个文本后，其图标将显示在状态栏上。当用户通过下拉打开通知抽屉时，将显示通知的大图标以及通知标题、内容文本和时间戳。这就是在Android中触发任何通知的方式。
- en: 'Now, we will discuss how notifications are triggered and how intents are used
    in notification applications. We will create a notification, which is shown in
    the following screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论通知是如何触发的以及通知应用中意图的使用方法。我们将创建一个通知，如下面的截图所示：
- en: '![The Notification layout](img/9639_06_38.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![通知布局](img/9639_06_38.jpg)'
- en: A simple notification
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的通知
- en: 'So, before moving forward to create a notification, we need the layout for
    our notification. The following code implementation shows our layout for the notification:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建通知之前，我们需要通知的布局。以下代码实现展示了我们通知的布局：
- en: '![The Notification layout](img/9639_06_39.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![通知布局](img/9639_06_39.jpg)'
- en: 'We have placed four views in `RelativeLayout`: an `ImageView` for the icon,
    a large `TextView` for the title, and two small `TextViews` for description and
    timestamp respectively. We have used the aligning of `RelativeLayouts` to place
    the views below, above, to the right of, and to the left of other views so that
    it can be displayed in the same way on every resolution of different smartphones.
    We have saved this file as `notification_layout.xml` in the layout folder of the
    resources directory. This was our layout for the notification. Now, let''s learn
    how to create any notification that will use this layout.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`RelativeLayout`中放置了四个视图：一个用于图标的`ImageView`，一个用于标题的大型`TextView`，以及两个分别用于描述和时间戳的小型`TextViews`。我们使用了`RelativeLayouts`的对其方式，将视图放置在其他视图的下方、上方、右侧和左侧，以便在不同分辨率智能手机上以相同方式显示。我们将此文件保存为资源目录中layout文件夹的`notification_layout.xml`。这就是我们的通知布局。现在，让我们学习如何创建使用此布局的任何通知。
- en: To create a notification with custom layouts, we have two different methods
    in Android. The first method is to use the `setLatestEventInfo` method to update
    the details displayed in the standard extended status-notification display. This
    method is the easiest method and is used in more applications. The other method
    is to set the `contentView` and `contentIntent` properties of the notification
    to assign the custom UI layout for the extended display status using the `RemoteView`
    class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有自定义布局的通知，我们在Android中有两种不同的方法。第一种方法是使用`setLatestEventInfo`方法更新标准扩展状态通知显示中显示的详细信息。这是最简单的方法，在更多应用中使用。另一种方法是设置通知的`contentView`和`contentIntent`属性，以使用`RemoteView`类为扩展状态显示分配自定义UI布局。
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`RemoteView` is a mechanism that allows developers to embed and control a layout
    embedded within any separate application. This is most commonly used in creating
    home screen widgets.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteView`是一种机制，允许开发者在任何独立应用程序中嵌入和控制布局。这通常用于创建主屏幕小部件。'
- en: We will be using a difficult method in this section to create the notification
    as this method uses intents in its code. We will first create a `RemoteView` object
    and assign it to the `contentView` property of the notification object. The `contentView`
    View represents the notification in the expanded status bar. Notifications often
    represent a request for action, and this action is performed when a user clicks
    on the notification in the notification drawer area or expanded status bar. We
    can specify `PendingIntent` that will be fired when the user clicks on the notification
    item. Mostly, this intent opens our application and provides more information
    about our notifications. Along with setting `contentView`, we also need to set
    `contentIntent` to our created object of `PendingIntent` in which a custom content
    view is assigned to our notification. The `contentIntent` intent is the intent
    that must be executed when the expanded status entry is clicked on. If this is
    the intent of the activity, we must include `FLAG_ACTIVITY_NEW_TASK` that will
    start our activity in a new task.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个复杂的方法来创建通知，因为此方法在代码中使用了意图。我们首先创建一个`RemoteView`对象，并将其分配给通知对象的`contentView`属性。`contentView`视图表示在展开状态栏中的通知。通知通常表示对操作的请求，当用户点击通知抽屉区域或展开状态栏中的通知时，执行此操作。我们可以指定当用户点击通知项时将被触发的`PendingIntent`。通常，此意图会打开我们的应用程序，并提供有关我们通知的更多信息。除了设置`contentView`之外，我们还需要将`contentIntent`设置为我们创建的`PendingIntent`对象，其中自定义内容视图被分配给我们的通知。`contentIntent`意图是在点击展开状态条目时必须执行的目的地。如果这是活动的意图，我们必须包括`FLAG_ACTIVITY_NEW_TASK`，这将使我们的活动在新任务中启动。
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you manually set the `contentView` property, you must also set the `contentIntent`
    property; otherwise, an exception will be thrown when a notification is triggered
    causing any runtime crash of your application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你手动设置`contentView`属性时，还必须设置`contentIntent`属性；否则，在触发通知时将抛出异常，导致应用程序的任何运行时崩溃。
- en: 'Once the `contentView` property is set to our custom remote view, we can''t
    set our required views in a normal way. We have to use the set methods on the
    `RemoteView` object that modifies each of the views used in the layout defined.
    This is how any notification with a custom layout is developed. The following
    code shows the implementation of the notification with custom layout, and this
    can be added in any activity:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`contentView`属性设置为我们的自定义远程视图，我们就不能以常规方式设置所需视图。我们必须使用`RemoteView`对象上的set方法，这些方法会修改在定义的布局中使用的每个视图。这就是任何具有自定义布局的通知的开发方式。以下代码展示了具有自定义布局通知的实现，这可以添加到任何活动中：
- en: '![The Notification layout](img/9639_06_40.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![通知布局](img/9639_06_40.jpg)'
- en: 'You can see from the code that we have first created an object of `Notification`
    with the initial icon, ticker text, and time of triggering the notification. Then,
    we create intent objects, `Intent` and `PendingIntent`, for specifying the action
    of our notification when it is clicked on. Then, we set `contentIntent` and `contentView`
    of the notification object. We create a new `RemoteView` object for `contentView`
    and pass our `notification_layout.xml` reference in it. This is how the notification
    layout is set to our custom layout passed in a `RemoteView` constructor. Then,
    we set our pending intent to `contentIntent`. And finally, we update the values
    of our layout using the set methods such as `setImageViewResource()` and `setTextViewText()`.
    Until now, we have developed our notification with a custom layout. Now, we will
    see how to trigger the notification. The following code snippet shows how to trigger
    the notification:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我们首先创建了一个`Notification`对象，带有初始图标、ticker文本和触发通知的时间。然后，我们创建意图对象，`Intent`和`PendingIntent`，用于指定当通知被点击时的动作。接着，我们设置了通知对象的`contentIntent`和`contentView`。我们为`contentView`创建了一个新的`RemoteView`对象，并在其中传递了我们的`notification_layout.xml`引用。这就是通知布局通过`RemoteView`构造函数设置为我们的自定义布局的方式。然后，我们将我们的待定意图设置为`contentIntent`。最后，我们使用set方法更新我们布局的值，如`setImageViewResource()`和`setTextViewText()`。到目前为止，我们已经使用自定义布局开发了自己的通知。现在，我们将了解如何触发通知。以下代码段展示了如何触发通知：
- en: '![The Notification layout](img/9639_06_41.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![通知布局](img/9639_06_41.jpg)'
- en: 'We are getting an instance of the `NotificationManager` class by calling the
    `getSystemService()` method. To trigger the notification, we are calling the `NotificationManager.notify()`
    method that receives two parameters: the first is the ID of the notification and
    the second is the notification object itself. The following screenshot shows an
    output of the application:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`getSystemService()`方法来获取`NotificationManager`类的实例。为了触发通知，我们调用了`NotificationManager.notify()`方法，该方法接收两个参数：第一个是通知的ID，第二个是通知对象本身。以下屏幕截图显示了应用程序的输出：
- en: '![The Notification layout](img/9639_06_42.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![通知布局](img/9639_06_42.jpg)'
- en: Notification fired from our application
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 来自我们应用程序的通知触发
- en: So far, we have seen how to create notifications and set custom layouts for
    their view. You might be thinking about the importance and use of intents in this
    application. In this application, intent was used only for one purpose and that
    is to navigate the user to our required application or activity when the user
    clicks on the notification. We created an `Intent` object, and from that, we created
    a `PendingIntent` object that was used in the notification as `contentIntent`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何创建通知并为它们的视图设置自定义布局。你可能正在思考意图在这个应用中的重要性及其用途。在这个应用中，意图仅用于一个目的，那就是当用户点击通知时，引导用户到我们所需的应用程序或活动。我们创建了一个`Intent`对象，并由此生成了一个`PendingIntent`对象，这个对象在通知中被用作`contentIntent`。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要总结
- en: In this chapter, we discussed Android features. We learned about common Android
    features such as layouts, display, connectivity, communication, accessibility,
    touch, and hardware support and their comparison with Android mobile components.
    We then saw how the two most important tags, `<uses-feature>` and `<uses-permission>`,
    are used in the `AndroidManifest` file and for what purpose.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Android的特性。我们了解了常见的Android特性，如布局、显示、连接性、通信、可访问性、触摸和硬件支持，以及它们与Android移动组件的比较。然后，我们看到了`AndroidManifest`文件中两个最重要的标签`<uses-feature>`和`<uses-permission>`的用途及其如何使用。
- en: We also discussed the relation between hardware and software features and Android
    mobile components and their relationship with these manifest tags. Then, we saw
    the most common intent action `ACTION_SEND` that is used to send or share anything
    with other applications using the implicit intents' approach. Then, we expanded
    our knowledge of intents to more specific features of phones including making
    calls, sending SMS/MMS messages, confirming the delivery of messages, and receiving
    messages. We used intents as well as native Android APIs to perform these actions.
    We then discussed notifications and alerts, and learned how we can set custom
    layouts in notifications. We learned two different ways, and used one way in our
    example application. We learned how intents are used in these types of applications
    and also learned about their role with those classes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了硬件和软件特性与Android移动组件之间的关系，以及它们与这些清单标签的联系。然后，我们了解了最常见的意图动作`ACTION_SEND`，它用于通过隐式意图的方法与其他应用程序分享或发送任何内容。接着，我们将意图的知识扩展到手机更具体的特性，包括拨打电话、发送短信/MMS、确认消息送达和接收消息。我们使用了意图以及Android的原生API来执行这些操作。然后，我们讨论了通知和警告，并学习了如何在通知中设置自定义布局。我们了解到了两种不同的方法，并在我们的示例应用程序中使用了一种方法。我们了解了这些类型的应用程序中意图的使用，也了解了它们与这些类的作用。
- en: In the next chapter, we will discuss intent filters and see how Android recognizes
    different intents and filters them according to the calls and applications.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论意图过滤器，并了解Android如何识别不同的意图并根据调用和应用程序对它们进行过滤。
