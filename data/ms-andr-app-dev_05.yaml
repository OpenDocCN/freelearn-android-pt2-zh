- en: Chapter 5. Lists and Grids
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 列表和网格
- en: In this chapter, we will work with lists and grids. A list or a matrix of elements
    can be found in almost every app on the market. Knowing how to display a list
    of elements on Android is something that you learn at a basic level; however,
    there is a lot to expand on and understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理列表和网格。几乎在市场上的每个应用中都可以找到列表或元素矩阵。了解如何在Android上显示元素列表是你在基础层面要学习的东西；然而，还有很多可以扩展和了解的内容。
- en: It's important to know which patterns we can use here, how to recycle the view,
    and how to display different kinds of elements with different views in the same
    list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们可以在这里使用哪些模式很重要，如何回收视图，以及如何在同一个列表中用不同的视图显示不同类型的元素。
- en: 'With this in mind, we will be able to understand why `RecyclerView` is the
    successor of `ListView`, and we will learn how to implement a list with this component.
    Therefore, we will cover the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们将能够理解为什么`RecyclerView`是`ListView`的继任者，并且我们将学习如何使用这个组件实现列表。因此，在本章中我们将介绍以下内容：
- en: Starting with lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表开始
- en: ListView
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ListView
- en: The custom adapter
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义适配器
- en: Recycling views
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图回收
- en: Using the ViewHolder pattern
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ViewHolder模式
- en: Introducing RecyclerView
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍RecyclerView
- en: List, grid, or stack
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、网格或堆叠
- en: Implementation
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: OnItemClick
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OnItemClick
- en: Starting with lists
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表开始
- en: If you have heard of `RecyclerView`, you might wonder why we are going through
    `ListView`. The `RecyclerView` widget is new; it came out with Android Lollipop,
    and is a revolution when displaying a list of items; it can do it vertically and
    horizontally, as a list or as a grid, or with nice animations among other improvements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你听说过`RecyclerView`，你可能会想知道为什么我们要学习`ListView`。`RecyclerView`小部件是新的，它随着Android
    Lollipop一起出现，在显示项目列表时是一场革命；它可以垂直和水平显示，作为列表或网格，以及具有其他改进的精美动画。
- en: Answering the question, even if `RecyclerView` is more efficient and flexible
    in some scenarios, it needs extra coding to achieve the same result, so there
    are still reasons to use `ListView`. For example, there is no `onItemClickListener()`
    for item selection in `RecyclerView`, and there is no visual feedback when we
    click on an item. If we don't need customization and animations, for instance
    for a simple data picker popup, this could be a dialog where we just have to select
    a country. In this case, it's perfectly fine to use `ListView` rather than `RecyclerView`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些场景下`RecyclerView`可能更高效、更灵活，但它需要额外的编码来实现相同的结果，因此仍然有使用`ListView`的理由。例如，`RecyclerView`中没有用于条目选择的`onItemClickListener()`，而且我们在点击条目时也没有视觉反馈。如果我们不需要定制和动画，例如对于一个简单的数据选择弹窗，这可能是一个只需选择一个国家的对话框。在这种情况下，使用`ListView`而不是`RecyclerView`是完全没问题的。
- en: Another reason to start with `ListView` is that `RecyclerView` solves most of
    the problems presented when working with `ListViews`. Therefore, by starting with
    `ListView` and solving these problems, we will fully understand how `RecyclerView`
    works and why it is implemented this way. Thus, we will explain individually the
    patterns that are used to have a global idea of the component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个从`ListView`开始的原因是`RecyclerView`解决了大多数在使用`ListViews`时遇到的问题。因此，通过从`ListView`开始并解决这些问题，我们将完全理解`RecyclerView`是如何工作的以及为什么这样实现。因此，我们将分别解释用于全局理解组件的模式。
- en: 'Here is an example of the basic `AlertDialog` with the purpose of selecting
    an item; here, the use of `ListView` makes perfect sense:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基本的`AlertDialog`示例，其目的是为了选择一个条目；在这种情况下，使用`ListView`是很有意义的：
- en: '![Starting with lists](img/4887_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![从列表开始](img/4887_05_01.jpg)'
- en: Using ListViews with built-in views
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置视图的ListViews
- en: When you first implement `ListView`, it might seem trivial and easy; however,
    when you spend more time with Android, you realize how complex it can get. You
    can very easily find performance and memory issues by just having a large list
    of elements with an image on every row. It can be difficult to customize the list
    if you try to implement a complex UI; for example, having the same list displaying
    different items, creating different rows with different views, or even trying
    to group some items while showing a section title can be a headache.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次实现`ListView`时，可能会觉得微不足道且简单；然而，当你花更多时间在Android上时，你会意识到它可能变得多么复杂。如果你有一个带有每行图片的大型元素列表，你很容易就能找到性能和内存问题。如果你尝试实现复杂的UI，例如让同一个列表显示不同的条目，创建具有不同视图的不同行，或者甚至尝试在显示部分标题时组合某些条目，可能会很头疼。
- en: Let's start with the shortest way to implement a list, using the Android built-in
    item layout, which is created to be used in simple lists as discussed before.
    In order to show the list, we will include it in `AlertDialog`, which will be
    shown when we tap on a button in the settings fragment. I will set the text of
    the button to `Lists Example`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现列表的最简方式开始，使用前面讨论过的简单列表中使用的Android内置项目布局。为了显示列表，我们将它包含在`AlertDialog`中，当我们点击设置片段中的按钮时，会显示这个对话框。我会将按钮的文本设置为`Lists
    Example`。
- en: 'The first step is to create the button in `settings_fragment.xml`; once created,
    we can set the click listener to the button. Now, we understand a bit more about
    software patterns instead of setting the click listener in the following way:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在`settings_fragment.xml`中创建按钮；创建后，我们可以为按钮设置点击监听器。现在，我们对软件模式有了更深入的了解，而不仅仅是以下这种方式设置点击监听器：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will do it in a more structured way, especially because we know that in the
    settings screen, there will be a good number of buttons, and we want to handle
    all the clicks in the same place. Instead of creating `onClickListener` inside
    the method call, we will make the `Fragment` implement `OnClikListener` by setting
    `onClickListener` to `this`. The `this` keyword refers to the whole fragment here,
    so the fragment will be listening for the click in the `onClick` method, which
    is mandatory to implement once the `Fragment` implements `View.OnClickListener`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以更有条理的方式来做这件事，特别是因为我们知道在设置屏幕上，将会有很多按钮，我们希望在同一地方处理所有点击事件。我们不会在方法调用内部创建`onClickListener`，而是通过将`onClickListener`设置为`this`，使`Fragment`实现`OnClikListener`。这里的`this`关键字指的是整个片段，因此片段将在`onClick`方法中监听点击，一旦`Fragment`实现了`View.OnClickListener`，这个方法是必须实现的。
- en: The `OnClick()` method receives a view, which is the view clicked on. If we
    compare that view's ID with the ID of the button, we will know whether the button
    or the other view where we set `clickListener` has been clicked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnClick()`方法接收一个视图，即被点击的视图。如果我们将该视图的ID与按钮的ID进行比较，我们就会知道是按钮还是设置了`clickListener`的其他视图被点击了。'
- en: 'Just type `implements View.OnClickListener` when defining the class, and you
    will be asked to implement the mandatory methods:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类时只需键入`implements View.OnClickListener`，你就会被要求实现必填的方法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will notice that we also move the logic to show the list dialog to an external
    method, keeping the structure easy to read in `onClick();`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们还把显示列表对话框的逻辑移到了外部方法中，这样在`onClick();`中的结构易于阅读。
- en: 'Continuing with the dialog, we can show an `AlertDialog` that has a `setAdapter()`
    property, which automatically binds the items with an internal `ListView`. Alternatively,
    we could create a view for our dialog with `ListView` on it and then set the adapter
    to that `ListView`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用对话框，我们可以显示一个带有`setAdapter()`属性的`AlertDialog`，它会自动将内部项与`ListView`绑定。或者，我们可以为对话框创建一个带有`ListView`的视图，然后将适配器设置给该`ListView`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This dialog will show a message indicating the option clicked. We have used
    `android.R.layout.select_dialog_singlechoice` as a view for our rows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对话框将显示一条消息，指示点击的选项。我们使用了`android.R.layout.select_dialog_singlechoice`作为我们行的视图。
- en: 'These are a few different examples of built-in layouts for lists, which will
    depend on the theme of our application. The dialog won''t look the same in 4.4
    KitKat and in 5.0 Lollipop, for instance, in `android.R.layout.simple_list_item_1`,
    this is how it will look:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是列表内置布局的几个不同示例，它们将取决于我们应用程序的主题。例如，在4.4 KitKat和5.0 Lollipop中，对话框看起来是不同的，在`android.R.layout.simple_list_item_1`中，它看起来会是这样：
- en: '![Using ListViews with built-in views](img/4887_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置视图的 ListViews](img/4887_05_02.jpg)'
- en: 'Here''s what `android.R.layout.simple_list_item_2` with two rows will look
    similar to:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`android.R.layout.simple_list_item_2`布局有两行，看起来会类似这样：'
- en: '![Using ListViews with built-in views](img/4887_05_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置视图的 ListViews](img/4887_05_03.jpg)'
- en: 'This is an example of `android.R.layout.simpleListItemChecked`, where we can
    change the choice mode to multiple or single:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`android.R.layout.simpleListItemChecked`的例子，我们可以将选择模式更改为多选或单选：
- en: '![Using ListViews with built-in views](img/4887_05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置视图的 ListViews](img/4887_05_04.jpg)'
- en: 'This is `android.R.layout.activityListItem`, where we have an icon and text:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`android.R.layout.activityListItem`，我们有一个图标和文本：
- en: '![Using ListViews with built-in views](img/4887_05_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置视图的 ListViews](img/4887_05_05.jpg)'
- en: We can access these built-in layout components to tweak the view a bit more
    when creating the layout. These components are named `android.resource.id.Text1`,
    `android.resource.id.Text2`, `android.resource.id.Icon`, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建布局时，我们可以访问这些内置的布局组件，以便进一步调整视图。这些组件的名称为`android.resource.id.Text1`、`android.resource.id.Text2`、`android.resource.id.Icon`等。
- en: Now, we have an idea of how to create lists with the functionality and views
    ready to be used. It's time to create our own Adapter and implement the functionality
    and the view manually.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了如何创建带有功能和视图的列表。是时候创建我们自己的适配器并手动实现功能和视图了。
- en: Creating a custom Adapter
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义适配器
- en: When you look for a job, apart from looking at offers, you would also be handing
    your CV to different software companies or to IT recruitment companies that will
    find a company for you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你寻找工作时，除了查看职位信息，你还会向不同的软件公司或IT招聘公司提交你的简历，他们会为你找到一家公司。
- en: 'In our contact fragment, we will create a list sorted by country, displaying
    the contact details of these companies. There will be two different rows: one
    for the country header and another one for the company details.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的联系人片段中，我们将创建一个按国家排序的列表，显示这些公司的联系人详细信息。将有两行不同的内容：一行用于国家头部，另一行用于公司详细信息。
- en: 'We can create another table in our Parse database, called `JobContact`, with
    the following fields:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Parse数据库中创建另一个表，名为`JobContact`，包含以下字段：
- en: '![Creating a custom Adapter](img/4887_05_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义适配器](img/4887_05_06.jpg)'
- en: 'We will request the job contacts from the server and build a list of items
    that will be sent to the Adapter to build the list. In the list, we will send
    two different elements: the company and the country. What we can do is generate
    a list of items and add the two as objects. Our two classes will look similar
    to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从服务器请求工作联系人，并构建一个项目列表，该列表将发送到适配器以构建列表。在列表中，我们将发送两个不同的元素：公司和国家。我们可以生成一个项目列表并将这两个作为对象添加。我们的两个类将类似于以下内容：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we download the information sorted by country from [http://www.parse.com](http://www.parse.com),
    we can build our list of items, iterating through the parse list and adding a
    country header when a different country is detected. Execute the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从[http://www.parse.com](http://www.parse.com)按国家排序下载了信息，我们就可以通过遍历解析列表并检测到不同国家时添加一个国家头部来构建我们的项目列表。执行以下代码：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have our list with the headers included we are ready to create
    the `Adapter` based on this list, which will be sent as a parameter in the constructor.
    The best way to customize an `Adapter` is to create a subclass extending `BaseAdapter`.
    Once we do this, we will be asked to implement the following methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包含头部的列表，我们可以基于这个列表创建`Adapter`，它将在构造函数中作为参数发送。自定义`Adapter`的最佳方式是创建一个扩展`BaseAdapter`的子类。一旦我们这样做，我们将被要求实现以下方法：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These methods will have to be implemented according to the data that we want
    to display; for instance, `getCount()` will have to return the size of the list.
    We need to implement a constructor receiving two parameters: the list and the
    context. The context will be necessary to inflate the list in the `getView()`
    method. This is how the adapter will look without implementing `getView()`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法需要根据我们想要显示的数据来实现；例如，`getCount()`需要返回列表的大小。我们需要实现一个接收两个参数的构造函数：列表和上下文。上下文将是在`getView()`方法中膨胀列表所必需的。下面是没有实现`getView()`的适配器的外观：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our case, we can create two different views; so, apart from the mandatory
    methods, we need to implement two extra methods:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以创建两个不同的视图；因此，除了必须实现的方法外，我们还需要实现两个额外的方法：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `getItemViewType` method will return `0` if the element is a country or
    `1` if the element is a company. With the help of this method, we can implement
    `getView()`. In case it''s a country, we inflate `row_job_country.xml`, which
    contains `ImageView` and `TextView`; in case it''s a company, we inflate `row_job_contact.xml`,
    which contains three text views:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`getItemViewType`方法将返回`0`如果元素是国家，或者`1`如果元素是公司。借助这个方法，我们可以实现`getView()`。如果是国家，我们膨胀`row_job_country.xml`，其中包含`ImageView`和`TextView`；如果是公司，我们膨胀`row_job_contact.xml`，其中包含三个文本视图：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To finish, we can create `ListView` in `contact_fragment.xml` and set the adapter
    to this list. However, we will take a shortcut and use `android.support.v4.ListFragment`;
    this is a fragment that already inflates a view with `ListView` and contains the
    `setListAdapter()` method, which sets an adapter to the built-in `ListView`. Extending
    from this fragment, our `ContactFragment` class will look similar to the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`contact_fragment.xml`中创建`ListView`，并将适配器设置到这个列表。但是，我们将采取捷径，使用`android.support.v4.ListFragment`；这是一个已经通过`ListView`膨胀了视图并包含`setListAdapter()`方法的片段，该方法将适配器设置到内置的`ListView`中。从这段代码扩展，我们的`ContactFragment`类将类似于以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Upon calling the `retrieveJobContacts()` method after the view has been created,
    we achieve the following result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图创建后调用`retrieveJobContacts()`方法，我们实现了以下结果：
- en: '![Creating a custom Adapter](img/4887_05_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义适配器](img/4887_05_07.jpg)'
- en: 'The flags that we have displayed are images in the `drawable` folder whose
    name matches the country code, *drawable/ "country_code" .png*. We can display
    them by setting the resource identifier to `ImageView` and retrieving it with
    the following method inside the `Country` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显示的旗帜是`drawable`文件夹中的图片，其名称与国家代码相匹配，*drawable/ "country_code" .png*。我们可以通过将资源标识符设置为`ImageView`并在`Country`类内的以下方法中获取它们来显示它们：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a basic version of `ListView` with two different types of rows. This
    version is still far from perfect; it lacks performance. It does not recycle the
    views, and it finds the IDs of the widget every time we create a row. We will
    explain and solve this problem in the following section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的`ListView`版本，包含两种不同类型的行。这个版本仍然远非完美；它的性能不佳，没有回收视图，并且每次创建行时都会查找小部件的ID。我们将在下一节解释并解决这个问题。
- en: Recycling views
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图回收
- en: While working with `ListView`, we need to keep in mind that the number of rows
    is a variable and we always want the list to feel fluent even if we scroll as
    quickly as we can. Hopefully, Android helps us a lot with this task.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ListView`时，我们需要牢记行数是一个变量，即使我们尽可能快速地滚动，我们也希望列表能够流畅。幸运的是，Android在这方面为我们提供了很大帮助。
- en: When we scroll through `ListView`, the views that are not visible anymore on
    one side of the screen are reused and displayed again on the other side. This
    way, android saves inflation of the views; when it inflates, a view has to go
    through the xml nodes, instantiating every component. This extra computation can
    be the difference between a fluent and staggering list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们滚动`ListView`时，屏幕一侧不再可见的视图会被复用并在另一侧再次显示。这样，Android节省了视图的膨胀；当它膨胀时，视图必须遍历xml节点，实例化每个组件。这种额外的计算可能是流畅列表和卡顿列表之间的区别。
- en: '![Recycling views](img/4887_05_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![回收视图](img/4887_05_08.jpg)'
- en: The `getView()` method receives as a parameter one of the views that are to
    be recycled or null if there are no views to be recycled.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`getView()`方法接收一个待回收的视图作为参数，如果没有视图可以回收，则接收null。'
- en: 'To take advantage of this view recycling, we need to stop creating a view every
    time and reuse the view coming as a parameter. We still need to change the value
    of the text views and widget inside the row on a recycled view because it has
    the initial values that correspond to its previous position. In our example, we
    have an extra complication; we cannot recycle a country view to be used for a
    company view, so we can only recycle views of the same view type. However, again,
    Android does that check for us using internally the `getItemViewType` method that
    we implemented:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种视图回收机制，我们需要停止每次都创建新视图，而是复用作为参数传入的视图。我们仍然需要在回收的视图中更改行内文本视图和小部件的值，因为它具有与其先前位置的初始值相对应的内容。在我们的示例中，有一个额外的复杂性；我们不能将国家的视图回收用于公司视图，因此我们只能回收相同视图类型的视图。然而，再次强调，Android通过内部使用我们实现的`getItemViewType`方法为我们进行这个检查：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Applying the ViewHolder pattern
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用ViewHolder模式
- en: Note that in `getView()`, every time we want to set a text to `TextView`, we
    search this `TextView` in row view with the `findViewById()` method; even when
    the row is recycled, we still find the `TextView` again to set the new value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`getView()`方法中，每次我们想要将文本设置到`TextView`时，都会使用`findViewById()`方法在行视图中搜索这个`TextView`；即使行被回收，我们仍然需要再次找到`TextView`以设置新值。
- en: 'We can create a class called `ViewHolder`, which holds the reference to the
    widget by saving the computation of the widget search inside the row. This `ViewHolder`
    class will only contain references to the widgets, and we can keep a reference
    between a row and its `ViewHolder` class through the `setTag()` method. A `View`
    object allows us to set an object as a tag and retrieve it later; we can add as
    many tags as we want by specifying a key for this tag: `setTag(key)` or `getTag(key)`.
    If no key is specified, we can save and retrieve the default tag.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为`ViewHolder`的类，它通过保存行内小部件搜索的计算来引用小部件。这个`ViewHolder`类将只包含对小部件的引用，我们可以通过`setTag()`方法在行与其`ViewHolder`类之间保持引用。`View`对象允许我们设置一个对象作为标签并在稍后检索它；我们可以通过指定这个标签的键来添加任意数量的标签：`setTag(key)`或`getTag(key)`。如果没有指定键，我们可以保存和检索默认标签。
- en: 'Following this pattern for the first time that we create the view, we will
    create the `ViewHolder` class and set it as a tag to the view. If the view is
    already created and we are recycling it, we will simply retrieve the holder. Execute
    the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种模式，在我们第一次创建视图时，我们将创建一个`ViewHolder`类并将其设置为视图的标签。如果视图已经创建并且我们正在回收利用它，我们只需简单地检索持有者。执行以下代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To simplify this code, we can create a method called `bindView()` inside each
    holder; it will get a country or company object and populate the widgets:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这段代码，我们可以在每个持有者内部创建一个名为`bindView()`的方法；它将获取一个国家或公司对象并填充小部件：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will now finish with the list of `ListView` performance improvements. If
    there are images or long operations to load a view, we need to create `AsyncTask`
    method inside `getView()` so as to avoid heavy operation while scrolling. For
    instance, if we want to display an image downloaded from the Internet on every
    row, we would have a `LoadImageAsyncTask` method, which we will execute with the
    holder and the URL to download the image from. When the `Asynctask` method finishes,
    it will have a reference to the holder and will therefore be able to display the
    image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将完成`ListView`性能改进列表。如果需要加载图像或长时间操作视图，我们需要在`getView()`中创建`AsyncTask`方法，以避免在滚动时进行繁重操作。例如，如果我们想在每一行显示从互联网下载的图像，我们会有一个`LoadImageAsyncTask`方法，我们将使用持有者和要下载图像的URL来执行它。当`Asynctask`方法完成后，它将拥有对持有者的引用，因此能够显示图像：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we know all of the different techniques to improve the performance
    of a `ListView`, we are ready to introduce `RecyclerView`. By applying most of
    these techniques in the implementation, we will be able to identify it easily.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了所有不同的提高`ListView`性能的技术，我们准备引入`RecyclerView`。通过在实现中应用这些技术的大部分，我们将能够轻松识别它。
- en: Introducing RecyclerView
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍RecyclerView
- en: The `RecyclerView` was introduced in Android 5.0 Lollipop and was defined by
    Google as a more flexible and advanced version of `ListView`. It is based on an
    `Adapter` class similar to `ListView`, but it enforces the use of a `ViewHolder`
    class to improve performance and modularity, as we have seen in the previous section.
    The flexibility comes in when we decouple the item representation from the component
    and allow animations, item decorations, and layout managers to do the work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`在Android 5.0 Lollipop中引入，并被谷歌定义为比`ListView`更灵活和先进的版本。它基于一个类似于`ListView`的`Adapter`类，但强制使用`ViewHolder`类来提高性能和模块化，如我们前一部分所见。当我们把项目表示与组件分离，允许动画、项目装饰和布局管理器来完成工作时，灵活性就体现出来了。'
- en: The `RecyclerView` handles the adding and removing of animations using `RecyclerView.ItemAnimator`,
    which we can subclass to customize the animations. If you display data from a
    source or if the data changes, for instance by adding or removing items, you can
    call `notifyItemInserted()` or `notifyItemRemoved()` to trigger the animations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`通过`RecyclerView.ItemAnimator`处理添加和移除动画，我们可以通过子类化来自定义动画。如果你从数据源显示数据，或者数据发生变化，例如添加或移除项目，可以调用`notifyItemInserted()`或`notifyItemRemoved()`来触发动画。'
- en: To add separators, group items, or highlight an item, we can use `RecyclerView.ItemDecoration`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加分隔线、分组项目或突出显示某个项目，我们可以使用`RecyclerView.ItemDecoration`。
- en: One of the main differences in utilizing `ListView` is the use of layout managers
    to position the items. With `ListView`, we know that our items will always be
    displayed vertically, and if we want to have a grid, we can use `GridView`. Layout
    managers make our list more flexible in that we can display elements as we want
    and can even create our own layout manager.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ListView` 的主要区别之一是使用布局管理器来定位项目。使用 `ListView` 时，我们知道我们的项目将始终垂直显示，如果我们想要网格，可以使用
    `GridView`。布局管理器使我们的列表更加灵活，因为我们可以按需显示元素，甚至可以创建自己的布局管理器。
- en: Using list, grid, or stack
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列表、网格或堆叠
- en: 'By default, we have three built-in layout managers: `LinearLayoutManager`,
    `GridLayoutManager`, and `StaggeredLayoutManager`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们有三个内置布局管理器：`LinearLayoutManager`、`GridLayoutManager` 和 `StaggeredLayoutManager`。
- en: The `LinearLayoutManager` displays the items aligned in a list, where we can
    specify the orientation—vertical or horizontal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayoutManager` 以列表形式对齐显示项目，我们可以指定方向——垂直或水平。'
- en: '![Using list, grid, or stack](img/4887_05_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用列表、网格或堆叠](img/4887_05_09.jpg)'
- en: 'The `GridLayoutManager` displays the items as a matrix, where we can specify
    the columns and rows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridLayoutManager` 以矩阵形式显示项目，我们可以指定列和行：'
- en: '![Using list, grid, or stack](img/4887_05_10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用列表、网格或堆叠](img/4887_05_10.jpg)'
- en: The `StaggereGriddLayoutManager` displays the items in a staggered way; these
    items can have different widths or heights, and we can control how they are displayed
    with `setGapStrategy()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaggereGriddLayoutManager` 以交错方式显示项目；这些项目可以有不同的宽度和高度，我们可以使用 `setGapStrategy()`
    控制它们的显示方式。'
- en: '![Using list, grid, or stack](img/4887_05_11.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用列表、网格或堆叠](img/4887_05_11.jpg)'
- en: Implementing RecyclerView
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 RecyclerView
- en: Continuing with `MasteringAndroidApp`, we will implement again the list of job
    offers, removing `ParseQueryAdapter` and using `RecyclerView` instead. We will
    still query the data from Parse, but this time, what we will do is save the list
    of items in a variable and use it to build `RecyclerView.Adapter`, which will
    be used by `RecyclerView`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 `MasteringAndroidApp`，我们将再次实现工作机会列表，移除 `ParseQueryAdapter` 并使用 `RecyclerView`
    替代。我们仍然会从 Parse 查询数据，但这次，我们将做的是将项目列表保存在一个变量中，并使用它来构建 `RecyclerView.Adapter`，这将由
    `RecyclerView` 使用。
- en: 'The `RecyclerView` is included in the v7 support library; the best way to include
    it in our project is to open the project structure, click on the dependencies
    tab, and search for `RecyclerView`. A list of results will be presented as shown
    in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView` 包含在 v7 支持库中；将依赖项添加到项目中的最佳方式是打开项目结构，点击依赖项标签，并搜索 `RecyclerView`。将展示如下截图所示的结果列表：'
- en: '![Implementing RecyclerView](img/4887_05_12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![实现 RecyclerView](img/4887_05_12.jpg)'
- en: 'This is the equivalent of adding the following line to the `build.gradle` dependencies:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在 `build.gradle` 依赖项中添加以下行：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once the line is added, we will click on **Sync Gradle with Project files**
    to update the dependencies and get ready to use `RecyclerView` in our XML.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 添加完代码行后，我们将点击**同步 Gradle 与项目文件**来更新依赖项，并准备在 XML 中使用 `RecyclerView`。
- en: 'Open `fragment_list.xml` and replace the existing `ListView` with `RecyclerView`,
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `fragment_list.xml` 文件，将现有的 `ListView` 替换为 `RecyclerView`，如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you don't get any errors after adding it, the dependency was added correctly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后如果没有错误，说明依赖项已正确添加。
- en: 'The next step is to create the adapter. This adapter is slightly different
    from the adapter that we created for the job contacts; instead of extending `BaseAdapter`,
    we will extend `RecyclerView.Adapter <RecyclerView.MyViewHolder>`, which is an
    adapter that implements the `ViewHolder` pattern after creating the `JobOfferAdapter`
    adapter class. However, before extending, we have to create an internal `MyViewHolder`
    class extending `RecylcerView.ViewHolder`. So far, we have the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建适配器。这个适配器与我们为工作联系人创建的适配器略有不同；我们不会扩展 `BaseAdapter`，而是将扩展 `RecyclerView.Adapter
    <RecyclerView.MyViewHolder>`，在创建 `JobOfferAdapter` 适配器类后实现 `ViewHolder` 模式。但在扩展之前，我们必须创建一个内部类
    `MyViewHolder` 继承 `RecylcerView.ViewHolder`。至此，我们有以下代码：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now is when we extend the `JobOffersAdapter` class from `RecyclerView.Adapter<JobsOfferAdapter.MyViewHolder>`.
    We will be asked to implement the following methods:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是扩展 `JobOffersAdapter` 类从 `RecyclerView.Adapter<JobsOfferAdapter.MyViewHolder>`
    的时候了。系统将要求我们实现以下方法：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Following the same approach as in `JobsContactsAdapter`, we create a constructor
    by receiving the list of job offers and implement the adapter methods based on
    that list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `JobsContactsAdapter` 中的方法相同，我们通过接收工作机会列表创建构造函数，并根据该列表实现适配器方法。
- en: '`OnBindViewHolder` receives the holder with a position; all we need to do is
    get the job offer in that position on the list and update the holder text views
    with these values. `OnCreateViewHolder` will inflate the view; in this case, we
    only have one type, so we ignore the `ViewType` parameter. We will show here an
    alternative way to inflate the view: using the context of the parent, which comes
    as a parameter.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnBindViewHolder` 接收带有位置的持有者；我们需要做的就是获取列表中该位置的 job offer 并使用这些值更新持有者的文本视图。`OnCreateViewHolder`
    将会填充视图；在这种情况下，我们只有一种类型，所以我们忽略 `ViewType` 参数。这里我们将展示一种替代的视图填充方法：使用作为参数传递的父级上下文。'
- en: 'Finally, `getItemCount` will return the number of job offers. As you complete
    all of the above tasks, our new Adapter will be created with the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`getItemCount` 将返回工作机会的数量。完成上述所有任务后，我们新的适配器将使用以下代码创建：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That is all that we need from the adapter side; now, we need to initialize
    `RecyclerView` and set a layout manager along with the adapter. The adapter has
    to be instantiated using the list of objects from Parse in the same way that we
    retrieved our job contacts in the previous Adapter. First, in `OnCreateView`,
    we will initialize `RecyclerView`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要适配器完成的所有工作；现在，我们需要初始化 `RecyclerView` 并设置布局管理器以及适配器。适配器必须使用从 Parse 获取的对象列表实例化，就像我们在之前的适配器中获取工作联系人一样。首先，在
    `OnCreateView` 中，我们将初始化 `RecyclerView`：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the end, we will call `retrieveOffers()`, which is an `async` operation.
    Only when the result is retrieved from Parse will we be able to create the adapter
    and set it to the list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将调用 `retrieveOffers()`，这是一个 `async` 操作。只有当从 Parse 获取结果后，我们才能创建适配器并将其设置到列表中：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The best way to test all that we set to work is to see if there are any errors
    in the console. If all runs fine, you should be able to see the list of offers,
    as in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 检验我们工作成果的最佳方式是查看控制台是否有错误。如果一切运行正常，你应该能够看到如下截图所示的优惠列表：
- en: '![Implementing RecyclerView](img/4887_05_13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![实现 RecyclerView](img/4887_05_13.jpg)'
- en: We have intentionally added a repeated job offer, which we will delete in order
    to see the removing animations included by default in `RecyclerView`. We will
    implement this functionality in a **long click listener**. The click listener
    is performed only to open the offer in the detail view. We will see how to do
    this in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意添加了一个重复的工作机会，以便删除它以查看 `RecyclerView` 中默认包含的移除动画。我们将在 **长按监听器** 中实现这个功能。点击监听器仅用于在详情视图中打开优惠。我们将在下一节中看到如何操作。
- en: Clicking on RecyclerView items
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击 `RecyclerView` 项
- en: In `ListView`, it was quite easy to detect a click on an item; we could simply
    perform `ListView.setOnItemClickLister` and `setOnItemLongClickListener` for long
    clicks. However, this implementation is not as quick with `RecyclerView`; the
    flexibility comes at a cost.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ListView` 中，检测项目点击相当简单；我们可以直接执行 `ListView.setOnItemClickLister` 和 `setOnItemLongClickListener`
    以处理长按点击。然而，这种实现方式在 `RecyclerView` 中并不那么快速，这种灵活性是有代价的。
- en: 'There are two approaches to implementing an item click here: one is to create
    a class that implements `RecyclerView.OnItemTouchListener` and calls the `RecyclerView`
    method, `addOnItemTouchListener`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种实现项目点击的方法：一种是通过创建一个实现 `RecyclerView.OnItemTouchListener` 的类，并调用 `RecyclerView`
    的方法 `addOnItemTouchListener`，如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The benefit of this approach is that we define what to do inside `onClick` in
    each activity or fragment. The logic of the click is not on the view, and once
    we build this component, we can reuse it in different apps.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处在于，我们可以在每个活动或片段中定义 `onClick` 内应该执行的操作。点击逻辑不在视图上，一旦我们构建了这个组件，就可以在不同的应用中重复使用它。
- en: 'The second approach is to set and manage the click inside `ViewHolder`. We
    will have a problem here if we want to reuse this `ViewHolder` in a different
    part of the app or in another app because the logic of the click is inside the
    view and we might want to have a different logic in different fragments or activities.
    However, this approach makes it easier to detect clicks on different components
    inside the same row. For instance, if we had a small icon to delete and another
    one to share the offer inside the row, this approach would make much more sense.
    This way, we can set the click on the job name in every row and a long click listener
    in the whole row:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是设置和管理`ViewHolder`内部的点击事件。如果我们想要在应用程序的不同部分或在另一个应用程序中复用这个`ViewHolder`，这里就会出现问题，因为点击逻辑位于视图内部，我们可能希望在不同的片段或活动中有不同的逻辑。然而，这种方法使得在同一行内检测不同组件的点击变得更加容易。例如，如果我们在行内有一个小图标用于删除，另一个用于分享优惠，这种方法更有意义。这样，我们可以在每一行设置对工作名称的点击，并在整行上设置长按监听器：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should be able to judge which implementation to use in every situation and
    argue in its favor. To be able to test this, we are going to delete an element
    after a long tap (we should have a confirmation dialog here to avoid deleting
    items by mistake but we will skip this part). The element will be deleted locally
    to display the remove animation. Note that we are not deleting this element from
    the source in Parse; all we need to do is to delete the element from the list
    and call `notifyItemRemoved` to trigger the notification. We will know which item
    is clicked on with the `getPosition()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够判断在每种情况下应该使用哪种实现，并为其辩护。为了能够测试这一点，我们将在长按后删除一个元素（这里应该有一个确认对话框以避免误删，但我们将省略这部分内容）。元素将在本地被删除以显示移除动画。注意，我们没有从Parse中的源数据中删除这个元素；我们需要做的是从列表中删除元素并调用`notifyItemRemoved`来触发通知。我们可以通过`getPosition()`方法知道哪个条目被点击了。
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the end of this chapter, you will know how to implement an Adapter, how to
    handle different types of items in lists, and how and why we apply the `ViewHolder`
    pattern. You first learned this along with the `ListView` class and manually implemented
    the recycling view techniques. As a result, you will be able to fully understand
    the features and how `RecyclerView` works in showing different ways to display
    the items and implement item click listeners.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，你将了解到如何实现一个适配器，如何在列表中处理不同类型的条目，以及我们如何以及为什么应用`ViewHolder`模式。你最早是在`ListView`类中学习这些内容，并手动实现了视图回收技术。因此，你将能够完全理解特性以及`RecyclerView`如何工作，以展示不同的条目显示方式和实现条目点击监听器。
- en: In the next chapter, we will discover a new component introduced along with
    `RecyclerView` in Android 5.0— `CardView`. We will combine this with `RecyclerView`
    to have a flexible and professional-looking list of cards.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探索在Android 5.0中与`RecyclerView`一起引入的一个新组件—`CardView`。我们将将其与`RecyclerView`结合使用，以获得灵活且专业外观的卡片列表。
