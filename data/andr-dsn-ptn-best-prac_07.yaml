- en: Chapter 7. Combining Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章. 组合模式
- en: We have seen how patterns can help us organize our code and how this can be
    applied specifically to Android apps, but we have only applied one pattern at
    a time. As the tasks we need to perform become more complex, we will need to apply
    several patterns, such as decorators and builders, at once and even combine them
    into **hybrid patterns**, and this is what we will do in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到模式如何帮助我们组织代码，以及如何将其具体应用于Android应用，但我们一次只应用了一个模式。随着我们需要执行的任务变得更加复杂，我们将需要同时应用多个模式，比如装饰器和生成器，甚至将它们组合成**混合模式**，这正是我们将在本章中要做的事情。
- en: We will begin by considering a more complex user interface (UI) and the code
    behind it. This will require us to think a little more precisely about what we
    actually want our application to do. This in turn will lead us to look at the
    **prototype pattern**, which provides a very efficient method for creating objects
    from an original, clone, object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从考虑更复杂的用户界面（UI）及其背后的代码开始。这将要求我们更精确地思考我们实际希望应用程序做什么。这也将引导我们研究**原型模式**，它提供了一种非常有效的方法，可以从原始对象或克隆对象创建对象。
- en: The **decorator pattern** is explored next, and we see how it can be used to
    add extra functionality to existing classes. Often referred to as a wrapper, the
    decorator is used to provide additional functionality to existing code. This is
    particularly useful to our sandwich builder app as it allows us to include options
    such as ordering an open sandwich or having the bread toasted. These are not in
    themselves ingredients, but nevertheless something a sandwich vendor would wish
    to provide. The decorator pattern is ideal for this task.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨**装饰器模式**，看看它如何用于向现有类添加额外功能。通常被称为包装器，装饰器用于为现有代码提供附加功能。这对于我们的三明治制作应用特别有用，因为它允许我们包含如下选项：订购开放式三明治或者选择烤面包。这些本身不是配料，但三明治销售商可能希望提供这些服务。装饰器模式非常适合这项任务。
- en: Having looked briefly at the alternatives, we construct a builder pattern to
    form the basis of our system, connecting it to a UI so that a simple sandwich,
    with a choice of options and ingredients, can be put together by the user. We
    then connect a decorator to this builder to provide further options.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要了解了其他选择之后，我们构建了一个生成器模式作为我们系统的核心，并将其连接到一个用户界面（UI），以便用户可以组合一个简单的三明治，并选择选项和配料。然后，我们连接一个装饰器到这个生成器以提供更多选项。
- en: 'In this chapter you will learn how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何做到以下几点：
- en: Create a prototype pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原型模式
- en: Create a decorator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建装饰器模式
- en: Extend a decorator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展装饰器
- en: Connect a builder to a UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成器连接到UI
- en: Manage compound buttons
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理复合按钮
- en: Combine patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: We are now in a position to start thinking more about the details of our app
    and what it can and should do. We need to think about the potential customer and
    design something that is simple and pleasant to use. Features need to be easily
    accessed and obvious in their nature and most of all, they need to be able to
    construct their desired sandwich with a minimum number of clicks. Later on, we
    will see how users can store favorites and how we can provide partially built
    sandwiches for the user to customize rather than build from the ground up. For
    now, we will take a look at how to classify our sandwich-related objects and classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够开始更多地考虑我们应用的细节以及它能做什么、应该做什么。我们需要考虑潜在客户，并设计出简单、易用的产品。功能需要易于访问且直观，最重要的是，用户需要用最少的点击次数就能构建出他们想要的三明治。稍后，我们将看到用户如何存储他们的最爱，以及我们如何为用户提供部分构建的三明治以进行自定义，而不是从头开始构建。现在，我们将看看如何对我们的三明治相关对象和类进行分类。
- en: Outlining specifications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定规范
- en: In the previous chapter, we created a simple list of sandwich ingredient objects
    using a factory pattern and connected it to a layout. However, we only represented
    a single type of filling. Before we can create a more sophisticated system, we
    need to plan our data structure, and to do that we need to consider the choices
    we present the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用工厂模式创建了一个简单的三明治配料对象列表，并将其连接到布局中。然而，我们只表示了一种填充类型。在创建更复杂的系统之前，我们需要规划我们的数据结构，为此我们需要考虑我们向用户呈现的选择。
- en: 'Firstly, what options can we offer the user to make the process simple, fun,
    and intuitive? Here is a list of functions a potential user may want from such
    an app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以提供哪些选项来使这个过程简单、有趣且直观？以下是一个潜在用户可能希望从这类应用中获得的功能列表：
- en: Order an off-the-shelf sandwich, with no customization
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订购现成的三明治，无需定制
- en: Customize an off-the-shelf sandwich
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制现成的三明治
- en: Start with some basic ingredients and build from there
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一些基本食材开始并逐步构建
- en: Order or customize a sandwich they have had before
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订购或定制他们之前吃过的三明治
- en: Build a sandwich from scratch
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始制作三明治
- en: Review and edit their sandwich at any time
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时查看并编辑他们的三明治
- en: 'Previously, we created an individual menu for cheeses, but a category for each
    food type may offer a clumsy solution: a user wanting a bacon, lettuce, and tomato
    sandwich may have to visit three separate menus. There are many different ways
    we could solve this problem, and it is largely a matter of personal choice. Here,
    we will try to follow the course we might take when making a sandwich for ourselves,
    which could be described by the following list:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们为奶酪创建了一个单独的菜单，但为每种食品类型提供一个类别可能是一个笨拙的解决方案：想要一个培根、生菜和番茄三明治的用户可能需要访问三个不同的菜单。我们有很多不同的方法可以解决这个问题，这在很大程度上是个人选择的问题。在这里，我们将尝试遵循我们自己制作三明治时可能会采取的过程，可以描述如下列表：
- en: Bread
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面包
- en: Butter
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黄油
- en: Fillings
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内馅
- en: Toppings
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配料
- en: 'By toppings, I mean mayonnaise, pepper, mustard, and so on. We will use these
    categories as the basis for our class structure. It would be nice if they could
    all belong to the same class type, but there are one or two subtle differences
    that forbid that:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的配料是指蛋黄酱、胡椒、芥末等。我们将把这些类别作为我们类结构的基础。如果它们都能属于同一个类类型会很不错，但有一两个细微的差别禁止这样做：
- en: '**Bread**: No one is going to order a sandwich without bread; it wouldn''t
    be a sandwich, and we would be forgiven for thinking that it could be treated
    like any other ingredient. However, we are going to offer the choice of an open
    sandwich, and to complicate things for ourselves, the option of having it toasted.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**面包**：没有人会订购没有面包的三明治；那就不叫三明治了，我们可能会认为它可以像其他任何食材一样处理。然而，我们将提供开放式三明治的选择，并且为了使情况复杂化，还有烤面包的选项。'
- en: '**Butter**: Again, it would be easy to think that adding butter goes without
    saying, but some customers will want a low-fat spread, or even none at all. Fortunately,
    there is a pattern that suits this purpose very well: the decorator pattern.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**黄油**：人们可能会认为添加黄油是理所当然的，但有些顾客可能想要低脂涂抹酱，或者根本不要。幸运的是，有一个非常适合此目的的模式：装饰者模式。'
- en: '**Fillings and toppings**: Although these classes could very easily share identical
    properties and instances if both extend from the same class, we will treat them
    separately as this will make constructing menus far clearer.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**内馅和配料**：尽管如果这两个类都从同一个类扩展而来，它们很容易共享相同的属性和实例，但我们将分别处理它们，因为这样构建菜单会更清晰。'
- en: 'With these specifications in place, we can start to think about how the top-level
    menu will look. We will use a sliding drawer navigation view and offer the following
    options:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些规格到位之后，我们可以开始考虑顶级菜单的外观。我们将使用滑动抽屉导航视图，并提供以下选项：
- en: '![Outlining specifications](img/image_07_001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![概述规格](img/image_07_001.jpg)'
- en: This gives us a rough idea of what we are aiming at. One of the advantages of
    using patterns is that the ease at which they can be modified means we can take
    a more intuitive approach to development, safe in the knowledge that even large-scale
    changes often only require editing a minimum of code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们大致展示了我们的目标。使用模式的一个优点是它们易于修改，这意味着我们可以更直观地处理开发，同时放心地知道即使是大规模的更改通常也只需编辑最少的代码。
- en: Our next step is to select a suitable pattern for the outlined task. We are
    familiar with both factories and builders and how they could both accomplish what
    we want, but there is another creational pattern, the prototype, which is also
    very handy, and although we will not be using it in this situation there will
    be times when we might, and certainly times when you will.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是选择一个适合概述任务的合适模式。我们对工厂和建造者都很熟悉，也知道它们如何实现我们想要的功能，但还有一个创建型模式，即原型模式，也非常方便，尽管在这种情况下我们不会使用它，但将来我们可能会使用，你肯定也会遇到需要使用的时候。
- en: The prototype pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: The prototype design pattern performs similar tasks to other creational patterns,
    such as builders and factories, but it takes a very different approach. Rather
    than rely heavily on a number of hard-coded sub-classes, the prototype, as its
    name suggests, makes copies from an original, vastly reducing the number of sub-classes
    required and any lengthy creation processes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式与其他创建型模式（如构建器和工厂）执行类似任务，但采用的方法截然不同。它不是重度依赖许多硬编码的子类，正如其名，原型从原始对象进行复制，大大减少了所需的子类数量和任何冗长的创建过程。
- en: Setting up a prototype
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置原型
- en: 'The prototype is at its most useful when the creation of an instance is expensive
    in some way. This could be the loading of a large file, a detailed cross-examination
    of a database, or some other computationally expensive operation. Furthermore,
    it allows us to decouple cloned objects from their originals, allowing us to make
    modifications without having to re-instantiate each time. In the following example,
    we will demonstrate this using functions that take some considerable time to calculate
    when first created: the nth prime number and the nth Fibonacci number.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例的创建在某种程度上是昂贵的时，原型最为有用。这可能是加载大文件、详细检查数据库，或是其他计算成本高昂的操作。此外，它允许我们将克隆对象与其原始对象解耦，使我们能够进行修改而无需每次重新实例化。在以下示例中，我们将使用首次创建时计算时间较长的函数来演示这一点：第n个素数和第n个斐波那契数。
- en: 'Viewed diagrammatically, our prototype will look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从图解上看来，我们的原型将如下所示：
- en: '![Setting up a prototype](img/image_07_002.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![设置原型](img/image_07_002.jpg)'
- en: 'We will not need the prototype pattern in our main app as there are very few
    expensive creations. However, it is vitally important in many situations and should
    not be neglected. Follow these steps to apply a prototype pattern:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主应用中，由于昂贵的创建非常少，因此不需要原型模式。然而，在许多情况下它至关重要，不应被忽视。以下是应用原型模式的步骤：
- en: 'We will start with the the following abstract class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从以下抽象类开始：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add this cloneable concrete class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加这个可克隆的具体类：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add another `Sequence` class, for the Fibonacci numbers, like so:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再添加一个`Sequence`类，用于斐波那契数列，如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, create the cache class, like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建缓存类，如下所示：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add three TextViews to your layout, and then add the code to your MainActivity's
    `onCreate()` method.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的布局中添加三个`TextViews`，然后在你的`MainActivity`的`onCreate()`方法中添加代码。
- en: 'Add these lines to the client code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端代码中添加以下几行：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the preceding code creates the pattern but does not demonstrate
    it. Once loaded, the cache can create instant copies of our previously expensive
    output. Furthermore, we can modify the copy, making the prototype very useful
    when we have a complex object and want to modify just one or two properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的代码创建了模式，但并未演示它。一旦加载，缓存就可以创建我们之前昂贵的输出的即时副本。此外，我们可以修改副本，当我们有一个复杂的对象并且只想修改一个或两个属性时，原型非常有用。
- en: Applying the prototype
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用原型
- en: Consider a detailed user profile such as you might find on a social media site.
    Users modify details such as images and text, but the overall structure is the
    same for all profiles, making it an ideal candidate for a prototype pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个在社交媒体网站上可能找到的详细用户资料。用户修改诸如图片和文本等详细信息，但所有资料的整体结构是相同的，这使得它成为原型模式的理想选择。
- en: 'To put this principle into practice, include the following code in your client
    source code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这一原则付诸实践，请在客户端源代码中包含以下代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Applying the prototype](img/image_07_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![应用原型](img/image_07_003.jpg)'
- en: 'The prototype is a very useful pattern in many occasions where we have expensive
    objects to create or when we face a proliferation of sub-classes. However, this
    is not the only pattern that helps reduce excessive sub-classing, and this leads
    us on to another design pattern: the **decorator**.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场合，原型是一个非常实用的模式，尤其是当我们需要创建昂贵的对象或面临子类激增的情况时。然而，这并不是唯一有助于减少过度子类化的模式，这引导我们了解另一个设计模式：**装饰器**。
- en: The decorator design pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器设计模式
- en: Regardless of object creation expense, there are still times when the nature
    of our model will necessitate an unreasonable number of sub-classes, and this
    is where the decorator comes in extremely handy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论对象创建的成本如何，我们的模型性质有时仍会迫使产生不合理数量的子类，这正是装饰器模式极其方便之处。
- en: Take the bread in our sandwich app, for example. We would like to offer several
    types of bread, but in addition, we want to offer the choice of having the bread
    toasted, the sandwich open, and a selection of spreads. By creating toasted and
    open versions for each bread type, the project would very soon become unmanageable.
    The decorator allows us to add functionality and properties to an object during
    runtime without having to make any changes to the original class structure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们三明治应用中的面包为例。我们希望提供几种类型的面包，但除此之外，我们还希望提供选择烤过、开口的三明治以及一系列涂抹酱。为每种面包类型创建烤过和开口版本，项目很快就会变得难以管理。装饰器允许我们在运行时向对象添加功能和属性，而无需对原始类结构进行任何更改。
- en: Setting up a decorator
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置装饰器
- en: One might think that properties such as *toasted* and *open* could be included
    as part of the *bread* class, but this itself can lead to increasingly unwieldy
    code. Say that we want *bread* and *filling* to inherit from the same class, say
    *ingredient*. This would make sense as they have properties in common, such as
    price and calorific value, and we want them both to be displayed through the same
    layout structures. However, properties such as toasted and spread make no sense
    when applied to fillings, and this would lead to redundancy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会认为像*烤过*和*开口*这样的属性可以作为*bread*类的一部分包含，但这本身可能导致代码越来越难以管理。假设我们希望*bread*和*filling*继承自同一个类，比如*ingredient*。这是有道理的，因为它们有共同的属性，比如价格和热量值，我们希望它们都通过相同的布局结构显示。然而，将烤过和涂抹这样的属性应用于填充物是没有意义的，这会导致冗余。
- en: 'The decorator solves both these issues. To see how it is applied, follow these
    steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器解决了这两个问题。要了解如何应用，请按照以下步骤操作：
- en: 'Start by creating this abstract class to represent all breads:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建这个抽象类来表示所有面包开始：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, create concrete instances, like so:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建具体实例，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we need an abstract decorator. It looks like this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个抽象的装饰器，它看起来像这样：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need four extensions of this decorator to represent two types of spread
    and both open and toasted sandwiches. First, the `Butter` decorator:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要四个此类装饰器的扩展来表示两种类型的涂抹酱以及开口和烤过的三明治。首先，是`Butter`装饰器：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only the values returned by the getters differ in the other three classes.
    They are as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他三个类中，只有getter返回的值不同。它们如下：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That is all that is required to set up our decorator pattern. All we need to
    do now is connect it to a working interface of some sort. Later, we will use a
    menu for selecting the bread and then a dialog to add the *decoration*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了装饰器模式的设置。我们现在需要做的就是将其连接到某种工作接口。稍后，我们将使用菜单选择面包，然后使用对话框添加*装饰*。
- en: Applying the decorator
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用装饰器
- en: The user will have to choose between butter and low-fat spread (although a *no
    spread* option could be included by adding another decorator), but can choose
    to have their sandwich both toasted and open.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将需要在黄油和低脂涂抹酱之间做出选择（尽管通过添加另一个装饰器可以包含一个*不涂抹*的选项），但可以选择让三明治既烤过又开口。
- en: 'For now, we will use the debugger to test various combinations by adding lines
    such as the following to the governing activity''s `onCreate()` method. Note how
    the objects are chained:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用调试器通过向管理活动的`onCreate()`方法添加如下几行来测试各种组合。注意对象是如何链式调用的：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should produce outputs like these:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Diagrammatically, our decorator pattern can be expressed like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表上，我们的装饰器模式可以这样表示：
- en: '![Applying the decorator](img/image_07_004.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![应用装饰器](img/image_07_004.jpg)'
- en: The decorator design pattern is an extremely useful development tool and can
    be applied to a multitude of situations. As well as helping us maintain a manageable
    number of concrete classes, we could also have our bread super class inherit from
    the same interface as the filling class and still behave differently.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计模式是一个极其有用的开发工具，可以应用于多种情况。除了帮助我们保持可管理的具体类数量，我们还可以让面包超类从与填充物类相同的接口继承，并仍然表现出不同的行为。
- en: Extending the decorator
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展装饰器
- en: 'It would be quite a simple task to extend the preceding pattern to cater for
    fillings as well. We could create an abstract class called `Fillings`, which would
    be identical to Bread, except for the name, with concrete extensions along the
    lines of this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的模式扩展到填充物同样很简单。我们可以创建一个名为`Fillings`的抽象类，它除了名字与Bread相同，具体扩展如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could even create decorators that were specific for fillings such as ordering
    a double portion. The `FillingDecorator` class would extend from `Filling` but
    otherwise be identical to `BreadDecorator`, and the concrete example would look
    like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以创建针对填充物（如点双份）的特定装饰器。`FillingDecorator`类将从`Filling`扩展而来，但除此之外与`BreadDecorator`相同，具体的例子如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The way that we chained our decorators together to produce a compound string
    is very similar to the way a builder works, and we could indeed use this pattern
    to generate an entire sandwich along with all its trimmings. However, as is often
    the case, there is more than one candidate for this task. As we saw earlier in
    the book, builders and abstract factories are both capable of producing complex
    objects. Before we decide on our model, we need to find the most suitable pattern
    or, better still, a combination of patterns.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将装饰器串联起来生成复合字符串的方式与构造者工作的方式非常相似，实际上我们可以使用这个模式生成整个三明治及其所有配料。然而，通常情况下，这项任务有多个候选者。正如本书前面所看到的，构造者和抽象工厂都能生产复杂对象。在我们决定模型之前，需要找到最适合的模式，或者更好的是，模式的组合。
- en: The builder pattern would seem the most obvious choice, so we will take a look
    at that first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 构造者模式似乎是最明显的选择，因此我们首先来看看这个模式。
- en: A sandwich builder pattern
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三明治构造者模式
- en: The builder pattern is purpose-built for combining simple objects to form one
    complex object, and this forms a perfect analogy of making a sandwich. We encountered
    a generalized builder pattern earlier in the book, but now we need to adapt it
    for a specific function. Furthermore, we will be connecting the pattern to a working
    UI so that a sandwich can be constructed according to user selections rather than
    the set meal demonstrated in previous builder examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 构造者模式专为将简单对象组合成一个复杂对象而设计，这形成了制作三明治的完美类比。在本书前面我们已经遇到了一个通用的构造者模式，但现在我们需要将其适配为一个特定功能。此外，我们还将把模式连接到一个工作用户界面，以便根据用户选择构建三明治，而不是之前示例中的套餐。
- en: Applying the pattern
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用模式
- en: 'To keep the code short and simple, we will only create two concrete classes
    of each ingredient type, and we will use buttons and a text view to display the
    output rather than a recycler view. Simply follow these steps to create our sandwich
    builder pattern:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码简短和简单，我们每种食材类型只创建两个具体类，我们将使用按钮和文本视图来显示输出，而不是回收视图。只需按照以下步骤创建我们的三明治构造者模式：
- en: 'Begin with the following interface:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下接口开始：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create these two abstract implementations of `Ingredient`. They are empty for
    now, but we will need them later:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建这两个`Ingredient`的抽象实现。现在它们是空的，但稍后我们会需要它们：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will need just two concrete examples of each ingredient type. Here is one,
    the `Bagel` class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将只需要每种食材类型的两个具体示例。下面是其中一个，`Bagel`类：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create another `Bread` called `Bun` and two `Filling` classes called `Egg` and
    `Cress`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`Bun`的`Bread`类和两个名为`Egg`和`Cress`的`Filling`类。
- en: Provide these classes with any description and calorific values you like.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这些类提供您喜欢的任何描述和卡路里值。
- en: 'Now we can create the sandwich class itself, like so:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建三明治类本身，如下所示：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The sandwich builder class does not build set meals, as in previous examples,
    but is used to add ingredients as requested. It is as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三明治构造者类不像之前的示例那样构建套餐，而是用于按需添加食材。如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This completes the pattern itself, but before we move on to create the UI, we
    need to address the empty abstract classes `Bread` and `Filling`. They appear
    to be utterly superfluous but there are two reasons why we have done this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了模式本身，但在我们继续创建用户界面之前，需要处理空抽象类`Bread`和`Filling`。它们看似完全多余，但我们之所以这样做有两个原因。
- en: Firstly, by defining their methods, `description()` and `kcal()`, in a common
    interface we can more easily create ingredients that are neither filling or bread
    by implementing the interface itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在公共接口中定义它们的方法`description()`和`kcal()`，我们可以更容易地创建既不是填充物也不是面包的食材，只需实现接口本身即可。
- en: 'To see how, add the following class to the project:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何操作，请将以下类添加到项目中：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This gives us the following class structure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下的类结构：
- en: '![Applying the pattern](img/image_07_005.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![应用模式](img/image_07_005.jpg)'
- en: The second reason for including these abstract classes is more interesting.
    The `BreadDecorator` class in the previous example worked directly with the abstract
    `Bread` class and by maintaining that structure we can easily connect decorators
    to our ingredient types. We will move on to this shortly, but first we are going
    to build a UI to run our sandwich builder on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 包含这些抽象类的第二个原因更有趣。上一个示例中的`BreadDecorator`类直接与抽象的`Bread`类一起工作，并且通过保持该结构，我们可以轻松地将装饰器连接到我们的成分类型。我们很快就会继续这个话题，但首先我们要构建一个
    UI 来运行我们的三明治构建器。
- en: Connecting to a UI
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到 UI
- en: In this demonstration, we have two types of filling and two breads. They can
    select as many or as few fillings as they wish, but only one type of bread, which
    makes the selection a good candidate for the use of **check boxes** and **radio
    buttons** respectively. There is also an option to add salt, and this is the kind
    of binary choice that perfectly suits the **switch widget**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们有两种类型的填充和两种面包。他们可以选择任意多或少的填充，但只能选择一种面包，这使得选择成为使用**复选框**和**单选按钮**的良好候选者。还有一个添加盐的选项，这种二元选择非常适合**开关小部件**。
- en: 'To begin with we need a layout. Here are the steps required:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个布局。以下是所需的步骤：
- en: Begin with a vertical linear layout.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从垂直线性布局开始。
- en: 'Then include the radio button group, like so:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后像这样包括单选按钮组：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, include the check boxes:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包括复选框：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then add the switch:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加开关：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is an inner relative layout containing the following action buttons:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个内部相对布局，包含以下操作按钮：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note the use of `android:onClick="onActionOkClicked"` in the OK button. This
    can be used in lieu of a click listener and identifies the method on the owning
    activity to be called when the view is clicked on. This is a very convenient technique,
    although it does rather blur the lines between model and view and can be prone
    to bugs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 OK 按钮中使用的`android:onClick="onActionOkClicked"`。这可以代替点击监听器，并标识拥有活动中的方法，当点击视图时会被调用。这是一种非常方便的技术，尽管它确实模糊了模型和视图之间的界限，并且可能容易产生错误。
- en: 'Before we add this method, we need to declare and instantiate one or two fields
    and views. Follow these steps to complete the exercise:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加这种方法之前，需要声明并实例化一个或两个字段和视图。按照以下步骤完成练习：
- en: 'Include the following field declarations in the class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中包括以下字段声明：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instantiate the widgets like so:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样实例化小部件：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can add the `onActionOkClicked()` method we declared in the XML layout:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们在 XML 布局中声明的`onActionOkClicked()`方法：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now test this code on a device, and despite the small number of ingredients,
    it should be clear how this works to allow users to build sandwiches of their
    choice:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在设备上测试这段代码，尽管成分数量较少，但应该清楚这是如何让用户构建他们选择的三明治：
- en: '![Connecting to a UI](img/image_07_006.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![连接到 UI](img/image_07_006.jpg)'
- en: Multiple widgets
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 多个小部件
- en: We only need to include more ingredients and a more sophisticated UI to handle
    this. Nevertheless, the principle will remain the same and the same structure
    and logic can be applied.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要包括更多的成分和一个更复杂的 UI 来处理这个问题。尽管如此，原则将保持不变，相同的结构和逻辑可以应用。
- en: Despite the potential, the preceding example lacks the decorative features we
    saw earlier, such as offering toasted varieties and low-fat spread. Fortunately,
    it is a simple task to attach decorators to both our bread and filling classes.
    Before we do so, we will take a quick look at why a builder is not the only candidate
    pattern capable of performing this task.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有潜力，但前面的示例缺少了我们之前看到的装饰性功能，例如提供烤面包品种和低脂涂抹酱。幸运的是，将装饰器附加到我们的面包和填充类是一个简单的任务。在我们这样做之前，我们将快速查看为什么构建器不是唯一能够执行此任务的可候选模式。
- en: Selecting patterns
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择模式
- en: 'Examine the following figure comparing a builder and an abstract factory:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下比较构建器和抽象工厂的图：
- en: '![Selecting patterns](img/image_07_007.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![选择模式](img/image_07_007.jpg)'
- en: Comparison between the builder and abstract factory patterns
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器和抽象工厂模式之间的比较
- en: Despite the differences in approach, there are striking similarities between
    the builder and abstract factory patterns, and they both perform similar functions.
    We could quite easily use abstract factories for this task. Factories are more
    flexible when it comes to adding or modifying products, and are structurally a
    little simpler, but there is one important difference between the two patterns
    that really determines our choice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管方法不同，构建器和抽象工厂模式之间有惊人的相似之处，它们执行类似的功能。我们可以很容易地使用抽象工厂来完成这项任务。在添加或修改产品时，工厂更具灵活性，结构上也稍微简单一些，但两种模式之间有一个重要的区别，这真正决定了我们的选择。
- en: Both factories and builders manufacture objects, but the major difference is
    that factories return their products as each of them are requested. This would
    be like having a sandwich delivered one ingredient at a time. The builder, on
    the other hand, only constructs its output once all the products have been selected,
    and this is far more like the behavior of making and delivering a sandwich. This
    is the reason why the builder pattern provides the best solution in this case.
    With this decision taken, we can stick with the preceding code and get down to
    adding a little extra functionality.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂和构建器都生产对象，但主要区别在于工厂在每次请求时返回其产品。这就像一次送来一个三明治配料。而构建器则在所有产品选择完毕后一次性构建其输出，这更像制作和送达三明治的行为。这就是为什么在这种情况下构建器模式提供最佳解决方案的原因。做出这个决定后，我们可以坚持使用前面的代码，并添加一些额外的功能。
- en: Adding a decorator
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加装饰器
- en: As we know, one of the best ways to add further functionality is with decorator
    patterns. We have already seen how these work, and now we can add one to our simple
    sandwich builder. Individual decorations are almost identical in structure, differing
    only in the values they return, so we need to create only one here, by way of
    example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，增加进一步功能的最佳方式之一是使用装饰器模式。我们已经了解了它们是如何工作的，现在我们可以将一个添加到我们的简单三明治构建器中。单个装饰在结构上几乎相同，只是它们返回的值不同，因此我们只需创建一个作为示例。
- en: Attaching the pattern
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加模式
- en: 'Follow these steps to add the option to offer a toasted sandwich:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤添加提供烤三明治的选项：
- en: 'Open the empty `Bread` class and complete it like so:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开空的`Bread`类，并像这样完成它：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a `BreadDecorator` class like the one found here:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个像这里找到的`BreadDecorator`类：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now add the concrete decorator itself:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加具体的装饰器本身：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Not only does the use of a decorator keep the number of sub-classes we need
    to a minimum, it also serves a perhaps more useful function, in that it allows
    us to include options such as toasted and/or open, which are not ingredients,
    strictly speaking, and this helps keep our classes meaningful.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器不仅可以最小化我们需要创建的子类数量，它还提供了一个也许更有用的功能，即允许我们包含诸如烤制和/或开放等选项，这些严格来说不是配料，这有助于保持我们的类有意义。
- en: It should be clear that we can now add as many such decorations as we like,
    but first there are, of course, one or two changes we need to make to our main
    source code to see our decoration in action.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们现在可以添加任意多的此类装饰，但首先我们需要对主源代码进行一两个更改，以便看到装饰的实际效果。
- en: Connecting the pattern to the UI
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模式连接到UI
- en: 'Edit the main XML layout and Java activity to achieve this by following these
    simple steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤编辑主XML布局和Java活动，以实现这一点：
- en: 'Add the following switch, just below the radio button group:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单选按钮组下面添加以下开关：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open the `MainActivity` class and provide it these two fields:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`类，并提供以下两个字段：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instantiate the widget like so:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化小部件如下：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following method variables to the `onActionOkClicked()` method:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onActionOkClicked()`方法中添加以下方法变量：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now add this code underneath the radio buttons:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单选按钮下面添加这段代码：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, modify the text output code like so:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像这样修改文本输出代码：
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That is all that is needed to add a decorator to our existing pattern and provide
    it as a working part of our UI.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是向现有模式添加装饰器并使其成为我们UI工作部分所需的一切。
- en: '![Connecting the pattern to the UI](img/image_07_008.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![将模式连接到UI](img/image_07_008.jpg)'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that although the filling classes have been refactored here to something
    tastier, the code, however, remains the same. Everything from variables to classes
    and packages can be refactored with **Shift + F6**. This will also rename all
    occurrences, calls, and even getters and setters. To rename an entire project,
    rename the directory in your Android Studio projects folder and then open it from
    the File menu.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然这里将填充类重构为更美味的内容，但代码保持不变。从变量到类和包，都可以使用**Shift + F6**进行重构。这也会重命名所有出现、调用，甚至包括获取器和设置器。要重命名整个项目，只需在Android
    Studio项目文件夹中重命名目录，然后从文件菜单中打开它。
- en: 'As a UML class diagram, we can express this new structure like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为UML类图，我们可以这样表达这个新的结构：
- en: '![Connecting the pattern to the UI](img/image_07_009.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![将模式连接到用户界面](img/image_07_009.jpg)'
- en: This covers the basic processes behind connecting model and view using simple
    design patterns. Our work, however, has left our main activity looking rather
    messy and complicated, and this is something we would like to avoid. It is not
    necessary to implement this here, as this is still a very simple program. However,
    there will be times when client code can become very cluttered with listeners
    and various other callbacks, and it is useful to know how best to square things
    away using a pattern.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了使用简单设计模式连接模型和视图的基本过程。然而，我们的工作使得主活动看起来相当混乱和复杂，这是我们需要避免的。在这里实现这一点并不是必须的，因为这仍然是一个非常简单的程序。但是，有时客户端代码会因监听器和各种回调而变得非常混乱，了解如何最好地使用模式来整理这些内容是很有用的。
- en: 'The facade is the most useful pattern for this kind of thing, and is quick
    and easy to implement. We have come across this pattern before, and implementing
    it here is left as an exercise for the reader. The class structure would look
    something like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类事情，外观模式是最有用的，它快速且易于实现。我们之前已经遇到过这种模式，在这里实现它留给读者作为练习。类结构大致如下：
- en: '![Connecting the pattern to the UI](img/image_07_010.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![将模式连接到用户界面](img/image_07_010.jpg)'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have seen how to combine design patterns to perform complex
    tasks. We created a builder to allow users to construct a sandwich of their choice
    and to customize it with a decorator pattern. We also explored another vital pattern,
    the prototype, and saw how vital it can be whenever we have large files or slow
    processes to contend with.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何结合设计模式来执行复杂任务。我们创建了一个构建器，允许用户构建他们选择的三明治，并通过装饰器模式进行定制。我们还探索了另一个重要的模式——原型模式，并了解了在处理大型文件或缓慢进程时它有多么重要。
- en: As well as delving into the concepts of pattern design, the chapter included
    the more practical aspects of setting, reading, and responding to compound buttons
    such as switches and checkboxes, and this formed a significant step on the way
    to developing more sophisticated systems.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了深入探讨设计模式的概念，本章还包含了更实际的方面，如设置、读取和响应复合按钮（如开关和复选框），这是开发更复杂系统的重要步骤。
- en: In the next chapter, we will look more closely at communicating with the user
    through the use of various Android notification tools, such as the snack bar and
    how services and broadcasts play a part in Android development.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解如何通过各种Android通知工具与用户进行通信，例如小吃栏，以及服务和广播在Android开发中的作用。
