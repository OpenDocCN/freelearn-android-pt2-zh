- en: Chapter 7. Deploying and Testing on Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 在设备上部署和测试
- en: Deploying to devices is both important and somewhat a hassle when you try it
    the first time. Certain issues will only happen on a mobile device, and cannot
    be reproduced in the iOS simulator or Android emulator. You can also test things
    that are only possible on real devices such as GPS, camera, memory limitations,
    or cellular network connectivity. There are also a few common pitfalls that exist
    when developing for Xamarin, which will only surface when testing on a physical
    device.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到设备既重要又有些麻烦，尤其是第一次尝试时。某些问题只会在移动设备上发生，无法在 iOS 仿真器或 Android 仿真器中复现。您还可以测试只有在真实设备上才能实现的功能，如
    GPS、摄像头、内存限制或蜂窝网络连接。在为 Xamarin 开发时，也存在一些常见的陷阱，只有在物理设备上测试时才会显现。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: iOS provisioning
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 配置
- en: Android device settings for debugging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓设备调试设置
- en: The linker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器
- en: Ahead-of-time (AOT) compilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前编译（AOT）
- en: Common memory pitfalls with Xamarin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Xamarin 常见的内存陷阱
- en: Before we begin this chapter, it is important to note that a valid iTunes account
    or iOS Developer Program membership is required to deploy to iOS devices. Feel
    free to go back to [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Xamarin Setup"),
    *Xamarin Setup*, to walk through that process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，需要注意的是，要部署到 iOS 设备，需要一个有效的 iTunes 账户或 iOS 开发者计划会员资格。可以随时回到[第1章](part0015.xhtml#aid-E9OE1
    "第1章. Xamarin 设置")，*Xamarin 设置*，了解该过程。
- en: iOS provisioning
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS 配置
- en: Apple has a strict process for deploying applications to iOS devices. While
    being quite convoluted and sometimes painful for developers, Apple can enable
    a certain level of security by preventing the average user from sideloading potentially
    malicious applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果对将应用程序部署到 iOS 设备有一个严格的过程。尽管对于开发者来说这个过程可能相当复杂和痛苦，但苹果可以通过阻止普通用户侧载可能恶意应用程序来提供一定级别的安全性。
- en: Before we can deploy our application to an iOS device, there are a few things
    we will need to set up in the **iOS Dev Center**. We will begin by creating an
    App ID or bundle ID for your account. This is the primary identifier for any iOS
    application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序部署到 iOS 设备之前，我们将在**iOS 开发中心**设置一些事情。我们将从为您的账户创建一个应用 ID 或捆绑 ID 开始。这是任何
    iOS 应用程序的主要标识符。
- en: 'Begin by navigating to [http://developer.apple.com/account](http://developer.apple.com/account)
    and perform the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时请访问 [http://developer.apple.com/account](http://developer.apple.com/account)
    并执行以下步骤：
- en: Sign in with your developer account.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的开发者账户登录。
- en: Click on **Certificates, IDs, & Profiles** on the right-hand-side navigation.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧导航栏中点击**证书、ID 和配置文件**。
- en: Click on **App IDs**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用 IDs**。
- en: Click on the plus button to add a new iOS App ID.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号按钮添加新的 iOS 应用 ID。
- en: In the **Name** field, enter something meaningful, such as `YourCompanyNameWildcard`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**字段中，输入一些有意义的文字，例如`YourCompanyNameWildcard`。
- en: Select the **Wildcard App ID** radio button.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**通配符应用 ID**单选按钮。
- en: In the **Bundle ID** field, select a reverse domain styled name for your company,
    such as `com.yourcompanyname.*`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**捆绑 ID**字段中，为您的公司选择一个反向域名格式的名称，例如`com.yourcompanyname.*`。
- en: Click on **Continue**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**继续**。
- en: Review the final setting and hit **Submit**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最终设置并点击**提交**。
- en: Leave this webpage open, as we will be using it throughout the chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 保持此网页打开，因为我们在整个章节中都会使用它。
- en: We just registered a wildcard bundle ID for your account; use this as a prefix
    for all future applications you wish to identify with this account. Later, when
    you are preparing to deploy an app to the Apple App Store, you will create an
    **Explicit App ID** such as `com.yourcompanyname.yourapp`. This allows you to
    deploy the specific app to the store, while the wildcard ID is best used for deploying
    to devices for testing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为您的账户注册了一个通配符捆绑 ID；将此作为您希望用此账户标识的所有未来应用程序的前缀。稍后，当您准备将应用程序部署到苹果应用商店时，您将创建一个**显式应用
    ID**，如`com.yourcompanyname.yourapp`。这允许您将特定应用程序部署到商店，而通配符 ID 最好用于将应用程序部署到测试设备。
- en: Next we need to locate the unique identifier on each device you plan to debug
    your application on. Apple requires each device to be registered under your account
    and has a limit of 110 devices per device type per developer (110 iPhones, iPads,
    iPods, Apple TVs, or Apple Watches). The only way to circumvent this requirement
    is to register for the iOS Developer Enterprise Program, which has a $299 yearly
    fee that is separate from the standard $99 developer fee.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要找到你计划调试应用程序的每个设备的唯一标识符。苹果要求每个设备都在你的账户下注册，并且每个开发者每种设备类型最多可注册110个设备（110个iPhone、iPad、iPod、Apple
    TV或Apple Watch）。绕过这一要求的唯一方式是注册iOS开发者企业计划，该计划除了标准的99美元开发者费用外，还需支付299美元的年费。
- en: 'Begin by launching Xcode and perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开始启动Xcode并执行以下步骤：
- en: Click on **Window** | **Devices** in the top menu.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中点击**窗口** | **设备**。
- en: Plug in your target device with a USB cable.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用USB线连接你的目标设备。
- en: On the left-hand-side navigation, you should see your device's name; select
    it.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中，你应该看到你的设备名称；选择它。
- en: Notice the **Identifier** value for your device. Copy it to your clipboard.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意你的设备的**标识符**值。将其复制到剪贴板。
- en: 'The following screenshot shows what your screen should look like with your
    device selected in Xcode:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Xcode中选择你的设备后的屏幕样子：
- en: '![iOS provisioning](img/image00236.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![iOS 配置](img/image00236.jpeg)'
- en: 'Return to [http://developer.apple.com/account](http://developer.apple.com/account)
    (hopefully, it is still open from earlier in the chapter) and perform the following
    steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到[http://developer.apple.com/account](http://developer.apple.com/account)（希望本章早些时候它还保持打开状态），并执行以下步骤：
- en: Click on **Devices | All** on the left-hand-side navigation.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧导航栏中的**设备 | 全部**。
- en: Click on the plus button in the top-right corner of the page.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右上角的加号按钮。
- en: Enter a meaningful name for your device and paste the **Identifier** from your
    clipboard into the **UDID** field.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的设备输入一个有意义的名称，并将剪贴板中的**标识符**粘贴到**UDID**字段中。
- en: Click on **Continue**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**继续**。
- en: Review the information you entered and hit **Register**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你输入的信息并点击**注册**。
- en: Down the road, when your account is fully set up, you can just click on the
    **Use for Development** button in Xcode and skip this second set of steps.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后，当你的账户完全设置好后，你只需在Xcode中点击**用于开发**按钮，就可以跳过这第二个步骤。
- en: 'The following screenshot shows what your device list should look like when
    complete:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了你的设备列表在完成时的样子：
- en: '![iOS provisioning](img/image00237.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![iOS 配置](img/image00237.jpeg)'
- en: Next, we will need to generate a certificate to represent you as the developer
    for your account. Prior to Xcode 5, you had to create a certificate-signing request
    by using the **Keychain** app on your Mac. The newer versions of Xcode make things
    a lot easier by integrating a lot of this process into Xcode.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要生成一个证书，以代表你的账户作为开发者。在Xcode 5之前，你必须使用Mac上的**钥匙串**应用程序创建一个证书签名请求。Xcode的新版本将这一流程集成到Xcode中，使得操作更加简便。
- en: 'Open Xcode and perform the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Xcode并执行以下步骤：
- en: Navigate to **Xcode** | **Preferences** in the menu at the top.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中导航至**Xcode** | **偏好设置**。
- en: Select the **Accounts** tab.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**账户**标签页。
- en: Click on the plus button on the bottom-left and then click on **Add Apple ID**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左下角的加号按钮，然后点击**添加 Apple ID**。
- en: Enter the e-mail and password for your developer account.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你的开发者账户的电子邮件和密码。
- en: Upon creating the account, click on **View Details** on the bottom-right.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建账户后，点击右下角的**查看详情**。
- en: Click on the **Download All** button on the bottom-left.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左下角的**下载全部**按钮。
- en: If this is a new account, Xcode will display a warning that no certificates
    exist yet. Check each box and click on **Request** to generate the certificates.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是一个新账户，Xcode会显示一个警告，提示还没有证书存在。勾选每个框并点击**请求**以生成证书。
- en: Xcode will now automatically create a developer certificate for your account
    and install it into your Mac's keychain.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode现在将自动为你的账户创建一个开发者证书，并将其安装到你的Mac钥匙串中。
- en: 'The following screenshot shows what your screen will look after setting up
    your account:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了设置你的账户后屏幕的样子：
- en: '![iOS provisioning](img/image00238.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![iOS 配置](img/image00238.jpeg)'
- en: Next, we need to create a **provisioning profile**. This is the final file that
    allows applications to be installed on an iOS device. A provisioning profile contains
    an App ID, a list of device IDs, and, finally, a certificate for the developer.
    You must also have the private key of the developer certificate in your Mac's
    keychain to use a provisioning profile.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个**配置文件**。这是允许应用程序安装在 iOS 设备上的最终文件。配置文件包含一个 App ID、一个设备 ID 列表，最后还有开发者的证书。你还需要在
    Mac 的钥匙串中拥有开发者证书的私钥才能使用配置文件。
- en: 'The following are a few types of provisioning profiles:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几种配置文件类型：
- en: '**Development**: This is used for debug or release builds; you will actively
    use this type of profile when your applications are in development.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：这用于调试或发布版本；当你的应用程序处于开发阶段时，你会积极使用这种类型的配置文件。'
- en: '**Ad Hoc**: This is used mainly for release builds; this type of certificate
    is great for beta testing or distribution to a small set of users. You can distribute
    to an unlimited number of users using this method with an enterprise developer
    account.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ad Hoc**：这主要用于发布版本；这种证书非常适合进行 beta 测试或分发给一组小用户。使用这种方法，你可以通过企业开发者账户向无限数量的用户分发。'
- en: '**App Store**: This is used for release builds for submission to the App Store.
    You cannot deploy an app to your device using this certificate; it can only be
    used for store submission.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**App Store**：这用于提交到 App Store 的发布版本。你不能使用此证书将应用程序部署到你的设备；它只能用于商店提交。'
- en: 'Let''s return to [http://developer.apple.com/apple](http://developer.apple.com/apple)
    and create a new provisioning profile by performing the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[http://developer.apple.com/apple](http://developer.apple.com/apple)，通过执行以下步骤创建一个新的配置文件：
- en: Click on **Provisioning Profiles | All** on the left-hand-side navigation.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧导航栏中的**配置文件 | 全部**。
- en: Click on the plus button on the top-right of the page.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右上角的加号按钮。
- en: Select **iOS App Development** and click on **Continue**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**iOS 应用开发**并点击**继续**。
- en: Select your wildcard App ID created earlier in the chapter and click on **Continue**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择本章前面创建的通配符 App ID 并点击**继续**。
- en: Select the certificate we created earlier in the chapter and click on **Continue**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们在本章前面创建的证书并点击**继续**。
- en: Select the devices you want to deploy to and click on **Continue**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要部署到的设备并点击**继续**。
- en: Enter an appropriate **Profile Name**, such as `YourCompanyDev`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个合适的**配置文件名称**，如`YourCompanyDev`。
- en: Click on **Continue** and your provisioning profile will be created.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**继续**，你的配置文件将被创建。
- en: The following screenshot shows the new profile that you will end up with upon
    creation. Don't worry about downloading the file; we'll use Xcode to import the
    final profile.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了你创建后最终会得到的新配置文件。不必担心下载文件；我们将使用 Xcode 导入最终的配置文件。
- en: '![iOS provisioning](img/image00239.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![iOS 配置](img/image00239.jpeg)'
- en: 'To import the provisioning profile, return to Xcode and perform the following
    steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入配置文件，请回到 Xcode 并执行以下步骤：
- en: Navigate to **Xcode** | **Preferences** in the menu at the top of the dialog.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到对话框顶部菜单中的**Xcode** | **偏好设置**。
- en: Select the **Accounts** tab.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**账户**标签。
- en: Select your account and click on **View Details**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的账户并点击**查看详情**。
- en: Click on the **Download All** button on the bottom-left.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左下角的**下载全部**按钮。
- en: After a few seconds, your provisioning profiles will appear.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，你的配置文件将出现。
- en: Xcode should automatically include any provisioning profiles you have created
    on the Apple developer site. Xcode will also create a few profiles on its own.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 应该会自动包含你在 Apple 开发者网站上创建的所有配置文件。Xcode 还会自行创建一些配置文件。
- en: In the latest version of Xamarin Studio, you can view these profiles, but will
    not be able to sync them. Navigate to **Xamarin Studio** | **Preferences** | **Developer
    Accounts** to view the provisioning profiles from Xamarin Studio. You can also
    see Xamarin's documentation on iOS provisioning on their documentation website
    at [http://developer.xamarin.com/guides/ios/getting_started/device_provisioning/](http://developer.xamarin.com/guides/ios/getting_started/device_provisioning/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的 Xamarin Studio 中，你可以查看这些配置文件，但无法同步它们。导航到 **Xamarin Studio** | **偏好设置**
    | **开发者账户**，从 Xamarin Studio 中查看配置文件。你也可以在 Xamarin 的文档网站上查看关于 iOS 配置的文档，网址为[http://developer.xamarin.com/guides/ios/getting_started/device_provisioning/](http://developer.xamarin.com/guides/ios/getting_started/device_provisioning/)。
- en: Android device settings
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓设备设置
- en: Compared to the hassle of deploying your application on iOS devices, Android
    is a breeze. To deploy an application to a device, you merely have to set a few
    settings on the device. This is due to Android's openness in comparison to iOS.
    Android device debugging is turned off for most users, but it can be easily turned
    on by any user that wishes to have a try at writing Android applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与在iOS设备上部署应用程序的麻烦相比，Android就轻松多了。要将应用程序部署到设备上，你只需在设备上设置几个选项。这是由于与iOS相比，Android的开放性。大多数用户的Android设备调试功能是关闭的，但任何希望尝试编写Android应用程序的用户都可以轻松地开启它。
- en: 'Begin by opening the **Settings** application. You may have to locate this
    by looking through all the applications on the device, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开**设置**应用。你可能需要通过查看设备上的所有应用程序来找到它，如下所示：
- en: Scroll down and click on the section labeled **Developer options**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动并点击标有**开发者选项**的部分。
- en: In the action bar at the top, you may have to toggle a switch to the **ON**
    position. This varies on each device.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的操作栏中，你可能需要将一个开关切换到**开启**位置。这个操作在每个设备上都有所不同。
- en: Scroll down and check **USB Debugging**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动并勾选**USB调试**。
- en: A warning confirmation will appear; click on **OK**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个警告确认提示；点击**确定**。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that some newer Android devices have made it a little more difficult for
    the average user to turn on USB debugging. You have to click on the **Developer
    options** item seven times to turn this option on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些较新的Android设备使得普通用户开启USB调试变得更加困难。你需要点击**开发者选项**七次来开启这个选项。
- en: 'The following screenshot shows what your device will look like during the process:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了在过程中你的设备的样子：
- en: '![Android device settings](img/image00240.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Android设备设置](img/image00240.jpeg)'
- en: After enabling this option, all you have to do is plug in your device via USB
    and debug an Android application in Xamarin Studio. You will see your device listed
    in the **Select Device** dialog. Note that if you are on Windows or have a non-standard
    device, you may have to visit your device vendor's website to install drivers.
    Most Samsung and Nexus devices install their drivers automatically. On Android
    4.3 and higher, there is also a confirmation dialog on the device that appears
    before beginning a USB debugging session.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 启用这个选项后，你只需通过USB连接你的设备，并在Xamarin Studio中调试一个Android应用程序。你会在**选择设备**对话框中看到你的设备列表。请注意，如果你使用的是Windows系统，或者你的设备是非标准的，你可能需要访问设备制造商的网站来安装驱动程序。大多数三星和Nexus设备会自动安装它们的驱动程序。在Android
    4.3及更高版本中，在开始USB调试会话之前，设备上还会出现一个确认对话框。
- en: The following screenshot shows what your device will look like for a Samsung
    Galaxy in the **Select Device** dialog. Xamarin Studio will display the model
    number, which is not always a name that you may recognize. You can view this model
    number in your device's settings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了在**选择设备**对话框中三星Galaxy设备的样子。Xamarin Studio将显示型号号码，这并不总是一个你可能认识的名字。你可以在你的设备的设置中查看这个型号号码。
- en: '![Android device settings](img/image00241.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Android设备设置](img/image00241.jpeg)'
- en: Understanding the linker
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解链接器
- en: To keep Xamarin applications small and lightweight for mobile devices, Xamarin
    has created a feature for their compiler called the **linker**. Its main purpose
    is to strip unused code out of the core Mono assemblies (such as `System.dll`)
    and platform-specific assemblies (`Mono.Android.dll` and `Xamarin.iOS.dll`); however,
    it can also give you the same benefits if set up to run on your own assemblies.
    Without running the linker, the entire Mono framework can be around 30 megabytes.
    This is why linking is enabled by default in device builds, which enables you
    to keep your applications small.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Xamarin应用程序在移动设备上保持小型和轻量级，Xamarin为编译器创建了一个名为**链接器**的功能。其主要目的是从核心Mono程序集（如`System.dll`）和特定平台的程序集（`Mono.Android.dll`和`Xamarin.iOS.dll`）中移除未使用的代码；然而，如果设置得当，它也可以为你自己的程序集提供同样的好处。如果不运行链接器，整个Mono框架可能大约有30兆字节。这就是为什么在设备构建中默认启用链接，这样你可以保持应用程序的小巧。
- en: The linker uses static analysis to work through the various code paths in an
    assembly. If it determines that a method or class is never used, it removes the
    unused code from that assembly. This can be a time-consuming process, so builds
    running in the simulator skip this step by default.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器使用静态分析来处理程序集中的各种代码路径。如果它确定一个方法或类从未被使用，它会从该程序集中移除未使用的代码。这个过程可能会很耗时，因此默认情况下，在模拟器中运行的构建会跳过这一步。
- en: 'Xamarin applications have the following three main settings for the linker:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin应用程序有以下三个主要的链接器设置：
- en: '**Don''t Link**: In this, the linker compilation step is skipped. This is best
    for builds running in the simulator or if you need to diagnose a potential issue
    with the linker.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不链接**：在这种情况下，链接器编译步骤将被跳过。这对于在模拟器中运行的构建或如果你需要诊断链接器的潜在问题最为合适。'
- en: '**Link SDK Assemblies Only**: In this, the linker will only be run on the core
    Mono assemblies such as `System.dll`, `System.Core.dll` and `System.Xml.dll`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅链接 SDK 程序集**：在这种情况下，链接器只会在核心 Mono 程序集上运行，如`System.dll`、`System.Core.dll`和`System.Xml.dll`。'
- en: '**Link All Assemblies**: In this, the linker is run against all the assemblies
    in your application, which includes any class libraries or third party assemblies
    you are using.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接所有程序集**：在这种情况下，链接器将对应用程序中的所有程序集运行，包括你正在使用的任何类库或第三方程序集。'
- en: These settings can be found in the **Project** options of any Xamarin.iOS or
    Xamarin.Android application. These settings are generally not present in class
    libraries as they are generally associated with an iOS or Android application
    that will be deployed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置可以在任何 Xamarin.iOS 或 Xamarin.Android 应用程序的项目选项中找到。这些设置通常不会出现在类库中，因为它们通常与将要部署的
    iOS 或 Android 应用程序相关联。
- en: The linker can also cause potential issues at runtime as there are cases in
    which its analysis determines incorrectly that a piece of code is unused. This
    can happen if you are using features in the `System.Reflection` namespace instead
    of accessing the method or property directly. This is one reason why it is important
    for you to test your application on physical devices, as linking is enabled for
    device builds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器还可能在运行时引起潜在问题，因为有时它的分析会错误地确定一段代码未被使用。如果你在`System.Reflection`命名空间中使用特性而不是直接访问方法或属性，这可能会发生。这就是为什么在物理设备上测试你的应用程序很重要，因为设备构建启用了链接。
- en: 'To demonstrate this issue, let''s look at the following code example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，让我们看一下以下代码示例：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding code will work fine using the options for **Don''t Link**
    or **Link SDK Assemblies Only**. However, if you try to run this when using **Link
    All Assemblies**, you will get an exception similar to the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码，在**不链接**或**仅链接 SDK 程序集**的选项下将正常工作。然而，如果你在**链接所有程序集**的选项下尝试运行此代码，你会遇到类似以下的异常：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the `Name` property's getter was never used directly from code, the linker
    stripped it from the assembly. This caused the reflection code to fail at runtime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从未直接从代码中使用`Name`属性的 getter，链接器将其从程序集中剥离。这导致反射代码在运行时失败。
- en: Even though potential issues can arise in your code, the option of **Link All
    Assemblies** is still quite useful. There are a few optimizations that can only
    be performed in this mode, and Xamarin can reduce your application to the smallest
    possible size. If performance or a tiny download size is the requirement for your
    application, give this option a try. However, thorough testing should be performed
    to verify that no problems are caused by linking your assemblies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的代码可能会出现潜在问题，但**链接所有程序集**的选项仍然非常有用。有些优化只能在此模式下执行，Xamarin 可以将你的应用程序缩减到尽可能小的尺寸。如果你的应用程序需要性能或极小的下载尺寸，请尝试这个选项。然而，应进行彻底测试，以确保链接程序集不会引起任何问题。
- en: To resolve issues in your code, Xamarin has included a complete set of workarounds
    to prevent specific parts of your code from being stripped away.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决代码中的问题，Xamarin 提供了一套完整的解决方案，以防止代码中的特定部分被剥离。
- en: 'Some of the options include the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些选项：
- en: Mark class members with `[Preserve]`; this will force the linker to include
    the attributed method, field, or property.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[Preserve]`标记类成员；这将强制链接器包含带属性的方法、字段或属性。
- en: Mark an entire class with `[Preserve(AllMembers=true)]`; this will preserve
    all code within the class.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[Preserve(AllMembers=true)]`标记整个类；这将保留类中的所有代码。
- en: 'Mark an entire assembly with `[assembly: Preserve]`; this is an assembly-level
    attribute that will preserve all code contained within it.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`[assembly: Preserve]`标记整个程序集；这是一个程序集级别的属性，将保留其中的所有代码。'
- en: Skip an entire assembly by modifying **Additional mtouch arguments** in your
    project options; use `--linkskip=System` to skip an entire assembly. This can
    be used on assemblies that you do not have the source code for.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改项目选项中的**附加 mtouch 参数**来跳过整个程序集；使用`--linkskip=System`来跳过整个程序集。这可以用于那些你没有源代码的程序集。
- en: Custom linking via an XML file, which is the best option when you need to skip
    linking on a specific class or method that you do not have the source code for.
    Use `--xml=YourFile.xml` in **Additional mtouch arguments**.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 XML 文件自定义链接，当你需要跳过没有源代码的具体类或方法的链接时，这是最佳选择。在**附加 mtouch 参数**中使用 `--xml=YourFile.xml`。
- en: 'The following is a sample XML file demonstrating custom linking:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示自定义链接的示例 XML 文件：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Custom linking is the most complicated option and is usually the last resort.
    Luckily, most Xamarin applications will not have to work around many linker issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义链接是选项中最复杂的，通常是最后的选择。幸运的是，大多数 Xamarin 应用程序不需要解决许多链接问题。
- en: Understanding AOT compilation
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 AOT 编译
- en: The runtime behind Mono and .NET on Windows is based on a **just-in-time** (**JIT**)
    compiler. C# and other .NET languages are compiled into **Microsoft intermediate
    language** (**MSIL**). At runtime, MSIL is compiled into a native code (just in
    time) to run on whatever type of architecture is running your application. Xamarin.Android
    follows this exact pattern. However, due to Apple's restrictions on dynamically
    generated code, a **just-in-time (JIT)** compiler is not allowed on iOS.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 上的 Mono 和 .NET 运行时基于**即时编译**（**JIT**）器。C# 和其他 .NET 语言被编译成**微软中间语言**（**MSIL**）。在运行时，MSIL
    会即时编译成本地代码（正好在需要时），以在任何类型的架构上运行你的应用程序。Xamarin.Android 遵循这一确切模式。然而，由于苹果对动态生成代码的限制，iOS
    上不允许使用**即时编译（JIT）**器。
- en: To work around this restriction, Xamarin has developed a new option called **ahead-of-time**
    (**AOT**) compilation, in which your C# code is compiled into native, platform-specific
    machine code. In addition to making .NET possible on iOS, AOT has other benefits,
    such as a shorter startup time and potentially better performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这一限制，Xamarin 开发了一个名为**提前编译**（**AOT**）的新选项，你的 C# 代码被编译成特定于平台的本地机器代码。除了使 .NET
    在 iOS 上成为可能之外，AOT 还具有其他好处，例如启动时间更短，性能可能更好。
- en: AOT also has some limitations that are generally related to C# generics. To
    compile an assembly ahead of time, the compiler will need to run some static analysis
    against your code to determine the type information. Generics throw a wrench into
    this situation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 也有一些与 C# 泛型相关的限制。为了提前编译程序集，编译器需要对代码进行一些静态分析，以确定类型信息。泛型在这种情况下会带来一些问题。
- en: 'There are a few cases that are not supported with AOT, but are completely valid
    in C#. The first is a generic interface, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 不支持一些在 C# 中完全有效的情况。首先是泛型接口，如下所示：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The compiler cannot determine the classes that may implement this interface
    ahead of time, especially when multiple assemblies are involved. The second limitation
    is related to the first: you cannot override virtual methods that contain generic
    parameters or return values.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器无法提前确定可能实现此接口的类，特别是涉及多个程序集时。第二个限制与第一个相关：你不能覆盖包含泛型参数或返回值的虚拟方法。
- en: 'The following is a simple example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的例子：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, the static analysis of the compiler cannot determine which classes may
    override this method at compile time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，编译器的静态分析无法在编译时确定哪些类可能会覆盖这个方法。
- en: 'Another limitation is that you cannot use `DllImport` in a generic class, as
    shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是，你不能在泛型类中使用 `DllImport`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are not familiar with the language feature, `DllImport` is a way to call
    native C/C++ methods from C#. Using them inside generic classes is not supported.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉这个语言特性，`DllImport` 是一种从 C# 调用本地 C/C++ 方法的方式。在泛型类中使用它们是不支持的。
- en: These limitations are another good reason why testing on devices is important,
    since the preceding code will work fine on other platforms that can run C# code,
    but not Xamarin.iOS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制是为什么在设备上进行测试很重要的另一个原因，因为上述代码在其他可以运行 C# 代码的平台上是没问题的，但在 Xamarin.iOS 上不行。
- en: Avoiding common memory pitfalls
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免常见的内存陷阱
- en: Memory on mobile devices is certainly not an unlimited commodity. Because of
    this, memory usage in your application can be much more important than on desktop
    applications. At times, you might find the need to use a memory profiler or improve
    your code to use memory more efficiently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上的内存绝对不是无限的资源。因此，你的应用程序中的内存使用可能比桌面应用程序更重要。有时，你可能会发现需要使用内存分析器或改进代码以更有效地使用内存。
- en: 'The following are the most common memory pitfalls:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的内存陷阱：
- en: The **garbage collector** (**GC**) is unable to collect large objects fast enough
    to keep up with your application
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收器**（**GC**）无法快速回收大对象以跟上应用程序的步伐'
- en: Your code inadvertently causes a memory leak
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码无意中导致了内存泄漏
- en: A C# object is garbage collected, but is later attempted to be used by native
    code
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个C#对象被垃圾回收，但后来被本地代码尝试使用
- en: 'Let''s take a look at the first problem, where the GC cannot keep up. Let''s
    say we have a Xamarin.iOS application with a button for sharing an image on Twitter,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个问题，即GC无法跟上。假设我们有一个Xamarin.iOS应用程序，其中有一个用于在Twitter上分享图像的按钮，如下所示：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's assume the image is a 10 MB image from the user's camera roll. If
    the user clicks on the button and cancels the Twitter post rapidly, there could
    be the possibility of your application running out of memory. iOS will commonly
    force apps using too much memory to close, and you don't want users to experience
    this with your app.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设图像是用户相册中的10MB图像。如果用户点击按钮并迅速取消Twitter帖子，应用程序可能会出现内存不足的情况。iOS通常会强制关闭使用过多内存的应用程序，你不会希望用户在使用你的应用时遇到这种情况。
- en: 'The best solution is to call `Dispose` on the image when you are finished with
    it, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是在使用完图像后调用其`Dispose`方法，如下所示：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An even better approach would be to take advantage of the C# `using` statement,
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法将是利用C#的`using`语句，如下所示：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The C# `using` statement will automatically call `Dispose` in a `try-finally`
    block, so the object will get disposed of even if an exception is thrown. I recommend
    taking advantage of the `using` statement for any `IDisposable` class, where possible.
    It is not always necessary for small objects, such as `NSString`, but it is always
    a good idea for larger, more heavyweight `UIKit` objects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`using`语句会自动在`try-finally`块中调用`Dispose`，因此即使抛出异常，对象也将被释放。我建议尽可能对任何`IDisposable`类使用`using`语句。对于小对象如`NSString`来说，这并不总是必要的，但对于更大、更重的`UIKit`对象来说，这总是一个好主意。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A similar situation can occur in Android with the `Bitmap` class. Although slightly
    different, it is best to call the `Dispose` method on this class, the same as
    you would with `UIImage` on iOS.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，与`Bitmap`类也可能发生类似情况。虽然略有不同，但最好是在此类上调用`Dispose`方法，这与你在iOS上对`UIImage`的处理是一样的。
- en: A memory leak is the next potential issue. C#, being a managed, garbage-collected
    language, prevents a lot of memory leaks, but not all of them. The most common
    leaks in C# are caused by events.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是下一个潜在问题。C#作为一种管理的、垃圾回收的语言，防止了很多内存泄漏，但并非全部。C#中最常见的泄漏是由事件引起的。
- en: 'Let''s assume we have a static class with an event, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个带有事件的静态类，如下所示：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s say we need to subscribe to the event from an iOS controller, as
    follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要从iOS控制器中订阅事件，如下所示：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The problem here is that the static class will hold a reference to the controller
    until the event is unsubscribed. This is a situation that a lot of developers
    might miss. To fix this issue on iOS, I would subscribe to the event in `ViewWillAppear`
    and unsubscribe from `ViewWillDisappear`. On Android, use `OnStart` and `OnStop`,
    or `OnPause` and `OnResume`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，静态类将持有对控制器的引用，直到事件被取消订阅。这是许多开发者可能会忽略的情况。为了在iOS上解决这个问题，我会在`ViewWillAppear`中订阅事件，并在`ViewWillDisappear`中取消订阅。在Android上，使用`OnStart`和`OnStop`，或者`OnPause`和`OnResume`。
- en: 'You would correctly implement this event, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你会正确实现此事件，如下所示：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, an event is not a surefire cause of a memory leak. Subscribing to the
    `TouchUpInside` event on a button inside the `ViewDidLoad` method, for example,
    is just fine. Since the button lives in memory just as long as the controller,
    everything can be garbage collected without causing a problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事件并不是内存泄漏的必然原因。例如，在`ViewDidLoad`方法中订阅按钮的`TouchUpInside`事件是没问题的。由于按钮与控制器在内存中的生命周期相同，一切都可以被垃圾回收，而不会造成问题。
- en: For the final issue, the garbage collector can sometimes remove a C# object;
    later, an Objective-C object attempts to access it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个问题，垃圾回收器有时可能会移除一个C#对象；后来，一个Objective-C对象尝试访问它。
- en: 'The following is an example of adding a button to `UITableViewCell`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个添加按钮到`UITableViewCell`的例子：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We add the built-in info button as an accessory view to the cell. The problem
    here is that the button will be garbage collected, but its Objective-C counterpart
    will remain in use as it is displayed on the screen. If you click on the button
    after a period of time, you will get a crash that looks something like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将内置的信息按钮作为单元格的附件视图添加。这里的问题是，按钮将被垃圾回收，但其Objective-C对应物仍将在屏幕上显示时被使用。如果过了一段时间后点击按钮，你可能会遇到类似下面的崩溃情况：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is not the most descriptive error message, but, in general, you know that
    something went wrong in the native Objective-C code. To resolve the issue, create
    a custom subclass of `UITableViewCell` and create a dedicated member variable
    for the button, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最描述性的错误消息，但一般来说，你知道原生Objective-C代码中出了问题。要解决这个问题，请创建一个`UITableViewCell`的自定义子类，并为按钮创建一个专用的成员变量，如下所示：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, your `GetCell` implementation will look something like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的`GetCell`实现看起来可能如下所示：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the button is not a local variable, it will no longer be garbage collected
    sooner than needed. A crash is avoided, and, in some ways, this code is a bit
    cleaner. Similar situations can happen on Android with the interaction between
    C# and Java; however, it is less likely, since both are garbage-collected languages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按钮不是一个局部变量，它不会比需要的时候更早地被垃圾回收。这样可以避免崩溃，并且在某些方面，这段代码看起来更整洁。在Android上，C#与Java之间的交互也可能出现类似情况；然而，由于两者都是垃圾回收语言，这种情况不太可能发生。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括
- en: In this chapter, we started out learning the process of setting up iOS provision
    profiles to deploy to iOS devices. Next, we looked at the required device settings
    for deploying your application to an Android device. We discovered the Xamarin
    linker, and how it can make your applications smaller and more performant. We
    went over the various settings for resolving problems caused by your code and
    the linker, and we explained AOT compilation on iOS and the limitations that occur.
    Finally, we covered the most common memory pitfalls that can occur with Xamarin
    applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习设置iOS供应配置文件的过程，以便部署到iOS设备。接下来，我们查看了将应用程序部署到Android设备所需的设备设置。我们发现了Xamarin链接器，以及它如何使应用程序变得更小、性能更好。我们讨论了解决由你的代码和链接器引起问题的各种设置，并解释了iOS上的AOT编译及其出现的限制。最后，我们涵盖了Xamarin应用程序可能遇到的常见内存陷阱。
- en: Testing your Xamarin application on mobile devices is important for various
    reasons. Some bugs are only displayed on the device due to the platform limitations
    that Xamarin has to work around. Your PC is much more powerful, so you will see
    different performance using the simulator compared to on a physical device. In
    the next chapter, we'll create a real web service using Windows Azure to drive
    our XamChat application. We will use a feature called Azure Mobile Services, and
    implement push notifications on iOS and Android.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上测试Xamarin应用程序有多种原因。由于Xamarin必须绕过的平台限制，一些错误只能在设备上显示。你的电脑强大得多，因此在使用模拟器与物理设备上的性能表现会有所不同。在下一章中，我们将使用Windows
    Azure创建一个真实的网络服务来驱动我们的XamChat应用程序。我们将使用一个名为Azure Mobile Services的功能，并在iOS和Android上实现推送通知。
