- en: Chapter 1. AndEngine Game Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. AndEngine游戏结构
- en: 'In this chapter, we''re going to take a look at the main components needed
    for structuring a game in **AndEngine**. The topics include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解构建**AndEngine**游戏中所需的主要组成部分。主题包括：
- en: Know the life cycle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解生命周期
- en: Choosing our engine type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择我们的引擎类型
- en: Selecting a resolution policy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择分辨率策略
- en: Creating object factories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象工厂
- en: Creating the game manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏管理器
- en: Introducing sounds and music
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入声音和音乐
- en: Working with different types of textures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同类型的纹理
- en: Applying texture options
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用纹理选项
- en: Using AndEngine font resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AndEngine字体资源
- en: Creating the resource manager
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建资源管理器
- en: Saving and loading game data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载游戏数据
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: The most appealing aspect of AndEngine is the incredible ease of creating games.
    The possibility of designing and coding a game in a matter of weeks after first
    looking into AndEngine is not too farfetched, but that's not to say it will be
    a perfect game. The coding process can be a tedious task when we do not understand
    how the engine works. It is a good idea to understand the main building blocks
    of AndEngine and the game structure in order to create precise, organized, and
    expandable projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine最吸引人的方面是创建游戏的极大便捷性。在首次接触AndEngine后，在几周内设计和编码一个游戏并非遥不可及，但这并不意味着它将是一个完美的游戏。如果我们不理解引擎的工作原理，编码过程可能会很繁琐。为了创建精确、有序且可扩展的项目，了解AndEngine的主要构建块和游戏结构是一个好主意。
- en: In this chapter, we're going to go over a few of the most necessary components
    of AndEngine and general game programming. We're going to take a look at some
    classes that will aid us in quickly and efficiently creating a foundation for
    all sorts of games. Additionally, we'll cover some of the differences between
    resources and object types, which play the biggest role in shaping the overall
    look and feel of our games. It is encouraged to keep tabs on this chapter as reference
    if needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍AndEngine和一般游戏编程中最必要的几个组成部分。我们将查看一些类，这些类将帮助我们快速高效地创建各种游戏的基础。此外，我们还将介绍资源和对象类型之间的区别，这些区别在塑造游戏的整体外观和感觉方面起着最重要的作用。如果需要，建议将本章作为参考资料保存。
- en: Know the life cycle
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解生命周期
- en: It is important to understand the order of operations when it comes to the initialization
    of our games. The basic needs for a game include creating the engine, loading
    the game's resources, and setting up the initial screen and settings. This is
    all it takes in order to create the foundation for an AndEngine game. However,
    if we plan on more diversity within our games, it is wise to get to know the full
    life cycle included in AndEngine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化游戏时，了解操作的顺序是很重要的。游戏的基本需求包括创建引擎、加载游戏资源、以及设置初始屏幕和设置。这就是创建AndEngine游戏基础所需的一切。但是，如果我们计划在游戏中实现更多多样性，那么了解AndEngine中包含的完整生命周期是明智的。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please refer to the class named `PacktRecipesActivity` in the code bundle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`PacktRecipesActivity`的类。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The AndEngine life cycle includes a few methods that we are responsible for
    defining directly. These methods include creating the `EngineOptions` object,
    creating the `Scene` object, and populating the scene with child entities. These
    methods are called in the following order:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine生命周期包括我们直接负责定义的几个方法。这些方法包括创建`EngineOptions`对象，创建`Scene`对象，以及用子实体填充场景。这些方法的调用顺序如下：
- en: 'Define the `onCreateEngineOptions()` method:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`onCreateEngineOptions()`方法：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the `onCreateResources()` method:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`onCreateResources()`方法：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the `onCreateScene()` method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`onCreateScene()`方法：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define the `onPopulateScene()` method:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`onPopulateScene()`方法：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The code found in this recipe's class is the foundation for any AndEngine game.
    We've set up a main activity class which serves as the entry point into our application.
    The activity contains the four main methods included in AndEngine's activity life
    cycle that we are responsible for, beginning with creating the `EngineOptions`
    options, creating the resources, creating the scene, and populating the scene.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱类中找到的代码是任何AndEngine游戏的基础。我们设置了一个主活动类，作为进入我们应用程序的入口点。活动包含AndEngine活动生命周期中我们负责的四个主要方法，从创建`EngineOptions`选项开始，创建资源，创建场景，以及填充场景。
- en: In the first step, we are overriding the Engine's `onCreateEngineOptions()`
    method. Inside this method, our main focus is to instantiate our `Camera` object
    as well as our `EngineOptions` object. These two object's constructors allow us
    to define the display properties of our application. Additionally, we've disabled
    the screen from automatically turning off during application inactivity via the
    `engineOptions.setWakeLockOptions(WakeLockOptions.SCREEN_ON)` method call.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们覆盖了引擎的`onCreateEngineOptions()`方法。在这个方法内部，我们主要关注实例化`Camera`对象和`EngineOptions`对象。这两个对象的构造函数允许我们定义应用程序的显示属性。此外，通过调用`engineOptions.setWakeLockOptions(WakeLockOptions.SCREEN_ON)`方法，我们阻止了在应用程序不活动期间屏幕自动关闭。
- en: In step two, we continue to override the `onCreateResources()` method, which
    gives us a specified method for creating and setting up any resources needed within
    our game. These resources may include textures, sounds and music, and fonts. In
    this step and the following two, we are required to make a call to the respective
    method callbacks in order to proceed through the application's life cycle. For
    the `onCreateResources()` method, we must call `pOnCreateResourcesCallback.onCreateResourcesFinished()`,
    which should be included at the end of the method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们继续覆盖`onCreateResources()`方法，该方法为我们提供了一个特定方法，用于创建和设置游戏所需的所有资源。这些资源可能包括纹理、声音和音乐以及字体。在这一步和接下来的两步中，我们需要调用相应的方法回调，以继续应用程序的生命周期。对于`onCreateResources()`方法，我们必须在方法的最后包含调用`pOnCreateResourcesCallback.onCreateResourcesFinished()`。
- en: Step three involves instantiating and setting up the `Scene` object. Setting
    up the Scene can be as simple as displayed in this recipe, or for more complex
    projects, it may include setting up touch event listeners, update handlers, and
    more. Once we've finished setting up the Scene, we must make a call to the `pOnCreateSceneCallback.onCreateSceneFinished(mScene)`
    method, passing our newly created `mScene` object to the Engine to be displayed
    on the device.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步涉及实例化和设置`Scene`对象。设置场景可以像本食谱中显示的那么简单，或者对于更复杂的项目，它可能包括设置触摸事件监听器、更新处理器等。完成场景设置后，我们必须调用`pOnCreateSceneCallback.onCreateSceneFinished(mScene)`方法，将我们新创建的`mScene`对象传递给引擎，以便在设备上显示。
- en: The final step to take care of includes defining the `onPopulateScene()` method.
    This method is in place specifically for attaching child entities to the Scene.
    As with the previous two steps, we must make a call to `pOnPopulateSceneCallback.onPopulateSceneFinished()`
    in order to proceed with the remaining AndEngine life cycle calls.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要处理的步骤包括定义`onPopulateScene()`方法。此方法专门用于将子实体附加到场景。与之前的两个步骤一样，我们必须调用`pOnPopulateSceneCallback.onPopulateSceneFinished()`以继续剩余的AndEngine生命周期调用。
- en: In the following list, we will cover the life cycle methods in the order they
    are called from the start up of an activity to the time it is terminated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们将按照从活动启动到终止时调用的顺序介绍生命周期方法。
- en: 'The life cycle calls during launch are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 启动期间的生命周期调用如下：
- en: '`onCreate`: This method is the Android SDK''s native application entry point.
    In AndEngine development, this method simply calls the `onCreateEngineOptions()`
    method in our `BaseGameActivity` class then applies the returned options to the
    game engine.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate`：此方法是Android SDK的原生应用程序入口点。在AndEngine开发中，此方法只需调用我们`BaseGameActivity`类中的`onCreateEngineOptions()`方法，然后将返回的选项应用到游戏引擎中。'
- en: '`onResume`: This is another Android SDK native method. Here, we simply acquire
    the wake lock settings from our `EngineOptions` object and proceed to call the
    `onResume()` method for the engine''s `RenderSurfaceView` object.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume`：这是Android SDK的另一个原生方法。在这里，我们从`EngineOptions`对象获取唤醒锁设置，然后为引擎的`RenderSurfaceView`对象调用`onResume()`方法。'
- en: '`onSurfaceCreated`: This method will either call `onCreateGame()`during the
    initial startup process of our activity or register a Boolean variable as `true`
    for resource reloading if the activity had previously been deployed.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceCreated`：此方法将在我们活动的初始启动过程中调用`onCreateGame()`，或者如果活动之前已经部署，则将布尔变量注册为`true`以重新加载资源。'
- en: '`onReloadResources`: This method reloads our game resources if our application
    is brought back into focus from minimization. This method is not called on the
    initial execution of an application.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onReloadResources`：如果我们的应用程序从最小化状态恢复到焦点状态，此方法将重新加载游戏资源。在应用程序首次执行时不会调用此方法。'
- en: '`onCreateGame`: This is in place to handle the order of execution of the next
    three callbacks in the AndEngine life cycle.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateGame`：这是为了处理 AndEngine 生命周期中接下来三个回调的执行顺序。'
- en: '`onCreateResources`: This method allows us to declare and define our application''s
    initial resources needed during the launch of our activity. These resources include,
    but are not limited to, textures, sounds and music, and fonts.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateResources`：这个方法允许我们声明和定义在启动活动时应用所需的最初资源。这些资源包括但不限于纹理、声音和音乐以及字体。'
- en: '`onCreateScene`: Here, we handle the initialization of our activity''s Scene
    object. It is possible to attach entities to the Scene within this method, but
    for the sake of keeping things organized, it''s usually best to attach entities
    within `onPopulateScene()`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateScene`：在这里，我们处理活动场景对象的初始化。在这个方法中可以附加实体到场景，但为了保持组织性，通常最好在`onPopulateScene()`中附加实体。'
- en: '`onPopulateScene`: In the `onPopuplateScene()` method of the life cycle we
    are just about finished setting up the scene, though there are still a few life
    cycle calls which will be handled automatically by the Engine. This method should
    be used to define the visual result of the Scene when our application first starts
    up. Note that the Scene is already created and applied to the Engine at this point.
    It is possible in some cases to see the entities being attached to the Scene if
    there is no loading screen or splash screen in place and if there are a large
    number of entities to attach.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPopulateScene`：在生命周期中的`onPopulateScene()`方法里，我们几乎完成了场景的设置，尽管还有一些生命周期调用会由引擎自动处理。这个方法应该用来定义应用首次启动时场景的视觉结果。注意，此时场景已经被创建并应用到引擎中。如果此时没有加载屏幕或启动画面，并且有许多实体需要附加到场景中，那么在某些情况下可能会看到实体被附加到场景上。'
- en: '`onGameCreated`: It signals that the `onCreateGame()` sequence has finished,
    reloadinresources if necessary, otherwise doing nothing. Reloading resources depends
    on the Boolean variable briefly mentioned in the `onSurfaceCreated` method five
    life cycle calls back.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onGameCreated`：这表明`onCreateGame()`序列已经完成，如有必要，重新加载资源，否则什么都不做。是否重新加载资源取决于在五个生命周期调用之前的`onSurfaceCreated`方法中简要提到的布尔变量。'
- en: '`onSurfaceChanged`: This method is called every time our application''s orientation
    changes from landscape to portrait mode or vice versa.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceChanged`：每次应用的方向从横屏模式变为竖屏模式，或者从竖屏模式变为横屏模式时，都会调用这个方法。'
- en: '`onResumeGame`: Here we have the final method call which takes place during
    an activity''s startup cycle. If our activity reaches this point without any problems,
    the engine''s `start()` method is called, bringing the game''s update thread to
    life.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResumeGame`：这是在活动启动周期中最后一个调用的方法。如果我们的活动在没有问题的情况下到达这一点，将调用引擎的`start()`方法，使游戏的更新线程活跃起来。'
- en: 'The life cycle calls during minimzation/termination are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化/终止过程中的生命周期调用如下：
- en: '`onPause`: The first method call when an activity is minimized or terminated.
    This is the native android pause method which calls the pause method for the `RenderSurfaceView`
    objects and reverts the wake lock settings appled by the game engine.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause`：活动最小化或结束时首先调用的方法。这是原生安卓的暂停方法，它调用`RenderSurfaceView`对象的暂停方法，并恢复游戏引擎应用的唤醒锁设置。'
- en: '`onPauseGame`: Next, AndEngine''s implementation of `onPause()` which simply
    calls the `stop()` method on the Engine, causing all of the Engine''s update handlers
    to halt along with the update thread.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPauseGame`：接下来，AndEngine 的`onPause()`实现，它只是简单地在引擎上调用`stop()`方法，导致引擎的所有更新处理器以及更新线程停止。'
- en: '`onDestroy`: In the `onDestroy()` method, AndEngine clears all graphical resources
    contained within `ArrayList` objects held by the Engine''s manager classes. These
    managers include the `VertexBufferObjectManager` class, the `FontManager` class,
    the `ShaderProgramManager` class, and finally the `TextureManager` class.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroy`：在`onDestroy()`方法中，AndEngine 会清除由引擎管理类持有的`ArrayList`对象中包含的所有图形资源。这些管理类包括`VertexBufferObjectManager`类、`FontManager`类、`ShaderProgramManager`类，以及最后的`TextureManager`类。'
- en: '`onDestroyResources`: This method name may be a little misleading since we''ve
    already unloaded the majority of resources in `onDestroy()`. What this method
    really does is release all of the sound and music objects stored within the respective
    managers by calling their `releaseAll()` methods.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroyResources`：这个方法名称可能有些误导，因为我们已经在`onDestroy()`中卸载了大部分资源。这个方法真正的作用是，通过调用相应管理器的`releaseAll()`方法，释放所有存储在其中的声音和音乐对象。'
- en: '`onGameDestroyed`: Finally, we reach the last method call required during a
    full AndEngine life cycle. Not a whole lot of action takes place in this method.
    AndEngine simply sets an `mGameCreated` Boolean variable used in the Engine to
    `false`, which stats that the activity is no longer running.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onGameDestroyed`：最后，我们到达在整个AndEngine生命周期中需要调用的最后一个方法。在这个方法中没有太多动作发生。AndEngine只是将用于Engine的`mGameCreated`布尔变量设置为`false`，表示活动不再运行。'
- en: 'In the following image, we can see what the life cycle looks like in action
    when the game is created, minimized, or destroyed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图片中，我们可以看到当创建游戏、最小化或销毁游戏时，生命周期的实际表现：
- en: '![How it works…](img/8987OS_01_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/8987OS_01_01.jpg)'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the asynchronous nature of the AndEngine life cycle, it is possible for
    some methods to be executed multiple times during a single startup instance. The
    occurrence of these events varies between devices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AndEngine生命周期的异步性质，在单个启动实例期间可能会多次执行某些方法。这些事件的发生在设备之间是不同的。
- en: There's more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In the previous section of this recipe, we covered the main `BaseGameActivity`
    class. The following classes can be used as alternatives to the `BaseGameActivity`
    class, each providing their own slight differences.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的前一部分中，我们已经介绍了主要的`BaseGameActivity`类。以下类可以作为`BaseGameActivity`类的替代品，每个类都有自己的一些细微差别。
- en: The LayoutGameActivity class
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`LayoutGameActivity`类'
- en: The `LayoutGameActivity` class is a useful activity class that allows us to
    incorporate the AndEngine scene-graph view into an ordinary Android application.
    On the other hand, with this class we are also able to include native Android
    SDK views, such as buttons, seek bars, spinners, additional layouts, or any other
    view into our game. However, the most popular reason for using this sort of activity
    is to allow easy implementation of advertisments into games for a means to gain
    revenue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutGameActivity`类是一个有用的活动类，它允许我们将AndEngine场景图视图集成到普通的Android应用程序中。另一方面，使用这个类，我们还可以将原生的Android
    SDK视图，如按钮、滑动条、下拉列表、附加布局或其他任何视图包含到我们的游戏中。然而，使用这种活动最流行的原因是便于在游戏中实现广告，作为一种获取收益的手段。'
- en: There are a few additional steps for setting up a `LayoutGameActivity` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为`LayoutGameActivity`类设置需要几个额外的步骤。
- en: 'Add the following line to the project''s default layout XML file. This file
    is usually called `main.xml`. The following code snippet adds the AndEngine `RenderSurfaceView`
    class to our layout file. This is theview that will display our game on the device:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的默认布局XML文件中添加以下行。这个文件通常称为`main.xml`。以下代码段将AndEngine `RenderSurfaceView`类添加到我们的布局文件中。这是将在设备上显示我们游戏的视图：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second and final additional step for this activity type is to reference
    the layout XML file and `RenderSurfaceView` in step one, in the `LayoutGameActivity`
    overridden methods. The following code is assuming the layout file is called `main.xml`
    in the `res/layout/` folder; in which case they can be copied/pasted into our
    `LayoutGameActivity` class after step one has been completed:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种活动类型的第二个也是最后一个额外步骤是在第一步中引用布局XML文件和`RenderSurfaceView`，在`LayoutGameActivity`重写方法中。以下代码假设布局文件在`res/layout/`文件夹中称为`main.xml`；在这种情况下，可以在完成第一步后将其复制/粘贴到我们的`LayoutGameActivity`类中：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The SimpleBaseGameActivity and SimpleLayoutGameActivity classes
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SimpleBaseGameActivity`和`SimpleLayoutGameActivity`类'
- en: The `SimpleBaseGameActivity` and the `SimpleLayoutGameActivity` classes, as
    suggested, make the overridden life cycle methods somewhat easier to deal with.
    They do not require us to override the `onPopulateScene()` method and on top of
    that, we are not required to make calls to the method callbacks when we are finished
    defining the overridden methods. With these activity types, we can simply add
    the unimplemented life cycle methods and AndEngine will handle the callbacks for
    us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如建议的那样，`SimpleBaseGameActivity`和`SimpleLayoutGameActivity`类使重写生命周期方法变得更容易处理。它们不要求我们重写`onPopulateScene()`方法，而且，在我们定义完重写的方法后，我们也不需要调用方法回调。使用这些活动类型，我们可以简单地添加未实现的生命周期方法，AndEngine会为我们处理回调。
- en: The SimpleAsyncGameActivity class
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SimpleAsyncGameActivity`类'
- en: 'The final game activity class we will talk about is the `SimpleAsyncGameActivity`
    class. This class includes three alternative life cycle methods called `onCreateResourcesAsync()`,
    `onCreateSceneAsync()`, and `onPopulateSceneAsync()` along with the usual `onCreateEngineOptions()`
    method. The main difference between this activity and others is that it provides
    us with loading bars for each of the "Async" methods. The following snippet shows
    how we can increment the loading bar in the event of a texture being loaded:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个游戏活动类是`SimpleAsyncGameActivity`类。这个类包括三个可选的生命周期方法：`onCreateResourcesAsync()`、`onCreateSceneAsync()`和`onPopulateSceneAsync()`，以及通常的`onCreateEngineOptions()`方法。这个活动与其他活动的主要区别在于，它为每个"Async"方法提供了加载进度条。以下代码片段展示了当纹理加载时我们如何增加加载进度条：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.PacktPub.com](http://www.PacktPub.com)的账户中下载你所购买的所有Packt图书的示例代码文件。如果你在其他地方购买了这本书，可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)注册，我们会将文件直接通过电子邮件发送给你。
- en: Choosing our engine type
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择我们的引擎类型
- en: Before we start programming our game, it is a good idea to come up with the
    performance needs of the game. AndEngine includes a few different types of engines
    we can choose to use, each with their own benefits. The benefits,of course, depend
    on the type of game we plan to create.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编程游戏之前，最好先确定游戏所需的性能需求。AndEngine包含几种不同类型的引擎供我们选择使用，每种都有其自身的优势。当然，这些优势取决于我们计划创建的游戏类型。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Carry out the *Know the life cycle* recipe in this chapter to get a basic AndEngine
    project set up in our IDE, then continue on to the *How to do it...* section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本章中的*了解生命周期*食谱，以在我们的IDE中设置一个基本的AndEngine项目，然后继续到*如何操作…*部分。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In order for us to properly define a specific `Engine` object for our game
    to use, we must override the `onCreateEngine()` method, which is part of AndEngine''s
    startup process. Add the following code to any base AndEngine activity in order
    to handle the Engine''s creation manually:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地为我们的游戏定义一个特定的`Engine`对象，我们必须重写`onCreateEngine()`方法，这是AndEngine启动过程的一部分。在任意基础的AndEngine活动中添加以下代码，以手动处理引擎的创建：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The following is an overview of the various `Engine` objects available in AndEngine,
    as well as a brief code snippet displaying how to set up each of the `Engine`
    objects:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是AndEngine中可用的各种`Engine`对象的概览，以及一个简短的代码片段，展示如何设置每个`Engine`对象：
- en: '`Engine`: First and foremost, we have the ordinary `Engine` object. The `Engine`
    object is not ideal for most game development as it has absolutely no limitations
    in regards to frames per second. On two separate devices, it is very likely that
    you will notice differences in the speed of the game. One way to think of this
    is if two separate devices are watching a video which was started at the same
    time, the faster device is likely to finish the video first rather than both finishing
    at the same time. For this reason, noticeable issues can arise in devices which
    might not run as fast, especially when physics are a big part of the game. There
    are no extra steps involved in incorporating this type of engine into our game.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine`：首先，我们有一个普通的`Engine`对象。对于大多数游戏开发来说，`Engine`对象并不理想，因为它在每秒帧数上没有任何限制。在两个不同的设备上，你很可能会注意到游戏速度的差异。一个思考方式是，如果两个不同的设备同时开始观看同一个视频，较快的设备可能会先完成视频观看，而不是同时完成。因此，在运行较慢的设备上可能会出现明显的问题，尤其是在物理是游戏重要部分的情况下。将这种类型的引擎集成到我们的游戏中不需要额外的步骤。'
- en: '`FixedStepEngine`: The second type of engine we have at our disposal is the
    `FixedStepEngine`. This is the ideal engine used in game development as it forces
    the game loop to update at a constant speed regardless of the device. This is
    done by updating the game based on the time passed rather than the device''s ability
    to execute code faster. `FixedStepEngine` requires us to pass the `EngineOptions`
    object, as well as an `int` value, in that order. The `int` value defines the
    number of steps per second that the engine will be forced to run at. The following
    code creates an engine that will run at a constant `60` steps per second:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedStepEngine`：我们可用的第二种引擎是`FixedStepEngine`。这是游戏开发中理想的引擎，因为它强制游戏循环以恒定速度更新，而与设备无关。这是通过根据经过的时间更新游戏，而不是根据设备执行代码的能力来实现的。`FixedStepEngine`要求我们按顺序传递`EngineOptions`对象和一个`int`值。这个`int`值定义了每秒引擎将强制运行的步数。以下代码创建了一个以恒定`60`步每秒运行的引擎：'
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`LimitedFPSEngine`: The `LimitedFPSEngine` engine allows us to set a limit
    on the frames per second that the Engine will run at. This will cause the Engine
    to do some internal calculations, and if the difference between the preferred
    FPS is greater than the current FPS that the Engine is achieving, the Engine will
    wait a fraction of a second before proceeding with the next update. `LimitedFPSEngine`
    requires two parameters in the constructor, including the `EngineOptions` object
    and an `int` value specifying the maximum frames per second. The following code
    creates an engine that will run at a maximum of 60 frames per second:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LimitedFPSEngine`：`LimitedFPSEngine`引擎允许我们设置引擎运行的每秒帧数限制。这将导致引擎进行一些内部计算，如果首选FPS与引擎当前实现的FPS之间的差值大于预设值，引擎将会等待一小段时间后再进行下一次更新。`LimitedFPSEngine`在构造函数中需要两个参数，包括`EngineOptions`对象和一个指定最大每秒帧数的`int`值。以下代码创建了一个最大以60帧每秒运行的引擎：'
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`SingleSceneSplitScreenEngine` and `DoubleSceneSplitScreenEngine`: The `SingleSceneSplitScreenEngine`
    engine and `DoubleSceneSplitScreenEngine` engine allow us to create a game with
    two separate cameras, either with a single scene, most generally used for single
    player games, or two scenes for multiplayer games on a single device. These are
    just examples, however, but these two engine''s can have a wide range of uses,
    including mini-maps, multiple perspectives, menu systems, and much more. See [Chapter
    4](ch04.html "Chapter 4. Working with Cameras"), *Creating a Split-screen Game*,
    for more specific details on setting up these types of `Engine` object.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleSceneSplitScreenEngine`和`DoubleSceneSplitScreenEngine`：`SingleSceneSplitScreenEngine`引擎和`DoubleSceneSplitScreenEngine`引擎允许我们创建带有两个独立摄像头的游戏，可以是单个场景，通常用于单人游戏，也可以是两个场景，用于单个设备上的多人游戏。这些只是示例，然而，这两个引擎可以具有广泛的应用，包括迷你地图、多重视角、菜单系统等等。更多关于设置这些类型`Engine`对象的详细信息，请参见[第4章](ch04.html
    "第4章. 使用摄像头")，*创建分屏游戏*。'
- en: Selecting a resolution policy
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择分辨率策略
- en: Choosing a resolution policy can be a sensitive topic, especially since we're
    dealing with a platform which currently runs on devices ranging from 3-inch displays
    up to 10.1-inch for the most part. Generally developers and users alike prefer
    that a game takes up the full width and height of the device's display, but in
    some cases our resolution policy may need to be carefully selected in order to
    properly display our scenes as we—the developer—see fit. In this recipe, we're
    going to discuss the various resolution policies included in AndEngine, which
    will help us decide which policy might best fit our application's needs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 选择分辨率策略可能是一个敏感的话题，特别是考虑到我们正在处理的平台目前主要运行在从3英寸显示屏到10.1英寸的设备上。通常，开发者和用户都希望游戏能够占据设备显示的完整宽度和高度，但在某些情况下，我们可能需要仔细选择分辨率策略，以便按照我们开发者的意愿正确显示场景。在本节中，我们将讨论AndEngine中包含的各种分辨率策略，这将帮助我们决定哪种策略可能最适合我们应用程序的需求。
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The resolution policy that we choose to adhere to must be included as a parameter
    in the `EngineOptions` constructor which is created in the `onCreateEngineOptions()`
    method of AndEngine''s life cycle. The following code creates our `EngineOptions`
    object using the `FillResolutionPolicy` class, which will be explained later in
    the chapter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择遵循的分辨率策略必须作为参数包含在`EngineOptions`构造函数中，该函数是在AndEngine生命周期中的`onCreateEngineOptions()`方法里创建的。以下代码使用`FillResolutionPolicy`类创建我们的`EngineOptions`对象，这一部分将在本章后面进行解释：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can select a different resolution policy by simply passing another variation
    of the resolution policy classes to this constructor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需向构造函数传递另一个分辨率策略类变体，就可以选择不同的分辨率策略。
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: 'The following is an overview of AndEngine''s `BaseResolutionPolicy` subtypes.
    These policies are used to specify how AndEngine will handle our application''s
    display width and height based on various factors:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是AndEngine的`BaseResolutionPolicy`子类型的概述。这些策略用于指定AndEngine如何根据各种因素处理应用程序的显示宽度和高度：
- en: '`FillResolutionPolicy`: The `FillResolutionPolicy` class is the typical resolution
    policy if we simply want our application to take up the full width and height
    of the display. While this policy allows our application to run in true full screen
    mode, it may cause some noticeable stretching in order for our scene to take up
    the full available dimensions of the display. We can select this resolution policy
    by simply including `new FillResolutionPolicy()` as our resolution policy parameter
    in the `EngineOptions` constructor.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FillResolutionPolicy`：如果我们只是希望应用程序占据显示器的全部宽度和高度，`FillResolutionPolicy`类是典型的分辨率策略。虽然此策略允许应用程序以真正的全屏模式运行，但它可能会导致场景为了占据显示器的全部可用尺寸而在某些部分产生明显的拉伸。我们只需在`EngineOptions`构造函数中的分辨率策略参数中包含`new
    FillResolutionPolicy()`，即可选择此分辨率策略。'
- en: '`FixedResolutionPolicy`: The `FixedResolutionPolicy` class allows us to apply
    a fixed display size for our application, regardless of the size of the device''s
    display or `Camera` object dimensions. This policy can be passed to `EngineOptions`
    via `new FixedResolutionPolicy(pWidth, pHeight)`, where `pWidth` defines the final
    width that the application''s view will cover, and `pHeight` defines the final
    height that the application''s view will cover. For example, if we pass a width
    of `800` and a height of `480` to this policy-types constructor, on a tablet with
    a resolution of 1280 x 752, we''d be left with an empty black area since there
    will be no compensation between the resolution policy and the actual display size.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedResolutionPolicy`：`FixedResolutionPolicy`类允许我们为应用程序应用固定的显示尺寸，无论设备显示尺寸或`Camera`对象尺寸如何。此策略可以通过`new
    FixedResolutionPolicy(pWidth, pHeight)`传递给`EngineOptions`，其中`pWidth`定义了应用程序视图将覆盖的最终宽度，而`pHeight`定义了应用程序视图将覆盖的最终高度。例如，如果我们向此策略类型的构造函数传递800的宽度和480的高度，在一个分辨率为1280
    x 752的平板电脑上，由于分辨率策略与实际显示尺寸之间没有补偿，我们将得到一个空白黑色区域。'
- en: '`RatioResolutionPolicy`: The `RatioResolutionPolicy` class is the best choice
    for resolution policies if we need to obtain the maximum display size without
    causing any distortion of sprites. On the other hand, due to the wide range of
    Android devices spanning many display sizes, it is possible that some devices
    may see "black bars" either on the top and bottom, or left and right sides of
    the display. This resolution policy''s constructor can be passed either a `float`
    value, which defines a preferred ratio value for the display dimensions, or a
    width and a height parameter from which a ratio value will be extracted by dividing
    the width by the height. For example, `new RatioResolutionPolicy(1.6f)` to define
    a ratio, or `new RatioResolutionPolicy(mCameraWidth, mCameraHeight)`, assuming
    `mCameraWidth` and `mCameraHeight` are the defined `Camera` object dimensions.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RatioResolutionPolicy`：如果需要在不扭曲精灵的情况下获得最大显示尺寸，`RatioResolutionPolicy`类是最佳的分辨率策略选择。另一方面，由于Android设备范围广泛，涵盖了许多显示尺寸，某些设备可能会在显示的顶部和底部，或左右两侧看到“黑边”。此分辨率策略的构造函数可以传递一个`float`值，用于定义显示尺寸的首选比率值，或者传递宽度和高度参数，从中通过宽度除以高度来提取比率值。例如，`new
    RatioResolutionPolicy(1.6f)`来定义一个比率，或者`new RatioResolutionPolicy(mCameraWidth,
    mCameraHeight)`，假设`mCameraWidth`和`mCameraHeight`是定义的`Camera`对象尺寸。'
- en: '`RelativeResolutionPolicy`: This is the final resolution policy. This policy
    allows us to apply scaling, either larger or smaller, to the overall application
    view based on a scaling factor with `1f` being the default value. We can apply
    general scaling to the view with the constructor—`new RelativeResolutionPolicy(1.5f)`—which
    will increase the scale of both the width and height by `1.5` times, or we can
    specify individual width and height scales, for example, `new RelativeResolutionPolicy(1.5f,
    0.5f)`. One thing to note with this policy is that we must be careful with the
    scaling factors, as scaling too large will cause an application to close without
    warning. Try to keep the scaling factor to less than `1.8f`; otherwise make sure
    to do extensive testing on various devices.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeResolutionPolicy`：这是最终的分辨率策略。该策略允许我们根据缩放因子对整个应用程序视图进行放大或缩小，`1f`是默认值。我们可以使用构造函数对视图应用一般缩放——`new
    RelativeResolutionPolicy(1.5f)`——这将使宽度和高度都增加`1.5`倍；或者我们可以指定单独的宽度和高度缩放比例，例如，`new
    RelativeResolutionPolicy(1.5f, 0.5f)`。需要注意的是，在使用此策略时，我们必须小心缩放因子，因为过大的缩放会导致应用程序在无警告的情况下关闭。尽量保持缩放因子小于`1.8f`；否则，请确保在各种设备上进行大量测试。'
- en: Creating object factories
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象工厂
- en: Object factories are a useful design pattern used in all sorts of areas in programming.
    In game development specifically, a factory might be used to spawn enemy objects,
    spawn bullet objects, particle effects, item objects, and much more. In fact,
    AndEngine even uses the factory pattern when we create sounds, music, textures,
    and fonts, among other things. In this recipe, we'll find out how we can create
    an object factory and discuss how we can use them to provide simplicity in object
    creation within our own projects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对象工厂是在编程的各个领域中都有使用的有用设计模式。特别是在游戏开发中，工厂可能被用来生成敌人对象、生成子弹对象、粒子效果、物品对象等等。实际上，AndEngine在创建声音、音乐、纹理和字体等时也使用了工厂模式。在这个示例中，我们将了解如何创建一个对象工厂，并讨论如何在我们自己的项目中使用它们来简化对象创建。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the class named `ObjectFactory` in the code bundle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`ObjectFactory`的类。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we're using the `ObjectFactory` class as a way for us to easily
    create and return subtypes of the `BaseObject` class. However, in a real-world
    project, the factory would not normally contain inner classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`ObjectFactory`类作为我们轻松创建和返回`BaseObject`类子类型的方式。然而，在实际项目中，工厂通常不会包含内部类。
- en: 'Before we create our object factory, we should create our base class as well
    as at least a couple subtypes extending the base class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建对象工厂之前，我们应该创建我们的基类以及至少几个扩展基类的子类型：
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we''ve got a base class with any number of subtypes, we can now start
    to consider implementing the factory design pattern. The `ObjectFactory` class
    contains the methods which will handle creating and returning objects of types
    `LargeObject` and `SmallObject` in this case:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们拥有一个带有任意数量的子类型的基类，我们现在可以开始考虑实现工厂设计模式。`ObjectFactory`类包含处理创建并返回类型为`LargeObject`和`SmallObject`对象的方法：
- en: '[PRE12]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是…
- en: In the first step of this recipe, we are creating a `BaseObject` class. This
    class includes two member variables called `mX` and `mY`, which we can imagine
    would define the position on the device's display if we are dealing with AndEngine
    entities. Once we've got our base class set up, we can start creating subtypes
    of the base class. The `BaseObject` class in this recipe has two inner classes
    which extend it, one named `LargeObject` and the other, `SmallObject`. The object
    factory's job is to determine which subtype of the base class that we need to
    create, as well as define the object's properties, or `mX` and `mY` member variables
    in this instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的第一步中，我们创建了一个`BaseObject`类。这个类包括两个成员变量`mX`和`mY`，如果我们处理的是AndEngine实体，可以想象它们将定义设备显示上的位置。一旦我们设置好了基类，就可以开始创建基类的子类型。这个示例中的`BaseObject`类有两个内部类扩展它，一个名为`LargeObject`，另一个名为`SmallObject`。对象工厂的工作是确定我们需要创建的基类的哪个子类型，以及定义对象的属性，或者在这个实例中是`mX`和`mY`成员变量。
- en: In the second step, we are taking a look at the `ObjectFactory` code. This class
    should contain any and all variations for object creation relating to the specific
    object-types that the factory deals with. In this case, the two separate objects
    simply require an `mX` and `mY` variable to be defined. In a real-world situation,
    we may find it helpful to create a `SpriteFactory` class. This class might contain
    a few different methods for creating ordinary sprites, button sprites, or tiled
    sprites, via `SpriteFactory.createSprite()`, `SpriteFactory.createButtonSprite()`,
    and `SpriteFactory.createTiledSprite()`. On top of that, each of these methods
    would probably require parameters that define the position, scale, texture region,
    color, and more. The most important aspect to this class is that its methods return
    a new subtype of an object as this is the whole purpose behind the factory class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们将查看`ObjectFactory`代码。这个类应该包含与工厂处理的具体对象类型相关的任何对象创建的变化。在这种情况下，两个独立的对象仅需要一个定义了`mX`和`mY`变量的变量。在现实世界中，我们可能会发现创建一个`SpriteFactory`类很有帮助。这个类可能包含几种不同的方法，用于通过`SpriteFactory.createSprite()`、`SpriteFactory.createButtonSprite()`和`SpriteFactory.createTiledSprite()`创建普通精灵、按钮精灵或平铺精灵。此外，这些方法可能还需要定义位置、缩放、纹理区域、颜色等参数。这个类最重要的方面是它的方法返回一个对象的新子类型，因为这是工厂类背后的整个目的。
- en: Creating the game manager
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏管理器
- en: The game manager is an important part of most games. A game manager is a class
    that should contain data relating to gameplay; including, but not limited to keeping
    track of score, credits/currency, player health, and other general gameplay information.
    In this topic, we're going to take a look at a game manager class to gain an understanding
    of how they work into our game structure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏管理器是大多数游戏的重要组成部分。游戏管理器是一个类，应该包含与游戏玩法相关的数据；包括但不限于跟踪分数、信用/货币、玩家健康和其他一般游戏信息。在本主题中，我们将研究一个游戏管理器类，以了解它们如何融入我们的游戏结构。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please refer to the class named `GameManager` in the code bundle.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`GameManager`的类。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The game manager we''re going to introduce will be following the singleton
    design pattern. This means that we will only create a single instance of the class
    throughout the entire application life cycle and we can access its methods across
    our entire project. Follow these steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的游戏管理器将遵循单例设计模式。这意味着在整个应用程序生命周期中，我们只创建类的单个实例，并且可以在整个项目中访问其方法。按照以下步骤操作：
- en: 'Create the game manager singleton:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建游戏管理器单例：
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the member variables with corresponding getters and setters which should
    keep track of gameplay data:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建成员变量以及相应的获取器和设置器，以跟踪游戏数据：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a reset method that will revert all data back to their initial values:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个重置方法，将所有数据恢复到它们的初始值：
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Depending on the type of game being created, the game manager is bound to have
    different tasks. This recipe's `GameManager` class is meant to resemble that of
    a certain emotional bird franchise. We can see that the tasks involved in this
    particular `GameManager` class are limited, but as gameplay becomes more complex,
    the game manager will often grow as it has more info to keep track of.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据创建的游戏类型，游戏管理器肯定有不同的任务。这个示例的`GameManager`类旨在模仿某个情感鸟品牌的类。我们可以看到，这个特定`GameManager`类中的任务有限，但随着游戏玩法的复杂化，游戏管理器通常会增长，因为它需要跟踪更多信息。
- en: In the first step for this recipe, we're setting up the `GameManager` class
    as a singleton. The singleton is a design pattern that is meant to ensure that
    there is only one static instance of this class that will be instantiated throughout
    the entire application's life cycle. Being static, this will allow us to make
    calls to the game manager's methods on a global level, meaning we can reach its
    methods from any class in our project without having to create a new `GameManager`
    class. In order to retrieve the `GameManager` class' instance, we can call `GameManager.getInstance()`
    in any of our project's classes. Doing so will assign a new `GameManager` class
    to `INSTANCE`, if the `GameManager` class has not yet been referenced. The `INSTANCE`
    object will then be returned, allowing us to make calls to the `GameManager` class'
    data-modifying methods, for example, `GameManager.getInstance().getCurrentScore()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的第一步中，我们将`GameManager`类设置为单例模式。单例是一种设计模式，旨在确保整个应用程序生命周期中只存在一个静态的此类实例。由于其静态特性，我们可以全局调用游戏管理器的方法，这意味着我们可以在项目中任何类中访问其方法，而无需创建新的`GameManager`类。为了获取`GameManager`类的实例，我们可以在项目的任何类中调用`GameManager.getInstance()`。这样做将会在`GameManager`类尚未被引用的情况下，为其分配一个新的`GameManager`类给`INSTANCE`。然后返回`INSTANCE`对象，这样我们就可以调用`GameManager`类中的数据修改方法，例如`GameManager.getInstance().getCurrentScore()`。
- en: In step two, we create the getter and setter methods that will be used to modify
    and obtain the data being stored in the `GameManager` class. The `GameManager`
    class in this recipe contains three `int` values that are used to keep track of
    important gameplay data; `mCurrentScore`, `mBirdCount`, and `mEnemyCount`. Each
    of these variables have their own corresponding getters and setters that allow
    us to easily make modifications to the game data. During gameplay, if an enemy
    happened to be destroyed then we could call `GameManager.getInstance().decrementEnemyCount()`
    along with `GameManager.getInstance().incrementScore(pValue)`, where `pValue`
    would likely be provided by the enemy object being destroyed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们创建了用于修改和获取存储在`GameManager`类中的数据的getter和setter方法。这个配方中的`GameManager`类包含三个`int`值，用于跟踪重要的游戏数据：`mCurrentScore`（当前得分）、`mBirdCount`（鸟类计数）和`mEnemyCount`（敌人计数）。这些变量各自都有对应的getter和setter，使我们能够轻松地修改游戏数据。在游戏过程中，如果有一个敌人被摧毁，我们可以调用`GameManager.getInstance().decrementEnemyCount()`以及`GameManager.getInstance().incrementScore(pValue)`，其中`pValue`可能由被摧毁的敌人对象提供。
- en: The final step involved in setting up this game manager is to provide a reset
    method for game data. Since we are working with a singleton, whether we move from
    gameplay to the main menu, to the shop, or any other scene, our `GameManager`
    class' data will not automatically revert back to default values. This means that
    any time a level is reset, we must reset the game manager's data as well. In the
    `GameManager` class, we've set up a method called `resetGame()`, whose job is
    to simply revert data back to original values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个游戏管理器的最后一步是提供一个重置游戏数据的方法。由于我们使用的是单例模式，无论我们是从小游戏转到主菜单、商店还是其他任何场景，`GameManager`类的数据都不会自动恢复到默认值。这意味着每次重置关卡时，我们也必须重置游戏管理器的数据。在`GameManager`类中，我们设置了一个名为`resetGame()`的方法，其作用是简单地将数据恢复到原始值。
- en: When starting a new level, we can call `GameManager.getInstance().resetGame()`
    in order to quickly revert all data back to the initial values. However, this
    is a general `GameManager` class and it is entirely up to the developer which
    data should be reset pending level reset or level loading. If the `GameManager`
    class is storing credit/currency data, it might be wise not to reset that particular
    variable back to default for use in a shop, for example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新关卡时，我们可以调用`GameManager.getInstance().resetGame()`以快速将所有数据恢复到初始值。然而，这是一个通用的`GameManager`类，具体哪些数据应该在关卡重置或加载时重置完全由开发者决定。如果`GameManager`类存储了信用/货币数据，例如在商店中使用时，最好不要将这个特定变量重置回默认值。
- en: Introducing sounds and music
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入声音和音乐。
- en: Sound and music plays a big role in gameplay for the user. If used properly,
    they can give a game the extra edge it needs to allow the player to become fully
    immersed while playing. On the other hand, they can also cause annoyance and disapproval
    if used incorrectly. In this recipe, we're going to jump into the subject of `Sound`
    and `Music` objects in AndEngine, covering the "how-to's" of loading them through
    to modifying their rates and more.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 声音和音乐在游戏玩法中对用户起着重要作用。如果使用得当，它们可以给游戏带来额外的优势，让玩家在玩游戏时能够完全沉浸其中。另一方面，如果使用不当，它们也可能引起烦恼和不满。在这个配方中，我们将深入探讨
    AndEngine 中的`Sound`和`Music`对象，涵盖从加载它们到修改它们的速率等内容。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Complete the *Know the life cycle* recipe given in this chapter, so that we've
    got a basic AndEngine project set up in our IDE. Additionally, we should create
    a new subfolder in our project's `assets/` folder. Name this folder as `sfx` and
    add a sound file named `sound.mp3` and another named `music.mp3`. Once this is
    done, continue on to the *How to do it...* section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章提供的*了解生命周期*配方，以便我们在 IDE 中设置一个基本的 AndEngine 项目。此外，我们应在项目的`assets/`文件夹中创建一个新的子文件夹。将此文件夹命名为`sfx`，并添加一个名为`sound.mp3`的声音文件，以及另一个名为`music.mp3`的文件。完成这些操作后，继续阅读*如何操作…*部分。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Perform the following steps to set up a game to use the `Sound` and `Music`
    objects. Note that `Sound` objects are meant for sound effects, such as explosions,
    collisions, or other short audio playback events. The `Music` objects are meant
    for long audio playback events such as looping menu music or game music.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，设置游戏以使用`Sound`和`Music`对象。请注意，`Sound`对象用于声音效果，例如爆炸、碰撞或其他短音频播放事件。而`Music`对象用于长时间音频播放事件，如循环菜单音乐或游戏音乐。
- en: 'The first step involves making sure that our `Engine` object recognizes that
    we plan to use `Sound` and `Music` objects in our game. Add the following lines
    in the `onCreateEngineOptions()` method of our activity''s life cycle after the
    `EngineOptions` object has been created:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确保我们的`Engine`对象认识到我们计划在游戏中使用`Sound`和`Music`对象。在创建`EngineOptions`对象之后，在我们的活动生命周期的`onCreateEngineOptions()`方法中添加以下几行：
- en: '[PRE16]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In step two, we will set our asset paths for the sound and music factories,
    then load the `Sound` and `Music` objects. `Sound` and `Music` objects are resources,
    so as you may have guessed, the following code can be dropped into the `onCreateResources()`
    method of our activity''s life cycle:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们将为声音和音乐工厂设置资源路径，然后加载`Sound`和`Music`对象。`Sound`和`Music`对象是资源，所以你可能已经猜到，以下代码可以放入我们活动生命周期的`onCreateResources()`方法中：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the `Sound` objects are loaded into the `SoundManager` class, we can play
    them as we see fit by calling `play()` on them, be it during a collision, button
    click, or otherwise:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`Sound`对象被加载到`SoundManager`类中，我们就可以根据需要通过调用`play()`来播放它们，无论是碰撞时、按钮点击还是其他情况：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Music` objects should be handled in a different manner to `Sound` objects.
    In cases where our `Music` object should loop continuously throughout the game,
    which is in most cases, we handle all `play()` and `pause()` methods within the
    activity life cycle:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Music`对象应该与`Sound`对象以不同的方式处理。在大多数情况下，如果我们的`Music`对象应该在游戏中持续循环，我们应在活动生命周期内处理所有的`play()`和`pause()`方法：'
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the first step for this recipe, we are required to let the Engine know whether
    we will be taking advantage of AndEngine's ability to play `Sound` or `Music`
    objects. Failing to address this step will cause an error in the application,
    so before we move forward in implementing audio into our game, make sure this
    step is done before returning `EngineOptions` in the `onCreateEngineOptions()`
    method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方的第一步，我们需要让引擎知道我们是否将利用 AndEngine 播放`Sound`或`Music`对象的能力。如果忽略这一步，将导致应用程序出现错误，因此在我们将音频实现到游戏中之前，请确保在`onCreateEngineOptions()`方法中返回`EngineOptions`之前完成这一步。
- en: 'In the second step, we are visiting the `onCreateResources()` method of the
    application''s life cycle. Firstly, we are setting the base path of both `SoundFactory`
    and `MusicFactory`. As mentioned in the *Getting ready* section, we should have
    a folder for our audio files in the `assets/sfx` folder in our project, which
    includes all of our audio files. By calling `setAssetBasePath("sfx/")` on each
    of the two factory classes used for audio, we are now pointing to the proper folder
    to look for audio files. Once this is done, we can load our `Sound` objects through
    the use of the `SoundFactory` class and `Music` objects through the use of the
    `MusicFactory` class. The `Sound` and `Music` objects require us to pass the following
    parameters: `mEngine.getSoundManager()` or `mEngine.getMusicManager()` depending
    on the type of audio object we''re loading, the `Context` class which is `BaseGameActivity`,
    or this activity, and the name of the audio file in string format.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们访问应用程序生命周期的`onCreateResources()`方法。首先，我们设置了`SoundFactory`和`MusicFactory`的基路径。如*准备就绪*部分所述，我们应在项目的`assets/sfx`文件夹中为我们的音频文件保留一个文件夹，其中包含所有音频文件。通过在两个用于音频的工厂类上调用`setAssetBasePath("sfx/")`，我们现在指向了查找音频文件的正确文件夹。完成此操作后，我们可以通过使用`SoundFactory`类加载`Sound`对象，以及通过使用`MusicFactory`类加载`Music`对象。`Sound`和`Music`对象要求我们传递以下参数：根据我们正在加载的音频对象类型选择`mEngine.getSoundManager()`或`mEngine.getMusicManager()`，`Context`类即`BaseGameActivity`，或者是这个活动，以及音频文件名称的字符串格式。
- en: In the third step, we can now call the `play()` method on the audio object that
    we wish to play. However, this method should only be called after the `onCreateResources()`callback
    has been notified that all resources have been loaded. To be safe, we should simply
    not play any `Sound` or `Music` objects until after the `onCreateResources()`
    portion of AndEngine's life cycle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们现在可以对希望播放的音频对象调用`play()`方法。但是，这个方法应该在`onCreateResources()`回调通知所有资源都已加载之后才能调用。为了安全起见，我们只需在
    AndEngine 生命周期的`onCreateResources()`部分之后，不再播放任何`Sound`或`Music`对象。
- en: In the final step, we are setting up our `Music` object to call its `play()`
    method when our activity starts up and `onResumeGame()` is called from the life
    cycle. On the other end, during `onPauseGame()`, the `Music` object's `pause()`
    method is called. It is best practice in most cases to set our `Music` objects
    up this way, especially due to the eventual inevitability of application interruptions,
    such as phone calls or accidental pop-up clicking. This approach will allow our
    `Music` object to automatically be paused when the application leaves focus and
    start back up once we return from minimization, including execution.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们设置`Music`对象，以便在活动启动时以及从生命周期中调用`onResumeGame()`时调用其`play()`方法。在另一端，在`onPauseGame()`期间，调用`Music`对象的`pause()`方法。在大多数情况下，最好以这种方式设置我们的`Music`对象，特别是由于应用程序中断的最终不可避免性，例如电话或意外弹出点击。这种方法将允许我们的`Music`对象在应用程序失去焦点时自动暂停，并在我们从最小化返回后重新开始执行。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In this recipe, and others relating to resource loading, the names of the files
    have been hardcoded in to the code snippets. This is done to add simplicity, but
    it is advisable to use the `strings.xml` Android resource file provided for our
    project in order to keep strings organized and easy to manage.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方和其他与资源加载相关的配方中，文件名已经被硬编码到代码片段中。这样做是为了增加简单性，但建议使用我们项目的`strings.xml` Android
    资源文件，以保持字符串的组织和易于管理。
- en: There's more…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: AndEngine uses Android native sound classes to provide audio entertainment within
    our games. These classes include a few additional methods aside from `play()`
    and `pause()` that allow us to have more control over the audio objects during
    runtime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 使用 Android 原生的声音类为我们的游戏提供音频娱乐。除了`play()`和`pause()`方法之外，这些类还包含一些额外的方法，允许我们在运行时对音频对象有更多的控制。
- en: Music objects
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音乐对象
- en: 'The following list includes methods provided for the `Music` objects:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包括为`Music`对象提供的方法：
- en: '`seekTo`: The `seekTo(pMilliseconds)` method allows us to define where the
    audio playback of a specific `Music` object should start from. `pMilliseconds`
    is equal to the position of the audio track, in milliseconds, where we''d like
    to start playback upon calling `play()` on the `Music` object. In order to obtain
    the duration of a `Music` object in milliseconds, we can call `mMusic.getMediaPlayer().getDuration()`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seekTo`：`seekTo(pMilliseconds)`方法允许我们定义特定`Music`对象的音频播放应从哪里开始。`pMilliseconds`等于音频轨道的位置（毫秒），我们希望在调用`Music`对象的`play()`时从此位置开始播放。为了获取`Music`对象的持续时间（毫秒），我们可以调用`mMusic.getMediaPlayer().getDuration()`。'
- en: '`setLooping`: The `setLooping(pBoolean)` method simply defines whether or not
    the `Music` object should replay from the beginning once it reaches the end of
    its duration. If `setLooping(true)`, the `Music` object will continuously repeat
    until the application is closed or until `setLooping(false)` is called.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLooping`：`setLooping(pBoolean)`方法简单定义了`Music`对象在到达持续时间末端后是否应从开始处重新播放。如果`setLooping(true)`，则`Music`对象会持续重复，直到应用程序关闭或调用`setLooping(false)`为止。'
- en: '`setOnCompletionListener`: This method allows us to apply a listener into the
    `Music` object, which gives us the opportunity to execute a function pending track
    completion. This is done by adding `OnCompletionListener` to our `Music` object,
    as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnCompletionListener`：此方法允许我们在`Music`对象中应用一个监听器，这给了我们待音频完成时执行函数的机会。这是通过向我们的`Music`对象添加`OnCompletionListener`来完成的，如下所示：'
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`setVolume`: With the `setVolume(pLeftVolume, pRightVolume)` method, we are
    able to adjust the left and/or right stereo channels independently. The minimum
    and maximum range for volume control is equal to `0.0f` for no volume and `1.0f`
    for full volume.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setVolume`：使用`setVolume(pLeftVolume, pRightVolume)`方法，我们可以独立调整左和右立体声通道。音量控制的最低和最高范围等于`0.0f`（无音量）和`1.0f`（全音量）。'
- en: Sound objects
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sound对象
- en: 'The following list includes methods provided for the `Sound` objects:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '以下列表包括为`Sound`对象提供的方法： '
- en: '`setLooping`: See the `Music` object''s `setLooping` method''s description
    above for details. Additionally, `Sound` objects allow us to set how many times
    the audio track will loop with `mSound.setLoopCount(pLoopCount)`, where `pLoopCount`
    is an `int` value defining the number of times to loop.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLooping`：具体详情请参阅上文`Music`对象的`setLooping`方法的描述。此外，`Sound`对象允许我们使用`mSound.setLoopCount(pLoopCount)`设置音频轨道循环的次数，其中`pLoopCount`是一个定义循环次数的`int`值。'
- en: '`setRate`: The `setRate(pRate)` method allows us to define the rate, or speed,
    at which the `Sound` object will play, where `pRate` is equal to the rate as a
    floating point value. The default rate is equal to `1.0f`, while decreasing the
    rate will lower the audio pitch and increasing the rate will increase audio pitch.
    Keep in mind, the Android API documentation states that the rate accepts values
    between a range of `0.5f` through to `2.0f`. Exceeding this range on a negative
    or positive scale may cause errors in playback.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRate`：`setRate(pRate)`方法允许我们定义`Sound`对象的播放速率或速度，其中`pRate`等于浮点值表示的速率。默认速率为`1.0f`，降低速率会降低音频音调，提高速率会增加音频音调。请注意，Android
    API文档指出，速率接受的范围在`0.5f`至`2.0f`之间。超出此范围可能会在播放时产生错误。'
- en: '`setVolume`: See the `Music` object''s `setVolume` method''s description above
    for details.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setVolume`：具体详情请参阅上文`Music`对象的`setVolume`方法的描述。'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those of us who are not geared toward audio creativity, there are plenty
    of resources out there which are free to use. There are plenty of free sound databases
    that can be found online that we can use in public projects, such as [http://www.soundjay.com](http://www.soundjay.com).
    Keep in mind, most free-to-use databases require attribution for the files used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不擅长音频创作的我们来说，有许多免费资源可供使用。网上有许多免费的音频数据库，我们可以在公共项目中使用，例如[http://www.soundjay.com](http://www.soundjay.com)。请注意，大多数免费使用的数据库要求对使用的文件进行署名。
- en: Working with different types of textures
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不同类型的纹理
- en: Getting to know how to manage textures should be one of the main priorities
    for every game developer. Of course, it's possible to build a game while only
    knowing the basics of texturing, but down the road that can very well lead to
    performance issues, texture bleeding, and other unwanted results. In this recipe,
    we're going to take a look at how we can build textures into our games in order
    to provide efficiency, while reducing the possibility of texture padding issues.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何管理纹理应该是每位游戏开发者的主要优先任务之一。当然，仅了解纹理的基础知识也是可以制作游戏的，但长远来看，这很可能会导致性能问题、纹理溢出和其他不希望出现的结果。在本教程中，我们将探讨如何将纹理构建到游戏中，以提供效率，同时减少纹理填充问题出现的可能性。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Perform the *Know the life cycle* recipe given in this chapter, so that we've
    get a basic AndEngine project set up in our IDE. Additionally, this recipe will
    require three images in PNG format. The first rectangle will be named `rectangle_one.png`,
    at 30 pixels wide by 40 pixels in height. The second rectangle named `rectangle_two.png`,
    is 40 pixels wide by 30 pixels in height. The final rectangle is named `rectangle_three.png`,
    at 70 pixels wide by 50 pixels in height. Once these rectangle images have been
    added to the project's `assets/gfx/` folder, continue on to the *How to do it...*
    section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本章中给出的*了解生命周期*教程，以便我们在IDE中设置了一个基本的AndEngine项目。此外，此教程需要三个PNG格式的图像。第一个矩形命名为`rectangle_one.png`，宽30像素，高40像素。第二个矩形命名为`rectangle_two.png`，宽40像素，高30像素。最后一个矩形命名为`rectangle_three.png`，宽70像素，高50像素。将这些矩形图像添加到项目的`assets/gfx/`文件夹后，继续进行*如何操作…*部分。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: There are two main components involved when building a texture in AndEngine.
    In the following steps, we will be creating what is known as a texture atlas that
    will store three texture regions out of the three rectangle PNG images mentioned
    in the *Getting ready* section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在AndEngine中构建纹理时涉及两个主要组成部分。在以下步骤中，我们将创建一个所谓的纹理图集，它将存储在*准备工作*部分提到的三个矩形PNG图像中的三个纹理区域。
- en: 'This step is optional. We point the `BitmapTextureAtlasTextureRegionFactory`
    class to the folder in which our graphical images are located. The factory is
    pointed to the `assets/` folder by default. By appending `gfx/` to the default
    base path of the factory, it will now look in `assets/gfx/` for our images:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤是可选的。我们将`BitmapTextureAtlasTextureRegionFactory`类指向我们的图像所在的文件夹。默认情况下，工厂指向`assets/`文件夹。通过在工厂的默认基本路径后附加`gfx/`，现在它将在`assets/gfx/`中查找我们的图像：
- en: '[PRE21]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will create `BitmapTextureAtlas`. The texture atlas can be thought
    of as a map which contains many different textures. In this case, our "map" or
    `BitmapTextureAtlas`, will have a size of 120 x 120 pixels:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`BitmapTextureAtlas`。纹理图集可以看作是包含许多不同纹理的地图。在这种情况下，我们的“地图”或`BitmapTextureAtlas`的大小将为120
    x 120像素：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we have `BitmapTextureAtlas` to work with, we can now create our `ITextureRegion`
    objects and place them onto specific locations within the `BitmapTextureAtlas`
    texture. We will use the `BitmapTextureAtlasTextureRegionFactory` class, which
    helps us with binding our PNG images to a specific `ITextureRegion` object as
    well as define a position to place the `ITextureRegion` object within the `BitmapTextureAtlas`
    texture atlas we''d created in the previous step:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们有了`BitmapTextureAtlas`可以使用时，现在可以创建我们的`ITextureRegion`对象，并将它们放置在`BitmapTextureAtlas`纹理中的特定位置。我们将使用`BitmapTextureAtlasTextureRegionFactory`类，它帮助我们绑定PNG图像到特定的`ITextureRegion`对象，并在我们上一步创建的`BitmapTextureAtlas`纹理图集中定义一个位置来放置`ITextureRegion`对象：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final step is to load our `ITextureRegion` objects into memory. We can
    do this in one call to the `BitmapTextureAtlas` atlas which contains the said
    `ITextureRegion` objects:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将我们的`ITextureRegion`对象加载到内存中。我们可以通过调用包含所述`ITextureRegion`对象的`BitmapTextureAtlas`图集来实现这一点：
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In AndEngine development, there are two main components we will use in order
    to create textures for our projects. The first component is known as `BitmapTextureAtlas`,
    which can be thought of as a flat surface with a maximum width and height that
    can store sub-textures within its width and height boundaries. These sub-textures
    are called texture regions, or `ITextureRegion` objects in AndEngine to be specific.
    The purpose of the `ITextureRegion` object is to act solely as a reference to
    a specific texture in memory, which is located at position x and y within a `BitmapTextureAtlas`
    atlas. One way to look at these two components is to picture a blank canvas, which
    will represent a texture atlas, and a handful of stickers, which will represent
    the texture regions. A canvas would have a maximum size, and within that area
    we can place the stickers wherever we'd like. With this in mind, we place a handful
    of stickers on the canvas. We've now got all of our stickers neatly laid out on
    this canvas and accessible to grab and place wherever we'd like. There is a little
    bit more to it as well, but that will be covered shortly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在AndEngine开发中，为了给我们的项目创建纹理，我们将使用两个主要组件。第一个组件被称为`BitmapTextureAtlas`，可以将其视为一个具有最大宽度和高度的平面，可以在其宽度和高度范围内存储子纹理。这些子纹理被称为纹理区域，或者具体到AndEngine中是`ITextureRegion`对象。`ITextureRegion`对象的目的仅是作为对内存中特定纹理的引用，该纹理位于`BitmapTextureAtlas`图集中的x和y位置。看待这两个组件的一种方式是想象一块空白的画布，这代表纹理图集，以及一把贴纸，这些将代表纹理区域。画布会有一个最大尺寸，在这个区域内我们可以将贴纸放在任何我们想要的地方。有了这个想法，我们在画布上放置了一把贴纸。现在，我们所有的贴纸都整齐地摆放在这个画布上，我们可以随时取用并放置到任何我们想要的地方。还有一些更细节的内容，但这会在稍后介绍。
- en: With the basics of `BitmapTextureAtlas` and `ITextureRegion` objects out of
    the way, the steps involved in creating our textures should now make more sense.
    As mentioned in the first step, setting the base path of the `BitmapTextureAtlasTextureRegionFactory`
    class is completely optional. We are simply including this step as it saves us
    from having to repeat saying which folder our images are in once we move on to
    creating the `ITextureRegion` objects. For example, if we were not to set the
    base path, we'd have to reference our images as `gfx/rectangle_one.png`, `gfx/rectangle_two.png`,
    and so on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了`BitmapTextureAtlas`和`ITextureRegion`对象的基础知识之后，创建我们纹理的步骤现在应该更有意义了。如第一步所述，设置`BitmapTextureAtlasTextureRegionFactory`类的基路径是完全可选的。我们包含这一步只是因为它让我们无需在创建`ITextureRegion`对象时重复说明我们的图像位于哪个文件夹。例如，如果我们不设置基路径，我们就必须以`gfx/rectangle_one.png`、`gfx/rectangle_two.png`等方式引用我们的图像。
- en: In the second step, we are creating our `BitmapTextureAtlas` object. This step
    is pretty straightforward as we must simply specify the Engine's `TextureManager`
    object which will handle the loading of textures, as well as a width and height
    for the texture atlas, in that order. Since we're only dealing with three small
    images in these steps, 120 x 120 pixels will be just fine.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们创建`BitmapTextureAtlas`对象。这一步相当直接，因为我们只需指定引擎的`TextureManager`对象来处理纹理加载，以及纹理图集的宽度和高度，按此顺序。由于在这些步骤中我们只处理三个小图像，120x120像素就非常合适。
- en: One important thing to keep in mind about texture atlases is to never create
    excessive texture atlases; as in do not create an atlas that is 256 x 256 for
    holding a single image which is 32 x 32 pixels for example. The other important
    point is to avoid creating texture atlases which are larger than 1024 x 1024 pixels.
    Android devices vary in their maximum texture sizes and while some may be able
    to store textures up to 2048 x 2048 pixels, a large number of devices have a maximum
    limit of 1024 x 1024\. Exceeding the maximum texture size will either cause a
    force-closure on startup or simply fail to display proper textures depending on
    the device. If there is no other option and a large image is absolutely necessary,
    see *Background stitching* in [Chapter 4](ch04.html "Chapter 4. Working with Cameras"),
    *Working with Cameras*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于纹理图集，有一点非常重要，那就是永远不要创建过多的纹理图集；比如，不要为了存放一个32x32像素的单个图像而创建一个256x256的图集。另一个重要点是，避免创建超过1024x1024像素的纹理图集。安卓设备在最大纹理尺寸上各不相同，尽管有些设备可能能够存储高达2048x2048像素的纹理，但大量设备的最大限制是1024x1024。超过最大纹理尺寸将会导致在启动时强制关闭，或者在特定设备上无法正确显示纹理。如果没有其他选择，确实需要大图像，请参考[第四章](ch04.html
    "第四章. 使用摄像头")中的*背景拼接*部分，*使用摄像头*。
- en: 'In the third step of this recipe, we are creating our `ITextureRegion` objects.
    In other words, we are applying a specified image to the `mBitmapTextureAtlas`
    object as well as defining where, exactly, that image will be placed on the atlas.
    Using the `BitmapTextureAtlasTextureRegionFactory` class, we can call the `createFromAsset(pBitmapTextureAtlas,
    pContext, pAssetPath, pTextureX, pTextureY)` method, which makes creating the
    texture region a piece of cake. In the order the parameters are listed from left
    to right, the `pBitmapTextureAtlas` parameter specifies the texture atlas which
    we''d like the `ITextureRegion` object to be stored in. The `pContext` parameter
    allows the class to open the image from the `gfx/` folder. The `pAssetPath` parameter
    defines the name of the specific file we''re looking for; example, `rectangle_one.png`.
    And the final two parameters, `pTextureX` and `pTextureY`, define the location
    on the texture atlas in which to place the `ITextureRegion` object. The following
    image represents what the three `ITextureRegion` objects would look like as defined
    in step three. Note that the positions are consistent between the code and image:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的第三步中，我们正在创建我们的`ITextureRegion`对象。换句话说，我们正在将指定的图像应用到`mBitmapTextureAtlas`对象上，并定义该图像在图集中的确切位置。使用`BitmapTextureAtlasTextureRegionFactory`类，我们可以调用`createFromAsset(pBitmapTextureAtlas,
    pContext, pAssetPath, pTextureX, pTextureY)`方法，这使得创建纹理区域变得轻而易举。从左到右列出参数的顺序，`pBitmapTextureAtlas`参数指定了希望存储`ITextureRegion`对象的纹理图集。`pContext`参数允许类从`gfx/`文件夹中打开图像。`pAssetPath`参数定义了我们正在寻找的特定文件的名称，例如`rectangle_one.png`。最后的两个参数，`pTextureX`和`pTextureY`，定义了放置`ITextureRegion`对象的纹理图集上的位置。以下图像表示在第三步中定义的三个`ITextureRegion`对象的样子。请注意，代码和图像之间的位置是一致的：
- en: '![How it works…](img/978-1-849518-98-7_01_2.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/978-1-849518-98-7_01_2.jpg)'
- en: In the previous image, notice that there is a minimum gap of 10 pixels between
    each of the rectangles and the texture edge. The `ITextureRegion` objects are
    not spaced out like this to make things more understandable, although it helps.
    They are actually spaced out in order to add what is known as **texture atlas
    source spacing**. What this spacing does is that it prevents the possibility of
    texture overlapping when a texture is applied to a sprite. This overlapping is
    called **texture bleeding**. Although creating textures as seen in this recipe
    does not completely mitigate the chance of texture bleeding, it does reduce the
    likelihood of this issue when certain texture options are applied to the texture
    atlas.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图像中，请注意，每个矩形与纹理边缘之间至少有10个像素的间隔。`ITextureRegion`对象并不是像这样间隔开来以使事物更易于理解，尽管这样做有帮助。实际上，它们是间隔开来的，以便添加所谓的**纹理图集源间隔**。这种间隔的作用是防止在将纹理应用到精灵时发生纹理重叠。这种重叠被称为**纹理溢出**。尽管按照本食谱创建的纹理并不能完全消除纹理溢出的可能性，但在将某些纹理选项应用于纹理图集时，它确实降低了这个问题发生的可能性。
- en: See the *Applying texture options* recipe given in this chapter for more information
    on texture options. Additionally, the *There's more...* section in this topic
    describes another method of creating texture atlases, which completely solves
    the texture bleeding issue! It is highly recommended.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于纹理选项的信息，请参阅本章中提供的*应用纹理选项*食谱。此外，本主题中的*还有更多...*部分描述了创建纹理图集的另一种方法，这种方法完全解决了纹理溢出的问题！强烈推荐。
- en: There's more…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: There is an abundance of different approaches we can take when it comes to adding
    textures into our game. They all have their own benefits and some even have negative
    aspects involved.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将纹理添加到我们的游戏时，我们可以采取多种不同的方法。它们都有自己的优点，有些甚至涉及到负面因素。
- en: BuildableBitmapTextureAtlas
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BuildableBitmapTextureAtlas
- en: The `BuildableBitmapTextureAtlas` object is a great way to implement `ITextureRegion`
    objects into our texture atlases without having to manually define positions.
    The purpose of the `BuildableBitmapTextureAtlas` texture atlas is to automatically
    place its `ITextureRegion` objects onto the atlas by applying them to the most
    convenient coordinates. This approach to creating textures is the easiest and
    most efficient method as it can become time-consuming and sometimes even error-prone
    when building large games with many texture atlases. In addition to `BuildableBitmapTextureAtlas`
    being automated, it also allows for the developer to define transparent padding
    to the texture atlas sources, removing any occurrence of texture bleeding. This
    was one of the most prominent visual issues in AndEngine's GLES 1.0 branch as
    there was no built-in method for supplying padding to the texture atlases.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildableBitmapTextureAtlas`对象是一种将`ITextureRegion`对象实现到我们的纹理图集中的便捷方式，无需手动定义位置。`BuildableBitmapTextureAtlas`纹理图集的目的是通过将它们放置到最方便的坐标上来自动放置其`ITextureRegion`对象。这种创建纹理的方法是最简单且最高效的，因为当构建包含许多纹理图集的大型游戏时，这种方法可能会节省时间，有时甚至可以避免错误。除了`BuildableBitmapTextureAtlas`的自动化之外，它还允许开发者定义纹理图集源的透明边距，从而消除纹理溢出的任何情况。这是AndEngine的GLES
    1.0分支中最突出的视觉问题之一，因为当时没有内置方法为纹理图集提供边距。'
- en: 'Using a `BuildableBitmapTextureAtlas` atlas differs slightly from the `BitmapTextureAtlas`
    route. See the following code for this recipe''s code using a `BuildableBitmapTextureAtlas`
    atlas instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BuildableBitmapTextureAtlas`图集与`BitmapTextureAtlas`路径略有不同。以下是使用`BuildableBitmapTextureAtlas`图集的此食谱代码：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see in this code, there are some minor differences between the `BuildableBitmapTextureAtlas`
    and the `BitmapTextureAtlas` atlases. The first main point to note is that when
    creating our `ITextureRegion` objects, we no longer have to specify where the
    texture region should be placed on the texture atlas. The second minor change
    when using the `BuildableBitmapTextureAtlas` alternative is that we must call
    the `build(pTextureAtlasBuilder)` method on `mBuildableBitmapTextureAtlas` before
    we call the `load()` method. Within the `build(pTextureAtlasBuilder)` method,
    we must provide a `BlackPawnTextureAtlasBuilder` class, defining three parameters.
    In this order, the parameters are `pTextureAtlasBorderSpacing`, `pTextureAtlasSourceSpacing`,
    and `pTextureAtlasSourcePadding`. In the previous code snippet, we will remove
    the likelihood of texture bleeding in almost all cases. However, in extreme cases,
    if there is texture bleeding, then simply increase the third parameter, this will
    help to alleviate any issues.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，`BuildableBitmapTextureAtlas`与`BitmapTextureAtlas`图集之间存在一些细微差别。首先要注意的是，在创建我们的`ITextureRegion`对象时，我们不再需要指定纹理区域应在纹理图集上的放置位置。使用`BuildableBitmapTextureAtlas`替代方案时的第二个小变化是，在调用`load()`方法之前，我们必须在`mBuildableBitmapTextureAtlas`上调用`build(pTextureAtlasBuilder)`方法。在`build(pTextureAtlasBuilder)`方法中，我们必须提供一个`BlackPawnTextureAtlasBuilder`类，定义三个参数。按顺序，这些参数是`pTextureAtlasBorderSpacing`、`pTextureAtlasSourceSpacing`和`pTextureAtlasSourcePadding`。在上述代码片段中，我们几乎可以消除所有情况下的纹理溢出可能性。然而，在极端情况下，如果仍有纹理溢出，只需增加第三个参数，这将有助于解决任何问题。
- en: TiledTextureRegion
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理区域块
- en: 'A tiled texture region is essentially the same object as a normal texture region.
    The difference between the two is that a tiled texture region allows us to pass
    a single image file to it and create a sprite sheet out of it. This is done by
    specifying the number of columns and rows within our sprite sheet. From there,
    AndEngine will automatically divide the tiled texture region into evenly distributed
    segments. This will allow us to navigate through each segment within the `TiledTextureRegion`
    object. This is how the tiled texture region will appear to create a sprite with
    animation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理区域块本质上与普通纹理区域是相同的对象。两者的区别在于，纹理区域块允许我们传递一个图像文件并从中创建一个精灵表。这是通过指定我们精灵表中的列数和行数来完成的。从此，AndEngine将自动将纹理区域块均匀分布成段。这将允许我们在`TiledTextureRegion`对象中导航每个段。这就是纹理区域块如何表现为创建具有动画的精灵的样子。
- en: '![TiledTextureRegion](img/978-1-849518-98-7_01_3.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![纹理区域块](img/978-1-849518-98-7_01_3.jpg)'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A real sprite sheet should not have outlines around each column and row. They
    are in place in the previous image to display how a sprite sheet is divided up
    into equal segments.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的精灵表不应该在每列和每行周围有轮廓。在上一张图片中它们是为了显示如何将精灵表划分为等分段。
- en: 'Let''s assume that the previous image is 165 pixels wide and 50 pixels high.
    Since we have 11 individual columns and a single row, we could create the `TiledTextureRegion`
    object like so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的图像宽度为165像素，高度为50像素。由于我们有11个单独的列和单行，我们可以像这样创建`TiledTextureRegion`对象：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What this code does is it tells AndEngine to divide the `sprite_sheet.png` image
    into `11` individual segments, each 15 pixels wide (since 165 pixels divided by
    11 segments equals 15). We can now use this tiled texture region object to instantiate
    a sprite with animation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是告诉AndEngine将`sprite_sheet.png`图像划分为`11`个独立的部分，每个部分宽度为15像素（因为165像素除以11个部分等于15）。现在我们可以使用这个分块纹理区域对象实例化一个带有动画的精灵。
- en: Compressed textures
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩纹理
- en: In addition to the more common image types (`.bmp`, `.jpeg`, and `.png`), AndEngine
    also has built-in support for PVR and ETC1 compressed textures. The main benefit
    in using compressed textures is the impact it has on reducing the load time and
    possibly increasing frame rates during gameplay. On that note, there are also
    disadvantages in using compressed textures. ETC1, for example, doesn't allow for
    an alpha channel to be used in its textures. Compressed textures may also cause
    a noticeable loss of quality in your textures. The use of these types of textures
    should be relevant to the significance of the object being represented by the
    compressed texture. You most likely wouldn't want to base your entire game's texture
    format on compressed textures, but for large quantities of subtle images, using
    compressed textures can add noticeable performance to your game.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更常见的图像类型（`.bmp`、`.jpeg`和`.png`），AndEngine还内置了对PVR和ETC1压缩纹理的支持。使用压缩纹理的主要好处是它对减少加载时间和可能在游戏过程中提高帧率的影响。就此而言，使用压缩纹理也有缺点。例如，ETC1不支持在其纹理中使用alpha通道。压缩纹理也可能导致纹理质量明显下降。这些类型纹理的使用应与压缩纹理所表示的对象的重要性相关。你很可能不希望将整个游戏的纹理格式基于压缩纹理，但对于大量微妙的图像，使用压缩纹理可以为你的游戏带来明显的性能提升。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating the resource manager* in this chapter.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建资源管理器*。
- en: '*Applying texture options* in this chapter.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*应用纹理选项*。
- en: Applying texture options
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用纹理选项
- en: We've discussed the different types of textures AndEngine provides; now let's
    go over the options we can supply our textures with. The contents in this topic
    tend to have noticeable effects on the quality and performance of our games.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了AndEngine提供的不同类型的纹理；现在让我们看看我们可以为纹理提供哪些选项。这个主题的内容往往会对我们游戏的质量和性能产生显著影响。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Perform the *Working with different types of textures* recipe given in this
    chapter, so that we've got a basic AndEngine project set up with `BitmapTextureAtlas`
    or `BuildableBitmapTextureAtlas` loading in place.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本章中提供的*处理不同类型的纹理*的步骤，以便我们使用`BitmapTextureAtlas`或`BuildableBitmapTextureAtlas`加载，设置了一个基本的AndEngine项目。
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In order to modify a texture atlas'' option and/or format, we need to add a
    parameter or two to the `BitmapTextureAtlas` constructor depending on whether
    we''d like to define either the options, format, or both. See the following code
    for modifying both, texture format and texture options:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改纹理图集的选项和/或格式，我们需要根据是否要定义选项、格式或两者都定义，向`BitmapTextureAtlas`构造函数中添加一个或两个参数。以下是修改纹理格式和纹理选项的代码：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From here on, all texture regions placed on this specific texture atlas will
    have the defined texture format and option applied to it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，放置在此特定纹理图集中的所有纹理区域都将应用定义的纹理格式和选项。
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: AndEngine allows us to apply texture options and formats to our texture atlases.
    The various combination of options and formats applied to a texture atlas will
    affect the overall quality and performance impact that sprites have on our game.
    Of course, that is if the mentioned sprites are using `ITextureRegion` objects,
    which are related to the modified `BitmapTextureAtlas` atlas.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine允许我们为纹理图集应用纹理选项和格式。应用于纹理图集的各种选项和格式的组合将影响精灵对我们游戏的整体质量和性能影响。当然，如果提到的精灵使用了与修改后的`BitmapTextureAtlas`图集相关的`ITextureRegion`对象，情况也是如此。
- en: 'The base texture options available in AndEngine are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine中可用的基本纹理选项如下：
- en: '**Nearest**: This texture option is applied to texture atlases by default.
    This is the fastest-performing texture option we can apply to a texture atlas,
    but also the poorest in quality. This option means that the texture will apply
    blending of pixels that make up the display by obtaining the nearest texel color
    to a pixel. Similar to how a pixel represents the smallest element of a digital
    image, a **texel** represents the smallest element of a texture.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近邻**：此纹理选项默认应用于纹理图集。这是我们能够应用在纹理图集中的最快性能的纹理选项，但也是质量最差的。这个选项意味着纹理将通过获取与像素最近的纹理元素颜色来应用构成显示的像素的混合。类似于像素代表数字图像的最小元素，**纹理元素（texel）**代表纹理的最小元素。'
- en: '**Bilinear**: The second main texture filtering option in AndEngine is called
    bilinear texture filtering. This approach takes a hit performance-wise, but the
    quality of scaled sprites will increase. Bilinear filtering obtains the four nearest
    texels per pixel in order to provide smoother blending to an onscreen image.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双线性**：AndEngine中的第二个主要的纹理过滤选项称为双线性纹理过滤。这种方法在性能上会有所下降，但缩放后精灵的质量将提高。双线性过滤获取每个像素的四个最近的纹理元素，以提供更平滑的屏幕图像混合。'
- en: 'Take a look at the following figure to see a comparison between bilinear filtering
    and nearest filtering:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下图表，以比较双线性过滤和最近邻过滤：
- en: '![How it works…](img/978-1-849518-98-7_01_4.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/978-1-849518-98-7_01_4.jpg)'
- en: These two images are rendered in the highest bitmap format. The difference between
    nearest and bilinear filtering is very clear in this case. In the left-hand side
    of the image, the bilinear star has almost no jagged edges and the colors are
    very smooth. On the right-hand side, we've got a star rendered with the nearest
    filtering. The quality level suffers as jagged edges are more apparent and if
    observed closely, the colors aren't as smooth.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这两张图像以最高的位图格式渲染。在这种情况下，最近邻与双线性过滤之间的区别非常明显。在图像的左侧，双线性星星几乎看不到锯齿边缘，颜色非常平滑。在右侧，我们得到了一个使用最近邻过滤渲染的星星。由于锯齿边缘更加明显，质量水平受到影响，如果仔细观察，颜色也不够平滑。
- en: 'The following are a few additional texture options:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几个额外的纹理选项：
- en: '**Repeating**: The repeating texture option allows the sprite to "repeat" the
    texture assuming that the `ITextureRegion` object''s width and height has been
    exceeded by the size of the sprite. In most games, the terrain is usually generated
    by creating a repeating texture and stretching the size of the sprite, rather
    than creating many separate sprites to cover the ground.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复**：重复纹理选项允许精灵“重复”纹理，假设精灵的大小超出了`ITextureRegion`对象的宽度和高度。在大多数游戏中，地形通常是通过创建重复纹理并拉伸精灵的大小来生成的，而不是创建许多独立的精灵来覆盖地面。'
- en: 'Let''s take a look at how to create a repeating texture:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个重复纹理：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The previous code is based on a square image which is 32 x 32 pixels in dimension.
    Two things to keep in mind when creating repeating textures are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码基于一个32 x 32像素的方形图像。创建重复纹理时需要注意的两点是：
- en: Texture atlases using the repeating texture option format require the power
    of two dimensions (2, 4, 8, 16, and so on)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重复纹理选项格式的纹理图集需要尺寸为2的幂（2, 4, 8, 16等）
- en: If you are using a buildable texture atlas, do not apply padding or spacing
    during the `build()` method, as it will be taken into account in the repeating
    of the texture, breaking the first rule of repeating textures
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是可构建的纹理图集，在`build()`方法中不要应用填充或间距，因为这在纹理的重复中会被考虑在内，破坏了重复纹理的第一个规则。
- en: 'Next, we have to create a sprite which uses this repeated texture:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个使用这种重复纹理的精灵：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What we're doing here is increasing the texture region's size to 800 x 480 pixels
    in dimension. This doesn't alter the size of the image while the repeating option
    is applied to a texture, rather it allows the image to be repeated up to 800 x
    480 pixels. This means that if we create a sprite and supply the repeating texture,
    we can scale the sprite up to 800 x 480 pixels in dimension, while still displaying
    a repeat effect. However, if the sprite exceeds the width or height dimensions
    of the texture region, no texture will be applied to the exceeding area.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的的是将纹理区域的尺寸增加到800 x 480像素。这并不会改变应用了重复选项的纹理图像的大小，而是允许图像最多重复至800 x 480像素。这意味着，如果我们创建了一个精灵并提供了重复纹理，我们可以将精灵的尺寸缩放到800
    x 480像素，同时仍然显示重复效果。然而，如果精灵超出了纹理区域的宽度或高度尺寸，超出区域将不应用纹理。
- en: 'Here''s the outcome taken from a device screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自设备截图的结果：
- en: '![How it works…](img/978-1-849518-98-7_01_5.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/978-1-849518-98-7_01_5.jpg)'
- en: '**Pre-multiply alpha**: Lastly, we have the option to add the pre-multiply
    alpha texture option to our textures. What this option does is multiply each of
    the RGB values by the specified alpha channel and then apply the alpha channel
    in the end. The main purpose of this option is to allow us to modify the opacity
    of the colors without loss of color. Keep in mind, modifying the alpha value of
    a sprite directly may introduce unwanted effects when using pre-multiplied alpha
    values. Sprites will likely not appear fully transparent when this option is applied
    to sprites with an alpha value of `0`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**预乘透明度**：最后，我们有一个选项可以将预乘透明度纹理选项添加到我们的纹理中。这个选项的作用是将每个RGB值乘以指定的透明通道，然后在最后应用透明通道。这个选项的主要目的是让我们能够修改颜色的不透明度而不会损失颜色。请记住，直接修改带有预乘透明度值的精灵的透明度值可能会产生不想要的效果。当这个选项应用于透明度为`0`的精灵时，精灵可能不会完全透明。'
- en: When applying texture options to our texture atlases, we can choose either nearest
    or bilinear texture filtering options. On top of these texture filtering options,
    we can include either the repeating option, the pre-multiply alpha option, or
    even both.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当将纹理选项应用到我们的纹理图集时，我们可以选择最近邻或双线性纹理过滤选项。除了这些纹理过滤选项，我们还可以选择重复选项、预乘透明度选项，或者两者都选。
- en: There's more…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Aside from texture options, AndEngine also allows us to set the texture format
    of each of our texture atlases. Texture formats, similar to texture options, are
    often decided upon depending on its purpose. The format of a texture can greatly
    affect both the performance and quality of an image even more noticeably than
    the texture options. Texture formats allow us to choose the available color ranges
    of the RGB values in a texture atlas. Depending on the texture format being used,
    we may also allow or disallow a sprite from having any alpha value which affects
    the transparency of the textures.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纹理选项，AndEngine 还允许我们设置每个纹理图集的纹理格式。纹理格式，类似于纹理选项，通常根据其用途来决定。纹理的格式可以极大地影响图像的性能和质量，甚至比纹理选项更明显。纹理格式允许我们选择纹理图集中RGB值的可用颜色范围。根据所使用的纹理格式，我们还可能允许或不允许精灵具有任何透明度值，这会影响纹理的透明度。
- en: The texture format naming conventions are not very complicated. All formats
    have a name similar to **RGBA_8888**, where the left-hand side of the underscore
    refers to the color or alpha channels available to the texture. The right-hand
    side of the underscore refers to the bits available to each of the color channels.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理格式的命名约定并不复杂。所有格式的名称类似于**RGBA_8888**，下划线左侧指的是纹理可用的颜色或透明通道。下划线右侧指的是每个颜色通道可用的位数。
- en: Texture formats
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理格式
- en: 'The following texture formats are available:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以使用的纹理格式：
- en: '`RGBA_8888`: Allows the texture to use red, green, blue, and alpha channels,
    assigned 8 bits each. Since we have 4 channels each assigned 8 bits (4 x 8), we''re
    left with a 32-bit texture format. This is the slowest texture format of the four.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RGBA_8888`：允许纹理使用红色、绿色、蓝色和透明通道，每个通道分配8位。由于我们有4个通道，每个通道分配8位（4 x 8），我们得到一个32位的纹理格式。这是这四种格式中最慢的纹理格式。'
- en: '`RGBA_4444`: Allows the texture to use red, green, blue, and alpha channels,
    assigned 4 bits each. Following the same rule as the previous format, we''re left
    with a 16-bit texture format. You will notice an improvement with this format
    over `RGBA_8888` as we''re only saving half as much information as the 32-bit
    format. The quality will suffer noticeably; see the following image:![Texture
    formats](img/978-1-849518-98-7_01_6.jpg)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RGBA_4444`：允许纹理使用红色、绿色、蓝色和透明通道，每个通道分配4位。按照与前一个格式相同的规则，我们得到一个16位的纹理格式。与`RGBA_8888`相比，你会注意到这个格式的改进，因为我们保存的信息量只有32位格式的一半。质量将明显受损；请看以下图片：![纹理格式](img/978-1-849518-98-7_01_6.jpg)'
- en: In this image, we compare the difference between two texture formats. The stars
    are both rendered with the default texture option (nearest), which has nothing
    to do with the RGBA format of the image. What we're more interested here is the
    color quality of the two stars. The left-hand side star is rendered with full
    32-bit color capabilities, the right with 16-bit. The difference between the two
    stars is rather apparent.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这张图片中，我们比较了两种纹理格式的差异。两颗星星都使用默认的纹理选项（最近邻）进行渲染，这与图像的RGBA格式无关。我们更感兴趣的是两颗星星的颜色质量。左侧的星星以全32位颜色能力进行渲染，右侧的则是16位。两颗星星之间的差异相当明显。
- en: '`RGB_565`: Another 16-bit texture format, though this one does not include
    an alpha channel; textures using this texture format will not allow for transparency.
    Due to the lack of transparency, the need for this format is limited, but it is
    still valuable. One example of this texture format being used would be to display
    a fullscreen image such as a background. Backgrounds don''t require transparency,
    so it is wise to keep this format in mind when introducing a background. The performance
    saved is fairly noticeable.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RGB_565`：这是另一种16位的纹理格式，不过它不包括透明通道；使用这种纹理格式的纹理将不支持透明度。由于缺乏透明度，这种格式的需求有限，但它仍然很有价值。这种纹理格式的一个使用场景是显示全屏图像，如背景。背景不需要透明度，因此在引入背景时，记住这种格式是明智的。这样节省的性能相当明显。'
- en: Tip
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `RGB_565` format color quality is more or less the same as you would expect
    from the `RGBA_4444` star image shown previously.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RGB_565`格式的颜色质量与之前展示的`RGBA_4444`星形图像大致相同。'
- en: '`A_8`: Finally, we have the last texture format, which is an 8-bit alpha channel
    (does not support colors). Another limited-use format; the A_8 format is generally
    used as an alpha mask (overlay) for sprites which have colors. One example of
    a use for this format is a screen fading in or out by simply overlaying a sprite
    with this texture, then altering the transparency as time passes.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A_8`：最后，我们来看最后一种纹理格式，它是8位的透明通道（不支持颜色）。这也是一种使用范围有限的格式；A_8格式通常用作具有颜色的精灵的透明遮罩（叠加）。这种格式的一个使用例子是，通过简单地叠加这种纹理的精灵，然后随着时间的推移改变透明度，使屏幕渐变出现或消失。'
- en: When creating your texture atlases, it is a good idea to think about which types
    of sprites will use which type of texture regions and pack them into texture atlases
    accordingly. For more important sprites, we'll most likely want to use the `RGBA_8888`
    texture format, since these sprites will be the main focus of our games. These
    objects might include the foreground sprites, main character sprites, or anything
    on the screen that would be more visually prominent. Backgrounds underlay the
    entire surface area of the device, so we most likely have no use for transparency.
    We will use `RGB_565` for these sprites in order to remove the alpha channel,
    which will help improve performance. Finally, we have objects which might not
    be very colorful, might be small, or simply may not need as much visual appeal.
    We can use the texture format `RGBA_4444` for these types of sprites in order
    to cut the memory needed for these textures in half.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建纹理图集时，考虑哪些类型的精灵将使用哪种类型的纹理区域，并据此将它们打包到纹理图集中是一个好主意。对于较重要的精灵，我们很可能会选择使用`RGBA_8888`纹理格式，因为这些精灵将是我们游戏的主要焦点。这些对象可能包括前景精灵、主角精灵或屏幕上任何视觉上更突出的物体。背景覆盖了设备整个表面区域，所以我们很可能不需要透明度。对于这些精灵，我们将使用`RGB_565`以移除透明通道，这将有助于提高性能。最后，我们有那些可能颜色不多、可能较小或只是不需要太多视觉吸引力的物体。对于这类精灵，我们可以使用`RGBA_4444`纹理格式，以减少这些纹理所需的内存一半。
- en: See also
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Know the life cycle* in this chapter.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章了解*生命周期*。
- en: '*Working with different types of textures* in this chapter.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章介绍*不同类型的纹理*的处理方法。
- en: '*Bringing a scene to life with sprites* in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章.处理实体")中，*使用实体*，介绍了如何通过精灵使场景*生动起来*。
- en: Using AndEngine font resources
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AndEngine 字体资源
- en: AndEngine fonts are simple to set up and include for use in our `Text` objects
    to be displayed on screen. We can choose from preset fonts or we can add our own
    via the `assets` folder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine 字体设置简单，可以包含在我们的`Text`对象中使用，显示在屏幕上。我们可以选择预设字体，也可以通过`assets`文件夹添加自己的字体。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Perform the *Know the life cycle* recipe given in this chapter, so that we've
    got a basic AndEngine project set up in our IDE, then continue on to the *How
    to do it...* section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本章提供的*了解生命周期*的步骤，这样我们就可以在IDE中设置基本的AndEngine项目，然后继续阅读*如何操作…*部分。
- en: How to do it…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The following code snippets display the four different options we have for creating
    preset, custom asset, preset stroke, and custom asset stroke font objects. Font
    creation should take place in the `onCreateResources()` method of our `BaseGameActivity`
    class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了创建预设、自定义资源、预设描边和自定义资源描边字体对象的四种不同选项。字体创建应该在`BaseGameActivity`类的`onCreateResources()`方法中进行。
- en: 'The `create()` method for preset fonts is as follows:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预设字体的`create()`方法如下：
- en: '[PRE30]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `createFromAsset()` method for custom fonts is as follows:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义字体的`createFromAsset()`方法如下：
- en: '[PRE31]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `createStroke()` and `createStrokeFromAsset()` methods for outlined fonts
    are:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描边字体的`createStroke()`和`createStrokeFromAsset()`方法如下：
- en: '[PRE32]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: As we can see, there are different approaches we can take to create our `Font`
    objects depending on how we'd like the font to look. However, all fonts share
    the need for us to define a texture width and texture height, whether it be directly
    as parameters in the `FontFactory` class' `create` methods or indirectly through
    the use of a `BitmapTextureAtlas` object. In the previous code snippets, we'd
    created all three `Font` objects using a texture size of `256` pixels in width
    by `256` pixels in height. Unfortunately, there is currently no easy way to automatically
    determine the texture size needed at runtime in order to support different languages,
    text sizes, stroke value, or font style.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，根据我们希望字体呈现的效果，我们可以采取不同的方法来创建我们的`Font`对象。然而，所有字体都需要我们定义纹理宽度和纹理高度，无论是直接作为`FontFactory`类`create`方法的参数，还是通过使用`BitmapTextureAtlas`对象间接定义。在之前的代码片段中，我们使用宽度为`256`像素、高度为`256`像素的纹理大小创建了所有三个`Font`对象。不幸的是，目前还没有简单的方法在运行时自动确定所需的纹理大小，以支持不同的语言、文本大小、描边值或字体样式。
- en: For now, the most common approach is to set the texture width and height to
    about `256` pixels and make small adjustments upward or downward until the texture
    is just the right size so as to not cause artifacts in the `Text` objects. The
    font size plays the biggest role in determining the final texture size needed
    for the `Font` object, so exceedingly large fonts, such as 32 and higher, may
    need larger texture sizes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最常见的方法是将纹理宽度和高度设置为大约`256`像素，然后向上或向下进行小调整，直到纹理大小刚好合适，不会在`Text`对象中产生伪影。字体大小在确定`Font`对象所需的最终纹理大小中起着最重要的作用，因此非常大的字体，例如32及以上，可能需要更大的纹理大小。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All `Font` objects require a method call to `load()` before they can properly
    display characters in the `Text` objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Font`对象在能够正确显示`Text`对象中的字符之前，都需要调用`load()`方法。
- en: 'Let''s take a look at how each of the methods presented in the *How to do it...*
    section work:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*如何操作…*部分中介绍的各种方法是如何工作的：
- en: 'The `create()` method: The `create()` method doesn''t allow for too much customization.
    This method''s parameters, starting at the fifth parameter, include supplying
    a typeface, font size, anti-aliasing option, and a color. We''re using the Android
    native typeface class which only supports a few different fonts and styles.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create()`方法：`create()`方法不允许太多自定义。从第五个参数开始，这个方法的参数包括提供字体样式、字体大小、抗锯齿选项和颜色。我们使用的是Android原生字体类，它只支持几种不同的字体和样式。'
- en: 'The `createFromAsset()` method: We can use this method in order to introduce
    custom fonts into our project via our `assets` folder. Let''s assume that we have
    a true-type font called `Arial.ttf` located in our project''s `assets` folder.
    We can see that the general creation is the same. In this method, we must pass
    the activity''s `AssetManager` class, which can be obtained through our activity''s
    `getAssets()` method. The parameter following that is the true type font we would
    like to import.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createFromAsset()`方法：我们可以使用这个方法将自定义字体引入到我们的项目中，通过我们的`assets`文件夹。假设我们有一个叫做`Arial.ttf`的真类型字体位于项目的`assets`文件夹中。我们可以看到，一般的创建过程是相同的。在这个方法中，我们必须传递活动的`AssetManager`类，这可以通过我们活动的`getAssets()`方法获得。接下来的参数是我们想要导入的真类型字体。'
- en: 'The `createStroke()` and `createStrokeFromAsset()` methods: Finally, we have
    our stroke fonts. The stroke font gives us the ability to add outlines to the
    characters in our `Text` object. These fonts are useful in situations where we
    would like our text to "pop". For creating stroke fonts, we''ll need to supply
    a texture atlas as the second parameter rather than passing the engine''s texture
    manager. From this point, we can either create the stroke font via a typeface
    or through our `assets` folder. Additionally, we''re given the option to define
    two new color values which have been added as the final two parameters. With these
    new parameters, we are able to adjust the thickness of the outline as well as
    the color.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createStroke()`和`createStrokeFromAsset()`方法：最后，我们有了描边字体。描边字体使我们能够为`Text`对象中的字符添加轮廓。在这些情况下，当我们希望我们的文本“突出”时，这些字体很有用。为了创建描边字体，我们需要提供一个纹理图集作为第二个参数，而不是传递引擎的纹理管理器。从这个点开始，我们可以通过字体类型或通过我们的`assets`文件夹来创建描边字体。此外，我们还提供了定义两个新颜色值的选项，这两个值作为最后两个参数添加。有了这些新参数，我们能够调整轮廓的厚度以及颜色。'
- en: There's more…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The way the `Font` class is currently set up, it is best to preload the characters
    that we expect to display via a `Text` object. Unfortunately, AndEngine currently
    makes calls to the garbage collector when new letters are still to be drawn, so
    in order to avoid hiccups when a `Text` object is first getting "acquainted" with
    the letters, we can call the method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Font`类目前的设置，最好预加载我们期望通过`Text`对象显示的字符。不幸的是，AndEngine目前在还有新字母要绘制时仍然调用垃圾回收器，因此为了避免`Text`对象首次“熟悉”字母时的卡顿，我们可以调用以下方法：'
- en: '[PRE33]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method call would prepare the lowercase letters from a to z. This method
    should be called during a loading screen at some point within the game in order
    to avoid any noticeable garbage collection. There's one more important class that
    we should discuss before moving off the topic of `Font` objects. AndEngine includes
    a class called `FontUtils` that allows us to retrieve information regarding a
    `Text` object's width on the screen via the `measureText(pFont, pText)` method.
    This is important when dealing with dynamically-changing strings as it gives us
    the option to relocate our `Text` object, assuming that the width or height of
    the string in pixels has changed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用将准备从a到z的小写字母。这个方法应该在游戏加载屏幕期间的某个时刻被调用，以避免任何可察觉的垃圾回收。在离开`Font`对象的话题之前，还有一个重要的类我们应该讨论。AndEngine包含一个名为`FontUtils`的类，它允许我们通过`measureText(pFont,
    pText)`方法获取关于`Text`对象在屏幕上的宽度的信息。在处理动态变化的字符串时，这很重要，因为它为我们提供了重新定位`Text`对象的选项，假设字符串的宽度或高度（以像素为单位）已经改变。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Know the life cycle* in this chapter.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解本章中的生命周期*。'
- en: '*Working with different types of textures* in this chapter.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*处理不同类型的纹理*。
- en: Applying text to a layer in [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html "第二章. 使用实体")《*使用实体*》中，将文本应用到图层。
- en: Creating the resource manager
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建资源管理器
- en: In this topic, we're finally going to look at our resources from a bigger picture.
    With the resource manager in place, we will easily be able to make a single call
    to methods such as `loadTextures()`, `loadSounds()`, or `loadFonts()` in order
    to load the different types of resources needed by our game, all from a single,
    convenient location.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们最终将从更大的角度查看我们的资源。有了资源管理器，我们将能够轻松地通过单一、方便的位置，调用如`loadTextures()`、`loadSounds()`或`loadFonts()`等方法，来加载游戏需要的不同类型的资源。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please refer to the class named `ResourceManager` in the code bundle.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`ResourceManager`的类。
- en: How to do it…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The `ResourceManager` class is designed with the singleton design pattern in
    mind. This allows for global access to all of our game's resources through a simple
    call to `ResourceManager.getInstance()`. The main purpose of the `ResourceManager`
    class is to store resource objects, load resources, and unload resources. The
    following steps display how we can use `ResourceManager` to handle textures of
    one of our game's scenes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager`类是以单例设计模式为理念设计的。这允许我们通过简单的调用`ResourceManager.getInstance()`来全局访问我们游戏的所有资源。`ResourceManager`类的主要目的是存储资源对象，加载资源，以及卸载资源。以下步骤展示了我们如何使用`ResourceManager`来处理我们游戏场景之一的纹理。'
- en: 'Declare all of the resources that will be used throughout the different scenes
    in our game:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明将在我们游戏的不同场景中使用的所有资源：
- en: '[PRE34]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Provide `load` methods that will handle loading the audio, graphical, and font
    resources declared in the `ResourceManager` class:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供处理在`ResourceManager`类中声明的音频、图形和字体资源加载的`load`方法：
- en: '[PRE35]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The third step involves providing a method of unloading all resources corresponding
    to our `ResourceManager` class'' `load` methods:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步涉及提供一个与我们的`ResourceManager`类的`load`方法相对应的所有资源的卸载方法：
- en: '[PRE36]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'By implementing a `ResourceManager` class into our project, we can easily load
    our various scene resources completely indepenently of one another. Because of
    this, we must make sure that our `public` class methods are synchronized in order
    to make sure that we''re running in a thread-safe environment. This is especially
    important with the use of singletons, as we''ve only got one instance of the class,
    with the potential for multiple threads accessing it. On top of that, we now only
    require one line of code when it comes to loading our scene resources which helps
    greatly in keeping our main activity class more organized. Here is what our `onCreateResources()`
    methods should look like with the use of a resource manager:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目中实现一个`ResourceManager`类，我们可以轻松地完全独立地加载各种场景资源。因此，我们必须确保我们的`public`类方法是同步的，以确保我们在一个线程安全的环境中运行。这对于单例的使用尤为重要，因为我们只有一个类实例，有多个线程访问它的可能性。除此之外，现在我们只需要一行代码即可加载场景资源，这极大地帮助我们的主活动类保持更有条理。以下是使用资源管理器时，我们的`onCreateResources()`方法应该看起来像什么样子：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the first step, we are declaring all of our resources, including `Font`
    objects, `ITextureRegion` objects, and `Sound`/`Music` objects. In this particular
    recipe, we''re only working with a limited number of resources, but in a fully-functional
    game, this class may include 50, 75, or even more than 100 resources. In order
    to obtain a resource from our `ResourceManager` class, we can simply include the
    following line into any class within our project:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们声明了所有的资源，包括`Font`对象，`ITextureRegion`对象，以及`Sound`/`Music`对象。在这个特定的示例中，我们只处理有限数量的资源，但在一个功能齐全的游戏中，这个类可能包括50、75，甚至超过100个资源。为了从我们的`ResourceManager`类中获取资源，我们只需在任何类中包含以下代码行：
- en: '`ResourceManager.getInstance().mGameBackgroundTextureRegion`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager.getInstance().mGameBackgroundTextureRegion`。'
- en: In the second step, we create the `loadGameTextures(pEngine, pContext)` method
    which is used to load the `Game` scene textures. For every additional scene within
    our game, we should have a separate `load` method in place. This allows for easy
    loading of resources on the fly.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们创建了`loadGameTextures(pEngine, pContext)`方法，用于加载`Game`场景的纹理。对于游戏中的每个附加场景，我们应该有一个单独的`load`方法。这使得可以轻松地动态加载资源。
- en: In the final step, we're creating `unload` methods which handle unloading the
    resources corresponding to each of the `load` methods. However, if there are any
    number of resources which happen to be used throughout a number of our game's
    scenes, it might be necessary to create a `load` method which doesn't come with
    an accompanying `unload` method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们创建`unload`方法，处理与每个`load`方法相对应的资源卸载。然而，如果有任何数量的资源在我们的游戏多个场景中使用，可能需要创建一个没有伴随`unload`方法的`load`方法。
- en: There's more…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In larger projects, sometimes we may find ourselves passing main objects to
    classes very frequently. Another use for the resource manager is to store some
    of the more important game objects such as the `Engine` or `Camera`. This way
    we no longer have to continuously pass these objects as parameters, rather we
    can call respective `get` methods in order to get the game's `Camera`, `Engine`,
    or any other specific object we'll need to reference throughout the classes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的项目中，有时我们可能会发现自己频繁地将主要对象传递给类。资源管理器的另一个用途是存储一些更重要的游戏对象，如`Engine`或`Camera`。这样我们就不必不断地将这些对象作为参数传递，而可以调用相应的`get`方法以获取游戏的`Camera`、`Engine`或我们将在类中引用的任何其他特定对象。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introducing sounds and music* in this chapter.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*引入声音和音乐*。
- en: '*Working with different types of textures* in this chapter.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*处理不同类型的纹理*。
- en: '*Using AndEngine font resources* in this chapter.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中*使用AndEngine字体资源*。
- en: Saving and loading game data
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载游戏数据
- en: In the final topic for the game structure chapter, we're going to set up a class
    that can be used in our project to manage data and settings. The more obvious
    game data we must save should include character stats, high scores, and other
    various data we may have included in our game. We should also keep track of certain
    options a game might have, such as whether the user has sounds muted or not, gore
    effects, and more. In this recipe, we're going to work with a class called `SharedPreferences`,
    which will allow us to easily store data to a device for retrieval at a later
    time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏结构章节的最后一个主题中，我们将设置一个可以在项目中使用的类来管理和设置数据。我们必须保存的更明显的游戏数据应该包括角色状态、高分和其他可能在我们的游戏中包含的各种数据。我们还应该跟踪游戏可能具有的某些选项，例如用户是否静音、血腥效果等。在这个示例中，我们将使用一个名为`SharedPreferences`的类，它将允许我们轻松地将数据保存到设备上，以便在稍后的时间检索。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `SharedPreferences` class is a great way to quickly store and retrieve primitive
    datatypes. However, as the data size increases, so will the needs of the method
    we use to store data. If our games do require a large amount of data to be stored,
    something to consider is to take a look into SQLite databases for data storage.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences`类是快速存储和检索原始数据类型的一种很好的方式。然而，随着数据量的增加，我们用来存储数据的方法的需求也会增加。如果我们的游戏确实需要存储大量数据，可以考虑使用SQLite数据库来存储数据。'
- en: Getting ready
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the class named `UserData` in the code bundle.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`UserData`的类。
- en: How to do it…
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we''re setting up a `UserData` class that will store a Boolean
    variable to determine sound muting and an `int` variable that will define the
    highest, unlocked level a user has reached. Depending on the needs of the game,
    there may be more or less datatypes to include within the class for different
    reasons, be it high score, currency, or other game-related data. The following
    steps describe how to set up a class to contain and store user data on a user''s
    device:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们设置了一个名为`UserData`的类，该类将存储一个布尔变量以决定是否静音，以及一个`int`变量，该变量将定义用户已解锁的最高级别。根据游戏的需求，可能需要在类中包含更多或更少的数据类型，无论是最高分、货币还是其他与游戏相关的数据。以下步骤描述了如何设置一个类，在用户的设备上包含和存储用户数据：
- en: 'The first step involves declaring our constant `String` variables, which will
    hold references to our preference file, as well as "key" names, which will hold
    references to data within the preference file, as well as corresponding "value"
    variables. Additionally, we declare the `SharedPreferences` object as well as
    an editor:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步涉及声明我们的常量`String`变量，这些变量将保存对我们偏好文件的引用，以及保存对偏好文件内部数据引用的“键”名称，以及相应的“值”变量。此外，我们还声明了`SharedPreferences`对象以及一个编辑器：
- en: '[PRE38]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create an initialization method for our `SharedPreferences` file. This method
    will be called when our game is first launched, either creating a new file for
    our game if one does not already exist, or load existing values from our preference
    file if it does exist:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`SharedPreferences`文件创建一个初始化方法。这个方法将在我们的游戏首次启动时被调用，如果不存在，则为我们的游戏创建一个新文件，如果存在，则从偏好文件加载现有值：
- en: '[PRE39]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will provide getter methods for each of the values that are meant
    to be stored in our `SharedPreferences` file, so that we can access the data throughout
    our game:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为那些打算存储在`SharedPreferences`文件中的每个值提供获取方法，以便我们可以在整个游戏中访问数据：
- en: '[PRE40]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And finally, we must provide setter methods for each of the values that are
    meant to be stored in our `SharedPreferences` file. The setter methods will be
    responsible for saving the data to the device:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须为那些打算存储在`SharedPreferences`文件中的每个值提供设置方法。设置方法将负责将数据保存到设备上：
- en: '[PRE41]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: This class demonstrates just how easily we are able to store and retrieve a
    game's data and options through the use of the `SharedPreferences` class. The
    structure of the `UserData` class is fairly straightforward and can be used in
    this same fashion in order to adapt to various other options we might want to
    include in our games.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类展示了我们如何通过使用`SharedPreferences`类轻松地存储和检索游戏的数据和选项。`UserData`类的结构相当直接，可以以相同的方式使用，以便适应我们可能想要在游戏中包含的各种其他选项。
- en: In the first step, we simply start off by declaring all of the necessary constants
    and member variables that we'll need to handle different types of data within
    our game. For constants, we have one `String` variable named `PREFS_NAME` that
    defines the name of our game's preference file, as well as two other `String`
    variables that will each act as references to a single primitive datatype within
    the preference file. For each key constant, we should declare a corresponding
    variable that preference file data will be stored to when it is first loaded.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们只是开始声明所有必要的常量和成员变量，这些变量我们将用于处理游戏中的不同类型的数据。对于常量，我们有一个名为`PREFS_NAME`的`String`变量，它定义了游戏的偏好文件的名称，还有另外两个`String`变量，它们将分别作为对偏好文件中单个原始数据类型的引用。对于每个键常量，我们应该声明一个相应的变量，当数据第一次加载时，偏好文件数据将存储到这个变量中。
- en: In the second step, we provide a means of loading the data from our game's preference
    file. This method only needs to be called once, during the startup process of
    a game in order to load the `UserData` classes member variables with the data
    stored in the `SharedPreferences` file. By first calling `context.getSharedPreferences(PREFS_NAME,
    Context.MODE_PRIVATE)`, we check to see whether or not a `SharedPreference` file
    exists for our application under the `PREFS_NAME` string, and if not, then we
    create a new one a—`MODE_PRIVATE`, meaning the file is not visible to other applications.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们提供了从游戏的偏好文件中加载数据的方法。这个方法只需要在游戏启动过程中调用一次，以将`SharedPreferences`文件中的数据加载到`UserData`类的成员变量中。首先调用`context.getSharedPreferences(PREFS_NAME,
    Context.MODE_PRIVATE)`，我们检查是否有针对我们的应用程序在`PREFS_NAME`字符串下的`SharedPreference`文件，如果没有，那么我们将创建一个新的文件——`MODE_PRIVATE`，意味着该文件对其他应用程序不可见。
- en: Once that is done, we can call getter methods from the preference file such
    as `mUnlockedLevels = mSettings.getInt(UNLOCKED_LEVEL_KEY, 1)`. This will pass
    the data stored in the `UNLOCKED_LEVEL_KEY` key of the preference file to `mUnlockedLevels`.
    If the game's preference file does not currently hold any value for the defined
    key, then a default value of `1` is passed to `mUnlockedLevels`. This would continue
    to be done for each of the datatypes being handled by the `UserData` class. In
    this case, just the levels and sound.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以从偏好文件中调用获取器方法，如`mUnlockedLevels = mSettings.getInt(UNLOCKED_LEVEL_KEY,
    1)`。这将偏好文件中`UNLOCKED_LEVEL_KEY`键的数据传递给`mUnlockedLevels`。如果游戏的偏好文件当前没有为定义的键保存任何值，那么默认值`1`将被传递给`mUnlockedLevels`。这将针对`UserData`类处理的每种数据类型继续进行。在这种情况下，只是关卡和声音。
- en: In the third step, we set up the getter methods that will correspond to each
    of the datatypes being handled by the `UserData` class. These methods can be used
    throughout the game; for example, we could call `UserData.getInstance().isSoundMuted()`
    during level loading to determine whether or not we should call `play()` on the
    `Music` object.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们设置了对`UserData`类处理的每种数据类型相对应的获取器方法。这些方法可以在游戏中的任何地方使用；例如，在关卡加载时，我们可以调用`UserData.getInstance().isSoundMuted()`，以确定是否应该对`Music`对象调用`play()`。
- en: In the fourth step, we create the methods that save data to the device. These
    methods are pretty straightforward and should be fairly similar regardless of
    the data we're working with. We can either take a value from a parameter as seen
    with `setSoundMuted(pEnableSound)` or simply increment as seen in `unlockNextLevel()`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们创建了将数据保存到设备的方法。这些方法非常直接，无论我们处理哪种数据，它们都应该相当相似。我们可以从参数中获取一个值，如`setSoundMuted(pEnableSound)`，或者简单地递增，如`unlockNextLevel()`中所示。
- en: When we want to finally save the data to the device, we use the `mEditor` object,
    using putter methods which are suitable for the primitive datatype we wish to
    store, specifying the key to store the data as well as the value. For example,
    for level unlocking, we use the method, `mEditor.putInt(UNLOCKED_LEVEL_KEY, mUnlockedLevels)`
    as we are storing an `int` variable. For a `boolean` variable, we call `putBoolean(pKey,
    pValue)`, for a `String` variable, we call `putString(pKey, pValue)`, and so on..
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最终想要将数据保存到设备上时，我们使用`mEditor`对象，使用适合我们要存储的原始数据类型的方法，指定存储数据的键以及值。例如，对于关卡解锁，我们使用方法`mEditor.putInt(UNLOCKED_LEVEL_KEY,
    mUnlockedLevels)`，因为我们正在存储一个`int`变量。对于`boolean`变量，我们调用`putBoolean(pKey, pValue)`，对于`String`变量，我们调用`putString(pKey,
    pValue)`，依此类推。
- en: There's more...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unfortunately, when storing data on a client's device, there's no way of guaranteeing
    that a user will not have access to the data in order to manipulate it. On the
    Android platform, most users will not have access to the `SharedPreferences` file
    that holds our game data, but users with rooted devices on the other hand will
    be able to see the file and make changes as they see fit. For the sake of explanation,
    we used obvious key names, such as `soundKey` and `unlockedLevels`. Using some
    sort of misconstruction can help to make the file look more like gibberish to
    an average user who had accidentally stumbled upon the game data with their rooted
    device.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在客户端设备上存储数据时，无法保证用户不会访问数据以进行操纵。在Android平台上，大多数用户无法访问保存我们游戏数据的`SharedPreferences`文件，但是拥有root权限的用户则能够查看该文件并根据需要做出修改。为了解释的方便，我们使用了明显的键名，比如`soundKey`和`unlockedLevels`。使用某种形式的混淆可以帮助让文件对于偶然在root设备上发现游戏数据的普通用户来说更像是一堆乱码。
- en: If we feel like going further to protect the game data, then the even more secure
    approach would be to encrypt the preference file. Java's `javax.crypto.*` package
    is a good place to start, but keep in mind that encryption and decryption does
    take time and will likely increase the duration of loading times within the game.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进一步保护游戏数据，那么更为安全的做法是对偏好设置文件进行加密。Java的`javax.crypto.*`包是一个不错的起点，但请记住，加密和解密确实需要时间，这可能会增加游戏加载时间。
