- en: Chapter 5. Data Transfer Using Intents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 使用意图进行数据传输
- en: Until now, we have learned the classification of intents, their uses in Android
    Components, and a step-by-step guide to implement them in your Android application.
    This is the right time to look at the most important part of an Android application.
    It is the necessity of an Android application to transfer data from one activity
    to another (whether implicit or explicit). The secure transfer and retrieval of
    data is the prime focus of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了意图的分类、它们在安卓组件中的用途以及在安卓应用程序中逐步实现它们的方法。现在是查看安卓应用程序最重要的部分的时候了。在安卓应用程序中，从一项活动向另一项活动传输数据（无论是隐式还是显式）是必不可少的。本章的主要焦点是数据的安全传输和检索。
- en: 'This chapter includes the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: The need to transfer data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输数据的必要性
- en: Data transfer between activities – an *INTENTed* way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动之间的数据传输——一种*有意*的方式
- en: Data transfer in explicit intents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显式意图中进行数据传输
- en: Methods of explicit data transferring using intents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图显式传输数据的方法
- en: Data transfer in implicit intents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隐式意图中进行数据传输
- en: Finding the need to transfer data
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找需要传输数据的需求
- en: Technically, an Android application is a combination of different activities.
    These activities consist of layouts, views, and some content. These contents are
    mostly not dynamic nor are they predecided. For example, if an Android layout
    consists of a button, the text in that button can be static or predefined. Similarly,
    if there is any text field or any List View present in an activity, it mostly
    consists of dynamic data that comes from any server or any other means.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，一个安卓应用程序是由不同的活动组合而成的。这些活动包括布局、视图和一些内容。这些内容大多数不是动态的，也不是预先决定的。例如，如果一个安卓布局包含一个按钮，那么该按钮中的文本可以是静态的或预定义的。同样，如果一个活动中有任何文本字段或列表视图，它通常包含来自任何服务器或其他手段的动态数据。
- en: In these kinds of situations, we need some dynamic data that our application
    can fetch from the server (or somewhere else), and activities to transfer it between
    one another. This is the scenario in which the transfer of data takes place. Furthermore,
    the transfer of data is highly probable, where one activity performs some manipulation
    on the data and the other activity needs to show it in its Views.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们需要一些动态数据，这些数据我们的应用程序可以从服务器（或其他地方）获取，并在活动之间传输。正是在这种场景下发生数据传输。此外，在其中一个活动对数据进行一些操作，而另一个活动需要在其视图中显示它的情况下，数据传输的可能性非常高。
- en: Taking a simple example
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举一个简单的例子
- en: In order to have a better understanding of the picture, let's take a theoretical
    example of why we need to perform data transfer between activities. The Reader
    application can be a good example to understand the reasons for data transfer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这张图片，让我们从理论上举例说明为什么需要在活动之间进行数据传输。读者应用程序可以作为一个很好的例子，来理解数据传输的原因。
- en: The Reader application is an application in which there are different kinds
    of news present in a List View, and tapping them leads to the description page
    where the whole news is displayed with images and other texts. Let's have a step-by-step
    look at the flow of this application (taking the TechCrunch Android app as an
    example).The application will start with a splash screen, describing to the reader
    or the developer who made the app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应用程序是一个包含不同种类新闻的列表视图的应用程序，点击新闻可以进入描述页面，页面中会展示整条新闻以及图片和其他文本。让我们一步步了解这个应用程序的流程（以TechCrunch安卓应用为例）。应用程序将以一个启动屏幕开始，向读者或开发者描述谁制作了这个应用。
- en: The following screenshot is the splash screen; the application will search for
    an Internet connection in order to display the feeds to the app's screen. Once
    the data is locally fetched, it parses it and places it inside the List View.
    Please note that the following screenshot of the List View is basically the custom
    List View that is not directly obtained by a built-in layout of Android. We need
    to make a custom layout for this and then populate it in the normal List View.
    For this, adapters are used (refer to the Internet in order to find how the basic
    List Views are created in Android).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是启动屏幕；应用程序将搜索互联网连接，以便将新闻源显示到应用程序的屏幕上。一旦本地获取了数据，它就会解析数据并将其放入列表视图中。请注意，以下列表视图的截图基本上是自定义列表视图，并不是直接通过安卓的内置布局获得的。我们需要为此制作一个自定义布局，然后在常规列表视图中填充它。为此，需要使用适配器（请参考互联网，了解如何在安卓中创建基本的列表视图）。
- en: '![Taking a simple example](img/9639_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![举一个简单的例子](img/9639_05_01.jpg)'
- en: Activity of the Reader app in which the news are listed in the List View.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应用的活动，其中新闻在列表视图中列出。
- en: 'Now, there are two possibilities of data transfer that are described as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有两种可能的数据传输方式，如下所述：
- en: Whole data including the description is fetched
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取包括描述在内的所有数据
- en: Once the feed on the List View is clicked on, the description of that feed is
    fetched at that particular moment
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦点击了列表视图中的馈送，将立即获取该馈送的描述。
- en: '![Taking a simple example](img/9639_05_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![举一个简单的例子](img/9639_05_02.jpg)'
- en: Activity showing the description of the story as it was tapped in the preceding
    Activity
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显示前一个活动中点击的故事描述的活动
- en: No matter what the case is, this step will require the data to be transferred
    from the first activity to the next activity. If the scenario is the first one,
    the description data that was parsed by the first activity will be delivered to
    the second activity in order to populate it in the View. Otherwise, in case of
    the second scenario, it will pass some URL to the second activity from where it
    can fetch the description of the news. Refer to the preceding screenshot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，这一步都需要将数据从第一个活动传输到下一个活动。如果是第一种情况，由第一个活动解析的描述数据将被传递到第二个活动，以便在视图中填充它。否则，在第二种情况下，它将传递一些URL给第二个活动，从那里它可以获取新闻的描述。请参考前面的屏幕截图。
- en: Data transfer between activities – an INTENTed way
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动之间的数据传输——一种INTENTed方式
- en: When we talk about data transfer between activities, we need to keep in mind
    that the only way to interact and manage the flow of the activities is through
    intents. In the previous chapter, we had a thorough discussion on how to move
    from one activity to the other using intents. Here, we will see how we can transfer
    data along with those intents and how to securely catch the transferred data in
    the destination activity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论活动之间的数据传输时，我们需要记住，管理与活动流程交互的唯一方式是通过意图。在上一章中，我们详细讨论了如何使用意图从一个活动移动到另一个活动。在这里，我们将看到如何将数据与这些意图一起传输，以及如何在目标活动中安全地捕获传输的数据。
- en: Data transfer in explicit intents
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式意图中的数据传输
- en: You can begin to understand data transfer in intents by noticing its use in
    explicit intents. Recalling the definition of explicit intents, they are intents
    that direct towards another activity (within that application or another application).
    Explicit intents are usually directed to activities within the same application,
    but based on the application requirement, they can also be directed to activities
    belonging to other applications (for example, a device camera).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过注意显式意图中数据传输的使用来开始理解意图中的数据传输。回想一下显式意图的定义，它们是指向另一个活动（在同一应用内或另一个应用内）的意图。显式意图通常指向同一应用内的活动，但根据应用需求，它们也可以指向属于其他应用的活动（例如，设备相机）。
- en: Methods of data transfer between activities
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动间数据传输的方法
- en: 'In this section, we will get started with the various data transfer techniques
    that are used in an Android application. The techniques have their own pros and
    cons. There are a total of three methods to transfer data explicitly from one
    activity to another. We will see them shortly along with their examples. The three
    methods are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始了解在Android应用程序中使用的各种数据传输技术。这些技术各有优缺点。总共有三种方法可以从一个活动显式地传输数据到另一个活动。我们很快就会看到它们以及它们的示例。这三种方法如下：
- en: Data transfer using `putExtras()`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`putExtras()`进行数据传输
- en: Data transfer using `Parcelable` (only applicable to custom data objects)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Parcelable`进行数据传输（仅适用于自定义数据对象）
- en: Data transfer using `Serializable` (only applicable to custom data objects)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Serializable`进行数据传输（仅适用于自定义数据对象）
- en: Data transfer using putExtras()
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用putExtras()进行数据传输
- en: In Android, the simplest way to transfer data from one activity to another is
    by sending it through extras. The intent extras support primitive data types to
    send the data. This means that you can send the data in the form of different
    data types such as `String`, `Boolean`, `Integer`, or `Float`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，将数据从一个活动传输到另一个活动的最简单方式是通过extras发送。意图extras支持原始数据类型以发送数据。这意味着你可以以不同的数据类型如`String`、`Boolean`、`Integer`或`Float`的形式发送数据。
- en: Theoretically explaining, intent extras can be found inside the `Intent` class
    in the Android API. Developers need to make an object of the `Intent` class. This
    would be the same object that will be used in order to navigate through the activity.
    With this object, there will be multiple polymorphs of the `putExtras()` function.
    These polymorphs take different data types (as described earlier) as arguments
    and load the intent object with that data. With this, the object is finalized.
    Now, calling the `startActivity()` method from the `Activity` class starts the
    execution of the intent.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，意图额外信息可以在 Android API 的 `Intent` 类中找到。开发者需要创建一个 `Intent` 类的对象。这个对象将用于在活动之间导航。有了这个对象，就会有
    `putExtras()` 函数的多种多态形式。这些多态形式接受不同的数据类型（如前所述）作为参数，并将意图对象加载到该数据中。这样，对象就完成了。现在，从
    `Activity` 类中调用 `startActivity()` 方法开始执行意图。
- en: That was one side of the picture. This intent takes the flow of application
    towards the second activity; it's an activity of the same application in the case
    of an explicit calling, or it can be some other application in the case of an
    implicit intent. This new activity will receive the intent object and extract
    the data from it. From this, there is another method referred to as `getExtras()`
    that is present in the `Intent` class. As a result, it will give all the extras
    that were added by the source activity in the intent object, and using this, we
    can easily extract the desired data present in the extras of the intent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是问题的一面。这个意图将应用程序的流程引导到第二个活动；在显式调用的情况下，它是同一应用程序的活动，或者在隐式意图的情况下，它可以是其他应用程序。这个新活动将接收意图对象并从中提取数据。因此，`Intent`
    类中还有另一个方法，称为 `getExtras()`。结果，它将给出源活动在意图对象中添加的所有额外信息，并使用它，我们可以轻松提取意图中额外信息中所需的数据。
- en: This theoretical explanation may not make you understand each and everything
    of the data transfer using intent. We will learn more about data transfer using
    intents through examples in the next section, in which a step-by-step explanation
    of the data transfer will be given.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论解释可能不会让你完全理解使用意图进行数据传输的每一个细节。我们将在下一节通过示例更多地了解使用意图进行数据传输，其中将给出数据传输的分步解释。
- en: Implementation of putExtras()
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`putExtras()` 的实现'
- en: In this section, we will study a step-by-step implementation of how to transfer
    data from one activity to another with the help of extras. As you may have previously
    read, this method is the simplest of all when considering data transferring between
    activities. In order to understand the working and implementation of this method,
    you must understand the activity life cycle, handling of different activities,
    and the implementation of intents in order to navigate between activities as prerequisites.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将逐步学习如何借助额外信息从一个活动向另一个活动传输数据。正如你可能之前读到的，考虑到活动之间的数据传输，这种方法是最简单的。为了理解这个方法的运作和实现，你必须了解活动生命周期、不同活动的处理以及意图的实现，以便在活动之间导航作为前提条件。
- en: In order to begin with the first example, the first step is to make an Android
    project. The steps for making a project in the Android Studio are described in
    the previous chapters; you may refer to them if you want. You will end up making
    a project with various numbers of files and folders (as it comes by default with
    the Android project).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始第一个示例，第一步是创建一个 Android 项目。在 Android Studio 中创建项目的步骤在之前的章节中已经描述；如果你需要，可以参考它们。你最终会创建一个带有许多文件和文件夹的项目（这是
    Android 项目的默认设置）。
- en: Implement a readymade tutorial
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现一个现成的教程
- en: For the sake of simplicity, we are using the name `Activity1` for the source
    activity and `Activity2` for the destination activity. Now, follow the given steps
    in order to successfully implement the example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将源活动命名为 `Activity1`，目标活动命名为 `Activity2`。现在，按照以下步骤成功实现示例。
- en: 'First, create a new Android project or choose any existing project in which
    you want to implement the data transfer with intents. Implement the following
    code inside your newly created project in their respective classes:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 Android 项目，或者选择你想要使用意图实现数据传输的任何现有项目。在你新创建的项目中，相应类里实现以下代码：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the project and the following screenshot will appear on the screen:![Implement
    a readymade tutorial](img/9639_05_13.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目，屏幕上会出现以下截图：![实现一个现成的教程](img/9639_05_13.jpg)
- en: The Acivity1.java layout for taking input from the user for PutExtra()
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Activity1.java`布局用于通过`PutExtra()`从用户处获取输入。'
- en: Fill the `EditText` fields and tap the button to transfer the data. The `Activity2`
    screen will appear with the form data that was entered in the `Activity1` screen:![Implement
    a readymade tutorial](img/9639_05_14.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写`EditText`字段并点击按钮以传输数据。`Activity2`屏幕将出现，并显示在`Activity1`屏幕中输入的表单数据：![实现一个现成的教程](img/9639_05_14.jpg)
- en: The view of the Activity2.java file, which shows that the data is successfully
    caught and showed.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Activity2.java`文件的视图，显示数据已成功捕获并显示。'
- en: Understanding the code
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解代码
- en: The previous subsection, *Implement a readymade tutorial*, consists of five
    parts that we will see in detail in the following sections. Like every example
    presented in this book, we have described this example with respect to a new project
    in order to make it flexible and easy to understand. You can easily put this example
    inside your own application; it will not take any extra effort to do it once you
    have a proper understanding of the intent extras.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节“*实现一个现成的教程*”包含五个部分，我们将在以下各节中详细查看。像本书中呈现的每个示例一样，我们已根据新项目描述此示例，以使其灵活且易于理解。你可以轻松地将此示例放入你自己的应用程序中；一旦你正确理解了意图额外信息，这样做不会花费额外的努力。
- en: The Activity1.java class
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Activity1.java`类'
- en: Getting started, this is the source activity that will initiate the intent in
    order to navigate to the next activity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开始，这是源活动，它将启动意图以导航到下一个活动。
- en: This is a simple activity that is built when the new Android project is created.
    Recalling the basics, it will have an `onCreate()` method that will be executed
    in the first place when the activity is created by Android. Once the activity
    is created, the layout that is defined in the `main_first.xml` file in the `Layout`
    folder will be rendered on the screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在创建新的Android项目时构建的简单活动。回顾基础知识，它将有一个`onCreate()`方法，该方法将在活动由Android创建时首先执行。一旦创建了活动，在`Layout`文件夹中的`main_first.xml`文件中定义的布局将在屏幕上呈现。
- en: 'Now, it is time to get the objects of all the `EditText` fields that are placed
    in the layout file. For this, we will add the following lines in the code which
    will find the View by ID and return the object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是获取布局文件中所有`EditText`字段对象的时候了。为此，我们将在代码中添加以下几行，通过ID查找视图并返回对象：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is good to use meaningful names for your objects. Since this book is meant
    for beginners who don't normally work on huge applications, the object names are
    given to make the code as simple as possible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的对象使用有意义的名称是很好的。由于这本书面向初学者，他们通常不处理大型应用程序，因此给出的对象名称是为了使代码尽可能简单。
- en: 'The `findViewById()` method belongs to the `Activity` class, whose purpose
    is to find the particular View that can be the child of any layout and return
    the object. Similarly, we will get the other two `EditText` objects by writing
    the following lines:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`findViewById()`方法属于`Activity`类，其目的是找到可以是任何布局子视图的特定视图并返回对象。同样，通过编写以下几行代码，我们将获得另外两个`EditText`对象：'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this moment, we have the objects of all the input fields that are present
    in the `Activity1.java` class. The next step is to implement the functionality
    of the button that will take the input from these fields, add them into the object
    of intent, and send it through.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们拥有`Activity1.java`类中所有输入字段的对象。下一步是实现按钮的功能，该功能将从这些字段获取输入，将它们添加到意图对象中，并发送出去。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The return type of the `findViewById()` method is an object of the `View` class.
    So, while using `findViewbyId()`, we need to cast the returning object into a
    particular class type. For understanding this, you can see that the View is being
    casted to `EditText` in the preceding code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`findViewById()`方法的返回类型是`View`类的对象。因此，在使用`findViewbyId()`时，我们需要将返回的对象强制转换为特定的类类型。为了理解这一点，你可以看到在前面的代码中，视图被转换为`EditText`。'
- en: Now, the next step is to implement the `OnClickListener()` method on the button.
    For this, the first step is to get the object of the button using a method similar
    to the one used in the input fields.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步是在按钮上实现`OnClickListener()`方法。为此，第一步是使用与输入字段类似的方法获取按钮对象。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we get the button object, we will implement the `setOnClickListener()`
    method with an argument, `OnClickListener()` and its implementation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了按钮对象，我们将使用参数`OnClickListener()`实现`setOnClickListener()`方法及其实现：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding line of code, we have attached an `OnClickListener()`
    object with `transferButton` along with its own `setOnClickListener` method. Keep
    in mind that it is still a raw method. It is now time to override the `onClick()`
    method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在前面的代码行中，我们已经为`transferButton`附加了一个`OnClickListener()`对象，以及它自己的`setOnClickListener`方法。请记住，它仍然是一个原始方法。现在，是时候重写`onClick()`方法了。
- en: 'In the preceding code, you can see that the definition of the `onClick()` method
    is given, and inside this method, we will get the data from the `EditText` fields
    and put it in the intent extras. As described in the code, the data is fetched
    from the `EditText` field by calling these lines on every `EditText` object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到给出了`onClick()`方法的定义，在这个方法中，我们将从`EditText`字段获取数据并将其放入意图额外数据中。如代码所述，通过在每个`EditText`对象上调用以下行来从`EditText`字段获取数据：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will get the current value present in the input field. We get the values
    of all the `EditText` fields and store them in `valueOne`, `valueTwo`, and `valueThree`
    consecutively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取输入字段中当前存在的值。我们获取所有`EditText`字段的值，并依次存储在`valueOne`、`valueTwo`和`valueThree`中。
- en: Now, as we have the data that is to be put inside the intent object, we make
    an object of the intent using the previously described method. We set the source
    and destination activities (that is, `Activity1.java` as the source and `Activity2.java`
    as the destination). The next step is to pass the values inside the code. The
    `Intent.putExtra(String name, String data)` method is the most suitable one to
    put the string value in extras.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了要放入意图对象中的数据，我们使用之前描述的方法创建一个意图对象。我们设置源活动和目标活动（即`Activity1.java`作为源活动，`Activity2.java`作为目标活动）。下一步是在代码中传递值。`Intent.putExtra(String
    name, String data)`方法最适合将字符串值放入额外数据中。
- en: 'The arguments of `putExtra()` is somewhat like the key-value pairs. The first
    argument, `name`, is basically the key by which it will be identified once it
    reaches the destination activity. The other one is simply the value that is to
    be transferred in the extra associated with that key. So, by following line, we
    put the string inside an intent object with a key:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`putExtra()`的参数有些像键值对。第一个参数`name`，基本上是到达目标活动后用来识别它的键。另一个就是与该键相关联的额外传输的值。因此，在下面的代码行中，我们使用一个键将字符串放入意图对象中：'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that the value of the first `EditText` field is placed inside the intent
    object with the key of `EDITTEXT_ONE_VALUE`, we repeat this information for the
    other two values. Once the values are loaded in the intent object, we call the
    `startActivity()` method to execute the intent.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将第一个`EditText`字段的值使用键`EDITTEXT_ONE_VALUE`放入了意图对象中，对于其他两个值，我们重复这一信息。一旦值被加载到意图对象中，我们就调用`startActivity()`方法来执行这个意图。
- en: The Activity2.java class
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Activity2.java`类'
- en: This is the destination class in which the incoming intent will be handled.
    This class contains a simple layout file with three `TextView` Views in order
    to show the values coming from the previous activity. In the `onCreate()` method
    the intent is received by the `getIntent()`method. This method belongs to the
    `Activity` class and is used to get the intent which will be navigating to it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理传入意图的目标类。这个类包含一个简单的布局文件，其中包含三个`TextView`视图，以显示来自前一个活动的值。在`onCreate()`方法中，意图是通过`getIntent()`方法接收的。这个方法属于`Activity`类，用于获取将导航到它的意图。
- en: 'There is a method inside the `Intent` class which is used to get all extras
    that are coming with that particular intent object. The following method is used
    to identify a particular set of data coming with the described key:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类中有一个方法，用于获取与特定意图对象一起到来的所有额外数据。以下方法用于识别带有描述键的特定数据集：'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The value associated with the key, `EDITTEXT_ONE_VALUE`, will be extracted from
    the intent object, and saved into the `valueOne` string. Similarly, all the data
    will be taken out of the intent object and saved in this destination class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与键`EDITTEXT_ONE_VALUE`关联的值将从意图对象中提取，并保存到`valueOne`字符串中。同样，所有的数据都将从意图对象中取出并保存在这个目标类中。
- en: Once the data is saved in the variables, it is time to get the objects of the
    `TextView` Views and set these values to it. As previously explained, the `TextView`
    Views are obtained using the `findViewById()` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据保存到变量后，是获取`TextView`视图的对象，并将这些值设置给它们的时候了。如前所述，使用`findViewById()`方法获取`TextView`视图。
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `setText()` method is used to set the text in `TextView`, and hence, it
    is saved by the value that is coming from the first activity. This is how the
    destination activity will get the data from the source activity using the `putExtras()`
    feature.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`setText()`方法用于在`TextView`中设置文本，因此它保存的是来自第一个活动传入的值。这就是目标活动如何通过使用`putExtras()`功能从源活动中获取数据。'
- en: The main_first.xml file
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main_first.xml文件
- en: The main_first.xml file is a simple XML file that contains three `EditText`
    fields used by the activity to take input from. Furthermore, it also has a button
    that is used to trigger the event in order to navigate to the next activity. The
    IDs for these Views are given as `edittext1`, `edittext2`, `edittext3`, and `button1`
    respectively.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: main_first.xml文件是一个简单的XML文件，其中包含三个`EditText`字段，用于活动从中获取输入。此外，它还包含一个按钮，用于触发事件以便导航到下一个活动。这些视图的ID分别被指定为`edittext1`、`edittext2`、`edittext3`和`button1`。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can make your desired layout file by dragging and dropping it in the GUI.
    The XML code of the layout file is simple, and explained in the previous chapters
    as well. But, keep in mind that *drag-and-drop is not recommended* especially
    for the new Android developers; so, the best way to implement it is via an XML
    file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在GUI中拖放来制作你想要的布局文件。布局文件的XML代码很简单，并且在之前的章节中也有解释。但是，请记住，*拖放特别不推荐*给新的Android开发者使用；因此，实现它的最佳方式是通过XML文件。
- en: The main_second.xml file
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main_second.xml文件
- en: This is the layout file for the second activity that is actually the destination
    and the data-receiving activity. The layout consists of the three `TextView` Views
    that are used to show `valueOne`, `valueTwo`, and `valueThree` as sent from `Activity1`,
    that is, the source activity.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个活动的布局文件，实际上它是目标活动和数据接收活动。布局包括三个`TextView`视图，用于显示从`Activity1`即源活动发送的`valueOne`、`valueTwo`和`valueThree`。
- en: The AndroidManifest.xml file
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: The `AndroidManifest.xml` file is the fundamental part of an Android application.
    It keeps track of the whole structure of the application. It contains all the
    activities, receivers, permissions, version-related issues, minimum and maximum
    SDK, and many other things. As we have two activities in our project, `Activity1`
    and `Activity2`, the `AndroidManifest.xml` file has these activities as also different
    things such as the application version name and the version code in the XML tags.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件是Android应用程序的基本部分。它跟踪整个应用程序的结构。它包含所有的活动、接收器、权限、与版本相关的问题、最小和最大SDK以及其他许多内容。由于我们的项目中有两个活动，`Activity1`和`Activity2`，因此`AndroidManifest.xml`文件中包含了这些活动以及像应用程序版本名称和版本代码等不同的内容。'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: No special permission is required to send the data from one activity to another,
    but in case of data writing and reading on the SD Card or internal memory, we
    do need certain permissions to fulfill the task.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个活动向另一个活动发送数据不需要特殊权限，但在SD卡或内部存储上进行数据读写时，我们确实需要某些权限来完成这项任务。
- en: Future considerations
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 未来的考虑事项
- en: Sending data through parcels is one of the basic techniques that is used by
    Android intents. It has many more improvements and efficient enhancements that
    we will further study in the following methods of data transferring. We should
    also keep in mind that this method is restricted to certain limited data types
    (given in the next section). In order to transfer the custom object from one activity
    to another, we need to use the next method of data transferring.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包裹发送数据是Android意图使用的基本技术之一。它有许多改进和效率提升，我们将在以下数据传输方法中进行进一步研究。我们还应该记住，这种方法仅限于某些特定的数据类型（在下一节中给出）。为了从从一个活动向另一个活动传输自定义对象，我们需要使用下一个数据传输方法。
- en: Extras supported data types
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持的数据类型
- en: 'Intent''s `putExtra()` method supports various data types that can be transferred
    to the destination activity. In the previous example, we used only one data type
    (`String`), but along with that, we can add various other data types. The methods
    are self-explanatory apart from `putParcelable()` and `putSerializable()`, which
    are the next major topics of this chapter. Take a look at the following screenshot
    showing the various data types:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Intent的`putExtra()`方法支持多种数据类型，可以传输到目标活动。在之前的示例中，我们只使用了一种数据类型（`String`），但除此之外，我们还可以添加其他各种数据类型。除了`putParcelable()`和`putSerializable()`之外，这些方法都是不言自明的，它们是本章的下一个主要话题。请查看以下截图，展示了各种数据类型：
- en: '![Extras supported data types](img/9639_05_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![支持的数据类型](img/9639_05_03.jpg)'
- en: Different data types that can be added inside the putExtras() intent
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 putExtras() 意图中添加的不同的数据类型
- en: The concept of Android Bundles
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安卓捆绑包（Android Bundles）的概念
- en: The Android data Bundle is a bundle in which various values can be added and
    sent together. For example, if we want to send multiple values via `putExtra()`,
    we create a Bundle, add all of those values inside that Bundle, and then send
    this Bundle with the `intent.putExtras()` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓数据 Bundle 是一个可以添加和一起发送各种值的捆绑包。例如，如果我们想通过`putExtra()`发送多个值，我们会创建一个 Bundle，将所有这些值添加到
    Bundle 中，然后使用`intent.putExtras()`方法发送此 Bundle。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can provide data directly to the intent by adding all the values individually
    to the intent, or the second method is to do it by adding all the values in the
    Bundle and sending it through the intent.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将所有值分别添加到意图中，以直接向意图提供数据，或者第二种方法是将所有值添加到 Bundle 中，并通过意图发送它。
- en: 'We will now take a look at how it is possible to provide data to the Bundle
    and send this Bundle to the next activity, by taking the previous activity and
    modifying it a little. While sending data from `Activity1`, instead of adding
    different values directly to the intent, we do the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何将数据提供给 Bundle，并通过修改上一个活动来将此 Bundle 发送到下一个活动。在从`Activity1`发送数据时，我们不是直接将不同的值添加到意图中，而是进行以下操作：
- en: '![The concept of Android Bundles](img/9639OS_05_06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![安卓捆绑包的概念](img/9639OS_05_06.jpg)'
- en: As you see in the code, `valueOne`, `valueTwo`, and `valueThree` are added inside
    the Bundle using the `newBundle.putString()` function with a unanimous key for
    each data value. Now, this Bundle is added inside the intent using the `intent.putExtras(newBundle)`
    function, and then we call the `startActivity()` function as it was called in
    the previous example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在代码中所见，`valueOne`、`valueTwo`和`valueThree`通过使用`newBundle.putString()`函数和每个数据值统一的关键字添加到
    Bundle 中。现在，这个 Bundle 通过`intent.putExtras(newBundle)`函数添加到意图中，然后我们像在之前的例子中一样调用`startActivity()`函数。
- en: 'On the destination activity, we can directly catch the data by extracting the
    data bundle first using the `getIntent().getExtras()` function. This will return
    the Bundle object, and by referencing that specific key (that we added in the
    source activity), we can extract the data using following function for all the
    three values:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标活动中，我们可以通过首先使用`getIntent().getExtras()`函数提取数据捆绑包直接捕获数据。这将返回 Bundle 对象，通过引用我们在源活动中添加的特定关键字，我们可以使用以下函数提取所有三个值的数据：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The second parameter in `Bundle.getString(key, defaultValue)` is the default
    value that will be returned if the value of the specified key is not found.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bundle.getString(key, defaultValue)`中的第二个参数是默认值，如果找不到指定键的值，将返回该默认值。'
- en: 'Take a look at the following screenshot. You will see the different data types
    that can be simultaneously added into a Bundle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图。你将看到可以同时添加到 Bundle 中的不同数据类型：
- en: '![The concept of Android Bundles](img/9639_05_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![安卓捆绑包的概念](img/9639_05_04.jpg)'
- en: Different functions that are used to add different data types inside a Bundle
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bundle 中添加不同数据类型的各种函数
- en: Data transfer using Parcelable
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Parcelable 进行数据传输
- en: The second and the most important method that is used to transfer data between
    activities is `Parcelable()`. The previous method has a restriction according
    to which we can only send the primitive data types such as `Strings`, `Integers`,
    `Doubles`, and `Floats`. In a practical scenario, when we work on projects, there
    are custom objects that we need to transfer between activities. These custom data
    objects hold information according to the need of the application. Hence, it should
    be transferred accordingly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动之间传输数据的第二个也是最重要的方法是`Parcelable()`。前面的方法有一个限制，即我们只能发送基本数据类型，如`Strings`、`Integers`、`Doubles`和`Floats`。在实际项目中，我们需要在活动之间传输自定义对象。这些自定义数据对象根据应用程序的需求保存信息。因此，应该相应地传输它们。
- en: As it is now clear that the previous version is for the data transfer of basic
    data types only, Parcelable can be called as the subtype of the previous type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很清楚，上一个版本仅用于基本数据类型的数据传输，而 Parcelable 可以被称为前一个类型的子类型。
- en: In this method, the data class is inherited by implementing the `Parcelable`
    class interface in order to make its object compatible with the `putExtra()` intent
    method. We also need to override some of the methods from the `Parcelable` class
    interface in order to give it the functionality. Once it is done, the object of
    that class can be placed inside the intent or the Bundle to navigate it through
    the activities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，数据类通过实现`Parcelable`类接口来继承，以使其对象与`putExtra()`意图方法兼容。我们还需要覆盖`Parcelable`类接口中的一些方法，以赋予其功能。一旦完成，该类的对象可以放入意图或Bundle中，以便在活动之间传递。
- en: Implementation of Parcelable
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Parcelable`的实现'
- en: 'In this section, we will learn how to implement `Parcelable` on a data class
    and then how to transfer that object between activities. There are two scenarios
    for this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在数据类上实现`Parcelable`，然后如何在不同活动之间传输该对象。对此有两种情况：
- en: Only one object is being sent from the source class to the destination class
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个对象从源类发送到目标类
- en: An array of the custom objects is being sent from the source class to the destination
    class
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义对象数组正在从源类发送到目标类
- en: Keeping the tradition, we will start by creating a new Android project. In the
    given example, we call it the Parcel application. This project has `Activity1.java`
    as the default activity that will be created when the project is newly created.
    It will also behave as the source activity. The second activity will be `Activity2.java`
    that will act as the destination activity that will receive the parcel.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照传统，我们将从创建一个新的Android项目开始。在给定的示例中，我们将其称为Parcel应用。该项目在创建时将创建`Activity1.java`作为默认活动，它也将作为源活动。第二个活动将是`Activity2.java`，它将作为接收parcel的目标活动。
- en: Implement a readymade tutorial
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现一个现成的教程
- en: Once we are done with making a new project, insert this code inside your application
    This will affect `Activity1.java`, `Activity2.java`, `layout_activity1.xml`, `layout_activity2.xml`,
    and `AndroidManifest.xml`, and introduce another class named `Person.java`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 完成新项目的创建后，将此代码插入到你的应用程序中。这将影响`Activity1.java`、`Activity2.java`、`layout_activity1.xml`、`layout_activity2.xml`和`AndroidManifest.xml`，并引入另一个名为`Person.java`的类。
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run this application and it will bring the `Activity1` output screen on your
    device. Take a look at the following screenshot to see how the application will
    appear on the Android screen:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序，它将在你的设备上显示`Activity1`的输出屏幕。查看以下截图，了解应用程序在Android屏幕上的显示效果：
- en: '![Implement a readymade tutorial](img/9639_05_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![实现一个现成的教程](img/9639_05_05.jpg)'
- en: Activity1 with three EditText fields in order to take the input from the user,
    and a button to transfer the data to the next activity
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity1`包含三个`EditText`字段以接收用户输入，以及一个按钮用于将数据传输到下一个活动'
- en: 'When you are on the first screen, enter the data and press the button to migrate
    to the next activity that will show the entered data. The screen will look as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处于第一个屏幕时，输入数据并按下按钮，迁移到下一个活动，该活动将显示输入的数据。屏幕将如下所示：
- en: '![Implement a readymade tutorial](img/9639_05_06.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![实现一个现成的教程](img/9639_05_06.jpg)'
- en: Activity2 showing the transferred data from Activity1 in the form of Parcelable
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity2`以`Parcelable`的形式显示从`Activity1`传输的数据'
- en: Understanding the Parcelable implementation
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解`Parcelable`实现
- en: In order to understand the working of this example, we need to first understand
    how `Parcelable` works. In Android, there is a need to transfer custom data (that
    is, custom objects and arrays of custom objects) from one activity to another.
    Normally, the custom data classes are not compatible with the extras; so, we implement
    the `Parcelable` interface to that class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解此示例的工作原理，我们首先需要了解`Parcelable`的工作方式。在Android中，需要将自定义数据（即自定义对象和自定义对象数组）从一个活动传输到另一个活动。通常，自定义数据类与extras不兼容；因此，我们为该类实现`Parcelable`接口。
- en: What `Parcelable` does with the custom data class is that it develops compatibility
    with extras. The object or objects of the class implemented using `Parcelable`
    can be added easily inside the `putExtra()` method of the intent. Similarly, it
    can also be part of the Bundle object that can later be transferred via intents.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parcelable`对自定义数据类的作用是它与extras兼容。使用`Parcelable`实现的类的对象可以轻松地添加到意图的`putExtra()`方法中。同样，它也可以成为Bundle对象的一部分，稍后可以通过意图进行传输。'
- en: We can now go through the explanation of the preceding code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以解释前面的代码。
- en: The Activity1.java class
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Activity1.java`类'
- en: This is the source class from which the `Parcelable` object will start to migrate.
    It starts with the implementation of the `onCreate()` method. In this method,
    after setting the main View, we found Views by their IDs and brought their objects
    to the activity. The Views include three `EditText` fields and a button. They
    are used to take inputs from the user and trigger the event in order to start
    transferring the data to the next activity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Parcelable`对象开始迁移的源类。它从实现`onCreate()`方法开始。在这个方法中，在设置主视图之后，我们通过它们的ID找到视图并将它们的对象带到活动中。这些视图包括三个`EditText`字段和一个按钮。它们用于获取用户的输入并触发事件，以便开始将数据传输到下一个活动。
- en: Inside the `button.setOnClickListener()` method, we pass a new `OnClickListener()`
    object inside which the `onClick()` method is overridden. We want the intent to
    start once the button is clicked; that is why we are implementing the intent and
    taking the data from the fields inside the `onClick()` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`button.setOnClickListener()`方法中，我们传递了一个新的`OnClickListener()`对象，在其中覆盖了`onClick()`方法。我们希望一旦点击按钮就启动意图，因此我们在`onClick()`方法中实现了意图，并从字段中获取数据。
- en: 'Now, we don''t want the method to directly transfer the data to the intent.
    That is why we are making an object of the `Person.java` class that will hold
    the values obtained from the fields. We name the object as `firstPerson`. In order
    to set the values to this object, we implement the following line of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不希望该方法直接将数据传输到意图中。这就是为什么我们要创建一个`Person.java`类的对象，该对象将保存从字段中获取的值。我们将这个对象命名为`firstPerson`。为了将值设置到这个对象中，我们实现了以下代码行：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding line will set the first name of that object to the value that
    is obtained from what is written inside the first `EditText` field. The first
    `EditText` field, `nameText`, holds the value of the first name. So, using the
    `nameText.getText()` method, it will return the `Editable` object that can be
    easily converted by calling the `toString()` method on it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行将把该对象的名字设置为从第一个`EditText`字段中获取的值。第一个`EditText`字段，`nameText`，保存了名字的值。因此，使用`nameText.getText()`方法，它将返回可以轻松通过调用其上的`toString()`方法转换的`Editable`对象。
- en: 'The same method will be repeated in order to get the value from the second
    and the third `EditText` fields. They will be set inside the same `Person` object.
    You can see this being done using the following lines of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从第二个和第三个`EditText`字段获取值，将重复相同的方法。它们将被设置在同一个`Person`对象中。你可以通过以下代码行看到这一操作：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this stage, the `firstPerson` object is ready to be delivered from `Activity1`
    to `Activity2`. As the object is inherited by implementing `Parcelable`, we can
    directly add it inside the extra. We will learn how to implement `Parcelable`
    in the forthcoming section. Here, we will see how to add `Parcelable` inside the
    intent object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`firstPerson`对象已经准备好从`Activity1`传递到`Activity2`。由于该对象是通过实现`Parcelable`来继承的，我们可以直接将其添加到额外数据中。我们将在接下来的部分学习如何实现`Parcelable`。在这里，我们将看到如何将`Parcelable`添加到意图对象中。
- en: 'Make an object of the `Intent` class and give it the source and destination,
    that is, the source context and `.class` reference of the destination class in
    order to let it know from where to initiate this intent and where to end. We can
    add the `Parcelable` by calling `parcelIntent.putExtra()`. See the following line
    of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Intent`类的对象，并为其提供源和目标，即源上下文和目标类的`.class`引用，以让它知道从哪里启动这个意图以及在哪里结束。我们可以通过调用`parcelIntent.putExtra()`来添加`Parcelable`。请看以下代码行：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using this, we can easily add the custom `Parcelable` data object inside the
    intent object, and in the next line, simply call the `startActivity()` function
    in order to start the intent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以轻松地将自定义的`Parcelable`数据对象添加到意图对象中，然后在下一行简单地调用`startActivity()`函数以启动意图。
- en: The Activity2.java class
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Activity2.java类
- en: In this class, we will learn how to catch the transmitted `Parcelable` object
    in the destination class. For this, first of all, start with the normal procedure
    of implementing the `onCreate()` method of the activity. Set the Content View
    and bring in three text Views by finding the IDs from the layout. These three
    text views will show the received values of the first activity's object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将学习如何在目标类中捕获传递的`Parcelable`对象。为此，首先按照实现活动的`onCreate()`方法的正常流程开始。设置内容视图并通过查找布局中的ID引入三个文本视图。这三个文本视图将显示第一个活动对象的接收值。
- en: The `getIntent()` method will receive the intent object that was transmitted
    by the `Activity1.java` class that holds the data. Once the object is obtained,
    we can get its extras by calling the `getExtras()` method that will return the
    Bundle that holds the data. Call the `getParcelable()` function on that Bundle
    with the key in order to retrieve the object. This object is now taken by a new
    object of the `Person` class named `incomingPersonObj`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`getIntent()`方法将接收由`Activity1.java`类传输的意图对象，该对象持有数据。一旦获取到对象，我们可以通过调用`getExtras()`方法来获取其额外信息，这将返回一个包含数据的`Bundle`。在那个`Bundle`上调用`getParcelable()`函数，并带上键，以获取对象。现在，这个对象被一个新的`Person`类对象`incomingPersonObj`接收。'
- en: 'Now, we have the same object that was initiated from the source class at the
    time of calling the intent from `startActivity()`. We will now set the text of
    the text views by calling the following lines of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个在从`startActivity()`调用意图时从源类初始化的相同对象。我们现在将通过调用以下代码行来设置文本视图的文本：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `incomingPersonObj.getFirstname()` method will get the first name of the
    person from `incomingPersonObj` and set its value directly to `nameTextView` when
    the first method is called. The procedure is the same for the `sirnameTextView`
    and `addressTextView` objects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`incomingPersonObj.getFirstname()`方法将从`incomingPersonObj`获取人的名字，并在第一次调用方法时直接将其值设置给`nameTextView`。对于`sirnameTextView`和`addressTextView`对象，过程相同。'
- en: The layout_activity1.xml file
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`layout_activity1.xml`文件'
- en: 'This is the layout file that contains the Views of `Activity1.java`. As mentioned
    in the code, it contains three `EditText` fields with the IDs: `edittext_enter_name`,
    `edittext_enter_sirname`, and `edittext_enter_address`. Apart from that there
    are also three text Views which are used to simply indicate which `EditText` field
    contains which value.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含`Activity1.java`视图的布局文件。如代码中所述，它包含三个`EditText`字段，其ID分别为：`edittext_enter_name`、`edittext_enter_sirname`和`edittext_enter_address`。除此之外，还有三个文本视图，用于简单地指示哪个`EditText`字段包含哪个值。
- en: Every activity requires an event trigger that is used to start any process.
    In this layout, the button will do the task; hence, it is also placed below the
    `EditText` fields.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动都需要一个事件触发器，用于启动任何进程。在这个布局中，按钮将执行任务；因此，它也被放置在`EditText`字段下方。
- en: The layout_activity2.xml file
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`layout_activity2.xml`文件'
- en: This layout file creates the layout of `Activity2.java` that is the destination
    activity. This activity is responsible for extracting the data and showing it
    in its layout. The layout consists of three `TextView` Views whose IDs are `person_name_text`,
    `person_sirname_text`, and `person_address_text`. These IDs are used to bring
    these Views to the code (as you can see in the second part of the code).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局文件创建了`Activity2.java`的布局，即目标活动。这个活动负责提取数据并在其布局中显示。布局包括三个`TextView`视图，其ID分别为`person_name_text`、`person_sirname_text`和`person_address_text`。这些ID用于将这些视图带到代码中（如代码的第二部分所示）。
- en: The Person.java class
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Person.java`类'
- en: The `Person` class is basically the data-holder class whose objects will be
    created anywhere in the application. This is also called the **bean class** that
    is used to hold the data coming from servers in JSON, XML, or any other format.
    In our `Person` class, it has three fields. All fields are private with their
    respective public getters and setters. The `firstName`, `sirName`, and `address`
    objects represent the kind of information they will hold. The `Activity1.java`
    class makes an object of this class, takes the data from the `EditText` fields,
    and adds it inside the object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类基本上是一个数据持有类，其对象将在应用程序的任何地方创建。这也被称为**豆类**，用于接收来自服务器以JSON、XML或其他任何格式的数据。在我们的`Person`类中，有三个字段。所有字段都是私有的，并具有它们各自的公共获取器和设置器。`firstName`、`sirName`和`address`对象表示它们将持有的信息类型。`Activity1.java`类创建了此类的一个对象，从`EditText`字段获取数据，并将其添加到对象内部。'
- en: This class is inherited by implementing the `Parcelable` interface. This `Parcelable`
    interface needs some important things to be implemented. First of all, we will
    implement a constructor of this class that will take `Parcel` as an argument.
    This constructor will be used from inside this class while implementing the `Parcelable`
    interface. The `in.readString()` method is used to read the value from the parcel.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类通过实现`Parcelable`接口来继承。这个`Parcelable`接口需要实现一些重要的事情。首先，我们将实现一个接受`Parcel`作为参数的此类构造函数。这个构造函数将在实现`Parcelable`接口时从类内部使用。`in.readString()`方法用于从包裹中读取值。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In order to make this technique work, read the parcel in the same order in which
    it was written in the `writeToParcel()` method. See the order of writing the parcel
    in the code. It is `firstName`, `sirName,` and `address`. The same thing can be
    observed in the constructor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这项技术工作，需要按照在`writeToParcel()`方法中写入的顺序读取Parcel。查看代码中写入Parcel的顺序。它是`firstName`、`sirName`和`address`。在构造函数中也可以观察到同样的顺序。
- en: The `writeToParcel()` method is overridden in order to produce objects of the
    same class by `Parcelable` so that it can be used. `Parcelable.Creator<Person>`
    is used to create instances of that class as used by `Parcel`; it uses the `writeToParcel()`
    method to do the job.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`writeToParcel()`方法是为了通过`Parcelable`生成同类对象，以便可以使用。`Parcelable.Creator<Person>`用于创建类的实例，供`Parcel`使用；它使用`writeToParcel()`方法来完成这项工作。
- en: Once the object is prepared, it is then forwarded to the next activity and caught
    by the `Activity2.java` class as it is explained in the first and second parts
    of the given code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好对象，就会将其转发到下一个活动，并由`Activity2.java`类捕获，如给定代码的第一和第二部分所解释的那样。
- en: The AndroidManifest.xml file
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AndroidManifest.xml文件
- en: The importance of this file cannot be neglected when you are talking about developing
    an Android application. We need to add both the activities in this file in order
    to get them recognized by the Android application. As you can see in the file,
    both activities have their own tags in the manifest file along with their parameters
    and intent filters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论开发Android应用程序时，这个文件的重要性不容忽视。我们需要在这个文件中添加这两个活动，以便它们被Android应用程序识别。如您在文件中所见，这两个活动在清单文件中都有自己的标签，以及它们的参数和意图过滤器。
- en: Future Consideration
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未来考虑
- en: The preceding method of implementing `Parcelable` is for transferring only one
    `Parcelable` object inside the extras or a Bundle. Similarly, we can transfer
    an Array or ArrayList of the custom data beans by implementing `Parcelable`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前述实现`Parcelable`的方法是用于在extras或Bundle中传输单个`Parcelable`对象的。同样，我们可以通过实现`Parcelable`来传输自定义数据豆的数组或ArrayList。
- en: Data transfer using Serializable
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Serializable进行数据传输
- en: The third type of data transfer method that is used in intents is `Serializable`.
    Many Java developers are already familiar with the term `Serializable` as it was
    used earlier, way before the introduction of Android. The biggest advantage of
    Android is that its development takes place on Java in SDK, and on C++ it's in
    NDK. This makes it extremely lenient and powerful.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在意图中使用的第三种数据传输方法是`Serializable`。许多Java开发人员已经熟悉`Serializable`这个词，因为它在Android引入之前就已经使用了。Android最大的优势在于，其开发在SDK中是Java，在NDK中是C++。这使得它非常灵活且强大。
- en: The same is the case with the functionality; `Java.io.Serializable` is purely
    a function of Java that can be used as it is in Android development. The `putExtras()`
    intent has an option of transferring the Java-serialized object from one activity
    to another without any specific amount of effort. We start this section with the
    introduction of `Serializable` for non-Java users.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 功能方面也是如此；`Java.io.Serializable`是纯Java功能，可以原封不动地在Android开发中使用。`putExtras()`意图有一个选项，可以在不进行任何特定努力的情况下将Java序列化对象从一个活动传输到另一个活动。我们从`Serializable`的介绍开始这一部分，供非Java用户了解。
- en: What is Serializable?
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是Serializable？
- en: Java comes with a mechanism in which an object can be represented in a byte
    array. It's not just the data that is serialized, but the information about the
    object type and what kind of data is placed inside the object can also be found
    in it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Java带有一个机制，可以将对象表示为字节数组。这里不仅序列化了数据，而且还可以找到关于对象类型以及对象内部放置了什么类型的数据的信息。
- en: These serialized objects can be written in the file and stored in any external
    storage (such as an SD Card). The process of remaking the object is called deserialization
    in which the information that is hidden inside the byte array can be gathered
    to regenerate the object in the memory at the time of need.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些序列化对象可以写入文件并存储在任何外部存储中（例如SD卡）。重新制作对象的过程称为反序列化，在这个过程中，可以收集隐藏在字节数组中的信息，以便在需要时在内存中重新生成对象。
- en: The process of making and remaking any serialized object is completely JVM independent.
    It means that the object can be serialized in Java and can be remade in any language
    that also supports JVM with the same Java version as at the time of making it
    serialized.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 制作和重新制作任何序列化对象的过程完全独立于JVM。这意味着可以在Java中序列化对象，并且可以在支持与序列化时相同版本的Java的JVM的任何语言中重新制作。
- en: In Java, the `ObjectOutputStream` class is used to serialize the object while
    the `ObjectInputStream` class is used to make an object when we are regenerating
    from an existing serialized object. These classes contain the `writeObject()`
    and `readObject()` methods respectively. The methods actually start the process
    of serialization or deserialization.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`ObjectOutputStream`类用于序列化对象，而`ObjectInputStream`类用于当我们从现有的序列化对象重新生成对象时。这些类分别包含`writeObject()`和`readObject()`方法。这些方法实际上开始了序列化或反序列化的过程。
- en: An example of Serializable
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Serializable`的一个例子'
- en: In this section, we will see how `Serializable` is done in Java. This is the
    inside mechanism of how Android handles these objects. This example contains two
    methods to perform the tasks of serialization and deserialization.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解Java中如何实现`Serializable`。这是Android处理这些对象的内部机制。这个例子包含两种方法，用于执行序列化和反序列化的任务。
- en: 'First of all, the method for serialization is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，序列化的方法如下：
- en: '![An example of Serializable](img/9639OS_05_10.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Serializable的一个例子](img/9639OS_05_10.jpg)'
- en: The `Person` class implements the `Serializable` interface. This will enable
    the object to be recognized by the `ObjectOutputStream` class's object. First
    of all, we will create a serialized object as shown in the code by setting the
    name and address.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类实现了`Serializable`接口。这将使对象能被`ObjectOutputStream`类的对象识别。首先，我们将通过设置名称和地址创建一个序列化的对象，如代码所示。'
- en: Once the object is created, it is ready to be serialized. We start by making
    an object of `FileOutputStream` that is used to write data into a file; the path
    that will refer to the location where that serialized file exists is also added.
    Make an `ObjectOutputStream` object that will have that file referenced by `ObjectOutputStream
    out = new ObjectOutputStream(fileOut)`. We are now ready to write the object by
    calling `out.writeObject(person)`. This will start to serialize the object (convert
    it to a byte array) and add it to the given location. We will then close the `out`
    and `fileOut` objects.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了对象，它就可以被序列化。我们从创建一个`FileOutputStream`对象开始，该对象用于将数据写入文件；同时添加将引用序列化文件所在位置的路径。创建一个将引用该文件的`ObjectOutputStream`对象，即`ObjectOutputStream
    out = new ObjectOutputStream(fileOut)`。现在我们可以通过调用`out.writeObject(person)`来写入对象。这将开始序列化对象（将其转换为字节数组）并将其添加到给定位置。然后我们将关闭`out`和`fileOut`对象。
- en: 'Reading data from a serialized source is the next step that we will see. See
    the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们将看到如何从序列化源读取数据。请看以下代码：
- en: '![An example of Serializable](img/9639OS_05_11.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Serializable的一个例子](img/9639OS_05_11.jpg)'
- en: The code is simple to understand because it contains almost the same steps as
    those required for writing an object as a serialized file. We will create an instance
    of the `Person` class to hold the remade object. The `FileInputStream` object
    is created. It directs towards the location of the file that is to be deserialized.
    The `ObjectInputStream` object is used to get that file path and make it ready
    to be read. Using this, the `in.readObject()` method is called in order to deserialize
    the object, and it will return the `person` object. Once it is done, we will close
    the `in` and `fileIn` objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很容易理解，因为它几乎包含了将对象写入序列化文件所需的所有步骤。我们将创建一个`Person`类的实例以保存重建的对象。创建`FileInputStream`对象。它指向要反序列化的文件的位置。使用`ObjectInputStream`对象获取该文件路径并使其准备好读取。通过这种方式，调用`in.readObject()`方法以反序列化对象，并将返回`person`对象。完成此操作后，我们将关闭`in`和`fileIn`对象。
- en: We now have the object of the deserialized `Person` class which can be in log
    or printed on the console.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了反序列化`Person`类的对象，可以在日志中或打印在控制台上。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The method of writing serializable objects in Java and Android are the same.
    While we are doing it in Android, we can write the file in an SD Card. The file
    can later be fetched and deserialized by any other activity or application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和Android中编写可序列化对象的方法是相同的。当我们在Android中执行此操作时，我们可以将文件写入SD卡。之后，该文件可以被任何其他活动或应用程序获取并反序列化。
- en: Implementation of Serializable
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Serializable`的实现'
- en: Until now, we have understood the main reasons of using `Serializable`. A quick
    review is always good. The `Serializable` technique is used to convert an object
    into byte array; we can use it to write into a file and store it as a `.ser` file
    on an SD card or any other storage. This serialized object can then be read from
    any location irrespective of the activity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经理解了使用 `Serializable` 的主要原因。快速复习总是好的。`Serializable` 技术用于将对象转换为字节数组；我们可以将其写入文件，并将其存储为
    SD 卡或其他存储设备上的 `.ser` 文件。然后可以在任何位置读取此序列化对象，而与活动无关。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Serializable` is the simplest method to perform data transfer. It is also
    used for transferring one or more custom data objects from one activity to another.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serializable` 是执行数据传输的最简单方法。它还用于从一个活动向另一个活动传递一个或多个自定义数据对象。'
- en: It is not necessary for serialized files to always have the `.ser` extension.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化文件不一定总是需要 `.ser` 扩展名。
- en: Just like the other examples and implementations, we will start this by making
    a fresh project. This project will have two activities; one will be the source
    and the other will be the destination. The serialized object will start to navigate
    from one activity, and the destination activity will catch it in order to extract
    data from it. Android supports the native Java procedure of serializing and deserializing
    the object; that is why, we don't have to do anything because the phenomenon of
    serialization is handled by Android itself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例和实现一样，我们将通过创建一个全新的项目来开始这一过程。这个项目将包含两个活动；一个作为源活动，另一个作为目标活动。序列化的对象将从其中一个活动开始导航，目标活动将捕捉它以便从中提取数据。Android
    原生支持 Java 的对象序列化和反序列化过程；因此，我们不需要做任何额外的工作，因为序列化的现象由 Android 自身处理。
- en: Passing Serializable – a tutorial
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传递可序列化对象 —— 教程
- en: In this chapter, the implementation of `Serializable` will start by making a
    new project. By default, this project will have one activity (let's say `Activity1.java`).
    Implement the following steps that will lead you to make a project in which `Serializable`
    is implemented. We will then see its explanation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将通过创建一个新项目来开始实现 `Serializable`。默认情况下，这个项目将包含一个活动（假设为 `Activity1.java`）。实施以下步骤，您将制作一个实现了
    `Serializable` 的项目。然后我们将了解其解释。
- en: 'Starting with the first step, implement the following code in your newly created
    Android project. This will introduce three new files:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一步开始，在您新创建的 Android 项目中实现以下代码。这将引入三个新文件：
- en: '`Activity2.java`: This will act as the destination activity.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity2.java`：这将作为目标活动。'
- en: '`layout_activity2.xml`: This file will hold the layout for the destination
    activity.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_activity2.xml`：这个文件将保存目标活动的布局。'
- en: '`Person.java`: This is the serialized class that is responsible for giving
    data beans'' objects.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.java`：这是负责提供数据豆（data beans）对象的序列化类。'
- en: '[PRE15]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you are done with the implementation, run the project. The following screen
    will appear in which you need to add your data into the fields. Then click on
    the **Enter Data** button:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 完成实现后，运行项目。将出现以下屏幕，您需要在字段中添加您的数据。然后点击 **Enter Data** 按钮：
- en: '![Passing Serializable – a tutorial](img/9639_05_07.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![传递可序列化对象 —— 教程](img/9639_05_07.jpg)'
- en: Source activity asking data to be entered to send it through serializable
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 源活动要求输入数据，以便通过序列化发送它
- en: 'As soon as you press the **Enter Data** button, `Activity2.java` will be opened
    and the following screen will be shown:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按下 **Enter Data** 按钮时，将打开 `Activity2.java`，并显示以下屏幕：
- en: '![Passing Serializable – a tutorial](img/9639_05_08.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![传递可序列化对象 —— 教程](img/9639_05_08.jpg)'
- en: Activity2 showing that the data is successfully entered
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Activity2 显示数据已成功输入
- en: 'Meanwhile, when you see the LogCat of the project, it will show the data that
    we logged in the `Activity2.java` file. See the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，当您查看项目的 LogCat 时，它将显示我们在 `Activity2.java` 文件中记录的数据。请看以下截图：
- en: '![Passing Serializable – a tutorial](img/9639_05_09.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![传递可序列化对象 —— 教程](img/9639_05_09.jpg)'
- en: LogCat showing the successful catching of data in Activity2
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: LogCat 显示在 Activity2 中成功捕捉到数据
- en: Walking through the Serializable code
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 漫步于 Serializable 代码中
- en: In order to understand the working of Serializable in Android, you need to go
    through the previously described details of `Serializable` in Java. We recommend
    you to have a look at this if you haven't already done so. In this section, we
    will rather focus on the explanation of the preceding example and how to implement
    it in an Android project.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Android中Serializable的工作原理，你需要回顾一下之前描述的Java中`Serializable`的细节。如果你还没有看过这部分内容，我们建议你查看一下。在本节中，我们将重点解释前面的示例以及如何在Android项目中实现它。
- en: For the sake of simplicity, we have divided it into six parts. The explanation
    of each part is given in detail.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将其分为六个部分。每个部分都有详细的解释。
- en: The Activity1.java class
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Activity1.java`类'
- en: The `Activity1.java` class will act as the source activity from which the intent
    will initiate. It will also act as the source activity because it is responsible
    for creating and sending the custom data object. Let's start with the very first
    part of the code, which is the implementation of the `Activity1.java` class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity1.java`类将作为启动意图的源活动。它还将作为源活动，因为它负责创建并发送自定义数据对象。让我们从代码的第一部分开始，即实现`Activity1.java`类。'
- en: As it was mentioned earlier, this class is responsible for taking data inputs
    from the user and making a data object out of it. Inside the `onCreate()` method,
    we will first set a particular layout that holds the Views using the `setContentView()`
    method. Once the layout is set, our next task is to bring those Views as objects
    in our Java code, as shown in the following code. This will help us perform various
    tasks on those objects that are bound on those Views in the layout.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个类负责从用户那里接收数据输入，并创建一个数据对象。在`onCreate()`方法中，我们首先会通过`setContentView()`方法设置一个特定的布局，该布局包含视图。布局设置完成后，我们的下一个任务是将这些视图作为对象带入到我们的Java代码中，如下面的代码所示。这将帮助我们执行这些对象上绑定在布局中的视图的各种任务。
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Calling the `findViewById()` function brings the particular View with which
    the ID is associated. We cast it to the `EditText` class, and take it inside the
    `edittext1`, `edittext2`, and `edittext3` objects respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`findViewById()`函数会带来与ID相关联的特定视图。我们将它强制转换为`EditText`类，并分别将其放入`edittext1`、`edittext2`和`edittext3`对象中。
- en: 'These three fields will be used to take the input from the user, but we need
    an event trigger that is used to navigate the user from one activity to another
    and is also responsible for data transferring. For that, we implement a button
    in the layout, and we will fetch it in the Java code by calling the `findViewById()`
    method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个字段将用于从用户那里获取输入，但我们需要一个事件触发器，用于从一个活动导航到另一个活动，并负责数据传输。为此，我们在布局中实现了一个按钮，并通过调用`findViewById()`方法在Java代码中获取它：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we have all the necessary views in our Java code. Our next step is to
    implement the button functionality, that is, what it will do when it is clicked
    on. For that, we need to implement an `OnClickListener` interface on this button:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的Java代码中有了所有必要的视图。下一步是实现按钮的功能，即它被点击时将执行什么操作。为此，我们需要在这个按钮上实现`OnClickListener`接口：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding line of code is responsible for setting the click listener on
    the button. It takes an argument of `OnClickListener` inside which we implement
    the `onClick()` method. This `onClick()` method will be responsible for assigning
    a job to the button:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行负责为按钮设置点击监听器。它接收一个`OnClickListener`参数，在其中我们实现了`onClick()`方法。这个`onClick()`方法将负责给按钮分配一个任务：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we are done with that, we will make an object of the `Person` class (the
    `Serializable` object) and set its values to the one that is obtained by taking
    the input from the `EditText` fields. Now, it has two parts; the first is to make
    a new object of the `Person` class. We will do this by calling its constructor:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们将创建一个`Person`类对象（`Serializable`对象），并将其值设置为从`EditText`字段获取的输入值。现在，它有两个部分；第一部分是创建`Person`类的新对象。我们将通过调用其构造函数来实现这一点：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the second part, we will get the values of the `EditText` object by calling
    the `getText()` method using that object. The `getText()` method returns an `Editable`
    object; so, in order to convert it into string, we call the `toString()` method
    on it. When you observe the code, we have performed all of these tasks together:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们将通过调用`getText()`方法获取`EditText`对象的值。`getText()`方法返回一个`Editable`对象；因此，为了将其转换为字符串，我们在其上调用`toString()`方法。当你观察代码时，我们会一起执行所有这些任务：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, the value from the `edittext1` object is brought and converted to `String`.
    Second, we are setting the person''s name by its value. We will further set `sirName`
    and `address` of the `person` object using a similar procedure:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`edittext1`对象获取值并将其转换为`String`。其次，我们通过其值设置人员的姓名。我们将使用类似的过程进一步设置`person`对象的`sirName`和`address`：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have an object that is ready to be transferred. We will now make an
    object of `Intent` and assign its source and destination activity''s contexts.
    It will represent which activity the intent is initiated and to which activity
    it will migrate. We will do this by calling the constructor:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有一个准备传输的对象。我们将创建一个`Intent`对象，并为其分配源活动和目的地活动的上下文。这将表示意图从哪个活动启动，以及它将迁移到哪个活动。我们将通过调用构造函数来实现这一点：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once the intent object is made, we will add the data object inside this intent
    and call the `startActivity()` method. In order to put the serialized object in
    the intent object, we will call the `intent.putExtra()` method. The final step
    for this part is to call the `startActivity()` method that will initiate the process
    of navigation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了意图对象，我们将在其中添加数据对象并调用`startActivity()`方法。为了将序列化对象放入意图对象中，我们将调用`intent.putExtra()`方法。这部分最后的步骤是调用`startActivity()`方法，该方法将启动导航过程。
- en: The Activity2.java class
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Activity2.java`类'
- en: The destination activity's main purpose is to catch the intent, extract data
    object from it, and show it in the Views. We start with the implementation of
    the `onCreate()` method. First, the layout is set by calling the `setContentView()`method
    of the `Activity` class. Now, it is time to catch the `intent` object that was
    initiated from the `Activity1.java` class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地活动的主要目的是捕捉意图，从中提取数据对象，并在视图中显示。我们从实现`onCreate()`方法开始。首先，通过调用`Activity`类的`setContentView()`方法来设置布局。现在，是时候捕捉从`Activity1.java`类启动的`intent`对象了。
- en: Just like the previous example in this chapter, we obtain the intent by calling
    the `getIntent()` function. This function returns an `intent` object that is used
    to launch this activity. Once the `intent` object is here, we call the `getExtras()`
    function. This will return a Bundle that contains all the extras that were added
    on this `intent` object by the sender activity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面的示例一样，我们通过调用`getIntent()`函数来获取意图。这个函数返回一个用于启动此活动的`intent`对象。一旦有了`intent`对象，我们就调用`getExtras()`函数。这将返回一个包含发送活动添加到这个`intent`对象的所有额外内容的Bundle。
- en: On this Bundle, we will now call the `getSerializable()` method that will bring
    the `Serializable` object with the help of the `key` value that is given to it
    by the sender activity. That `key` value should be identical to that of the sender
    activity; otherwise, it will return a null value that may result in the crashing
    of your application due to `NullPointException`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Bundle上，我们现在将调用`getSerializable()`方法，它将借助发送活动赋予的`key`值带来一个`Serializable`对象。那个`key`值应与发送活动的值相同；否则，它将返回一个可能导致应用因`NullPointException`而崩溃的空值。
- en: The `Person` object is now in hand with all the values. Our next task is to
    log these values in the LogCat so that we can verify it. A null-pointer check
    is implemented in order to see whether or not the object is null. If it is not
    null, we log its values by getting it from `person.getName`, `person.getSirName`
    and `person.getAddress`. If the object is null, it will say `Data Object is null`,
    and hence, it will not crash.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Person`对象已经包含了所有的值。我们接下来的任务是把这些值在LogCat中记录下来，以便我们可以验证它。实现了一个空指针检查，以查看对象是否为空。如果不为空，我们从`person.getName`、`person.getSirName`和`person.getAddress`获取并记录其值。如果对象为空，它会显示“Data
    Object is null”，因此不会崩溃。
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Person.java class
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Person.java`类'
- en: When we talk about transferring data from `Serializable`, the `Person.java`
    class is the most important class that we need to implement in order to do the
    transferring. We made a Java class that consists of three private string variables.
    Each one of them has its own getter and setter functions in order to get and set
    the value from outside of the class. As in the previous method, we implemented
    our data bean class using the `Parcelable` interface; here, we will implement
    our class with `Serializable`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论从`Serializable`传输数据时，`Person.java`类是我们需要实现的最重要的类。我们创建了一个Java类，其中包含三个私有字符串变量。每个变量都有自己获取和设置外部值的getter和setter函数。与前面的方法一样，我们使用`Parcelable`接口实现了我们的数据豆类；在这里，我们将使用`Serializable`实现我们的类。
- en: Once it is implemented, Android is ready to treat the objects of this class
    as `Serializable`. Now, whenever it is added inside the intent object, Android
    will transfer it as a byte array. This is a slow process as compared to `Parcelable`,
    but its slowness is not noticeable when we do it on few objects. If we want to
    apply this method where there are thousands of data objects, it may take some
    time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现，Android就可以将这个类的对象视为`Serializable`。现在，每当它被添加到意图对象中时，Android将以字节数组的形式传输它。与`Parcelable`相比，这是一个较慢的过程，但当我们只处理几个对象时，这种缓慢是不明显的。如果我们想在有数千个数据对象的地方应用这种方法，可能会花费一些时间。
- en: The layout_activity1.xml file
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`layout_activity1.xml`文件'
- en: The layout file belongs to the `Activity1.java` class. When you run the code
    for the first time, the layout that will appear is described in this layout file.
    In the `Activity1.java` class inside the `onCreate()` method, we used the `setContentView()`
    method in order to paste the user interface.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件属于`Activity1.java`类。当你第一次运行代码时，将显示这个布局文件中描述的布局。在`Activity1.java`类的`onCreate()`方法中，我们使用了`setContentView()`方法来粘贴用户界面。
- en: In this XML file, there are four Views; three of them are `EditText` fields
    that are placed to take input from the user in Activity1\. Apart from that, there
    is a button that is used to trigger an event after the data is completely filled
    in the fields. The IDs given to them are the default ones that were used by the
    `Activity1.java` class to fetch these Views inside the `.java` class, and `edittext1`,
    `edittext2`, and `edittext3` are the IDs for their respective fields.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个XML文件中，有四个视图；其中三个是`EditText`字段，用于在Activity1中接收用户输入。除此之外，还有一个按钮，用于在字段中完全填充数据后触发事件。给它们分配的ID是`Activity1.java`类默认使用的，用于在`.java`类中获取这些视图，`edittext1`、`edittext2`和`edittext3`分别是它们各自字段的ID。
- en: The layout_activity2.xml file
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`layout_activity2.xml`文件'
- en: This layout file contains the Views for the `Activity2.java` class. It consists
    of one `TextView` View that will tell us whether or not the values coming from
    the `Activity1.java` class have been correctly fetched. This text View will then
    show the **Data successfully caught** or **Data object is null** message in accordance
    with the data object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局文件包含了`Activity2.java`类所需的视图。它由一个`TextView`视图组成，该视图将告诉我们从`Activity1.java`类传来的值是否正确获取。这个文本视图将根据数据对象显示**数据成功捕获**或**数据对象为空**的消息。
- en: The AndroidManifest.xml file
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件'
- en: The `AndroidManifest.xml` file consists of all the activities, permissions,
    SDK information, version codes, and many other things. In short, it is used to
    keep all the information regarding the applications. In this, we have our activities,
    `Activity1.java` and `Activity2.java` classes along with their intent values.
    If you forgot to mention any of your activity in this file, it will produce an
    exception in the LogCat saying `ClassNotFoundException`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`文件包含所有的活动、权限、SDK信息、版本代码等许多其他内容。简而言之，它用于保存有关应用程序的所有信息。在这里，我们有我们的活动，`Activity1.java`和`Activity2.java`类以及它们的意图值。如果你忘记在这个文件中提及任何活动，它将在LogCat中产生异常，显示`ClassNotFoundException`。'
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`Parcelable` and `Serializable` are two methods used to transfer data objects
    from one activity to another. `Serializable` is the simplest one to implement
    while `Parcelable` is the fastest of all. In case you need to perform a task based
    on fewer objects and you want a simple solution, you should go for `Serializable`.
    But if you want a perfect method irrespective of the complexity of the implementation,
    you should go for `Parcelable`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parcelable`和`Serializable`是两种用于从一个活动传输数据对象到另一个活动的方法。`Serializable`是最简单实现的，而`Parcelable`是所有方法中最快的。如果你需要基于较少的对象执行任务，并且想要一个简单的解决方案，你应该选择`Serializable`。但是，如果你想要一个无论实现复杂性如何都完美的方法，你应该选择`Parcelable`。'
- en: Data and the implicit intents
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据和隐式意图
- en: In the preceding examples, the need of data transfer was described within an
    application. It is now very clear that any application is incomplete without the
    transfer and manipulation of data. In this section of the chapter, we will see
    the scenarios in which there is a need to transfer data to implicit intents.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，描述了应用程序内部数据传输的需求。现在非常清楚，没有数据的传输和处理，任何应用程序都是不完整的。在本章的这一部分，我们将看到需要将数据传输到隐式意图的场景。
- en: Recalling the definition of implicit intents, they are those intents that normally
    do not direct towards a specialized target rather they give the flow of the application
    to an outside application, or in other words, they start another activity in order
    to perform a certain task.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾隐式意图的定义，它们通常不会指向一个专门的目标，而是将应用程序的流程交给外部应用程序，或者换句话说，它们启动另一个活动以执行特定任务。
- en: The outside applications require some data from your application in order to
    perform tasks. We will now see the scenarios in which the data transfer in the
    form of URI is passed to the implicit intent.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 外部应用程序需要从你的应用程序中获取一些数据以执行任务。现在，我们将看到在哪种情况下，以URI形式的数据传递会传递给隐式意图。
- en: Viewing a map
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看地图
- en: Google Map can be initiated from your own application with a particular place.
    It means that you can send any location that you need to open in the Google Map
    via implicit intents. Based on the latitude and longitude, you can open a particular
    point in the Google Map. This latitude and longitude is given to the Google Map
    using a URI that is a way to send data to implicit intents.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从自己的应用程序启动谷歌地图，并定位到一个特定的地点。这意味着你可以通过隐式意图发送需要打开的任何位置到谷歌地图。基于纬度和经度，你可以打开谷歌地图上的一个特定点。这个纬度和经度通过URI传递给谷歌地图，这是向隐式意图发送数据的一种方式。
- en: 'In order to perform this task, we need to write the following line of code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这项任务，我们需要编写以下代码行：
- en: '![Viewing a map](img/9639OS_05_15.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![查看地图](img/9639OS_05_15.jpg)'
- en: There is a particular syntax according to which we need to write the URI string.
    In order to open the map with a particular location, the URI string consists of
    the `geo` keyword followed by the latitude and longitude (comma separated as shown
    in the code). This URI value is given to the implicit intent with the `android.content.Intent.ACTION_VIEW`
    action. This View action will take the URI and open the best available application
    to perform the task. We will then start the intent by calling the `startActivity(intent)`
    method.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定的语法，我们需要编写URI字符串。为了打开特定位置的地图，URI字符串包含`geo`关键字，后面跟着纬度和经度（如代码所示，以逗号分隔）。这个URI值通过`android.content.Intent.ACTION_VIEW`动作传递给隐式意图。这个视图动作将获取URI并打开最佳的应用程序来执行任务。然后，我们将通过调用`startActivity(intent)`方法启动意图。
- en: '![Viewing a map](img/9639_05_10.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![查看地图](img/9639_05_10.jpg)'
- en: Google Map View in an Android OS.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓操作系统中的谷歌地图视图。
- en: Opening a webpage
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开网页
- en: The implicit need of transferring data can also be categorized in case you want
    to open a webpage, where you need to open the default web browser with a particular
    loaded page . In this process, we need to transfer the URL that our application
    wants to open in the browser. This URL is also passed with the help of the `Uri.parse()`
    method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想打开网页，数据传递的隐式需求也可以按类别划分，你需要用特定的加载页面打开默认的网页浏览器。在这个过程中，我们需要传递应用程序想要在浏览器中打开的URL。这个URL也是通过`Uri.parse()`方法传递的。
- en: Tip
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that we are using the default web browser in this scenario. It
    is not the web View that comes as a part of an Android application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在此场景中我们使用的是默认的网络浏览器，并不是作为安卓应用程序一部分的网页视图。
- en: 'Implement the following lines of code in order to send and open the URL in
    the default web browser:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在默认的网络浏览器中发送并打开URL，请按顺序实现以下代码行：
- en: '![Opening a webpage](img/9639OS_05_17.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![打开网页](img/9639OS_05_17.jpg)'
- en: As you can see in the code, there is a string that contains the value (URL)
    that is to be opened in the web browser. This value is then entered in the constructor
    of the intent in the `Uri.parse()` function with an `Intent.ACTION_VIEW` action.
    This will choose the best available option to open the URL.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，有一个字符串包含要在网络浏览器中打开的值（URL）。这个值然后通过`Uri.parse()`函数的意图构造器中，使用`Intent.ACTION_VIEW`动作输入。这将选择最佳选项来打开URL。
- en: '![Opening a webpage](img/9639_05_11.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![打开网页](img/9639_05_11.jpg)'
- en: The view of a browser opening the Google.com webpage as called from our application
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器打开我们应用程序调用的Google.com网页的视图。
- en: Sending an e-mail
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: There is a probability that you need a function that needs to call the default
    Google Mail application with a particular typed e-mail and a particular recipient
    in your application. In this case, we again need to add the data, that is, the
    sender name, e-mail body, and e-mail subject into the intent object and start
    the activity with that.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要一种功能，在您的应用程序中调用默认的Google邮件应用程序，并指定一个特定的收件人和电子邮件内容。在这种情况下，我们同样需要将数据添加到意图对象中，即发件人姓名、电子邮件正文和电子邮件主题，然后启动该活动。
- en: 'In order to perform this task, we need to write the following lines of code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此任务，我们需要编写以下代码行：
- en: '![Sending an e-mail](img/9639OS_05_19.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![发送电子邮件](img/9639OS_05_19.jpg)'
- en: Make an `Intent` object with the `Intent.ACTION_SEND` action. Its work is to
    open the intent with the sending option. Now, it's time to add the data inside
    this object. The Android API caters to all the scenarios that can occur; hence,
    there are certain constants defined in the `Intent` class that can be used to
    uniquely identify the data by Android. `Intent.EXTRA_EMAIL` is the keyword constant
    that is used in the `putExtra()` method while you are giving an e-mail address
    to the intent. Similarly, there is a keyword constant for mentioning the subject
    in the extras; `Intent.EXTRA_SUBJECT` and `Intent.EXTRA_TEXT` will be used to
    add the body of the e-mail.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有`Intent.ACTION_SEND`动作的`Intent`对象。其作用是打开发送选项的意图。现在，是时候向这个对象中添加数据了。Android
    API考虑到了所有可能发生的场景；因此，在`Intent`类中有一些定义的常量，可用于由Android唯一标识数据。`Intent.EXTRA_EMAIL`是在使用`putExtra()`方法向意图提供电子邮件地址时使用的关键字常量。同样，在额外信息中提及主题也有一个关键字常量；`Intent.EXTRA_SUBJECT`和`Intent.EXTRA_TEXT`将用于添加电子邮件的正文。
- en: 'Once we call the application with these parameters, it will open Gmail with
    these parameters filled in the fields. It will look something similar to the following
    screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用这些参数调用应用程序，它将以这些参数填充字段的方式打开Gmail。它看起来会类似于以下截图：
- en: '![Sending an e-mail](img/9639_05_12.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![发送电子邮件](img/9639_05_12.jpg)'
- en: A view of the Gmail application as called by our application
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由我们的应用程序调用的Gmail应用程序视图
- en: Making a call
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拨打电话
- en: 'If you want to initiate a call with a certain number inside your application,
    you need to call the dialer intent. Using `Intent.ACTION_DIAL`, you can provoke
    the dialer intent with a particular number given as the URI. Follow the given
    code to implement the dialer functionality in your application:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在应用程序中启动一个特定号码的呼叫，您需要调用拨号器意图。使用`Intent.ACTION_DIAL`，您可以启动带有给定URI的特定号码的拨号器意图。按照以下代码，在您的应用程序中实现拨号器功能：
- en: '![Making a call](img/9639OS_05_21.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![拨打电话](img/9639OS_05_21.jpg)'
- en: The URI string contains the telephone number with which the dialer should initiate.
    Once the dialer is opened, it will show the number as it is written, and the user
    can now dial that number.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: URI字符串包含了拨号器应该启动的电话号码。一旦打开拨号器，它会显示号码原文，用户现在可以拨打这个号码。
- en: Miscellaneous scenarios
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他杂项场景
- en: There are various other scenarios that can be included in this chapter (such
    as calendar and time widgets), but due to limited space and constraints, we have
    taken only four scenarios into consideration. The implementation of data transferring
    between implicit intents is of extreme significance and can be done with great
    ease.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还可以包含其他各种场景（例如日历和时间小部件），但由于篇幅和限制，我们只考虑了四个场景。在隐式意图间实现数据传输至关重要，且可以非常轻松地完成。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a detailed learning of how to play with data inside
    an Android application. We learned how to transfer data from one activity to the
    other using different methods and the simple transfer of default data structures
    using the `putExtra()` function of Intent. The custom data objects or the array
    of custom data objects can be sent to another activity using `Parcelable` and
    `Serializable`. We also learned how to implement all these kinds of data-transferring
    methods in our Android application. At the end of the chapter, we briefly covered
    four scenarios in which the data is sent to other applications (using implicit
    intents) when calling them through intents from our application.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细学习了如何在Android应用程序内操作数据。我们了解到如何使用不同的方法将数据从一个活动传输到另一个活动，以及如何使用意图的`putExtra()`函数简单传递默认数据结构。自定义数据对象或自定义数据对象数组可以通过`Parcelable`和`Serializable`发送到另一个活动。我们还学习了如何在我们的Android应用程序中实现所有这些数据传输方法。在章节的最后，我们简要介绍了四种场景，在这些场景中，当通过意图从我们的应用程序调用其他应用程序时，数据会通过隐式意图发送到其他应用程序。
- en: This chapter is of great importance with respect to practical application development
    because transferring data between activities or even outside the application is
    a fundamental part of any Android application, and this can easily be done using
    Android intents.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节对于实际应用开发至关重要，因为活动间甚至应用外部的数据传递是任何Android应用程序的基本组成部分，而使用Android意图可以轻松实现这一功能。
- en: In the following chapters, we will study the use of intents for accessing the
    Android features. We will also see how the intent filters work, what are the basics
    of the broadcasting intents, and at the end, we will see the implementation of
    intent service and pending intents.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何使用意图来访问Android的特性。我们还将了解意图过滤器是如何工作的，广播意图的基础知识是什么，最后，我们将学习意图服务及待定意图的实现。
