- en: Chapter 10. Placing Applications in Domains
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章. 将应用程序置于域中
- en: In [Chapter 3](ch03.html "Chapter 3. Android Is Weird"), *Android Is Weird*,
    we introduced the zygote and that all applications, APKs in Android speak, emanate
    from the zygote just like services emanate from the `init` process. As such, they
    need to be labeled, as we did in the previous chapter. Recall that labeling is
    the same as placing a process in a domain of that label. Applications need to
    be labeled as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.html "第三章. 安卓古怪")，*安卓古怪*，我们介绍了zygote，所有应用程序（在安卓中称为APK）都源自zygote，就像服务源自`init`进程一样。因此，它们需要被标记，正如我们在前一章所做的那样。回想一下，标记等同于将进程放置在相应标签的域中。应用程序也需要被标记。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: APK is the file extension and format for installable application packages on
    Android. It's analogous to the desktop package formats like RPM (Redhat based)
    or DEB (Debian based).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: APK是安卓上可安装应用程序包的文件扩展名和格式。它类似于桌面包格式，如RPM（基于Redhat）或DEB（基于Debian）。
- en: 'In this chapter, we will learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: Properly label application private data directories and their runtime contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确标记应用程序的私有数据目录及其运行时上下文
- en: Further examine zygote and methods to secure it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步检查zygote及其安全方法
- en: Discover how a finished `mac_permssions.xml` file assigns `seinfo` value
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解一个完成的`mac_permssions.xml`文件是如何分配`seinfo`值的
- en: Create a new custom domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的自定义域
- en: The case to secure the zygote
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护zygote的情况
- en: Android applications with elevated permissions and capabilities are spawned
    from the zygote. An example of this is the system server, a large process comprised
    of native and non-native code hosting a variety of services. The system server
    houses the activity manager, package manager, GPS feeds and so on. The system
    server also runs with a highly sensitive UID of `system` (`1000`). Also, many
    OEMs package what are known as **system apps**, which are standalone applications
    running with the `system` UID.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓上具有提升权限和能力的应用程序是从zygote中产生的。一个例子就是系统服务器，这是一个由本地和非本地代码组成的大型进程，提供各种服务。系统服务器包含了活动管理器、包管理器、GPS信息等。系统服务器也以高度敏感的`system`
    UID（`1000`）运行。此外，许多OEM将所谓的**系统应用**打包，这些是使用`system` UID独立运行的应用程序。
- en: The zygote also spawns applications that do not need elevated permissions. All
    third-party applications represent this. Third party applications run as their
    own UID, separate from sensitive UIDs, such as `system`. Additionally, applications
    get spawned into various UIDs such as `media`, `nfc`, and so on. OEMs tend to
    define additional UIDs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: zygote还产生不需要提升权限的应用程序。所有第三方应用程序都属于这一类。第三方应用程序以自己的UID运行，与敏感的UID（如`system`）分开。此外，应用程序会被放入各种UID中，如`media`、`nfc`等。OEM倾向于定义额外的UID。
- en: 'It''s important to note that to get into a special UID, like `system`, you
    must be signed with the proper key. Android has four major keys used to sign applications:
    `media`, `platform`, `shared`, and `testkey`. They are located in `build/target/product/security`,
    along with a `README`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，要进入像`system`这样的特殊UID，你必须使用适当的密钥签名。安卓有四个主要密钥用于签名应用程序：`media`、`platform`、`shared`和`testkey`。它们位于`build/target/product/security`目录中，以及一个`README`文件。
- en: 'According to the `README`, the key usage is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`README`，密钥使用如下：
- en: '`testkey`: A generic key for packages that do not otherwise specify a key.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testkey`：对于那些没有指定密钥的包的通用密钥。'
- en: '`platform`: A test key for packages that are part of the core platform.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform`：为核心平台部分包的测试密钥。'
- en: '`shared`: A test key for things that are shared in the home/contacts process.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared`：用于在home/contacts进程中共享事物的测试密钥。'
- en: '`media`: A test key for packages that are part of the media/download system.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media`：用于媒体/下载系统中部分的包的测试密钥。'
- en: In order to request `system` UID for your application, you must be signed with
    the `platform` key. Possession of the private key is required to execute in these
    more privileged environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为你的应用程序请求`system` UID，你必须使用`platform`密钥进行签名。在这些更加特权的环境中执行，需要拥有私钥。
- en: As you can see, we have applications executing at a variety of permission levels,
    and trust levels. We cannot trust third party applications since they are created
    by unknown entities, and we can trust things signed with our private keys. However,
    before SELinux, application permissions were still bound by the same DAC permission
    limitations as those identified in [Chapter 1](ch01.html "Chapter 1. Linux Access
    Controls"), *Linux Access Controls*. Because of these properties, it makes the
    zygote a prime target for attack, as well as fortification with SELinux.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序在不同的权限级别和信任级别下执行。我们不能信任第三方应用程序，因为它们是由未知实体创建的，而我们可以信任使用我们的私钥签名的实体。然而，在SELinux之前，应用程序权限仍然受到与[第1章](ch01.html
    "第1章. Linux访问控制")中提到的*Linux访问控制*相同的DAC权限限制。由于这些特性，zygote成为了攻击的主要目标，同时也需要用SELinux来加固。
- en: Fortifying the zygote
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固zygote
- en: Now that we have identified a problem with zygote, the next step is understanding
    how to get applications into appropriate domains. We need either SELinux policy
    or code changes to place new processes into a domain. In [Chapter 9,](ch09.html
    "Chapter 9. Adding Services to Domains") *Adding Services to Domains*, we covered
    dynamic domain transitions with init-based services and the end of the chapter
    mentions the importance of the `exec()` syscall in the "Limitations on App Labeling"
    section. This is the trigger on which dynamic domain transitions occur. If there
    is no `exec` in the path, we would have to rely on code changes. However, one
    also has to consider the signing key in this security model, and there is no way
    in pure SELinux policy language to express the key the process was signed with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了zygote的问题，下一步就是了解如何将应用程序放入适当的域中。我们需要SELinux策略或代码更改来将新进程放入一个域中。在[第9章](ch09.html
    "第9章. 将服务添加到域")中，我们讨论了基于init服务的动态域转换，并在章节末尾提到了`exec()`系统调用在“应用程序标签限制”部分的重要性。这是动态域转换发生的触发器。如果路径中没有`exec`，我们将不得不依赖代码更改。但是，在这个安全模型中，我们还必须考虑签名密钥，而纯粹的SELinux策略语言无法表达进程签名的密钥。
- en: Rather than exploring the whole zygote, we can dissect the following patches
    that introduce application labeling into Android. Additionally, we can discover
    how the introduced design meets the requirements of respecting the signing key,
    working within the design of SELinux and the zygote.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必探索整个zygote，可以剖析以下引入应用程序标签到Android的补丁。此外，我们可以发现引入的设计如何满足尊重签名密钥、在SELinux和zygote的设计内工作的要求。
- en: Plumbing the zygote socket
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理zygote套接字
- en: In [Chapter 3](ch03.html "Chapter 3. Android Is Weird"), *Android Is Weird*,
    we learned that the zygote listens for requests to spawn a new application from
    a socket. The first patch to examine is [https://android-review.googlesource.com/#/c/31066/](https://android-review.googlesource.com/#/c/31066/).
    This patch modifies three files in the base frameworks of Android. The first file
    is `Process.java` in the method `startViaZygote()`. This method is the main entry
    point for other methods with respect to building string arguments and passing
    them to the zygote with `zygoteSendArgsAndGetResult()`. The patch introduces a
    new argument called `seinfo`. Later on, we will see how this gets used. It appears
    that this patch is plumbing this new `seinfo` argument over the socket. Note that
    this code is called external to the zygote process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. Android很奇怪")中，我们了解到zygote通过监听套接字来等待请求启动新的应用程序。要检查的第一个补丁是[https://android-review.googlesource.com/#/c/31066/](https://android-review.googlesource.com/#/c/31066/)。这个补丁修改了Android基础框架中的三个文件。第一个文件是`Process.java`中的`startViaZygote()`方法。这个方法是相对于构建字符串参数并将它们通过`zygoteSendArgsAndGetResult()`传递给zygote的其他方法的主要入口点。补丁引入了一个名为`seinfo`的新参数。稍后，我们将看到如何使用它。看起来这个补丁正在通过套接字传输这个新的`seinfo`参数。请注意，这段代码是在zygote进程外部调用的。
- en: The next file to look at in this patch is `ZygoteConnection.java`. This code
    executes from within the context. The patch starts off by declaring a string member
    variable `peerContext` in the `ZygoteConnection` class. In the constructor, this
    `peerContext` member is set to the value obtained from a call to `SELinux.getPeerContext(mSocket.getFileDescriptor())`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个补丁中要查看的下一个文件是`ZygoteConnection.java`。这段代码从上下文中执行。补丁首先在`ZygoteConnection`类中声明了一个字符串成员变量`peerContext`。在构造函数中，这个`peerContext`成员被设置为调用`SELinux.getPeerContext(mSocket.getFileDescriptor())`得到的值。
- en: 'Since the `LocalSocket` `mSocket` is a Unix domain socket under the hood, you
    can obtain the connected client''s credentials. In this case, the call to `getPeerContext()`
    gets the client''s security context, or in more formal terms, the process label.
    After the initialization, further down in method `runOnce()`, we see it being
    used in calls to `applyUidSecurityPolicy` and other `apply*SecurityPolicy` routines.
    The protected method `runOnce()` is called to read one start command from the
    socket and arguments. Eventually, after the `apply*SecurityPolicy` checks, it
    calls `forkandSpecialize()`. Each security policy check has been modified to use
    SELinux on top of the existing DAC security controls. If we review `applyUidSecurityPolicy`,
    we see they make the call:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层的`LocalSocket` `mSocket`是Unix域套接字，你可以获取连接客户端的凭据。在这种情况下，调用`getPeerContext()`获取客户端的安全上下文，或者更正式地说，是进程标签。初始化后，在方法`runOnce()`中进一步向下，我们看到它在调用`applyUidSecurityPolicy`和其他`apply*SecurityPolicy`例程时被使用。受保护的`runOnce()`方法被调用以从套接字读取一个启动命令和参数。最终，在`apply*SecurityPolicy`检查之后，它调用`forkandSpecialize()`。每个安全策略检查都已修改为在现有的DAC安全控制之上使用SELinux。如果我们审查`applyUidSecurityPolicy`，我们会看到他们进行如下调用：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example of a userspace leveraging mandatory access controls in what
    is known as an object manager. Additionally, a security check has been added for
    the mysterious `seinfo` string in the `applyseInfoSecurityPolicy()` method. All
    the security checks here for SELinux specify the target class `zygote`. So if
    we look into `sepolicy access_vectors`, we see the added class `zygote`. This
    is a custom class for Android and defines all the vectors checked in the security
    checks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用户空间利用强制访问控制的示例，这在对象管理器中是众所周知的。此外，在`applyseInfoSecurityPolicy()`方法中为神秘的`seinfo`字符串添加了一个安全检查。这里所有的SELinux安全检查都指定了目标类`zygote`。所以如果我们查看`sepolicy
    access_vectors`，我们会看到添加的类`zygote`。这是Android的一个自定义类，定义了所有在安全检查中检查的向量。
- en: The last file we'll consider from this patch is `ActivityManagerService.java`.
    The `ActivityManager` is responsible for starting applications and managing their
    lifecycles. It's a consumer of the `Process.start` API and needs to specify `seinfo`.
    This patch is simple, and for now, just sends `null`. Later, we will see the patch
    enabling its use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个补丁中考虑的最后一个文件是`ActivityManagerService.java`。`ActivityManager`负责启动应用程序并管理它们的生命周期。它是`Process.start`
    API的使用者，需要指定`seinfo`。这个补丁很简单，目前只是发送了`null`。稍后，我们将看到启用其使用的补丁。
- en: The next patch, [https://android-review.googlesource.com/#/c/31063/](https://android-review.googlesource.com/#/c/31063/),
    executes within the context of the Android Dalvik VM and is coded in the VM zygote
    process space. The `forkAndSpecialize()` we saw in `ZygoteConnection` ends up
    in this native routine. It enters using `static pid_t forkAndSpecializeCommon(const
    u4* args, bool isSystemServer)`. This routine is responsible for creating the
    new process that becomes the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个补丁，[https://android-review.googlesource.com/#/c/31063/](https://android-review.googlesource.com/#/c/31063/)，在Android
    Dalvik VM的上下文中执行，并在VM zygote进程空间中编码。我们在`ZygoteConnection`中看到的`forkAndSpecialize()`最终进入了这个本地例程。它通过`static
    pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)`进入。这个例程负责创建成为应用程序的新进程。
- en: It begins with housekeeping code moving from Java to C and sets up the `niceName`
    and `seinfo` values as C-style strings. Eventually, the code calls `fork()` and
    the child process starts doing things, like executing `setgid` and `setuid`. The
    `uid` and `gid` values are specified to the zygote connection with the `Process.start`
    method. We also see a new call to `setSELinuxContext()`. As an aside, the order
    of these events is important here. If you set the SELinux context of the new process
    too early, the process would need additional capabilities in the new context to
    do things like `setuid` and `setgid`. However, those permissions are best left
    to the `zygote` domain, so the application domain we entered can be as minimal
    as possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它从Java开始，将清理代码移动到C，并设置C风格字符串的`niceName`和`seinfo`值。最终，代码调用`fork()`，子进程开始执行操作，如执行`setgid`和`setuid`。`uid`和`gid`值通过`Process.start`方法指定给zygote连接。我们还看到一个对`setSELinuxContext()`的新调用。顺便说一下，这些事件的顺序在这里很重要。如果你太早设置新进程的SELinux上下文，那么进程在新上下文中需要额外的能力才能执行像`setuid`和`setgid`这样的操作。然而，这些权限最好留给`zygote`域，这样我们进入的应用程序域可以尽可能最小化。
- en: Continuing, `setSELinuxContext` eventually calls `selinux_android_setcontext()`.
    Note that the `HAVE_SELINUX` conditional compilation macros were removed after
    this commit, but prior to the 4.3 release. Also note that `selinux_android_setcontext()`
    is defined in `libselinux`, so our journey will take us there. Here we see the
    mysterious `seinfo` is still being passed along.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，`setSELinuxContext`最终调用了`selinux_android_setcontext()`。注意，在这个提交之后，移除了`HAVE_SELINUX`条件编译宏，但在4.3版本发布之前。还要注意，`selinux_android_setcontext()`在`libselinux`中定义，所以我们的旅程将带我们到那里。在这里我们看到神秘的`seinfo`仍然在传递。
- en: The next patch to evaluate is [https://android-review.googlesource.com/#/c/39601/](https://android-review.googlesource.com/#/c/39601/).
    This patch actually passes a more meaningful `seinfo` value from the Java layer.
    Rather than being set to `null`, this patch introduces some parsing logic from
    an XML file, and passes this along to the `Process.start` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要评估的补丁是[https://android-review.googlesource.com/#/c/39601/](https://android-review.googlesource.com/#/c/39601/)。这个补丁实际上从Java层传递了一个更有意义的`seinfo`值。这个补丁没有设置为`null`，而是引入了从XML文件中解析的逻辑，并将其传递给`Process.start`方法。
- en: 'This patch modifies two major components: `PackageManager` and `installd`.
    `PackageManager` runs inside the `system_server`, and performs application installation.
    It maintains the state of all installed packages in the system. The second component,
    a service known as `installd`, is a very privileged root service that creates
    all the applications'' private directories on disk. Rather than giving system
    server, and therefore `PackageManager`, the capability to create these directories,
    only `installd` has these permissions. Using this approach, even the system server
    cannot read data in your private data directories unless you make it world readable.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补丁修改了两个主要组件：`PackageManager`和`installd`。`PackageManager`在`system_server`内部运行，执行应用程序安装。它维护系统中所有已安装包的状态。第二个组件，称为`installd`的服务，是一个非常特权级的root服务，在磁盘上创建所有应用程序的私有目录。这种方法不是给系统服务器，因此`PackageManager`提供创建这些目录的能力，只有`installd`拥有这些权限。即使系统服务器也无法读取您的私有数据目录中的数据，除非您将其设置为全局可读。
- en: This patch is larger than the others, so we are only going to inspect the parts
    directly relevant to our discussion. We'll start by looking at `PackageManagerService.java`.
    This class is the package manager, proper for Android. In the constructor for
    `PackageManagerService()`, we see the addition of `mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补丁比其他的要大，因此我们只检查与讨论直接相关的部分。我们将从查看`PackageManagerService.java`开始。这个类是Android的包管理器。在`PackageManagerService()`的构造函数中，我们看到了添加了`mFoundPolicyFile
    = SELinuxMMAC.readInstallPolicy();`这一行。
- en: Based on the naming, we can conjecture that this method is looking for some
    type of policy configuration file, and if found, returns true, setting the `mFoundPolicyFile`
    member variable. We also see some calls to `createDataDirs` and `mInstaller.*`
    calls. These we can ignore, since those calls are headed to `installd`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据命名，我们可以推测这个方法是在寻找某种策略配置文件，如果找到，返回true，并设置`mFoundPolicyFile`成员变量。我们还看到一些对`createDataDirs`和`mInstaller.*`的调用。我们可以忽略这些，因为那些调用是发送给`installd`的。
- en: 'The next major portion adds the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主要部分添加了以下内容：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's important to note that this code was added into the `scanPackageLI()` method.
    This method is called every time a package needs to be scanned for installation.
    So at a high level, if some policy file is found during service startup, then
    a `seinfo` value is assigned to the package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意这段代码被添加到了`scanPackageLI()`方法中。每次需要扫描包以进行安装时，都会调用这个方法。因此，在高级别上，如果在服务启动期间找到某些策略文件，那么就会为包分配一个`seinfo`值。
- en: The next file to look at is `ApplicationInfo.java`, a container class for maintaining
    meta information about a package. As we can see, the `seinfo` value is specified
    here for storage purposes. Additionally, there is some code for serializing and
    deserializing the class via the Android specific `Parcel` implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要查看的文件是`ApplicationInfo.java`，这是一个用于维护关于包的元信息的容器类。正如我们所见，`seinfo`值在这里指定以供存储。此外，还有一些通过Android特定的`Parcel`实现序列化和反序列化类的代码。
- en: At this point, we should have a closer look at the `SELinuxMMAC.java` code to
    confirm our understanding of what's going on. The class starts by declaring two
    locations for policy files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该仔细查看`SELinuxMMAC.java`代码，以确认我们对正在发生的事情的理解。这个类开始时声明了两个策略文件的位置。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'According to this, policy files can exist in two locations- `/data/system/mac_permissions.xml`
    and `/system/etc/security/mac_permissions.xml`. Eventually, we see the call from
    `PackageManagerService` initialization to the method defined in the class `readInstallPolicy()`,
    which eventually reduces to a call of:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个，策略文件可以存在于两个位置：`/data/system/mac_permissions.xml`和`/system/etc/security/mac_permissions.xml`。最终，我们看到`PackageManagerService`初始化时对类中定义的方法`readInstallPolicy()`的调用，最终简化为以下调用：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With `policyFiles` set to `INSTALL_POLICY_FILE`, this code uses the array to
    find a file at the specified locations. It is priority based, with the `/data`
    location taking precedence over `/system`. The rest of the code in this method
    looks like parsing logic and fills up two hash tables that were defined in the
    class declaration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当`policyFiles`设置为`INSTALL_POLICY_FILE`时，这段代码使用数组在指定位置查找文件。它是基于优先级的，`/data`位置优先于`/system`。这个方法中的其余代码看起来像解析逻辑，并填充了在类声明中定义的两个哈希表：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `sSigSeinfo` maps `Signatures`, or signing keys, to `seinfo` strings. The
    other map, `sPackageSeinfo` maps a package name to a string.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`sSigSeinfo`将`Signatures`（或签名密钥）映射到`seinfo`字符串。另一个映射`sPackageSeinfo`将包名映射到字符串。'
- en: At this point, we can read some formatted XML from the `mac_permissions.xml`
    file and create internal mappings from signing key to `seinfo` and package name
    to `seinfo`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以从`mac_permissions.xml`文件中读取一些格式化的XML，并从签名密钥到`seinfo`以及包名到`seinfo`创建内部映射。
- en: The other call from `PackageManagerService` into this class came from `void
    assignSeinfoValue(PackageParser.Package pkg)`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackageManagerService` 类调用这个类的另一个方法来自于 `void assignSeinfoValue(PackageParser.Package
    pkg)`。'
- en: 'Let''s investigate what this method can do. It starts by checking if the application
    is system UID or a system installed app. In other words, it checks whether the
    application is a third-party application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一下这个方法能做什么。它首先检查应用程序是否为系统UID或系统安装的应用程序。换句话说，它检查应用程序是否为第三方应用程序：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code has subsequently been dropped by Google, and was initially a requirement
    for merge. We can, however, continue our evaluation. The code loops over all the
    signatures in the package, and checks against the hash table. If it is signed
    with something in that map, it uses the associated `seinfo` value. The other case
    is that it matches by package name. In either case, the package''s `ApplictionInfo`
    class `seinfo` value is updated to reflect this and be used elsewhere by `installd`
    and zygote application spawn:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码后来被谷歌删除，最初是合并的要求。然而，我们可以继续进行评估。代码遍历包中的所有签名，并与哈希表进行对比。如果它使用该映射中的某个内容签名，它就会使用关联的`seinfo`值。另一种情况是它通过包名匹配。在任一情况下，包的`ApplictionInfo`类的`seinfo`值都会更新以反映这一点，并供`installd`和zygote应用程序生成在其他地方使用：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As an aside, what is merged into mainline AOSP and what is maintained in the
    NSA Bitbucket repositories is a bit different. The NSA has additional controls
    in these policy files that can cause an application installation to abort. Google
    and the NSA are "forked" over this issue, so to speak. In the NSA versions of
    `SELinuxMMAC.java`, you can specify that applications matching a specific signature
    or package name are allowed to have certain sets of Android-level permissions.
    For instance, you can block all applications from being installed that request
    `CAMERA` permissions or block applications signed with certain keys. This also
    highlights how important it can be to find patches within large code bases and
    quickly come up to speed on how projects evolve, which can often seem daunting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便一提，主线AOSP（Android Open Source Project）中合并的内容与NSA在Bitbucket仓库中维护的内容略有不同。NSA在这些策略文件中有额外的控制，可能导致应用程序安装被终止。可以说，谷歌和NSA在这个问题上“分道扬镳”。在NSA版本的`SELinuxMMAC.java`中，你可以指定匹配特定签名或包名的应用程序被允许拥有某些Android级别的权限集。例如，你可以阻止所有请求`CAMERA`权限的应用程序安装，或者阻止使用某些密钥签名的应用程序。这也突显了在大型代码库中找到补丁并快速了解项目如何发展的重要性，这往往可能显得有些困难。
- en: The last file in this patch for us to consider is `ActivityManagerService.java`.
    This patch replaces the null with `app.info.seinfo`. After all that work and all
    that plumbing, we finally have the mystical `seinfo` value fully parsed, associated
    per application package, and sent along to the zygote for use in `selinux_android_setcontext()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个补丁中，我们需要考虑的最后一个文件是`ActivityManagerService.java`。这个补丁用`app.info.seinfo`替换了null。经过所有这些工作和管道铺设，我们最终有了完全解析的神秘的`seinfo`值，与每个应用程序包关联，并传递给zygote，在`selinux_android_setcontext()`中使用。
- en: Now it would benefit us to sit back and think about some of the properties we
    wanted to achieve in labeling applications. One of them is to somehow couple a
    security context with the application signing key, and this is precisely the main
    benefit of `seinfo`. This is a highly sensitive and trusted string associated
    value of a signing key. The actual contents of the string are arbitrary and dictated
    in `mac_permissions.xml`, which is the next stop on our adventure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下，我们希望在标记应用程序时实现的一些属性。其中之一是以某种方式将安全上下文与应用程序签名密钥耦合，这正是 `seinfo` 的主要好处。这是一个高度敏感且受信任的与签名密钥相关联的字符串值。字符串的实际内容是任意的，在
    `mac_permissions.xml` 中指定，这是我们冒险旅程的下一站。
- en: The mac_permissions.xml file
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`mac_permissions.xml` 文件'
- en: The `mac_permissions.xml` file has a very confusing name. Expanded, the name
    is MAC permissions. However, its major mainline functionality is to map a signing
    key to a `seinfo` string. Secondarily, it can also be used to configure a non-mainstream
    install-time permission-checking feature, known as install time MMAC. MMAC controls
    are part of the NSA's work to implement mandatory access controls in the middleware
    layer. MMAC stands for "Middleware Mandatory Access Controls". Google has not
    merged any of the MMAC features. However, since we used the NSA Bitbucket repositories,
    our code base contains these features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`mac_permissions.xml` 文件的名字非常容易混淆。展开来看，名字是MAC权限。然而，其主要主流功能是将签名密钥映射到一个 `seinfo`
    字符串。其次，它还可以用于配置非主流的安装时权限检查功能，称为安装时MMAC。MMAC控制是国家安全局（NSA）在中层实现强制访问控制工作的一部分。MMAC代表“中间件强制访问控制”。谷歌没有合并任何MMAC功能。但是，由于我们使用了NSA的Bitbucket仓库，我们的代码库包含了这些功能。'
- en: 'The `mac_permissions.xml` is an XML file, and should adhere to the following
    rules, where italicized portions are only supported on NSA branches:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`mac_permissions.xml` 是一个XML文件，应遵循以下规则，其中斜体部分仅在NSA分支上支持：'
- en: A signature is a hex encoded X.509 certificate and is required for each signer
    tag.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名是一个十六进制编码的X.509证书，每个签名者标签都需要。
- en: 'A `<signer signature="" >` element may have multiple child elements:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<signer signature="" >` 元素可能有多个子元素：'
- en: '`allow-permission`: It produces a set of maximal allowed permissions (whitelist)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow-permission`：它生成一组最大允许的权限集合（白名单）。'
- en: '`deny-permission`: It produces a blacklist of permissions to deny'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deny-permission`：它生成一个要拒绝的权限黑名单。'
- en: '`allow-all`: It is a wildcard tag that will allow every permission requested'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow-all`：这是一个通配符标签，将允许所有请求的权限。'
- en: '`package`: It is a complex tag which defines allow, deny, and wildcard sub-elements
    for a specific package name protected by the signature'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：这是一个复杂的标签，定义了一个特定包名的签名保护的允许、拒绝和通配符子元素。'
- en: Zero or more global `<package name="">` tags are allowed. These tags allow a
    policy to be set outside any signature for specific package names.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个全局 `<package name="">` 标签是被允许的。这些标签允许在特定包名的外部设置策略，不受任何签名限制。
- en: A `<default>` tag is allowed that can contain install policy for all apps not
    signed with a previously listed cert and not having a per package global policy.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用 `<default>` 标签，其中可以包含未使用先前列出的证书签名的所有应用的安装策略，且没有每个包的全局策略。
- en: Unknown tags at any level are skipped.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何级别的未知标签将被跳过。
- en: Zero or more signer tags are allowed.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个签名者标签是被允许的。
- en: Zero or more package tags are allowed per signer tag.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个签名者标签允许零个或多个包标签。
- en: A `<package name="">` tag may not contain another `<package name="">` tag. If
    found, it's skipped.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<package name="">` 标签可能不包含另一个 `<package name="">` 标签。如果发现，则跳过。'
- en: 'When multiple sub-elements appear for a tag, the following logic is used to
    ultimately determine the type of enforcement:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个标签出现多个子元素时，以下逻辑用于最终确定执行类型：
- en: A blacklist is used if at least one deny-permission tag is found.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果至少找到一个 deny-permission 标签，则使用黑名单。
- en: A whitelist is used, if not a blacklist, and at least one allow-permission tag
    is found.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有黑名单，则使用白名单，并且至少找到一个 allow-permission 标签。
- en: A wildcard (accept all permissions) policy is used if not a blacklist and not
    a whitelist, and at least one allow-all tag is present.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有黑名单和白名单，且至少存在一个 allow-all 标签，则使用通配符（接受所有权限）策略。
- en: If a `<package name="">` sub-element is found, then that sub-element's policy
    is used according to the earlier logic and overrides any signature global policy
    type.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到 `<package name="">` 子元素，则根据之前的逻辑使用该子元素的策略，并覆盖任何签名全局策略类型。
- en: In order for a policy stanza to be enforced, at least one of the preceding situations
    must apply. Meaning, empty signer, default or package tags will not be accepted.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使策略段落得到执行，至少需要满足前述情况之一。这意味着，不接受空签名人、默认或软件包标签。
- en: Each `signer/default/package` (global or attached to a signer) tag is allowed
    to contain one `<seinfo value=""/>` tag. This tag represents additional info that
    each app can use in setting an SELinux security context on the eventual process.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`signer/default/package`（全局或附加到签名人）标签允许包含一个`<seinfo value=""/>`标签。这个标签表示每个应用程序可以在设置SELinux安全上下文时使用的附加信息，在最终的处理过程中。
- en: Strict enforcing of any XML stanza is not enforced in most cases. This mainly
    applies to duplicate tags, which are allowed. In the event that a tag already
    exists, the original tag is replaced.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，并不严格执行任何XML段落的规则。这主要适用于允许的重复标签。如果已经存在一个标签，则原始标签将被替换。
- en: There are also no checks on the validity of permission names. Although valid
    Android permissions are expected, nothing prevents unknowns.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时也没有检查权限名称的有效性。尽管预期是有效的安卓权限，但并未阻止未知权限。
- en: 'Following are the enforcement decisions:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是执行决策：
- en: All signatures used to sign an app are checked for policy according to signer
    tags. However, only one of the signature policies has to pass.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于签署应用程序的所有签名都将根据签名人标签检查策略。然而，只有一个签名策略需要通过。
- en: In the event that none of the signature policies pass, or none even match, then
    a global package policy is sought. If found, this policy mediates the install.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有的签名策略都未通过，或者没有任何匹配项，那么将寻求全局软件包策略。如果找到，此策略将调解安装。
- en: The default tag is consulted last, if needed.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，最后将咨询默认标签。
- en: A local package policy always overrides any parent policy.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地软件包策略总是覆盖任何父策略。
- en: If none of the cases apply, then the app is denied.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有任何情况适用，那么应用程序将被拒绝。
- en: 'The following examples ignore the Install MMAC support and focus on the mainline
    usage of `seinfo` mapping. The following is an example of stanza mapping all things
    signed with the platform key to `seinfo` value platform:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例忽略了安装MMAC支持，并专注于`seinfo`映射的主要用途。以下是将所有使用平台密钥签名的项映射到`seinfo`值平台的段落映射示例：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example mapping all things signed with the release key to the release
    domain with the exception of the browser. The browser gets assigned a `seinfo`
    value of `browser`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个将使用发布密钥签名的所有内容映射到发布域的示例，但浏览器除外。浏览器被分配了一个`seinfo`值为`browser`，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Anything with an unknown key, gets mapped to the default tag:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有未知密钥的内容，都会被映射到默认标签：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The signing tags are of interest, the `@PLATFORM` and `@RELEASE` are special
    processing strings used during build. Another mapping file maps these to actual
    key values. The file that is processed and placed onto the device has all key
    references replaced with hex encoded public keys rather than these placeholders.
    It also has all whitespace and comments stripped to reduce size. Let's take a
    look by pulling the built file from the device and formatting it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 签名标签值得关注，`@PLATFORM`和`@RELEASE`是在构建期间使用的特殊处理字符串。另一个映射文件将这些映射到实际的关键值。处理过的文件被放置在设备上，所有密钥引用都被替换为十六进制编码的公钥，而不是这些占位符。它还删除了所有的空白和注释，以减少大小。让我们通过从设备中提取构建的文件并格式化它来查看。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, scroll to the top of the formatted output; you should see the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，滚动到格式化输出的顶部，你应该看到以下内容：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `signature=@PLATFORM` is now a hex string. This hex string is a
    valid X509 certificate.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`signature=@PLATFORM`现在是一个十六进制字符串。这个十六进制字符串是一个有效的X509证书。
- en: keys.conf
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: keys.conf
- en: 'The actual magic doing the mapping from `signature=@PLATFORM` in `mac_permissions.xml`
    is `keys.conf`. This configuration file allows you to map a pem encoded x509 to
    an arbitrary string. The convention is to start them with `@`, but this is not
    enforced. The format of the file is based on the Python config parser and contains
    sections. The section names are the tags in the `mac_permissions.xml` file you
    wish to replace with key values. The platform example is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从`mac_permissions.xml`中的`signature=@PLATFORM`到`keys.conf`的映射才是魔法所在。这个配置文件允许你将一个pem编码的x509映射到一个任意的字符串。约定是使用`@`开始，但这不是强制性的。该文件的格式基于Python配置解析器，并包含部分。部分名称是你在`mac_permissions.xml`文件中希望用密钥值替换的标签。平台示例是：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Android, when you build, you can have three levels of builds: `engineering`,
    `userdebug`, or `user`. In the `keys.conf` file, you can associate a key to be
    used for all levels with the section attribute `ALL`, or you can assign different
    keys per level. This is helpful when building release or user builds with very
    special release keys. We see an example of this in the `@RELEASE` section:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，构建时你可以有三个级别的构建：`engineering`，`userdebug` 或 `user`。在 `keys.conf`
    文件中，你可以将一个密钥与 `ALL` 区段属性关联以用于所有级别，或者你可以为每个级别分配不同的密钥。这对于使用非常特殊的发布密钥构建发布或用户版本很有帮助。我们在
    `@RELEASE` 区段看到了一个这样的例子：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The file also allows the use of environment variables through the traditional
    `$` special character. The default location for the pem files is `build/target/product/security`.
    However, you should *never* use these keys for a user release build. These keys
    are the AOSP test keys and are public! By doing so, anyone can use the system
    key to sign their app and gain system privilege. The `keys.conf` file is only
    used during the build and is not located on the system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件还允许通过传统的 `$` 特殊字符使用环境变量。pem 文件的默认位置是 `build/target/product/security`。然而，你*绝不能*将这些密钥用于用户发布版本。这些密钥是
    AOSP 测试密钥，是公开的！这样做的话，任何人都可以使用系统密钥来签署他们的应用并获得系统权限。`keys.conf` 文件只在构建过程中使用，并且不在系统上。
- en: seapp_contexts
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: seapp_contexts
- en: 'So far, we have looked at how a finished `mac_permssions.xml` file assigns
    the `seinfo` value. Now we should address how the labeling is actually configured
    and utilizes this value. The labeling of applications is managed in another configuration
    file, `seapp_contexts`. Like `mac_permissions.xml`, it is loaded to the device.
    However, the default location is `/seapp_contexts`. The format of `seapp_contexts`
    is the `key=value` pair mappings per line, adhering to the following rules:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了完成的 `mac_permssions.xml` 文件如何分配 `seinfo` 值。现在我们应该探讨标记实际上是如何配置并使用这个值的。应用程序的标记是在另一个配置文件
    `seapp_contexts` 中管理的。与 `mac_permissions.xml` 一样，它被加载到设备上。然而，默认位置是 `/seapp_contexts`。`seapp_contexts`
    的格式是每行遵循 `key=value` 对映射，以下规则：
- en: 'Input selectors:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入选择器：
- en: '`isSystemServer` (boolean)'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSystemServer`（布尔值）'
- en: '`user` (string)'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`（字符串）'
- en: '`seinfo` (string)'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seinfo`（字符串）'
- en: '`name` (string)'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（字符串）'
- en: '`sebool` (string)'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sebool`（字符串）'
- en: 'Input selector rules:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入选择器规则：
- en: '`isSystemServer=true` can only be used once.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSystemServer=true` 只能使用一次。'
- en: An unspecified `isSystemServer` defaults to false.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定的 `isSystemServer` 默认为 false。
- en: An unspecified string selector will match any value.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定的字符串选择器将匹配任何值。
- en: A user string selector that ends in `*` will perform a prefix match.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `*` 结尾的用户字符串选择器将执行前缀匹配。
- en: '`user=_app` will match any regular app UID.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user=_app` 将匹配任何常规的应用 UID。'
- en: '`user=_isolated` will match any isolated service UID.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user=_isolated` 将匹配任何隔离服务 UID。'
- en: All specified input selectors in an entry must match (logical AND).
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条目中所有指定的输入选择器必须匹配（逻辑与）。
- en: Matching is case-insensitive.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配不区分大小写。
- en: 'Precedence rules in order:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级规则如下：
- en: '`isSystemServer=true` before `isSystemServer=false`'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSystemServer=true` 优先于 `isSystemServer=false`'
- en: Specified `user=` string before unspecified `user=` string
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 `user=` 字符串优先于未指定的 `user=` 字符串。
- en: Fixed the `user=` string before the `user=` prefix (ending in `*`)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复了 `user=` 字符串，使其优先于以 `*` 结尾的 `user=` 前缀。
- en: Longer `user=` prefix before shorter `user=` prefix
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较长的 `user=` 前缀优先于较短的前缀。
- en: Specified `seinfo=` string before unspecified `seinfo=` string.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 `seinfo=` 字符串优先于未指定的 `seinfo=` 字符串。
- en: Specified `name=` string before unspecified `name=` string.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 `name=` 字符串优先于未指定的 `name=` 字符串。
- en: Specified `sebool=` string before unspecified `sebool=` string.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 `sebool=` 字符串优先于未指定的 `sebool=` 字符串。
- en: 'Outputs:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：
- en: '`domain` (string): It specifies the process domain for the application.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`（字符串）：它指定了应用程序的进程域。'
- en: '`type` (string): It specifies the disk label for the applications'' private
    data directory.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`（字符串）：它指定了应用程序私有数据目录的磁盘标签。'
- en: '`levelFrom` (string; one of `none`, `all`, `app`, or `user`): It gives the
    MLS specifier.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelFrom`（字符串；值为 `none`，`all`，`app` 或 `user`）：它给出了 MLS 指示符。'
- en: '`level` (string): It shows the hardcoded MLS value.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level`（字符串）：它显示硬编码的 MLS 值。'
- en: 'Output rules:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出规则：
- en: Only entries that specify `domain=` will be used for app process labeling.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有指定了 `domain=` 的条目会被用于应用进程标记。
- en: Only entries that specify `type=` will be used for app directory labeling.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有指定了 `type=` 的条目才会用于应用目录标记。
- en: '`levelFrom=user` is only supported for `_app` or `_isolated` UIDs.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelFrom=user` 只支持 `_app` 或 `_isolated` UIDs。'
- en: '`levelFrom=app` or `levelFrom=all` is only supported for `_app` UIDs.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelFrom=app` 或 `levelFrom=all` 只支持 `_app` UIDs。'
- en: '`level` may be used to specify a fixed level for any UID.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level` 可用于为任何 UID 指定固定的级别。'
- en: 'During application spawn, this file is used by the `selinux_android_setcontext()`
    and `selinux_android_setfilecon2()` functions to look up the proper application
    domain or filesystem context, respectively. The source for these can be found
    in `external/libselinux/src/android.c` and are recommended reads. For example,
    this entry places all applications with UID `bluetooth` in the `bluetooth` domain
    with a data directory label of `bluetooth_data_file`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序生成期间，`selinux_android_setcontext()` 和 `selinux_android_setfilecon2()` 函数会使用此文件来查找适当的应用程序域或文件系统上下文。这些函数的源代码可以在
    `external/libselinux/src/android.c` 中找到，推荐阅读。例如，以下条目将所有具有 UID `bluetooth` 的应用程序放在
    `bluetooth` 域中，数据目录标签为 `bluetooth_data_file`：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example places all third party or "default" applications into a process
    domain of `untrusted_app` and a data directory of `app_data_file`. It additionally
    uses MLS categories of `levelFrom=app` to help provide additional MLS-based separations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将所有第三方或“默认”应用程序放入 `untrusted_app` 的进程域和 `app_data_file` 的数据目录中。它还使用基于 MLS
    的 `levelFrom=app` 类别以帮助提供额外的分离。
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Currently, this feature is experimental as this breaks some known application
    compatibility issues. At the time of this writing, this was a hot item of focus
    for both Google and NSA engineers. Since it is experimental, let's validate its
    functionality and then disable it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此功能是实验性的，因为它破坏了一些已知的应用程序兼容性问题。在撰写本文时，这成为了谷歌和美国国家安全局工程师的热门关注点。由于它是实验性的，让我们验证其功能，然后禁用它。
- en: 'We have not installed any third party applications yet, so we''ll need to do
    so in order to experiment. FDroid is a useful place to find third party applications,
    so let''s download something from there and install it. We can use the `0xbenchmark`
    application located at [https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark](https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark)
    with an APK at [https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk](https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk),
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有安装任何第三方应用程序，因此我们需要安装一个以便进行实验。FDroid 是一个寻找第三方应用程序的好地方，因此我们可以从那里下载并安装一些内容。我们可以使用位于
    [https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark](https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark)
    的 `0xbenchmark` 应用程序，APK 下载地址为 [https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk](https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk)，如下所示：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Check `logcat` for the install time `seinfo` value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `logcat` 中的安装时 `seinfo` 值：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From your UDOO, launch the `0xbenchmark` APK. We should see it running with
    its label in `ps`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从 UDOO 中启动 `0xbenchmark` APK。我们应在 `ps` 中看到它正在运行，并带有其标签：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the level portion of the context string `s0:c40,c256`. These categories
    were created with the `level=app` setting from `seapp_contexts`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上下文字符串中的级别部分 `s0:c40,c256`。这些类别是在 `seapp_contexts` 中使用 `level=app` 设置创建的。
- en: To disable it, we could simply remove the key-value pair for level from the
    entry in `seapp_contexts`, or we could leverage the `sebool` conditional assignment.
    Let's use the Boolean approach. Modify the sepolicy `seapp_contexts` file so the
    existing `untrusted_app` entry is modified, and a new one is added. Change `user=_app
    domain=untrusted_app type=app_data_file` to `user=_app sebool=app_level domain=untrusted_app
    type=app_data_file levelFrom=app`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用它，我们可以简单地从 `seapp_contexts` 中的条目中删除 level 的键值对，或者我们可以利用 `sebool` 条件赋值。让我们使用布尔值方法。修改
    sepolicy `seapp_contexts` 文件，以便修改现有的 `untrusted_app` 条目，并添加一个新条目。将 `user=_app
    domain=untrusted_app type=app_data_file` 更改为 `user=_app sebool=app_level domain=untrusted_app
    type=app_data_file levelFrom=app`。
- en: 'Build that with `mmm external/sepolicy`, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mmm external/sepolicy` 进行构建，如下所示：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Well, there was a build error complaining about not finding the `selinux` Boolean
    on line 42 of `seapp_contexts`. Let''s attempt to correct the issue by declaring
    the Boolean. In `app.te`, add: `bool app_level false;`. Now push the newly built
    `seapp_contexts` and sepolicy file to the device and trigger a dynamic reload:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在 `seapp_contexts` 的第 42 行有一个构建错误，抱怨找不到 `selinux` 布尔值。让我们尝试通过声明布尔值来纠正问题。在
    `app.te` 中添加：`bool app_level false;`。现在将新构建的 `seapp_contexts` 和 sepolicy 文件推送到设备上，并触发动态重载：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can verify that the Boolean exists by:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式验证布尔值是否存在：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Due to design limitations, we need to uninstall and reinstall the application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计限制，我们需要卸载并重新安装应用程序：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Re-install and check the context of the process *after* launching it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动进程后，重新安装并检查进程的上下文内容：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Great! It failed. After some debugging, we discovered the source of the issue
    is that the path `/data/security` is not world searchable, causing a DAC permissions
    failure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！它失败了。在经过一些调试后，我们发现问题的根源是 `/data/security` 路径不是全局可搜索的，导致 DAC 权限失败。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We found this by printing off the result and error codes in `android.c` where
    we saw the `fopen` on `seapp_contexts_file[]` array (files in priority order)
    while checking the result of `fp = fopen(seapp_contexts_file[i++], "r")` in `selinux_android_seapp_context_reload()`
    and using `selinux_log()` to dump the data to `logcat`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `android.c` 中打印结果和错误代码找到这个，我们看到在检查 `fp = fopen(seapp_contexts_file[i++],
    "r")` 的结果时，`selinux_android_seapp_context_reload()` 中的 `seapp_contexts_file[]`
    数组（按优先级排序的文件）上的 `fopen`，并使用 `selinux_log()` 将数据转储到 `logcat`。
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember the `set selinux` context occurs after the UID switch, so we need to
    make it searchable for others. We can fix the permissions on the UDOO `init.rc`
    script by changing `device/fsl/imx6/etc/init.rc`. Specifically, change the line
    `mkdir /data/security 0700 system system` to `mkdir /data/security 0711 system
    system`. Build and flash the `bootimage`, and try the context test again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`set selinux` 上下文发生在 UID 切换之后，因此我们需要使其对其他人可搜索。我们可以通过更改 `device/fsl/imx6/etc/init.rc`
    中的 UDOO `init.rc` 脚本的权限来修复权限。具体来说，将行 `mkdir /data/security 0700 system system`
    更改为 `mkdir /data/security 0711 system system`。构建并刷新 `bootimage`，然后再次尝试上下文测试。
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So far, we've demonstrated how to use the `sebool` option on `seapp_contexts`
    to disable the MLS categories. It's important to note that when changing categories
    or types on APKs, it is required to remove and install the APK, or you will orphan
    the process from its data directory because it won't have access permissions under
    most circumstances.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经演示了如何使用 `seapp_contexts` 上的 `sebool` 选项来禁用 MLS 类别。需要注意的是，在更改 APK 的类别或类型时，需要卸载并重新安装
    APK，否则在大多数情况下，由于没有访问权限，该进程会与其数据目录脱离。
- en: 'Next, let''s take this APK, uninstall it, and assign it a unique domain by
    changing its `seinfo` string. Typically, you use this feature to take a set of
    applications signed with a common key and get them into a custom domain to do
    custom things. For example, if you''re an OEM, you may need to allow custom permissions
    to third party applications that are not signed with an OEM controlled key. Start
    by uninstalling the APK:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们拿这个 APK，卸载它，并通过更改其 `seinfo` 字符串为其分配一个唯一的域。通常，你使用这个特性将一组用共同密钥签名的应用程序放入自定义域以执行自定义操作。例如，如果你是
    OEM，你可能需要允许未用 OEM 控制的密钥签名的第三方应用程序拥有自定义权限。首先卸载 APK：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a new entry in `mac_permissions.xml` by adding:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下内容在 `mac_permissions.xml` 中创建一个新条目：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we need to get a pem file for `keys.conf`. So unpackage the APK and extract
    the public certificate:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为 `keys.conf` 获取一个 pem 文件。因此，解压 APK 并提取公共证书：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll have to strip any cruft from the generated `CERT.pem` file. If you open
    it up, you should see these lines at the top:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从生成的 `CERT.pem` 文件中删除任何多余的内容。如果你打开它，你应该会在顶部看到这些行：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: They need to be removed, so remove *only* the subject and issuer lines. The
    file should start with `BEGIN CERTIFICATE` and end with `END CERTIFICATE` scissor
    lines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它们需要被删除，因此只删除主题和发行者行。文件应以 `BEGIN CERTIFICATE` 开头，以 `END CERTIFICATE` 剪切线结尾。
- en: 'Let''s move this to a new folder in our workspace called `certs` and move the
    certificate into this folder with a better name:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个移动到工作区中名为 `certs` 的新文件夹，并将证书移动到这个文件夹，并赋予其一个更好的名字：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can set up our `keys.conf` by adding:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加以下内容来设置 `keys.conf`：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Don''t forget to update `seapp_contexts` in order to use the new mapping:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了更新 `seapp_contexts` 以使用新的映射：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now declare the new types to be used. The domain type should be declared in
    a file called `benchmark_app.te` in `sepolicy`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明要使用的新类型。域类型应在 `sepolicy` 中名为 `benchmark_app.te` 的文件中声明：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Also, add the `benchmark_app_data_file` in `file.te`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还在 `file.te` 中添加 `benchmark_app_data_file`：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may not always want *all* of these attributes, especially if you're doing
    something security critical. Make sure you look at each attribute and macro and
    see its usage. You don't want to open up an unintended hole by having an overly
    permissive domain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能并不总是想要这些*所有*属性，尤其是如果你在做一些安全关键的事情。确保你查看每个属性和宏以及其用法。你不想因为过于宽松的域而打开一个未预期的大门。
- en: Rebuild the policy, push the required pieces, and trigger a reload.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建策略，推送所需的部分，并触发重新加载。
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Start a shell and grep logcat to see the `seinfo` value the benchmark APK is
    installed as. Then install the APK:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 shell 并使用 grep logcat 查看基准测试 APK 安装时的 `seinfo` 值。然后安装该 APK：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On the `logcat` output, you should see:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`logcat`输出中，你应该看到：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It should have been `seinfo=benchmark`! What could have happened?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是`seinfo=benchmark`！可能发生了什么？
- en: 'The problem is in `frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`.
    It looks in `/data/security/mac_permissions.xml`; so we can just push `mac_permissions.xml`.
    This is another bug in the dynamic policy reload and has to do with historical
    changes in this loading procedure. The culprit is within the `frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`中。它查看`/data/security/mac_permissions.xml`；所以我们可以直接推送`mac_permissions.xml`。这是动态策略重载中的另一个错误，与加载过程中历史更改有关。罪魁祸首在`frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`文件中：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To get around this, remount `system` and push it to the default location.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，重新挂载`system`并将其推送到默认位置。
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This does *not* require a `setprop selinux.reload_policy 1`. Uninstall and
    reinstall the benchmark APK, and check the logs:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要`setprop selinux.reload_policy 1`。卸载并重新安装基准测试APK，并检查日志：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'OK. It still didn''t work. When we examined the code, the `mac_permissions.xml`
    file was loaded during package manager service start. This file won''t get reloaded
    without a reboot, so let''s uninstall the benchmark APK, and reboot the UDOO.
    After it''s been booted and `adb` is enabled, trigger a dynamic reload, install
    the APK, and check `logcat`. It should have:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它仍然没有工作。当我们检查代码时，发现`mac_permissions.xml`文件在包管理器服务启动时被加载。没有重启的情况下，这个文件不会被重新加载，所以让我们卸载基准测试APK，并重启UDOО。启动后，启用`adb`，触发动态重载，安装APK，并检查`logcat`。它应该包含：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s verify the process domain by launching the APK, checking `ps`, and
    verifying its application private directory:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过启动APK，检查`ps`，并验证其应用程序私有目录来验证进程域：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time, all the types check out. We successfully created a new custom domain.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，所有类型都检查通过了。我们成功创建了一个新的自定义域。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we investigated how to properly label application private data
    directories as well as their runtime contexts via the configuration files and
    SELinux policy. We also looked into the subsystems and code to make all of this
    work as well as some basic things that may go wrong along the way. In the next
    chapter, we will expand on how the policy and configuration files get built by
    peering into the SE for Android build system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了如何通过配置文件和SELinux策略正确标记应用程序的私有数据目录及其运行时上下文。我们还探讨了使这一切正常工作的子系统及代码，以及在此过程中可能出错的一些基本问题。在下一章中，我们将通过查看SE
    for Android构建系统，详细介绍策略和配置文件是如何构建的。
