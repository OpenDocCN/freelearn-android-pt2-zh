- en: Chapter 9. AndEngine Extensions Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章 AndEngine扩展概述
- en: 'In this chapter, we''re going to cover the purpose and usage of some of AndEngine''s
    most popular extensions. The following topics are included in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些AndEngine最受欢迎的扩展的目的和用法。本章包括以下主题：
- en: Creating live wallpapers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态壁纸
- en: Networking with the multiplayer extension
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多人游戏扩展进行网络通信
- en: Creating high-resolution graphics with **scalable vector graphics** (**SVG**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**可伸缩矢量图形**（**SVG**）创建高分辨率图形
- en: Color mapping with SVG texture regions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SVG纹理区域进行颜色映射
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the extensions overview chapter, we're going to begin to work with a number
    of classes that don't come packaged with AndEngine. There are many extensions
    that can be written to add various improvements or extra features to any default
    AndEngine game. In this chapter, we're going to be working with three main extensions
    that will allow us to create live wallpapers with AndEngine, create online games
    that allow multiple devices to connect directly to each other or a dedicated server,
    and finally, incorporate SVG files into our games as texture regions, allowing
    for high resolution and scalable graphics within our games.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展概述章节中，我们将开始使用一些AndEngine没有打包的类。有许多扩展可以编写，以添加各种改进或额外功能到任何默认的AndEngine游戏。在本章中，我们将使用三个主要扩展，它们将允许我们使用AndEngine创建动态壁纸，创建允许多个设备直接相互连接或连接到专用服务器的在线游戏，并最终将SVG文件作为纹理区域整合到我们的游戏中，从而在游戏中实现高分辨率和可伸缩的图形。
- en: 'AndEngine includes a relatively long list of extensions which can be included
    in our projects in order to make certain tasks easier to complete. Unfortunately,
    due to the number of extensions and the current state of some of them, we are
    limited in the number of extensions, which can be included within this chapter.
    However, most AndEngine extensions are relatively easy to use and include example
    projects which can be acquired from Nicolas Gramlich''s public GitHub repository
    – [https://github.com/nicolasgramlich](https://github.com/nicolasgramlich). The
    following is a list of additional AndEngine extensions, as well as a brief description
    describing its purpose:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: AndEngine包含一个相对较长的扩展列表，我们可以将这些扩展包含在项目中，以便使某些任务更容易完成。不幸的是，由于扩展的数量和一些扩展的当前状态，我们限制在本章中包含的扩展数量。然而，大多数AndEngine扩展相对容易使用，并且包含可以从Nicolas
    Gramlich的公共GitHub仓库获取的示例项目——[https://github.com/nicolasgramlich](https://github.com/nicolasgramlich)。以下是其他AndEngine扩展的列表以及简短的用途描述：
- en: '`AndEngineCocosBuilderExtension`: This extension allows developers to create
    games through the use of the **WYSIWYG** or **what you see is what you get** concept.
    This approach allows developers to build applications in a GUI based drag-and-drop
    environment using the CocosBuilder software for desktop computers. This extension
    can help make menu and level design as simple as placing objects on a screen and
    exporting the setup to a file which can be read in via the `AndEngineCocosBuilderExtension`
    extension.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndEngineCocosBuilderExtension`：这个扩展允许开发者通过使用**所见即所得**（**WYSIWYG**）的概念来创建游戏。这种方法允许开发者在使用CocosBuilder软件为桌面电脑的GUI拖放环境中构建应用程序。这个扩展可以帮助将菜单和关卡设计简化为在屏幕上放置对象，并将设置导出到一个可以通过`AndEngineCocosBuilderExtension`扩展读取的文件。'
- en: '`AndEngineAugmentedRealityExtension`: The augmented reality extension allows
    developers to easily convert an otherwise ordinary AndEngine activity into an
    augmented reality activity, which will display the device''s physical camera view
    on the screen. We are then able to attach entities over the top of the camera''s
    view displayed on the screen.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndEngineAugmentedRealityExtension`：增强现实扩展允许开发者轻松地将一个普通的AndEngine活动转换为一个增强现实活动，它将在屏幕上显示设备的物理摄像头视图。然后我们能够将实体附着在屏幕上显示的摄像头视图之上。'
- en: '`AndEngineTexturePackerExtension`: This extension allows developers to import
    sprite sheets created through the use of the TexturePacker program for desktop
    computers. This program makes creating sprite sheets remarkably easy by allowing
    us to drag-and-drop our images into the program, export the finished sprite sheet
    into an AndEngine-readable format, and simply load it into our project with the
    `AndEngineTexturePackerExtension` extension.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndEngineTexturePackerExtension`：这个扩展允许开发者导入通过TexturePacker程序为桌面电脑创建的精灵表。这个程序通过让我们将图片拖放到程序中，将完成的精灵表导出为AndEngine可读取的格式，然后使用`AndEngineTexturePackerExtension`扩展简单地将它加载到我们的项目中，使得创建精灵表变得非常简单。'
- en: '`AndEngineTMXTiledMapExtensions`: This extension can greatly increase productivity
    in games based on the tiled map style of gameplay. With the use of a TMX tiled
    map editor, developers can simply drag-and-drop sprites/tiles onto a grid-based
    level editor in order to create levels. Once a level is created in the editor,
    simply export it to the `.tmx` file format and from there use the `AndEngineTMXTiledMapExtension`
    to load the level into our project.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndEngineTMXTiledMapExtensions`：这个扩展可以在基于图块地图样式的游戏中大大提高生产力。使用TMX图块地图编辑器，开发者只需将精灵/图块拖放到基于网格的关卡编辑器中即可创建关卡。一旦在编辑器中创建了一个关卡，只需将其导出为
    `.tmx` 文件格式，然后使用 `AndEngineTMXTiledMapExtension` 将关卡加载到我们的项目中。'
- en: Creating live wallpaper
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态壁纸
- en: The live wallpaper extension is a great addition to the AndEngine lineup of
    available Android development resources. With this extension, we can easily create
    wallpapers through the use of all the normal AndEngine classes we're used to using
    for our game development. In this topic, we're going to create a live wallpaper
    containing a simple particle system that spawns particles at the top of the screen.
    The wallpaper settings will include a value that allows a user to increase the
    speed of particle movement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 动态壁纸扩展是AndEngine提供的Android开发资源中的一个很好的补充。使用这个扩展，我们可以轻松地通过使用我们习惯于游戏开发的所有普通AndEngine类来创建壁纸。在本主题中，我们将创建一个包含简单粒子系统的动态壁纸，该粒子系统在屏幕顶部生成粒子。壁纸设置将包括一个允许用户增加粒子移动速度的值。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe assumes that you have at least a basic knowledge of the Android
    SDK's `Activity` class as well as a general understanding of Android view objects,
    such as `SeekBars` and `TextViews`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程假设您至少具备Android SDK的 `Activity` 类的基本知识，以及对Android视图对象（如 `SeekBars` 和 `TextViews`）的一般了解。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Live wallpapers are not your typical Android activity. Instead, they are a service,
    which requires a slightly different approach in terms of setting a project up.
    Before visiting the code, let's go ahead and create the necessary folders and
    files for the live wallpaper.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 动态壁纸不是典型的Android活动。相反，它们是一个服务，在项目设置方面需要略有不同的方法。在访问代码之前，让我们继续创建动态壁纸所需的文件夹和文件。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the project named `LiveWallpaperExtensionExample` in the code bundle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 参考代码捆绑包中名为 `LiveWallpaperExtensionExample` 的项目。
- en: 'We will cover the code to reside in each file in the following section:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节介绍每个文件中驻留的代码：
- en: Create or overwrite the current `main.xml` file in the `res/layout` folder,
    naming it `settings_main.xml`. This layout file will be used to create the settings
    activity layout where the wallpaper's properties are adjusted by the user.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/layout` 文件夹中创建或覆盖当前的 `main.xml` 文件，将其命名为 `settings_main.xml`。这个布局文件将用于创建用户调整壁纸属性设置活动的布局。
- en: Create a new folder named `xml` in the `res` folder. Within this folder, create
    a new `xml` file and name it `wallpaper.xml`. This file will be used as a reference
    to the wallpaper's icon, description, as well as a reference to the setting's
    activity which will be used to modify the wallpaper properties.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res` 文件夹中创建一个名为 `xml` 的新文件夹。在这个文件夹内，创建一个新的 `xml` 文件，并将其命名为 `wallpaper.xml`。这个文件将用作壁纸图标的引用，以及描述和设置活动的引用，该设置活动将用于修改壁纸属性。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will start off by populating all of the XML files in order to accommodate
    a live wallpaper service. These files include `settings_main.xml`, `wallpaper.xml`,
    and finally `AndroidManifest.xml`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从填充所有XML文件开始，以便容纳一个动态壁纸服务。这些文件包括 `settings_main.xml`、`wallpaper.xml`，最后是
    `AndroidManifest.xml`。
- en: 'Create the `settings_main.xml` layout file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `settings_main.xml` 布局文件：
- en: The first step involves defining the `settings_main.xml` file as a layout for
    the settings activity of the wallpaper. There are no rules limiting a developer
    to a specific layout style, but the most common approach for a live wallpaper
    is a simple `TextView` with a corresponding `Spinner` used to provide a means
    of modification to the live wallpaper's adjustable values.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一步涉及将 `settings_main.xml` 文件定义为壁纸设置活动的布局。没有限制开发者使用特定布局样式的规则，但对于动态壁纸来说，最常见的方法是使用一个简单的
    `TextView` 和相应的 `Spinner` 来提供修改动态壁纸可调整值的方式。
- en: 'Open the `wallpaper.xml` file in the `res/xml/` folder. Import the following
    code to `wallpaper.xml`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `res/xml/` 文件夹中的 `wallpaper.xml` 文件。将以下代码导入 `wallpaper.xml`：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `AndroidManifest.xml` to suit the wallpaper service needs:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `AndroidManifest.xml` 以满足壁纸服务的需求：
- en: 'In the third step, we must modify `AndroidManifest.xml` in order to allow our
    project to run as a wallpaper service. In the project''s `AndroidManifest.xml`
    file, replace all code inside of the `<manifest>` tags with the following:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第三步中，我们必须修改`AndroidManifest.xml`，以便允许我们的项目作为壁纸服务运行。在项目的`AndroidManifest.xml`文件中，替换`<manifest>`标签内的所有代码，使用以下内容：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the three xml files have been taken care of, we can create the classes
    needed for the live wallpaper. We will be using three classes to handle the live
    wallpaper''s execution. These classes are `LiveWallpaperExtensionService.java`,
    `LiveWallpaperSettings.java`, and `LiveWallpaperPreferences.java`, which will
    be covered in the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这三个xml文件后，我们可以创建实时壁纸所需的类。我们将使用三个类来处理实时壁纸的执行。这些类是`LiveWallpaperExtensionService.java`、`LiveWallpaperSettings.java`和`LiveWallpaperPreferences.java`，在以下步骤中将会介绍：
- en: 'Create the live wallpaper preferences class:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实时壁纸偏好设置类：
- en: 'The `LiveWallpaperPreferences.java` class is similar to that of the preferences
    class we covered in the *Saving and loading game data* section in [Chapter 1](ch01.html
    "Chapter 1. AndEngine Game Structure"), *AndEngine Game Structure*. The main purpose
    of the preference class in this case is to handle the speed value of the spawned
    particles. The following methods are used for saving and loading the particle''s
    speed value. Note that we negate the `mParticleSpeed` value as we want the particles
    to travel toward the bottom of the screen:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LiveWallpaperPreferences.java`类与我们在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中讨论的偏好设置类相似。在这种情况下，偏好设置类的主要目的是处理生成的粒子的速度值。以下方法用于保存和加载粒子的速度值。请注意，我们取反了`mParticleSpeed`值，因为我们希望粒子向屏幕底部移动：'
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create the live wallpaper settings activity:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实时壁纸设置活动：
- en: The live wallpaper's settings activity extends Android SDK's `Activity` class,
    using the `settings_main.xml` file as the activity's layout. This activity's purpose
    is to obtain a value for the `mParticleSpeed` variable depending on the progress
    of the `SeekBar` object. Once the settings activity is exited, the `mParticleSpeed`
    value is saved to our preferences.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实时壁纸的设置活动扩展了Android SDK的`Activity`类，使用`settings_main.xml`文件作为活动的布局。此活动的目的是根据`SeekBar`对象的进度为`mParticleSpeed`变量获取一个值。一旦退出设置活动，`mParticleSpeed`值就会被保存到我们的偏好设置中。
- en: 'Create the live wallpaper service:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实时壁纸服务：
- en: The final step involved for setting up our live wallpaper is to create the `LiveWallpaperExtensionService.java`
    class, containing the code for the live wallpaper service. In order to specify
    that we would like the class to use the live wallpaper extension class, we simply
    add `extends BaseLiveWallpaperService` to the `LiveWallpaperExtensionService.java`
    declaration. Once this is done we can see that setting up a `BaseLiveWallpaperService`
    class is very much the same as setting up a `BaseGameActivity` class from this
    point on, allowing us to load resources, apply sprites, or any other common AndEngine
    task we're already used to.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为设置实时壁纸而涉及的最终步骤是创建`LiveWallpaperExtensionService.java`类，其中包含实时壁纸服务的代码。为了指定我们希望该类使用实时壁纸扩展类，我们只需在`LiveWallpaperExtensionService.java`声明中添加`extends
    BaseLiveWallpaperService`。完成这一步后，我们可以看到，设置`BaseLiveWallpaperService`类与从这时起设置`BaseGameActivity`类非常相似，这使我们能够加载资源、应用精灵，或我们已经习惯的任何其他常见的AndEngine任务。
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: This recipe is a rather big one if we look at the whole project, but fortunately
    most of the code related to the class files has already been discussed in previous
    sections, so don't be worried! For the sake of brevity we are going to omit the
    classes which have already been discussed in previous chapters. Take a look at
    the topics mentioned in the *See more...* subsection for a refresher if needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从整个项目来看，这个“配方”相当大，但幸运的是，与类文件相关的代码在之前的章节中已经讨论过了，所以不必担心！为了简洁起见，我们将省略在之前章节中已经讨论过的类。如果需要复习，请查看*查看更多...*小节中提到的主题。
- en: In the first step, all we're doing is creating a minimal Android `xml` layout
    to be used for the settings activity. It is quite possible to skip this step and
    use AndEngine's `BaseGameActivity` for the settings activity, but to keep things
    simple we are using a very basic `TextView/SeekBar` approach. This makes things
    convenient for both the developer, time-wise, as well as the user, for convenience.
    Try to keep this screen as clutter free as possible as it is meant to be a simple
    screen, with a simple purpose.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们要做的就是创建一个最小的Android `xml`布局，用于设置活动。完全有可能跳过这一步，使用AndEngine的`BaseGameActivity`作为设置活动，但为了简化问题，我们采用了非常基本的`TextView/SeekBar`方法。这对开发人员来说节省了时间，对用户来说也更加方便。尽量保持这个屏幕简洁，因为它应该是一个简单屏幕，有简单的目的。
- en: In step two, we are creating the `wallpaper.xml` file to be used as a reference
    to a few specifications needed for the live wallpaper service in the `AndroidManifest.xml`
    file. This file is simply in place to store the service's properties, which include
    the package and class name or "link" to the settings activity to be launched by
    pressing the **Settings...** button during the wallpaper preview. `wallpaper.xml`
    also includes a reference to the icon to be used in the wallpaper selection window.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们将创建一个`wallpaper.xml`文件，该文件将作为`AndroidManifest.xml`文件中动态壁纸服务所需的一些规范的引用。这个文件仅仅用于存储服务的属性，这些属性包括包和类名，或者按下壁纸预览中的**设置...**按钮时要启动的设置活动的“链接”。`wallpaper.xml`还包括对壁纸选择窗口中要使用的图标的引用。
- en: In step three, we are modifying the `AndroidManifest.xml` file to allow us to
    run the live wallpaper service as the main component for this project, rather
    than launching an activity. Within the `<service>` tags, we are including the
    `name`, `icon`, and `label` attributes for the wallpaper service. These attributes
    have the same purpose as they would for an activity. The other two attributes
    are `android:enabled="true"`, meaning that we'd like the wallpaper service to
    be enabled by default, as well as the `android:permission="android.permission.BIND_WALLPAPER"`
    attribute, meaning only the Android OS can bind to the service. The activity's
    attributes are similar, except we're including the `exported` and `theme` attributes
    and excluding the `enabled` and `permission` attributes. The `android:exported="true"`
    attribute states that the activity can be launched through outside processes while
    the theme attribute will alter the appearance of the settings activity UI.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们正在修改`AndroidManifest.xml`文件，以便将动态壁纸服务作为本项目的主组件运行，而不是启动一个活动。在`<service>`标签内，我们为壁纸服务包含了`name`、`icon`和`label`属性。这些属性与活动中的属性具有相同的目的。另外两个属性是`android:enabled="true"`，这意味着我们希望默认启用壁纸服务，以及`android:permission="android.permission.BIND_WALLPAPER"`属性，这意味着只有Android操作系统可以绑定到该服务。活动的属性与此类似，只是我们包括了`exported`和`theme`属性，并排除了`enabled`和`permission`属性。`android:exported="true"`属性表示活动可以通过外部进程启动，而主题属性将改变设置活动UI的外观。
- en: Step four involves creating the preferences class that we will be using to store
    the values available for adjustment by the user. In this recipe, we're including
    a single value called `mParticleSpeed` within the preferences class with corresponding
    getter and setter methods. In a more complex live wallpaper we can build on this
    class, allowing us to easily add or remove variables for as many customizable
    properties to our wallpaper as we'd like.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步涉及创建我们将用于存储用户可调整值的偏好设置类。在这个食谱中，我们在偏好设置类中包含了一个名为`mParticleSpeed`的单个值，并带有相应的获取器和设置器方法。在一个更复杂的动态壁纸中，我们可以在此基础上构建这个类，使我们能够轻松添加或移除变量，为壁纸提供尽可能多的自定义属性。
- en: 'In step five, we are creating the `Activity` class shown when a user presses
    the **Settings...** button on the live wallpaper preview screen. In this particular
    `Activity`, we''re obtaining the `settings_main.xml` file to be used as our layout,
    containing two `TextView` view types used to display labels and corresponding
    values, and one `SeekBar` to allow manipulation of the wallpaper''s adjustable
    values. The most important task for this `Activity` is to be able to save to the
    preference file once a user has selected their ideal speed. This is done by adjusting
    the `mParticleSpeed` variable when `SeekBar` realizes a user has moved the `SeekBar`
    slider:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们创建了一个`Activity`类，当用户在动态壁纸预览屏幕上按下**设置...**按钮时显示。在这个特定的`Activity`中，我们获取了`settings_main.xml`文件作为我们的布局，其中包含两个用于显示标签和相应值的`TextView`视图类型，以及一个允许操作壁纸可调整值的`SeekBar`。这个`Activity`最重要的任务是当用户选择理想的速度后，能够将设置保存到偏好文件中。这是通过在`SeekBar`意识到用户移动了`SeekBar`滑块时调整`mParticleSpeed`变量来完成的：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As well as updating the `mParticleSpeed` value, the associating `TextView`
    is updated within this event. This value, however, is not actually saved to the
    preference file until the user leaves the settings activity, to avoid unnecessary
    overwriting to the preference file. In order to save the new value to the preference
    file, we can call `setParticleSpeed(mParticleSpeed)` from the `LiveWallpaperPreferences`
    singleton during minimization of the `Activity` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件中，除了更新`mParticleSpeed`值，相关的`TextView`也会被更新。然而，这个值实际上只有在用户离开设置活动时才会保存到偏好文件中，以避免不必要地覆盖偏好文件。为了将新值保存到偏好文件，我们可以在`Activity`类最小化时从`LiveWallpaperPreferences`单例调用`setParticleSpeed(mParticleSpeed)`：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the sixth and final step, we can finally start to code the visual aspects
    of our live wallpaper. In this particular wallpaper, we''re keeping it simple
    in terms of visual appeal, but we do cover what all necessary information for
    developing a wallpaper. If we take a look at the `LiveWallpaperExtensionService`
    class, a few of the key variables to pay attention to, include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六步也是最后一步中，我们终于可以开始编写动态壁纸的视觉部分。在这款特定的壁纸中，我们在视觉吸引力方面保持了简单，但我们确实涵盖了开发壁纸所需的所有必要信息。如果我们查看`LiveWallpaperExtensionService`类，需要关注的一些关键变量包括以下内容：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While we''ve already discussed the `mParticleSpeed` variable throughout the
    other class explanations, it should be obvious at this point that we''ll be using
    this variable to finally determine the speed of the particles, as this is the
    class that will handle the `ParticleSystem` object. The other two ''ratio'' variables
    declared above are to help us keep a proper scaling ratio for our entities. These
    variables are needed in the event that a user tilts their device from landscape
    to portrait or vice versa, so that we can calculate the scale of the particles
    depending on the width and height of the surface view. This is to prevent our
    entities from being stretched or distorted upon orientation changes. Skipping
    to the bottom overridden method of this class, the following code determines the
    values for `mRatioX` and `mRatioY`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在其他类解释中我们已经讨论了`mParticleSpeed`变量，但此时应该很清楚，我们将使用这个变量来最终确定粒子的速度，因为这是将处理`ParticleSystem`对象的类。上面声明的另外两个'比例'变量是为了帮助我们保持实体的适当缩放比例。这些变量在用户将设备从横屏倾斜到竖屏或反之亦然时是必需的，这样我们就可以根据表面视图的宽度和高度计算粒子的比例，以防止实体在方向改变时被拉伸或扭曲。跳到这个类的底部覆盖方法，以下代码确定了`mRatioX`和`mRatioY`的值：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see here that the `if` statement is checking whether or not the device
    is in landscape or portrait mode. If `pWidth` is greater than `pHeight`, it means
    the orientation is currently in landscape mode, setting the x and y scale ratios
    to the default 1 value. On the other hand, if the device is set to portrait mode,
    then we must recalculate the scale ratio for our particle entities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到，`if`语句正在检查设备是否处于横屏或竖屏模式。如果`pWidth`大于`pHeight`，这意味着当前的方向是横屏模式，将x和y的比例尺设置为默认值1。另一方面，如果设备设置为竖屏模式，那么我们必须重新计算粒子实体的比例尺。
- en: Once the `onSurfaceChanged()` method is taken care of, let's continue on to
    the remaining key points with the next up being preference management. Taking
    care of preferences is a fairly trivial task. First and foremost, we should initialize
    the preference file, in case it is the first time the wallpaper is launched. We
    do this by calling the `initPreferences(this)` method from the `LiveWallpaperPreferences`
    instance in `onCreateEngineOptions()`. We also need to override the `onResume()`
    method in order to load the `mParticleSpeed` variable with the value stored in
    the preference file by calling the `getParticleSpeed()` method from the `LiveWallpaperPreferences`
    instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理完`onSurfaceChanged()`方法后，我们继续讨论剩余的关键点，下一个是偏好设置管理。处理偏好设置是一项相当琐碎的任务。首先，我们应该初始化偏好设置文件，以防这是第一次启动壁纸。我们通过在`onCreateEngineOptions()`中的`LiveWallpaperPreferences`实例调用`initPreferences(this)`方法来实现这一点。我们还需要重写`onResume()`方法，以便通过从`LiveWallpaperPreferences`实例调用`getParticleSpeed()`方法，用偏好设置文件中存储的值加载`mParticleSpeed`变量。
- en: 'Finally, we come to the remaining setup step for the live wallpaper, which
    is setting up the particle system. This particular particle system is none too
    fancy, but it does include a `ParticleModifier` object, which includes some points
    to note. Since we''re adding an `IParticleModifier` interface to the particle
    system, we are given access to individual particles spawned by the system on every
    update to each particle. In the `onUpdateParticle()` method, we''ll be setting
    the particle''s speed based on the `mParticleSpeed` variable loaded in from the
    preference file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到实时壁纸设置的最后一个步骤，即设置粒子系统。这个特定的粒子系统并不特别花哨，但它包括一个`ParticleModifier`对象，其中有一些需要注意的点。由于我们将`IParticleModifier`接口添加到粒子系统中，因此我们可以在每次更新每个粒子时访问由系统生成的单个粒子。在`onUpdateParticle()`方法中，我们将根据从偏好设置文件中加载的`mParticleSpeed`变量设置粒子的速度：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We must also adjust the scale of the particle if its scale is not equal to
    the `mRatioX/mRatioY` values to compensate for device orientation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子的比例不等于`mRatioX/mRatioY`值，我们还必须调整粒子的比例，以补偿设备方向：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's all it takes to set up a live wallpaper with AndEngine! Try playing around
    with the particle system, adding new customizable values to the settings, and
    see what you can come up with. With this extension, you'll be up and running,
    creating new live wallpapers in no time at all!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了使用AndEngine设置实时壁纸的全部工作！尝试玩转粒子系统，在设置中添加新的可自定义值，看看你能想出什么。使用这个扩展，你将能够快速上手，立即创建新的实时壁纸！
- en: See also…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: The *Saving and loading game data* section in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. AndEngine游戏结构")中的*保存和加载游戏数据*部分，*AndEngine游戏结构*。'
- en: The *Working with particle systems* section in [Chapter 2](ch02.html "Chapter 2. Working
    with Entities"), *Working with Entities*.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章. 使用实体")中的*使用粒子系统*部分，*使用实体*。'
- en: Networking with the multiplayer extension
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多人游戏扩展进行网络编程
- en: Here we come to the undoubtedly most popular aspect of game design. This is
    of course multiplayer gaming. In this project recipe, we're going to work with
    AndEngine's multiplayer extension in order to create a fully functional client
    and server directly onto the mobile device. Once we cover the range of classes
    and features that this extension includes to make network programming easier,
    you will be able to take your online gaming ideas and turn them into reality!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里无疑是最受欢迎的游戏设计方面。这当然是多人游戏。在这个项目配方中，我们将使用AndEngine的多玩家扩展，以便直接在移动设备上创建一个完全功能性的客户端和服务器。一旦我们介绍了这个扩展包括的类和特性，以简化网络编程，你将能够将你的在线游戏想法变为现实！
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Creating a multiplayer game can require quite a few components in order to satisfy
    the readability of the project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个多人游戏可能需要相当多的组件，以满足项目的可读性。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the project named `MultiplayerExtensionExample` in the code bundle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中的名为`MultiplayerExtensionExample`的项目。
- en: For this reason, we're going to separate these different components into five
    classes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将把这些不同的组件分为五个类别。
- en: 'Create a new Android project, naming it `MultiplayerExtensionExample`. Once
    the project is ready to go, create four new class files with the following names:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`MultiplayerExtensionExample`的新Android项目。项目准备就绪后，创建四个具有以下名称的新类文件：
- en: '`MultiplayerExtensionExample.java`: The `BaseGameActivity` class for the recipe'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiplayerExtensionExample.java`：本食谱的`BaseGameActivity`类'
- en: '`MultiplayerServer.java`: The class containing the main server component'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiplayerServer.java`：包含主要服务器组件的类'
- en: '`MultiplayerClient.java`: The class containing the main client component'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiplayerClient.java`：包含主要客户端组件的类'
- en: '`ServerMessages.java`: The class containing messages meant to be sent from
    the server to clients'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerMessages.java`：包含旨在从服务器发送到客户端的消息的类'
- en: '`ClientMessages.java`: The class containing messages meant to be sent from
    clients to the server'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientMessages.java`：包含旨在从客户端发送到服务器的消息的类'
- en: 'Open the project''s `AndroidManifest.xml` file and add the following two `<uses-permission>`
    attributes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目的`AndroidManifest.xml`文件，并添加以下两个`<uses-permission>`属性：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For the sake of keeping things relative throughout this recipe, we're going
    to work with each class in the order they were mentioned in the *Getting ready*
    section, starting with the `MultiplayerExtensionExample` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持本食谱中内容的相对性，我们将按照*准备就绪*部分提到的顺序，依次处理每个类，从`MultiplayerExtensionExample`类开始。
- en: 'Declare and register the server/client messages for `mMessagePool`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`mMessagePool`声明并注册服务器/客户端消息：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Configure the scene touch listener to allow the sending of messages to and
    from the server:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置场景触摸监听器，以允许与服务器之间的消息发送和接收：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the dialog *switch* statement prompting users to select to either act
    as the server or client. In the event a server or client component is selected,
    we will initialize one of the two components:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个*开关*对话框，提示用户选择作为服务器或客户端。如果选择了服务器或客户端组件，我们将初始化这两个组件中的一个：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Override the activity''s `onDestroy()` method to terminate both the server
    and client components when the activity is destroyed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写活动的`onDestroy()`方法，在活动被销毁时终止服务器和客户端组件：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once all of the main activity's functionality is in place, we can move on to
    writing the server-side code.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦所有主要活动的功能就位，我们可以继续编写服务器端代码。
- en: 'Create the server''s initialization method—creating the `SocketServer` object,
    which handles connections to the server''s clients:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务器的初始化方法——创建处理服务器客户端连接的`SocketServer`对象：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Handle the client connection to the server. This involves registering client
    messages and defining how to handle them:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理客户端连接到服务器。这涉及到注册客户端消息并定义如何处理它们：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the `SocketServer` object has been declared and initialized, we need to
    call its `start()` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化了`SocketServer`对象后，我们需要调用其`start()`方法：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `sendMessage()` server broadcasting method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`sendMessage()`服务器广播方法：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the `terminate()` method to shut down the connection:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`terminate()`方法以关闭连接：
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the server-side code out of the way, we will continue on to implement the
    client-side code in the `MultiplayerClient` class. The class is quite similar
    to the `MultiplayerServer` class, so we'll be omitting the unnecessary client-side
    steps from here.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器端代码完成后，我们将在`MultiplayerClient`类中继续实现客户端代码。这个类与`MultiplayerServer`类非常相似，因此我们将省略不必要的客户端步骤。
- en: 'Create the `Socket`, `SocketConnection`, and finally the `ServerConnector`
    to establish the connection with the server:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Socket`、`SocketConnection`，最后创建`ServerConnector`以与服务器建立连接：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Handling the messages received from the server:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理从服务器接收到的消息：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Creating client and server messages:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建客户端和服务器消息：
- en: '`ClientMessage` and `ServerMessage` are meant to act as bundles of data that
    are able to be sent and received to and from the server as well as to and from
    clients. In this recipe, we''re creating a message for both the client and server
    to handle sending information about where to draw points on the client devices.
    The variables stored in these messages include:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ClientMessage`和`ServerMessage`旨在作为数据包，能够被发送到服务器和客户端，以及从服务器和客户端接收。在这个食谱中，我们将为客户端和服务器创建一个消息，以处理发送关于在客户端设备上绘制点的信息。这些消息中存储的变量包括：'
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While reading and writing the data for communication is as simple as the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 读取和写入通信数据就像以下这样简单：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe's implementation of server/client communication, we're building
    an application that allows a server to be deployed directly on a mobile device.
    From here, other mobile devices are able to act as a client and connect to the
    aforementioned mobile server. Once the server has been established with at least
    one client, the server will begin to relay messages to all clients if a touch
    event is created by any client, drawing points on the screens of all connected
    clients. If this sounds a bit confusing, have no fear. It will all come together
    shortly!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱实现的服务器/客户端通信中，我们构建了一个允许直接在移动设备上部署服务器的应用程序。从这里，其他移动设备可以作为客户端连接到前述的移动服务器。一旦服务器与至少一个客户端建立连接，如果任何客户端创建了触摸事件，服务器将开始向所有客户端中继消息，在所有连接的客户端屏幕上绘制点。如果这听起来有些令人困惑，不用害怕，很快一切就会变得清晰。
- en: In the first five steps, we're writing the `BaseGameActivity` class. This class
    is simply the entry point to the server and client, as well as a means to provide
    touch event capabilities for clients to draw onscreen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前五个步骤中，我们将编写`BaseGameActivity`类。这个类是服务器和客户端的入口点，同时也提供了触摸事件功能，使客户端能够在屏幕上绘图。
- en: In the first step, we're registering the necessary `ServerMessage` and `ClientMessage`
    objects to our `mMessagePool`. The `mMessagePool` object is an extension of the
    `MultiPool` class in AndEngine. See the *Creating sprite pools* section in [Chapter
    8](ch08.html "Chapter 8. Maximizing Performance"), *Maximizing Performance*, for
    how to use the `MessagePool` class to recycle messages sent and received across
    the network.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们需要将必要的`ServerMessage`和`ClientMessage`对象注册到我们的`mMessagePool`中。`mMessagePool`对象是AndEngine中`MultiPool`类的扩展。关于如何使用`MessagePool`类回收通过网络发送和接收的消息，请参阅[第8章](ch08.html
    "第8章. 最大化性能")《最大化性能》中的*创建精灵池*部分。
- en: In step two, we are setting up the scene with a scene touch listener interface
    whose purpose is to send messages across the network. Within the touch listener,
    we can use simple conditional statements to check whether or not the device is
    running as a client or a server with the line, `if(mServer != null)`, returning
    true if the device is running as a server. Additionally, we can call `if(mClient
    != null)` to check if the device is running as a client. A nested client check
    inside a server check would return true in the event of a device operating as
    both a client and a server. If a device is operating as a client, sending a message
    is as easy as obtaining a new message from `mMessagePool`, calling the `set(device_id,
    touchX, touchY, colorId)` method on the said message, then calling `mClient.sendMessage(message)`.
    Once the message is sent, we should always recycle it back into the pool so as
    to not waste memory. One final point to mention before moving on; in the nested
    client conditional, we're sending a server message rather than a client message.
    This is because the client, in this case, is also the server. This means we can
    skip over sending a client message to the server since the server already contains
    the touch event data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们通过设置一个场景触摸监听器接口来建立场景，该接口的目的是发送跨网络的消息。在触摸监听器内部，我们可以使用简单的条件语句来检查设备是否作为客户端或服务器运行，通过`if(mServer
    != null)`这行代码，如果设备作为服务器运行则返回true。此外，我们可以调用`if(mClient != null)`来检查设备是否作为客户端运行。在服务器检查中嵌套的客户端检查，如果设备同时作为客户端和服务器运行，将返回true。如果设备作为客户端运行，发送消息只需从`mMessagePool`获取一条新消息，在消息上调用`set(device_id,
    touchX, touchY, colorId)`方法，然后调用`mClient.sendMessage(message)`。消息发送后，我们应该始终将其回收至池中，以免浪费内存。在继续之前，最后要提到的一点是，在嵌套的客户端条件中，我们发送的是服务器消息而不是客户端消息。这是因为在这种情况下，客户端同时也是服务器。这意味着我们可以跳过向服务器发送客户端消息，因为服务器已经包含了触摸事件数据。
- en: Step three will most likely not be an ideal situation for most developers as
    we're using dialogs as a means to choose whether the device will act as a server
    or a client. This scenario is simply used to display how to initialize the components,
    so a dialog is not necessarily important. Choosing whether users should be able
    to host games or not is very much dependent on the game type and developer's idea,
    but this recipe at least covers how to set up a server if need be. Just keep in
    mind, when initializing a server, all we need to know is the **port number** .
    A client, on the other hand, needs to know a valid **server IP** and server port
    in order to establish a connection. Once the `MultiplayerServer` and/or `MultiplayerClient`
    classes have been constructed with these parameters, we can initialize the components.
    The purpose of the initialization will be covered shortly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步对于大多数开发者来说可能并不是理想的情况，因为我们使用对话框作为选择设备是作为服务器还是客户端的手段。这个场景仅用于展示如何初始化组件，所以对话框并不一定重要。选择用户是否能够主持游戏取决于游戏类型和开发者的想法，但这个方案至少涵盖了如何设置服务器（如果需要的话）。请记住，在初始化服务器时，我们只需要知道**端口号**。另一方面，客户端需要知道有效的**服务器IP**和服务器端口才能建立连接。一旦使用这些参数构建了`MultiplayerServer`和/或`MultiplayerClient`类，我们就可以初始化组件。初始化的目的将在不久后介绍。
- en: The fourth and final step for the `BaseGameActivity` class is to allow the activity
    to terminate the `MultiplayerServer` and `MultiplayerClient` connections in the
    event that the activity calls `onDestroy()`. This will shut down the communication
    threads and sockets before the application is destroyed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BaseGameActivity`类的第四步也是最后一步，是允许活动在调用`onDestroy()`时终止`MultiplayerServer`和`MultiplayerClient`的连接。这将关闭通信线程和套接字，在应用程序被销毁之前。
- en: Moving on to the `MultiplayerServer` code, let's take a look at the initialization
    of a server in step five. When creating a `SocketServer` object that a server
    uses in order to listen for new client connections, we must pass in the server's
    port number, as well as a `ClientConnectorListener` and a `SocketServerListener`.
    The `MultiplayerServer` class implements those two listeners, logging whenever
    the server starts up, stops, when a client connects to the server, and when a
    client disconnects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看第五步中的`MultiplayerServer`代码，了解服务器的初始化。在创建服务器用来监听新客户端连接的`SocketServer`对象时，我们必须传入服务器的端口号，以及一个`ClientConnectorListener`和一个`SocketServerListener`。`MultiplayerServer`类实现了这两个监听器，记录服务器启动、停止、客户端连接到服务器以及客户端断开连接时的日志。
- en: 'In the sixth step, we''re implementing the system which handles how the server
    will respond to incoming connections, and how to handle messages received by clients.
    The following points cover the process involved in the order they should be implemented:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六步中，我们正在实施处理服务器如何响应传入连接以及如何处理客户端接收到的消息的系统。以下是按应实施顺序涉及的过程：
- en: '`protected SocketConnectionClientConnector newClientConnector(...)` is called
    when a new client has connected to the server.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新客户端连接到服务器时，将调用`protected SocketConnectionClientConnector newClientConnector(...)`。
- en: Create a new `SocketConnectionClientConnector` is for the client to use as a
    means of communication between the new client and the server.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`SocketConnectionClientConnector`供客户端用作新客户端与服务器之间的通信手段。
- en: Register the `ClientMessages` you wish the server to recognize via `registerClientMessage(flag,
    message.class, messageHandlerInterface)`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`registerClientMessage(flag, message.class, messageHandlerInterface)`注册你希望服务器识别的`ClientMessages`。
- en: Within the `onHandleMessage()`method of the `messageHandlerInterface` interface,
    we handle any messages received from across the network. In this case, the server
    is simply relaying the client's message back to all connected clients.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`messageHandlerInterface`接口的`onHandleMessage()`方法中，我们处理从网络接收到的任何消息。在这种情况下，服务器只是将客户端的消息中继回所有连接的客户端。
- en: Return the new `clientConnector` object.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回新的`clientConnector`对象。
- en: These points outline the main functionality of server/client communication.
    In this recipe, we're using a single message in order to draw points on client
    devices, but for a more broad range of messages we can continue to call the `registerClientMessage()`
    method so long as the flag parameter matches up with the message type we're obtaining
    in the `onHandleMessage()` interface. Once all of the appropriate messages have
    been registered and we're finished with the client handling code, we can continue
    on to step seven and call `start()` on the `mSocketServer` object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点概述了服务器/客户端通信的主要功能。在这个示例中，我们使用单一消息在客户端设备上绘制点，但对于更广泛的消息范围，只要标志参数与我们在`onHandleMessage()`接口中获得的消息类型匹配，我们就可以继续调用`registerClientMessage()`方法。一旦注册了所有适当的消息，并且我们完成了客户端处理代码，我们可以继续第七步，在`mSocketServer`对象上调用`start()`。
- en: 'In step eight, we create the `sendMessage(message)` method for the server.
    The server''s variation of `sendMessage(message)` sends a broadcast message to
    all clients by simply looping through the client connector list, calling `sendServerMessage(message)`
    to each connector. If we wish to send a server message to individual clients,
    we can simply call `sendServerMessage(message)` on an individual ClientConnector.
    On the other end, we have the client''s variation of `sendMessage(message)`. The
    client''s `sendMessage()` method does not actually send a message to other clients;
    in fact, the client doesn''t communicate with other clients at all. A client''s
    job is to communicate with the server, which then communicates to the other clients.
    See the following figure for a better understanding of how our netwok communication
    works:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第八步中，我们为服务器创建了`sendMessage(message)`方法。服务器的`sendMessage(message)`版本通过简单地遍历客户端连接器列表，向每个连接器调用`sendServerMessage(message)`，向所有客户端发送广播消息。如果我们希望向单个客户端发送服务器消息，可以直接在单个`ClientConnector`上调用`sendServerMessage(message)`。在另一端，我们有客户端版本的`sendMessage(message)`。客户端的`sendMessage()`方法实际上并不向其他客户端发送消息；实际上，客户端根本不与其他客户端通信。客户端的工作是与服务器通信，然后服务器再与其他客户端通信。查看以下图表以更好地了解我们的网络通信是如何工作的：
- en: '![How it works...](img/8987OS_09_01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_09_01.jpg)'
- en: In the preceding figure, the process is outlined by the numbers. First, a client
    sends the message to the server. Once the server receives the message, it will
    loop through each of the `ClientConnector` objects in its client list, sending
    the broadcast to all clients.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，流程由数字标出。首先，客户端将消息发送到服务器。一旦服务器接收到消息，它将遍历其客户端列表中的每个`ClientConnector`对象，向所有客户端发送广播。
- en: The final step involved in creating the `MultiplayerServer` component is to
    create a method for terminating the `mSocketServer`. This method is called by
    `onDestroy()` in our main activity in order to destroy the communication thread
    when we are finished with it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`MultiplayerServer`组件的最后一步是创建一个用于终止`mSocketServer`的方法。此方法由我们主活动中的`onDestroy()`调用，以便在我们使用完毕后销毁通信线程。
- en: With all of the server-side code in place, we can move on to writing the client-side.
    The `MultiplayerClient` code is somewhat similar to the server's, with a few differences.
    When establishing a connection with the server, we must be a little bit more specific
    than in the server's initialization. First, we must create a new Socket with a
    specified IP address to connect to, along with a server port number. We then pass
    the `Socket` to a new `SocketConnection` object, used to establish an input/output
    stream on the socket. Once this is done we can then create our `ServerConnector`,
    whose purpose is to make the final connection between the client and the server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的所有代码准备就绪后，我们可以继续编写客户端代码。`MultiplayerClient`的代码与服务器端有些相似，但存在一些差异。在与服务器建立连接时，我们必须比服务器初始化时更具体一些。首先，我们必须创建一个新的Socket，指定要连接的IP地址以及服务器端口号。然后，我们将`Socket`传递给一个新的`SocketConnection`对象，用于在socket上建立输入/输出流。完成此操作后，我们可以创建我们的`ServerConnector`，其目的是在客户端和服务器之间建立最终的连接。
- en: We're coming close to a full client/server communication project now! Step eleven
    is where the real magic happens—the client receiving server messages. In order
    to receive a server message, similar to the server implementation of receiving
    messages, we simply call `mServerConnector.registerServerMessage(...)` which then
    gives us the opportunity to fill in an interface for `onHandleMessage(serverConnector,
    serverMessage)`. Again, similar to the server-side implementation, we can class-cast
    the `serverMessage` object to an `AddPointServerMessage` class, allowing us to
    obtain the custom values stored in the message.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经接近一个完整的客户端/服务器通信项目了！第11步是真正的魔法发生的地方——客户端接收服务器消息。为了接收服务器消息，类似于服务器接收消息的实现，我们只需调用`mServerConnector.registerServerMessage(...)`，这会给我们一个填充`onHandleMessage(serverConnector,
    serverMessage)`接口的机会。同样，类似于服务器端的实现，我们可以将`serverMessage`对象强制转换为`AddPointServerMessage`类，这样我们就能获取到消息中存储的自定义值。
- en: Now, with all of the server and client code out of the way, we come to the final
    step. This is, of course, creating the messages that will be used for `MessagePool`
    as well as the objects that we've been sending and receiving all over the place.
    There are two different types of Message objects that we need to be aware of.
    The first type is `ServerMessage`, which consists of messages that are meant to
    be *sent from the client and received/read by the server*. The other type of message
    is, you've guessed it, `ClientMessage`, which is meant to be *sent from the server
    and received/read by the client(s)*. By creating our own message classes, we can
    easily package together chunks of data represented by primitive datatypes and
    send them across the network. The primitive datatypes include `int`, `float`,
    `long`, `boolean`, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将所有服务器和客户端代码处理完毕，来到了最后一步。这当然就是创建将用于`MessagePool`的消息，以及我们一直在到处发送和接收的对象。我们需要了解两种不同类型的消息对象。第一种是`ServerMessage`，它包括那些*从客户端发送并由服务器接收/读取*的消息。另一种消息，你已经猜到了，是`ClientMessage`，它用于*从服务器发送并由客户端接收/读取*。通过创建我们自己的消息类，我们可以轻松地将由基本数据类型表示的数据块打包并发送到网络中。基本数据类型包括`int`、`float`、`long`、`boolean`等。
- en: 'In the messages used in this recipe, we''re storing an ID, which is meant to
    tell us whether the message is sent from a client or the server, the x and y coordinates
    of every client touch event, and the currently selected color id for drawing.
    Each value should have its own corresponding *get* method so that we''re able
    to obtain message details whenever a message is received. Additionally, by overriding
    a client or server message, we must implement the `onReadTransmissionData(DataInputStream)`
    method which allows us to obtain the datatypes from the input stream and copy
    them to our member variables. We must also implement the `onWriteTransmissionData(DataOutputStream)`,
    which is used to write the member variables to the data stream and send it across
    the network. One thing we need to be aware of when creating the server and client
    messages is that data read into our receiving member variables are obtained in
    the same order they were sent. See the order of our server message read and write
    methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中使用的消息里，我们存储了一个ID，用以标识消息是来自客户端还是服务器，每个客户端触摸事件的x和y坐标，以及当前选定的绘图颜色ID。每个值都应该有其对应的*获取*方法，这样我们在接收到消息时就能获取到消息的详细信息。此外，通过覆盖客户端或服务器消息，我们必须实现`onReadTransmissionData(DataInputStream)`方法，它允许我们从输入流中获取数据类型并将它们复制到我们的成员变量中。我们还必须实现`onWriteTransmissionData(DataOutputStream)`方法，用于将成员变量写入数据流并发送到网络中。在创建服务器和客户端消息时，我们需要注意的一个问题是，接收到的成员变量中的数据是以它们发送时的顺序获取的。请看我们服务器消息的读写方法的顺序：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Keeping the preceding code in mind, we can be sure that if we write a message
    containing an `int`, `float`, `int`, `boolean`, and a `float` into the output
    stream, any device receiving the message will read in an `int`, `float`, `int`,
    `boolean`, and a `float` respectively.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在记住前面的代码的前提下，我们可以确信，如果我们向输出流中写入包含`int`、`float`、`int`、`boolean`和一个`float`的消息，任何接收该消息的设备将分别读取一个`int`、`float`、`int`、`boolean`和一个`float`。
- en: Creating high-resolution graphics with SVG
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG创建高分辨率图形
- en: 'The ability to incorporate **scalable vector graphics** (**SVG**) into our
    mobile games is a serious benefit to development, and even more so when working
    with Android. The biggest benefit, and the one we''ll be covering in this topic,
    is the fact that SVG''s can be scaled to suit the device running our applications.
    No more having to create multiple PNG sets for larger displays, and even more
    importantly, no more having to deal with terribly pixelated graphics on large
    screen devices! In this topic we''re going to use the `AndEngineSVGTextureRegionExtension`
    extension to create high-resolution texture regions for our sprites. See the following
    screenshot for a standard resolution image scaled on the left-hand side, versus
    SVG on the right-hand side:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将**可缩放矢量图形**（**SVG**）集成到我们的移动游戏中，对于开发来说是一个巨大的优势，尤其是在与Android平台合作时。最大的好处，也是我们将在本主题中讨论的内容，是SVG可以根据运行我们应用的设备进行缩放。不再需要为更大的显示屏创建多个PNG图片集，更重要的是，不再需要在大型屏幕设备上处理严重的像素化图形！在本主题中，我们将使用`AndEngineSVGTextureRegionExtension`扩展来为我们的精灵创建高分辨率纹理区域。请看下面的截图，左侧是标准分辨率图像的缩放，右侧是SVG的效果：
- en: '![Creating high-resolution graphics with SVG](img/8987OS_09_02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![使用SVG创建高分辨率图形](img/8987OS_09_02.jpg)'
- en: While SVG assets can be very convincing when it comes to creating high-resolution
    graphics across multiple screen sizes, there are some downsides to them as well,
    in the `SVG` extension's current state. The `SVG` extension will not render all
    of the elements available, such as text and 3D shapes, for example. However, most
    of the necessary elements are available and will properly load during runtime,
    such as paths, gradients, fill-colors, and some shapes. Elements which fail to
    load will be displayed via the Logcat during SVG loaing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SVG资源在创建多种屏幕尺寸的高分辨率图形时可能非常有说服力，但在`SVG`扩展当前的状态下，也存在一些缺点。`SVG`扩展不会渲染所有可用的元素，例如文本和3D形状。然而，大多数必要的元素都是可用的，并且在运行时可以正确加载，如路径、渐变、填充颜色和一些形状。在SVG加载过程中未能加载的元素将通过Logcat显示。
- en: It is a wise choice to remove the elements which are not supported by the `SVG`
    extension from SVG files as they can influence loading times, which is the other
    negative aspect when it comes to using the `SVG` extension. The `SVG` textures
    will take considerably longer to load than PNG files as they must first be converted
    to PNG before loading to memory. It is not uncommon to see `SVG` textures take
    up to two or three times longer than the equivalent PNG images, depending on how
    many elements are included in each SVG. The most common workaround is to save
    the `SVG` textures to the device in PNG format during the first launch of the
    application. Every subsequent launch would then load the PNG images in order to
    reduce load time while keeping device-specific image resolutions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从SVG文件中移除不受`SVG`扩展支持的元素是一个明智的选择，因为它们可能会影响加载时间，这是使用`SVG`扩展的另一个负面因素。由于SVG纹理在加载到内存之前必须先转换为PNG格式，因此它们的加载时间将比PNG文件长得多。根据每个SVG中包含的元素数量，SVG纹理的加载时间可能会达到等效PNG图像的两到三倍。最常见的解决方法是，在应用程序首次启动时将SVG纹理以PNG格式保存到设备上。随后的每次启动都会加载PNG图像，以减少加载时间，同时保持设备特定的图像分辨率。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the project named `WorkingWithSVG` in the code bundle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码包中名为`WorkingWithSVG`的项目。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Creating a `SVG` texture region is an easy task to accomplish with big results.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SVG纹理区域是一个简单易行且效果显著的任务。
- en: 'Similar to your average `TextureRegion`, first we require a `BuildableBitmapTextureAtlas`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与普通的`TextureRegion`类似，首先我们需要一个`BuildableBitmapTextureAtlas`：
- en: '[PRE24]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we''ve got a texture atlas setup, we can create the `SVG` texture
    regions through the use of the `SVGBitmapTextureAtlasTextureRegionFactory` singleton:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了纹理图集，可以通过使用`SVGBitmapTextureAtlasTextureRegionFactory`单例来创建SVG纹理区域：
- en: '[PRE25]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we can see, creating an `SVG` texture region is not much different from your
    average `TextureRegion`. The only real difference between the two in terms of
    instantiation is the fact that we have to enter a `width` and `height` value as
    the final two parameters. This is because, unlike your average raster image format
    whose width and height are more or less hardcoded due to the fixed pixel positions,
    `SVG` pixel positions can be scaled up or down to any size we'd like. If we scale
    the `SVG` texture region, the vector's coordinates will simply adjust themselves
    in order to continue to produce a clear, precise image. Once the `SVG` texture
    region is built, we can apply it to a sprite as we would any other texture region.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，创建一个`SVG`纹理区域与普通的`TextureRegion`并没有太大区别。两者在实例化方面的唯一真正区别在于，我们必须输入一个`width`和`height`值作为最后两个参数。这是因为，与平均的栅格图像格式不同，由于固定的像素位置，其宽度和高度或多或少是硬编码的，`SVG`像素位置可以按我们喜欢的任何大小进行放大或缩小。如果我们缩放`SVG`纹理区域，向量的坐标将简单地调整自己以继续生成清晰、精确的图像。一旦构建了`SVG`纹理区域，我们就可以像应用其他任何纹理区域一样将其应用于精灵。
- en: 'That''s all fine and dandy, knowing how to create the `SVG` texture region,
    but there''s more to it than that. After all, the beauty of being able to use
    SVG images in our games is the ability to scale the image depending on the device''s
    display size. In this way we can avoid having to load larger images for smaller
    screened devices in order to accommodate for tablets, and we won''t have to make
    our tablet users suffer by creating small texture regions in order to conserve
    memory. The `SVG` extension actually makes it quite simple for us to deal with
    the idea of scaling depending on display size. The following code shows us how
    we can implement a mass-scaling factor to all `SVG` texture regions created. This
    will allow us to avoid having to create different sized texture regions manually,
    depending on dispay size:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建`SVG`纹理区域是很好的，但它的意义远不止于此。毕竟，在游戏中使用SVG图像的美妙之处在于能够根据设备显示大小来缩放图像。这样，我们就不需要为小屏幕设备加载大图像以适应平板电脑，也不需要通过创建小的纹理区域来节省内存，让平板用户受苦。`SVG`扩展实际上使我们能够非常简单地处理根据显示大小进行缩放的概念。以下代码展示了我们如何为所有创建的`SVG`纹理区域实现大规模缩放因子。这将使我们避免手动根据显示大小创建不同大小的纹理区域：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code can be copied and pasted into the `onCreateEngineOptions()`
    method of an activity. All that needs to be done is to decide on the scale factors
    you''d like to apply to the SVG''s depending on device size! From this point on,
    we can create a single `SVG` texture region and, depending on the display size,
    the texture region will scale accordingly. For example, we can load up a texture
    region like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以复制并粘贴到活动的`onCreateEngineOptions()`方法中。需要做的就是决定您希望根据设备大小为SVG应用哪些缩放因子！从这一点开始，我们可以创建一个单一的`SVG`纹理区域，根据显示大小，纹理区域将相应地缩放。例如，我们可以加载如下纹理区域：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We may define the texture region's width and height values to `32`, but by adjusting
    the scale factor in the factory class, the texture region would be built to `80x80`
    by multiplying the specified value by the scale factor for a `DENSITY_XHIGH` display.
    Just be careful when handling texture regions with autoscaling factors. The scale
    will also increase the space they consume within the `BuildableBitmapTextureAtlas`
    object and may cause errors if exceeded, as with any other `TextureRegion`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将纹理区域的宽度和高度值定义为`32`，但是通过在工厂类中调整缩放因子，对于`DENSITY_XHIGH`显示，纹理区域会通过将指定值与缩放因子相乘来构建成`80x80`。处理具有自动缩放因子的纹理区域时要小心。缩放还会增加它们在`BuildableBitmapTextureAtlas`对象中占用的空间，如果超出限制，可能会像其他任何`TextureRegion`一样导致错误。
- en: See also…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见……
- en: The *Different types of textures* section in [Chapter 1](ch01.html "Chapter 1. AndEngine
    Game Structure"), *AndEngine Game Structure*.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. AndEngine游戏结构")，*AndEngine游戏结构*中的*不同类型的纹理*部分。
- en: Color mapping with SVG texture regions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG纹理区域进行色彩映射
- en: A useful aspect of `SVG` texture regions is the fact that we are able to easily
    map the texture's colors. This technique is common in games that allow users to
    select custom colors for their player's character, be it clothing and accessory
    color, hair color, skin color, terrain themes, and much more. In this topic, we're
    going to use the `ISVGColorMapper` interface while building our `SVG` texture
    regions in order to create customized color sets for our sprites.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`SVG` 纹理区域的一个有用特点是，我们可以轻松地映射纹理的颜色。这种技术在允许用户为其角色的角色选择自定义颜色的游戏中很常见，无论是服装和配饰颜色、发色、肤色、地形主题等等。在本主题中，我们将在构建
    `SVG` 纹理区域时使用 `ISVGColorMapper` 接口，为我们的精灵创建自定义颜色集。'
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we get into the coding side of color mapping, we need to create an SVG
    image with preset colors. We can think of these preset colors as our *map*. One
    of the most preferred SVG editors amongst many developers is called **Inkscape**
    , which is a free, very easy to use, and full-featured editor. Inkscape can be
    downloaded from the following link, [http://inkscape.org/download/](http://inkscape.org/download/),
    or feel free to work with another SVG editor of your choice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始颜色映射的编码工作之前，需要创建一个带有预设颜色的 SVG 图像。我们可以将这些预设颜色视为我们的*映射图*。许多开发者中最受欢迎的 SVG
    编辑器之一是**Inkscape**，它是一款免费、易于使用且功能齐全的编辑器。可以从以下链接下载 Inkscape，[http://inkscape.org/download/](http://inkscape.org/download/)，或者你也可以选择使用其他你喜欢的
    SVG 编辑器。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Color mapping might sound like it will be a tedious job, but in reality it's
    actually very easy to accomplish. All we need is to keep a little bit of consistency
    between the `SVG` image and the code. Keeping this in mind, the idea of creating
    multicolored, single source textures can be a very quick task. The steps below
    include the process starting from drawing the `SVG` image to allow for easy color
    mapping, as well as writing the code for mapping colors to specific areas of the
    `SVG` image within our application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色映射听起来可能是一项繁琐的工作，但实际上非常容易完成。我们需要做的是保持 `SVG` 图像与代码之间的一点点一致性。牢记这一点，创建多颜色的单一源纹理可以是一个非常快速的任务。以下步骤包括从绘制
    `SVG` 图像以方便颜色映射，到编写将颜色映射到应用程序中 `SVG` 图像特定区域的代码的过程。
- en: 'Drawing our `SVG` image:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制我们的 `SVG` 图像：
- en: In order to easily map colors to an `SVG` texture region during runtime, we
    need to draw an `SVG` image in the editor of our choice. This involves color-coding
    the different segments of our images for easy recognition in our `ISVGColorMapper`
    interface. The following figure depicts a shape with defined color values that
    are displayed on the left of the figure.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在运行时轻松地将颜色映射到 `SVG` 纹理区域，我们需要在选择的编辑器中绘制一个 `SVG` 图像。这涉及到为我们的 `ISVGColorMapper`
    接口容易识别而将图像的不同部分进行颜色编码。下图显示了一个带有定义颜色值的形状，这些颜色值显示在图的左侧。
- en: '![How to do it...](img/8987OS_09_03.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8987OS_09_03.jpg)'
- en: 'Implementing the `ISVGColorMapper` interface:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `ISVGColorMapper` 接口：
- en: 'Just prior to creating the `SVG` texture region via `SVGBitmapTextureAtlasTextureRegionFactory`,
    we will define our `ISVGColorMapper` interface in relation to our `SVG` image.
    If we look at the conditionals in the following code, we can see that we are checking
    for the same color values found in the preceding figure:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在通过 `SVGBitmapTextureAtlasTextureRegionFactory` 创建 `SVG` 纹理区域之前，我们将根据我们的 `SVG`
    图像定义 `ISVGColorMapper` 接口。如果我们查看以下代码中的条件语句，我们可以看到我们正在检查前一个图中找到的相同颜色值：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Lastly, once the interface has been defined, we can pass it in as the final
    parameter when creating the texture region. Once this is done, creating a new
    sprite with the `SVG` texture region will yield the color values defined within
    the color mapper.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一旦定义了接口，我们可以在创建纹理区域时将其作为最后一个参数传入。完成这一步后，使用 `SVG` 纹理区域创建新的精灵将产生颜色映射器中定义的颜色值。
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Just a brief lesson on colors before we start; if you're looking at this recipe's
    code and are confused about the *random* values selected for our conditionals
    and color results, it's very simple. Each color component, red, green and blue,
    can be supplied a color value anywhere between 0 and 255\. passing a value of
    0 to a color component would result in no contribution from that color, while
    passing 255 would be considered to be *full* color contribution. With this in
    mind, we know that if all color components return a value of 0, we will be passing
    the color black to our texture region's path. If we pass a value of 255 to the
    red component, while passing 0 for both green and blue, we know that the texture
    region's path will be a bright red color.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，先简单介绍一下颜色知识；如果你在看这个食谱的代码，并对我们为条件语句和颜色结果选择的*随机*值感到困惑，这非常简单。每个颜色成分（红色、绿色和蓝色）可以提供0到255之间的任何颜色值。将0值传递给颜色成分将导致该颜色没有贡献，而传递255则被认为是*完全*颜色贡献。考虑到这一点，我们知道如果所有颜色成分返回0值，我们将把黑色传递给纹理区域的路径。如果我们给红色成分传递255值，同时绿色和蓝色都传递0，我们知道纹理区域的路径将会是明亮的红色。
- en: 'If we take a look back at the figure in the *How to do it...* section, we can
    see **alpha, red, green, and blue** (**ARGB**) color values with arrows pointing
    to the area on the circle that they represent. These will not directly affect
    the end result of our texture region''s colors; they are simply in place so that
    we can gain a reference to each portion of the circle within our color mapper
    interface. Note that the very first, most outer portion of the circle, is bright
    red at a value of 255\. With that in mind, see the following condition within
    our color mapper:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下*如何操作...*部分中的图表，我们可以看到**alpha、红色、绿色和蓝色**（**ARGB**）的颜色值，以及指向它们代表的圆圈区域的箭头。这些不会直接影响我们纹理区域颜色的最终结果；它们的存在仅仅是为了让我们可以在颜色映射器界面中引用圆圈的每一部分。注意，圆圈最外层的部分是明亮的红色，值为255。考虑到这一点，请看我们颜色映射器中的以下条件：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The conditional statement in the preceding code will check for any path of the
    `SVG` image which contains a pure red value with no contributions from green or
    blue, returning a pure blue color instead. This is how the swapping of colors
    occurs, and this is how we can map colors to our images! Knowing this, it is entirely
    possible to create many different sets of colors for our `SVG` images, but for
    each color set, we must provide a separate texture region.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段代码中的条件语句将会检查`SVG`图像中是否包含没有任何绿色或蓝色贡献的纯红色值，并以纯蓝色替代。这就是颜色交换的原理，也是我们如何将颜色映射到图像中的方法！了解到这一点，我们完全有可能为我们的`SVG`图像创建许多不同的颜色集合，但针对每一组颜色，我们必须提供一个独立的纹理区域。
- en: 'One important key point to note is that we should include a returning value
    that will return the default path''s color values in the event that none of our
    conditions are met. This allows us to leave out conditionals for smaller details
    such as the `SVG` image''s outline, or other colors, and instead fill them in
    as they appear in the image if we were to open it in our favorite `SVG` editor.
    This should be included as the final `else` statement in the color mapper:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意的一个重要关键是，我们应该包含一个返回值，当我们的条件都不满足时，它会返回默认路径的颜色值。这允许我们省略一些条件，比如`SVG`图像的轮廓或其他颜色等小细节，而是在我们喜欢的`SVG`编辑器中打开图像时按出现的颜色填充。这应该作为颜色映射器中的最后一个`else`语句包含：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In the *How it works...* section of this recipe, we covered how to change the
    colors of static `SVG` image paths. Without putting too much thought into the
    idea of creating color themes as mentioned above, it might sound like this is
    the be-all-end-all to creating more objects, terrain, characters, and so on. The
    truth is that, in this day and age, a lot of games need variance in order to create
    an appealing asset. By variance, we are of course referring to gradients. If we
    think back to the conditionals we'd written above, we are checking for absolute
    color values before returning a customized color.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的*工作原理...*部分，我们介绍了如何改变静态`SVG`图像路径的颜色。如果不深入考虑上述提到的创建颜色主题的想法，这听起来像是创建更多对象、地形、角色等的终极方法。但事实上，在当今时代，许多游戏需要变化以创造吸引人的资源。所谓的变化，当然是指渐变。回想我们上面编写的条件语句，我们在返回自定义颜色之前检查绝对的颜色值。
- en: 'Thankfully, working with gradients is not too difficult as we can adjust the
    gradient''s **Stop Color** and the interpolation between colors will automatically
    be handled for us! We can think of a *stop* as a color-defining point of the gradient
    which interpolates between other *stops* as distance increases. This is what causes
    the gradient''s blending effect and this also plays a role in the ease of creating
    color themes through the use of the same method described in this recipe. See
    the following screenshot for a gradient that starts out as a pure red color `RGB{255,
    0, 0}`, to pure green `RGB{0, 255, 0}`, and finally to blue `RGB{0, 0, 255}`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，处理渐变并不太困难，因为我们可以调整渐变的**停止颜色**，而颜色之间的插值将自动为我们处理！我们可以将*停止点*视为定义渐变颜色的点，随着距离的增加，它在其他*停止点*之间进行插值。这就是产生渐变混合效果的原因，这也在通过本食谱中描述的相同方法创建颜色主题时发挥作用。以下是开始为纯红色`RGB{255,
    0, 0}`，到纯绿色`RGB{0, 255, 0}`，最后到蓝色`RGB{0, 0, 255}`的渐变的屏幕截图：
- en: '![There''s more…](img/8987OS_09_04.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/8987OS_09_04.jpg)'
- en: 'If we were to use the above gradient in an `SVG` image, we could easily apply
    color mapping with proper interpolation between the color stops by simply modifying
    the specific color at the position of each stop. The following code will change
    the gradient to appear red, green, and yellow, rather than having blue as the
    third color stop:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在`SVG`图像中使用上述渐变，只需简单修改每个停止点的特定颜色位置，就可以轻松应用颜色映射以及颜色停止点之间的适当插值。以下代码将改变渐变，使其呈现红色、绿色和黄色，而不是将蓝色作为第三个颜色停止点：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: The *Creating high-resolution graphics with SVG* section.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用SVG创建高分辨率图形*部分。'
