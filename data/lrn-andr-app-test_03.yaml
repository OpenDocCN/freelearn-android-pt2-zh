- en: Chapter 3. Baking with Testing Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：测试方法的应用
- en: This chapter provides practical examples of multiple common situations that
    you will encounter, by applying the disciplines and techniques described in the
    previous chapters. The examples are presented in an easy-to-follow manner, so
    you can adapt and use them for your own projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了多个常见情况的实用示例，这些示例应用了前几章描述的纪律和技术。示例以易于跟随的方式呈现，因此你可以调整并用于自己的项目。
- en: 'The following are the topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Android unit tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓单元测试
- en: Testing activities and applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试活动和应用程序
- en: Testing databases and content providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据库和内容提供者
- en: Testing local and remote services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试本地和远程服务
- en: Testing user interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用户界面
- en: Testing exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异常
- en: Testing parsers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试解析器
- en: Testing for memory leaks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试内存泄漏
- en: Testing with Espresso
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Espresso进行测试
- en: After this chapter, you will have a reference to apply different testing recipes
    to your projects for different situations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将有一个参考，可以将不同的测试方法应用到你的项目中，以应对不同的情境。
- en: Android unit tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓单元测试
- en: There are some cases where you really need to test parts of the application
    in isolation with little connection to the underlying system. In Android, the
    system is the Activity framework. In such cases, we have to select a base class
    that is high enough in the test hierarchy to remove some of the dependencies but
    not high enough for us to be responsible for some of the basic infrastructure
    of instantiating Context, for example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你确实需要隔离测试应用程序的部分内容，与底层系统的联系很少。在安卓中，系统是活动框架（Activity framework）。在这种情况下，我们必须选择一个在测试层次结构中足够高的基类，以移除一些依赖，但又不能太高，以至于我们需要负责一些基本的基础设施，如实例化上下文（Context），例如。
- en: 'In such cases, the candidate base class is `AndroidTestCase` because this allows
    the use of Context and Resources without thinking about Activities:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，候选基类是`AndroidTestCase`，因为这样可以在不考虑活动（Activities）的情况下使用上下文（Context）和资源（Resources）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This example is based on the Android **Compatibility Test Suite** (**CTS**)
    at [http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html).
    The CTS is a suite of tests aimed at making the Android hardware and software
    environment consistent for application developers, irrespective of the original
    equipment manufacturer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本例基于[Android兼容性测试套件（CTS）](http://source.android.com/compatibility/cts-intro.html)。CTS旨在为应用开发者提供一个一致的Android硬件和软件环境，无论原始设备制造商如何。
- en: The `AccessPrivateDataTest` class extends `AndroidTestCase` because it's a unit
    test that doesn't require the system infrastructure. In this particular case,
    we could not have used `TestCase` directly because we are using `getContext()`
    later on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccessPrivateDataTest`类扩展了`AndroidTestCase`，因为这是一个不需要系统基础设施的单元测试。在这种情况下，我们不能直接使用`TestCase`，因为我们稍后会用到`getContext()`。'
- en: This test method, `testAccessAnotherAppsPrivateDataIsNotPossible()`, tests the
    access to another package's private data and fails if access is possible. To achieve
    this, the expected exceptions are caught, and if this doesn't happen, `fail()`
    is invoked with a custom message. The test seems pretty straightforward, but you
    can see how powerful this is to stop inadvertent security mistakes from creeping
    in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试方法`testAccessAnotherAppsPrivateDataIsNotPossible()`测试了对另一个包私有数据的访问，如果可以访问则测试失败。为此，捕获了预期的异常，如果异常没有发生，则会使用自定义消息调用`fail()`。测试看似简单，但你可以看到这对于防止无意中的安全错误非常有效。
- en: Testing activities and applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试活动和应用程序
- en: Here, we cover some common cases that you will find in your day-to-day testing,
    including dealing with Intents, Preferences, and Context. You can adapt these
    patterns to suit your specific needs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们涵盖了一些在日常测试中会遇到的常见情况，包括处理意图（Intents）、偏好设置（Preferences）和上下文（Context）。你可以根据具体需求调整这些模式。
- en: Mocking applications and preferences
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟应用程序和偏好设置
- en: In Android parlance, an application refers to a base class used when it is needed
    to maintain a global application state. The full package is `android.app.Application`.
    This can be utilized when dealing with shared preferences.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓术语中，应用程序是指需要维护全局应用状态时使用的基类。完整的包名是`android.app.Application`。在处理共享偏好设置时可以使用。
- en: We expect that the tests that alter these preferences' values will not affect
    the behavior of the real application. Without the correct testing framework, the
    tests could delete user account information for an application that stores these
    values as shared preferences. This doesn't sound like a good idea. So what we
    really need is the ability to mock a Context that also mocks the access to `SharedPreferences`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望那些更改这些偏好设置值的测试不会影响实际应用程序的行为。如果没有正确的测试框架，这些测试可能会删除将偏好值存储为共享偏好的应用程序中的用户账户信息。这听起来可不是个好主意。因此，我们真正需要的是模拟一个`Context`，它同时也能模拟对`SharedPreferences`的访问。
- en: Our first attempt could be to use `RenamingDelegatingContext`, but unfortunately,
    it does not mock `SharedPreferences`, although it is close because it mocks the
    database and filesystem access. So first, we need to mock access to our shared
    preferences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的尝试可能是使用`RenamingDelegatingContext`，但不幸的是，它并不模拟`SharedPreferences`，尽管它已经很接近了，因为它模拟了数据库和文件系统的访问。所以首先，我们需要模拟对共享偏好的访问。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever you come across a new class (like `RenamingDelegatingContext`), it's
    a good idea to read the relevant Java doc to get an overview of how the framework
    developers expect it to be used. For more information, refer to [http://developer.android.com/reference/android/test/RenamingDelegatingContext.html](http://developer.android.com/reference/android/test/RenamingDelegatingContext.html).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当遇到一个新类（如`RenamingDelegatingContext`）时，阅读相关的Java文档以了解框架开发者期望如何使用它是个不错的主意。更多信息，请参考[http://developer.android.com/reference/android/test/RenamingDelegatingContext.html](http://developer.android.com/reference/android/test/RenamingDelegatingContext.html)。
- en: The RenamingMockContext class
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RenamingMockContext类
- en: Let's create the specialized Context. The `RenamingDelegatingContext` class
    is a very good point to start from because as we mentioned before, database and
    filesystem access will be mocked. The problem is how to mock the `SharedPreferences`
    access.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个专门的`Context`。`RenamingDelegatingContext`类是一个很好的起点，因为我们之前提到过，数据库和文件系统的访问将被模拟。问题是怎样模拟对`SharedPreferences`的访问。
- en: 'Remember that `RenamingDelegatingContext`, as its name suggests, delegates
    everything to a Context. So the root of our problem lies in this Context. When
    you access `SharedPreferences` from a Context, you use `getSharedPreferences(String
    name, int mode)`. To change the way this method works, we can override it inside
    `RenamingMockContext`. Now that we have control, we can prepend the name parameter
    with our test prefix, which means that when our tests run, they will write to
    a preferences file that is different than that of our main application:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`RenamingDelegatingContext`，顾名思义，将所有操作委托给一个`Context`。所以我们的问题的根源就在这个`Context`中。当从`Context`访问`SharedPreferences`时，你会使用`getSharedPreferences(String
    name, int mode)`。为了改变这个方法的工作方式，我们可以在`RenamingMockContext`内部重写它。现在我们有了控制权，我们可以用我们的测试前缀来添加名称参数，这意味着当我们的测试运行时，它们将写入与主应用程序不同的偏好设置文件：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we have full control over how preferences, databases, and files are stored.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以完全控制偏好设置、数据库和文件的存储方式。
- en: Mocking contexts
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟上下文
- en: We have the `RenamingMockContext` class. Now, we need a test that uses it. As
    we will be testing an application, the base class for the test would be `ApplicationTestCase`.
    This test case provides a framework in which you can test application classes
    in a controlled environment. It provides basic support for the lifecycle of an
    application, and hooks to inject various dependencies and control the environment
    in which your application is tested. Using the `setContext()` method, we can inject
    the `RenamingMockContext` method before the application is created.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`RenamingMockContext`这个类。现在，我们需要一个使用它的测试。由于我们将要测试应用程序，测试的基类将是`ApplicationTestCase`。这个测试用例提供了一个框架，你可以在这个框架中在一个受控环境中测试应用程序类。它为应用程序的生命周期提供基本支持，以及钩子来注入各种依赖并控制应用程序测试的环境。使用`setContext()`方法，我们可以在创建应用程序之前注入`RenamingMockContext`。
- en: 'We''re going to test an application called `TemperatureConverter`. This is
    a simple application that converts Celsius to Fahrenheit and vice versa. We will
    discuss more about the development of this app in [Chapter 6](part0061_split_000.html#page
    "Chapter 6. Practicing Test-driven Development"), *Practicing Test-driven Development*.
    For now, the details aren''t necessary as we are concentrating on testing scenarios.
    The `TemperatureConverter` application will store the decimal places of any conversion
    as a shared preference. Consequently, we will create a test to set the decimal
    places and then retrieve it to verify its value:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试一个名为`TemperatureConverter`的应用程序。这是一个简单的应用程序，用于将摄氏度转换为华氏度，反之亦然。我们将在[第6章](part0061_split_000.html#page
    "第6章. 实践测试驱动开发")，*实践测试驱动开发*中讨论更多关于这个应用程序的开发。现在，这些细节不是必需的，因为我们专注于测试场景。`TemperatureConverter`应用程序将把任何转换的小数位数存储为共享偏好设置。因此，我们将创建一个测试来设置小数位数，然后检索它以验证其值：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We extend `ApplicationTestCase` using the `TemperatureConverterApplication`
    template parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TemperatureConverterApplication`模板参数扩展了`ApplicationTestCase`。
- en: Then, we use the given name constructor pattern that we discussed in [Chapter
    2](part0020_split_000.html#page "Chapter 2. Understanding Testing with the Android
    SDK"), *Understanding Testing with the Android SDK*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了在[第2章](part0020_split_000.html#page "第2章. 了解使用Android SDK的测试")中讨论的给定名称构造函数模式，*了解使用Android
    SDK的测试*。
- en: 'Here, we have not used a `setUp()` method since there is only one test in the
    class–*you ain''t gonna need it* as they say. One day, if you come to add another
    test to this class, this is when you can override `setUp()` and move the behavior.
    This follows the DRY principle, meaning Don''t Repeat Yourself, and leads to more
    maintainable software. So at the top of the test method, we create the mock context
    and set the context for this test using the `setContext()` method; we create the
    application using `createApplication()`. You need to ensure you call `setContext`
    before `createApplication` as this is how you get the correct instantiation order.
    Now, the code that actually tests for the required behavior setting the decimal
    places, retrieving it, and verifying its value. This is it, using `RenamingMockContext`
    to give us control over `SharedPreferences`. Whenever the `SharedPreference` is
    requested, the method will invoke the delegating context, adding the prefix for
    the name. The original `SharedPreferences` class used by the application are unchanged:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有使用`setUp()`方法，因为类中只有一个测试——正如他们所说，*你不会需要它*。有一天，如果你要向这个类添加另一个测试，这时你可以重写`setUp()`并移动行为。这遵循了DRY原则，即不要重复自己，这会导致软件更易于维护。因此，在测试方法顶部，我们创建模拟上下文并使用`setContext()`方法为此测试设置上下文；我们使用`createApplication()`创建应用程序。你需要确保在`createApplication`之前调用`setContext`，因为这是你获得正确实例化顺序的方式。现在，实际测试所需行为的代码设置小数位数，检索它，并验证其值。就是这样，使用`RenamingMockContext`让我们控制`SharedPreferences`。每当请求`SharedPreference`时，该方法将调用委派上下文，为名称添加前缀。应用程序使用的原始`SharedPreferences`类保持不变：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can verify that our tests do not affect the application by furnishing the
    `TemperatureConverterApplication` class with some value in the shared preferences,
    running the application, then running the tests and eventually verifying that
    this value was not affected by executing the tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为`TemperatureConverterApplication`类提供一些共享偏好设置中的值，运行应用程序，然后执行测试，并最终验证执行测试后该值未受影响，以确保我们的测试不会影响应用程序。
- en: Testing activities
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试活动（Testing activities）
- en: The next example shows how an activity can be tested in complete isolation using
    the `ActivityUnitTestCase<Activity>` base class. A second choice would be `ActivityInstrumentationTestCase2<Activity>`.
    However, the former allows you to create an Activity but not attach it to the
    system, meaning you cannot launch other Activities (you are an Activity single
    unit). This choice of the parent class not only requires more care and attention
    in your setup but also provides a greater flexibility and control over the Activity
    under test. This kind of test is intended to test general Activity behavior and
    not an Activity instance's interaction with other system components or any UI-related
    tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何使用`ActivityUnitTestCase<Activity>`基类完全独立地测试活动。第二个选择是`ActivityInstrumentationTestCase2<Activity>`。然而，前者允许你创建一个活动但不将其附加到系统，这意味着你不能启动其他活动（你是一个活动的单一单元）。这种父类的选择不仅要求你在设置时更加小心注意，同时也为被测试的活动提供了更大的灵活性和控制。这种测试旨在测试一般的活动行为，而不是活动实例与系统其他组件的交互或任何与UI相关的测试。
- en: 'First things first, here is the class under test. It is a simple Activity with
    one button. When this button is pressed, it fires an Intent to start the Dialer
    and finishes itself:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要明确，下面是被测试的类。这是一个带有一个按钮的简单活动。当按下此按钮时，它会触发一个意图来启动拨号器并结束自己：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For our test `case`, we extend `ActivityUnitTestCase<ForwardingActivity>`,
    as we mentioned earlier, as a unit test for an `Activity` class. This activity
    under test will be disconnected from the system, so it is only intended to test
    internal aspects of it and not its interaction with other components. In the `setUp()`
    method, we create the Intent that will start our Activity under test, that is,
    `ForwardingActivity`. Note the use of `getInstrumentation()`. The `getContext`
    class, as at this point in the `setUp()` method of the Activity Context, is still
    null:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试`case`，我们扩展了`ActivityUnitTestCase<ForwardingActivity>`，正如我们之前提到的，作为一个`Activity`类的单元测试。这个被测试的活动将脱离系统，因此它仅用于测试其内部方面，而不是与其他组件的交互。在`setUp()`方法中，我们创建了一个意图，用于启动我们被测试的活动，即`ForwardingActivity`。注意`getInstrumentation()`的使用。此时在`setUp()`方法中的活动上下文`getContext`类仍然是null：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that the setup is done, we can move onto our tests:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置完成了，我们可以继续进行我们的测试：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first test performs a click on the **Go** button of the Forwarding Activity.
    The `onClickListener` class of that button invokes `startActivity()` with an Intent
    that defines a new `Activity` that will be started. After performing this action,
    we verify that the `Intent` used to launch the new Activity is not null. The `getStartedActivityIntent()`
    method returns the Intent that was used if the Activity under tests invoked `startActivity(Intent)`
    or `startActivityForResult(Intent, int)`. Next, we assert that `finish()` was
    called, and we do that by verifying the return value of `FinishCalled()`, which
    returns `true` if one of the `finish` methods (`finish()`, `finishFromChild(Activity)`,
    or `finishActivity(int)`) was called in the Activity under test:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试对Forwarding活动的**Go**按钮进行点击。该按钮的`onClickListener`类调用`startActivity()`，并带有一个定义了将要启动的新`Activity`的意图。执行此操作后，我们验证用于启动新活动的`Intent`不为null。`getStartedActivityIntent()`方法返回了如果被测试的活动调用了`startActivity(Intent)`或`startActivityForResult(Intent,
    int)`所使用的意图。接下来，我们断言`finish()`被调用，通过验证`FinishCalled()`的返回值来做到这一点，如果被测试活动中的`finish`方法之一（`finish()`、`finishFromChild(Activity)`或`finishActivity(int)`）被调用，它将返回`true`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second test is perhaps the more interesting test method in this test case.
    This test case demonstrates how to exercise the Activity life cycle. After starting
    the Activity, `onCreate()` is called automatically, and we can then exercise other
    life cycle methods by invoking them manually. To be able to invoke these methods,
    we use `Intrumentation` of this test. Also, we don't manually invoke `onDestroy()`
    as it will be invoked for us in `tearDown()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试可能是这个测试案例中更有趣的测试方法。这个测试案例演示了如何执行活动生命周期。启动活动后，`onCreate()`会自动调用，然后我们可以通过手动调用其他生命周期方法来进行测试。为了能够调用这些方法，我们使用了这个测试的`Intrumentation`。同时，我们不手动调用`onDestroy()`，因为`tearDown()`会为我们调用它。
- en: Let's walk through the code. This method starts the Activity in the same way
    as the previously analyzed test. After the activity is started, its `onCreate()`
    method is called automatically by the system. We then use `Instrumentation` to
    invoke other life cycle methods to complete the Activity under test start up.
    These correspond to `onStart()` and `onResume()` in the Activity life cycle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解代码。这个方法以之前分析过的测试相同的方式启动 Activity。Activity 启动后，系统会自动调用其 `onCreate()` 方法。然后我们使用
    `Instrumentation` 来调用其他生命周期方法，以完成被测试 Activity 的启动。这些对应于 Activity 生命周期中的 `onStart()`
    和 `onResume()`。
- en: The Activity is now completely started, and it's time to test for the aspects
    we are interested in. Once this is achieved, we can follow other steps in the
    life cycle. Note that this sample test does not assert anything here but simply
    points out how to step through the life cycle. To finish the life cycle, we call
    through to `onPause()` and `onStop()`. As we know, `onDestroy()` is avoided as
    it will automatically be called by `tearDown()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Activity 已经完全启动，是时候测试我们感兴趣的那些方面了。一旦完成，我们可以按照生命周期的其他步骤进行。请注意，这个示例测试在这里并没有断言任何内容，只是指出了如何逐步执行生命周期。为了完成生命周期，我们调用了
    `onPause()` 和 `onStop()`。我们知道，`onDestroy()` 会被 `tearDown()` 自动调用，因此避免了它。
- en: This test represents a test skeleton. You can reuse it to test your Activities
    in isolation and to test life cycle-related cases. The injection of mock objects
    can also facilitate testing of other aspects of the Activity, such as accessing
    system resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试代表了一个测试框架。你可以用它来隔离测试你的 Activities，以及测试与生命周期相关的案例。注入模拟对象还可以方便地测试 Activity
    的其他方面，比如访问系统资源。
- en: Testing files, databases, and content providers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文件、数据库和内容提供者
- en: Some test cases have the need to exercise databases or `ContentProvider` operations,
    and soon comes the need to mock these operations. For example, if we are testing
    an application on a real device, we don't want to interfere with the normal operation
    of applications on the said device, especially if we were to change values that
    may be shared by more than one application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试案例需要执行数据库或 `ContentProvider` 操作，很快就需要模拟这些操作。例如，如果我们正在实机上测试一个应用程序，我们不想干扰该设备上应用程序的正常运行，尤其是如果我们更改可能被多个应用程序共享的值。
- en: Such cases can take advantage of another mock class that is not a part of the
    `android.test.mock` package but of `android.test` instead, namely `RenamingDelegatingContext`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些案例可以利用另一个不属于 `android.test.mock` 包，而是属于 `android.test` 的模拟类，即 `RenamingDelegatingContext`。
- en: Remember, this class lets us mock file and database operations. A prefix supplied
    in the constructor is used to modify the target of these operations. All other
    operations are delegated to the delegating Context that you specify.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个类允许我们模拟文件和数据库操作。在构造函数中提供的缀会在修改这些操作的目标时使用。所有其他操作都委托给你指定的委托上下文。
- en: Suppose our Activity under test uses some files or databases that we want to
    control in some way, probably to introduce specialized content to drive our tests,
    and we don't want to, or we cannot use the real files or database. In such cases,
    we create `RenamingDelegatingContext`, which specifies a prefix. We provide mock
    files using this prefix and introduce any content we need to drive our tests,
    and the Activity under test could use them with no alteration.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在测试的 Activity 使用了一些我们希望在某种方式下控制的文件或数据库，可能是为了引入特殊内容来驱动我们的测试，而我们不想或不能使用真实的文件或数据库。在这种情况下，我们创建一个指定前缀的
    `RenamingDelegatingContext`。我们使用这个前缀提供模拟文件，并引入我们需要驱动测试的任何内容，被测试的 Activity 可以毫无修改地使用它们。
- en: The advantage of keeping our Activity unchanged, that is, not modifying it to
    read from a different source, is that this assures that all the tests are valid.
    If we introduce a change only intended for our tests, we will not be able to assure
    that, under real conditions, the Activity behaves the same.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保持我们的 Activity 不变（即不修改它以从不同的来源读取数据）的优势在于，这样可以确保所有测试的有效性。如果我们引入了一个只为测试而设计的改变，我们将无法确保在实际条件下，Activity
    的行为是相同的。
- en: To demonstrate this case, we will create an extremely simple Activity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个情况，我们将创建一个极其简单的 Activity。
- en: 'The `MockContextExampleActivity` activity displays the content of a file inside
    `TextView`. What we intend to demonstrate is how it displays different content
    during a normal operation of Activity, as compared to when it is under test:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockContextExampleActivity` 活动在 `TextView` 中显示文件的内容。我们想要演示的是，在 Activity 正常运行时与处于测试状态时，它如何显示不同的内容：'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is our simple Activity. It reads the content of the `my_file.txt` file
    and displays it on `TextView`. It also displays any error that might occur. Obviously,
    in a real scenario, you would have better error handling than this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的简单活动。它读取 `my_file.txt` 文件的内容并将其显示在 `TextView` 上。它还会显示可能发生的任何错误。显然，在真实场景中，你会比这有更好的错误处理。
- en: 'We need some content for this file. Probably the easiest way to create the
    files is as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为此文件准备一些内容。创建文件最简单的方法可能如下面的代码所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We created two different files, one named `my_file.txt` and the other `test.my_file.txt`,
    with different content. The latter indicates that it is a mock content. If you
    ran the preceding activity now, you would see **This is real data** as it is reading
    from the expected file `my_file.txt`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个不同的文件，一个名为 `my_file.txt`，另一个名为 `test.my_file.txt`，内容不同。后者表示它是一个模拟内容。如果你现在运行前面的活动，你会看到**这是真实数据**，因为它是从预期的文件
    `my_file.txt` 中读取的。
- en: 'The following code demonstrates the use of this mock data in our activity tests:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了在我们的活动测试中使用这个模拟数据：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `MockContextExampleTest` class extends `ActivityUnitTestCase` because we
    are looking for isolated testing of `MockContextExampleActivity` and because we
    are going to inject a mocked context; in this case, the injected context is `RenamingDelegatingContext`
    as a dependency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockContextExampleTest` 类扩展了 `ActivityUnitTestCase`，因为我们要对 `MockContextExampleActivity`
    进行隔离测试，并且我们将注入一个模拟上下文；在这种情况下，注入的上下文是作为依赖的 `RenamingDelegatingContext`。'
- en: Our fixture consists of the mock context, `mockContext` and `RenamingDelegatingContext`,
    using the target context obtained by `getInstrumentation().getTargetContext()`.
    Note that the context where the instrumentation is run is different than the context
    of the Activity under test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的夹具包括模拟上下文 `mockContext` 和 `RenamingDelegatingContext`，使用通过 `getInstrumentation().getTargetContext()`
    获取的目标上下文。请注意，运行仪器化的上下文与被测试活动的上下文是不同的。
- en: Here a fundamental step follows—since we want to make the existing files and
    databases accessible to this test, we have to invoke `makeExistingFilesAndDbsAccessible()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个基本步骤——由于我们希望让现有的文件和数据库可供这个测试使用，因此我们必须调用 `makeExistingFilesAndDbsAccessible()`。
- en: Then, our test named `testSampleTextDisplayed()` injects the mock context using
    `setActivityContext()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的名为 `testSampleTextDisplayed()` 的测试通过使用 `setActivityContext()` 注入模拟上下文。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You must invoke `setActivityContext()` to inject a mock context before you start
    the Activity under test by invoking `startActivity()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `startActivity()` 启动被测活动之前，你必须调用 `setActivityContext()` 来注入一个模拟上下文。
- en: Then, the Activity is started by `startActivity()` using a blank Intent just
    created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用刚刚创建的空白意图调用 `startActivity()` 启动活动。
- en: We obtain the text value held by the `TextView` by using a getter that we added
    to the Activity. I would never recommend changing production code (that is, exposing
    getters) just for your tests in a real project, as this can lead to bugs, incorrect
    usage patterns by other developers, and security issues. However, here, we are
    demonstrating the use of `RenamingDelegatingContext` rather than test correctness.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用我们添加到活动中的getter来获取 `TextView` 中持有的文本值。我绝不建议在真实项目中仅仅为了测试而改变生产代码（即暴露getter），因为这可能导致错误、其他开发者的错误使用模式和安全问题。然而，这里，我们是在展示使用
    `RenamingDelegatingContext` 而不是测试正确性。
- en: Finally, the text value obtained is checked against the `This is MOCK* data`
    string. It is important here to notice that the value used for this test is the
    test file content and not the real file content.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取的文本值与字符串 `This is MOCK* data` 进行了对比。这里需要注意的是，用于此测试的值是测试文件内容，而不是真实文件内容。
- en: The BrowserProvider tests
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器提供者测试
- en: 'These tests are based on the Browser module of the Android Open Source Project
    (AOSP). The AOSP has lots of great test examples, and using them as an example
    here stops you from writing a lot of boilerplate code to set up the scenario for
    the test. They are intended to test some aspects of the Browser bookmarks, content
    provider, which is part of the standard Browser included with the Android platform
    (not the Chrome app but the default Browser app):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试基于Android开源项目（AOSP）的浏览器模块。AOSP有很多很好的测试示例，使用它们作为这里的例子可以让你不必编写大量用于设置测试场景的样板代码。它们旨在测试浏览器书签的一部分方面，内容提供者，这是Android平台（不是Chrome应用，而是默认的浏览器应用）包含的标准浏览器的一部分：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The fixture created in the `setUp()` method creates a list of `Uris` that are
    used to keep track of the inserted `Uris` to be deleted at the end of each test
    in the `tearDown()` method. The developers could have saved this hassle using
    a mock content provider, maintaining the isolation between our tests and the system.
    Anyway, `tearDown()` iterates over this list and deletes the stored `Uris`. There
    is no need to override the constructor here as `AndroidTestCase` is not a parameterized
    class, and we don't need to do anything special in it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp()`方法中创建的夹具创建了一个`Uris`列表，用于跟踪每个测试在`tearDown()`方法结束时需要删除的插入的`Uris`。开发者本可以使用一个模拟内容提供者来避免这个麻烦，以保持测试与系统的隔离。无论如何，`tearDown()`方法遍历这个列表并删除存储的`Uris`。这里不需要重写构造函数，因为`AndroidTestCase`不是一个参数化类，我们也不需要在其中进行特殊操作。
- en: 'Now comes the test:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试时间：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `testHasDefaultBookmarks()` method is a test to ensure that there are a
    number of default bookmarks always present in the database. On startup, a cursor
    iterates over the default bookmarks obtained by invoking `getBookmarksSuggest("")`,
    which returns an unfiltered cursor of bookmarks; this is why the content provider
    query parameter is `""`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`testHasDefaultBookmarks()`方法是一个测试，用于确保数据库中始终存在一些默认书签。启动时，游标遍历通过调用`getBookmarksSuggest("")`获得的默认书签，这返回一个未经过滤的书签游标；这就是内容提供者查询参数为`""`的原因：'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `testPartialFirstTitleWord()` method and three others like it not shown
    here `testFullFirstTitleWord()`, `testFullFirstTitleWordPartialSecond()`, and
    `testFullTitle()` test for the insertion of bookmarks. To achieve this, they invoke
    `assertInsertQuery()` using the bookmarked URL, its title, and the query. The
    method `assertInsertQuery()` adds the bookmarks to the bookmark provider, inserting
    the URL issued as a parameter with the specified title. The `Uri` returned is
    verified to be not null and not exactly the same as the default one. Finally,
    the `Uri` is inserted in the list of `Uri` instances to be deleted in `tearDown()`.
    The code for this can be seen in the utility methods shown as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`testPartialFirstTitleWord()`方法以及其他三个类似的方法（这里未显示的`testFullFirstTitleWord()`、`testFullFirstTitleWordPartialSecond()`和`testFullTitle()`）测试书签的插入。为此，它们使用书签的
    URL、标题和查询调用`assertInsertQuery()`。`assertInsertQuery()`方法将书签添加到书签提供者中，插入作为参数给出的指定标题的
    URL。返回的`Uri`被验证不为空且不完全是默认的。最后，`Uri`被插入到`tearDown()`中要删除的`Uri`实例列表中。以下代码可以在显示的实用方法中看到：'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unicode is a computing industry standard designed to consistently and uniquely
    encode characters used in written languages throughout the world. The Unicode
    standard uses hexadecimals to express a character. For example, the value \u30ae
    represents the Katakana letter GI (ギ).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 是一个计算行业标准，旨在一致且唯一地编码全世界书面语言中使用的字符。Unicode 标准使用十六进制来表示一个字符。例如，值\u30ae表示片假名字母GI（ギ）。
- en: We have several tests that are intended to verify the utilization of this bookmark
    provider for locales and languages other than just English. These particular cases
    cover the Japanese language utilization in bookmark titles. The tests `testFullTitleJapanese()`,
    and two others that are not shown here, that is, `testPartialTitleJapanese()`
    and `testSoundmarkTitleJapanese()` are the Japanese versions of the tests introduced
    before using Unicode characters. It is recommended to test the application's components
    under different conditions, like in this case, where other languages with different
    character sets are used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个测试旨在验证此书签提供者对于除了英语之外的其他地区和语言的利用情况。这些特定案例涵盖了书签标题中日语的使用情况。测试`testFullTitleJapanese()`以及这里未显示的其他两个测试，即`testPartialTitleJapanese()`和`testSoundmarkTitleJapanese()`是之前使用
    Unicode 字符引入的测试的日语版本。建议在不同的条件下测试应用程序的组件，就像在这种情况下，使用具有不同字符集的其他语言。
- en: 'Several utility methods follow. These are the utilities used in the tests.
    We briefly looked at `assertInsertQuery()` before, so now, let''s look at the
    other methods as well:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来有几个实用方法。这些是在测试中使用的工具。我们之前简要介绍了`assertInsertQuery()`，现在让我们看看其他方法：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The method `assertInsertQuery()` invokes `assertQueryReturns(url`, `title`,
    and `query)`, after `addBookmark()`, to verify that the Cursor returned by `getBookmarksSuggest(query)`
    contains the expected data. This expectation can be summarized as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertInsertQuery()`方法在`addBookmark()`之后调用`assertQueryReturns(url`、`title`和`query)`，以验证`getBookmarksSuggest(query)`返回的游标是否包含预期的数据。这个期望可以概括为：'
- en: The number of rows returned by the query is greater than 0
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的行数大于0
- en: The number of rows returned by the query is equal to 1
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的行数等于1
- en: The title in the returned row is not null
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回行中的标题不为空
- en: The title returned by the query is exactly the same as the method parameter
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的标题与方法的参数完全相同
- en: The second line for the suggestion is not null
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于建议的第二行不为空
- en: The URL returned by the query is not null
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的URL不为空
- en: This URL matches exactly the URL issued as the method parameter
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个URL与作为方法参数发出的URL完全匹配
- en: This strategy provides an interesting pattern to follow in our tests. Some of
    the utility methods that we need to create to complete our tests can also carry
    their own verification of several conditions and improve our test quality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略为我们的测试提供了一个有趣的模式。我们需要创建的一些实用方法来完成我们的测试，也可以自行验证多个条件，提高我们的测试质量。
- en: Creating assert methods in our classes allows us to introduce a domain-specific
    testing language that can be reused when testing other parts of the system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类中创建断言方法，可以引入一种特定领域的测试语言，当测试系统的其他部分时可以重复使用。
- en: Testing exceptions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常
- en: 'We have mentioned this before in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with Testing"), *Getting Started with Testing*, where we stated that you
    should test for exceptions and wrong values instead of just testing positive cases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0014_split_000.html#page "Chapter 1. Getting Started with Testing")中提到过*开始测试*，我们指出你应该测试异常和错误值，而不仅仅是测试正面情况：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have also presented these tests before, but here, we are digging deeper into
    it. The first thing to notice is that these are JUnit4 tests, meaning we can test
    for exceptions using the `expected` annotation parameter. When you download the
    chapter's sample project, you will be able to see that it is split into two modules,
    one of them being core, which is a pure Java module, and so, we have the chance
    to use JUnit4\. At the time of writing this, Android has announced JUnit4 support
    but not yet released it, so we are still on JUnit3 for Instrumented Android tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经介绍过这些测试，但在这里，我们将更深入地探讨它。首先要注意的是，这些是JUnit4测试，意味着我们可以使用`expected`注解参数测试异常。当你下载本章的示例项目时，你会看到它被分为两个模块，其中一个是核心模块，它是一个纯Java模块，因此我们有使用JUnit4的机会。在撰写本文时，Android已经宣布支持JUnit4，但尚未发布，因此对于Android的仪器测试，我们仍然使用JUnit3。
- en: 'Every time we have a method that is supposed to generate an exception, we should
    test this exceptional condition. The best way of doing it is by using JUnit4''s
    `expected` parameter. This declares that the test should throw the exception,
    if it does not throw the exception or throws a different exception, the test will
    fail. This can also be done in JUnit3 by invoking the method under test inside
    a try-catch block, catching the expected exception, and failing otherwise:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有一个应该生成异常的方法时，我们都应该测试这种异常情况。最佳的做法是使用JUnit4的`expected`参数。这声明测试应该抛出异常，如果没有抛出异常或抛出不同的异常，测试将失败。在JUnit3中也可以通过在try-catch块中调用测试方法，捕获预期的异常，否则失败：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing local and remote services
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试本地和远程服务
- en: 'When you want to test an `android.app.Service`, the idea is to extend the `ServiceTestCase<Service>`
    class to test in a controlled environment:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想测试一个`android.app.Service`时，想法是扩展`ServiceTestCase<Service>`类，在受控环境中进行测试：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The constructor, as in other similar cases, invokes the parent constructor that
    passes the Android service class as a parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，像其他类似的情况一样，调用父构造函数，将Android服务类作为参数传递。
- en: This is followed by `testBasicStartup()`. We start the service using an Intent
    that we create here, setting its class to the class of the service under test.
    We also use the instrumented Context for this Intent. This class allows for some
    dependency injection, as every service depends on the Context in which it runs,
    and the application with which it is associated. This framework allows you to
    inject modified, mock, or isolated replacements for these dependencies, and thus
    performs a true unit test.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是`testBasicStartup()`。我们使用一个Intent启动服务，在这里创建它，将其类设置为正在测试的服务类。我们还为这个Intent使用仪器化上下文。这个类允许一些依赖注入，因为每个服务都依赖于其运行的上下文以及与之关联的应用程序。这个框架允许你注入修改过的、模拟的或独立的依赖替代品，从而执行真正的单元测试。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Dependency Injection** (**DI**) is a software design pattern that deals with
    how components get hold of their dependencies. You can do this yourself manually
    or use one of the many dependency injection libraries.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种软件设计模式，涉及组件如何获取其依赖关系。你可以手动完成这一操作，或者使用众多依赖注入库中的一个。'
- en: Since we simply run our tests as is, the service will be injected with a fully
    functional `Context` and a generic `MockApplication` object. Then, we start the
    service using the `startService(startIntent)` method, in the same way as if it
    were started by `Context.startService()`, providing the arguments it supplied.
    If you use this method to start the service, it will automatically be stopped
    by `tearDown()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是按原样运行测试，服务将被注入一个功能完整的`Context`和一个通用的`MockApplication`对象。然后，我们使用`startService(startIntent)`方法启动服务，这与通过`Context.startService()`启动服务的方式相同，并提供它所提供的参数。如果你使用此方法启动服务，它将自动由`tearDown()`停止。
- en: Another test, `testBindable()`, will test whether the service can be bound.
    This test uses `bindService(startIntent)`, which starts the service under test
    in the same way as if it were started by `Context.bindService()`, providing the
    arguments it supplied. It returns the communication channel to the service. It
    may return null if clients cannot bind to the service. Most probably, this test
    should check for the null return value in the service with an assertion like `assertNotNull(service)`
    to verify that the service was bound correctly, but it doesn't, so we can focus
    on the framework classes in use. Be sure to include this test when you write code
    for similar cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试`testBindable()`，将测试服务是否可以被绑定。这个测试使用`bindService(startIntent)`，它以与通过`Context.bindService()`启动服务相同的方式启动正在测试的服务，并提供它所提供的参数。它返回与服务通信的通道。如果客户端无法绑定到服务，它可能返回
    null。这个测试应该用类似`assertNotNull(service)`的断言检查服务中的 null 返回值，以验证服务是否正确绑定，但实际没有这样做，因此我们可以专注于使用的框架类。在编写类似情况的代码时，请务必包含此测试。
- en: 'The returned `IBinder` is usually for a complex interface that has been described
    using AIDL. In order to test with this interface, your service must implement
    a `getService()` method, as shown in `DummService` in the example project for
    this chapter; which has this implementation of that method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`IBinder`通常是一个使用 AIDL 描述的复杂接口。为了测试这个接口，你的服务必须实现一个`getService()`方法，如本章示例项目中的`DummService`所示；该方法有以下实现：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Extensive use of mock objects
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广泛使用模拟对象
- en: In the previous chapters, we described and used the mock classes that are present
    in the Android SDK. While these classes can cover a great number of cases, there
    are other Android classes and your own domain classes to consider. You might have
    the need for other mock objects to furnish your test cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述并使用了 Android SDK 中存在的模拟类。尽管这些类可以覆盖很多情况，但也有其他 Android 类和你的领域类需要考虑。你可能需要其他模拟对象来丰富你的测试用例。
- en: Several libraries provide the infrastructure to satisfy our mocking needs, but
    we are now concentrating on Mockito, which is perhaps the most widely used library
    in Android.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 几个库提供了满足我们模拟需求的基础设施，但现在我们专注于 Mockito，这可能是 Android 中使用最广泛的库。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not a Mockito tutorial. We will just be analyzing its use in Android,
    so if you are not familiar with it, I would recommend that you take a look at
    the documentation available on its website at [https://code.google.com/p/mockito/](https://code.google.com/p/mockito/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个 Mockito 教程。我们只是分析它在 Android 中的使用，所以如果你不熟悉它，我建议你查看其网站上的文档，网址为[https://code.google.com/p/mockito/](https://code.google.com/p/mockito/)。
- en: Mockito is an open source software project available under the MIT license,
    and provides test doubles (mock objects). It is a perfect match for Test-driven
    Development due to the way it verifies expectations and due to its dynamically
    generated mock objects because they support refactoring, and the test code will
    not break when renaming methods or changing its signature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 是一个开源软件项目，可在 MIT 许可下使用，并提供测试替身（模拟对象）。由于其验证期望的方式和动态生成的模拟对象，它非常适合测试驱动开发，因为它们支持重构，且在重命名方法或更改其签名时，测试代码不会断裂。
- en: 'Summarizing its documentation, the most relevant benefits of Mockito are as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 概括其文档，Mockito 最相关的优势如下：
- en: Ask questions about interactions after execution
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行后询问交互问题
- en: It is not expect-run-verify – avoids expensive setup
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是期望-运行-验证——避免昂贵的设置
- en: One way to mock that is a simple API
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种模拟简单 API 的方法
- en: Easy refactoring with types used
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型进行简单的重构
- en: It mocks concrete classes as well as interfaces
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以模拟具体类以及接口
- en: To demonstrate its usage and to establish a style that can be later reproduced
    for other tests, we are completing some example test cases.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示其用法，并确立一种稍后可以用于其他测试的风格，我们正在完成一些示例测试用例。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest version of Mockito supported by Android as of this writing is Dexmaker
    Mockito 1.1\. You might want to try out a different one, but you will most probably
    encounter problems.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文撰写时，Android支持的最新版Mockito是Dexmaker Mockito 1.1。你可能想尝试其他版本，但很可能会遇到问题。
- en: 'The first thing we should do is add `Mockito` as a dependency for your Android
    instrumentation tests. This is as simple as adding the `androidTestCompile` reference
    to your dependencies closure. Gradle will do the rest, that is, download the JAR
    file and add it to your classpath:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该做的是将`Mockito`作为依赖添加到你的Android仪器测试中。这只需简单地在你的依赖闭包中添加`androidTestCompile`引用。Gradle会完成剩下的工作，即下载JAR文件并将其添加到你的类路径中：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to use Mockito in our tests, we only need to statically import its
    methods from `org.mockito`. Usually, your IDE will give you the option to statically
    import these, but if it does not, you can try to add them manually (if the code
    is red when manually added, then you have a problem with the library being available):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的测试中使用Mockito，我们只需要从`org.mockito`静态导入其方法。通常，你的IDE会给你静态导入这些选项，但如果它没有，你可以尝试手动添加（如果手动添加时代码变红，那么你遇到的问题就是库不可用的问题）。
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is preferable to use specific imports instead of using the wildcard. The
    wildcards are here just for brevity. It is most likely that when your IDE autosaves,
    it will expand them into the imports needed (or remove them if you aren't using
    them!).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用特定的导入，而不是使用通配符。这里使用通配符只是为了简洁。很可能当你的IDE自动保存时，它会将它们扩展为所需的导入（或者如果你没有使用它们，就会移除它们！）。
- en: Importing libraries
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入库
- en: 'We have added the Mockito library to the project''s Java Build Path. Usually,
    this is not a problem, but sometimes, rebuilding the project leads us to the following
    error that stops the project being built: **Error: duplicate files during packaging
    of APK**.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将Mockito库添加到了项目的Java构建路径中。通常这不会有问题，但有时，重新构建项目会导致以下错误，阻止项目构建：**错误：在APK打包期间文件重复**。
- en: This depends on how many libraries are included by the project and what they
    are.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于项目中包含了多少库以及它们是什么。
- en: 'Most of the available open source libraries have a similar content as proposed
    by GNU and include files such as `LICENSE`, `NOTICE`, `CHANGES`, `COPYRIGHT`,
    and `INSTALL`, among others. We will find this problem as soon as we try to include
    more than one in the same project to ultimately build a single APK. This can be
    resolved in your `build.gradle`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可用的开源库都包含类似GNU提议的内容，并包含如`LICENSE`、`NOTICE`、`CHANGES`、`COPYRIGHT`和`INSTALL`等文件。当我们尝试在同一个项目中包含多个库以最终构建一个单一的APK时，我们会立即遇到这个问题。你可以在你的`build.gradle`中解决这个问题：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Mockito usage example
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mockito使用示例
- en: Let's create `EditText`, which only accepts signed decimal numbers. We'll call
    it `EditNumber`. `EditNumber` uses `InputFilter` to provide this feature. In the
    following tests, we will be exercising this filter to verify that the correct
    behavior is implemented.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个只接受有符号十进制数的`EditText`，我们将它称为`EditNumber`。`EditNumber`使用`InputFilter`提供此功能。在以下测试中，我们将执行此过滤器来验证是否实现了正确的行为。
- en: To create the test, we will be using a property that `EditNumber` inherits from
    `EditText`, so it can add a listener, actually a `TextWatcher`. This will provide
    methods that are called whenever the text of `EditNumber` changes. This `TextWatcher`
    is a collaborator for the test, and we could have implemented it as its own separate
    class and verified the results of calling its methods, but this is tedious, and
    might introduce more errors, so the approach taken is to use Mockito in order
    to avoid the need of writing an external `TextWatcher`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建测试，我们将使用`EditNumber`从`EditText`继承的一个属性，这样它就可以添加一个监听器，实际上是一个`TextWatcher`。这将提供当`EditNumber`的文本发生变化时调用的方法。这个`TextWatcher`是测试的协助者，我们可以将其实现为单独的类，并验证调用其方法的结果，但这样做既繁琐，可能会引入更多错误，所以我们采用的方法是使用Mockito，以避免编写外部的`TextWatcher`。
- en: This is precisely how we are introducing a mock `TextWatcher` to check method
    invocations when the text changes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们引入一个模拟的`TextWatcher`来检查文本变化时方法调用的方式。
- en: The EditNumber filter tests
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditNumber过滤器测试
- en: This suite of tests will exercise `InputFilter` behavior of `EditNumber`, checking
    the method calls on the `TextWatcher` mock and verifying the results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件将执行`EditNumber`的`InputFilter`行为，检查`TextWatcher`模拟上的方法调用并验证结果。
- en: We are using an `AndroidTestCase` because we are interested in testing `EditNumber`
    in isolation of other components or Activities.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AndroidTestCase`，因为我们希望独立于其他组件或活动来测试`EditNumber`。
- en: 'We have several inputs that need to be tested (we allow decimal numbers, but
    do not allow multiple decimals, letters, and so on), and so we can have one test
    with an array of expected input and an array of expected output. However, the
    test can get very complicated and would be awful to maintain. A better approach
    is to have one test for each test case of `InputFilter`. This allows us to give
    meaningful names to our tests and an explanation of what we are aiming to test.
    We will finish up with a list like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个需要测试的输入（我们允许小数，但不允许多个小数点、字母等），因此我们可以有一个带有预期输入数组和预期输出数组的测试。然而，测试可能会变得非常复杂，难以维护。更好的方法是针对`InputFilter`的每个测试用例都有一个测试。这允许我们给测试赋予有意义的名称，并解释我们旨在测试的内容。我们将以如下列表结束：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we will run through the use of mocks for one of these tests `testTextChangedFilterWorksForCharacterInput()`,
    and if you check the example project, you will see that all the other tests follow
    the same pattern, and we have actually extracted out a helper method that acts
    as a custom assertion for all tests:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过一个测试`testTextChangedFilterWorksForCharacterInput()`来介绍模拟对象的使用，如果你查看示例项目，你会发现所有其他测试都遵循相同的模式，实际上我们已经提取了一个帮助方法，该方法作为所有测试的自定义断言：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the text case is pretty straightforward; it asserts that when
    you enter `A1A` into the text of the **EditNumber** view, the text is actually
    changed into `1`. This means that our EditNumber has filtered out the characters.
    An interesting thing happens when we look at the `assertEditNumberTextChangeFilter(input,
    output)` helper method. Within our helper method is where we verify that the `InputFilter`
    is doing its job and it is here we use Mockito. There are four common steps to
    take when using Mockito mock objects:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试用例非常直接；它断言当你将`A1A`输入到**EditNumber**视图的文本中时，文本实际上被更改为`1`。这意味着我们的EditNumber已经过滤掉了字符。当我们查看`assertEditNumberTextChangeFilter(input,
    output)`帮助方法时，会发生一件有趣的事情。在我们的帮助方法中，我们验证了`InputFilter`是否正在执行其工作，这里我们使用了Mockito。使用Mockito模拟对象时有四个常见步骤：
- en: Instantiate the intended mocks that are ready for use.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化准备好的模拟对象。
- en: Determine what behavior is expected and stub it to return any fixture data.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定预期的行为并将其存根以返回任何固定数据。
- en: Exercise the methods, usually by invoking methods of the class under test.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法，通常是通过调用测试类的各个方法。
- en: Verify the behavior of your mock object to pass the test.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证模拟对象的行为以通过测试。
- en: According to step one, we create a mock `TextWatcher` using `mock(TextWatcher.class)`
    and set it as our `TextChangedListener` on EditNumber.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第一步，我们使用`mock(TextWatcher.class)`创建一个模拟的`TextWatcher`，并将其设置为EditNumber上的`TextChangedListener`。
- en: We skip step two in this instance as we have no fixture data, in that the class
    we are mocking does not have any methods that are expected to return a value.
    We'll come back to this in another test later on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们跳过第二步，因为没有固定数据，即我们模拟的类没有任何预期返回值的方法。稍后我们在另一个测试中会回到这一点。
- en: In step three, we have our mock in place, and we can exercise the method under
    test to perform its intended action. In our case, the method is `editNumber.setText(input)`,
    and the intended action is to set the text and thus prompt our `InputFilter` to
    run.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们已经设置好了模拟对象，可以执行测试方法以执行其预期操作。在我们的案例中，方法是`editNumber.setText(input)`，预期操作是设置文本，从而触发我们的`InputFilter`运行。
- en: 'Step four is where we verify that the text was actually changed by our filter.
    Let''s break step four down a little. Here are our verifications again:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步是验证文本是否确实被我们的过滤器更改。让我们稍微分解一下第四步。以下是我们再次的验证：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will be using two custom written matchers (`editableCharSequenceEq(String)`
    and `charSequenceEq(String)`) because we are interested in comparing the string
    content for different classes used by Android, such as `Editable` and `CharSequence`.
    When you use a special matcher, it means all comparisons done for that verification
    method call need a special wrapper method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个自定义匹配器（`editableCharSequenceEq(String)` 和 `charSequenceEq(String)`），因为我们关心的是比较
    Android 使用的不同类（如 `Editable` 和 `CharSequence`）的字符串内容。当你使用一个特殊的匹配器时，这意味着对该验证方法调用的所有比较都需要一个特殊的包装方法。
- en: The other matcher, `eq()`, expects `int` that is equal to the given value. The
    latter is provided by Mockito for all primitive types and objects, but we need
    to implement `editableCharSequenceEq()` and `charSequenceEq()` as it is an Android-specific
    matcher.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个匹配器 `eq()`，期望得到一个等于给定值的 `int`。后者由 Mockito 为所有原始类型和对象提供，但我们需要实现 `editableCharSequenceEq()`
    和 `charSequenceEq()`，因为这是一个针对 Android 的特定匹配器。
- en: 'Mockito has a predefined `ArgumentMatcher` that would help us create our matcher.
    You extend the class and it gives you one method to override:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 有一个预定义的 `ArgumentMatcher`，可以帮助我们创建匹配器。你扩展这个类，它会给你一个要覆盖的方法：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `matches` argument matcher method expects an argument that you can use to
    compare against a predefined variable. This argument is the "actual" result of
    your method invocation, and the predefined variable is the "expected" one. You
    then decide to return true or false whether they are the same or not.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`matches` 参数匹配器方法期望得到一个你可以用来与预定义变量进行比较的参数。这个参数是你方法调用的“实际”结果，而预定义变量是“预期”的。然后你决定返回
    true 或 false，看它们是否相同。'
- en: 'As you might have already realized, the custom `ArgumentMatcher` class''s frequent
    use in a test could become really complex and might lead to errors, so to simplify
    this process, we will be using a helper class that we call `CharSequenceMatcher`.
    We also have `EditableCharSequenceMatcher`, which can be found in the example
    project of this chapter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，自定义 `ArgumentMatcher` 类在测试中的频繁使用可能会变得非常复杂，并可能导致错误，为了简化这个过程，我们将使用一个辅助类，我们称之为
    `CharSequenceMatcher`。我们还有 `EditableCharSequenceMatcher`，可以在本章的示例项目中找到：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We implement matches by returning the result of the comparison of the object
    passed as arguments with our predefined field after they are converted to a string.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过返回将作为参数传递的对象与转换为字符串后我们预定义的字段比较的结果来实现匹配。
- en: 'We also override the `describeTo` method, and this allows us to change the
    error message when the verification fails. This is always a good tip to remember:
    take a look at the error messages before and after doing this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还覆盖了 `describeTo` 方法，这允许我们在验证失败时更改错误消息。这是一个始终要记住的好技巧：在这样做之前和之后，查看错误消息。
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the static instantiation method for our matcher is used and we import
    this as a static method, in our test, we can simply write:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用匹配器的静态实例化方法并将其作为静态方法导入测试中时，我们可以简单地编写：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing views in isolation
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离测试视图
- en: The test that we are analyzing here is based on the Focus2AndroidTest from the
    Android SDK ApiDemos project. It demonstrates how some properties of the Views
    that conform to a layout can be tested when the behavior itself cannot be isolated.
    The testing focusability of a view is one of these situations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里分析的测试是基于 Android SDK ApiDemos 项目中的 Focus2AndroidTest。它演示了当行为本身无法被隔离时，如何测试符合布局的视图的一些属性。测试视图的可聚焦性就是这种情况之一。
- en: 'We are only testing individual views. In order to avoid creating the full Activity,
    this test extends `AndroidTestCase`. You may have thought about using just `TestCase`,
    but unfortunately, this is not possible as we need a Context to inflate the XML
    layout via `LayoutInflater`, and `AndroidTestCase` will provide us with this component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只测试单个视图。为了避免创建完整的 Activity，这个测试扩展了 `AndroidTestCase`。你可能考虑过仅使用 `TestCase`，但不幸的是，这是不可能的，因为我们需要一个
    Context 来通过 `LayoutInflater` 加载 XML 布局，而 `AndroidTestCase` 将为我们提供此组件：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The setup prepares our test as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 设置将按以下方式准备我们的测试：
- en: We request a `FocusFinder` class. This is a class that provides the algorithm
    used to find the next focusable View. It implements the singleton pattern and
    that's why we use `FocusFinder.getInstance()` to obtain a reference to it. This
    class has several methods to help us find focusable and touchable items, given
    various conditions as the nearest in a given direction or searching from a particular
    rectangle.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们请求一个`FocusFinder`类。这是一个提供用于查找下一个可聚焦视图的算法的类。它实现了单例模式，因此我们使用`FocusFinder.getInstance()`来获取它的引用。这个类有几种方法可以帮助我们找到在不同条件下可聚焦和可触摸的项，例如在给定方向上最近的或者从特定矩形区域开始搜索。
- en: Then, we get the `LayoutInflater` class and inflate the layout under test. One
    thing we need to take into account, as our test is isolated from other parts of
    the system, is that we have to manually measure and lay out the components.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取`LayoutInflater`类并展开测试下的布局。由于我们的测试与其他系统部分隔离，我们需要考虑的一件事是，我们必须手动测量和布局组件。
- en: Then, we use the find views pattern and assign the found views to the fields.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用查找视图模式并将找到的视图分配给字段。
- en: 'In a previous chapter, we enumerated all the available asserts in our arsenal,
    and you may remember that to test a View''s position, we had a complete set of
    assertions in the `ViewAsserts` class. However, this depends on how the layout
    is defined:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们列举了我们的工具库中所有可用的断言，您可能还记得，为了测试视图的位置，我们在`ViewAsserts`类中有一套完整的断言。然而，这取决于布局是如何定义的：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The method `testGoingRightFromLeftButtonJumpsOverCenterToRight()`, as its name
    suggests, tests the focus gained by the right button when the focus moves from
    the left to the right button. To achieve this search, the instance of `FocusFinder`
    obtained during the `setUp()` method is employed. This class has a `findNextFocus()`
    method to obtain the View that receives focus in a given direction. The value
    obtained is checked against our expectations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`testGoingRightFromLeftButtonJumpsOverCenterToRight()`方法，如其名称所示，测试了当焦点从左向右移动时，右侧按钮获得焦点的情况。为了实现这一搜索，我们在`setUp()`方法中获得的`FocusFinder`实例被使用。这个类有一个`findNextFocus()`方法，可以获取在给定方向上接收焦点的视图。获得的值与我们的预期进行对比检查。'
- en: In a similar way, the `testGoingLeftFromRightButtonGoesToCenter()` test tests
    the focus that goes in the other direction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`testGoingLeftFromRightButtonGoesToCenter()`测试检查了相反方向上的焦点移动。
- en: Testing parsers
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试解析器
- en: There are many occasions where your Android application relies on external XML,
    JSON messages, or documents obtained from web services. These documents are used
    for data interchange between the local application and the server. There are many
    use cases where XML or JSON documents are obtained from the server or generated
    by the local application to be sent to the server. Ideally, methods invoked by
    these activities have to be tested in isolation to have real unit tests, and to
    achieve this, we need to include some mock files somewhere in our APK to run the
    tests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您的Android应用程序依赖于从Web服务获取的外部XML、JSON消息或文档。这些文档用于本地应用程序和服务器之间的数据交换。有许多用例需要从服务器获取XML或JSON文档，或者由本地应用程序生成并发送到服务器。理想情况下，由这些活动调用的方法必须独立测试以实现真正的单元测试，为此，我们需要在APK中包含一些模拟文件以运行测试。
- en: But the question is where can we include these files?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是，我们可以在哪里包含这些文件呢？
- en: Let's find out.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出答案。
- en: Android assets
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓资产
- en: 'To begin, a brief review of the assets'' definition can be found in the Android
    SDK documentation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以在Android SDK文档中找到关于资产定义的简要回顾。
- en: '*The difference between "resources" and "assets" isn''t much on the surface,
    but in general, you''ll use resources to store your external content much more
    often than you''ll use assets. The real difference is that anything placed in
    the resources directory will be easily accessible from your application from the
    R class, which is compiled by Android. Whereas, anything placed in the assets
    directory will maintain its raw file format and, in order to read it, you must
    use the AssetManager to read the file as a stream of bytes. So keeping files and
    data in resources (res/) makes them easily accessible.*'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“资源”和“资产”之间的区别表面上看不大，但通常您会更频繁地使用资源来存储外部内容，而不是使用资产。真正的区别在于，放在资源目录中的任何东西都可以通过Android编译的R类轻松地从应用程序中访问。而放在资产目录中的任何东西将保持其原始文件格式，为了读取它，您必须使用`AssetManager`将文件作为字节流读取。因此，将文件和数据放在资源（res/）目录中可以更容易地访问它们。*'
- en: Clearly, assets are what we need to store the files that will be parsed to test
    the parser.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，assets是我们需要存储将被解析以测试解析器的文件。
- en: So our XML or JSON files should be placed in the assets folder to prevent manipulation
    at compile time and to be able to access the raw content while the application
    or tests are run.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的XML或JSON文件应该放在assets文件夹中，以防止编译时被操纵，并能够在应用程序或测试运行时访问原始内容。
- en: But be careful, we need to place them in the assets of our `androidTest` folder
    because then, these are not part of the application, and we don't want them packed
    with our code when we release a live application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心，我们需要将它们放在`androidTest`文件夹的assets中，因为这样，这些就不是应用程序的一部分，而且我们不想在发布实时应用程序时将它们与我们的代码打包在一起。
- en: The parser test
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器测试
- en: 'This test implements an `AndroidTestCase` as all we need is a Context to be
    able to reference our assets folder. Also, we have written the parsing inside
    of the test, as the point of this test is not how to parse xml but how to reference
    mock assets from your tests:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试实现了一个`AndroidTestCase`，因为我们只需要一个上下文来引用我们的assets文件夹。同时，我们在测试中编写了解析，因为此测试的重点不是如何解析xml，而是如何从你的测试中引用模拟资产：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `InputStream` class is obtained by opening the `my_document.xml` file from
    the assets by `getContext().getAssets()`. Note that the Context and thus the assets
    obtained here are from the tests package and not from the Activity under test.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputStream`类是通过使用`getContext().getAssets()`从assets中打开`my_document.xml`文件获得的。请注意，这里获得的上下文和资产来自测试包，而不是被测Activity。'
- en: Next, the `parseXml()` method is invoked using the recently obtained `InputStream`.
    If there is an `IOException`, the test will fail and spit out the error from the
    stack trace, and if everything goes well, we test that the result is not null.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用最近获得的`InputStream`调用`parseXml()`方法。如果发生`IOException`，测试将失败并输出堆栈跟踪中的错误，如果一切顺利，我们将测试结果不为空。
- en: We should then provide the XML we want to use for the test in an asset named
    `my_document.xml`. You want the asset to be under the test project folder; by
    default, this is `androidTest/assets`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该在名为`my_document.xml`的资产中提供我们想要用于测试的XML，资产应该在测试项目文件夹下；默认情况下，这是`androidTest/assets`。
- en: 'The content could be:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内容可能是：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Testing for memory usage
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试内存使用情况
- en: Sometimes, memory consumption is an important factor to measure the good behavior
    of the test target, be it an Activity, Service, Content Provider, or another component.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，内存消耗是衡量测试目标（无论是Activity、Service、Content Provider还是其他组件）良好行为的一个重要因素。
- en: 'To test for this condition, we can use a utility test that you can invoke from
    other tests mainly after having run a test loop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种情况，我们可以使用一个实用测试工具，你可以在运行测试循环后，主要从其他测试中调用它：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This assertion can be called from other tests. At the beginning, it obtains
    `MemoryInfo` from `ActivityManager` using `getMemoryInfo()`, after getting the
    instance using `getSystemService()`. The `lowMemory` field is set to `true` if
    the system considers itself to currently be in a low memory situation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言可以从其他测试中调用。首先，它通过使用`getSystemService()`获取实例后，使用`getMemoryInfo()`从`ActivityManager`获取`MemoryInfo`。如果系统认为自己当前处于低内存状态，则`lowMemory`字段被设置为`true`。
- en: In some cases, we want to dive even deeper into the resource usage and can obtain
    more detailed information from the process table.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们想要更深入地了解资源使用情况，并可以从进程表中获得更详细的信息。
- en: 'We can create another helper method to obtain process information and use it
    in our tests:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建另一个辅助方法来获取进程信息，并在我们的测试中使用它：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To obtain this information, a command (in this case, `ps` is used, but you can
    adapt it to your needs) is executed using `Runtime.exec()`. The output of this
    command is concatenated in a string that is later returned. We can use the return
    value to print it to the logs in our test, or we can further process the content
    to obtain summary information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这些信息，使用`Runtime.exec()`执行了一个命令（在本例中使用了`ps`，但你可以根据需要调整它）。这个命令的输出被连接在一个字符串中，稍后返回。我们可以使用返回值将输出发送到测试中的日志，或者进一步处理内容以获得摘要信息。
- en: 'This is an example of logging the output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个记录输出的例子：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When this test is run, we obtain information about the running processes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此测试时，我们可以获取有关运行进程的信息：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The output was cut for brevity, but if you run it, you will get the complete
    list of processes that run on the system.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为了简洁起见已被截断，但如果你运行它，你会得到系统上运行的完整进程列表。
- en: 'A brief explanation of the information obtained is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的信息简要解释如下：
- en: '| Column | Description |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 描述 |'
- en: '| --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| USER | This is the textual user ID. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| USER | 这是文本用户ID。 |'
- en: '| PID | This is the process ID number of the process. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| PID | 这是进程的进程ID号。 |'
- en: '| PPID | This is the parent process ID. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| PPID | 这是父进程ID。 |'
- en: '| VSIZE | This is the virtual memory size of the process in KB. This is the
    virtual memory the process reserves. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| VSIZE | 这是进程的虚拟内存大小，以KB为单位。这是进程保留的虚拟内存。 |'
- en: '| RSS | This is the resident set size, the non-swapped physical memory that
    a task has used (in pages). This is the actual amount of real memory the process
    takes in pages.This does not include pages that have not been demand-loaded in.
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| RSS | 这是常驻集合大小，即任务已使用的非交换物理内存（以页为单位）。这是进程实际占用的真实内存页数。这不包括尚未按需加载的页面。 |'
- en: '| WCHAN | This is the "channel" in which the process is waiting. It is the
    address of a system call, and can be looked up in a name list if you need a textual
    name. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| WCHAN | 这是进程等待的“通道”。它是系统调用的地址，如果需要文本名称，可以在名称列表中查找。 |'
- en: '| PC | This is the current EIP (instruction pointer). |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| PC | 这是当前的EIP（指令指针）。 |'
- en: '| State (no header) | This denotes the process states, which are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '| 状态（无标题） | 这表示以下的过程状态： |'
- en: S is used to indicate sleeping in an interruptible state
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S用于表示在可中断状态下的睡眠
- en: R is used to indicate running
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R用于表示运行中
- en: T is used to indicate a stopped process
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T用于表示已停止的进程
- en: Z is used to indicate a zombie
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z用于表示僵尸进程
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Column** | **Description** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **列** | **描述** |'
- en: '| NAME | This denotes the command name. The application processes in Android
    are renamed after its package name. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| NAME | 这表示命令名称。Android中的应用程序进程会以其包名重命名。 |'
- en: Testing with Espresso
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Espresso进行测试
- en: Testing UI components can be difficult. Knowing when a view has been inflated
    or ensuring you don't access views on the wrong thread can lead to strange behavior
    and flaky tests. This is why Google has released a helper library for UI-related
    instrumentation tests called Espresso ([https://code.google.com/p/android-test-kit/wiki/Espresso](https://code.google.com/p/android-test-kit/wiki/Espresso)).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 测试UI组件可能很困难。了解视图何时被加载或确保不在错误的线程上访问视图可能会导致奇怪的行为和不确定的测试结果。这就是谷歌发布了一个用于UI相关自动化测试的帮助库Espresso的原因。（[https://code.google.com/p/android-test-kit/wiki/Espresso](https://code.google.com/p/android-test-kit/wiki/Espresso)）。
- en: 'Adding the Espresso library JAR can be achieved by adding to the `/libs` folder,
    but to make it easier for Gradle users, Google released a version to their Maven
    repository (consider yourselves lucky users because this was not available before
    version 2.0). When using Espresso, you need to use the bundled TestRunner as well.
    Therefore, the setup becomes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将Espresso库JAR添加到`/libs`文件夹中可以实现，但为了方便Gradle用户，谷歌发布了他们的Maven仓库版本（因为幸运的是，在2.0版本之前这是不可用的）。使用Espresso时，还需要使用捆绑的TestRunner。因此，设置变为：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once the Espresso dependency has been added to your project, you have a fluid
    interface to be able to assert the behavior on your UI elements. In our example,
    we have an Activity that allows you to order Espresso coffee. When you press the
    order button, a nice Espresso image appears. We want to verify this behavior in
    an instrumentation test.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Espresso依赖项被添加到项目中，您就可以流畅地断言UI元素的行为。在我们的示例中，我们有一个允许您订购Espresso咖啡的Activity。当您按下订单按钮时，会出现一个精美的Espresso图像。我们希望在一个自动化测试中验证这种行为。
- en: 'The first thing to do is to set up our Activity to test. We use `ActivityInstrumentationTestCase2`
    so that we can have a full lifecycle Activity running. You need to call `getActivity()`
    at the start of your test or in the `setup()` method to allow the activity to
    be started and for Espresso to find the Activity in a resumed state:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是设置我们的Activity进行测试。我们使用`ActivityInstrumentationTestCase2`，这样我们就可以拥有一个完整的生命周期Activity运行。在测试开始时或`setup()`方法中需要调用`getActivity()`，以允许Activity启动并且Espresso在恢复状态下找到Activity：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once the setup is done, we can write a test using Espresso to click our button
    and check whether the image was shown (made visible) in the Activity:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们可以使用Espresso编写一个测试，点击按钮并检查图像是否在Activity中显示（变为可见）：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This example shows the use of Espresso to find our order button, click on the
    button, and check whether our ordered Espresso is shown to the user. Espresso
    has a fluid interface, meaning it follows a builder-style pattern, and most method
    calls can be chained. In the preceding example, I showed the fully qualified classes
    for clarity, but these can easily be changed to static imports so that the test
    is even more human readable:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了使用Espresso查找我们的订单按钮，点击按钮，并检查我们的订单Espresso是否对用户可见。Espresso有一个流畅的接口，意味着它遵循构建器样式模式，而且大多数方法调用可以被链式调用。在上面的示例中，我为了清晰展示了完全限定类，但这些可以很容易地更改为静态导入，使测试更具可读性：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This can now be read in a much more *sentence* style. This example shows the
    use of Espresso to find our order button `onView(withId(R.id.espresso_button_order))`.
    Click on `perform(click())`, then we find the cup image `onView(withId(R.id.espresso_imageview_cup))`,
    and check whether it is visible to the user `check(matches(isDisplayed()))`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以以更加*句子*的样式来阅读这个。这个示例展示了使用Espresso查找我们的订单按钮`onView(withId(R.id.espresso_button_order))`。点击`perform(click())`，然后我们找到咖啡杯图片`onView(withId(R.id.espresso_imageview_cup))`，并检查它是否对用户可见`check(matches(isDisplayed()))`。
- en: 'This shows that the only classes you need to think about are:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你需要考虑的类只有：
- en: '**Espresso**: This is the entry point. Always start with this to interact with
    a View.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Espresso**：这是入口点。始终从这一点开始与视图交互。'
- en: '**ViewMatchers**: This is used to locate a View within the current hierarchy.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewMatchers**：这用于在当前层次结构中定位视图。'
- en: '**ViewActions**: This is used to click, long click, and so on, on a located
    View.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewActions**：这用于对定位的视图执行点击、长按等操作。'
- en: '**ViewAssertions**: This is used to check the state of a View after an action
    has been performed.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewAssertions**：这用于在执行操作后检查视图的状态。'
- en: Espresso has a really powerful API, which allows you to test the positions of
    views next to each other, match data in a ListView, get data straight from a header
    or footer, and check the views in your ActionBar/ToolBar and many more assertions.
    Another feature is its capability to deal with threading; Espresso will wait for
    asynchronous tasks to finish before it asserts whether the UI has changed. An
    explanation of these features and much more is listed on the wiki page ([https://code.google.com/p/android-test-kit/w/list](https://code.google.com/p/android-test-kit/w/list)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso有一个非常强大的API，它允许你测试视图之间的位置，匹配ListView中的数据，直接从头部或脚部获取数据，并检查ActionBar/ToolBar中的视图以及许多其他断言。另一个特点是它能处理线程；Espresso将等待异步任务完成，然后断言UI是否已更改。这些特性以及更多的解释都列在wiki页面上（[https://code.google.com/p/android-test-kit/w/list](https://code.google.com/p/android-test-kit/w/list)）。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, several real-world examples of tests that cover a wide range
    of cases were presented. You can use them as a starting point while creating your
    own tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提出了涵盖广泛情况的几个现实世界中的测试示例。在创建你自己的测试时，你可以将它们作为起点。
- en: We covered a variety of testing recipes that you can extend for your own tests.
    We used mock contexts and showed how `RenamingDelegatingContext` can be used in
    various situations to change the data obtained by the tests. We also analyzed
    the injection of these mock contexts into test dependencies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了一系列的测试方法，你可以为你的测试进行扩展。我们使用了模拟上下文，并展示了`RenamingDelegatingContext`如何在各种情况下被用来改变测试获取的数据。我们还分析了这些模拟上下文注入测试依赖的过程。
- en: Then, we used `ActivityUnitTestCase` to test Activities in complete isolation.
    We tested Views in isolation using `AndroidTestCase`. We demonstrated the use
    of Mockito to mock objects combined with `ArgumentMatchers` to provide custom
    matchers on any object. Finally, we treated the analysis of potential memory leaks
    and took a peek into the power of testing UI with Espresso.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ActivityUnitTestCase`以完全隔离的方式测试活动。我们使用`AndroidTestCase`以隔离的方式测试视图。我们展示了结合使用Mockito和`ArgumentMatchers`来提供任何对象的定制匹配器的模拟对象。最后，我们探讨了潜在的内存泄漏分析，并窥视了使用Espresso测试UI的强大功能。
- en: The next chapter focuses on managing your test environment to enable you to
    run tests in a consistent, fast, and always deterministic way, which leads to
    automation and those mischievous monkeys!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节将专注于管理你的测试环境，以便你能够以一致、快速且始终确定性的方式运行测试，这导致了自动化和那些淘气的猴子！
