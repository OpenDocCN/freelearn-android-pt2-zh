- en: Chapter 6. Applications of Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 物理学的应用
- en: 'Physics-based games provide players with a unique type of experience not encountered
    in many other genres. This chapter covers the use of AndEngine''s **Box2D physics
    extension**. Our recipes include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物理的游戏为玩家提供了许多其他类型无法体验的独特体验。本章介绍了 AndEngine 的 **Box2D 物理扩展** 的使用。我们的食谱包括：
- en: Introduction to the Box2D physics extension
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Box2D 物理扩展简介
- en: Understanding different body types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同的物体类型
- en: Creating category-filtered bodies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分类过滤的物体
- en: Creating multiple-fixture bodies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多固定装置物体
- en: Creating unique bodies by specifying vertices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定顶点创建独特的物体
- en: Using forces, velocities, and torque
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用力、速度和扭矩
- en: Applying anti-gravity to a specific body
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对特定物体应用反重力
- en: Working with joints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与关节一起工作
- en: Creating a rag doll
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建布娃娃
- en: Creating a rope
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建绳子
- en: Working with collisions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与碰撞工作
- en: Using preSolve and postSolve
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 preSolve 和 postSolve
- en: Creating destructible objects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可破坏的物体
- en: Raycasting
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射线投射
- en: Introduction to the Box2D physics extension
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Box2D 物理扩展简介
- en: Physics-based games are one of the most popular types of games available for
    mobile devices. AndEngine allows the creation of physics-based games with the
    Box2D extension. With this extension, we can construct any type of physically
    realistic 2D environment from small, simple simulations to complex games. In this
    recipe, we will create an activity that demonstrates a simple setup for utilizing
    the Box2D physics engine extension. Furthermore, we will use this activity for
    the remaining recipes in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物理的游戏是移动设备上最受欢迎的游戏类型之一。AndEngine 允许使用 Box2D 扩展来创建基于物理的游戏。通过这个扩展，我们可以构建任何类型的物理现实的2D环境，从小的简单模拟到复杂游戏。在本食谱中，我们将创建一个演示简单设置的活动，以利用
    Box2D 物理引擎扩展。此外，我们将在本章的剩余食谱中使用此活动。
- en: Getting ready...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: First, create a new activity class named `PhysicsApplication` that extends `BaseGameActivity`
    and implements `IAccelerationListener` and `IOnSceneTouchListener`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `PhysicsApplication` 的新活动类，该类扩展了 `BaseGameActivity` 并实现了 `IAccelerationListener`
    和 `IOnSceneTouchListener`。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build our `PhysicsApplication` activity class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的 `PhysicsApplication` 活动类：
- en: 'Create the following variables in the class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中创建以下变量：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to set up the foundation of our activity. To start doing so, place
    these four, common overridden methods in the class to set up the engine, resources,
    and the main scene:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要建立活动的基础。为此，首先在类中放置这四个常见的重写方法，以设置引擎、资源和主场景：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Continue setting up the activity by adding the following overridden method,
    which will be used to populate our scene:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续设置活动，通过添加以下重写方法，该方法将用于填充我们的场景：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will fill the previous method with the following code to create our
    `PhysicsWorld` object and `Scene` object:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将用以下代码填充前一个方法，以创建我们的 `PhysicsWorld` 对象和 `Scene` 对象：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following overridden activities handle the scene touch events, the accelerometer
    input, and the two engine life cycle events—`onResumeGame` and `onPauseGame`.
    Place them at the end of the class to finish this recipe:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下重写活动处理场景触摸事件、加速度计输入以及两个引擎生命周期事件—`onResumeGame` 和 `onPauseGame`。将它们放在类的末尾以完成此食谱：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first thing that we do is define a camera width and height. Then, we define
    a `Scene` object and a `FixedStepPhysicsWorld` object in which the physics simulations
    will take place. The last set of variables defines what will act as the borders
    for our physics-based scenes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要定义一个相机的宽度和高度。然后，我们定义一个 `Scene` 对象和一个 `FixedStepPhysicsWorld` 对象，在其中进行物理模拟。最后一组变量定义了作为我们基于物理的场景边界的对象。
- en: In the second step, we override the `onCreateEngine()` method to return a `FixedStepEngine`
    object that will process `60` updates per second. The reason that we do this,
    while also using a `FixedStepPhysicsWorld` object, is to create a simulation that
    will be consistent across all devices, regardless of how efficiently a device
    can process the physics simulation. We then create the `EngineOptions` object
    with standard preferences, create the `onCreateResources()` method with only a
    simple callback, and set the main scene with a light-gray background.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们重写了`onCreateEngine()`方法，以返回一个每秒处理`60`次更新的`FixedStepEngine`对象。我们这样做的同时还使用了一个`FixedStepPhysicsWorld`对象，是为了创建一个在所有设备上都能保持一致的模拟，而不管设备处理物理模拟的效率如何。然后我们使用标准偏好创建`EngineOptions`对象，仅用一个简单的回调创建`onCreateResources()`方法，并将主场景设置为浅灰色背景。
- en: In the `onPopulateScene()` method, we create our `FixedStepPhysicsWorld` object
    that has double the gravity of the Earth, passed as an `(x,y)` coordinate `Vector2`
    object, and will update `60` times per second. The gravity can be set to other
    values to make our simulations more realistic or `0` to create a zero gravity
    simulation. A gravity setting of `0` is useful for space simulations or for games
    that use a top-down camera view instead of a profile. The `false` Boolean parameter
    sets the `AllowSleep` property of the `PhysicsWorld` object, which tells `PhysicsWorld`
    to not let any bodies deactivate themselves after coming to a stop. The last two
    parameters of the `FixedStepPhysicsWorld` object tell the physics engine how many
    times to calculate velocity and position movements. Higher iterations will create
    simulations that are more accurate, but can cause lag or jitteriness because of
    the extra load on the processor. After creating the `FixedStepPhysicsWorld` object,
    we register it with the main scene as an update handler. The physics world will
    not run a simulation without being registered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onPopulateScene()`方法中，我们创建了一个`FixedStepPhysicsWorld`对象，其重力是地球的两倍，通过`(x,y)`坐标的`Vector2`对象传递，并且每秒更新`60`次。重力可以被设置为其他值以使模拟更加真实，或者设置为`0`以创建零重力模拟。重力设置为`0`对于太空模拟或者使用俯视摄像机视角而不是侧视视角的游戏很有用。布尔参数`false`设置了`PhysicsWorld`对象的`AllowSleep`属性，告诉`PhysicsWorld`在停止后不要让任何实体自行停用。`FixedStepPhysicsWorld`对象的最后两个参数告诉物理引擎计算速度和位置移动的次数。更高的迭代次数将创建更准确的模拟，但也可能因为处理器负载增加而导致延迟或抖动。在创建`FixedStepPhysicsWorld`对象之后，我们将其注册为主场景的更新处理器。未经注册，物理世界不会运行模拟。
- en: The variable `WALL_FIXTURE_DEF` is a **fixture definition** . Fixture definitions
    hold the shape and material properties of entities that will be created within
    the physics world as fixtures. The shape of a fixture can be either circular or
    polygonal. The material of a fixture is defined by its density, elasticity, and
    friction, all of which are required when creating a fixture definition. Following
    the creation of the `WALL_FIXTURE_DEF` variable, we create four rectangles that
    will represent the locations of the wall bodies. A body in the Box2D physics world
    is made of fixtures. While only one fixture is necessary to create a body, multiple
    fixtures can create complex bodies with varying properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`WALL_FIXTURE_DEF`是一个**固定装置定义**。固定装置定义包含了将在物理世界中作为固定装置创建的实体的形状和材质属性。固定装置的形状可以是圆形或多边形的。固定装置的材质通过其密度、弹性和摩擦系数来定义，这些都是在创建固定装置定义时需要提供的。在创建`WALL_FIXTURE_DEF`变量之后，我们创建了四个矩形，它们将代表墙壁实体的位置。在Box2D物理世界中，一个实体是由固定装置组成的。虽然只需要一个固定装置来创建一个实体，但多个固定装置可以创建具有不同属性的复杂实体。
- en: Further along in the `onPopulateScene()` method, we create the box bodies that
    will act as our walls in the physics world. The rectangles that were previously
    created are passed to the bodies to define their position and shape. We then define
    the bodies as static, which means that they will not react to any forces in the
    physics simulation. Lastly, we pass the wall fixture definition to the bodies
    to complete their creation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onPopulateScene()`方法的后续部分，我们创建了将作为物理世界中的墙壁的盒子实体。之前创建的矩形被传递给这些实体以定义它们的位置和形状。然后我们将这些实体定义为静态的，这意味着它们在物理模拟中不会对任何力产生反应。最后，我们将墙壁固定装置定义传递给实体以完成它们的创建。
- en: After creating the bodies, we attach the rectangles to the main scene and set
    the scene's touch listener to our activity, which will be accessed by the `onSceneTouchEvent()`
    method. The final line of the `onPopulateScene()` method tells the engine that
    the scene is ready to be shown.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建刚体后，我们将矩形附加到主场景，并将场景的触摸监听器设置为我们活动，该活动将通过 `onSceneTouchEvent()` 方法访问。`onPopulateScene()`
    方法中的最后一行告诉引擎场景已准备好显示。
- en: The overridden `onSceneTouchEvent()` method will handle all touch interactions
    for our scene. The `onAccelerationAccuracyChanged()` and `onAccelerationChanged()`
    methods are inherited from the `IAccelerationListener` interface and allow us
    to change the gravity of our physics world when the device is tilted, rotated,
    or panned. We override `onResumeGame()` and `onPauseGame()` to keep the accelerometer
    from using unnecessary battery power when our game activity is not in the foreground.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的 `onSceneTouchEvent()` 方法将处理我们场景的所有触摸交互。`onAccelerationAccuracyChanged()`
    和 `onAccelerationChanged()` 方法继承自 `IAccelerationListener` 接口，允许我们在设备倾斜、旋转或平移时改变物理世界的重力。我们重写
    `onResumeGame()` 和 `onPauseGame()` 方法，以防止游戏活动不在前台时加速计使用不必要的电池电量。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the overridden `onAccelerationChanged()` method, we make two calls to the
    `Vector2Pool` class. The `Vector2Pool` class simply gives us a way of re-using
    our `Vector2` objects that might otherwise require garbage collection by the system.
    On newer devices, the Android Garbage Collector has been streamlined to reduce
    noticeable hiccups, but older devices might still experience lag depending on
    how much memory the variables being garbage collected occupy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写的 `onAccelerationChanged()` 方法中，我们两次调用了 `Vector2Pool` 类。`Vector2Pool` 类只是为我们提供了一种复用
    `Vector2` 对象的方法，否则这些对象可能需要系统进行垃圾回收。在较新的设备上，Android垃圾收集器已经得到优化，以减少明显的卡顿，但较旧的设备可能会根据被垃圾回收的变量占用的内存量仍然出现延迟。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visit [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html) to
    see the **Box2D User Manual**. The AndEngine Box2D extension is based on a Java
    port of the official Box2D C++ physics engine, so some variations in procedure
    exist, but the general concepts still apply.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html) 查看完整的**Box2D用户手册**。AndEngine
    Box2D 扩展基于官方 Box2D C++ 物理引擎的 Java 移植版本，因此在程序上存在一些差异，但总体概念仍然适用。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Understanding different body types* in this chapter.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解本章中的*不同身体类型*。
- en: Understanding different body types
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不同的身体类型
- en: The Box2D physics world gives us the means to create different body types that
    allow us to control the physics simulation. We can generate **dynamic bodies**
    that react to forces and other bodies, **static bodies** that do not move, and
    **kinematic bodies** that move but are not affected by forces or other bodies.
    Choosing which type each body will be is vital to producing an accurate physics
    simulation. In this recipe, we will see how three bodies react to each other during
    collision, depending on their body types.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D物理世界为我们提供了创建不同身体类型的方法，使我们能够控制物理模拟。我们可以生成**动态刚体**，它们会对力和其他刚体做出反应；**静态刚体**，它们不会移动；以及**运动刚体**，它们会移动但不受力或其他刚体的影响。选择每个刚体的类型对于产生准确的物理模拟至关重要。在本教程中，我们将看到三种不同身体类型的刚体在碰撞期间如何相互反应。
- en: Getting ready...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Follow the recipe in the *Introduction to the Box2D physics extension* section
    given at the beginning of this chapter to create a new activity that will facilitate
    the creation of our bodies with varying body types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分给出的 *Box2D物理扩展介绍* 部分的教程，创建一个新的活动，以便创建具有不同身体类型的刚体。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Complete the following steps to see how specifying a body type for bodies affects
    them:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤，了解为刚体指定不同的身体类型如何影响它们：
- en: 'First, insert the following fixture definition into the `onPopulateScene()`
    method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `onPopulateScene()` 方法中插入以下固定定义：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, place the following code that creates three rectangles and their corresponding
    bodies after the fixture definition from the previous step:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一步的固定定义之后放置以下代码，创建三个矩形及其对应的刚体：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, add the following code after the definitions from the previous step
    to set the linear and angular velocities for our kinematic body:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在上一步定义之后添加以下代码，为我们的运动刚体设置线性和角速度：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first step, we create the `BoxBodyFixtureDef` fixture definition that
    we will use when creating our bodies in the second step. For more information
    on fixture definitions, see the *Introduction to the Box2D physics extension*
    recipe in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了`BoxBodyFixtureDef`夹具定义，我们将在第二步创建刚体时使用它。有关夹具定义的更多信息，请参阅本章中的*Box2D物理扩展介绍*食谱。
- en: In step two, we first define the `staticRectangle` rectangle by calling the
    `Rectangle` constructor. We place `staticRectangle` at the position of `cameraWidth
    / 2f, 75f`, which is near the lower-center of the scene, and we set the rectangle
    to have a width of `400f` and a height of `40f`, which makes the rectangle into
    a long, flat bar. Then, we set the `staticRectangle` rectangle's color to be red
    by calling `staticRectangle.setColor(0.8f, 0f, 0f)`. Lastly, for the `staticRectangle`
    rectangle, we attach it to the scene by calling the `mScene.attachChild()` method
    with `staticRectangle` as the parameter. Next, we create a body in the physics
    world that matches our `staticRectangle`. To do this, we call the `PhysicsFactory.createBoxBody()`
    method with the parameters of `mPhysicsWorld`, which is our physics world, `staticRectangle`
    to tell the box to be created with the same position and size as the `staticRectangle`
    rectangle, `BodyType.StaticBody` to define the body as static, and our `BoxBodyFixtureDef`
    fixture definition.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们首先通过调用`Rectangle`构造函数来定义`staticRectangle`矩形。我们将`staticRectangle`放置在场景的下方中央位置，坐标为`cameraWidth
    / 2f, 75f`，并设置矩形的宽度为`400f`，高度为`40f`，使其成为一条长条形平板。然后，我们通过调用`staticRectangle.setColor(0.8f,
    0f, 0f)`将`staticRectangle`矩形的颜色设置为红色。最后，对于`staticRectangle`矩形，我们通过调用`mScene.attachChild()`方法，并将`staticRectangle`作为参数，将其附加到场景中。接下来，我们在物理世界中创建一个与`staticRectangle`相匹配的刚体。为此，我们调用`PhysicsFactory.createBoxBody()`方法，参数包括`mPhysicsWorld`（我们的物理世界）、`staticRectangle`（告诉箱子以与`staticRectangle`矩形相同的位置和大小创建）、`BodyType.StaticBody`（将刚体定义为静态）以及我们的`BoxBodyFixtureDef`夹具定义。
- en: Our next rectangle, `dynamicRectangle`, is created at the location of `400f`
    and `120f`, which is the middle of the scene slightly above the `staticRectangle`
    rectangle. Our `dynamicRectangle` rectangle's width and height are set to `40f`
    to make it a small square. Then, we set its color to green by calling `dynamicRectangle.setColor(0f,
    0.8f, 0f)` and attach it to our scene using `mScene.attachChild(dynamicRectangle)`.
    Next, we create the `dynamicBody` variable using the `PhysicsFactory.createBoxBody()`
    method in the same way that we did for our `staticRectangle` rectangle. Notice
    that we set the `dynamicBody` variable to have `BodyType` of `DynamicBody`. This
    sets the body to be dynamic. Now, we register `PhysicsConnector` with the physics
    world to link `dynamicRectangle` and `dynamicBody`. A `PhysicsConnecter` class
    links an entity within our scene to a body in the physics world, representing
    the body's realtime position and rotation in our scene.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个矩形`dynamicRectangle`在位置`400f`和`120f`处创建，位于场景的中央，略高于`staticRectangle`矩形。我们的`dynamicRectangle`矩形的宽度和高度设置为`40f`，使其成为一个小的正方形。然后，我们通过调用`dynamicRectangle.setColor(0f,
    0.8f, 0f)`将其颜色设置为绿色，并通过`mScene.attachChild(dynamicRectangle)`将其附加到我们的场景中。接下来，我们使用与`staticRectangle`矩形相同的方式，通过`PhysicsFactory.createBoxBody()`方法创建`dynamicBody`变量。注意，我们将`dynamicBody`变量的`BodyType`设置为`DynamicBody`。这会将刚体设置为动态的。现在，我们注册`PhysicsConnector`与物理世界，将`dynamicRectangle`和`dynamicBody`连接起来。`PhysicsConnecter`类将场景中的实体与物理世界中的刚体相连接，表示刚体在场景中的实时位置和旋转。
- en: Our last rectangle, `kinematicRectangle`, is created at the location of `600f`
    and `100f`, which places it on top of our `staticRectangle` rectangle toward the
    right-hand side of the scene. It is set to have a height and width of `40f`, which
    makes it a small square like our `dynamicRectangle` rectangle. We then set the
    `kinematicRectangle` rectangle's color to yellow and attach it to our scene. Similar
    to the previous two bodies that we created, we call the `PhysicsFactory.createBoxBody()`
    method to create our `kinematicBody` variable. Take note that we create our `kinematicBody`
    variable with a `BodyType` type of `KinematicBody`. This sets it to be kinematic
    and thus moved only by the setting of its velocities. Lastly, we register a `PhysicsConnector`
    class between our `kinematicRectangle` rectangle and our `kinematicBody` body
    type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的矩形`kinematicRectangle`在位置`600f`和`100f`处创建，这将其放置在我们场景右侧的`staticRectangle`矩形上方。它被设置为具有`40f`的高度和宽度，使其成为像我们的`dynamicRectangle`矩形那样的小正方形。然后我们将`kinematicRectangle`矩形的颜色设置为黄色并附加到我们的场景中。与我们之前创建的两个物体类似，我们调用`PhysicsFactory.createBoxBody()`方法来创建我们的`kinematicBody`变量。请注意，我们使用`BodyType`类型为`KinematicBody`的参数来创建`kinematicBody`变量。这将其设置为运动学物体，因此只能通过设置其速度来进行移动。最后，我们在`kinematicRectangle`矩形和`kinematicBody`物体类型之间注册一个`PhysicsConnector`类。
- en: In the last step, we set our `kinematicBody` body's linear velocity by calling
    the `setLinearVelocity()` method with a vector of `-2f` on the x axis, which makes
    it move to the left. Finally, we set our `kinematicBody` body's angular velocity
    to negative `pi` by calling `kinematicBody.setAngularVelocity((float) (-Math.PI))`.
    For more information on setting a body's velocities, see the *Using forces, velocities,
    and torque* recipe in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们通过调用`setLinearVelocity()`方法并设置x轴上的`-2f`向量来设置`kinematicBody`物体的线性速度，使其向左移动。最后，我们通过调用`kinematicBody.setAngularVelocity((float)
    (-Math.PI))`将`kinematicBody`物体的角速度设置为负的π。有关设置物体速度的更多信息，请参见本章节中的*使用力、速度和扭矩*食谱。
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Static bodies cannot move from applied or set forces, but can be relocated using
    the `setTransform()` method. However, we should avoid using the `setTransform()`
    method while a simulation is running, because it makes the simulation unstable
    and can cause some strange behaviors. Instead, if we want to change the position
    of a static body, we can do so whenever creating the simulation or, if we need
    to change the position at runtime, simply check that the new position will not
    cause the static body to overlap existing dynamic bodies or kinematic bodies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 静态物体不能通过施加或设定的力来移动，但可以使用`setTransform()`方法进行重新定位。然而，在模拟运行时，我们应避免使用`setTransform()`方法，因为它会使模拟变得不稳定，并可能导致一些奇怪的行为。相反，如果我们想要改变静态物体的位置，可以在创建模拟时进行，如果需要在运行时改变位置，只需检查新的位置是否会导致静态物体与现有的动态物体或运动学物体重叠。
- en: Kinematic bodies cannot have forces applied, but we can set their velocities
    via the `setLinearVelocity()` and `setAngularVelocity()` methods.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运动学物体不能施加力，但我们可以通过`setLinearVelocity()`和`setAngularVelocity()`方法设置它们的速度。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中的*Box2D物理扩展介绍*。
- en: '*Using forces, velocities, and torque* in this chapter.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中的*使用力、速度和扭矩*。
- en: Creating category-filtered bodies
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分类筛选的物体
- en: Depending on the type of physics simulation that we want to achieve, controlling
    which bodies are capable of colliding can be very beneficial. In Box2D, we can
    assign a category, and category-filter to fixtures to control which fixtures can
    interact. This recipe will cover the defining of two category-filtered fixtures
    that will be applied to bodies created by touching the scene to demonstrate category-filtering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们想要实现的物理模拟类型，控制哪些物体能够发生碰撞可能非常有用。在Box2D中，我们可以为夹具分配一个类别和类别筛选器，以控制哪些夹具可以互动。本食谱将介绍两个定义了类别筛选的夹具，这些夹具将通过触摸场景创建的物体来演示类别筛选。
- en: Getting ready...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section given at the beginning of the chapter. This activity
    will facilitate the creation of the category-filtered bodies used in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分给出的*Box2D物理扩展介绍*部分的步骤创建一个活动。这个活动将促进本节中使用的分类筛选物体的创建。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build our category-filtering demonstration activity:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建我们的分类筛选演示活动：
- en: 'Define the following class-level variables within the activity:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动中定义以下类级别变量：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, create this method within the class that generates new category-filtered
    bodies at a given location:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在类中创建此方法，以在给定位置生成新的类别筛选刚体：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, fill the body of the `onSceneTouchEvent()` method with the following
    code that calls the `addBody()` method by passing the touched location:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用以下代码填充`onSceneTouchEvent()`方法的主体，该代码通过传递触摸位置来调用`addBody()`方法：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: In the first step, we create an integer, `mBodyCount`, which counts how many
    bodies we have added to the physics world. The `mBodyCount` integer is used in
    the second step to determine which color, and thus which category, should be assigned
    to the new body.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了一个整数`mBodyCount`，用于计算我们向物理世界添加了多少个刚体。`mBodyCount`整数在第二步中用于确定应将哪种颜色（从而确定哪个类别）分配给新的刚体。
- en: We also create the `CATEGORYBIT_DEFAULT`, `CATEGORYBIT_RED_BOX`, and `CATEGORYBIT_GREEN_BOX`
    category bits by defining them with unique power-of-two short integers and the
    `MASKBITS_RED_BOX` and `MASKBITS_GREEN_BOX` mask bits by adding their associated
    category bits together. The category bits are used to assign a category to a fixture,
    while the mask bits combine the different category bits to determine which categories
    a fixture can collide with. We then pass the category bits and mask bits to the
    fixture definitions to create fixtures that have category collision rules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义具有唯一幂次方的短整数来创建`CATEGORYBIT_DEFAULT`、`CATEGORYBIT_RED_BOX`和`CATEGORYBIT_GREEN_BOX`类别位，以及通过将相关的类别位相加来定义`MASKBITS_RED_BOX`和`MASKBITS_GREEN_BOX`掩码位。类别位用于为固定装置分配一个类别，而掩码位结合不同的类别位以确定固定装置可以与哪些类别发生碰撞。然后，我们将类别位和掩码位传递给固定装置定义以创建具有类别碰撞规则的固定装置。
- en: The second step is a simple method that creates a rectangle and its corresponding
    body. The method takes the `X` and `Y` location parameters that we want to use
    to create a new body and passes them to a `Rectangle` object's constructor, to
    which we also pass a height and width of `50f` and the activity's `VertexBufferObjectManager`.
    Then, we set the rectangle to be 50 percent transparent using the `rectangle.setAlpha()`
    method. After that, we define a body and modulate the `mBodyCount` variable by
    `2` to determine the color and fixture of every other created body. After determining
    the color and fixture, we assign them by setting the rectangle's color and creating
    a body by passing our `mPhysicsWorld` physics world, the rectangle, a dynamic
    body type, and the previously-determined fixture to use. Finally, we attach the
    rectangle to our scene and register a `PhysicsConnector` class to connect the
    rectangle to our body.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是一个简单的方法，用于创建一个矩形及其对应的刚体。该方法采用我们想要用来创建新刚体的`X`和`Y`位置参数，并将它们传递给`Rectangle`对象的构造函数，同时我们还传递了一个高度和宽度为`50f`以及活动的`VertexBufferObjectManager`。然后，我们使用`rectangle.setAlpha()`方法将矩形设置为50%透明。之后，我们定义一个刚体，并通过将`mBodyCount`变量与`2`取模来确定每个创建的刚体的颜色和装置。确定颜色和装置后，我们通过设置矩形的颜色和创建一个刚体来分配它们，传递我们的`mPhysicsWorld`物理世界、矩形、动态刚体类型以及先前确定的装置。最后，我们将矩形附加到我们的场景中，并注册一个`PhysicsConnector`类以将矩形连接到我们的刚体。
- en: The third step calls the `addBody()` method from step two only if the physics
    world has been created and only if the scene's `TouchEvent` is `ActionDown`. The
    parameters that are passed, `pSceneTouchEvent.getX()` and `pSceneTouchEvent.getY()`,
    represent the location on the scene that received a touch input, which is also
    the location where we want to create a new category-filtered body.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步仅当已创建物理世界且场景的`TouchEvent`为`ActionDown`时，才从第二步调用`addBody()`方法。传递的参数`pSceneTouchEvent.getX()`和`pSceneTouchEvent.getY()`表示在场景上接收触摸输入的位置，这也是我们想要创建新的类别筛选刚体的位置。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The default category of all fixtures has a value of one. When creating mask
    bits for specific fixtures, remember that any combination that includes the default
    category will cause the fixture to collide with all other fixtures that are not
    masked to avoid collision with the fixture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有固定装置的默认类别值为一。在为特定固定装置创建掩码位时，请记住，包含默认类别的任何组合都会导致该固定装置与所有未设置为避免与之碰撞的其他固定装置发生碰撞。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章介绍*Box2D 物理扩展*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中*了解不同的刚体类型*。
- en: Creating multiple-fixture bodies
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有多个装置的刚体。
- en: We sometimes need a body that has varying physics attributes on certain parts
    of it. For instance, a car with a bumper should react differently if it hits a
    wall to a car without a bumper. The creation of such a multifixture body in Box2D
    is fairly simple and straightforward. In this recipe, we will see how to create
    a multifixture body by creating two fixtures and adding them to an empty body.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要一个具有不同物理属性的身体部位。例如，带保险杠的车如果撞墙应该与没有保险杠的车有不同的反应。在Box2D中创建这样的多固定装置身体是相当简单直接的。在本节中，我们将了解如何通过创建两个固定装置并将它们添加到空身体中来创建多固定装置身体。
- en: Getting ready...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    the creation of our multifixture body.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分*Box2D物理扩展介绍*一节中的步骤创建一个新的活动，以便促进我们多固定装置身体的创建。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to see how we can create multifixture bodies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，了解如何创建多固定装置身体：
- en: 'Place the following code in the `onPopulateScene()` method to create two rectangles
    that have a modified `AnchorCenter` value which allows for precise placement when
    linked to a body:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onPopulateScene()`方法中放置以下代码，以创建两个具有修改过的`AnchorCenter`值的矩形，这允许在连接到身体时进行精确放置：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code creates a `Body` object and two fixtures, one that is perfectly
    elastic and another that is perfectly inelastic. Add it after the creation of
    the rectangles in the preceding step:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码创建了一个`Body`对象和两个固定装置，一个完全弹性，另一个完全非弹性。在前面步骤中创建矩形后添加它：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we need to set the location of our multifixture body now that it has
    been created. Place the following call to `setTransform()` after the creation
    of the bodies in the previous step:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要设置多固定装置身体的位置，既然它已经被创建了。在前面步骤中创建身体后，放置以下对`setTransform()`的调用：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first step that we take is to define a rectangle that will represent a non-bouncy
    fixture by using the `Rectangle` constructor and passing `0f` on the x axis and
    `0f` on the y axis, representing the origin of the world. We then pass a height
    and width of `100f`, which makes the rectangle a large square, and the activity's
    `VertexBufferObjectManager`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`Rectangle`构造函数定义一个矩形，它将代表一个非弹性的固定装置，在x轴和y轴上传递`0f`，表示世界原点。然后我们传递一个高度和宽度为`100f`，这使得矩形成为一个大正方形，以及活动的`VertexBufferObjectManager`。
- en: Then, we set the color of the non-bouncy rectangle to black, `0f, 0f, 0f`, and
    set its anchor-center using the `nonbouncyBoxRect.setAnchorCenter()` method to
    represent the location on the body, created in the second step, at which the non-bouncy
    rectangle will be attached. The anchor-center location of `(((nonbouncyBoxRect.getWidth()
    / 2) - nonbouncyBoxRect.getX()) / nonbouncyBoxRect.getWidth(), ((nonbouncyBoxRect.getHeight()
    / 2) – nonbouncyBoxRect.getY()) / nonbouncyBoxRect.getHeight()` converts the rectangle's
    location and size to the location that the rectangle rests on the origin. In the
    case of our non-bouncy rectangle, the anchor-center remains at the default `0.5f,
    0.5f`, but the formula is necessary for any fixture that will be created from
    a rectangle that is not centered on the origin. Next, we attach our non-bouncy
    rectangle to the scene. Then, we create a rectangle that will represent a bouncy
    fixture using the same method that we used to create the non-bouncy rectangle,
    but we place the rectangle at `-55f` on the y axis to put it directly below the
    non-bouncy rectangle. We also set the width of the rectangle to `90f`, making
    it slightly smaller than the previous rectangle, and the height to `10f` to make
    it a slim bar that will act as a bouncy portion directly below the non-bouncy
    rectangle. After setting the bouncy rectangle's anchor-center using the same formula
    used for the non-bouncy rectangle, we attach it to the scene. Take note that we
    have modified the `AnchorCenter` values of each of the rectangles, so that the
    `PhysicsConnectors` class that we register in the second step can place the rectangles
    in the proper location when we run the simulation. Also, note that we create our
    rectangles and multifixture body at the world's origin to make calculations simple
    and fast. After our body has been created, we move it to the position that it
    should be in for the simulation, as can be seen in the third step, when we call
    the `multiFixtureBody.setTransform()` method with the parameters `400f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    and `240f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`, which represent the
    center of the screen in the physics world, and `0f`, which represents the zero-rotation
    that the body will have.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们将非弹跳矩形的颜色设置为黑色 `0f, 0f, 0f`，并使用 `nonbouncyBoxRect.setAnchorCenter()` 方法设置其锚点中心，以表示在第二步创建的物体上，非弹跳矩形将被附着的地点的位置。锚点中心的位置
    `(((nonbouncyBoxRect.getWidth() / 2) - nonbouncyBoxRect.getX()) / nonbouncyBoxRect.getWidth(),
    ((nonbouncyBoxRect.getHeight() / 2) – nonbouncyBoxRect.getY()) / nonbouncyBoxRect.getHeight()`
    将矩形的定位和大小转换为相对于原点的位置。在我们的非弹跳矩形的情况下，锚点中心保持在默认的 `0.5f, 0.5f`，但对于任何从非原点中心矩形创建的固定装置，这个公式是必要的。接下来，我们将非弹跳矩形附加到场景中。然后，我们使用与非弹跳矩形相同的方法创建一个将表示弹跳组件的矩形，但是我们将矩形在y轴上放置在
    `-55f` 的位置，使其直接位于非弹跳矩形的下方。我们还将矩形的宽度设置为 `90f`，使其比之前的矩形略小，并将高度设置为 `10f`，使其成为一个细长的条，作为非弹跳矩形下方的弹跳部分。使用与非弹跳矩形相同的公式设置弹跳矩形的锚点中心后，我们将其附加到场景中。请注意，我们已经修改了每个矩形的
    `AnchorCenter` 值，这样在第二步中注册的 `PhysicsConnectors` 类可以在运行模拟时将矩形放置在正确的位置。还要注意，我们在世界原点创建我们的矩形和多固定装置物体，以简化计算并提高速度。在物体创建之后，我们将其移动到模拟中应有的位置，如第三步所示，当我们调用
    `multiFixtureBody.setTransform()` 方法时，使用参数 `400f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    和 `240f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`，这代表了物理世界中的屏幕中心，以及 `0f`，这表示物体将具有的零旋转。
- en: In the second step, we create an empty body, `multiFixtureBody`, by calling
    `mPhysicsWorld.createBody(new BodyDef())` and set it to be dynamic by calling
    its `setType()` method with the parameter `BodyType.DynamicBody`. Then, we define
    a fixture definition, `nonbouncyBoxFixtureDef`, for the non-bouncy fixture.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们通过调用 `mPhysicsWorld.createBody(new BodyDef())` 创建一个空的物体 `multiFixtureBody`，并通过调用其
    `setType()` 方法并传入参数 `BodyType.DynamicBody` 来设置它为动态的。然后，我们定义一个用于非弹跳组件的固定装置定义 `nonbouncyBoxFixtureDef`。
- en: Next, we create a `PolygonShape` shape named `nonbouncyBoxShape` and set it
    as a box that mimics our `nonbouncyBoxRect` by calling `nonbouncyBoxShape` shape's
    `setAsBox()` method with the first two parameters as `nonbouncyBoxRect.getWidth()
    / 2f` and `nonbouncyBoxRect.getHeight() / 2f` to set the `nonbouncyBoxShape` object
    to have the same width and height as our `nonbouncyBoxRect` rectangle. Both of
    the parameters are divided by `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    to scale the values to the physics world. Furthermore, the `setAsBox()` method's
    first two parameters are half sizes. This means that a normal width of `10f` will
    be passed to the `setAsBox()` method as `5f`. The next parameter of the `setAsBox()`
    method is a `Vector2` parameter that will identify the location of our `nonbouncyBoxShape`
    shape in the physics world. We set it to the location of our `nonbouncyBoxRect`
    rectangle, converting the location to physics world coordinates by scaling with
    the `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT` variable. The last parameter
    of the `setAsBox()` method is the rotation that `nonbouncyBoxShape` should have.
    Because our `nonbouncyBoxRect` rectangle is not rotated, we use `0f`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `nonbouncyBoxShape` 的 `PolygonShape` 形状，并通过调用 `nonbouncyBoxShape`
    形状的 `setAsBox()` 方法，将第一个两个参数设置为 `nonbouncyBoxRect.getWidth() / 2f` 和 `nonbouncyBoxRect.getHeight()
    / 2f`，使其模仿我们的 `nonbouncyBoxRect` 矩形，从而将其设置为与 `nonbouncyBoxRect` 矩形具有相同的宽度和高度。这两个参数都除以
    `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT` 以将值缩放到物理世界。此外，`setAsBox()` 方法的头两个参数是半尺寸。这意味着正常的宽度
    `10f` 将作为 `5f` 传递给 `setAsBox()` 方法。`setAsBox()` 方法的下一个参数是一个 `Vector2` 参数，用于标识我们的
    `nonbouncyBoxShape` 形状在物理世界中的位置。我们将其设置为我们的 `nonbouncyBoxRect` 矩形的当前位置，并通过使用 `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    变量进行缩放，将位置转换为物理世界坐标。`setAsBox()` 方法的最后一个参数是 `nonbouncyBoxShape` 应具有的旋转。因为我们的 `nonbouncyBoxRect`
    矩形没有旋转，所以我们使用 `0f`。
- en: Then, we set the `shape` property of our `nonbouncyBoxFixtureDef` fixture definition
    to `nonbouncyBoxShape`, which applies the shape to our fixture definition. Next,
    we attach the fixture to our multifixture body by calling the body's `createFixture()`
    method with the `nonbouncyBoxFixtureDef` fixture definition as the parameter.
    Then, we register a `PhysicsConnector` class to link the `nonbouncyBoxRect` rectangle
    in our scene to the `multiFixtureBody` body in the physics world. Finally, we
    follow the same procedures that we used when creating the non-bouncy fixture to
    create our bouncy fixture. The result should be a black square with one bouncy,
    green side.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `nonbouncyBoxFixtureDef` 夹具定义的 `shape` 属性设置为 `nonbouncyBoxShape`，将形状应用到我们的夹具定义中。接下来，通过调用物体的
    `createFixture()` 方法，并将 `nonbouncyBoxFixtureDef` 夹具定义作为参数，将夹具附加到我们的 multifixture
    物体上。然后，我们注册一个 `PhysicsConnector` 类，将场景中的 `nonbouncyBoxRect` 矩形与物理世界中的 `multiFixtureBody`
    物体连接起来。最后，我们按照创建非弹跳夹具时使用的相同程序来创建我们的弹跳夹具。结果应该是一个带有绿色弹跳边的黑色正方形。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By setting the `isSensor` property of a fixture definition to `true`, a fixture
    can be created as a sensor, which allows it to contact other fixtures without
    a physical interaction occurring. For more information on sensors, see the **Fixtures**
    section of the Box2D manual at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将夹具定义中的 `isSensor` 属性设置为 `true`，可以创建一个传感器夹具，使其能够与其他夹具接触而不发生物理交互。关于传感器的更多信息，请参见
    Box2D 手册中的**夹具**部分，链接为 [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章介绍 Box2D 物理扩展*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中*了解不同的物体类型*。
- en: Creating unique bodies by specifying vertices
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过指定顶点创建独特的物体。
- en: Not everything in our physics simulations must be made of rectangles or circles.
    We can also create polygonal bodies by creating a list of the polygonal points.
    This approach is useful for creating certain types of terrain, vehicles, and characters.
    In this recipe, we will demonstrate how to create a unique body from a list of
    vertices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们物理模拟中的所有东西不必都是由矩形或圆形制成的。我们还可以通过创建多边形点的列表来创建多边形物体。这种方法对于创建特定类型的地形、车辆和角色很有用。在本教程中，我们将演示如何从顶点列表中创建一个独特的物体。
- en: Getting ready...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section given at the beginning of the chapter. This activity
    will easily allow the creation of a uniquely constructed body with vertices.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分给出的*Box2D 物理扩展介绍*一节中的步骤创建一个活动。这个活动将轻松允许创建一个具有顶点的独特构造的物体。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Complete the following steps to define and create our unique, polygonal body:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤以定义和创建我们独特的多边形主体：
- en: 'Our unique body''s vertices will be defined by a list of `Vector2` objects.
    Add the following list to the `onPopulateScene()` method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们独特主体的顶点将由`Vector2`对象列表定义。将以下列表添加到`onPopulateScene()`方法中：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To use the preceding list of vertices, we must run them through the `EarClippingTriangulator`
    class to turn the vertices list into a list of triangles that the physics engine
    will use to create multiple fixtures that are joined into a single body. Place
    this code after the creation of the initial `ector2` list:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用前面的顶点列表，我们必须通过`EarClippingTriangulator`类处理它们，将顶点列表转换为物理引擎将用于创建多个固定装置并连接成一个单一主体的三角形列表。在初始`Vector2`列表创建后放置以下代码：
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a mesh that will represent our unique body, as well as adapt the
    triangulated vertices for use in the physics world, add the following code snippet:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建表示我们独特主体的网格，以及调整三角化顶点以在物理世界中使用，请添加以下代码片段：
- en: '[PRE16]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have adapted the vertices to be used in the physics world, we can
    create the body:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经调整了顶点以在物理世界中使用，我们可以创建主体：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we want the unique body to have something to collide with. Add the
    following body definitions to create two static bodies that will act as small
    pegs in our hysics world:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望独特主体有与之碰撞的物体。添加以下主体定义以创建两个静态主体，它们将在我们的物理世界中充当小钉子：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The list of vertices that we first create represents the shape that our unique
    body will be, relative to the center of the body. In the second step, we create
    another list of vertices using the `EarClippingTriangulator` class. This list
    that is returned from the `computeTriangles()` method of the `EarClippingTriangulator`
    class contains all of the points of the triangles that make up our unique body.
    The following figure shows what our polygonal body looks like before and after
    running its vertices through the `EarClippingTriangulator` class. Notice that
    our body will be made from several triangular shapes that represent the original
    shape:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建的顶点列表表示我们独特主体的形状，相对于主体的中心。在第二步中，我们使用`EarClippingTriangulator`类创建另一个顶点列表。从`EarClippingTriangulator`类的`computeTriangles()`方法返回的列表包含了构成我们独特主体的所有三角形点。以下图展示了在通过`EarClippingTriangulator`类处理顶点之前和之后我们的多边形主体的样子。请注意，我们的主体将由表示原始形状的几个三角形形状组成：
- en: '![How it works...](img/8987OS_06_01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_06_01.jpg)'
- en: In step three, after adding each vertex to the `MeshTriangles` array for use
    in creating a mesh to represent our body, we multiply each vertex by `1/PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`,
    which is the same as dividing the vertex's coordinates by the default pixel-to-meter
    ratio. This division process is a common practice used to convert the scene coordinates
    to the physics world coordinates. The physics world measures distance in meters,
    so a conversion from pixels is necessary. Any consistent, reasonable value can
    be used as the conversion constant, but the default pixel-to-meter-ratio is 32
    pixels per meter and has been proven to work in almost every simulation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，将每个顶点添加到`MeshTriangles`数组以用于创建表示我们主体的网格后，我们每个顶点都乘以`1/PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`，这相当于将顶点的坐标除以默认的像素到米比率。这种除法过程是用于将场景坐标转换为物理世界坐标的常见做法。物理世界以米为单位测量距离，因此需要从像素进行转换。任何一致且合理的值都可以用作转换常数，但默认的像素到米比率是每米32像素，几乎在每一个模拟中都已被证明是有效的。
- en: Step four creates the unique body by calling `PhysicsFactory.createTrianglulatedBody`.
    It is important to note that while it is possible to create polygonal bodies from
    a non-triangulated list of vertices, the only benefit to doing so would be if
    we were using a list with less than seven vertexes. Even with such a small list,
    triangulating the body does not have a noticeable negative impact on the simulation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步通过调用`PhysicsFactory.createTrianglulatedBody`创建独特的主体。需要注意的是，尽管可以从非三角化的顶点列表创建多边形主体，但只有当我们的列表顶点少于七个时，这样做才会有所好处。即使列表很小，三角化主体对模拟的影响也没有明显的负面影响。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Several physics-body editors are available to simplify body creation. The following
    are all usable with AndEngine:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个物理主体编辑器可以简化主体的创建。以下都是与AndEngine兼容的：
- en: '**Physics Bo****dy Editor** (free): [http://code.google.com/p/box2d-editor](http://code.google.com/p/box2d-editor)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Physics Body Editor**（免费）：[http://code.google.com/p/box2d-editor](http://code.google.com/p/box2d-editor)'
- en: '**Phys****icsEditor** (paid): [http://www.codeandweb.com/physicseditor](http://www.codeandweb.com/physicseditor)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PhysicsEditor**（付费）：[http://www.codeandweb.com/physicseditor](http://www.codeandweb.com/physicseditor)'
- en: '**Inkscape** (free, plugins required): [http://inkscape.org/](http://inkscape.org/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Inkscape**（免费，需要插件）：[http://inkscape.org/](http://inkscape.org/)'
- en: See also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章介绍*Box2D物理扩展*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章了解*不同的物体类型*。
- en: Using forces, velocities, and torque
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用力、速度和扭矩
- en: No matter what kind of simulation we are creating, we will more than likely
    want to control at least one body. To move bodies in Box2D, we can apply linear
    or angular forces, set linear or angular velocities, and apply an angular force
    in the form of torque. In this recipe, we will see how we can apply these forces
    and velocities on multiple bodies.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们创建何种类型的模拟，我们很可能会至少想要控制一个物体。在Box2D中移动物体，我们可以施加线性或角力，设置线性或角速度，并以扭矩的形式施加角力。在本食谱中，我们将看到如何对多个物体施加这些力和速度。
- en: Getting ready...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    the creation of bodies that will react to forces, velocities, and torque. Then,
    update the activity to include the additional code from the `ForcesVelocitiesTorqueActivity`
    class found in the code bundle.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分*Box2D物理扩展*一节的步骤创建一个新活动，以便创建能够对力、速度和扭矩做出反应的物体。然后，更新活动，包括来自代码捆绑包中`ForcesVelocitiesTorqueActivity`类的附加代码。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Refer to the supplemental `ForcesVelocitiesTorqueActivity` class for the complete
    example of this recipe. We will cover only the basics of the recipe in this section:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 参考补充的`ForcesVelocitiesTorqueActivity`类，以获取本食谱的完整示例。我们将在本节中仅介绍食谱的基础知识：
- en: 'We will first work with the methods that handle the linear motion of our bodies.
    Place the following code snippet in the overridden `onAreaTouched()` method of
    the `LinearForceRect` rectangle:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先会使用处理物体线性运动的方法。在`LinearForceRect`矩形重写的`onAreaTouched()`方法中放置以下代码片段：
- en: '[PRE19]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, insert this code in the `onAreaTouched()` method of the `LinearImpulseRect`
    rectangle:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将此代码插入到`LinearImpulseRect`矩形的`onAreaTouched()`方法中：
- en: '[PRE20]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, add this code to the `onAreaTouched()` method of the `LinearVelocityRect`
    rectangle:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此代码添加到`LinearVelocityRect`矩形的`onAreaTouched()`方法中：
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will work with the `Body` methods that affect the angular motion of
    our bodies. Place this code in the `onAreaTouched()` method of the `AngularTorqueRect`
    rectangle:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用影响物体角运动的`Body`方法。将此代码放在`AngularTorqueRect`矩形的`onAreaTouched()`方法中：
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Insert the following code in the `onAreaTouched()` method of the `AngularImpulseRect`
    rectangle:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AngularImpulseRect`矩形的`onAreaTouched()`方法中插入以下代码：
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, add this code to the `onAreaTouched()` method of the `AngularVelocityRect`
    rectangle:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将此代码添加到`AngularVelocityRect`矩形的`onAreaTouched()`方法中：
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step one, we apply a linear force on `LinearForceBody` by calling its `applyForce()`
    method with the force parameters of `0f` on the x axis and `2000f` on the y axis
    to apply a strong, positive vertical force and the force location in world coordinates
    of `LinearForceBody.getWorldCenter().x` and `LinearForceBody.getWorldCenter().y`
    to apply the force at the center of the `LinearForceBody` body.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们通过调用`LinearForceBody`的`applyForce()`方法，并在x轴上使用`0f`，在y轴上使用`2000f`的力参数，在其世界坐标中心`LinearForceBody.getWorldCenter().x`和`LinearForceBody.getWorldCenter().y`处施加一个强大的、正的垂直力。
- en: Step two applies a linear impulse on the `LinearImpulseBody` body via its `applyLinearImpulse()`
    method. The `applyLinearImpulse()` method's first two parameters are the impulse
    amount with respect to the world axis. We use the values of `0f` and `200f` to
    apply the moderate impulse pointing straight up. The remaining two parameters
    of the `applyLinearImpulse()` method are the x and y location that the impulse
    will be applied to the body in world coordinates. We pass `LinearImpulseBody.getWorldCenter().x`
    and `LinearImpulseBody.getWorldCenter().y` to apply the impulse at the center
    of the `LinearImpulseBody` body.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步通过`LinearImpulseBody.applyLinearImpulse()`方法在`LinearImpulseBody`物体上应用一个线性冲量。`applyLinearImpulse()`方法的前两个参数是相对于世界坐标轴的冲量量。我们使用值`0f`和`200f`来应用一个指向正上方的适度冲量。`applyLinearImpulse()`方法的剩余两个参数是冲量在世界坐标中应用到的物体的x和y位置。我们传递`LinearImpulseBody.getWorldCenter().x`和`LinearImpulseBody.getWorldCenter().y`，以在`LinearImpulseBody`物体的中心应用冲量。
- en: In step three, we set the linear velocity of `LinearVelocityBody` by calling
    its `setLinearVelocity()` method with the parameters `0f` and `20f`. The parameter
    of `0f` signifies that the body will not be moving on the x axis, and the parameter
    of `20f` sets the y axis motion immediately to be 20 meters per second. When using
    the `setLinearVelocity()` method, the velocity is automatically set at the body's
    center of mass.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们通过调用`LinearVelocityBody.setLinearVelocity()`方法并传入参数`0f`和`20f`来设置`LinearVelocityBody`的线性速度。参数`0f`表示物体在x轴上不会移动，而参数`20f`则立即将y轴上的运动速度设置为每秒20米。使用`setLinearVelocity()`方法时，速度会自动设置在物体的质心上。
- en: Step four applies a torque to `AngularTorqueBody`. We call the `AngularTorqueBody.applyTorque()`
    method with a value of `2000f` to apply a very strong torque to the `AngularTorqueBody`
    body at the body's center of mass.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步给`AngularTorqueBody`应用一个扭矩。我们调用`AngularTorqueBody.applyTorque()`方法并传入值`2000f`，以在物体的质心上给`AngularTorqueBody`施加一个非常大的扭矩。
- en: In the fifth step, we apply an angular impulse to the `AngularImpulseBody` body
    by calling the `AngularImpulseBody.applyAngularImpulse()` method with a value
    of `20f`. This small, angular impulse will be applied to the `AngularImpulseBody`
    body's center of mass.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们通过调用`AngularImpulseBody.applyAngularImpulse()`方法并传入值`20f`，给`AngularImpulseBody`物体应用一个角冲量。这个小的角冲量将被应用到`AngularImpulseBody`物体的质心上。
- en: For the final step, we set the angular velocity of the `AngularVelocityBody`
    body. We call the `AngularVelocityBody.setAngularVelocity()` method with the value
    of `10f` to make the body immediately rotate at 10 radians per second.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们设置`AngularVelocityBody`物体的角速度。我们调用`AngularVelocityBody.setAngularVelocity()`方法并传入值`10f`，使物体立即以每秒10弧度的速度旋转。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '*Impulses* differ from *forces* in that they function independently of the
    timestep. An impulse actually equals *force* multiplied by *time*. Likewise, *forces*
    equal the *impulse* divided by *time*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*冲量*与*力*的不同之处在于，它们独立于时间步长起作用。实际上，冲量等于*力*乘以*时间*。同样，*力*等于*冲量*除以*时间*。'
- en: Setting the velocity of bodies and applying an impulse are similar, but there
    is an important distinction to make—applying impulses directly adds to or subtracts
    from the velocity, while setting a velocity does not incrementally increase or
    decrease he velocity.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设置物体的速度和应用冲量相似，但有一个重要的区别——直接应用冲量会增加或减少速度，而设置速度并不会逐渐增加或减少速度。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的《*Box2D物理扩展简介*》。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中了解不同的物体类型。
- en: Applying anti-gravity to a specific body
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对特定物体应用反重力
- en: In the previous recipe, we looked at how forces affect bodies. Using a constant
    force that opposes gravity, we can release a body from the gravity of the physics
    world. If the force that opposes gravity is great enough, the body will even float
    away! In this recipe, we will create a body that counteracts the force of gravity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们了解了力如何影响物体。使用与重力相对抗的恒定力，我们可以使物体从物理世界的重力中释放出来。如果与重力相对抗的力足够大，物体甚至会飘走！在这个食谱中，我们将创建一个与重力相抵消的物体。
- en: Getting ready...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section at the beginning of the chapter. This activity will
    facilitate the creation of a body that has a constant force applied that opposes
    gravity.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分《*Box2D物理扩展简介*》一节中的步骤创建一个活动。这个活动将有助于创建一个受到恒定力作用的物体，该力与重力相对抗。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this recipe, follow these steps to create a body that opposes gravity:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此教程，按照以下步骤创建一个反对重力的刚体：
- en: 'Place the following definitions in the activity:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动中放置以下定义：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, create a rectangle and body that will demonstrate the normal effects
    of gravity on a body. Place the following code snippet in the `onPopulateScene()`
    method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个矩形和刚体，以演示重力对刚体的正常影响。在`onPopulateScene()`方法中放置以下代码片段：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, create a rectangle and body that show how a body can ignore gravity
    by applying an anti-gravity force during every update:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个矩形和刚体，以展示如何通过在每次更新时施加反重力力使刚体忽略重力：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step that we take is to define a body affected by gravity, a body
    that opposes gravity, and a fixture definition used when creating the bodies.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的第一步是定义一个受重力影响的刚体、一个反对重力的刚体，以及创建刚体时使用的夹具定义。
- en: Next, we create a rectangle and its corresponding body that is affected by gravity.
    For more information on creating rectangles, refer to the *Applying primitives
    to a layer* recipe in [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*, or for more information on creating bodies, refer to
    the *Understanding different body types* recipe in this chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个受重力影响的矩形及其对应的刚体。有关创建矩形的更多信息，请参阅[第2章](ch02.html "第2章. 使用实体")中的*将基元应用于层*教程，*使用实体*，或有关创建刚体的更多信息，请参阅本章中的*了解不同的刚体类型*教程。
- en: 'Then, we create the anti-gravity body and its connected rectangle. By overriding
    the anti-gravity rectangle''s `onManagedUpdate()` method, we can place code in
    it that will run after every engine update. In the case of our `AntiGravityRect`
    rectangle, we fill the `onManagedUpdate()` method with the `antigravityBody.applyForce()`
    method, passing the negated `mPhysicsWorld.getGravity()` method''s `x` and `y`
    values multiplied by `antigravityBody` body''s mass and finally set the force
    to be applied at the world center of `antigravityBody`. By using this force that
    is the exact opposite of the physics-world''s gravity within the `onManagedUpdate()`
    method, the anti-gravity body is corrected against the physics-world''s gravity
    after every update. Furthermore, the force that we apply must be multiplied by
    the body''s mass to fully compensate for the effects of gravity. Refer to the
    following diagram to better understand how anti-gravity bodies function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建反重力刚体及其连接的矩形。通过重写反重力矩形的`onManagedUpdate()`方法，我们可以在其中放置代码，这些代码将在每次引擎更新后运行。在`AntiGravityRect`矩形的情况下，我们用`antigravityBody.applyForce()`方法填充`onManagedUpdate()`方法，传递负的`mPhysicsWorld.getGravity()`方法的`x`和`y`值乘以`antigravityBody`的质量，并最终设置力在世界中心的`antigravityBody`上施加。通过在`onManagedUpdate()`方法中使用与物理世界的重力完全相反的力，每次更新后，反重力刚体都能对抗物理世界的重力。此外，我们施加的力必须乘以刚体的质量，以完全抵消重力的效果。参考以下图表以更好地了解反重力刚体的功能：
- en: '![How it works...](img/8987OS_06_02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_06_02.jpg)'
- en: See also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章中的Box2D物理扩展介绍*。'
- en: '*Using forces, velocities, and torque* in this chapter.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中使用力、速度和扭矩*。'
- en: Working with joints
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关节
- en: In Box2d, **joints** are used to connect two bodies so that each body is in
    some way attached to the other. The various types of joints make it possible to
    customize our characters, vehicles, and the world. Furthermore, joints can be
    created and destroyed during a simulation, which gives us endless possibilities
    for our games. In this recipe, we will create a line joint to demonstrate how
    joints are set up and used in the physics world.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2d中，**关节**用于连接两个刚体，使每个刚体以某种方式附着在另一个上。各种类型的关节使我们能够定制角色、车辆和世界。此外，关节可以在模拟过程中创建和销毁，这为我们的游戏提供了无限的可能性。在本教程中，我们将创建一个线关节，以演示如何在物理世界中设置和使用关节。
- en: Getting ready...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Create an activity following the steps in the *Introduction to the Box2D physics
    extension* section given at the beginning of the chapter. This activity will facilitate
    the creation of two bodies and a connecting line joint that we will use for this
    recipe. Refer to the `JointsActivity` class in the supplemental code for examples
    of more types of joints.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分给出的*Box2D物理扩展介绍*部分的步骤创建一个活动。这个活动将有助于创建两个刚体和一个连接线关节，我们将在此教程中使用它们。参考补充代码中的`JointsActivity`类，了解更多类型的关节示例。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a line joint:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个线关节：
- en: 'Define the following variables within our activity:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的活动中定义以下变量：
- en: '[PRE28]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code in the `onPopulateScene()` method to create two rectangles
    and their associated bodies:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onPopulateScene()`方法中添加以下代码，以创建两个矩形及其相关联的物体：
- en: '[PRE29]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Place the following code after the code shown in the previous step to create
    a line joint that connects the bodies from the previous step:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一步显示的代码之后放置以下代码，以创建一个连接前一步物体的线关节：
- en: '[PRE30]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We first define the two bodies, `LineJointBodyA` and `LineJointBodyB`, that
    will be connected to our line joint and the `boxFixtureDef` fixture definition
    that will be applied to the bodies. For more information about creating fixture
    definitions, refer to the *Introduction to the Box2D physics extension* recipe
    given at the beginning of this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个物体`LineJointBodyA`和`LineJointBodyB`，它们将连接到我们的线关节，以及将应用于这些物体的`boxFixtureDef`夹具定义。关于创建夹具定义的更多信息，请参考本章开始部分提供的*Box2D物理扩展介绍*食谱。
- en: In step two, we create the `LineJointRectA` rectangle using the `Rectangle()`
    constructor with a position of `228f` and `240f`, which places it in the middle
    of the left-half of our scene, and a height and width of `30f` to make it a small
    square. We then set its color to dark orange by calling the `LineJointRectA.setColor()`
    method with the parameters `0.5f`, `0.25f` and `0f`. Next, we create `LineJointRectA`
    rectangle's associated `LineJointBodyA` body by calling the `PhysicsFactory.createBoxBody()`
    constructor with the parameters `mPhysicsWorld`, which is our physics world, `LineJointRectA`,
    which is used to define the shape and position of the body, `BodyType` of `BodyType.KinematicBody`,
    and the `boxFixtureDef` fixture definition.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用`Rectangle()`构造函数创建`LineJointRectA`矩形，其位置为`228f`和`240f`，使其位于场景左半部分的中间位置，高度和宽度设置为`30f`以使其成为一个小正方形。然后，我们通过调用`LineJointRectA.setColor()`方法并传入参数`0.5f`、`0.25f`和`0f`将其颜色设置为深橙色。接下来，我们通过调用`PhysicsFactory.createBoxBody()`构造函数创建与`LineJointRectA`矩形相关联的`LineJointBodyA`物体，传入参数`mPhysicsWorld`（即我们的物理世界）、`LineJointRectA`（用于定义物体的形状和位置）、`BodyType`为`BodyType.KinematicBody`以及`boxFixtureDef`夹具定义。
- en: Next, we handle the creation of `LineJointRectB` and `LineJointBodyB` in the
    same way that we created `LineJointRectA` and `LineJointBodyA`, but with the addition
    of the overridden `onManagedUpdate()` method in the creation of `LineJointRectB`
    and a `PhysicsConnector` class to connect `LineJointRectB` and `LineJointBodyB`.
    The overridden `onManagedUpdate()` method of `LineJointRectB` applies a large
    torque to `LineJointBodyB` by calling the `LineJointBodyB.applyTorque()` method
    with a value of `1000f`. After we apply the torque, we make sure that LineJointBodyB
    body's angular velocity does not exceed `0.2f` by passing `Math.min(LineJointBodyB.getAngularVelocity(),
    0.2f)` to the `LineJointBodyB.setAngularVelocity()` method. Finally, the `PhysicsConnector`
    class created and registered at the end of step two links `LineJointRectB` in
    our scene to `LineJointBodyB` in the physics world.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以创建`LineJointRectA`和`LineJointBodyA`相同的方式处理`LineJointRectB`和`LineJointBodyB`的创建，但在创建`LineJointRectB`时增加了重写的`onManagedUpdate()`方法，并添加了一个`PhysicsConnector`类以连接`LineJointRectB`和`LineJointBodyB`。`LineJointRectB`的`onManagedUpdate()`方法通过调用`LineJointBodyB.applyTorque()`方法并传入值`1000f`，对`LineJointBodyB`施加大的扭矩。施加扭矩后，我们确保`LineJointBodyB`物体的角速度不超过`0.2f`，通过将`Math.min(LineJointBodyB.getAngularVelocity(),
    0.2f)`传递给`LineJointBodyB.setAngularVelocity()`方法。最后，在第二步末尾创建并注册的`PhysicsConnector`类将我们场景中的`LineJointRectB`与物理世界中的`LineJointBodyB`连接起来。
- en: In step three, we create our line joint. To initialize the line joint, we use
    the `lineJointDef.initialize()` method to which we pass the associated bodies,
    `LineJointBodyA` and `LineJointBodyB`. Then, we pass the world-based center of
    `LineJointBodyB` as the anchor point of the joint and `Vector2`, that contains
    the unit vector world axis of our joint. The world axis for our joint is set at
    `0f` and `1f`, which means zero movement on the x axis and a movement with a scale
    of `1f` on the y axis. We then tell the joint to allow collisions between the
    joint's bodies by setting the `lineJointDef.collideConnected` variable to `true`
    and enable the limit of the joint by setting the `lineJointDef.enableLimit` variable
    to `true`, which limits `LineJointBodyB` body's distance from the first. To set
    the lower distance limit of our joint, which represents how far from the joint
    that `LineJointBodyB` body can travel in the negative, we set the `lineJointDef.lowerTranslation`
    variable to `-220f / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`. For the upper
    distance limit, we set the `lineJointDef.upperTranslation` variable to `0f` to
    keep `LineJointBodyB` from being forced above `LineJointBodyA`. Next, we enable
    the joint's motor by setting the `lineJointDef.enableMotor` variable to `true`,
    which will either pull or push `LineJointBodyB` toward or away from `LineJointBodyA`
    depending on the motor's speed. Lastly, we give the joint's motor a fast, negative
    speed by setting the `lineJointDef.motorSpeed` variable to `-200f` to move `LineJointBodyB`
    toward the `lowerTranslation` limit and give the motor a strong maximum force
    by setting the `lineJointDef.maxMotorForce` variable to `420f`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们创建线性关节。为了初始化线性关节，我们使用`lineJointDef.initialize()`方法，并传入相关联的刚体`LineJointBodyA`和`LineJointBodyB`。然后，我们将`LineJointBodyB`的世界中心作为关节的锚点，并传入包含关节的世界单位轴的`Vector2`。我们关节的世界轴设置为`0f`和`1f`，这意味着在x轴上没有移动，在y轴上以`1f`的比例移动。然后，我们通过将`lineJointDef.collideConnected`变量设置为`true`来告诉关节允许两个刚体之间的碰撞，并通过将`lineJointDef.enableLimit`变量设置为`true`来启用关节的限制，这限制了`LineJointBodyB`与第一个刚体的距离。为了设置关节的下限距离，即`LineJointBodyB`可以在负方向上移动多远，我们将`lineJointDef.lowerTranslation`变量设置为`-220f
    / PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`。对于上限距离，我们将`lineJointDef.upperTranslation`变量设置为`0f`，以防止`LineJointBodyB`被推到`LineJointBodyA`之上。接下来，我们通过将`lineJointDef.enableMotor`变量设置为`true`来启用关节的电机，这将根据电机的速度将`LineJointBodyB`向`LineJointBodyA`拉或推。最后，我们通过将`lineJointDef.motorSpeed`变量设置为`-200f`来给关节的电机一个快速的负速度，使`LineJointBodyB`向`lowerTranslation`限制移动，并通过将`lineJointDef.maxMotorForce`变量设置为`420f`来给电机一个强大的最大力。
- en: 'The line joint acts similarly to the suspension-and-wheel part of a car. It
    allows for constrained movement on an axis, usually vertical for vehicles, and
    allows the second body to rotate or act as a powered wheel if necessary. The following
    diagram illustrates the various components of the line joint:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 线性关节的作用类似于汽车的悬挂和车轮部分。它允许在一个轴上进行约束运动，通常是车辆的垂直方向，并允许第二个刚体旋转或必要时作为动力轮。下图说明了线性关节的各个组成部分：
- en: '![How it works...](img/8987OS_06_03.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_06_03.jpg)'
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All joints have two bodies and give us the option of allowing collision between
    those connected bodies. We enable the collision whenever we need it, but the default
    value of every joint's `collideConnected` variable is `false`. Furthermore, the
    second body of all joints should always be one with a `BodyType` type of `BodyType.DynamicBody`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关节都有两个刚体，并为我们提供了允许连接刚体之间碰撞的选项。我们可以在需要时启用碰撞，但每个关节的`collideConnected`变量的默认值是`false`。此外，所有关节的第二个刚体应该是具有`BodyType.DynamicBody`类型的`BodyType`。
- en: For any joints that have a frequency, which determines how elastically the joint
    behaves, never set the frequency to exceed more than half of the physics world
    timestep. If the timestep of the physics world is 40, the maximum value that we
    should assign as the frequency of our joints would be `20f`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有频率的任何关节，该频率决定了关节的弹性行为，切勿将频率设置为超过物理世界时间步长的一半。如果物理世界的时间步长为40，我们应分配给关节频率的最大值应为`20f`。
- en: If either body connected to a joint is destroyed while the joint is active,
    the joint is also destroyed. This means that when we dispose of a physics world,
    we do not need to dispose of the joints within it as long as we destroy all of
    the bodies.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在关节处于活动状态时，与关节连接的任一刚体被销毁，则关节也会被销毁。这意味着当我们处理物理世界时，只要我们销毁所有刚体，就不需要销毁其中的关节。
- en: More joint types
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关节类型
- en: The line joint is only one of several types of joints available for use in our
    physics simulations. The other types of joints are the distance, mouse, prismatic,
    pulley, revolute, and weld joints. Continue reading to learn more about each type.
    Refer to the supplemental `JointsActivity` class for a more in-depth example of
    each of the joint types.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 线性关节只是我们可以在物理模拟中使用的几种关节类型之一。其他类型的关节包括距离关节、鼠标关节、棱柱关节、滑轮关节、旋转关节和焊接关节。继续阅读以了解每种类型的更多信息。参考补充的`JointsActivity`类，以获得每种关节类型的更深入示例。
- en: '![More joint types](img/8987OS_06_04.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![更多关节类型](img/8987OS_06_04.jpg)'
- en: The distance joint
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 距离关节
- en: 'The **distance joint** simply attempts to keep its connected bodies a certain
    distance from each other. If we do not set the length of the distance joint, it
    assumes the length to be the initial distance between its bodies. The following
    code creates a distance joint:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**距离关节**只是试图保持其连接的刚体之间的特定距离。如果我们不设置距离关节的长度，它会假定长度为其刚体之间的初始距离。以下代码创建了一个距离关节：'
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we initialize the distance joint by passing the two bodies to be
    connected, `DistanceJointBodyA` and `DistanceJointBodyB`, and the centers of the
    bodies, `DistanceJointBodyA.getWorldCenter()` and `DistanceJointBodyB.getWorldCenter()`,
    as the anchor points for the joint. Next, we set the length of the joint by setting
    the `distanceJointDef.length` variable to `3.0f`, which tells the joint that the
    two bodies should be 3 meters apart in the physics world. Finally, we set the
    `distanceJointDef.frequencyHz` variable to `1f` to force a small frequency for
    the spring of the joint and the `distanceJointDef.dampingRatio` variable to `0.001f`
    to produce a very small dampening effect for the connected bodies. For an easier
    understanding of what the distance joint looks like, refer to the preceding diagram.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过传递两个要连接的刚体`DistanceJointBodyA`和`DistanceJointBodyB`以及刚体的中心点`DistanceJointBodyA.getWorldCenter()`和`DistanceJointBodyB.getWorldCenter()`作为关节的锚点来初始化距离关节。接下来，我们通过设置`distanceJointDef.length`变量为`3.0f`来设置关节的长度，这告诉关节在物理世界中两个刚体应该相隔3米。最后，我们将`distanceJointDef.frequencyHz`变量设置为`1f`以强制关节弹簧具有小的频率，并将`distanceJointDef.dampingRatio`变量设置为`0.001f`以产生连接刚体的非常小的阻尼效果。为了更容易理解距离关节的外观，请参考前面的图表。
- en: The mouse joint
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 鼠标关节
- en: 'The **mouse joint** attempts to pull a body to a specific location, usually
    the location of a touch, using a set maximum force. It is a great joint for testing
    purposes, but for the release version of most games, we should opt for using a
    kinematic body with the appropriate code to move it to where a touch is registered.
    To understand how the mouse joint acts, reference the preceding diagram. The following
    code defines a mouse joint:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**鼠标关节**试图使用设定的最大力将一个刚体拉到特定位置，通常是触摸的位置。它是一个很好的测试用关节，但对于大多数游戏的发布版本，我们应选择使用适当的代码将动力刚体移动到触摸注册的位置。要了解鼠标关节的作用，请参考前面的图表。以下代码定义了一个鼠标关节：'
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unlike other joints, the mouse joint does not have an `initialize()` method
    to help set up the joint. We first create the `mouseJointDef` mouse joint definition
    and set the `mouseJointDef.bodyA` variable to `MouseJointBodyA` and the `mouseJointDef.bodyB`
    variable to `MouseJointBodyB` in order to tell the joint which bodies it will
    be linking. In all of our simulations, `MouseJointBodyA` should be an immobile
    body that does not move while the mouse joint is active.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他关节不同，鼠标关节没有`initialize()`方法来帮助设置关节。我们首先创建`mouseJointDef`鼠标关节定义，并将`mouseJointDef.bodyA`变量设置为`MouseJointBodyA`，将`mouseJointDef.bodyB`变量设置为`MouseJointBodyB`，以告诉关节它将连接哪些刚体。在我们所有的模拟中，`MouseJointBodyA`应该是一个不动的刚体，在鼠标关节激活时不会移动。
- en: Next, we set the `mouseJointDef.dampingRatio` variable to `0.0f` to cause the
    joint to have absolutely no damping. We then set the `mouseJointDef.frequencyHz`
    variable to `1f` to force a slight frequency response whenever `MouseJointBodyB`
    has reached the mouse joint's target, which we can see being set in the following
    code. Finally, we set the `maxForce` variable of our `mouseJointDef to (100.0f
    * MouseJointBodyB.getMass())` method. The strong force of `100.0f` is multiplied
    by `MouseJointBodyB` body's mass to account for any changes in the mass of `MouseJointBodyB`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`mouseJointDef.dampingRatio`变量设置为`0.0f`，使关节完全没有阻尼。然后，我们将`mouseJointDef.frequencyHz`变量设置为`1f`，以在`MouseJointBodyB`达到鼠标关节的目标时强制产生轻微的频率响应，我们可以在下面的代码中看到这一点。最后，我们将`mouseJointDef`的`maxForce`变量设置为`(100.0f
    * MouseJointBodyB.getMass())`方法。强大的力`100.0f`乘以`MouseJointBodyB`的质量，以考虑`MouseJointBodyB`质量的变化。
- en: 'In this code, we initialized the mouse joint, but it should only be active
    after the simulation has started. To activate the mouse joint from within the
    `onSceneTouchEvent()` method of a class while the simulation is running, see the
    following code. Note that the `mouseJoint` variable, which is a mouse joint, is
    created at the class level:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们初始化了鼠标关节，但它只应在模拟开始后激活。要在模拟运行时从类的`onSceneTouchEvent()`方法内部激活鼠标关节，请参阅以下代码。请注意，`mouseJoint`变量是一个鼠标关节，在类级别创建：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the screen is first touched, which is determined by checking `pSceneTouchEvent.isActionDown()`,
    we set the initial mouse joint target using the `mouseJointDef.target.set()` method
    to the world center of `MouseJointBodyB` via the `MouseJointBodyB.getWorldCenter()`
    method. Then, we set the `mouseJoint` variable by creating the mouse joint definition
    in the physics world using the `MouseJoint` joint-casted `mPhysicsWorld.createJoint()`
    method with the `mouseJointDef` variable as the parameter. After the joint is
    created, we create `Vector2` from `Vector2Pool`, that holds the location of the
    scene's touch location, `pSceneTouchEvent.getX()` and `pSceneTouchEvent.getY()`,
    converted to physics-world coordinated by dividing the location by `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次被触摸时，通过检查`pSceneTouchEvent.isActionDown()`确定，我们使用`mouseJointDef.target.set()`方法将初始鼠标关节目标设置为`MouseJointBodyB`的世界中心，通过`MouseJointBodyB.getWorldCenter()`方法获取。然后，我们通过在物理世界中使用`MouseJoint`关节转换的`mPhysicsWorld.createJoint()`方法以及`mouseJointDef`变量作为参数创建鼠标关节定义，来设置`mouseJoint`变量。关节创建后，我们从`Vector2Pool`创建`Vector2`，保存场景触摸位置`pSceneTouchEvent.getX()`和`pSceneTouchEvent.getY()`，通过除以`PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`转换为物理世界的坐标。
- en: We then change the `mouseJoint` joint's target variable to the previously created
    `Vector2` and recycle `Vector2` to `Vector2Pool`. While the touch is still active,
    determined by checking `pSceneTouchEvent.isActionMove()`, we update the target
    of the mouse joint using the same procedure that we used immediately after creating
    the mouse joint in the physics world. We call for `Vector2` from `Vector2Pool`,
    that is set to the physics world-converted touch location, set the target of the
    mouse joint to that `Vector2`, and then recycle `Vector2`. As soon as the touch
    is released, which is determined by checking `pSceneTouchEvent.isActionCancel()`,
    `pSceneTouchEvent.isActionOutside()`, or `pSceneTouchEvent.isActionUp()`, we destroy
    the mouse joint in the world by calling the `mPhysicsWorld.destroyJoint()` method
    with our `mouseJoint` variable as the parameter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`mouseJoint`关节的目标变量更改为先前创建的`Vector2`，并将`Vector2`回收至`Vector2Pool`。当触摸仍然有效时，通过检查`pSceneTouchEvent.isActionMove()`确定，我们使用在物理世界中创建鼠标关节后立即使用的相同过程来更新鼠标关节的目标。我们从`Vector2Pool`获取`Vector2`，将其设置为转换后的物理世界触摸位置，将鼠标关节的目标设置为该`Vector2`，然后回收`Vector2`。一旦触摸释放，通过检查`pSceneTouchEvent.isActionCancel()`，`pSceneTouchEvent.isActionOutside()`，或`pSceneTouchEvent.isActionUp()`确定，我们通过调用`mPhysicsWorld.destroyJoint()`方法并传入我们的`mouseJoint`变量作为参数，在世界中销毁鼠标关节。
- en: '![The mouse joint](img/8987OS_06_05.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标关节](img/8987OS_06_05.jpg)'
- en: The prismatic joint
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 斜轴关节（prismatic joint）
- en: 'The **prismatic joint** allows its connected bodies to slide apart or together
    on a single axis, powered by a motor if necessary. The bodies have a locked rotation,
    so we must keep that in mind when designing a simulation that uses a prismatic
    joint. Consider the preceding diagram to grasp how this joint functions. The following
    code creates a prismatic joint:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**斜轴关节**允许其连接的刚体沿单一轴滑动分离或靠拢，必要时可以由电机驱动。刚体具有锁定的旋转，因此在使用斜轴关节设计模拟时我们必须牢记这一点。考虑前面的图表来理解这个关节是如何工作的。以下代码创建了一个斜轴关节：'
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After defining our `prismaticJointDef` variable, we initialize it using the
    `prismaticJointDef.initialize()` method and passing to it our connected bodies,
    `PrismaticJointBodyA` and `PrismaticJointBodyB`, the anchor point, which we declare
    to be the center of `PrismaticJointBodyA` in world coordinates, and the unit vector
    world axis of the joint in terms of a `Vector2` object, `Vector2(0f,1f)`. We disable
    collision between the bodies by setting the `prismaticJointDef.collideConnected`
    variable to `false` and then enable limits for the range of sliding of the joint
    by setting the `prismaticJointDef.enableLimit` variable to `true`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`prismaticJointDef`变量之后，我们使用`prismaticJointDef.initialize()`方法对其进行初始化，并传递我们的连接刚体`PrismaticJointBodyA`和`PrismaticJointBodyB`，锚点被声明为`PrismaticJointBodyA`在世界坐标系中的中心点，以及关节的世界单位向量轴，以`Vector2`对象`Vector2(0f,1f)`表示。我们通过将`prismaticJointDef.collideConnected`变量设置为`false`来禁用两个刚体之间的碰撞，并通过将`prismaticJointDef.enableLimit`变量设置为`true`来启用关节滑动范围的限制。
- en: To set the limits of the joint, we set the `lowerTranslation` and `upperTranslation`
    properties to `-80f` and `80f` pixels, respectively, divided by `PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`
    to convert the pixel limits to meters in the physics world. Finally, we enable
    the motor by setting the `prismaticJointDef.enableMotor` property to `true`, set
    its max force to `400f` via the `prismaticJointDef.maxMotorForce` property, and
    set its speed to a positive `500f` via the `prismaticJointDef.motorSpeed` property
    to drive `PrismaticJointBodyB` toward the upper-limit of the joint.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置关节的限制，我们将`lowerTranslation`和`upperTranslation`属性分别设置为`-80f`和`80f`像素，然后除以`PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT`，将像素限制转换为物理世界中的米。最后，我们通过将`prismaticJointDef.enableMotor`属性设置为`true`来启用马达，通过`prismaticJointDef.maxMotorForce`属性将其最大力设置为`400f`，并通过`prismaticJointDef.motorSpeed`属性将其速度设置为正值`500f`，以驱动`PrismaticJointBodyB`向关节的上限移动。
- en: The pulley joint
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 滑轮关节
- en: 'The **pulley joint** acts much like a realistic pulley—when one side descends,
    the other ascends. The length of the pulley joint is determined at initialization
    and should not be changed after creation. Refer to the preceding diagram to see
    what a pulley joint looks like. The following code creates a pulley joint:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**滑轮关节**的作用非常类似于真实的滑轮——当一侧下降时，另一侧上升。滑轮关节的长度在初始化时确定，并且在创建后不应更改。参考前图以了解滑轮关节的外观。以下代码创建了一个滑轮关节：'
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After creating the `pulleyJointDef` variable, we initialize it via the `pulleyJointDef.initialize()`
    method. The first two parameters of the `pulleyJointDef.initialize()` method are
    the two connected bodies, `PulleyJointBodyA` and `PulleyJointBodyB`. The next
    two parameters are the ground anchors for the pulley, which in this case are `2.5f`
    meters above each body. To get the relative point above each body in world coordinates,
    we use the `getWorldPoint()` method of each of the bodies with an x parameter
    of `0` and a y parameter of `2.5` meters above each body. The fifth and sixth
    parameters of the `pulleyJointDef.initialize()` method are the anchor points of
    each body in world coordinates. We use the center in this simulation, so we pass
    the `getWorldCenter()` method of each of the connected bodies.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`pulleyJointDef`变量之后，我们通过`pulleyJointDef.initialize()`方法对其进行初始化。`pulleyJointDef.initialize()`方法的前两个参数是两个连接的刚体，分别是`PulleyJointBodyA`和`PulleyJointBodyB`。接下来的两个参数是滑轮的地面锚点，在这种情况下，它们分别位于每个刚体上方`2.5f`米处。为了获取每个刚体上方世界坐标系中的相对点，我们使用每个刚体的`getWorldPoint()`方法，x参数为`0`，y参数为每个刚体上方`2.5`米。`pulleyJointDef.initialize()`方法的第五和第六个参数是每个刚体在世界坐标系中的锚点。在这个模拟中，我们使用中心点，因此传递每个连接刚体的`getWorldCenter()`方法。
- en: The final parameter of the method is the ratio of the pulley, `1f` in this case.
    A ratio of `2` would cause `PulleyJointBodyA` to move twice the distance from
    its ground anchor for every distance change of `PulleyJointBodyB` from its ground
    anchor. Furthermore, because the work required by `PulleyJointBodyA` to move in
    relation to its ground anchor would be half of the work that `PulleyJointBodyB`
    would take to move, `PulleyJointBodyA` would have more leverage than `PulleyJointBodyB`,
    causing `PulleyJointBodyA` to be more easily affected by gravity and thus acting
    to lift `PulleyJointBodyB` in a normal simulation. The last step in creating a
    pulley joint is to call the `mPhysicsWorld.createJoint()` method by passing to
    it our `pulleyJointDef` variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的最后一个参数是滑轮的比例，在这种情况下是`1f`。比例为`2`将导致`PulleyJointBodyA`相对于其地面锚点的移动距离是`PulleyJointBodyB`的每段距离变化的两倍。此外，因为`PulleyJointBodyA`相对于其地面锚点移动所需的工作量是`PulleyJointBodyB`所需工作量的一半，所以`PulleyJointBodyA`比`PulleyJointBodyB`有更大的杠杆作用，导致在正常模拟中`PulleyJointBodyA`更容易受到重力的影响，从而起到提升`PulleyJointBodyB`的作用。创建滑轮接头的最后一步是调用`mPhysicsWorld.createJoint()`方法，并将我们的`pulleyJointDef`变量传递给它。
- en: '![The pulley joint](img/8987OS_06_06.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![滑轮接头](img/8987OS_06_06.jpg)'
- en: The revolute joint
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转动关节
- en: 'The **revolute joint** is the most popular joint in Box2D simulations. It is
    essentially a pivot point between its two connected bodies with an optional motor
    and limits. See the previous diagram to help clarify how the revolute joint functions.
    The following code creates a revolute joint:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**转动关节**是Box2D模拟中最受欢迎的关节类型。它本质上是两个连接体之间的一个支点，具有可选的电机和限制。查看前一个图表可以帮助更清楚地了解转动关节的工作原理。以下代码创建了一个转动关节：'
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We first define the `revoluteJointDef` definition as a new `RevoluteJointDef()`
    method. Then, we initialize it using the `revoluteJointDef.initialize()` method
    with the parameters of `RevoluteJointBodyA` and `RevoluteJointBodyB` to connect
    the bodies and the `getWorldCenter()` method of `RevoluteJointBodyA` to define
    where the joint will rotate. Then, we enable our revolute joint's motor by setting
    the `revoluteJointDef.enableMotor` property to `true`. Next, we set the `maxMotorTorque`
    property to `5000f` to make the motor very strong and the `motorSpeed` property
    to `-1f` to make the motor spin clockwise at a very slow rate. Finally, we create
    the revolute joint in the physics world by calling `mPhysicsWorld.createJoint(revoluteJointDef)`
    to make the physics world create a revolute joint using our `revoluteJointDef`
    variable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`revoluteJointDef`定义为新创建的`RevoluteJointDef()`方法。然后，我们使用`revoluteJointDef.initialize()`方法初始化它，参数为`RevoluteJointBodyA`和`RevoluteJointBodyB`以连接两个刚体，以及`RevoluteJointBodyA`的`getWorldCenter()`方法来定义关节旋转的位置。接着，我们通过将`revoluteJointDef.enableMotor`属性设置为`true`来启用我们的转动关节的电机。然后，我们将`maxMotorTorque`属性设置为`5000f`以使电机非常强大，并将`motorSpeed`属性设置为`-1f`以使电机以非常慢的速度顺时针旋转。最后，我们通过调用`mPhysicsWorld.createJoint(revoluteJointDef)`在物理世界中创建转动关节，使物理世界使用我们的`revoluteJointDef`变量创建一个转动关节。
- en: The weld joint
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 焊接接头
- en: 'The **weld joint** bonds two bodies together and disables rotation between
    them. It is a useful joint for destructible objects, but larger destructible objects
    will occasionally fail due to jittering from Box2D''s iterative position solver.
    In such a case, we would create the object from multiple fixtures, and recreate
    each piece of the object, when detached, in the form of a new body. Refer to the
    previous diagram of the weld joint to better understand how it works. The following
    code creates a weld joint:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**焊接关节**将两个刚体连接在一起并禁用它们之间的旋转。它对于可破坏物体非常有用，但是较大的可破坏物体可能会由于Box2D的迭代位置求解器产生的抖动而偶尔失败。在这种情况下，我们会从多个夹具创建物体，并在物体分离时以新刚体的形式重新创建每个部分。参考前一个焊接关节的图表，可以更好地理解它是如何工作的。以下代码创建了一个焊接关节：'
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To create our weld joint, we first create a `WeldJointDef` definition named
    `weldJointDef`. Then, we initialize it by calling the `weldJointDef.initialize()`
    method with the body parameters of `WeldJointBodyA` and `WeldJointBodyB` to connect
    our bodies and the anchor point of the joint at the center of `WeldJointBodyA`
    body in world coordinates. The anchor point of a weld joint may seem like it could
    be placed anywhere, but because of how Box2D handles the anchor of weld joints
    during collision, we want to put it at the center location of one of the connected
    bodies. Doing otherwise can cause shearing or displacement of the joint when colliding
    with a body that has a large mass.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的焊接关节，我们首先创建一个名为`weldJointDef`的`WeldJointDef`定义。然后，通过调用`weldJointDef.initialize()`方法并传入`WeldJointBodyA`和`WeldJointBodyB`的身体参数以及关节在世界坐标系中`WeldJointBodyA`身体的中心作为锚点来初始化它。焊接关节的锚点似乎可以放在任何地方，但由于Box2D在碰撞处理焊接关节的锚点时的方式，我们希望将其放置在连接身体之一的中心位置。否则，在与具有大质量的身体碰撞时，可能会导致关节剪切或位移。
- en: See also
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*Box2D物理扩展介绍*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*了解不同的身体类型*。
- en: Creating a rag doll
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建布娃娃
- en: One of the most popular depictions of characters in physics simulations is the
    rag doll. The visual look of such characters differs according to detail, but
    the underlying system is always the same—we just attach several physics bodies
    to a larger physics body via joints. In this recipe, we will create a rag doll.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 物理模拟中最受欢迎的角色描绘之一是布娃娃。这类角色的视觉外观根据细节而有所不同，但底层系统始终相同——我们只是通过关节将几个物理身体附着到更大的物理身体上。在本食谱中，我们将创建一个布娃娃。
- en: Getting ready...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Review the creation of a physics-based activity in the *Introduction to the
    Box2D physics extension* recipe, the creation of bodies in the *Understanding
    different body types* recipe, and the use of revolute joints and mouse joints
    in the *Working with joints* recipe, all found in this chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 复习本章中*Box2D物理扩展介绍*食谱中物理活动创建，*了解不同的身体类型*食谱中身体创建，以及*处理关节*食谱中旋转关节和鼠标关节的使用。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Refer to the supplemental `RagdollActivity` class for the code that we use in
    this recipe.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考补充的`RagdollActivity`类，这是我们在此食谱中使用的代码。
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first step is to define the variables that represent the multiple bodies
    that make up our rag doll. Our bodies are the `headBody`, which represents the
    head, the `torsoBody`, which represents the torso, the `leftUpperarmBody` and
    `leftForearmBody`, representing the left arm, the `rightUpperarmBody` and `rightForearmBody`,
    representing the right arm, the `leftThighBody` and `leftCalfBody`, which represent
    the left leg, and finally the `rightThighBody` and `rightCalfBody`, which represent
    the right leg. The following diagram shows how all of our bodies will be linked
    together using revolute joints:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义代表布娃娃多个身体的变量。我们的身体包括代表头部的`headBody`，代表躯干的`torsoBody`，代表左臂的`leftUpperarmBody`和`leftForearmBody`，代表右臂的`rightUpperarmBody`和`rightForearmBody`，代表左腿的`leftThighBody`和`leftCalfBody`，以及最后代表右腿的`rightThighBody`和`rightCalfBody`。以下图表显示了如何使用旋转关节将我们所有的身体连接在一起：
- en: '![How it works...](img/8987OS_06_07.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_06_07.jpg)'
- en: Next, we define the necessary variables used by our mouse joint to throw the
    rag doll when the screen is touched, the `Vector2 localMouseJointTarget` target
    for the mouse joint, the `mouseJointDef` mouse joint definition, the `mouseJoint`
    joint, and the ground body for the mouse joint, `MouseJointGround`. We then create
    the fixture definitions that we will apply to the various parts of our ragdoll—`headFixtureDef`
    for the head, `torsoFixtureDef` for the torso, `armsFixtureDef` for the arms,
    and `legsFixtureDef` for the legs. For more information on creating fixture definitions,
    refer to the *Introduction to the Box2D physics extension* recipe in this chapter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了当屏幕被触摸时用来抛掷布娃娃的鼠标关节所需的变量，即`Vector2 localMouseJointTarget`鼠标关节的目标，`mouseJointDef`鼠标关节定义，`mouseJoint`关节，以及鼠标关节的地面身体`MouseJointGround`。然后，我们创建了将应用于布娃娃各个部分的固定装置定义——头部的`headFixtureDef`，躯干的`torsoFixtureDef`，手臂的`armsFixtureDef`以及腿部的`legsFixtureDef`。有关创建固定装置定义的更多信息，请参考本章中的*Box2D物理扩展介绍*食谱。
- en: Then, in the `onPopulateScene()` method, we create individual rectangles and
    their linked bodies, which are defined in the activity, for each body part of
    the rag doll. Each rectangle matches the exact location and size in which its
    corresponding body part is located As we create the bodies to be linked to the
    rectangles, we assign the appropriate fixture definition defined in the activity
    via the final parameter of the `PhysicsFactory.createBoxBody()` method. Finally,
    for each rectangle body group, we register a `PhysicsConnector` object with the
    physics world. For more information on creating bodies and `PhysicsConnector`
    objects, refer to the *Understanding different body types* recipe in this chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onPopulateScene()`方法中，我们为布娃娃的每个身体部位创建单独的矩形和它们关联的物体，这些在活动中定义。每个矩形与其对应身体部位的位置和大小完全匹配。在我们创建要链接到矩形的物体时，我们通过`PhysicsFactory.createBoxBody()`方法的最后一个参数分配活动中定义的适当的固定定义。最后，对于每个矩形身体组，我们向物理世界注册一个`PhysicsConnector`对象。有关创建物体和`PhysicsConnector`对象的更多信息，请参考本章中的*了解不同的身体类型*食谱。
- en: Next, we create the many revolute joints that connect the body parts of our
    rag doll. The locations of the anchor points of each joint are where we want that
    body part to rotate, in world coordinates, passed via the final parameter of the
    `initialize()` method of each of the joint definitions. We make sure that each
    joint's connected bodies do not collide by setting the joint's `collideConnected`
    property to `false`. This does not keep the bodies from colliding with other portions
    of the rag doll, but it does allow the joint's bodies to overlap when rotating.
    Next, notice that we apply limits to the joint definitions to keep the body parts
    from moving beyond a set range of motion, much like the limits that humans have
    when moving their limbs. Not setting limits for the joints would create a rag
    doll that would allow complete rotation of its limbs, which is an unrealistic
    representation but necessary for some simulations. For more information on revolute
    joints, refer to the *Working with joints* recipe in this chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建许多旋转关节，用以连接布娃娃的身体部位。每个关节的锚点位置是在世界坐标系中我们希望该身体部位旋转的地方，通过每个关节定义的`initialize()`方法的最后一个参数传递。我们确保每个关节连接的物体不会相互碰撞，通过将关节的`collideConnected`属性设置为`false`。这不会阻止物体与其他布娃娃部分发生碰撞，但确实允许关节的物体在旋转时重叠。接下来，注意我们给关节定义应用了限制，以防止身体部位移动超出一定的运动范围，这很像人类移动四肢时的限制。如果不为关节设置限制，将会创建一个允许其四肢完全旋转的布娃娃，这种表示虽然不真实，但对于某些模拟是必要的。有关旋转关节的更多信息，请参考本章中的*使用关节*食谱。
- en: After creating the revolute joints that represent the joints of our rag doll,
    we create the `mouseJointDef` mouse joint definition that will allow us to fling
    the rag doll around the scene. We attach the `headBody` body of our rag doll as
    the mouse joint's second body, but any of the bodies attached to the rag doll
    could be used depending on the simulation. Our final step in creating our rag
    doll is to set up the mouse joint for use at runtime via touch interactions passed
    by the `onSceneTouchEvent()` method of our activity. For more information on using
    mouse joints, refer to the *Working with joints* recipe in this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表示布娃娃关节的旋转关节之后，我们创建了`mouseJointDef`鼠标关节定义，这将允许我们拖动布娃娃在场景中飞来飞去。我们将布娃娃的`headBody`作为鼠标关节的第二个物体，但根据模拟的需要，可以使用连接到布娃娃的任何物体。创建布娃娃的最后一个步骤是设置鼠标关节，以便在运行时通过`onSceneTouchEvent()`方法的触摸交互使用。有关使用鼠标关节的更多信息，请参考本章中的*使用关节*食谱。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*Box2D 物理扩展介绍*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*了解不同的身体类型*。
- en: '*Working with joints* in this chapter.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用关节*。
- en: Creating a rope
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一根绳子
- en: Though it is performance-intensive to simulate a realistic rope using Box2D,
    a simple rope is not only fast, but also very customizable. A rope, from a construction
    standpoint, is similar to a rag doll and can add an extra layer of playability
    to a game. If a physics simulation seems to be too bland to attract players, the
    addition of rope will be sure to give players another reason to like a game. In
    this recipe, we will create a physics-enabled rope for use in our simulations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用Box2D模拟真实的绳子是性能密集型的，但一个简单的绳子不仅快速，而且非常可定制。从构建的角度来看，绳子类似于布娃娃，可以为游戏增加额外的可玩层次。如果一个物理模拟看起来过于平淡，无法吸引玩家，那么添加绳子将肯定给玩家另一个喜欢游戏的原因。在本食谱中，我们将创建一个用于我们模拟的物理启用的绳子。
- en: Getting ready...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好...
- en: Review the creation of a physics-based activity in the *Introduction to the
    Box2D physics extension* recipe, the creation of bodies in the *Understanding
    different body types* recipe, and the use of revolute joints and mouse joints
    in the *Working with joints* recipe, all found in this chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章中的*Box2D物理扩展介绍*食谱中基于物理的活动创建，*了解不同的身体类型*食谱中的身体创建，以及*使用关节*食谱中的旋转关节和鼠标关节的使用。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Refer to the supplemental `Rope` and `RopeActivity` classes for the code that
    we use in this recipe.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考补充的`Rope`和`RopeActivity`类，了解我们在此食谱中使用的代码。
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A rope created in Box2D can be thought of as a chain of similar bodies linked
    together by joints. We can use either rectangular or circular bodies to define
    each section of a rope, but circular bodies will have less chance of catching
    onto and stretching from collision with other bodies. See the following diagram
    to get an idea of how we design a rope for a physics simulation:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D中创建的绳子可以被视为由关节连接在一起的相似身体的链条。我们可以使用矩形或圆形身体来定义绳子的每个部分，但圆形身体在与其他身体碰撞时抓住并拉伸的可能性较小。查看以下图表，了解我们如何为物理模拟设计绳子：
- en: '![How it works...](img/8987OS_06_08.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_06_08.jpg)'
- en: First, refer to the `Rope` class, which will make it easier for us to create
    multiple ropes and fine-tune all of the ropes at once for our simulation. The
    initial code in the `Rope` class is a set of variables that reflect the specific
    properties of each rope. The `numRopeSegments` variable holds the number of segments
    that our rope will have. The `ropeSegmentsLength` and `ropeSegmentsWidth` variables
    hold the length and width that each segment of rope will have. Next, the `ropeSegmentsOverlap`
    variable represents how much each rope segment will overlap the previous rope
    segment, which prevents gaps during slight stretches. The `RopeSegments` array
    and `RopeSegmentsBodies` array define the rectangles and bodies for each segment
    of our rope. Finally, the `RopeSegmentFixtureDef` fixture definition will hold
    the fixture data that we will apply to each segment of the rope.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，参考`Rope`类，这将使我们更容易创建多条绳子，并一次性为我们的模拟调整所有绳子。`Rope`类中的初始代码是一组反映每条绳子特定属性的变量。`numRopeSegments`变量保存我们的绳子将拥有的段数。`ropeSegmentsLength`和`ropeSegmentsWidth`变量保存每个绳子段的长度和宽度。接下来，`ropeSegmentsOverlap`变量表示每个绳子段与上一个绳子段重叠多少，这可以防止在轻微拉伸时出现间隙。`RopeSegments`数组和`RopeSegmentsBodies`数组为我们的绳子的每个部分定义矩形和身体。最后，`RopeSegmentFixtureDef`固定定义将保存我们将应用于绳子每个部分的固定装置数据。
- en: Next, we create a constructor, named `Rope`, to handle the placement, detail,
    length, width, weight, and general creation of the rope. Then, we assign values
    to the variables created in the previous step. Notice that the `RopeSegmentFixtureDef`
    fixture definition starts with the maximum density. As each segment of the rope
    is created via the `for` loop later in the constructor, the density, and thus
    mass, of the fixture decrements to the minimum density. This prevents stretching
    by giving the highest body segments the most strength to hold the lower body segments.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`Rope`的构造函数，以处理绳子的放置、细节、长度、宽度、重量以及绳子的总体创建。然后，我们为上一步创建的变量赋值。注意，`RopeSegmentFixtureDef`固定定义从最大密度开始。由于绳子的每个部分都是通过构造函数后面的`for`循环创建的，因此固定装置的密度（从而质量）会递减到最小密度。这通过给最高身体部分最大的强度来防止拉伸，以保持较低身体部分。
- en: At the beginning of the `Rope` constructor's `for` loop, we define the revolute
    joint for each rope segment. For more information on revolute joints, see the
    *Working with joints* recipe in this chapter. Then, we create the rectangle, `RopeSegments[i]`,
    that will represent the segment, checking to make sure that the first segment,
    when `i` is less than `1`, is placed according to the `pAttachTo` hinge passed
    in the constructor while the remaining segments are placed relative to their previous
    segment, `RopeSegments[i-1]`. The creation of the rectangles includes an overlap
    value, `ropeSegmentsOverlap`, to remove spacing in the rope caused by the iterative
    process of Box2D.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Rope`构造函数的`for`循环开始处，我们为每个绳索段定义了旋转关节。关于旋转关节的更多信息，请参见本章中的*使用关节*部分。然后，我们创建了表示该段的矩形`RopeSegments[i]`，并检查确保当`i`小于`1`时，第一个段根据构造函数中传递的`pAttachTo`铰链放置，而其余的段相对于它们的前一段`RopeSegments[i-1]`放置。创建矩形时包括了一个重叠值`ropeSegmentsOverlap`，以消除由Box2D的迭代过程造成的绳索中的间隔。
- en: After we have created the segment's rectangle and set its color to brown by
    calling `RopeSegments[i].setColor(0.97f, 0.75f, 0.54f)`, we apply the density
    calculation to the `RopeSegmentFixtureDef` fixture definition and create a circular
    body based on the segment's rectangle using the `PhysicsFactory.createCircleBody()`
    method. For more information on creating bodies, refer to the *Understanding different
    body types* recipe in this chapter. We then set a moderate angular damping of
    each rope segment body via the `setAngularDamping(4f)` method and a slight linear
    damping via the `setLinearDamping(0.5f)` method to remove unpredictability in
    the rope's behavior.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了段的矩形并通过调用`RopeSegments[i].setColor(0.97f, 0.75f, 0.54f)`将其颜色设置为棕色之后，我们对`RopeSegmentFixtureDef`固定定义应用了密度计算，并使用`PhysicsFactory.createCircleBody()`方法基于段的矩形创建了一个圆形体。关于创建体的更多信息，请参考本章中的*了解不同的体类型*部分。然后，我们通过`setAngularDamping(4f)`方法为每个绳索段体设置适中的角阻尼，并通过`setLinearDamping(0.5f)`方法设置轻微的线性阻尼，以消除绳索行为中的不可预测性。
- en: After that, we enable the rope segment to act as a bullet by setting the `RopeSegmentsBodies[i].setBullet`
    property to `true`, which reduces the chances of our segments slipping through
    colliding bodies. Finally, we create the revolute joint for the current rope segment
    in relation to the previous segment, or the hinge if the current segment is the
    first in the rope. For more information on revolute joints, refer to the *Working
    with joints* recipe in this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过将`RopeSegmentsBodies[i].setBullet`属性设置为`true`，使绳索段能够作为子弹行动，这减少了我们的段穿过碰撞体的机会。最后，我们为当前绳索段相对于前一段或如果当前段是绳索中的第一段则相对于铰链创建旋转关节。关于旋转关节的更多信息，请参见本章中的*使用关节*部分。
- en: For our activity class, we first create the variables necessary for our mouse
    joint, which will move the rope's hinge body to the touched location, and define
    our `RopeHingeBody` body that will act as the anchor point of the rope. Then,
    in the `onPopulateScene()` method, we create our `RopeHingeBody` body and, subsequently,
    our `rope` object, passing the rope-hinge body as the first parameter to the `Rope`
    constructor. For more information on creating bodies, refer to the *Understanding
    different body types* recipe in this chapter. The next parameters of the `Rope`
    constructor tell our rope to be `10` segments long, make each segment `25f` pixels
    long and `10f` pixels wide with an overlap of `2f` pixels, have a minimum density
    of `5f` and a maximum density of `50f`, and our `mScene` scene to which we attach
    the rope segment rectangles. The final two parameters of the `Rope` constructor
    tell the rope to create the segment bodies in our `mPhysicsWorld` physics world
    and to set each segment's rectangle to be managed by the activity's `VertexBufferObjectManager`
    class.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的活动类，我们首先创建了用于鼠标关节的必要变量，该关节将绳索的铰链体移动到触摸位置，并定义了我们的`RopeHingeBody`体，该体将作为绳索的锚点。然后在`onPopulateScene()`方法中，我们创建了`RopeHingeBody`体，随后是我们的`rope`对象，将绳索铰链体作为第一个参数传递给`Rope`构造函数。关于创建体的更多信息，请参考本章中的*了解不同的体类型*部分。`Rope`构造函数的下一个参数告诉我们的绳索要有`10`个段长，每个段长`25f`像素，宽`10f`像素，重叠`2f`像素，具有最小密度`5f`和最大密度`50f`，以及我们附加绳索段矩形的`mScene`场景。`Rope`构造函数的最后两个参数告诉绳索在我们的`mPhysicsWorld`物理世界中创建段体，并将每个段的矩形设置为活动类的`VertexBufferObjectManager`管理。
- en: Next, we define and set up the variables used for our mouse joint. Take note
    that we set the `RopeHingeBody` body as the mouse joint's second body. Finally,
    we set up the `onSceneTouchEvent()` method to handle our mouse joint. For more
    information on mouse joints, refer to the *Working with joints* recipe in this
    chapter.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义并设置用于我们的鼠标关节的变量。请注意，我们将`RopeHingeBody`设置为鼠标关节的第二个物体。最后，我们设置`onSceneTouchEvent()`方法来处理我们的鼠标关节。有关鼠标关节的更多信息，请参考本章中的*处理关节*部分。
- en: See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*Box2D 物理扩展介绍*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*了解不同的物体类型*。
- en: '*Working with joints* in this chapter.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*处理关节*。
- en: Working with collisions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: Causing an effect to occur from the collisions between bodies, whether it is
    the playing of sound or the disposal of a body, is often a necessary part of a
    game based on a physics simulation. Handling collisions seems like an intimidating
    task at first, but it will become second nature after we learn how each part of
    the `ContactListener` interface functions. In this recipe, we will demonstrate
    how to handle collisions between fixtures.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于物理模拟的游戏中，使物体之间的碰撞产生某种效果，无论是播放声音还是处理物体，通常都是必要的部分。处理碰撞一开始看起来可能是一项艰巨的任务，但当我们了解了`ContactListener`接口的每个部分如何工作之后，它就会变得很自然。在本教程中，我们将演示如何处理固定装置之间的碰撞。
- en: Getting ready...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    the creation of our simulation in which we will control collision behavior.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分*Box2D 物理扩展介绍*中的步骤创建一个新活动，这将有助于创建我们的模拟，其中我们将控制碰撞行为。
- en: How to do it...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to demonstrate our control of collisions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤演示我们对碰撞的控制：
- en: 'Place the following definitions at the beginning of the activity class:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动类的开始处放置以下定义：
- en: '[PRE38]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To determine whether a specific body is contacted in the `ContactListener`
    interface, insert the following method in the activity:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在`ContactListener`接口中确定特定物体是否被接触，请在活动中插入以下方法：
- en: '[PRE39]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following method is similar to the previous method, but tests another body
    in addition to the first. Add it to the class after the previous method:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的方法与之前的方法相似，但除了第一个物体外，还测试了另一个物体。在之前的 方法后，将以下代码添加到类中：
- en: '[PRE40]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we are going to create a dynamic body and a static body to test collisions.
    Place the following in the `onPopulateScene()` method:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个动态物体和一个静态物体来测试碰撞。在`onPopulateScene()`方法中放置以下内容：
- en: '[PRE41]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we need to set the `ContactListener` property of the physics world. Add
    the following to the `onPopulateScene()` method:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置物理世界的`ContactListener`属性。在`onPopulateScene()`方法中添加以下内容：
- en: '[PRE42]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because the physics world may call the `ContactListener` interface multiple
    times per contact, we want to move all logic from the `ContactListener` interface
    to an update handler called once per engine update. Place the following in the
    `onPopulateScene()` method to complete our activity:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于物理世界可能会每次接触多次调用`ContactListener`接口，我们希望将所有逻辑从`ContactListener`接口移动到一个每次引擎更新只调用一次的更新处理程序中。在`onPopulateScene()`方法中放置以下内容，以完成我们的活动：
- en: '[PRE43]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we define the rectangles and bodies that we will be using to visualize
    collisions. We also define several Boolean variables that will be changed depending
    on the results of the `ContactListener` interface. The final variable is the fixture
    definition used to create the collision-enabled bodies.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了用于可视化碰撞的矩形和物体。我们还定义了几个布尔变量，这些变量将根据`ContactListener`接口的结果进行更改。最后的变量是用于创建具有碰撞功能的物体的固定装置定义。
- en: In steps two and three, we create two convenience methods, `isBodyContacted()`
    and `areBodiesContacted()`, that will make determining the presence of bodies
    in the `ContactListener` interface easier. Notice that the `if` statements in
    each of the methods check both of the fixtures against each body. Because of the
    way that the contact listener passes the `Contact` object, we cannot be certain
    which fixture will correlate with a certain body, so we must check both.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步和第三步中，我们创建了两个便捷方法`isBodyContacted()`和`areBodiesContacted()`，这将使在`ContactListener`接口中确定物体的存在变得更加容易。注意，每个方法中的`if`语句检查了每个物体与两个固定装置的碰撞情况。由于接触监听器传递`Contact`对象的方式，我们无法确定哪个固定装置将与特定物体相关联，因此我们必须检查两者。
- en: Step four creates the rectangles and bodies—one static and one dynamic—used
    in this simulation. We set the alpha of the rectangles using their `setAlpha()`
    method with a value of `0.5f` to demonstrate that contact is not currently occurring.
    The alpha of the rectangles is restored to opaque upon collision and set back
    to transparent after the collision has ended.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步创建了本模拟中使用的矩形和物体——一个静态的和一个动态的。我们使用它们的`setAlpha()`方法将矩形的透明度设置为`0.5f`，以演示当前没有发生接触。在碰撞时，矩形的透明度恢复为不透明，并在碰撞结束后重新设置为透明。
- en: In step five, we set the physics world's contact listener by overriding the
    inherited methods. The first method, `beginContact()`, is called when a collision
    has occurred within the physics world. In that method, we first test that the
    collision actually involves the touching of two bodies by checking the `isTouching()`
    property of the `contact` parameter. Box2D considers a collision to start whenever
    the **AABB**, or bounding box, of two bodies overlap, not when the actual bodies
    touch. Refer to the next diagram to see how collisions and touching differ. After
    that, we check to see if both, or just one, of our bodies are involved in the
    collision. If so, we set our full-alpha Boolean variables to `true`. The next
    method, `endContact()`, is called when bodies are no longer colliding. If our
    bodies are involved in the collision that is ending, we set the half-alpha Boolean
    variables to `true`. The remaining methods in the contact listener are called
    either before or after the collision-correcting calculations have occurred. Because
    we simply want to test which bodies have collided, we do not need to use those
    two methods.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们通过重写继承的方法来设置物理世界的接触监听器。第一个方法，`beginContact()`，在物理世界中发生碰撞时被调用。在这个方法中，我们首先通过检查`contact`参数的`isTouching()`属性来测试碰撞是否真正涉及到两个物体的接触。Box2D认为，当两个物体的**AABB**（边界框）重叠时，碰撞就开始了，而不是实际物体接触时。参考下一张图来了解碰撞和接触的区别。之后，我们会检查我们的物体是否都参与了碰撞，或者只有其中一个。如果是，我们将我们的完全不透明布尔变量设置为`true`。下一个方法，`endContact()`，在物体不再碰撞时被调用。如果我们的物体参与了正在结束的碰撞，我们会将半透明布尔变量设置为`true`。接触监听器中的其余方法在碰撞纠正计算发生之前或之后被调用。因为我们只想测试哪些物体发生了碰撞，所以不需要使用这两个方法。
- en: '![How it works...](img/8987OS_06_09.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_06_09.jpg)'
- en: In step six, we create an update handler to remove the effective code from the
    `ContactListener` interface. It simply checks the Boolean values set within the
    `ContactListener` interface to determine which actions need to be taken after
    every engine update. After the correct actions have been taken, we reset the Boolean
    variables. The reason that we need to remove effectual code from the contact listener
    is that the contact listener can, and often is, called multiple times per collision.
    If we were to change the score of a game from inside the contact listener, the
    score would often change at a much greater magnitude than we intended. We could
    have a variable that checks whether a contact has already been handled, but the
    flow of such code becomes messy and eventually counter productive.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六步中，我们创建了一个更新处理器，以从`ContactListener`接口中移除有效代码。它只是检查`ContactListener`接口内设置的布尔值，以确定在每次引擎更新后需要采取哪些操作。在采取了正确的操作后，我们重置布尔变量。我们需要从接触监听器中移除有效代码的原因是，接触监听器可能会被多次调用，而且通常在每次碰撞时都会被调用多次。如果在接触监听器内部改变游戏的得分，得分通常会比我们预期的变化大得多。我们可以有一个变量来检查是否已经处理了接触，但这样的代码流程会变得混乱，最终会适得其反。
- en: See also
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节的*Box2D物理扩展介绍*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节讲述*理解不同的身体类型*。
- en: Pre-solve and Post-solve in this chapter.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节介绍`preSolve`和`postSolve`。
- en: Using preSolve and postSolve
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`preSolve`和`postSolve`
- en: Making use of the available data for a collision inside the contact listener's
    `presolve` method, which is called before the Box2D iterator causes a reaction,
    allows us to have unique control over how our collisions occur. The `preSolve()`
    method is most commonly used to create “one-way” platforms that a character can
    jump through from below while still being able to walk on them from above. The
    `postSolve()` method, which is called after a reaction has been set in motion,
    gives us the corrective data, also known as the **impact force**, for the collision.
    This data can then be used to destroy or break apart objects. In this recipe,
    we will demonstrate how to properly use the `preSolve()` and `postSolve()` methods
    of a `ContactListener` interface.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在接触监听器的`presolve`方法中使用碰撞的可用数据，该方法在Box2D迭代器引起反应之前被调用，这让我们能独特地控制碰撞发生的方式。`preSolve()`方法通常用于创建角色可以从下面跳过但仍然可以从上面走过去的“单向”平台。在反应已经启动后被调用的`postSolve()`方法，为我们提供了碰撞的纠正数据，也称为**冲击力**。这些数据可以用来销毁或分解物体。在本教程中，我们将演示如何正确使用`ContactListener`接口的`preSolve()`和`postSolve()`方法。
- en: Getting ready...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Create a new activity by following the steps in the *Introduction to the Box2D
    physics extension* section given at the beginning of the chapter. This new activity
    will facilitate our use of the `preSolve()` and `postSolve()` methods called within
    the contact listener.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分提供的*Box2D物理扩展介绍*部分中的步骤创建一个新活动。这个新活动将方便我们使用接触监听器内调用的`preSolve()`和`postSolve()`方法。
- en: How to do it...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to complete the activity that demonstrates the use of these
    methods:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤完成演示这些方法使用的活动：
- en: 'Place the following definitions at the beginning of the activity:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动的开始处放置以下定义：
- en: '[PRE44]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To determine which body or bodies are contacted, insert these methods into
    the class:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确定哪个或哪些刚体被接触，将这些方法插入到类中：
- en: '[PRE45]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We are going to test the collisions between a small, dynamic body and a larger,
    static body. Place the following code in the `onPopulateScene()` method to create
    such bodies:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将测试一个小型动态刚体和一个大型静态刚体之间的碰撞。在`onPopulateScene()`方法中放置以下代码以创建这样的刚体：
- en: '[PRE46]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we need to set the contact listener for our physics world. Insert the
    following into the `onPopulateScene()` method:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为物理世界设置接触监听器。在`onPopulateScene()`方法中插入以下内容：
- en: '[PRE47]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We want to be able to move the smaller body by touching where we want it to
    move to. Add the following code to set up a mouse joint which will alow us to
    do so:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望可以通过触摸想要移动到的位置来移动较小的刚体。添加以下代码以设置一个鼠标关节，使我们能够这样做：
- en: '[PRE48]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, insert the following in the `onSceneTouchEvent()` method to control
    the mouse joint created in the previous step:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onSceneTouchEvent()`方法中插入以下内容，以控制上一步创建的鼠标关节：
- en: '[PRE49]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first define a static body, a dynamic body, and a fixture definition that
    will be used to create the two bodies. Then, we create two methods that make managing
    collisions using the contact listener much easier. Next, we create the bodies
    using their associated rectangles.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个静态刚体、一个动态刚体以及一个将用于创建这两个刚体的夹具定义。然后，我们创建两个使使用接触监听器管理碰撞变得更容易的方法。接下来，我们使用相关联的矩形创建刚体。
- en: '![How it works...](img/8987OS_06_10.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8987OS_06_10.jpg)'
- en: In step four, we set the physics world's contact listener. Notice that we create
    a variable, `maxImpulse`, at the beginning of the contact listener for use in
    the `postSolve()` method at the end of the contact listener. For this simulation
    we have no use for the `beginContact()` and `endContact()` methods so we leave
    them empty. In the `preSolve()` method, we first test to determine if the contact
    is between our two bodies, `dynamicBody` and `staticBody`. If it is, we test if
    the `dynamicBody` body is below our `staticBody` body by checking if the `dynamicBody.getWorldCenter().y`
    property is less than the `staticBody.getWorldCenter().y` property, and if so,
    we cancel the collision. This allows the dynamic body to pass through the static
    body from below while still colliding with the static body from above.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们设置了物理世界的接触监听器。注意，我们在接触监听器开始处创建了一个变量`maxImpulse`，以在接触监听器的末尾的`postSolve()`方法中使用。对于这个模拟，我们不需要`beginContact()`和`endContact()`方法，因此我们让它们保持为空。在`preSolve()`方法中，我们首先测试以确定接触是否发生在我们的两个身体之间，`dynamicBody`和`staticBody`。如果是，我们测试`dynamicBody`是否在我们的`staticBody`下方，通过检查`dynamicBody.getWorldCenter().y`属性是否小于`staticBody.getWorldCenter().y`属性，如果是，我们取消碰撞。这使得动态身体可以从下方穿过静态身体，同时仍然从上方与静态身体发生碰撞。
- en: In the `postSolve()` method, we test to ensure that we are only handling the
    dynamic and static bodies that we had defined previously. If so, we set the `maxImpulse`
    variable to the first impulse in the `impulse.getNormalImpulses()` array. This
    list holds the corrective impulses of all contacted points between the two colliding
    fixtures. Next, we step through the list of impulses and set the `maxImpulse`
    variable to either the current `maxImpulse` value or the current impulse value
    from the list, whichever is greater. This gives us the greatest corrective impulse
    in the collision, which we then use to spin the dynamic body if the impulsive
    force is great enough, an impulse of `400f` in this simulation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在`postSolve()`方法中，我们测试以确保只处理我们先前定义的动态和静态身体。如果是这样，我们将`maxImpulse`变量设置为`impulse.getNormalImpulses()`数组中的第一个冲量。这个列表保存了两个碰撞夹具之间所有接触点的纠正冲量。接下来，我们遍历冲量列表，并将`maxImpulse`变量设置为当前`maxImpulse`值或列表中的当前冲量值，以较大者为准。这为我们提供了碰撞中的最大纠正冲量，然后我们使用它来旋转动态身体，如果冲力足够大，在这个模拟中是`400f`的冲量。
- en: Step five initializes the mouse joint for dragging our dynamic body around the
    screen, and step six controls the mouse joint using the `onSceneTouchEvent()`
    method. Refer to *Working with joints* for more informaton on the mouse joint.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步初始化用于在屏幕上拖动动态身体的鼠标关节，第六步使用`onSceneTouchEvent()`方法控制鼠标关节。有关鼠标关节的更多信息，请参考*处理关节*。
- en: See also
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中介绍了*Box2D物理扩展入门*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中*了解不同的身体类型*。
- en: '*Working with joints* in this chapter.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中*处理关节*。
- en: '*Working with collisions* in this chapter.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节中*处理碰撞*。
- en: Creating destructible objects
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可破坏的物体
- en: Using the impulse data from the `postSolve()` method in the physics world's
    contact listener gives us a force of impact for each collision. Extending that
    data to cause a multiple-body object to break apart simply involves determining
    which body collided and if the force was great enough to break the body from the
    multiple-body object. In this recipe, we will demonstrate the creation of a destructible
    object made from bodies.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用物理世界接触监听器中的`postSolve()`方法提供的冲量数据，我们可以得到每次碰撞的冲击力。将这个数据扩展到使多体物体破碎，只需确定哪个身体发生碰撞，以及冲击力是否足够大以至于能将身体从多体物体中分离。在本教程中，我们将演示如何创建由多个身体组成的可破坏物体。
- en: Getting ready...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Create an activity by following the steps in the *Introduction to the Box2D
    physics extension* section at the beginning of the chapter. This activity will
    facilitate the creation of the destructible body groups that we will use in this
    section.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分*Box2D物理扩展入门*一节中的步骤创建一个活动。这个活动将促进我们在此节中使用的可破坏身体组的创建。
- en: How to do it...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a destructible object that breaks apart when it
    collides with a large force:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个在受到大力碰撞时可以破碎的物体：
- en: 'Add the following definitions to the activity class:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向活动类中添加以下定义：
- en: '[PRE50]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To determine which body is contacted easier, insert this method into the class:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更容易确定哪个身体被接触，请在类中插入此方法：
- en: '[PRE51]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We are going to create a physics object comprised of three boxes that are held
    together by weld joints. Define the following boxes in the `onPopulateScene()`
    method:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要创建一个由三个盒子组成的物理对象，这些盒子通过焊接关节保持在一起。在`onPopulateScene()`方法中定义以下盒子：
- en: '[PRE52]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, place the following weld joint definitions in the `onPopulateScene()`
    method after the box definitions defined in the previous step:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一步中定义的盒子定义之后，在`onPopulateScene()`方法中放置以下焊接关节定义：
- en: '[PRE53]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We now need to set our physics world''s contact listener. Add the following
    code to the `onPopulateScene()` method:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要设置物理世界的接触监听器。将以下代码添加到`onPopulateScene()`方法中：
- en: '[PRE54]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Lastly, to remove the logic from the contact listener, place the following
    update handler in the `onPopulateScene()` method:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了从接触监听器中移除逻辑，请在`onPopulateScene()`方法中放置以下更新处理程序：
- en: '[PRE55]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Step one initially defines three bodies that we will link together with weld
    joints. Next, we define three Boolean variables that represent which body, if
    any, should be released from the group of bodies. Then, we define three weld joints
    that hold our bodies together and their respective Boolean values that represent
    whether the joint exists. Finally, we define a fixture definition from which we
    will create our three box bodies.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步初步定义了三个我们将通过焊接关节连接在一起的身体。接下来，我们定义了三个布尔变量，表示如果有，哪个身体应该从身体组中释放。然后，我们定义了三个保持我们的身体在一起的焊接关节以及表示关节是否存在的相应布尔值。最后，我们定义了一个固定装置定义，我们将根据它创建三个盒状身体。
- en: Step two creates a method that allows us to determine if a particular body is
    involved in a collision, as also seen in the *Working with collisions* recipe.
    Step three creates our bodies, and step four creates the weld joints that attach
    them. Refer to the *Understanding different body types* recipe for more information
    about creating bodies, or the *Working with joints* recipe for more information
    on using joints.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步创建了一个方法，该方法允许我们确定一个特定的身体是否参与了碰撞，这与*处理碰撞*的教程中看到的内容类似。第三步创建我们的身体，第四步创建连接它们的焊接关节。有关创建身体的更多信息，请参考*理解不同的物体类型*的教程，或者有关使用关节的更多信息，请参考*使用关节*的教程。
- en: In step five, we set the physics world's contact listener, creating only the
    `maxImpulse` variable and filling only the `postSolve()` method. In the `postSolve()`
    method, we determine if the force of the collision impulse is great enough to
    break the joints connected to a body. If it is, we determine which of the bodies
    should be broken off from the group and set the associated Boolean value for that
    body. After the `ContactListener` interface is set, we register an update handler
    to destroy the appropriate joints according to which bodies are flagged to be
    broken off. Because each of the three bodies is connected to the other two bodies,
    there are two joints to destroy for each body in the group. As we destroy the
    joints, we flag each destroyed joint as inactive so that we do not attempt to
    destroy an already destroyed joint.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们设置了物理世界的接触监听器，只创建了`maxImpulse`变量，并只填充了`postSolve()`方法。在`postSolve()`方法中，我们确定碰撞冲量的力是否足以破坏与一个物体相连的关节。如果是，我们会确定应该从组中分离哪个物体，并为此物体设置相关的布尔值。设置`ContactListener`接口后，我们注册了一个更新处理程序，根据哪些物体被标记为需要分离来销毁相应的关节。由于三个物体中的每一个都与另外两个物体相连，因此对于组中的每个物体都有两个关节需要销毁。当我们销毁关节时，我们会将每个被销毁的关节标记为非活动状态，这样我们就不会尝试销毁已经销毁的关节。
- en: See also
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节介绍*Box2D物理扩展的入门*。
- en: '*Understanding different body types* in this chapter.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节讲解如何*理解不同的物体类型*。
- en: '*Working with joints* in this chapter.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节讲解如何*使用关节*。
- en: '*Using preSolve and postSolve* in this chapter.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章节介绍如何使用`preSolve`和`postSolve`。
- en: Raycasting
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光线投射
- en: '**Raycasting** via the physics world is a calculation that shoots an imaginary
    line from one point to another, and reports back with the distance, each encountered
    fixture, and the normal vector of each surface hit. Raycasts can be used for anything
    from lasers and vision cones to determining what an imaginary bullet hit. In this
    recipe, we will demonstrate raycasting within our physics world.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通过物理世界进行**光线投射**是一种从一个点向另一个点发射假想线，并返回距离、遇到的每个固定装置以及每个被撞击表面的法线向量的计算。光线投射可用于任何从激光和视野锥到确定一个假想子弹击中什么的一切。在本教程中，我们将演示如何在我们的物理世界中执行光线投射。
- en: Getting ready...
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Follow the steps in the *Introduction to the Box2D physics extension* section
    at the beginning of the chapter to create a new activity that will facilitate
    our use of raycasting in the physics world.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章开始部分*Box2D物理扩展介绍*中的步骤创建一个新活动，以便我们在物理世界中使用光线投射。
- en: How to do it...
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a raycasting demonstration:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个光线投射演示：
- en: 'Place the following definitions at the beginning of the activity:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动的开始处放置以下定义：
- en: '[PRE56]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we tell the physics world to perform a raycast, it will use a provided
    `callback` interface to allow us to make use of the information gathered by the
    raycast. Place the following `RayCastCallback` definition in the activity:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们告诉物理世界执行光线投射（raycast）时，它会使用一个提供的`callback`接口，让我们可以利用光线投射收集到的信息。在活动中放置以下`RayCastCallback`定义：
- en: '[PRE57]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To give our raycast something to impact, we will create a box in the physics
    world. Insert the following code snippet in the `onPopulateScene()` method:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让光线投射有撞击的对象，我们将在物理世界中创建一个盒子。在`onPopulateScene()`方法中插入以下代码片段：
- en: '[PRE58]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we will define the `Line` object that represents some of the information
    gathered from the raycast. Add the following to the `onPopulateScne()` method:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个`Line`对象，它表示从光线投射中收集到的一些信息。在`onPopulateScene()`方法中添加以下内容：
- en: '[PRE59]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Lastly, we want the raycast to occur wherever we touch the scene. Place the
    following in the `onSceneTouchEvent()` method:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望光线投射在触摸场景的任何地方发生。在`onSceneTouchEvent()`方法中放置以下内容：
- en: '[PRE60]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We first define a body, `BoxBody`, against which we will use the raycast. Then,
    we define several lines that will visually represent the raycast. Lastly, we define
    a series of variables that help us to determine the positioning and results of
    the raycast.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个刚体`BoxBody`，我们将使用光线投射与之交互。然后，我们定义了几条视觉上表示光线投射的线条。最后，我们定义了一系列变量，帮助我们确定光线投射的位置和结果。
- en: 'In step two, we define a `RayCastCallback` interface, which we will pass to
    the physics world whenever we request it to calculate a raycast. In the callback,
    we use the overridden `reportRayFixture()` method. This method is called every
    time that a requested raycast encounters a new fixture. In the method, we use
    the raycast-returned point and normal variables to modify the position of our
    line that represents the normal line of the reported fixture''s hit surface. After
    setting the normal line to be visible, we determine the normal angle and then
    the bounce angle. We then position the bounce line to represent the bounce of
    the raycast and set the bounce line to be visible. Finally, we return `0` for
    the method to tell the raycast to terminate after hitting the first fixture. For
    a better understanding of the various parameters returned in a raycast callback,
    consider the following diagram:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们定义了一个`RayCastCallback`接口，当我们请求物理世界计算光线投射时，将传递这个接口。在回调中，我们使用重写的`reportRayFixture()`方法。每次请求的光线投射遇到新的固定装置时，都会调用这个方法。在方法中，我们使用光线投射返回的点和平面变量来修改表示报告固定装置撞击表面的法线位置。设置法线可见后，我们确定法线角度，然后是反弹角度。接着我们定位反弹线以表示光线投射的反弹，并设置反弹线可见。最后，我们返回`0`，告诉光线投射在撞击第一个固定装置后终止。为了更好地理解光线投射回调中返回的各种参数，请参考以下图表：
- en: '![How it works...](img/8987OS_06_11.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8987OS_06_11.jpg)'
- en: Step three creates the body defined in step one and sets it to have a semi-random
    rotation by calling the `BoxBody.setTransform()` method with the last parameter
    of `MathUtils.random(0.349f, 1.222f)`, which orients the body to a rotation between
    `0.349` radians and `1.222` radians. Step four creates the visual lines that represent
    the various parts of the raycast. For more information on creating bodies, see
    the *Understanding different body types* recipe in this chapter, and for more
    information on lines, see [Chapter 2](ch02.html "Chapter 2. Working with Entities"),
    *Working with Entities*.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步创建了第一步中定义的刚体，并通过调用`BoxBody.setTransform()`方法设置了半随机的旋转，最后一个参数为`MathUtils.random(0.349f,
    1.222f)`，这使得刚体的旋转在`0.349`弧度和`1.222`弧度之间。第四步创建了表示光线投射各个部分的视觉线条。关于创建刚体的更多信息，请参阅本章中的*了解不同的刚体类型*菜谱；关于线条的更多信息，请参阅[第2章](ch02.html
    "第2章. 使用实体")，*使用实体*。
- en: In step five, we assign the `onSceneTouchEvent()` method to handle our raycasting.
    When a touch occurs, we first set the `RayCastAngle` variable for use in the raycast's
    callback. Then, we position the main raycast line and set it to be visible while
    also setting the other lines associated with the raycast to be invisible. Lastly,
    we request a raycast from the physics world by passing our callback, the start
    position of the raycast, and the end position of the raycast. When the touch event
    has ended, we set the main raycast line to be invisible.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步中，我们将`onSceneTouchEvent()`方法分配给处理射线投射（raycasting）。当触摸发生时，我们首先设置`RayCastAngle`变量以供射线投射的回调函数使用。然后，我们定位主射线线，并将其设置为可见，同时将与其他射线相关的线设置为不可见。最后，我们通过传递我们的回调函数、射线投射的起始位置和结束位置，从物理世界中请求射线投射。当触摸事件结束时，我们将主射线线设置为不可见。
- en: See also
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅。
- en: '*Introduction to the Box2D physics extension* in this chapter.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章介绍*Box2D物理扩展*。
