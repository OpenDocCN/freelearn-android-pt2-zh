- en: Chapter 2. Understanding Testing with the Android SDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 理解使用Android SDK进行测试
- en: We now know how to create tests inside an Android project and how to run these
    tests. It is now time to start digging a bit deeper to recognize the building
    blocks available to create more useful tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何在Android项目中创建测试以及如何运行这些测试。现在是时候更深入地挖掘，以识别可用于创建更有用的测试的构建块。
- en: 'In this second chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Common assertions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见断言
- en: View assertions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图断言
- en: Other assertion types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他断言类型
- en: Helpers to test User Interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试用户界面的辅助工具
- en: Mock objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象
- en: Instrumentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测
- en: TestCase class hierarchies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestCase`类层次结构'
- en: Using external libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部库
- en: We will be analyzing these components and showing examples of their use when
    applicable. The examples in this chapter are intentionally split from the original
    Android project that contains them. This is done to let you concentrate and focus
    only on the subject being presented, though the complete examples in a single
    project can be downloaded as explained later. Right now, we are interested in
    the trees and not the forest.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析这些组件，并在适用的情况下展示它们的使用示例。本章中的示例故意从包含它们的原始Android项目中分离出来。这样做是为了让您集中精力只关注所呈现的主题，尽管可以按照后面的说明下载包含在一个项目中的完整示例。现在，我们关注的是树木，而不是森林。
- en: Along with the examples presented, we will be identifying reusable common patterns
    that will help you in the creation of tests for your own projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在呈现的示例中，我们将识别可重用的常见模式，这将帮助您为自己的项目创建测试。
- en: The demonstration application
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示应用程序
- en: A very simple application has been created to demonstrate the use of some of
    the tests in this chapter. The source for the application can be downloaded from
    XXXXXXXXXXXXX.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了一个非常简单的应用程序，以演示本章中一些测试的使用。该应用程序的源代码可以从XXXXXXXXXXXX下载。
- en: 'The following screenshot shows this application running:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图展示了这个应用程序的运行情况：
- en: '![The demonstration application](img/00013.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![演示应用程序](img/00013.jpeg)'
- en: When reading the explanation of the tests in this chapter, at any point, you
    can refer to the demo application that is provided in order to see the test in
    action. The previous simple application has a clickable link, text input, click
    on a button and a defined layout UI, we can test these one by one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章中的测试解释时，您可以随时参考提供的演示应用程序，以查看测试的实际效果。前面的简单应用程序有一个可点击的链接、文本输入、点击按钮和定义的布局UI，我们可以逐一测试这些。
- en: Assertions in depth
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言深入理解
- en: Assertions are methods that check for a condition that can be evaluated. If
    the condition is not met, the assertion method will throw an exception, thereby
    aborting the execution of the test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是检查可以评估的条件的方法。如果条件不满足，断言方法将抛出异常，从而终止测试的执行。
- en: 'The JUnit API includes the class `Assert`. This is the base class of all the
    `TestCase` classes that hold several assertion methods useful for writing tests.
    These inherited methods test for a variety of conditions and are overloaded to
    support different parameter types. They can be grouped together in the following
    different sets, depending on the condition checked, for example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit API 包含了`Assert`类。这是所有`TestCase`类的基类，其中包含多种用于编写测试的断言方法。这些继承的方法用于测试各种条件，并且为了支持不同的参数类型而被重载。根据检查的条件，它们可以分为以下不同的组，例如：
- en: assertEquals
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals`'
- en: assertTrue
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue`'
- en: assertFalse
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse`'
- en: assertNull
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull`'
- en: assertNotNull
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotNull`'
- en: assertSame
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSame`'
- en: assertNotSame
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotSame`'
- en: fail
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail`'
- en: The condition tested is pretty obvious and is easily identifiable by the method
    name. Perhaps the ones that deserve some attention are `assertEquals()` and `assertSame()`.
    The former, when used on objects, asserts that both objects passed as parameters
    are equally calling the objects' `equals()` method. The latter asserts that both
    objects refer to the same object. If, in some case, `equals()` is not implemented
    by the class, then `assertEquals()` and `assertSame()` will do the same thing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的条件非常明显，通过方法名称可以轻松识别。可能需要关注的是`assertEquals()`和`assertSame()`。前者在对象上使用时，断言传递的参数对象通过调用对象的`equals()`方法是相等的。后者断言两个对象引用同一个对象。如果某些情况下，类没有实现`equals()`，那么`assertEquals()`和`assertSame()`将执行相同的操作。
- en: When one of these assertions fails inside a test, an `AssertionFailedException`
    is thrown, and this indicates that the test has failed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试中的一个断言失败时，将抛出`AssertionFailedException`，这表示测试已经失败。
- en: 'Occasionally, during the development process, you might need to create a test
    that you are not implementing at that precise time. However, you want to flag
    that the creation of the test was postponed (we did this in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with Testing"), *Getting Started with Testing*, when
    we added just the test method stubs). In such cases, you can use the `fail()`
    method, which always fails and uses a custom message that indicates the condition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，有时您可能需要创建一个当时并未实现的测试。但是，您希望标记该测试的创建已推迟（我们在[第1章](part0014_split_000.html#page
    "Chapter 1. Getting Started with Testing")，*开始测试*中添加了测试方法存根）。在这种情况下，您可以使用总是失败并使用自定义消息指明条件的`fail()`方法：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Still, there is another common use for `fail()` that is worth mentioning. If
    we need to test whether a method throws an exception, we can surround the code
    with a try-catch block and force a fail if the exception was not thrown. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`fail()`还有另一个常见的用途值得一提。如果我们需要测试一个方法是否抛出异常，我们可以用try-catch块包围代码，并在没有抛出异常时强制失败。例如：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JUnit4 has the annotation `@Test(expected=Exception.class)`, and this supersedes
    the need for using `fail()` when testing exceptions. With this annotation, the
    test will only pass if the expected exception is thrown.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit4有一个注解`@Test(expected=Exception.class)`，这取代了在测试异常时使用`fail()`的需要。使用这个注解，只有当预期的异常被抛出时，测试才会通过。
- en: Custom messages
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义消息
- en: It is worth knowing that all `assert` methods provide an overloaded version
    including a custom `String` message. Should the assertion fail, this custom message
    will be printed by the test runner, instead of a default message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值得知道的是，所有的`assert`方法都提供了一个包含自定义`String`消息的重载版本。如果断言失败，测试运行器将打印这个自定义消息，而不是默认消息。
- en: The premise behind this is that, sometimes, the generic error message does not
    reveal enough details, and it is not obvious how the test failed. This custom
    message can be extremely useful to easily identify the failure once you are looking
    at the test report, so it's highly recommended as a best practice to use this
    version.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的前提是，有时，通用错误消息没有透露足够的信息，而且测试失败的原因并不明显。自定义消息在查看测试报告时可以极大地帮助轻松识别失败，因此强烈建议作为最佳实践使用这个版本。
- en: 'The following is an example of a simple test that uses this recommendation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用此建议的简单测试示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we can see another practice that would help you organize
    and understand your tests easily. This is the use of explicit names for variables
    that hold the actual values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到另一个实践，这将帮助您轻松组织和理解测试。这就是为保存实际值的变量使用明确的名称。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other libraries available that have better default error messages
    and also a more fluid interface for testing. One of these that is worth looking
    at is Fest ([https://code.google.com/p/fest/](https://code.google.com/p/fest/)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些库提供了更好的默认错误消息以及更流畅的测试界面。其中一个值得一看的是Fest（[https://code.google.com/p/fest/](https://code.google.com/p/fest/)）。
- en: Static imports
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态导入
- en: 'Though basic assertion methods are inherited from the Assert base class, some
    other assertions need specific imports. To improve the readability of your tests,
    there is a pattern to statically import the assert methods from the corresponding
    classes. Using this pattern instead of having:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基本的断言方法是从Assert基类继承而来的，但某些其他断言需要特定的导入。为了提高测试的可读性，有一个模式是从相应类静态导入断言方法。使用这种模式，而不是：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can simplify it by adding the static import:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加静态导入来简化它：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: View assertions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图断言
- en: The assertions introduced earlier handle a variety of types as parameters, but
    they are only intended to test simple conditions or simple objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前引入的断言处理了各种类型的参数，但它们仅用于测试简单条件或简单对象。
- en: For example, we have `asertEquals(short expected, short actual)` to test `short`
    values, `assertEquals(int expected, int actual)` to test integer values, `assertEquals(Object
    expected, Object expected)` to test any `Object` instance, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有`assertEquals(short expected, short actual)`来测试`short`值，`assertEquals(int
    expected, int actual)`来测试整数值，`assertEquals(Object expected, Object actual)`来测试任何`Object`实例等。
- en: Usually, while testing user interfaces in Android, you will face the problem
    of more sophisticated methods, which are mainly related with Views. In this respect,
    Android provides a class with plenty of assertions in `android.test.ViewAsserts`
    (see [http://developer.android.com/reference/android/test/ViewAsserts.html](http://developer.android.com/reference/android/test/ViewAsserts.html)
    for more details), which test relationships between Views and their absolute and
    relative positions on the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Android中测试用户界面时，你会遇到更复杂的方法，这些方法主要与视图有关。在这方面，Android提供了一个包含大量断言的类`android.test.ViewAsserts`（更多详情请见[http://developer.android.com/reference/android/test/ViewAsserts.html](http://developer.android.com/reference/android/test/ViewAsserts.html)），用于测试视图之间以及它们在屏幕上的绝对和相对位置关系。
- en: 'These methods are also overloaded to provide different conditions. Among the
    assertions, we can find the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也提供了重载以提供不同的条件。在断言中，我们可以找到以下内容：
- en: '`assertBaselineAligned`: This asserts that two Views are aligned on their baseline;
    that is, their baselines are on the same y location.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertBaselineAligned`：此断言用于判断两个视图是否基于基线对齐，即它们的基线是否在同一y位置。'
- en: '`assertBottomAligned`: This asserts that two views are bottom aligned; that
    is, their bottom edges are on the same y location.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertBottomAligned`：此断言用于判断两个视图是否底部对齐，即它们的底部边缘是否在同一y位置。'
- en: '`assertGroupContains`: This asserts that the specified group contains a specific
    child once and only once.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGroupContains`：此断言用于判断指定组是否包含一个特定的子视图，且仅包含一次。'
- en: '`assertGroupIntegrity`: This asserts the specified group''s integrity. The
    child count should be >= 0 and each child should be non-null.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGroupIntegrity`：此断言用于判断指定组的完整性。子视图数量应大于等于0，每个子视图都不应为空。'
- en: '`assertGroupNotContains`: This asserts that the specified group does not contain
    a specific child.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGroupNotContains`：此断言用于判断指定组不包含特定的子视图。'
- en: '`assertHasScreenCoordinates`: This asserts that a View has a particular x and
    y position on the visible screen.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertHasScreenCoordinates`：此断言用于判断一个视图在可见屏幕上是否有特定的x和y位置。'
- en: '`assertHorizontalCenterAligned`: This asserts that the test View is horizontally
    center aligned with respect to the reference view.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertHorizontalCenterAligned`：此断言用于判断测试视图相对于参考视图是否水平居中对齐。'
- en: '`assertLeftAligned`: This asserts that two Views are left aligned; that is,
    their left edges are on the same x location. An optional margin can also be provided.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertLeftAligned`：此断言用于判断两个视图是否左对齐，即它们的左侧边缘是否在同一x位置。也可以提供一个可选的边距。'
- en: '`assertOffScreenAbove`: This asserts that the specified view is above the visible
    screen.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertOffScreenAbove`：此断言用于判断指定视图是否位于可见屏幕上方。'
- en: '`assertOffScreenBelow`: This asserts that the specified view is below the visible
    screen.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertOffScreenBelow`：此断言用于判断指定视图是否位于可见屏幕下方。'
- en: '`assertOnScreen`: This asserts that a View is on the screen.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertOnScreen`：此断言用于判断一个视图是否在屏幕上。'
- en: '`assertRightAligned`: This asserts that two Views are right-aligned; that is,
    their right edges are on the same x location. An optional margin can also be specified.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRightAligned`：此断言用于判断两个视图是否右对齐，即它们的右侧边缘是否在同一x位置。也可以指定一个可选的边距。'
- en: '`assertTopAligned`: This asserts that two Views are top aligned; that is, their
    top edges are on the same y location. An optional margin can also be specified.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTopAligned`：此断言用于判断两个视图是否顶部对齐，即它们的顶部边缘是否在同一y位置。也可以指定一个可选的边距。'
- en: '`assertVerticalCenterAligned`: This asserts that the test View is vertically
    center-aligned with respect to the reference View.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertVerticalCenterAligned`：此断言用于判断测试视图相对于参考视图是否垂直居中对齐。'
- en: 'The following example shows how you can use `ViewAssertions` to test the user
    interface layout:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何使用`ViewAssertions`来测试用户界面布局：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `assertOnScreen` method uses an origin to start looking for the requested
    Views. In this case, we are using the top-level window decor View. If, for some
    reason, you don't need to go that high in the hierarchy, or if this approach is
    not suitable for your test, you may use another root View in the hierarchy, for
    example `View.getRootView()`, which, in our concrete example, would be `editText.getRootView()`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertOnScreen`方法使用一个原点来查找请求的视图。在这种情况下，我们使用顶层窗口装饰视图。如果由于某些原因，你不需要在层次结构中那么高，或者这种方法不适用于你的测试，你可以在层次结构中使用另一个根视图，例如`View.getRootView()`，在我们的具体示例中，将是`editText.getRootView()`。'
- en: Even more assertions
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的断言
- en: If the assertions that are reviewed previously do not seem to be enough for
    your tests' needs, there is still another class included in the Android framework
    that covers other cases. This class is `MoreAsserts` ([http://developer.android.com/reference/android/test/MoreAsserts.html](http://developer.android.com/reference/android/test/MoreAsserts.html)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前审查的断言似乎不足以满足您的测试需求，Android框架中仍然包含另一个类，涵盖了其他情况。这个类是`MoreAsserts`（[http://developer.android.com/reference/android/test/MoreAsserts.html](http://developer.android.com/reference/android/test/MoreAsserts.html)）。
- en: 'These methods are also overloaded to support different parameter types. Among
    the assertions, we can find the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也支持不同的参数类型重载。在断言中，我们可以找到以下几种：
- en: '`assertAssignableFrom`: This asserts that an object is assignable to a class.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertAssignableFrom`：此断言一个对象可以分配给一个类。'
- en: '`assertContainsRegex`: This asserts that an expected Regex matches any substring
    of the specified `String`. It fails with the specified message if it does not.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContainsRegex`：此断言预期的Regex匹配指定`String`的任何子字符串。如果不符合则使用指定的消息失败。'
- en: '`assertContainsInAnyOrder`: This asserts that the specified `Iterable` contains
    precisely the elements expected, but in any order.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContainsInAnyOrder`：此断言指定的`Iterable`包含精确预期的元素，但顺序不限。'
- en: '`assertContainsInOrder`: This asserts that the specified `Iterable` contains
    precisely the elements expected, but in the same order.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContainsInOrder`：此断言指定的`Iterable`包含精确预期的元素，并且顺序相同。'
- en: '`assertEmpty`: This asserts that an `Iterable` is empty.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEmpty`：此断言一个`Iterable`是空的。'
- en: '`assertEquals`: This is for some `Collections` not covered in JUnit asserts.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals`：这是针对一些JUnit断言中未涉及的`Collections`。'
- en: '`assertMatchesRegex`: This asserts that the specified `Regex` exactly matches
    the `String` and fails with the provided message if it does not.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertMatchesRegex`：此断言指定的`Regex`必须完全匹配`String`，如果不匹配则提供消息失败。'
- en: '`assertNotContainsRegex`: This asserts that the specified Regex does not match
    any substring of the specified String, and fails with the provided message if
    it does.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotContainsRegex`：此断言指定的Regex不匹配指定String的任何子字符串，如果不匹配则提供消息失败。'
- en: '`assertNotEmpty`: This asserts that some Collections not covered in JUnit asserts
    are not empty.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotEmpty`：此断言一些在JUnit断言中未涉及的集合不是空的。'
- en: '`assertNotMatchesRegex`: This asserts that the specified `Regex` does not exactly
    match the specified String, and fails with the provided message if it does.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotMatchesRegex`：此断言指定的`Regex`不精确匹配指定的String，如果匹配则提供消息失败。'
- en: '`checkEqualsAndHashCodeMethods`: This is a utility used to test the `equals()`
    and `hashCode()` results at once. This tests whether `equals()` that is applied
    to both objects matches the specified result.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkEqualsAndHashCodeMethods`：这是一个用于一次性测试`equals()`和`hashCode()`结果的工具。这测试应用在两个对象上的`equals()`是否与指定结果匹配。'
- en: 'The following test checks for an error during the invocation of the capitalization
    method called via a click on the UI button:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试检查通过点击UI按钮调用的首字母大写方法在调用过程中是否出现错误：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are not familiar with regular expressions, invest some time and visit
    [http://developer.android.com/reference/java/util/regex/package-summary.html](http://developer.android.com/reference/java/util/regex/package-summary.html)
    because it will be worth it!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉正则表达式，花些时间访问[http://developer.android.com/reference/java/util/regex/package-summary.html](http://developer.android.com/reference/java/util/regex/package-summary.html)，这是值得的！
- en: In this particular case, we are looking for the word `ERROR` contained in the
    result with a case-insensitive match (setting the flag `i` for this purpose).
    That is, if for some reason, capitalization doesn't work in our application, and
    it contains an error message, we can detect this condition with the assertion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，我们希望以不区分大小写的方式（为此设置标志`i`）匹配结果中包含的单词`ERROR`。也就是说，如果由于某种原因，在我们的应用程序中大小写不起作用，并且包含错误消息，我们可以使用这个断言检测这种情况。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that because this is a test that modifies the user interface, we must
    annotate it with `@UiThreadTest`; otherwise, it won''t be able to alter the UI
    from a different thread, and we will receive the following exception:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于这是一个修改用户界面的测试，我们必须使用`@UiThreadTest`进行注解；否则，它将无法从不同的线程修改UI，并且我们会收到以下异常：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The TouchUtils class
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TouchUtils类
- en: Sometimes, when testing UIs, it is helpful to simulate different kinds of touch
    events. These touch events can be generated in many different ways, but probably
    `android.test.TouchUtils` is the simplest to use. This class provides reusable
    methods to generate touch events in test cases that are derived from `InstrumentationTestCase`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在测试UI时，模拟不同类型的触摸事件会很有帮助。这些触摸事件可以通过多种方式生成，但可能使用`android.test.TouchUtils`是最简单的。这个类提供了可重用的方法，在从`InstrumentationTestCase`派生的测试用例中生成触摸事件。
- en: The featured methods allow a simulated interaction with the UI under test. The
    `TouchUtils` class provides the infrastructure to inject the events using the
    correct UI or main thread, so no special handling is needed, and you don't need
    to annotate the test using `@UIThreadTest`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性方法允许与被测UI进行模拟交互。`TouchUtils`类提供了基础设施，以使用正确的UI或主线程注入事件，因此无需特殊处理，你也不需要在测试中使用`@UIThreadTest`注解。
- en: 'TouchUtils supports the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TouchUtils支持以下操作：
- en: Clicking on a View and releasing it
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击一个视图并释放
- en: Tapping on a View (touching it and quickly releasing)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻敲一个视图（触摸它并快速释放）
- en: Long-clicking on a View
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长点击一个视图
- en: Dragging the screen
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动屏幕
- en: Dragging Views
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动视图
- en: 'The following test represents a typical usage of `TouchUtils`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试代表了`TouchUtils`的典型使用方法：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This test does the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试执行以下操作：
- en: Repositions the list at the beginning to start from a known condition
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表重新定位到开始位置，以便从已知条件开始
- en: Scrolls the list
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动列表
- en: Checks for the first visible position to see that it was correctly scrolled
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查第一个可见位置，以确认它是否正确滚动
- en: Even the most complex UIs can be tested in that way, and it would help you detect
    a variety of conditions that could potentially affect the user experience.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最复杂的UI也可以通过这种方式进行测试，它可以帮助你检测可能影响用户体验的各种条件。
- en: Mock objects
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象
- en: We have seen the mock objects provided by the Android testing framework in [Chapter
    1](part0014_split_000.html#page "Chapter 1. Getting Started with Testing"), *Getting
    Started with Testing*, and evaluated the concerns about not using real objects
    to isolate our tests from the surrounding environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0014_split_000.html#page "Chapter 1. Getting Started with Testing")《开始测试》中看到了Android测试框架提供的模拟对象，并评估了关于不使用真实对象将我们的测试与周围环境隔离开来的担忧。
- en: The next chapter deals with Test-driven Development, and if we were Test-driven
    Development purists, we can argue about the use of mock objects and be more inclined
    to use real ones. Martin Fowler calls these two styles the *classical* and *mockist*
    Test-driven Development dichotomy in his great article *Mocks aren't stubs*, which
    can be read online at [http://www.martinfowler.com/articles/mocksArentStubs.html](http://www.martinfowler.com/articles/mocksArentStubs.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍测试驱动开发（Test-driven Development），如果我们是测试驱动开发的纯粹主义者，我们可以讨论使用模拟对象的问题，更倾向于使用真实对象。Martin
    Fowler在他的精彩文章《Mocks aren't stubs》中称这两种风格为经典的和模拟的测试驱动开发二分法，该文章可以在[http://www.martinfowler.com/articles/mocksArentStubs.html](http://www.martinfowler.com/articles/mocksArentStubs.html)在线阅读。
- en: Independent of this discussion, we are introducing mock objects as one of the
    available building blocks because, sometimes, using mock objects in our tests
    is recommended, desirable, useful, or even unavoidable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于这场讨论，我们将介绍模拟对象作为可用的构建块之一，因为有时在测试中使用模拟对象是推荐、可取、有用甚至不可避免的。
- en: 'The Android SDK provides the following classes in the subpackage `android.test.mock`
    to help us:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK在子包`android.test.mock`中提供了以下类以帮助我们：
- en: '`MockApplication`: This is a mock implementation of the `Application` class.
    All methods are non-functional and throw `UnsupportedOperationException`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockApplication`：这是`Application`类的模拟实现。所有方法均不具备功能，并抛出`UnsupportedOperationException`。'
- en: '`MockContentProvider`: This is a mock implementation of `ContentProvider`.
    All methods are non-functional and throw `UnsupportedOperationException`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContentProvider`：这是`ContentProvider`的模拟实现。所有方法均不具备功能，并抛出`UnsupportedOperationException`。'
- en: '`MockContentResolver`: This is a mock implementation of the `ContentResolver`
    class that isolates the test code from the real content system. All methods are
    non-functional and throw `UnsupportedOperationException`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContentResolver`：这是`ContentResolver`类的模拟实现，它将测试代码与真实内容系统隔离开来。所有方法均不具备功能，并抛出`UnsupportedOperationException`。'
- en: '`MockContext`: This is a mock context class, and this can be used to inject
    other dependencies. All methods are non-functional and throw `UnsupportedOperationException`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContext`：这是一个模拟上下文类，可以用来注入其他依赖项。所有方法均不具备功能，并抛出`UnsupportedOperationException`。'
- en: '`MockCursor`: This is a mock Cursor class that isolates the test code from
    real Cursor implementation. All methods are non-functional and throw `UnsupportedOperationException`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockCursor`：这是一个模拟的游标类，它将测试代码与实际的游标实现隔离开来。所有方法都是非功能性的，当使用时会抛出`UnsupportedOperationException`。'
- en: '`MockDialogInterface`: This is a mock implementation of the `DialogInterface`
    class. All methods are non-functional and throw `UnsupportedOperationException`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockDialogInterface`：这是`DialogInterface`类的模拟实现。所有方法都是非功能性的，当使用时会抛出`UnsupportedOperationException`。'
- en: '`MockPackageManager`: This is a mock implementation of the `PackageManager`
    class. All methods are non-functional and throw `UnsupportedOperationException`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockPackageManager`：这是`PackageManager`类的模拟实现。所有方法都是非功能性的，当使用时会抛出`UnsupportedOperationException`。'
- en: '`MockResources`: This is a mock `Resources` class.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockResources`：这是一个模拟的`Resources`类。'
- en: All of these classes have non-functional methods that throw `UnsupportedOperationException`
    when used. If you need to use some of these methods, or if you detect that your
    test is failing with this `Exception`, you should extend one of these base classes
    and provide the required functionality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类都具有非功能性的方法，当使用时将抛出`UnsupportedOperationException`。如果你需要使用其中一些方法，或者你发现你的测试因这个`Exception`而失败，你应该扩展这些基类之一并提供所需的功能。
- en: An overview of MockContext
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MockContext概述
- en: This mock can be used to inject other dependencies, mocks, or monitors into
    the classes under test. Extend this class to provide your desired behavior, overriding
    the correspondent methods. The Android SDK provides some prebuilt mock `Context`
    objects, each of which has a separate use case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟可以用来将其他依赖项、模拟或监视器注入到被测试的类中。扩展这个类以提供你想要的行为，覆盖相应的方法。Android SDK提供了一些预构建的模拟`Context`对象，每个对象都有单独的使用场景。
- en: The IsolatedContext class
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IsolatedContext类
- en: In your tests, you might find the need to isolate the Activity under test from
    other Android components to prevent unwanted interactions. This can be a complete
    isolation, but sometimes, this isolation avoids interacting with other components,
    and for your Activity to still run correctly, some connection with the system
    is required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中，你可能会发现需要将正在测试的Activity与其他Android组件隔离开来，以防止不必要的交互。这可以是完全隔离，但有时，这种隔离避免了与其他组件的交互，为了让你的Activity仍然正确运行，需要与系统建立一些联系。
- en: For those cases, the Android SDK provides `android.test.IsolatedContext`, a
    mock `Context` that not only prevents interaction with most of the underlying
    system but also satisfies the needs of interacting with other packages or components
    such as `Services` or `ContentProviders`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，Android SDK提供了`android.test.IsolatedContext`，这是一个模拟的`Context`，它不仅阻止了与大部分底层系统的交互，还满足了与其他包或组件（如`Services`或`ContentProviders`）交互的需求。
- en: Alternate route to file and database operations
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和数据库操作的替代路径
- en: In some cases, all we need is to be able to provide an alternate route to the
    file and database operations. For example, if we are testing the application on
    a real device, we perhaps don't want to affect the existing database but use our
    own testing data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们只需要能够为文件和数据库操作提供一条替代路径。例如，如果我们正在实际设备上测试应用程序，我们可能不希望影响现有的数据库，而是使用我们自己的测试数据。
- en: Such cases can take advantage of another class that is not part of the `android.test.mock`
    subpackage but is part of `android.test` instead, that is, `RenamingDelegatingContext`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况可以利用另一个不属于`android.test.mock`子包，而是属于`android.test`的类，即`RenamingDelegatingContext`。
- en: This class lets us alter operations on files and databases by having a prefix
    that is specified in the constructor. All other operations are delegated to the
    delegating Context that you must specify in the constructor too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许我们通过在构造函数中指定的前缀来修改对文件和数据库的操作。所有其他操作都被委托给必须在构造函数中指定的委托上下文。
- en: Suppose our `Activity` under test uses a database we want to control, probably
    introducing specialized content or fixture data to drive our tests, and we don't
    want to use the real files. In this case, we create a `RenamingDelegatingContext`
    class that specifies a prefix, and our unchanged Activity will use this prefix
    to create any files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在测试的`Activity`使用了一个我们想要控制的数据库，可能引入特殊内容或固定数据来驱动我们的测试，我们不想使用真实的文件。在这种情况下，我们创建一个`RenamingDelegatingContext`类，它指定了一个前缀，我们的未更改的Activity将使用这个前缀来创建任何文件。
- en: For example, if our Activity tries to access a file named `birthdays.txt`, and
    we provide a `RenamingDelegatingContext` class that specifies the prefix `test`,
    then this same Activity will access the file `testbirthdays.txt` instead when
    it is being tested.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的Activity尝试访问一个名为`birthdays.txt`的文件，而我们提供了一个指定前缀`test`的`RenamingDelegatingContext`类，那么在测试时，这个相同的Activity将改为访问文件`testbirthdays.txt`。
- en: The MockContentResolver class
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MockContentResolver类
- en: The `MockContentResolver` class implements all methods in a non-functional way
    and throws the exception `UnsupportedOperationException` if you attempt to use
    them. The reason for this class is to isolate tests from the real content.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockContentResolver`类以非功能方式实现所有方法，如果你尝试使用它们，它会抛出`UnsupportedOperationException`异常。这个类的目的是将测试与真实内容隔离开来。'
- en: Let's say your application uses a `ContentProvider` class to feed your Activity
    information. You can create unit tests for this `ContentProvider` using `ProviderTestCase2`,
    which we will be analyzing shortly, but when we try to produce functional or integration
    tests for the Activity against `ContentProvider`, it's not so evident as to what
    test case to use. The most obvious choice is `ActivityInstrumentationTestCase2`,
    mainly if your functional tests simulate user experience because you might need
    the `sendKeys()` method or similar methods, which are readily available on these
    tests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序使用一个`ContentProvider`类来为你的Activity提供信息。你可以使用`ProviderTestCase2`为这个`ContentProvider`创建单元测试，我们稍后会进行分析，但是当我们尝试为Activity针对`ContentProvider`编写功能测试或集成测试时，就不太明显应该使用哪种测试用例。最明显的选择是`ActivityInstrumentationTestCase2`，尤其是如果你的功能测试模拟用户体验，因为你可能需要`sendKeys()`方法或类似的方法，而这些方法在这些测试中是可用的。
- en: The first problem you might encounter then is that it's unclear as to where
    to inject a `MockContentResolver` in your test to be able to use test data with
    your `ContentProvider`. There's no way to inject a `MockContext` either.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的第一个问题是，不清楚在哪里注入一个`MockContentResolver`以使你的测试能够使用`ContentProvider`的测试数据。也无法注入一个`MockContext`。
- en: This problem will be solved in [Chapter 3](part0037_split_000.html#page "Chapter 3. Baking
    with Testing Recipes"), *Baking with Testing Recipes* where further details are
    provided.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题将在[第三章](part0037_split_000.html#page "Chapter 3. Baking with Testing Recipes")，*使用测试配方烘焙*中得到解决，其中提供了更多细节。
- en: The TestCase base class
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestCase基类
- en: This is the base class of all other test cases in the JUnit framework. It implements
    the basic methods that we were analyzing in the previous examples (`setUp()`).
    The `TestCase` class also implements the `junit.framework.Test` interface, meaning
    it can be run as a JUnit test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JUnit框架所有其他测试用例的基类。它实现了我们之前分析的示例中的基本方法（`setUp()`）。`TestCase`类还实现了`junit.framework.Test`接口，这意味着它可以作为一个JUnit测试来运行。
- en: Your Android test cases should always extend `TestCase` or one of its descendants.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Android测试用例应该始终扩展`TestCase`或其子类。
- en: The default constructor
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: All test cases require a default constructor because, sometimes, depending on
    the test runner used, this is the only constructor that is invoked, and is also
    used for serialization.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试用例都需要一个默认构造函数，因为有时，根据使用的测试运行器，这是唯一被调用的构造函数，也用于序列化。
- en: According to the documentation, this method is not intended to be used by "mere
    mortals" without calling `setName(String name)`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，这个方法不打算被“凡人”在没有调用`setName(String name)`的情况下使用。
- en: 'Therefore, to appease the Gods, a common pattern is to use a default test case
    name in this constructor and invoke the `given name` constructor afterwards:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了取悦众神，通常在这个构造函数中使用一个默认的测试用例名称，并在之后调用给定的名称构造函数：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com](http://www.packtpub.com)的账户下载你所购买的Packt Publishing书籍的所有示例代码文件。如果你在其他地方购买了这本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)注册，文件会直接通过电子邮件发送给你。
- en: The given name constructor
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给定名称构造函数
- en: This constructor takes a name as an argument to label the test case. It will
    appear in test reports and would be of much help when you try to identify where
    failed tests have come from.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数接受一个名称作为参数来标记测试用例。它将出现在测试报告中，并在你尝试确定失败的测试来自哪里时非常有帮助。
- en: The setName() method
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`setName()`方法'
- en: There are some classes that extend `TestCase` that don't provide a given name
    constructor. In such cases, the only alternative is to call `setName(String name)`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有些扩展了`TestCase`的类没有提供给定名称的构造函数。在这种情况下，唯一的选择是调用`setName(String name)`。
- en: The AndroidTestCase base class
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AndroidTestCase`基类'
- en: This class can be used as a base class for general-purpose Android test cases.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以用作通用Android测试用例的基类。
- en: Use it when you need access to Android resources, databases, or files in the
    filesystem. Context is stored as a field in this class, which is conveniently
    named `mContext` and can be used inside the tests if needed, or the `getContext()`
    method can be used too.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要访问Android资源、数据库或文件系统中的文件时，请使用它。上下文存储在此类的字段中，名为`mContext`，如果需要，可以在测试中使用，或者也可以使用`getContext()`方法。
- en: Tests based on this class can start more than one Activity using `Context.startActivity()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此类的测试可以使用`Context.startActivity()`启动多个Activity。
- en: 'There are various test cases in Android SDK that extend this base class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK中有各种扩展了此基类的测试用例：
- en: '`ApplicationTestCase<T extends Application>`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationTestCase<T extends Application>`'
- en: '`ProviderTestCase2<T extends ContentProvider>`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProviderTestCase2<T extends ContentProvider>`'
- en: '`ServiceTestCase<T extends Service>`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceTestCase<T extends Service>`'
- en: When using the `AndroidTestCase` Java class, you inherit some base assertion
    methods that can be used; let's look at these in more detail.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AndroidTestCase` Java类时，你继承了一些可以使用的基断言方法；让我们更详细地看看这些方法。
- en: The assertActivityRequiresPermission() method
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertActivityRequiresPermission()`方法'
- en: 'The signature for this method is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的签名如下：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Description
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'This assertion method checks whether the launching of a particular Activity
    is protected by a specific permission. It takes the following three parameters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言方法检查特定Activity的启动是否受到特定权限的保护。它需要以下三个参数：
- en: '`packageName`: This is a string that indicates the package name of the activity
    to launch'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packageName`：这是一个指示要启动的活动包名的字符串'
- en: '`className`: This is a string that indicates the class of the activity to launch'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`className`：这是一个指示要启动的活动类的字符串'
- en: '`permission`: This is a string with the permission to check'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permission`：这是一个包含要检查的权限的字符串'
- en: The Activity is launched and then `SecurityException` is expected, which mentions
    that the required permission is missing in the error message. The actual instantiation
    of an activity is not handled by this assertion, and thus, an Instrumentation
    is not needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Activity后，预期会出现`SecurityException`，它指出错误消息中缺少所需的权限。此断言实际上并不处理活动的实例化，因此不需要Instrumentation。
- en: Example
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'This test checks the requirement of the `android.Manifest.permission.WRITE_EXTERNAL_STORAGE`
    permission, which is needed to write to external storage, in the `MyContactsActivity`
    Activity:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查`MyContactsActivity`活动中写入外部存储所需的`android.Manifest.permission.WRITE_EXTERNAL_STORAGE`权限：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Always use the constants that describe the permissions from `android.Manifest.permission`,
    not the strings, so if the implementation changes, your code will still be valid.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用`android.Manifest.permission`中描述权限的常量，而不是字符串，这样如果实现发生更改，你的代码仍然有效。
- en: The assertReadingContentUriRequiresPermission method
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertReadingContentUriRequiresPermission`方法'
- en: 'The signature for this method is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的签名如下：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Description
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This assertion method checks whether reading from a specific URI requires the
    permission provided as a parameter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言方法检查从特定URI读取是否需要作为参数提供的权限。
- en: 'It takes the following two parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要以下两个参数：
- en: '`uri`: This is the Uri that requires a permission to query'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri`：这是需要查询权限的Uri'
- en: '`permission`: This is a string that contains the permission to query'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permission`：这是一个包含要查询的权限的字符串'
- en: If a `SecurityException` class is generated, which contains the specified permission,
    this assertion is validated.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成了一个包含指定权限的`SecurityException`类，则此断言被验证。
- en: Example
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'This test tries to read contacts and verifies that the correct `SecurityException`
    is generated:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试尝试读取联系人信息，并验证是否生成了正确的`SecurityException`：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The assertWritingContentUriRequiresPermission() method
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`assertWritingContentUriRequiresPermission()`方法'
- en: 'The signature for this method is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的签名如下：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Description
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This assertion method checks whether inserting into a specific `Uri` requires
    the permission provided as a parameter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言方法检查向特定`Uri`插入是否需要作为参数提供的权限。
- en: 'It takes the following two parameters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要以下两个参数：
- en: '`uri`: This is the Uri that requires a permission to query'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri`：这是需要查询权限的Uri'
- en: '`permission`: This is a string that contains the permission to query'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permission`：这是一个包含查询权限的字符串'
- en: If a `SecurityException` class is generated, which contains the specified permission,
    this assertion is validated.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成了一个包含指定权限的`SecurityException`类，则此断言被验证。
- en: Example
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'This test tries to write to Contacts and verifies that the correct `SecurityException`
    is generated:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试尝试写入联系人并验证是否生成了正确的`SecurityException`：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instrumentation
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Instrumentation（检测）
- en: Instrumentation is instantiated by the system before any of the application
    code is run, thereby allowing monitoring of all the interactions between the system
    and the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序代码运行之前，系统会实例化Instrumentation，从而允许监控系统与应用之间的所有交互。
- en: 'As with many other Android application components, instrumentation implementations
    are described in the `AndroidManifest.xml` under the tag `<instrumentation>`.
    However, with the advent of Gradle, this has now been automated for us, and we
    can change the properties of the instrumentation in the app''s `build.gradle`
    file. The `AndroidManifest` file for your tests will be automatically generated:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他Android应用组件一样，instrumentation的实现是在`AndroidManifest.xml`文件中的`<instrumentation>`标签下描述的。然而，随着Gradle的出现，这一过程现已自动化，我们可以在应用的`build.gradle`文件中更改instrumentation的属性。测试的`AndroidManifest`文件将会自动生成：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The values mentioned in the preceding code are also the defaults if you do not
    declare them, meaning that you don't have to have any of these parameters to start
    writing tests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有声明前面代码中提到的值，则它们也是默认值，这意味着您不需要这些参数就可以开始编写测试。
- en: The `testApplicationId` attribute defines the name of the package for your tests.
    As a default, it is your application under the test package name + `tests`. You
    can declare a custom test runner using `testInstrumentationRunner`. This is handy
    if you want to have tests run in a custom way, for example, parallel test execution.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`testApplicationId`属性定义了测试包的名称。默认情况下，它是测试包名称下的应用+ `tests`。您可以使用`testInstrumentationRunner`声明自定义测试运行器。如果您想以自定义方式运行测试，例如并行测试执行，这将非常有用。'
- en: There are also many other parameters in development, and I would advise you
    to keep your eyes upon the Google Gradle plugin website ([http://tools.android.com/tech-docs/new-build-system/user-guide](http://tools.android.com/tech-docs/new-build-system/user-guide)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 开发中还有许多其他参数，我建议您关注Google Gradle插件网站（[http://tools.android.com/tech-docs/new-build-system/user-guide](http://tools.android.com/tech-docs/new-build-system/user-guide)）。
- en: The ActivityMonitor inner class
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ActivityMonitor`内部类'
- en: As mentioned earlier, the Instrumentation class is used to monitor the interaction
    between the system and the application or the Activities under test. The inner
    class Instrumentation `ActivityMonitor` allows the monitoring of a single Activity
    within an application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Instrumentation类用于监控系统与应用程序或测试中的Activities之间的交互。内部类`Instrumentation.ActivityMonitor`允许监控应用程序内的单个Activity。
- en: Example
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let''s pretend that we have a TextView in our Activity that holds a URL and
    has its auto link property set:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的Activity中有一个`TextView`，它包含一个URL并设置了自动链接属性：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we want to verify that, when clicked, the hyperlink is correctly followed
    and some browser is invoked, we can create a test like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想验证点击超链接后是否正确跳转并调用了某个浏览器，我们可以创建如下测试：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we will do the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将执行以下操作：
- en: Create an IntentFilter for intents that would open a browser.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为那些会打开浏览器的意图创建一个`IntentFilter`。
- en: Add a monitor to our Instrumentation based on the `IntentFilter` class.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据基于`IntentFilter`类的`Instrumentation`添加一个监控。
- en: Click on the hyperlink.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击超链接。
- en: Wait for the activity (hopefully the browser).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待活动（希望是浏览器）。
- en: Verify that the monitor hits were incremented.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证监控点击次数是否增加。
- en: Remove the monitor.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除监控。
- en: Using monitors, we can test even the most complex interactions with the system
    and other Activities. This is a very powerful tool to create integration tests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用监控，我们可以测试与系统和其他Activity的最复杂的交互。这是创建集成测试的一个非常强大的工具。
- en: The InstrumentationTestCase class
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`InstrumentationTestCase`类'
- en: 'The `InstrumentationTestCase` class is the direct or indirect base class for
    various test cases that have access to Instrumentation. This is the list of the
    most important direct and indirect subclasses:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstrumentationTestCase`类是各种测试用例的直接或间接基类，这些测试用例可以访问Instrumentation。以下是最重要的直接和间接子类的列表：'
- en: '`ActivityTestCase`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityTestCase`'
- en: '`ProviderTestCase2<T extends ContentProvider>`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProviderTestCase2<T extends ContentProvider>`'
- en: '`SingleLaunchActivityTestCase<T extends Activity>`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleLaunchActivityTestCase<T extends Activity>`'
- en: '`SyncBaseInstrumentation`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyncBaseInstrumentation`'
- en: '`ActivityInstrumentationTestCase2<T extends Activity>`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityInstrumentationTestCase2<T extends Activity>`'
- en: '`ActivityUnitTestCase<T extends Activity>`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityUnitTestCase<T extends Activity>`'
- en: The `InstrumentationTestCase` class is in the `android.test` package, and extends
    `junit.framework.TestCase`, which extends `junit.framework.Assert`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstrumentationTestCase`类在`android.test`包中，并扩展了`junit.framework.TestCase`，后者又扩展了`junit.framework.Assert`。'
- en: The launchActivity and launchActivityWithIntent methods
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`launchActivity`和`launchActivityWithIntent`方法'
- en: 'These utility methods are used to launch Activities from a test. If the Intent
    is not specified using the second option, a default Intent is used:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实用方法用于从测试中启动活动。如果没有使用第二个选项指定Intent，将使用默认的Intent：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The template class parameter `T` is used in `activityCls` and as the return
    type, limiting its use to Activities of that type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模板类参数`T`在`activityCls`中使用，并作为返回类型，将其使用限制为该类型的活动。
- en: 'If you need to specify a custom Intent, you can use the following code that
    also adds the `intent` parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要指定一个自定义的Intent，你可以使用以下代码，它还添加了`intent`参数：
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The sendKeys and sendRepeatedKeys methods
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sendKeys`和`sendRepeatedKeys`方法'
- en: While testing Activities' UI, you will face the need to simulate interaction
    with qwerty-based keyboards or DPAD buttons to send keys to complete fields, select
    shortcuts, or navigate throughout the different components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试活动的UI时，你将需要模拟与基于qwerty的键盘或DPAD按钮的交互，以发送按键来完成字段、选择快捷方式或在不同的组件间导航。
- en: This is what the different `sendKeys` and `sendRepeatedKeys` are used for.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`sendKeys`和`sendRepeatedKeys`的不同用途。
- en: There is one version of `sendKeys` that accepts integer keys values. They can
    be obtained from constants defined in the `KeyEvent` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendKeys`有一个接受整数值作为按键的版本。它们可以从`KeyEvent`类中定义的常量中获得。'
- en: 'For example, we can use the `sendKeys` method in this way:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样使用`sendKeys`方法：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are sending `H`, `E`, and `Y` letter keys and then the `ENTER` key
    using their integer representations to the Activity under test.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发送`H`、`E`和`Y`字母键，然后使用它们的整数值发送`ENTER`键到被测试的活动。
- en: 'Alternatively, we can create a string by concatenating the keys we desire to
    send, discarding the `KEYCODE` prefix, and separating them with spaces that are
    ultimately ignored:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过连接我们想要发送的按键来创建一个字符串，忽略`KEYCODE`前缀，并用最终被忽略的空格分隔它们：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we did exactly the same as in the previous test but we used a `String
    "H 3* EY DPAD_DOWN ENTER"`. Note that every key in the `String` can be prefixed
    by a repeating factor followed by `*` and the key to be repeated. We used `3*E`
    in our previous example, which is the same as `E E E`, that is, three times the
    letter `E`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们与前一个测试做了完全相同的事情，但我们使用了`String "H 3* EY DPAD_DOWN ENTER"`。请注意，`String`中的每个键都可以用重复因子前缀和`*`以及要重复的键。我们在前面的例子中使用了`3*E`，这与`E
    E E`相同，即字母`E`三次。
- en: 'If sending repeated keys is what we need in our tests, there is also another
    alternative that is precisely intended for these cases:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的测试需要发送重复的按键，还有一种专门为这种情况设计的替代方法：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the same test implemented in a different manner. The repetition number
    precedes each key.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用另一种方式实现的相同测试。重复次数在每次按键前。
- en: The runTestOnUiThread helper method
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`runTestOnUiThread`帮助方法'
- en: 'The `runTestOnUiThread` method is a helper method used to run portions of a
    test on the UI thread. We used this inside the method `requestMessageInputFocus()`;
    so that we can set the focus on our EditText before waiting for the application
    to be idle, using `Instrumentation.waitForIdleSync()`. Also, the `runTestOnUiThread`
    method throws an exception, so we have to deal with this case:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`runTestOnUiThread`方法是一个帮助方法，用于在UI线程上运行测试的一部分。我们在`requestMessageInputFocus()`方法内部使用了这个方法；这样我们可以在使用`Instrumentation.waitForIdleSync()`等待应用程序空闲之前，将焦点设置在我们的EditText上。此外，`runTestOnUiThread`方法会抛出异常，所以我们必须处理这种情况：'
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alternatively, as we have discussed before, to run a test on the UI thread,
    we can annotate it with `@UiThreadTest`. However, sometimes, we need to run only
    parts of the test on the UI thread because other parts of it are not suitable
    to run on that thread, for example, database calls, or we are using other helper
    methods that provide the infrastructure themselves to use the UI thread, for example
    the `TouchUtils` methods.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，若要在UI线程上运行测试，我们可以使用`@UiThreadTest`注解。然而，有时我们只需要将测试的部分内容在UI线程上运行，因为测试的其他部分不适合在UI线程上运行，例如数据库调用，或者我们使用其他提供UI线程基础设施的帮助方法，例如`TouchUtils`方法。
- en: The ActivityTestCase class
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActivityTestCase类
- en: This is mainly a class that holds common code for other test cases that access
    Instrumentation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是一个包含其他访问Instrumentation的测试用例的通用代码的类。
- en: You can use this class if you are implementing a specific behavior for test
    cases and the existing alternatives don't fit your requirements. This means you
    are unlikely to use this class unless you want to implement a new base class for
    other tests to use. For example, consider a scenario where Google brings out a
    new component and you want to write tests around it (like `SuperNewContentProvider`).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在实现特定行为的测试用例，而现有的替代方案不符合您的需求，可以使用这个类。这意味着除非您想为其他测试实现一个新的基类，否则您不太可能使用这个类。例如，考虑一个场景，谷歌推出一个新组件，而您想围绕它编写测试（如`SuperNewContentProvider`）。
- en: 'If this is not the case, you might find the following options more suitable
    for your requirements:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况不是这样，您可能会发现以下选项更适合您的需求：
- en: '`ActivityInstrumentationTestCase2<T extends Activity>`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityInstrumentationTestCase2<T extends Activity>`'
- en: '`ActivityUnitTestCase<T extends Activity>`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityUnitTestCase<T extends Activity>`'
- en: The abstract class `android.test.ActivityTestCase` extends `android.test.InstrumentationTestCase`
    and serves as a base class for other different test cases, such as `android.test.ActivityInstrumentationTestCase`,
    `android.test.ActivityInstrumentationTestCase2`, and `android.test.ActivityUnitTestCase`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类`android.test.ActivityTestCase`扩展了`android.test.InstrumentationTestCase`，并为其他不同的测试用例（如`android.test.ActivityInstrumentationTestCase`，`android.test.ActivityInstrumentationTestCase2`和`android.test.ActivityUnitTestCase`）提供基类。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `android.test.ActivityInstrumentationTestCase` test case is a deprecated
    class since Android API Level 3 (Android 1.5) and should not be used in newer
    projects. Even though it was deprecated long ago, it has a great name for auto
    import, so be careful!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`android.test.ActivityInstrumentationTestCase`测试用例自Android API Level 3（Android
    1.5）起已被弃用，不应用于新项目中。尽管它早已被弃用，但其自动导入的名称仍然很常见，因此要小心！'
- en: The scrubClass method
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: scrubClass方法
- en: 'The `scrubClass` method is one of the protected methods in the class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrubClass`方法是该类中的受保护方法之一：'
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is invoked from the `tearDown()` method in several of the discussed test
    case implementations in order to clean up class variables that may have been instantiated
    as non-static inner classes so as to avoid holding references to them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它在之前讨论的几个测试用例实现中的`tearDown()`方法中被调用，以清理可能作为非静态内部类实例化的类变量，从而避免保留对它们的引用。
- en: This is in order to prevent memory leaks for large test suites.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了防止大型测试套件出现内存泄漏。
- en: '`IllegalAccessException` is thrown if a problem is encountered while accessing
    these class variables.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在访问这些类变量时遇到问题，将抛出`IllegalAccessException`。
- en: The ActivityInstrumentationTestCase2 class
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActivityInstrumentationTestCase2类
- en: The `ActivityInstrumentationTestCase2` class would probably be the one you use
    the most to write functional Android test cases. It provides functional testing
    of a single Activity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityInstrumentationTestCase2`类可能是您编写功能性Android测试用例最常使用的类。它提供了对单个Activity的功能测试。'
- en: This class has access to Instrumentation and will create the Activity under
    test using the system infrastructure, by calling `InstrumentationTestCase.launchActivity()`.
    The Activity can then be manipulated and monitored after creation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以访问Instrumentation，并通过调用`InstrumentationTestCase.launchActivity()`使用系统基础结构创建被测Activity。创建后，可以操作和监控Activity。
- en: If you need to provide a custom Intent to start your Activity, before invoking
    `getActivity()`, you may inject an Intent with `setActivityIntent(Intent intent)`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在启动Activity之前提供自定义Intent，可以在调用`getActivity()`之前使用`setActivityIntent(Intent
    intent)`注入一个Intent。
- en: This test case would be very useful to test interactions through the user interface
    as events can be injected to simulate user behavior.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例对于测试通过用户界面的交互非常有用，因为可以注入事件以模拟用户行为。
- en: The constructor
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'There is only one public non-deprecated constructor for this class, which is
    as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个公开的非弃用构造函数，如下所示：
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It should be invoked with an instance of the `Activity` class for the same Activity
    used as a class template parameter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该使用与类模板参数相同的Activity类的Activity实例来调用。
- en: The setUp method
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`setUp`方法'
- en: The `setUp` method is the precise place to initialize the test case fields and
    other fixture components that require initialization.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp`方法是初始化测试案例字段和其他需要初始化的固定组件的确切位置。'
- en: 'This is an example that shows some of the patterns that you might repeatedly
    find in your test cases:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示了您可能在测试用例中反复出现的某些模式：
- en: '[PRE27]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We perform the following actions:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行以下操作：
- en: Invoke the super method. This is a JUnit pattern that should be followed here
    to ensure correct operation.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用超类方法。这是JUnit模式，在这里应该遵循以确保正确操作。
- en: Disable the touch mode. To take effect, this should be done before the Activity
    is created, by invoking `getActivity()`. It sets the initial touch mode of the
    Activity under test as disabled. The touch mode is a fundamental Android UI concept,
    and is discussed in [http://developer.android.com/guide/topics/ui/ui-events.html#TouchMode](http://developer.android.com/guide/topics/ui/ui-events.html#TouchMode).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用触摸模式。为了使其生效，这应该在Activity创建之前完成，通过调用`getActivity()`。它将测试中的Activity的初始触摸模式设置为禁用。触摸模式是Android
    UI的一个基本概念，在[http://developer.android.com/guide/topics/ui/ui-events.html#TouchMode](http://developer.android.com/guide/topics/ui/ui-events.html#TouchMode)中有讨论。
- en: Start the Activity using `getActivity()`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getActivity()`启动Activity。
- en: Get the instrumentation. We have access to the instrumentation because `ActivityInstrumentationTestCase2`
    extends `InstrumentationTestCase`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Instrumentation。我们能够访问Instrumentation是因为`ActivityInstrumentationTestCase2`继承了`InstrumentationTestCase`。
- en: Find the Views and set the fields. In these operations, note that the `R` class
    used is from the target package and not from the tests.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找Views并设置字段。在这些操作中，请注意使用的`R`类来自目标包，而不是测试包。
- en: The tearDown method
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`tearDown`方法'
- en: Usually, this method cleans up what was initialized in `setUp`. For instance,
    if you were creating an integration test that sets up a mock web server before
    your tests, you would want to tear it back down afterwards to free up resources.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个方法会清理在`setUp`中初始化的内容。例如，如果您在测试之前创建了一个集成测试，设置了一个模拟Web服务器，那么您可能想在之后将其拆除以释放资源。
- en: 'In this example, we ensure that the object we used is disposed of:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们确保我们使用的对象被处置：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The ProviderTestCase2<T> class
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ProviderTestCase2<T>`类'
- en: This is a test case designed to test the `ContentProvider` classes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个旨在测试`ContentProvider`类的测试用例。
- en: The `ProviderTestCase2` class also extends `AndroidTestCase`. The class template
    parameter `T` represents `ContentProvider` under test. Implementation of this
    test uses `IsolatedContext` and `MockContentResolver`, which are mock objects
    that we described before in this chapter.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProviderTestCase2`类也扩展了`AndroidTestCase`。类模板参数`T`表示正在测试的`ContentProvider`。此测试的实现使用了`IsolatedContext`和`MockContentResolver`，这些我们在本章前面介绍过的是模拟对象。'
- en: The constructor
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'There is only one public non-deprecated constructor for this class. This is
    as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个公开的非弃用构造函数。如下所示：
- en: '[PRE29]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should be invoked with an instance of the `ContentProvider` class for the
    same `ContentProvider` class used as a class template parameter.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用与类模板参数相同的`ContentProvider`类的`ContentProvider`类实例来调用它。
- en: The second parameter is the authority for the provider, which is usually defined
    as the `AUTHORITY` constant in the `ContentProvider` class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是提供程序的权限，通常在`ContentProvider`类中定义为`AUTHORITY`常量。
- en: An example
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例
- en: 'This is a typical example of a `ContentProvider` test:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的`ContentProvider`测试示例：
- en: '[PRE30]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this test, we are expecting the query to return a Cursor that contains two
    rows (this is just an example that uses the number of rows that applies for your
    particular case) and asserts this condition.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试中，我们期望查询返回一个包含两行（这只是一个适用于您特定情况的行数示例）的Cursor，并断言此条件。
- en: Usually, in the `setUp` method, we obtain a reference to the `mProvider` provider
    in this example, using `getProvider()`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在`setUp`方法中，我们获取对示例中的`mProvider`提供者的引用，使用`getProvider()`。
- en: 'What is interesting to note is that because these tests are using `MockContentResolver`
    and `IsolatedContext`, the content of the real database is not affected, and we
    can also run destructive tests like this one:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由于这些测试使用了 `MockContentResolver` 和 `IsolatedContext`，实际的数据库内容并未受到影响，我们还可以运行像这样的破坏性测试：
- en: '[PRE31]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This test deletes some content from the database, but the database is restored
    to its initial content afterwards not to affect other tests.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试从数据库中删除了一些内容，但之后数据库会被恢复到初始内容，以免影响其他测试。
- en: The ServiceTestCase<T>
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ServiceTestCase<T>`'
- en: This is a test case specially created to test services. The methods to exercise
    the service life cycle, such as `setupService`, `startService`, `bindService`,
    and `shutDownService`, are also included in this class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个专门用于测试服务的测试案例。这个类中还包括了锻炼服务生命周期的方法，如 `setupService`、`startService`、`bindService`
    和 `shutDownService`。
- en: The constructor
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'There is only one public non-deprecated constructor for this class. This is
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个公开的、未被弃用的构造函数。如下所示：
- en: '[PRE32]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It should be invoked with an instance of the `Service` class for the same `Service`
    used as a class template parameter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该使用 `Service` 类的一个实例来调用，该实例与作为类模板参数的 `Service` 相同。
- en: The TestSuiteBuilder.FailedToCreateTests class
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`TestSuiteBuilder.FailedToCreateTests` 类'
- en: 'The `TestSuiteBuilder.FailedToCreateTests` class is a special `TestCase` class
    used to indicate a failure during the `build()` step. That is, during the test
    suite creation, if an error is detected, you will receive an exception like this
    one, which indicates the failure to construct the test suite:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestSuiteBuilder.FailedToCreateTests` 类是一个特殊的 `TestCase` 类，用于指示在 `build()`
    步骤期间发生的失败。也就是说，在测试套件创建期间，如果检测到错误，你会收到一个异常，如下所示，这表示构建测试套件失败：'
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using libraries in test projects
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试项目中使用库
- en: Your Android project might require an external Java library or an Android library.
    Now, we will explain how to incorporate these in your project that is ready to
    be tested. Note that the following explains the usage of a local module that is
    an Android library, but the same rules can be applied to an external JAR (Java
    library) file or an external AAR (Android library) file.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Android 项目可能需要一个外部 Java 库或 Android 库。现在，我们将解释如何将这些库整合到你的项目中，以便进行测试。请注意，以下内容解释了本地模块（Android
    库）的使用方法，但同样的规则也适用于外部 JAR（Java 库）文件或外部 AAR（Android 库）文件。
- en: Let's pretend that in one Activity, we are creating objects from a class that
    is part of a library. For the sake of our example, let's say the library is called
    `dummyLibrary`, and the mentioned class is `Dummy`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在一个 Activity 中，我们正在从一个属于库的类中创建对象。为了我们的示例，假设这个库叫做 `dummyLibrary`，提到的类是 `Dummy`。
- en: 'So our Activity would look like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的 Activity 会像这样：
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This library is an Android AAR module, and so it should be added to your `build.gradle`
    dependencies in the normal way:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是一个 Android AAR 模块，因此应该按照常规方式添加到你的 `build.gradle` 依赖项中：
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If this was an external library, you would replace `project(':dummylibrary')`
    with `'com.external.lib:name:version'`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个外部库，你会将 `project(':dummylibrary')` 替换为 `'com.external.lib:name:version'`。
- en: 'Now, let''s create a simple test. From our previous experience, we know that
    if we need to test an Activity, we should use `ActivityInstrumentationTestCase2`,
    and this is precisely what we will do. Our simple test will be as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的测试。根据我们以往的经验，我们知道如果需要测试一个 Activity，应该使用 `ActivityInstrumentationTestCase2`，这正是我们将要做的。我们的简单测试将如下所示：
- en: '[PRE36]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The test in the preceding code runs and passes in the first instance! Note that
    in the not-so-distant past (pre-Gradle), the test would not have even compiled.
    We would have had to jump through hoops, adding the test library to our Android
    tests project, or making the JAR/AAR file exportable from our main project. It's
    a nice time to stop and reflect on the power of Gradle and Android Studio that
    give us a lot of manual setup for free.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的测试在第一次运行时通过了！注意，在不久前（Gradle 之前），测试甚至无法编译。我们不得不采取各种措施，将测试库添加到我们的 Android
    测试项目中，或者使 JAR/AAR 文件可以从我们的主项目导出。现在是停下来反思 Gradle 和 Android Studio 强大功能的好时机，它们为我们免费提供了许多手动设置。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'We investigated the most relevant building blocks and reusable patterns to
    create our tests. Along this journey, we:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了创建测试的最相关的构建块和可重用模式。在这个过程中，我们：
- en: Understood the common assertions found in JUnit tests
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解了 JUnit 测试中常见的断言
- en: Explained the specialized assertions found in the Android SDK
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释了 Android SDK 中找到的专业断言
- en: Explored Android mock objects and their use in Android tests
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了 Android 中的模拟对象及其在 Android 测试中的应用
- en: Exemplified the use of the different test cases available in the Android SDK
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例展示了在 Android SDK 中可用的不同测试用例的使用方法
- en: Now that we have all the building blocks, it is time to start creating more
    and more tests to acquire the experience needed to master the technique.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经拥有了所有的构建模块，现在是时候开始创建越来越多的测试，以获得掌握这项技术所需的经验。
- en: The next chapter will provide you with examples of when and where to use different
    test cases on Android. This will give us a great breadth of expertise in knowing
    what testing methodology to apply when we have a specific scenario to test.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将为您提供在 Android 上何时以及何处使用不同测试用例的示例。这将让我们在了解在具有特定测试场景时应采用何种测试方法方面拥有更广泛的专业知识。
