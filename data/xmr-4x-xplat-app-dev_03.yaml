- en: Chapter 3. Code Sharing Between iOS and Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 iOS与Android之间的代码共享
- en: Xamarin's tools promise to share a good portion of your code between iOS and
    Android while taking advantage of the native APIs on each platform where possible.
    Doing so is an exercise in software engineering more than a programming skill
    or having the knowledge of each platform. To architect a Xamarin application for
    enabling code sharing, it is a must to separate your application into distinct
    layers. We'll cover the basics as well as specific options to consider certain
    situations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin的工具承诺在可能的情况下利用每个平台的本地API，在iOS和Android之间共享大部分代码。这样做更多的是软件工程的实践，而不是编程技能或对每个平台的知识。为了构建一个支持代码共享的Xamarin应用程序，必须将应用程序分离为不同的层次。我们将介绍基础知识以及针对特定情况考虑的具体选项。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The MVVM design pattern for code sharing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于代码共享的MVVM设计模式
- en: Project and solution organization strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目和解决方案的组织策略
- en: Portable Class Libraries (PCLs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植类库（PCLs）
- en: Preprocessor statements for platform-specific code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对特定平台代码的预处理器语句
- en: Dependency Injection (DI) simplified
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入（DI）简化
- en: Inversion of Control (IoC)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制反转（IoC）
- en: Learning the MVVM design pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习MVVM设计模式
- en: The **Model-View-ViewModel** (**MVVM**) design pattern was originally invented
    for **WPF** (**Windows Presentation Foundation**) applications using **XAML**
    for separating the UI from business logic and taking full advantage of **data
    binding**. Applications architected in this way have a distinct ViewModel layer
    that has no dependencies on its user interface. This architecture in itself is
    optimized for unit testing as well as cross-platform development. Since an application's
    ViewModel classes have no dependencies on the UI layer, you can easily swap an
    iOS user interface for an Android one and write tests against the ViewModel layer.
    The MVVM design pattern is also very similar to the MVC design pattern discussed
    in the previous chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）设计模式最初是为了使用**XAML**的**WPF**（**Windows Presentation
    Foundation**）应用程序而发明的，用于将UI与业务逻辑分离，并充分利用**数据绑定**。以这种方式构建的应用程序有一个独特的视图模型层，它与用户界面没有依赖关系。这种架构本身针对单元测试以及跨平台开发进行了优化。由于应用程序的视图模型类对UI层没有依赖，你可以轻松地将iOS用户界面替换为Android界面，并针对视图模型层编写测试。MVVM设计模式与前面章节讨论的MVC设计模式也非常相似。'
- en: 'The MVVM design pattern includes the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM设计模式包括以下内容：
- en: '**Model**: The model layer is the backend business logic driving the application
    and any business objects to go along with it. This can be anything from making
    web requests to a server to using a backend database.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型层是驱动应用程序的后端业务逻辑以及任何伴随的业务对象。这可以是任何从向服务器发起网络请求到使用后端数据库的内容。'
- en: '**View**: This layer is the actual user interface seen on the screen. In case
    of cross-platform development, it includes any platform-specific code for driving
    the user interface of the application. On iOS, this includes controllers used
    throughout an application and on Android, an application''s activities.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这一层是屏幕上实际看到用户界面。在跨平台开发中，它包括任何特定于平台的代码，用于驱动应用程序的用户界面。在iOS上，这包括整个应用程序中使用的控制器，在Android上，则包括应用程序的活动。'
- en: '**ViewModel**: This layer acts as the glue in MVVM applications. The ViewModel
    layers coordinate operations between the View and Model layers. A ViewModel layer
    will contain properties that the view will get or set, and functions for each
    operation that can be made by the user on each view. The ViewModel will also invoke
    operations on the Model layer if needed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这一层在MVVM应用程序中充当粘合剂。视图模型层协调视图和模型层之间的操作。视图模型层将包含视图获取或设置的属性，以及每个视图上用户可以进行的每个操作的函数。如果需要，视图模型还将在模型层上调用操作。'
- en: 'The following diagram shows the MVVM design pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了MVVM设计模式：
- en: '![Learning the MVVM design pattern](img/image00209.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![学习MVVM设计模式](img/image00209.jpeg)'
- en: It is important to note that the interaction between the View and ViewModel
    layers is traditionally created by data binding with WPF. However, iOS and Android
    do not have built-in data binding mechanisms, so our general approach throughout
    this book will be to manually call the ViewModel layer from the view. There are
    a few frameworks out there that provide data binding functionality such as **MVVMCross**
    and **Xamarin.Forms**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，视图(View)和视图模型(ViewModel)层之间的交互传统上是通过WPF的数据绑定来创建的。然而，iOS和Android没有内置的数据绑定机制，因此本书将采用的方法是从视图手动调用视图模型层。有几个框架提供了数据绑定功能，例如**MVVMCross**和**Xamarin.Forms**。
- en: To understand this pattern better, let's implement a common scenario. Let's
    say we have a search box on the screen and a search button. When the user enters
    some text and clicks on the button, a list of products and prices will be displayed
    to the user. In our example, we will use the **async** and **await** keywords
    that are available in C# 5 to simplify asynchronous programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一模式，让我们实现一个常见场景。假设我们在屏幕上有一个搜索框和一个搜索按钮。当用户输入一些文本并点击按钮时，将向用户显示产品和价格列表。在我们的示例中，我们将使用C#
    5中可用的**async**和**await**关键字来简化异步编程。
- en: 'To implement this feature, we would start with a simple `model` class (also
    called a `business` object) as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，我们将从一个简单的`model`类（也称为`business`对象）开始，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we would implement our Model layer for retrieving products based on the
    search term. This is where the business logic is performed, expressing how the
    search needs to actually work. This is seen in the following lines of code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据搜索词实现我们的模型层以检索产品。这里执行业务逻辑，表达实际需要如何执行搜索。以下代码行中可以看到这一点：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to note here that the `Product` and `ProductRepository` class
    are both considered as part of the Model layer of a cross-platform application.
    Some may consider `ProductRepository` as a **service** that is generally a self-contained
    class for retrieving data. It is a good idea to separate this functionality into
    two classes. The `Product` class's job is to hold information about a product,
    while `ProductRepository` is in charge of retrieving products. This is the basis
    for the **single responsibility principle**, which states that each class should
    only have one job or concern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`Product`和`ProductRepository`类都被认为是跨平台应用程序模型层的一部分。有些人可能认为`ProductRepository`是一个**服务**，通常是一个自包含的用于获取数据的类。将此功能分为两个类是一个好主意。`Product`类的任务是保存有关产品的信息，而`ProductRepository`负责检索产品。这是**单一职责原则**的基础，该原则指出每个类应该只有一个工作或关注点。
- en: 'Next, we would implement a `ViewModel` class as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按以下方式实现一个`ViewModel`类：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From here, your platform-specific code starts. Each platform would handle managing
    an instance of a `ViewModel` class, setting the `SearchTerm`property, and calling
    `Search` when the button is clicked. When the task completes, the user interface
    layer would update a list displayed on the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你的特定平台代码就开始了。每个平台将处理管理`ViewModel`类的实例，设置`SearchTerm`属性，并在点击按钮时调用`Search`。当任务完成后，用户界面层将更新屏幕上显示的列表。
- en: If you are familiar with the MVVM design pattern used with WPF, you might notice
    that we are not implementing `INotifyPropertyChanged` for data binding. Since
    iOS and Android don't have the concept of data binding, we omitted this functionality.
    If you plan on having a WPF or Windows UWP version of your mobile application
    or are using a framework that provides data binding, you should implement support
    for it where needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉与WPF一起使用的MVVM设计模式，你可能会注意到我们没有为数据绑定实现`INotifyPropertyChanged`。由于iOS和Android没有数据绑定的概念，我们省略了此功能。如果你计划为移动应用程序提供一个WPF或Windows
    UWP版本，或者使用提供数据绑定的框架，你应在需要的地方实现支持。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To learn more about `INotifyPropertyChanged`, check out this article on MSDN:
    [https://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged](https://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`INotifyPropertyChanged`的信息，请查看MSDN上的这篇文章：[https://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged](https://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged)
- en: Comparing project organization strategies
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较项目组织策略
- en: You might be asking yourself at this point, how do I set up my solution in Xamarin
    Studio to handle shared code and also have platform-specific projects? Xamarin.iOS
    applications can only reference Xamarin.iOS class libraries; so, setting up a
    solution can be problematic. There are several strategies for setting up a cross-platform
    solution, each with its own advantages and disadvantages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问自己，如何在Xamarin Studio中设置解决方案以处理共享代码，同时也有特定平台的项目？Xamarin.iOS应用程序只能引用Xamarin.iOS类库；因此，设置解决方案可能会遇到问题。有几种设置跨平台解决方案的策略，每种策略都有其自身的优点和缺点。
- en: 'Options for cross-platform solutions are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台解决方案的选项如下：
- en: '**File Linking**: For this option, you would start with either a plain .NET
    4.0 or .NET 4.5 class library containing all the shared code. You would then have
    a new project for each platform you want your app to run on. Each platform-specific
    project would have a subdirectory with all of the files linked in from the first
    class library. To set this up, add the existing files to the project, and select
    the **Add a link to the file** option. Any unit tests can run against the original
    class library. The advantages and disadvantages of file linking are as follows:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件链接**：对于这个选项，你可以从普通的.NET 4.0或.NET 4.5类库开始，该类库包含所有共享代码。然后，你需要为每个希望应用运行的平台创建一个新项目。每个特定平台的项目将包含一个子目录，其中链接了第一个类库中的所有文件。要设置这个，将现有文件添加到项目中，并选择**添加对文件的链接**选项。任何单元测试都可以针对原始类库运行。文件链接的优点和缺点如下：'
- en: '**Advantages**: This approach is very flexible. You can choose to link or not
    link certain files and can also use preprocessor directives such as `#if IPHONE`.
    You can also reference different libraries on Android versus iOS.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：这种方法非常灵活。你可以选择链接或不链接某些文件，并且可以使用如`#if IPHONE`之类的预处理器指令。你还可以在Android和iOS上引用不同的库。'
- en: '**Disadvantages**: You have to manage a file''s existence in three projects:
    core library, iOS, and Android. This can be a hassle if it is a large application
    or if many people are working on it. This option is also a bit outdated since
    the arrival of shared projects.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：你必须在三个项目中管理文件的存在：核心库、iOS和Android。如果这是一个大型应用程序，或者有很多人在处理它，这可能会很麻烦。自从共享项目出现后，这个选项也有些过时了。'
- en: '**Cloned Project Files**: It is very similar to file linking, the main difference
    being that you have a class library for each platform in addition to the main
    project. By placing the iOS and Android projects in the same directory as the
    main project, the files can be added without linking. You can easily add files
    by right-clicking on the solution and selecting **Display Options** | **Show All
    Files**. Unit tests can run against the original class library or the platform-specific
    versions:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克隆项目文件**：这非常类似于文件链接，主要的区别在于除了主项目之外，每个平台都有一个类库。将iOS和Android项目放在主项目同一目录下，文件可以添加而无需链接。你可以通过右键单击解决方案并选择**显示选项**
    | **显示所有文件**轻松地添加文件。单元测试可以针对原始类库或特定平台的版本运行：'
- en: '**Advantages**: This approach is just as flexible as file linking, but you
    don''t have to manually link any files. You can still use preprocessor directives
    and reference different libraries on each platform.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：这种方法与文件链接一样灵活，但你不需要手动链接任何文件。你仍然可以使用预处理器指令，并在每个平台上引用不同的库。'
- en: '**Disadvantages**: You still have to manage a file''s existence in three projects.
    There is additionally some manual file arranging required to set this up. You
    also end up with an extra project to manage on each platform. This option is also
    a bit outdated since the arrival of shared projects.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：你仍然需要在三个项目中管理文件的存在。此外，还需要一些手动文件整理来设置这个。你最终在每个平台上还要管理一个额外的项目。自从共享项目出现后，这个选项也有些过时了。'
- en: '**Shared Project**: Beginning in Visual Studio 2013, Microsoft created the
    concept of shared projects to enable code sharing between Windows 8 and Windows
    Phone apps. Xamarin has also implemented shared projects in Xamarin Studio as
    another option for enabling code sharing. Shared projects are virtually the same
    as file linking, in that adding a reference to a shared project effectively adds
    its files to your project:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享项目**：从Visual Studio 2013开始，微软创建了共享项目的概念，以实现Windows 8和Windows Phone应用程序之间的代码共享。Xamarin也在Xamarin
    Studio中实现了共享项目，作为实现代码共享的另一种选项。共享项目实际上与文件链接相同，因为添加对共享项目的引用实际上将其文件添加到你的项目中：'
- en: '**Advantages**: This approach is the same as file linking, but a lot cleaner
    since your shared code is in a single project. Xamarin Studio also provides a
    dropdown to toggle between each referencing project, so you can see the effect
    of preprocessor statements in your code.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：这种方法与文件链接相同，但更加整洁，因为你的共享代码位于一个单一的项目中。Xamarin Studio还提供了一个下拉菜单，可以在引用的每个项目之间切换，这样你就可以看到预处理器语句在代码中的效果。'
- en: '**Disadvantages**: Since all files in a shared project get added to each platform''s
    main project, it can get ugly to include platform specific code in a shared project.
    Preprocessor statements can quickly get out of hand if you have a large team,
    or have team members that don''t have a lot of experience. A shared project also
    doesn''t compile to a DLL, so there is not a way to distribute this kind of project
    without the source code.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：由于共享项目中的所有文件都会被添加到每个平台的主项目中，因此在共享项目中包含特定平台的代码可能会变得不美观。如果你有一个大型团队，或者团队成员经验不足，预处理语句可能会迅速失控。共享项目也不会编译成DLL，所以如果没有源代码，就没有办法分发这种类型的项目。'
- en: '**Portable Class Libraries**: This is the most optimal option once you are
    more experienced with Xamarin; you begin the solution by making a **portable**
    class library (**PCL**) project for all your shared code. This is a special project
    type that allows multiple platforms to reference the same project, allowing you
    to use the smallest subset of C# and the .NET framework available in each platform.
    Each platform-specific project would reference this library directly, as well
    as any unit test projects:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携式类库**：一旦你对Xamarin更加熟悉，这将是最佳选择；你从创建一个所有共享代码的**便携式**类库（**PCL**）项目开始解决方案。这是一种特殊的项目类型，允许多个平台引用同一个项目，使你可以使用每个平台中可用的C#和.NET框架的最小子集。每个特定平台的项目将直接引用这个库，以及任何单元测试项目：'
- en: '**Advantages**: All your shared code is in one project, and all platforms use
    the same library. Since preprocessor statements aren''t possible, PCL libraries
    generally have cleaner code. Platform specific code is generally abstracted away
    by interfaces or abstract classes.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：你所有的共享代码都在一个项目中，所有平台都使用相同的库。由于不可能使用预处理器语句，PCL库的代码通常更整洁。特定平台的代码通常通过接口或抽象类进行抽象。'
- en: '**Disadvantages**: You are limited to a subset of .NET depending on how many
    platforms you are targeting. Platform specific code requires use of **dependency
    injection**, which can be a more advanced topic for developers not familiar with
    it.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：根据你面向的平台数量，你将受限于.NET的一个子集。特定平台的代码需要使用**依赖注入**，这对于不熟悉这一主题的开发者来说可能是一个更高级的话题。'
- en: Setting up a shared project
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置共享项目
- en: To understand each option completely and what situations call for, let's define
    a solution structure for both shared projects and portable class libraries. Let's
    use the product search example from earlier in the chapter and set up a solution
    for each approach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解每个选项以及何种情况需要它，让我们为共享项目和便携式类库定义一个解决方案结构。让我们使用本章前面提到的产品搜索示例，并为每种方法设置一个解决方案。
- en: 'To set up a shared project, perform the following steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置共享项目，请执行以下步骤：
- en: Open Xamarin Studio and start a new solution.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xamarin Studio并开始一个新解决方案。
- en: Select a new **Single View App** under the **Multiplatform | App** section.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**多平台 | 应用**部分下选择一个新的**单视图应用**。
- en: Name the app `ProductSearch`, and select **Use Shared Library**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用命名为`ProductSearch`，并选择**使用共享库**。
- en: 'Complete this new project wizard and Xamarin Studio will generate three projects:
    `ProductSearch`, `ProductSearch.Droid`, and `ProductSearch.iOS`.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个新项目向导，Xamarin Studio将生成三个项目：`ProductSearch`、`ProductSearch.Droid`和`ProductSearch.iOS`。
- en: Add the `Product`, `ProductRepository`, and `ProductViewModel` classes to the
    `ProductSearch` project from earlier in this chapter. You will need to add `using
    System.Threading.Tasks;` and `using System.Linq;` where needed.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Product`、`ProductRepository`和`ProductViewModel`类添加到本章前面提到的`ProductSearch`项目中。你需要在需要的地方添加`using
    System.Threading.Tasks;`和`using System.Linq;`。
- en: Click on **Build** | **Build All** from the menu at the top to double-check
    everything, and you have successfully set up a cross-platform solution.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部菜单中的**构建** | **构建全部**来再次检查一切，这样你就成功设置了一个跨平台解决方案。
- en: 'When all is done, you will have a solution tree that looks something like what
    you can see in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将得到一个解决方案树，其外观类似于以下截图所示：
- en: '![Setting up a shared project](img/image00210.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![设置共享项目](img/image00210.jpeg)'
- en: Shared projects are a great place to start when getting started with cross-platform
    development. You can't go wrong with them, and they give you ultimate flexibility
    with the ability to use `#if` throughout your shared code. The only times shared
    projects might not be the best fit would be if you need to distribute the shared
    project to others or have a very large team or code base. Preprocessor directives
    can definitely get out of hand if left unchecked.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 共享项目是开始跨平台开发的一个很好的起点。使用它们不会出错，并且它们提供了最大的灵活性，可以在共享代码中使用`#if`。共享项目可能不是最佳选择的情况，可能是因为你需要将共享项目分发给其他人，或者拥有非常大的团队或代码库。如果放任不管，预处理器指令确实可能会失控。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Visual Studio, the project template for a cross-platform application can
    be found under **Cross-platform | Blank App (Native Shared)**. One thing to note
    is that it will also generate a Windows Phone project, which you can simply remove
    if not needed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，跨平台应用程序的项目模板可以在**跨平台 | 空白应用（原生共享）**下找到。需要注意的是，它还会生成一个Windows
    Phone项目，如果不需要，你可以简单地移除它。
- en: Working with portable class libraries
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用便携式类库进行工作。
- en: A **portable class library** (**PCL**) is a C# library project that is able
    to be supported on multiple platforms including iOS, Android, Windows, Windows
    Store apps, Windows phone, Silverlight, and Xbox 360\. PCLs have been an effort
    by Microsoft to simplify development across different versions of the .NET framework.
    Xamarin has also added support on iOS and Android for PCLs. Many popular cross-platform
    frameworks and open source libraries are starting to develop PCL versions such
    as Json.NET and MVVMCross.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**便携式类库**（**PCL**）是一个C#库项目，能够在包括iOS、Android、Windows、Windows Store应用、Windows
    Phone、Silverlight和Xbox 360在内的多个平台上得到支持。PCL是微软为简化不同.NET框架版本间开发而做出的努力。Xamarin也为iOS和Android增加了对PCL的支持。许多流行的跨平台框架和开源库开始开发PCL版本，如Json.NET和MVVMCross。'
- en: 'To set up a shared project, perform the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个共享项目，请执行以下步骤：
- en: Open Xamarin Studio and start a new solution.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xamarin Studio并开始一个新的解决方案。
- en: Select a new **Single View App** under the **Multiplatform | App** section.
    Or in Visual Studio, **Cross-platform | Blank App (Native Portable)**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**多平台 | 应用**部分下选择新的**单视图应用**。或者在Visual Studio中，选择**跨平台 | 空白应用（原生便携式）**。
- en: Name the app `ProductSearch`, and select **Use Portable Library**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用命名为`ProductSearch`，并选择**使用便携式库**。
- en: 'Complete this new project wizard and Xamarin Studio will generate three projects:
    `ProductSearch`, `ProductSearch.Droid`, and `ProductSearch.iOS`.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个新项目向导，Xamarin Studio将生成三个项目：`ProductSearch`、`ProductSearch.Droid`和`ProductSearch.iOS`。
- en: Add the `Product`, `ProductRepository`, and `ProductViewModel` classes to the
    `ProductSearch` project from earlier in the chapter. You will need to add `using
    System.Threading.Tasks;` and `using System.Linq;` where needed.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章前面提到的`Product`、`ProductRepository`和`ProductViewModel`类添加到`ProductSearch`项目中。你需要在需要的地方添加`using
    System.Threading.Tasks;`和`using System.Linq;`。
- en: Click on **Build** | **Build All** from the menu at the top to double-check
    everything, and you have successfully set up a PCL cross-platform solution.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部菜单中的**构建** | **构建全部**以再次检查一切，这样你就成功设置了一个PCL跨平台解决方案。
- en: PCLs are the way to go if you need to share your project as a DLL or NuGet package.
    It also helps you keep platform-specific concerns separate as it forces you to
    use an interface or base class along with **Dependency Injection (DI)**. Similar
    issues would arise if you needed to use a native library such as the Facebook
    SDK on iOS or Android.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将项目作为DLL或NuGet包共享，PCL是最佳选择。它还帮助你将特定平台的关注点分离，因为它迫使你使用接口或基类，并结合**依赖注入（DI）**。如果你需要在iOS或Android上使用类似本地的库，如Facebook
    SDK，也会出现类似的问题。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing, Microsoft has just released .NET Core and the new .NET
    Standard. This will affect the way PCLs work in the future, but should not break
    existing Xamarin.iOS and Xamarin.Android projects. It will, however, enable you
    to share code with .NET Core and ASP.NET Core projects going forward.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，微软刚刚发布了.NET Core和新的.NET Standard。这将影响未来PCLs的工作方式，但不会破坏现有的Xamarin.iOS和Xamarin.Android项目。不过，这将使你能够继续与.NET
    Core和ASP.NET Core项目共享代码。
- en: Using preprocessor statements
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预处理器语句
- en: When using shared projects, one of your most powerful tools is the use of preprocessor
    statements. If you are unfamiliar with them, C# has the ability to define preprocessor
    variables such as `#define IPHONE`, and then using `#if IPHONE` or `#if !IPHONE`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用共享项目时，你最有力的工具之一就是使用预处理器语句。如果你不熟悉它们，C# 有能力定义预处理器变量，如 `#define IPHONE`，然后使用
    `#if IPHONE` 或 `#if !IPHONE`。
- en: 'The following is a simple example of using the technique:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用该技术的简单示例：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Xamarin Studio, you can define preprocessor variables in your project's options
    under **Build** | **Compiler** | **Define Symbols**, delimited with semicolons.
    These will be applied to the entire project. Be warned that you must set up these
    variables for each configuration setting in your solution (**Debug** and **Release**);
    it can be an easy step to miss. You can also define these variables at the top
    of any C# file by declaring `#define IPHONE`, but they will only be applied within
    the C# file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中，你可以在项目选项的 **构建** | **编译器** | **定义符号** 下定义预处理器变量，用分号分隔。这些变量将被应用到整个项目。请注意，你必须为解决方案中的每个配置设置（**调试**
    和 **发布**）设置这些变量；这是一个容易遗漏的步骤。你还可以在任何 C# 文件的顶部通过声明 `#define IPHONE` 来定义这些变量，但它们只会在
    C# 文件内应用。
- en: 'Let''s go over another example, assuming we want to implement a class to open
    URLs on each platform:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，假设我们想要在每个平台上实现一个打开 URL 的类：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example is a perfect candidate for using preprocessor statements,
    since it is very specific to each platform and is a fairly simple function. To
    implement the method on iOS and Android, we will need to take advantage of some
    native APIs. Refactor the class to look as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是使用预处理器语句的完美候选者，因为它非常特定于每个平台，而且是一个相当简单的函数。要在 iOS 和 Android 上实现该方法，我们需要利用一些本地
    API。重构类，使其如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding class supports three different types of projects: Android, iOS,
    and a standard Mono or .NET framework class library. In the case of iOS, we can
    perform the functionality with static classes available in Apple''s APIs. Android
    is a little more problematic, and requires an `Activity` object for launching
    a browser natively. We get around this by modifying the input parameters on Android.
    Lastly, we have a plain .NET version that uses `Process.Start()` to launch a URL.
    It is important to note that using the third option would not work on iOS or Android
    natively, which necessitates our use of preprocessor statements.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类别支持三种不同类型的项目：Android、iOS 和标准的 Mono 或 .NET 框架类库。在 iOS 的情况下，我们可以使用苹果 API 中可用的静态类来执行功能。Android
    稍微有些复杂，需要 `Activity` 对象来本地启动浏览器。我们通过修改 Android 上的输入参数来解决这一问题。最后，我们有一个纯 .NET 版本，它使用
    `Process.Start()` 来启动一个 URL。需要注意的是，使用第三种选项在 iOS 或 Android 上本地是无法工作的，这就需要我们使用预处理器语句。
- en: Using preprocessor statements is not normally the cleanest or the best solution
    for cross-platform development. They are generally best used in a tight spot or
    for very simple functions. Code can easily get out of hand and can become very
    difficult to read with many `#if` statements, so it is always better to use it
    in moderation. Using inheritance or interfaces is generally a better solution
    when a class is mostly platform specific.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理器语句通常不是跨平台开发中最干净或最好的解决方案。它们通常最好在困境中使用，或用于非常简单的函数。代码很容易失控，如果有很多 `#if` 语句，代码可能会变得非常难以阅读，因此适度使用总是更好的。当类大多数是特定于平台的时候，使用继承或接口通常是更好的解决方案。
- en: Simplifying dependency injection
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化依赖注入
- en: '**Dependency injection** at first seems like a complex topic, but for the most
    part it is a simple concept. It is a design pattern aimed at making your code
    within your applications more flexible so that you can swap out certain functionality
    when needed. The idea builds around setting up dependencies between classes in
    an application so that each class only interacts with an interface or base/abstract
    class. This gives you the freedom to override different methods on each platform
    when you need to fill in native functionality.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入** 一开始看起来可能是一个复杂的话题，但大部分情况下它是一个简单的概念。它是一个设计模式，旨在使你的应用程序中的代码更加灵活，以便在需要时可以替换某些功能。这个想法围绕在应用程序中设置类之间的依赖关系，以便每个类只与接口或基类/抽象类交互。这给了你在需要实现本地功能时在每个平台上覆盖不同方法的自由。'
- en: The concept originated from the **SOLID** object-oriented design principles,
    which is a set of rules you might want to research if you are interested in software
    architecture. The **D** in SOLID stands for **dependencies**. Specifically, the
    principle declares that a program should depend upon abstractions, not concretions
    (concrete types).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念源自于**SOLID**面向对象设计原则，如果你对软件架构感兴趣，这是一组你可能想要研究的规定。SOLID中的**D**代表**依赖关系**。具体来说，该原则声明程序应依赖于抽象，而不是具体（具体类型）。
- en: 'To build upon this concept, let''s walk through the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立这个概念，让我们通过以下例子来逐步了解：
- en: Let's assume we need to store a setting in an application that determines if
    the sound is on or off.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们需要在应用程序中存储一个设置，以确定声音是开还是关。
- en: 'Now let''s declare a simple interface for the setting: `interface ISettings
    { bool IsSoundOn { get; set; } }`.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来声明一个简单的设置接口：`interface ISettings { bool IsSoundOn { get; set; } }`。
- en: On iOS, we'd want to implement this interface using the `NSUserDefaults` class.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS上，我们想使用`NSUserDefaults`类来实现这个接口。
- en: Likewise, on Android, we would implement this using `SharedPreferences`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在Android上，我们会使用`SharedPreferences`来实现这一点。
- en: Finally, any class that needs to interact with this setting would only reference
    `ISettings` so that the implementation could be replaced on each platform.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，任何需要与这个设置交互的类只需引用`ISettings`，这样每个平台上的实现都可以被替换。
- en: 'For reference, the full implementation of this example would look like the
    following snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，这个例子的完整实现看起来如下片段所示：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you would potentially have a `ViewModel` class that would only reference
    `ISettings` when following the MVVM pattern. It can be seen in the following snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照MVVM模式，你可能会有一个`ViewModel`类，它只引用`ISettings`，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using a ViewModel layer for such a simple example is not necessarily needed,
    but you can see it would be useful if you needed to perform other tasks such as
    input validation. A complete application might have a lot more settings and might
    need to present the user with a loading indicator. Abstracting out your setting's
    implementation has other benefits that add flexibility to your application. Let's
    say you suddenly need to replace `NSUserDefaults` on iOS with an iCloud version
    instead; you can easily do so by implementing a new `ISettings` class and the
    remainder of your code will remain unchanged. This will also help you target new
    platforms such as Windows UWP, where you may choose to implement `ISettings` in
    a platform-specific way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的例子来说，使用ViewModel层并不一定需要，但如果你需要进行其他任务，如输入验证，你可以看到它将非常有用。一个完整的应用程序可能会有更多的设置，并且可能需要向用户展示加载指示器。抽象出你的设置的实现会给你的应用程序带来其他好处，增加灵活性。比如说，你突然需要将iOS上的`NSUserDefaults`替换为iCloud版本；你可以通过实现一个新的`ISettings`类轻松做到这一点，其余的代码将保持不变。这还将帮助你针对新的平台，比如Windows
    UWP，你可能选择以特定于平台的方式实现`ISettings`。
- en: Implementing Inversion of Control
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制反转
- en: You might be asking yourself at this point of time, how do I switch out different
    classes such as the `ISettings` example? **Inversion of Control** (**IoC**) is
    a design pattern meant to complement the dependency injection and solve this problem.
    The basic principle is that many of the objects created throughout your application
    are managed and created by a single class. Instead of using the standard C# constructors
    for your `ViewModel` or `Model` classes, a service locator or factory class would
    manage them throughout the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问自己，如何切换不同的类，比如`ISettings`的例子？**控制反转**（**IoC**）是一种设计模式，旨在补充依赖注入并解决这个问题。基本原则是，在应用程序中创建的许多对象都由一个单独的类来管理和创建。在应用程序中，不是使用标准的C#构造函数来创建你的`ViewModel`或`Model`类，而是由服务定位器或工厂类来管理它们。
- en: 'There are many different implementations and styles of IoC, so let''s implement
    a simple service locator class to use throughout the remainder of this book as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: IoC有许多不同的实现和风格，所以让我们实现一个简单的服务定位器类，以供本书的其余部分使用，如下所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class is inspired by the simplicity of XNA/MonoGame's `GameServiceContainer`
    class, and follows the **service locator** pattern. The main differences are the
    use of generics and the fact that it is a static class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类受到XNA/MonoGame的`GameServiceContainer`类的简单性的启发，并遵循**服务定位器**模式。主要区别在于使用泛型和它是一个静态类。
- en: 'To use our `ServiceContainer` class, we would declare the version of `ISettings`
    or other interfaces that we want to use throughout our application by calling
    `Register`, as seen in the following lines of code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的`ServiceContainer`类，我们只需通过调用`Register`声明应用中要使用的`ISettings`或其他接口的版本，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On iOS, you could place this registration code in either your `static void Main()`
    method or in the `FinishedLaunching` method of your `AppDelegate` class. These
    methods are always called before the application is started.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，您可以将此注册代码放在`static void Main()`方法中，或者放在`AppDelegate`类的`FinishedLaunching`方法中。这些方法总是在应用程序启动之前调用。
- en: 'On Android, it is a little more complicated. You cannot put this code in the
    `OnCreate` method of your activity that is acting as the main launcher. In some
    situations, the Android OS can close your application, but restart it later in
    another activity. This situation would cause your application to crash, as it
    would try to access services from our container that was not registered yet. The
    guaranteed safe place to put this is in a custom Android `Application` class,
    which has an `OnCreate` method that is called prior to any activities being created
    in your application. The following lines of code show the use of the `Application`
    class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，情况稍微复杂一些。您不能将此代码放在作为主启动器的活动的`OnCreate`方法中。在某些情况下，Android OS可能会关闭您的应用程序，但稍后会在另一个活动中重新启动它。这种情况会导致您的应用程序崩溃，因为它会尝试访问尚未注册的容器中的服务。将此代码放在自定义的Android
    `Application`类中是安全的，该类有一个在应用程序中任何活动创建之前调用的`OnCreate`方法。下面的代码展示了`Application`类的使用：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To pull a service out of the `ServiceContainer` class, we could rewrite the
    constructor of the `SettingsViewModel` class, as shown in the following lines
    of code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`ServiceContainer`类中获取服务，我们可以重写`SettingsViewModel`类的构造函数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Likewise, you would use the generic `Resolve` method to pull out any `ViewModel`
    classes you would need to call from within controllers on iOS or activities on
    Android. This is a great, simple way to manage dependencies within your application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用泛型`Resolve`方法从iOS上的控制器或Android上的活动中调用任何需要的`ViewModel`类。这是管理应用程序内部依赖关系的很好且简单的方法。
- en: There are, of course, some great open source libraries out there that implement
    IoC for C# applications. You might consider switching to one of them if you need
    more advanced features for service location, or just want to graduate to a more
    complicated IoC container.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一些优秀的开源库实现了C#应用程序的IoC。如果您需要更高级的服务定位功能，或者只是想过渡到一个更复杂的IoC容器，您可以考虑切换到其中之一。
- en: 'Here are a few libraries that have been used with Xamarin projects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些与Xamarin项目一起使用的库：
- en: '**TinyIoC**: [https://github.com/grumpydev/TinyIoC](https://github.com/grumpydev/TinyIoC)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TinyIoC**：[https://github.com/grumpydev/TinyIoC](https://github.com/grumpydev/TinyIoC)'
- en: '**Ninject**: [http://www.ninject.org/](http://www.ninject.org/)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ninject**：[http://www.ninject.org/](http://www.ninject.org/)'
- en: '**MvvmCross**: [https://github.com/MvvmCross/MvvmCross](https://github.com/MvvmCross/MvvmCross)
    includes a full MVVM framework as well as IoC'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MvvmCross**：[https://github.com/MvvmCross/MvvmCross](https://github.com/MvvmCross/MvvmCross)
    包括完整的MVVM框架以及IoC。'
- en: '**Autofac**:[https://autofac.org](https://autofac.org)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Autofac**：[https://autofac.org](https://autofac.org)'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we learned about the MVVM design pattern and how it can be
    used to better architect cross-platform applications. We compared several project
    organization strategies for managing a Xamarin Studio solution containing both
    iOS and Android projects. We went over portable class libraries as the preferred
    option for sharing code and how to use preprocessor statements as a quick and
    dirty way to implement platform-specific code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了MVVM设计模式以及如何使用它来更好地构建跨平台应用程序。我们比较了管理包含iOS和Android项目的Xamarin Studio解决方案的几种项目组织策略。我们讨论了可移植类库作为共享代码的首选选项，以及如何使用预处理器语句作为实现平台特定代码的快速而简单的方法。
- en: After completing this chapter, you should be up to speed with several techniques
    for sharing code between iOS and Android applications using Xamarin Studio. Using
    the MVVM design pattern will help you separate your shared code and code that
    is platform specific. We also covered several options for setting up cross-platform
    Xamarin solutions. You should also have a firm understanding of using the dependency
    injection and Inversion of Control to give your shared code access to the native
    APIs on each platform. In our next chapter, we will begin with writing a cross-platform
    application and dive into using these techniques.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章节后，你应该已经掌握了使用 Xamarin Studio 在 iOS 和 Android 应用之间共享代码的几种技术。采用 MVVM 设计模式可以帮助你区分共享代码和特定平台的代码。我们还介绍了设置跨平台
    Xamarin 解决方案的几种选项。你也应该牢固掌握使用依赖注入和控制反转技术，使共享代码能够访问每个平台的本地 API。在下一章节中，我们将开始编写跨平台应用程序，并深入探讨这些技术的使用。
