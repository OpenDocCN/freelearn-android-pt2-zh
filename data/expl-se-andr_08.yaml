- en: Chapter 8. Applying Contexts to Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 应用上下文到文件
- en: 'In the last chapter, we upgraded our system, collected the audit logs, and
    started to analyze the audit records. We discovered that some objects on the filesystem
    were unlabeled. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们升级了系统，收集了审计日志，并开始分析审计记录。我们发现文件系统上的一些对象未标记。在本章中，我们将：
- en: Learn how filesystems and filesystem objects get their labels
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解文件系统和文件系统对象如何获取它们的标签
- en: Demonstrate techniques to change labels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示更改标签的技术
- en: Introduce extended attributes for labeling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入扩展属性进行标记
- en: Investigate file contexts and dynamic type transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查文件上下文和动态类型转换
- en: Labeling filesystems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记文件系统
- en: Filesystems on Linux originate from mount, with the exception of `ramdisk rootfs`
    on Android. Filesystems on Linux vary drastically. In general, in order to support
    all the features of SELinux, you need a filesystem with the support for `xattr`
    and the `security` namespace. We saw this requirement when we were setting up
    the kernel configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的文件系统源自mount，Android上的`ramdisk rootfs`除外。Linux上的文件系统差异极大。通常，为了支持SELinux的所有功能，你需要一个支持`xattr`和`security`命名空间的文件系统。我们在设置内核配置时遇到了这个要求。
- en: Filesystem objects, as they are created, all start with an initial context,
    just like all other kernel objects. Contexts on files simply inherit from their
    parent, so if the parent is unlabeled, then the child is unlabeled, with the exception
    of a type transition rule. Typically, if the context is unlabeled, it infers that
    the data was created on a filesystem prior to enabling SELinux support, or the
    type label in the `xattr` does not exist in the currently loaded policy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统对象在创建时，都带有初始上下文，就像所有其他内核对象一样。文件上的上下文简单地继承自它们的父级，因此如果父级未标记，则子级未标记，除非有类型转换规则。通常，如果上下文未标记，它推断数据是在启用SELinux支持之前的文件系统上创建的，或者当前加载的策略中不存在`xattr`中的类型标签。
- en: 'The initial label or initial **security id** (**sid**), is in the `sepolicy`
    file `initial_sid_contexts`. Each object class has its associated initial `sid`
    present. For example, let''s take a look at the following code snippet:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 初始标签或初始**安全ID**（**sid**）在`sepolicy`文件`initial_sid_contexts`中。每个对象类都有其相关的初始`sid`。例如，让我们看一下以下代码片段：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: fs_use
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs_use
- en: 'Filesystems can be labeled in a variety of ways. The best case scenario is
    when the filesystem supports `xattrs`. In that case, an `fs_use_xattr` statement
    should appear in the policy. These statements appear in the `fs_use` file in the
    `sepolicy` directory. The syntax for `fs_use_xattr` is:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统可以通过多种方式进行标记。最佳的情况是文件系统支持`xattrs`。在这种情况下，策略中应该会出现`fs_use_xattr`声明。这些声明位于`sepolicy`目录中的`fs_use`文件中。`fs_use_xattr`的语法如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To look at `fs_use` from `sepolicy`, we can refer to an example for the `ext4`
    filesystems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`sepolicy`中的`fs_use`，我们可以参考`ext4`文件系统的示例：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This tells SELinux that when it encounters an `ext4` `fs` object; look in the
    extended attributes for the label or file context.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉SELinux，当它遇到`ext4` `fs`对象时；在扩展属性中查找标签或文件上下文。
- en: fs_task_use
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs_task_use
- en: 'The other way a filesystem can be labeled is by using the process'' context
    while creating objects. This makes sense for pseudo filesystems where the objects
    are really process contexts, such as `pipefs` and `sockfs`. These pseudo filesystems
    manage the pipe and socket syscalls and are not really mounted to userspace. They
    exist internally to the kernel, for the kernels use. However, they do have objects,
    and like any other object, they need to be labeled. This is the context in which
    the `fs_task_use` policy statement makes sense. These internal filesystems can
    only be accessed by processes directly, and provide services to those processes.
    Hence, labeling them with the creator makes sense. The syntax is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统可以通过在创建对象时使用进程上下文来进行标记。这对于伪文件系统来说是有意义的，因为这些对象实际上是进程上下文，如`pipefs`和`sockfs`。这些伪文件系统管理管道和套接字系统调用，并不真正挂载到用户空间。它们存在于内核内部，供内核使用。然而，它们确实有对象，并且像任何其他对象一样，它们需要被标记。在这种情况下，`fs_task_use`策略声明是有意义的。这些内部文件系统只能被进程直接访问，并为这些进程提供服务。因此，用创建者进行标记是合理的。语法如下：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Examples from the `sepolicy` file `fs_use` are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy`文件`fs_use`中的示例如下：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: fs_use_trans
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs_use_trans
- en: 'The next way you might wish to set labels on pseudo filesystems that are actually
    mounted, is by using `fs_use_trans`. This sets a filesystem wide label on the
    pseudo filesystem. The syntax for this is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望设置的下一个在实际上挂载的伪文件系统上设置标签的方法是使用`fs_use_trans`。这为伪文件系统设置一个文件系统范围的标签。这个的语法如下：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Example from the `sepolicy` file `fs_use` is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy`文件中`fs_use`的示例如下：'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: genfscon
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: genfscon
- en: If none of the `fs_use_*` statements meet your use cases, which would be the
    case for `vfat` filesystems and `procfs`, then you would use the `genfscon` statement.
    The label specified for `genfscon` applies to *all* instances of that filesystem
    mount. For instance, you might wish to use `genfscon` with the `vfat` filesystems.
    If you have two `vfat` mounts, they will use the same `genfscon` statement for
    each mount. However, `genfscon` behaves differently with `procfs`, and lets you
    label each file or directory within the filesystem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何`fs_use_*`语句符合你的使用场景，比如`vfat`文件系统和`procfs`，那么你会使用`genfscon`语句。为`genfscon`指定的标签适用于*所有*该文件系统挂载的实例。例如，你可能希望对`vfat`文件系统使用`genfscon`。如果你有两个`vfat`挂载点，它们将针对每个挂载点使用相同的`genfscon`语句。然而，`genfscon`在处理`procfs`时行为不同，允许你为文件系统内的每个文件或目录设置标签。
- en: 'The syntax of `genfscon` is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`genfscon`的语法如下：'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Examples from `sepolicy genfs_contexts` are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy genfs_contexts`的示例如下：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the `rootfs` partial path is `/`. It's not `procfs`, so it doesn't
    support any fine granularity to its labeling; so `/` is the only thing you can
    use. However, you can get wild with `procfs` and set to any granularity you desire.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`rootfs`的部分路径是`/`。它不是`procfs`，所以不支持对其标记的任何细粒度控制；因此，`/`是你唯一可以使用的。然而，你可以对`procfs`进行任意粒度的设置。
- en: Mount options
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载选项
- en: Another option, if none of those fit your needs, is to pass the `context` option
    via the `mount` command line. This sets a filesystem wide mount context, such
    as `genfscon`, but is useful in the case of multiple filesystems that need to
    have separate labels. For instance, if you have two `vfat` filesystems mounted,
    you might wish to separate accesses to them. With `genfscon` statements, both
    filesystems would use the same label provided by `genfscon`. By specifying the
    label at mount time, you can have two `vfat` filesystems mounted with different
    labels.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些选项都不符合你的需求，另一个选项是可以通过`mount`命令行传递`context`选项。这设置一个文件系统范围的挂载上下文，如`genfscon`，但在需要分别设置标签的多个文件系统中很有用。例如，如果你挂载了两个`vfat`文件系统，你可能希望分开访问它们。使用`genfscon`语句，两个文件系统将使用由`genfscon`提供的相同标签。通过在挂载时指定标签，你可以让两个`vfat`文件系统使用不同的标签挂载。
- en: 'Take the following command as an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下命令为例：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Additional to the context as a mount option are: `fscontext` and `defcontext`.
    These options are mutually exclusive from context. The `fscontext` option sets
    the meta filesystem type that is used for certain operations, such as mount, but
    does not change the per file labels. The `defcontext` sets the default context
    for unlabeled files overriding the `initial_sid` statements. Lastly, another option,
    `rootcontext` allows you to set the root inode context in the filesystem, but
    only for that object. According to the man page mount (`man 8 mount`), it was
    found useful in stateless Linux.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为挂载选项的上下文之外，还有：`fscontext`和`defcontext`。这些选项与上下文是互斥的。`fscontext`选项设置用于某些操作（如挂载）的元文件系统类型，但不会改变每个文件的标签。`defcontext`设置未标记文件的默认上下文，覆盖`initial_sid`语句。最后，另一个选项`rootcontext`允许你设置文件系统中的根inode上下文，但仅适用于该对象。根据mount的手册页（`man
    8 mount`），在无状态Linux中它被证明是有用的。
- en: Labeling with extended attributes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展属性进行标记
- en: Lastly, and probably the most frequently used way of labeling, is by using the
    extended attributes support also known as `xattr` or EA support. Even with `xattr`
    support, new objects inherit the context of their parent directory; however, these
    labels have the granularity of being per filesystem object-based or inode-based.
    If you remember, we had to turn on or verify that `XATTR(CONFIG_EXT4_FS_XATTR)`
    support was enabled for our filesystems on Android as well as configuring SELinux
    to use it via the config option `CONFIG_EXT4_FS_SECURITY`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最常用于标记的方法之一是使用扩展属性支持，也称为`xattr`或EA支持。即使有`xattr`支持，新对象也会继承其父目录的上下文；然而，这些标签具有基于每个文件系统对象或inode的细粒度。如果你记得，我们需要为Android上的文件系统启用或验证`XATTR(CONFIG_EXT4_FS_XATTR)`支持，并通过配置选项`CONFIG_EXT4_FS_SECURITY`配置SELinux使用它。
- en: Extended attributes are a key-value metadata stores for files. SELinux security
    contexts use the `security.selinux` key, and the value is a string that is the
    security context or label.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性是文件的键值元数据存储。SELinux安全上下文使用`security.selinux`键，值是一个字符串，即安全上下文或标签。
- en: The file_contexts file
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`file_contexts`文件'
- en: 'Within the `sepolicy` directory, you will find the `file_contexts` file. This
    file is consulted to set the attributes on filesystems that support per file security
    labels. Note that a couple of pseudo filesystems support this as well, such as
    `tmpfs`, `sysfs`, and recently `rootfs`. The `file_context` file has a regular
    expression-based syntax as follows, where `regexp` is the regular expression for
    the path:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sepolicy`目录中，你会找到`file_contexts`文件。这个文件用于设置支持每个文件安全标签的文件系统的属性。请注意，一些伪文件系统也支持这一点，如`tmpfs`、`sysfs`以及最近的`rootfs`。`file_context`文件具有基于正则表达式的语法，如下所示，其中`regexp`是路径的正则表达式：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If multiple regular expressions are defined for a file, the last match is used,
    so order is important.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为文件定义了多个正则表达式，将使用最后一个匹配项，因此顺序很重要。
- en: 'The following list shows each type field value for the type of filesystem object,
    their meanings, and syscall interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了每种文件系统对象的类型字段值，它们的含义以及系统调用接口：
- en: '`--`: This denotes a regular file.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`：这表示一个常规文件。'
- en: '`-d`: This denotes a directory.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：这表示一个目录。'
- en: '`-b`: This denotes a block file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`：这表示一个块文件。'
- en: '`-s`: This denotes a socket file.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：这表示一个套接字文件。'
- en: '`-c`: This denotes a character file.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`：这表示一个字符文件。'
- en: '`-l`: This denotes a link file.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`：这表示一个链接文件。'
- en: '`-p`: This denotes a named pipe file.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：这表示一个命名管道文件。'
- en: As you can see, the type is essentially the mode as output by `ls -la` command.
    If it's not specified, it matches everything.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，类型本质上是`ls -la`命令输出的模式。如果没有指定，它将匹配所有内容。
- en: The next field is the file label or the special identifier `<<none>>`. Either
    one would supply a context or the identifier `<<none>>`. If you specify the context,
    the SELinux tools that consult `file_contexts` use the last match to the specified
    context. If the context specified is `<<none>>`, it means that no context is assigned.
    So, leave the one that we have found. The keyword `<<none>>` is not used in the
    AOSP reference, `sepolicy`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段是文件标签或特殊标识符`<<none>>`。两者都可以提供上下文或标识符`<<none>>`。如果你指定了上下文，那么咨询`file_contexts`的SELinux工具将使用与指定上下文最后的匹配项。如果指定的上下文是`<<none>>`，这意味着没有分配上下文。所以，保留我们找到的那个。关键字`<<none>>`没有在AOSP参考的`sepolicy`中使用。
- en: It's important to note that the preceding paragraph explicitly states that SELinux
    tools use the `file_contexts` policy. The kernel is not aware that this file exists.
    SELinux labels all its objects by explicitly setting them from userspace with
    tools that look up the context in `file_context` or via the `fs_use_*` and `genfs`
    policy statements. In other words, `file_contexts` is not built in the core policy
    file, and it is not loaded or used directly by the kernel. At build time, the
    `file_contexts` file is built in the ramdisk rootfs and can be found at `/file_contexts`.
    Also, during build time, the system image is labeled, freeing the device itself
    from this burden.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，前一段明确指出SELinux工具使用了`file_contexts`策略。内核并不知道这个文件的存在。SELinux通过明确地从用户空间设置工具来给所有对象贴上标签，这些工具会在`file_context`中查找上下文，或者通过`fs_use_*`和`genfs`策略声明。换句话说，`file_contexts`没有内置于核心策略文件中，也没有被内核直接加载或使用。在构建时，`file_contexts`文件被构建在ramdisk的rootfs中，可以在`/file_contexts`找到。此外，在构建时，系统镜像被贴上标签，从而减轻设备本身的负担。
- en: In Android, `init`, `ueventd`, and `installd` have all been modified to look
    up the contexts of objects they are creating; so that they can label them properly.
    Thus, all the init built ins that create filesystem objects, such as `mkdir`,
    have been modified to make use of the `file_contexts` file if it exists, and the
    same goes for `installd` and `ueventd`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，`init`、`ueventd`和`installd`都已经修改为在创建对象时查找它们的上下文；这样它们可以正确地给它们贴上标签。因此，所有创建文件系统对象的init内置命令，如`mkdir`，都已被修改以使用存在的`file_contexts`文件，`installd`和`ueventd`也是如此。
- en: 'Let''s take a look at some snippets from the `file_context` file located in
    `sepolicy`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些来自`sepolicy`目录中的`file_context`文件的部分内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are setting up the contexts for files in `/dev`. Note how the entries
    are in order from most generic to more specific `dev` files. Thus, any files not
    covered by the more specific entries will end up with the context `u:object_r:device:s0`,
    and the files that match further down, end up with a more specific label. For
    instance, the accelerometer at `/dev/accelerometer` will get the context `u:object_r:sensors_device:s0`.
    Note that the type field was omitted, which means that it matches on *all* filesystem
    objects, such as directories (`type -d`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为`/dev`中的文件设置上下文。请注意，条目是从最通用到更具体的`dev`文件的顺序。因此，未被更具体条目覆盖的任何文件最终将具有上下文`u:object_r:device:s0`，而匹配到更下面文件的将具有更具体的标签。例如，在`/dev/accelerometer`的加速度计将获得上下文`u:object_r:sensors_device:s0`。注意类型字段被省略了，这意味着它匹配*所有*文件系统对象，如目录（`type
    -d`）。
- en: 'You might be wondering how `/dev`, the directory itself, gets a file context.
    Looking at some of the snippets, we say the `/` or root, got labeled via the statement
    `genfscon rootfs / u:object_r:rootfs:s0` in the `genfs_context` file. This chapter
    stated earlier that, "new objects inherit the context of their parent directory."
    Hence, we can reason that `/dev` is of context `u:object_r:rootfs:s0` since that
    is the label `/` has. We can test this by passing the `-Z` flag to `ls` to show
    us the label of `/dev`. On the UDOO serial connection, execute the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`/dev`目录本身是如何获得文件上下文的。查看一些代码片段，我们看到根目录`/`通过`genfs_context`文件中的声明`genfscon
    rootfs / u:object_r:rootfs:s0`被标记。本章前面提到，“新对象继承其父目录的上下文。”因此，我们可以推断出`/dev`的上下文是`u:object_r:rootfs:s0`，因为这是`/`的标签。我们可以通过向`ls`传递`-Z`标志来显示`/dev`的标签来测试这一点。在UDOО串行连接上，执行以下命令：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It seems that the hypothesis is incorrect, but note that it is true that everything
    has a label, and if it's not specified, then it inherits from the parent. Looking
    back at `sepolicy`, we can see that the `dev` filesystem was initially set with
    a `fs_use_trans devtmpfs u:object_r:device:s0;` policy statement. So when the
    filesystem is mounted, it is set filesystem wide. Later, when entries are added
    by `init` or `ueventd`, they use `file_contexts` entries to set the context of
    the newly created filesystem object to what is specified in the `file_contexts`
    file. The filesystem at `/dev`, which is a `devtmps` pseudo filesystem, is an
    example of a filesystem that has both a filesystem-wide label via the `fs_use_trans`
    statement, but can also support fine grained labeling via `file_contexts;`. Filesystems
    are not very consistent in capabilities on Linux.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个假设是错误的，但请注意，确实一切都有标签，如果没有明确指定，那么它将从父级继承。回顾`sepolicy`，我们可以看到`dev`文件系统最初设置了`fs_use_trans
    devtmpfs u:object_r:device:s0;`这样的策略声明。因此，当文件系统被挂载时，它是全局设置的。后来，当`init`或`ueventd`添加条目时，它们使用`file_contexts`条目将新创建的文件系统对象的上下文设置为`file_contexts`文件中指定的内容。在`/dev`的文件系统，它是一个`devtmps`伪文件系统，就是一个同时具有通过`fs_use_trans`声明设置的全局标签，同时也能通过`file_contexts;`支持细粒度标签的文件系统示例。在Linux上，文件系统的能力并不一致。
- en: Dynamic type transitions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型转换
- en: 'Dynamic type transitions indicated by the SELinux policy statement `type_transition`
    are a way to allow files to dynamically determine their types. Because these are
    compiled into the policy, these do not have any relation to the `file_contexts`
    file. These policy statements allow the policy author to dynamically dictate the
    context of a file based on the context in which the file is created. These are
    useful in situations where you don''t control source code, or do not wish to couple
    SELinux in any way. For instance, the `wpa` supplicant, which is a service that
    runs for Wi-Fi support and creates a socket file in its data directory. Its data
    directory is labeled with the type `wifi_data_file` and as expected, the socket
    ends up with that label. However, this socket is shared by the system server.
    Now, we can allow just the system server to access the type and object class,
    however, `hostapd` and other things are creating sockets and other objects in
    that directory and thus the objects also have this type. We really want to ensure
    that the two sockets in question, the one used by `hostapd` and the other by system
    server, are kept exclusive from each other. To do this, we need to be able to
    label one of the sockets at a finer granularity, and to do so, we can either modify
    the code or use a dynamic type transition. Rather than mucking with the code,
    let''s use a type transition, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由SELinux策略语句`type_transition`指示的动态类型转换是一种允许文件动态确定其类型的方法。因为这些是编译到策略中的，所以它们与`file_contexts`文件无关。这些策略语句允许策略作者基于文件创建的上下文动态地指示文件上下文。在你不控制源代码，或者不想以任何方式将SELinux耦合在一起的情况下，这些是非常有用的。例如，`wpa`请求者，这是一个为Wi-Fi支持运行的服务，在其数据目录中创建一个套接字文件。其数据目录被标记为类型`wifi_data_file`，如预期的那样，套接字最终也具有该标签。然而，此套接字由系统服务器共享。现在，我们可以允许系统服务器访问类型和对象类，但是`hostapd`和其他东西正在该目录中创建套接字和其他对象，因此这些对象也具有此类型。我们确实希望确保两个有问题的套接字，一个由`hostapd`使用，另一个由系统服务器使用，彼此保持独立。为此，我们需要能够以更细的粒度标记其中一个套接字，为此，我们可以修改代码或使用动态类型转换。与其修改代码，不如使用以下类型的转换：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is an actual statement from the `sepolicy` file, `wpa_supplicant.te`.
    It says that, when a process of the type `wpa` creates a file of the type `wifi_data_file`
    and the object class is `sock_file` to label it as `wpa_socket` on creation. The
    statement syntax is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`sepolicy`文件`wpa_supplicant.te`中的实际语句。它表示，当类型为`wpa`的进程创建类型为`wifi_data_file`的文件且对象类为`sock_file`时，在创建时将其标记为`wpa_socket`。语句语法如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As of SELinux policy version 25, the `type_transition` statement can support
    named type transitions where a fourth argument exists and is the name of the file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从SELinux策略版本25开始，`type_transition`语句可以支持带名称的类型转换，其中第四个参数存在，且是文件的名称：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will see an example use of this filename in the `sepolicy` file, `system_server.te`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`sepolicy`文件`system_server.te`中看到一个关于此文件名的示例使用：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the filename or basename and not the path, and it must match exactly. Regex
    is not supported. It's also interesting to note that the dynamic transitions are
    not limited to file objects, but any object class event processes. We will see
    how dynamic process transitions are used in [Chapter 9](ch09.html "Chapter 9. Adding
    Services to Domains"), *Adding Services to Domains*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意文件名或基名称，而不是路径，并且必须完全匹配。不支持正则表达式。有趣的是，动态转换不仅限于文件对象，还包括任何对象类事件进程。我们将在[第9章](ch09.html
    "第9章. 将服务添加到域")《将服务添加到域》中看到如何使用动态进程转换。
- en: Examples and tools
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例和工具
- en: 'With the theory behind us, let''s look at the tools and techniques to label
    files in the system. Let''s start by mounting a `ramfs` filesystem. We will start
    by remounting `/` since it is read only and create a mount point for the filesystem.
    Via the UDOO serial console, execute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理论知识我们已经有了，现在让我们看看系统中标记文件的工具和技术。首先，我们从挂载一个`ramfs`文件系统开始。由于`/`是只读的，我们将重新挂载它并为文件系统创建一个挂载点。通过UDOOUDOO串行控制台，执行以下命令：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we want to see which label the filesystem has:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要查看文件系统具有哪个标签：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can recall, the `initial_sid_context` file had this initial `sid` set
    for the filesystem:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，`initial_sid_context`文件为此文件系统设置了此初始`sid`：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we want to get this ramdisk in a new label, we need to create the type in
    the policy, and set a new `genfscon` statement to use it. We will declare the
    new type in the sepolicy file `file.te`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在新标签中获取这个ramdisk，我们需要在策略中创建类型，并设置一个新的`genfscon`语句来使用它。我们将在sepolicy文件`file.te`中声明新类型：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The type policy statement syntax is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型策略语句的语法如下：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Attributes in SELinux are statements that let you define common groups. They
    are defined via the `attribute` statement. In Android SELinux policy, we have
    `file_type` and `fs_type` defined for us already. We will use them here because
    this new type, which we're creating, has the attributes `file_type` and `fs_type`.
    The `file_type` attribute is associated with a type for a file, and the `fs_type`
    attribute means that this type is also associated with filesystems. Attributes,
    right now, are not of great importance; so don't get caught up in the detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux中的属性是允许你定义常见组的语句。它们是通过`attribute`语句定义的。在Android SELinux策略中，我们已经定义了`file_type`和`fs_type`。我们将在这里使用它们，因为我们要创建的这种新类型具有`file_type`和`fs_type`属性。`file_type`属性与文件的类型相关联，而`fs_type`属性意味着此类型也与文件系统相关联。目前，属性并不是非常重要；所以不要在细节上纠结。
- en: 'The next thing to modify is the `sepolicy` file, `genfs_context` by adding
    the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要修改的是`sepolicy`文件，`genfs_context`，通过添加以下内容：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we will compile the boot image and flash it to the device, or better yet,
    let's use the dynamic policy reload support like the following.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编译引导映像并将其闪存到设备上，或者更好的是，让我们使用如下所示的动态策略重新加载支持。
- en: 'From the root of the UDOO project tree build just the `sepolicy` project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从UDOOb项目的根目录仅构建`sepolicy`项目：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Push the new policy over `adb`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`adb`推送新策略，如下所示：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Trigger a reload by using the `setprop` command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setprop`命令触发重新加载：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you have the serial console connected, you should see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你连接了串行控制台，你应该会看到：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you don''t, and just have `adb`, check `dmesg`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有，只有`adb`，检查`dmesg`：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A successful load should use our policy at the path, `/data/security/current/sepolicy`.
    Let''s unmount the ramdisk and remount it to check out its type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 成功加载应该使用我们在路径`/data/security/current/sepolicy`上的策略。让我们卸载ramdisk并重新挂载它，以查看其类型：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We were able to modify the policy and use `genfscon` to change the filesystem
    type, and now to show inheritance, let''s go ahead and create a file on the filesystem
    with `touch`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够修改策略并使用`genfscon`更改文件系统类型，现在为了显示继承，让我们继续在文件系统上使用`touch`创建一个文件：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we expected, the new file is labeled with the type ramdisk. Now, suppose
    when we do touch from the shell, we want the file to be of a different type, such
    as `ramdisk_newfile`; how can we do this? We can do this by modifying touch itself
    to consult `file_contexts`, or we can define a dynamic type transition; let us
    try the dynamic type transition approach. The first argument to the `type_transition`
    statement is the creating type; so what type is our shell in? You can get this
    by performing:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，新文件被标记为ramdisk类型。现在，假设我们从shell执行touch操作，希望文件是另一种类型，比如`ramdisk_newfile`，我们该如何操作？我们可以通过修改touch本身来咨询`file_contexts`，或者我们可以定义一个动态类型转换；让我们尝试动态类型转换的方法。`type_transition`语句的第一个参数是创建类型；那么我们的shell是什么类型呢？你可以通过执行以下操作来获取：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A simpler way is to run the `id -Z` command, which uses the aforementioned
    `proc` file. For a serial console, execute:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的方法是运行`id -Z`命令，该命令使用前述的`proc`文件。对于串行控制台，执行：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And to run the same command for the `adb` shell:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并为`adb` shell运行相同的命令：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note the discrepancy between our serial console shell and the `adb` shell, in
    [Chapter 9](ch09.html "Chapter 9. Adding Services to Domains"), *Adding Services
    to Domains*; we will fix this. Because of this, the policy we author now will
    address both cases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在串行控制台shell和`adb` shell之间的差异，在[第9章](ch09.html "第9章. 将服务添加到域")*将服务添加到域*中，我们将修复这个问题。因此，我们现在编写的策略将解决这两种情况。
- en: 'Start by opening the `sepolicy` file, `init_shell.te` and append the following
    to the end of the file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`sepolicy`文件，`init_shell.te`，并在文件的末尾添加以下内容：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do this for the `sepolicy` file, `shell.te`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对`sepolicy`文件，`shell.te`执行以下操作：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to declare the new type; so open up the `sepolicy` file, `file.te`
    and append the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要声明新类型；因此，打开`sepolicy`文件，`file.te`，并在末尾添加以下内容：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that we have only used the `file_type` attribute. This is because a filesystem
    should never have the type `ramdisk_newfile`, only a file residing within that
    file system should.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们只使用了`file_type`属性。这是因为文件系统不应该有`ramdisk_newfile`类型，只有位于该文件系统内的文件才应该有。
- en: 'Now, build the `adb` policy, push it to the device, and trigger a reload. With
    that done, create the file and check the results:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建`adb`策略，将其推送到设备上，并触发重新加载。完成这些操作后，创建文件并检查结果：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So it didn''t work. Let''s investigate the reason by trying on an example of
    an `ext4` filesystem. Let''s use the following commands:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它没有起作用。让我们通过尝试一个`ext4`文件系统的例子来调查原因。我们将使用以下命令：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, check its context:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查其上下文：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The label is `system_data_file`. This is not helpful, as it doesn''t apply
    to our type transition rule; to fix this, we can use the `chcon` command to explicitly
    change the files context:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是`system_data_file`。这并不有用，因为它不适用于我们的类型转换规则；为了修复这个问题，我们可以使用`chcon`命令显式地更改文件的上下文：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now with the context changed to match what we were trying earlier with the
    ramdisk, let''s try to create a file within this directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将上下文更改为与我们之前尝试的内存盘相匹配，让我们尝试在这个目录中创建一个文件：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see, the type transition has occurred. This was meant to illustrate
    the issues you may find while working with SELinux and Android. Now that we have
    shown that our `type_transition` statement is valid, there are only two possibilities
    why this is failing: the filesystem doesn''t support it or we''re missing something
    somewhere to "turn it on". It turns out that the latter is the case; we were missing
    our `fs_use_trans` statements. So go ahead and open up the `sepolicy` file, `fs_use`
    and add the following line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，类型转换已经发生。这是为了说明你在使用SELinux和Android时可能会遇到的问题。既然我们已经证明了我们的`type_transition`语句是有效的，那么失败只有两种可能：文件系统不支持它，或者我们在某个地方遗漏了“开启”它的内容。事实证明是后者；我们遗漏了`fs_use_trans`语句。那么打开`sepolicy`文件，`fs_use`并添加以下行：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This statement enables SELinux dynamic transitions on this filesystem. Now,
    rebuild the `sepolicy` project, `adb push` the policy file, and enable a dynamic
    reload via `setprop`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句在这个文件系统上启用了SELinux动态转换。现在，重建`sepolicy`项目，使用`adb push`推送策略文件，并通过`setprop`启用动态重载：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There you have it, the object has the right value determined by a dynamic type
    transition. We were missing `fs_use_trans`, which enabled type transitions on
    filesystems that don't support `xattrs`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，对象具有由动态类型转换确定的正确值。我们遗漏了`fs_use_trans`，它启用了不支持`xattrs`的文件系统上的类型转换。
- en: 'Now, suppose we want to mount another ramdisk, what would happen? Well since
    it was labeled with the `genfscon` statement, all filesystems mounted with that
    type should get the context, `u:object_r:ramdisk:s0`. We will mount this filesystem
    at `/ramdisk2`, and verify this behavior:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想挂载另一个内存盘，会发生什么？由于它被`genfscon`语句标记，所有使用该类型挂载的文件系统都应该得到上下文`u:object_r:ramdisk:s0`。我们将在`/ramdisk2`挂载这个文件系统，并验证这种行为：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, check the contexts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，检查上下文：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we want to write allow rules to separate accesses to these file systems,
    we will need to have their target files in separate types. To do this, we can
    mount the new ramdisk with the context option. But first, we need to create the
    new type; lets go to the `sepolicy` file, `file.te` and add a new type called
    `ramdisk2`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要编写允许规则以分隔对这些文件系统的访问，我们需要将它们的目标文件放在不同的类型中。为此，我们可以使用上下文选项挂载新的内存盘。但首先，我们需要创建新的类型；让我们打开`sepolicy`文件，`file.te`并添加一个名为`ramdisk2`的新类型：
- en: '[PRE45]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, build the `sepolicy` with the command `mmm`, followed be using the command
    `abd push` to push the policy, and trigger a reload with the `setprop` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用命令`mmm`构建`sepolicy`，然后使用命令`adb push`推送策略，并通过`setprop`命令触发重载：
- en: '[PRE46]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, let''s umount `/ramdisk2` and remount it with the `context=`
    option:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们卸载`/ramdisk2`并使用`context=`选项重新挂载它：
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, verify the contexts:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证上下文：
- en: '[PRE48]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can override the `genfscon` context with the `mount` option, `context=<context>`.
    In fact, if we look at `dmesg`, we can see some great messages. When we mounted
    `ramfs` without the context option, we got:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`mount`选项`context=<context>`覆盖`genfscon`上下文。实际上，如果我们查看`dmesg`，我们可以看到一些很好的信息。当我们没有使用上下文选项挂载`ramfs`时，我们得到了：
- en: '[PRE49]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we mounted it with the `context=<context>` option, we got:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`context=<context>`选项挂载它时，我们得到了：
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can see that SELinux gives us some helpful messages while trying to figure
    out from where it sources its labels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当SELinux试图找出其标签来源时，它给出了一些有用的信息。
- en: Now, let's go onto labeling filesystems with the `xattr` support, such as `ext4`.
    We will start with the toolbox command, `chcon`. The `chcon` command allows you
    to set the context of a file system object explicitly, it does not consult `file_contexts`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始给支持`xattr`的文件系统，如`ext4`打标签。我们将从工具箱命令`chcon`开始。`chcon`命令允许你显式地设置文件系统对象的上下文，它不会咨询`file_contexts`。
- en: 'Let''s take a look at `/system/bin` and in it, at the first 10 files:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`/system/bin`目录，以及其中的前10个文件：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can see that many of them have the `system_file` label, which is the default
    label for that filesystem; let''s change the `am` type to `am_exec`. Again, we
    need to create a new type by adding the following to `sepolicy` file, `file.te`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，其中许多文件都有`system_file`标签，这是该文件系统的默认标签；让我们将`am`类型更改为`am_exec`。同样，我们需要通过向`sepolicy`文件`file.te`中添加以下内容来创建一种新类型：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, rebuild the policy file, push it to the UDOO, and trigger a reload. After
    that, let''s start remounting the system, since it is read only:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新构建策略文件，将其推送到UDO，并触发重新加载。之后，让我们开始重新挂载系统，因为它是只读的：
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now perform `chcon`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行`chcon`：
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Verify the result:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 验证结果：
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Additionally, the `restorecon` command will use `file_contexts`, and restore
    that file to what is set in the `file_contexts` file, which should be `system_file`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`restorecon`命令将使用`file_contexts`，并将该文件恢复为`file_contexts`文件中设置的内容，这应该是`system_file`：
- en: '[PRE56]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, `restorecon` was able to consult `file_contexts` and restore
    the specified context on that object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`restorecon`能够咨询`file_contexts`并恢复该对象的指定上下文。
- en: 'The Android system''s filesystem gets constructed during the build time, and
    consequently, all its file objects are labeled during that process. We can also
    change this at build time by changing `file_contexts`. With this changed, the
    system partition rebuilt, and after reflashing the system, we should see the `am`
    file with the `am_exec` type. We can test this by amending the `sepolicy` file,
    `file_contexts` by adding this line at the end of the `system/bin` section:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统的文件系统在构建时进行构造，因此，其所有文件对象在此过程中都被标记。我们还可以在构建时通过更改`file_contexts`来更改这一点。更改后，重新构建系统分区，并在重新刷新系统后，我们应该会看到具有`am_exec`类型的`am`文件。我们可以通过在`system/bin`部分的末尾添加这一行来修改`sepolicy`文件`file_contexts`进行测试：
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Rebuild the whole system with:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重新构建整个系统：
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now flash and reboot, and let''s take a look at the `/system/bin/am` context
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新并重启，然后让我们按照以下方式查看`/system/bin/am`的上下文：
- en: '[PRE59]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This shows that the system partition respects the file contexts for build-time
    labeling, and how we can control these labels.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明系统分区尊重构建时的文件上下文标记，以及我们如何控制这些标签。
- en: Fixing up /data
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复`/data`
- en: 'Additionally in the audit logs, we have seen a bunch of unlabeled files, for
    instance, the following denial:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在审计日志中，我们还发现了一堆未标记的文件，例如下面的拒绝访问记录：
- en: '[PRE60]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can see that the device is `mmcblk0p4`, which mount commands and will tell
    us what filesystem this is mounted to, in its output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到设备是`mmcblk0p4`，挂载命令会告诉我们这个文件系统挂载到了哪里，其输出如下：
- en: '[PRE61]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So why does the `/data` filesystem have so many unlabeled files? The reason
    is that SELinux is meant to be turned on from an empty device, that is, from first
    boot. Android builds the data directory structures on demand. Thus, all the labels
    for the `/data` are handled by the `file_contexts` file since it is `ext4`. Also,
    it is handled by the systems that create the `/data` files and directories. These
    systems have been modified to label the data partition based on the `file_contexts`
    specifications. So this presents two options: wipe `/data` and reboot, or `restorecon
    -R /data`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`/data`文件系统为什么有这么多未标记的文件呢？原因是SELinux应该从空设备开始启用，即从第一次启动时。Android按需构建数据目录结构。因此，由于它是`ext4`，所有`/data`的标签都由`file_contexts`文件处理。同时，这些由创建`/data`文件和目录的系统处理。这些系统已经被修改为根据`file_contexts`规范对数据分区进行标记。因此，这里有两个选择：擦除`/data`并重启，或者执行`restorecon
    -R /data`。
- en: Option one is a bit harsh, but if you eject the SD card and remove all the files
    on the data partition, `partition 4`, Android will rebuild and you won't see any
    more unlabeled issues. However, this is not recommended for deployed devices when
    you upgrade; you will destroy all of the users' data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项有点激烈，但如果你弹出SD卡并删除数据分区`partition 4`上的所有文件，Android将重新构建，你就不会再看到任何未标记的问题。然而，对于升级时的已部署设备，这并不推荐；你将破坏所有用户的数据。
- en: 'Option two is more palatable in deployed scenarios, but has its limitations.
    Notably, executing `restorecon -R /data` will take a long time and must be done
    early in boot, right after the mount. However, this is really the only option
    at this point. Google, however, has done a lot of work in this area, and created
    a system that intelligently relabels `/data` on policy updates. For our use, we
    will choose a variant of option two, especially after considering how sparsely
    populated the `/data` filesystem is; we really haven''t installed or generated
    a lot of user data yet. With that stated, execute:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署场景中，第二个选项更受欢迎，但也有其局限性。特别是，执行`restorecon -R /data`将花费很长时间，并且必须在启动早期，在挂载之后立即进行。然而，目前这确实是唯一的选择。不过，谷歌在这一领域做了大量工作，并创建了一个系统，可以在策略更新时智能地重新标记`/data`。考虑到我们的使用情况，我们将选择第二个选项的一个变体，尤其是考虑到`/data`文件系统的稀疏性；我们实际上还没有安装或生成大量用户数据。基于这一点，执行：
- en: '[PRE62]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We don''t have to execute `restorecon` early in boot since our system is in
    permissive mode, and we''re not in a deployed scenario. Now, let''s pull the `audit.log`
    file and compare it to the already pulled `audit.log`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的系统处于宽容模式，且不在部署场景中，因此我们无需在启动早期执行`restorecon`。现在，让我们拉取`audit.log`文件，并将其与已拉的`audit.log`进行比较：
- en: '[PRE63]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s use `grep` to count the number of occurrences in each file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`grep`来计算每个文件中出现的次数：
- en: '[PRE64]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great, we fixed up all of our unlabeled issues on `/data`!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们已经修复了`/data`上的所有未标记问题！
- en: A side note on security
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于安全的补充说明
- en: 'Note that even though we are running all these commands and changing all these
    things, this is not a security vulnerability within SELinux. Being able to change
    type labels, mounting filesystems, and associating filesystems with a type, all
    require allow rules. If you look through the audit logs, you''ll see a slew of
    denials; a sample is provided:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们运行了所有这些命令并更改了所有这些内容，但这并不是SELinux中的安全漏洞。更改类型标签、挂载文件系统以及将文件系统与类型关联，都需要允许规则。如果你查看审核日志，你会看到一系列的拒绝记录；以下是一个示例：
- en: '[PRE65]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If we were in an enforcing mode, we wouldn't have been able to perform any of
    the experiments shown here.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于强制模式，我们将无法执行这里展示的任何实验。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to get files into contexts by relabeling them. We
    used a variety of techniques to accomplish this task, from toolbox commands such
    as `chcon` and `restorecon`, to mount options and dynamic transitions. With these
    tools, we can ensure that all filesystem objects are labeled correctly. This way,
    we end up with the right target contexts so that the policies we author are effective.
    In the next chapter, we will focus on the processes, making sure that they are
    in the right domain or context.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何通过重新标记文件将文件放入上下文中。我们使用了各种技术来完成这项任务，从工具箱命令如`chcon`和`restorecon`，到挂载选项和动态转换。有了这些工具，我们可以确保所有文件系统对象都被正确标记。这样，我们最终得到了正确的目标上下文，以便我们编写的策略能够有效。在下一章中，我们将关注进程，确保它们处于正确的域或上下文中。
