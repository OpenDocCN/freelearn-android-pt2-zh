- en: Chapter 8. Designing Content-centric Activities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 设计内容中心式活动
- en: '*When you have a lot of data to display to the user, and you need a content
    presentation `Activity`. Generally, such types of Activities turn out to be content-centric.
    The main purpose of a content-centric `Activity` is to give the user as much of
    the information as possible while not overwhelming them. This is a common requirement
    of applications that perform some sort of search, or present any type of specialized
    information.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*当您需要向用户展示大量数据，并且需要一个内容展示`Activity`时，通常这类Activity会变成以内容为中心的。内容中心式`Activity`的主要目的是在不过度压倒用户的情况下向用户提供尽可能多的信息。这是执行某种搜索或展示任何类型专业信息的应用程序的一个常见要求。*'
- en: Shopping and related e-commerce applications are an ideal example of a content-centric
    application. Much of the effort in the design is dedicated to displaying information
    about the products on sale. If the users can't find the information about a product
    they are looking for, they will look somewhere else. For this reason, the product
    display must not only be attractive and easy to use, but also provide as much
    information as possible, without being cryptic or cluttered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 购物及相关电子商务应用是内容中心式应用的一个理想示例。在设计过程中，大部分努力都致力于展示有关在售产品的信息。如果用户无法找到他们想要的产品信息，他们就会去其他地方寻找。因此，产品展示不仅要吸引人、易于使用，还必须尽可能提供更多信息，同时避免晦涩难懂或杂乱无章。
- en: Another example of a content-centric layout is a user's profile page in a social-networking
    application. People generally have a lot to say about themselves, and if they
    don't, other people will often say a lot about them. These applications not only
    have a lot of information to present to the user, but the information varies widely
    in terms of quality and relevance. Just because one user thinks something is important,
    doesn't mean the next person will. In cases like these, it's also very important
    to have an interface that can be customized to the user's preferences (often just
    by re-organizing the order in which information is displayed), and is also able
    to draw the user's attention to new information or areas they may find interesting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个内容中心式布局的示例是社交网络应用中的用户个人资料页面。人们通常有很多关于自己的话要说，如果没有，其他人也经常会说很多关于他们的话。这些应用不仅需要向用户展示大量信息，而且信息的质量和相关性也大不相同。仅仅因为一个用户认为某件事很重要，并不意味着下一个人也会这么认为。在这些情况下，拥有一个可以根据用户偏好定制的界面（通常只需重新组织信息展示的顺序）也非常重要，同时还能吸引用户的注意力到他们可能感兴趣的新信息或区域。
- en: A great example of a good way to draw a user's attention is seen in a chat application.
    If the user has scrolled up, he/she is probably reading something that was said
    a few minutes ago. If a new message arrives, it's very rude to just scroll them
    to the new message, since they may well still be reading it. An audio tone to
    notify them of a new message is a common option, but will also draw others' attention
    to the user (this is a mobile device after all). The best option is a small animated
    icon at the bottom of the screen, possibly color-coded to tell the user the relevance
    of the message (if that is available). Such an icon could also be an interactive
    element, allowing the user to touch it in order to automatically scroll to the
    most recently posted message. This type of thinking is important when designing
    any application, but when building a content-centric `Activity,` putting some
    extra thought into your design is even more critical.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个吸引用户注意的好方法的绝佳示例可以在聊天应用程序中看到。如果用户向上滚动，他/她可能正在阅读几分钟前说过的内容。如果此时收到一条新消息，直接将他们滚动到新消息是非常不礼貌的，因为他们可能还在阅读旧消息。用音频提示通知他们有新消息是一种常见的选择，但这也会吸引其他人对用户的注意（毕竟这是移动设备）。最佳选择是在屏幕底部显示一个小型动画图标，可能通过颜色编码来告诉用户消息的相关性（如果有的话）。这样的图标也可以是交互式元素，允许用户点击它以自动滚动到最近发布的信息。这种思维方式在设计任何应用程序时都很重要，但在构建以内容为中心的`Activity`时，在设计上多花一些心思更为关键。
- en: 'In this chapter, we''ll be exploring the different aspects to consider when
    displaying content to the user, as well as different ways in which content screens
    can be developed. Specifically, we''ll be exploring:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在向用户展示内容时需要考虑的不同方面，以及内容屏幕可以开发的多种方式。具体来说，我们将探讨：
- en: Thought process when designing content displays on Android
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计Android内容展示时的思考过程
- en: How users use and view content screens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户如何使用和查看内容屏幕
- en: Using the `WebView` class to display content
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WebView`类来显示内容
- en: Building native layouts for displaying content
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于显示内容的原生布局
- en: Formatting and styling text in Android
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android中格式化和样式化文本
- en: Drawing attention to specific areas of the screen
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导用户注意屏幕的特定区域
- en: Considering design options when displaying content on an Android device
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android设备上显示内容时考虑设计选项
- en: A content-centric `Activity` bears a strong resemblance to a web page, but has
    some key design considerations that people don't have in mind when creating a
    web page. For example, a touchscreen device generally doesn't have a software
    pointer, and so doesn't have any concept of a "roll over". However, many web pages
    are built using cursor roll over to drive everything from link highlighting to
    menus.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以内容为核心的`Activity`与网页非常相似，但在设计上有一些关键考虑因素，这些是人们在创建网页时不会考虑到的。例如，触摸屏设备通常没有软件指针，因此没有“悬停”的概念。然而，许多网页是利用光标悬停来驱动从链接高亮到菜单的一切操作。
- en: When designing a content-centric `Activity`, you'll want to consider carefully
    the aesthetics of your design. The screen should avoid clutter since many elements
    may be interactive, presenting the user with additional information when touched.
    At the same time, you should attempt to minimize the need to scroll, especially
    horizontal scrolling. The need to keep information concise is often the motivator
    to make more of the elements interactive. As mentioned in previous chapters, it's
    a good idea to consider using icons instead of text where you can, and to organize
    the information in order of importance to the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计以内容为核心的`Activity`时，你需要仔细考虑设计的美观性。屏幕应避免杂乱，因为许多元素可能是可交互的，当用户触摸时会呈现附加信息。同时，你应尽量减少滚动的需要，尤其是水平滚动。保持信息简洁通常是使更多元素可交互的驱动力。如前几章所述，考虑在可能的地方使用图标代替文字，并按照对用户的重要性组织信息。
- en: Also bear in mind that screen-sizes change. Some devices have a large number
    of pixels (such as the various Android Tablets), while others have tiny 3.5 inch
    screens. For this reason it's important to consider that while some people will
    be able to see all of the presented information on a single screen, others will
    be presented with three or four screens worth of content for the same amount of
    information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑到屏幕尺寸的变化。一些设备拥有大量像素（如各种Android平板电脑），而其他设备则只有3.5英寸的小屏幕。因此，考虑到一些人可以在一个屏幕上看到所有展示的信息，而其他人可能需要三个或四个屏幕来显示相同数量的内容，这是非常重要的。
- en: A web page is a great way to quickly and easily put together a content-centric
    layout when working on an Android application. It has the advantage of having
    great HTML and CSS support from WebKit, and easy integration with the rest of
    your application. It can also be handled by an existing web-designer, or even
    just display a web page if your application is connected to a web-based system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Android应用程序中工作时，网页是快速轻松地构建以内容为中心的布局的好方法。它具有WebKit对HTML和CSS的出色支持以及与应用程序其他部分轻松集成的优势。它还可以由现有的网页设计师处理，或者如果应用程序连接到基于网页的系统，甚至只需显示一个网页。
- en: 'A web page is however constrained (to some degree) to the layout structures
    dictated in HTML and CSS. While these are extremely flexible at one level, HTML
    and CSS layout development can also be a tedious and frustrating process even
    when only targeting a single rendering engine (in Android''s case: WebKit), if
    you are not used to building web-based systems. When it comes to animations and
    similar structures, you are further constrained by the performance of the HTML
    rendering engine, whether using JavaScript or CSS3 animations.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，网页在某种程度上受到HTML和CSS布局结构的限制。虽然这些在一级上非常灵活，但如果你不习惯于构建基于网页的系统，即使是针对单一的渲染引擎（在Android的案例中是WebKit），HTML和CSS布局开发也可能是一个繁琐和令人沮丧的过程。当涉及到动画和类似结构时，你还会受到HTML渲染引擎性能的进一步限制，无论使用JavaScript还是CSS3动画。
- en: Considering user behavior
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑用户行为
- en: As with any type of user interface, it's important to understand your user behavior
    and how they will interact with the screens you provide them with. In the context
    of large amount of content information, it's important to understand both what
    information is important, and how users will read and absorb that information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何类型的用户界面一样，了解用户的行为以及他们如何与你提供的屏幕互动非常重要。在大量内容信息的情况下，了解哪些信息是重要的，以及用户如何阅读和吸收这些信息至关重要。
- en: While you may want to draw attention to a selected piece of information (such
    as price), running a looping animation to change the color of that element will
    distract the user from the other information on the screen. However, simply changing
    the font, placing the data in a box, or changing the text color can also have
    the desired effect. It's also important to consider how a user will interact with
    the screen. On a touchscreen device, users can and will touch almost every part
    of the screen. They'll also drag items that look movable, and use scroll gestures
    if the content appears to run over the screen length.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然你可能想要吸引用户注意某个选定的信息（如价格），但运行一个循环动画来改变该元素的颜色会分散用户对屏幕上其他信息的注意力。然而，简单地改变字体、将数据放在框内，或者改变文字颜色也可以达到预期的效果。同时，考虑用户如何与屏幕互动也很重要。在触摸屏设备上，用户几乎会触摸屏幕的每一个部分。他们还会拖动看起来可以移动的项，如果内容看起来超出了屏幕长度，他们也会使用滚动手势。 '
- en: Most people scan information in the same way. When a user is presented with
    a screen for the first time, or with lots of information on it, their minds approach
    reading the information in more-or-less the same way. The following are illustrations
    of the various movement patterns a user's eyes will follow when scanning for important
    information on the screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人以相同的方式扫描信息。当用户第一次看到一个屏幕，或者屏幕上有大量信息时，他们阅读信息的方式大致相同。以下是用户在屏幕上寻找重要信息时眼睛会遵循的各种移动模式的说明。
- en: '![Considering user behavior](img/4484OS_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![考虑用户行为](img/4484OS_08_01.jpg)'
- en: You'll generally want to make sure that important information is in the areas
    where one arrow meets another. The most important area is the corner in which
    your user normally starts reading. For most Western users, this is the top-left
    corner of the screen, while Asian and Arab users will often start at the top-right.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常需要确保重要信息位于一个箭头与另一个箭头相遇的区域。最重要的区域是用户通常开始阅读的角落。对于大多数西方用户来说，这是屏幕的左上角，而亚洲和阿拉伯用户经常会从右上角开始。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: When designing a content screen, consider making the information in these areas
    stand out a little more than normal. This will create a "linger" time where the
    users' eyes will generally focus on that area a little longer than normal. This
    is why we normally put a logo on the top-left of a web page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计内容屏幕时，可以考虑让这些区域的信息比正常情况下更加突出。这将产生一个“停留”时间，用户的眼光通常会在这个区域上比平时停留得更久一些。这就是为什么我们通常会在网页的左上角放置一个标志的原因。
- en: Drawing user attention
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 吸引用户注意
- en: Almost always, some information is more important than other information. You
    want your user to be able to pick-out the important information as quickly as
    possible, and get on with what they are doing. Once a person is familiar with
    your application, they may well stop reading the fine print altogether. This is
    a good thing, you're helping your users make better use of your application by
    letting them get on with their lives.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，某些信息比其他信息更重要。你希望用户能够尽可能快地识别出重要信息，并继续他们正在做的事情。一旦用户熟悉了你的应用，他们很可能会完全停止阅读细则。这是一件好事，你通过让用户继续他们的生活，帮助他们更好地使用你的应用。
- en: When you need to draw attention to specific information, such as a product's
    name or price, it's a good idea to make use of the extensive options provided
    by the `TextView` class. Simply changing an item's color can make it stand out
    for the user. If you need to go further, consider adding a shadow, or placing
    the content in a "highlight box". As we've already discussed in [Chapter 7](ch07.html
    "Chapter 7. Animating Widgets and Layouts"), *Animating Widgets and Layouts*,
    animations can also be used to draw attention to specific areas of the user interface.
    A simple "blink" animation (consisting of a fade-out followed by a fade-in animation)
    can be used to draw the users' attention to a change.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要吸引用户注意特定信息，如产品名称或价格时，利用`TextView`类提供的广泛选项是一个好主意。简单地改变一个项目的颜色就可以让用户注意到它。如果你需要更进一步，可以考虑添加阴影，或者将内容放在“高亮框”中。正如我们在[第7章](ch07.html
    "第7章. 动画小部件和布局") *动画小部件和布局*中已经讨论过的，动画也可以用来吸引用户界面的特定区域。一个简单的“闪烁”动画（由淡出后紧跟淡入动画组成）可以用来吸引用户注意变化。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A more specific example: money**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个更具体的例子：金钱**'
- en: If you are selling something to your user, and allowing them to choose between
    different shipping methods and packaging options, the total price will change
    based on their selections. Make sure that the total amount stands out by rendering
    it in a bold font. When the price is updated, cycle through a series of "intermediate"
    prices so that the total is graphically "counted up" or "counted down" to its
    new value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向用户销售产品，并允许他们选择不同的运输方式和包装选项，那么根据他们的选择，总价会发生变化。确保通过加粗字体使总价突出显示。当价格更新时，通过一系列的“中间”价格循环显示，以便总价的图形“递增”或“递减”到新值。
- en: Think carefully about the widgets that you'll want to make use of in your user
    interface. Instead of using the normal `TextView`, you may well want to place
    a piece of what would normally be a single field in a `TextSwitcher` (or something
    similar) to allow you to animate a single word or value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑你希望在用户界面中使用的控件。你可能会选择将通常为单一字段的文本放入 `TextSwitcher`（或类似控件）中，以便对单个单词或值进行动画处理，而不是使用常规的`TextView`。
- en: Displaying content with the WebView class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `WebView` 类显示内容
- en: The `WebView` class (in the `android.webkit` package) is often a logical choice
    for content-centric designs and holds some very serious advantages over building
    the user interface and a normal Android XML layout resource. The `WebView` class
    offers you a single point at which you can place all of the content for a screen,
    and it handles all of its own history and scrolling, making your code very simple
    to write.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView` 类（位于 `android.webkit` 包中）通常是基于内容的设计逻辑选择，并且与构建用户界面和常规的Android XML布局资源相比，具有非常明显的优势。`WebView`
    类提供了一个单独的入口，你可以在这里放置屏幕的所有内容，它自行处理历史记录和滚动，使得你的代码非常易于编写。'
- en: When displaying content that requires complex layout and/or lots of text content
    (which may require markup), the `WebView` class is a highly favorable option.
    Having built-in support for HTML and CSS mark up, it reduces the number of widgets
    that you'll need on the screen. Given that Android makes use of Web-Kit as a rendering
    engine, you also have many CSS3 structures available (such as CSS animations).
    Although the `WebView` is generally used for browser like networked applications
    where hyperlinks are very important, you can just as easily supply it with local
    content containing no links. You can also intercept link requests to allow navigation
    to other parts of your application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示需要复杂布局和/或大量文本内容（可能需要标记）的内容时，`WebView` 类是一个非常好的选择。它内置支持HTML和CSS标记，减少了屏幕上所需的控件数量。鉴于Android使用Web-Kit作为渲染引擎，你还可以使用许多CSS3结构（如CSS动画）。尽管
    `WebView` 通常用于类似浏览器的网络应用，其中超链接非常重要，但你也可以轻松地为其提供不包含链接的本地内容。你还可以拦截链接请求，以允许导航到应用程序的其他部分。
- en: Generally when working with a `WebView` structure, you'll need some method by
    which you can generate the content that you will be displaying. In contrast to
    building the user interface in a layout resource, where you can simply ID the
    various `View` objects that you need to inject dynamic content into. That said,
    a full template engine is often much easier to work with than a hybrid of XML
    layout and Java code, although the ease of implementation is strongly dependant
    on both the skills available to you and the type of information you need to display
    on the screen.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在使用 `WebView` 结构时，你需要某种方法来生成你将要显示的内容。与在布局资源中构建用户界面不同，你可以简单地为需要注入动态内容的各种 `View`
    对象分配ID。也就是说，完整的模板引擎通常比XML布局和Java代码的混合更容易使用，尽管实施的难易程度强烈依赖于你拥有的技能以及需要在屏幕上显示的信息类型。
- en: Using a WebView object
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `WebView` 对象
- en: To work a bit with the `WebView` and give a more specific example on how it
    can be used to present large amounts of content, we'll be building an `Activity`
    to display a food recipe on the screen. For this example we'll be hard coding
    the actual recipe and the layout code to generate the HTML. In practice, you would
    want to make use of a template engine such as Velocity/FreeMarker or XSLT to generate
    the HTML code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 `WebView` 进行一些操作，并给出一个更具体的示例，说明如何使用它来呈现大量内容，我们将构建一个 `Activity` 来在屏幕上显示食谱。在这个例子中，我们将硬编码实际的食谱和布局代码以生成HTML。实际上，你会希望使用如Velocity/FreeMarker或XSLT这样的模板引擎来生成HTML代码。
- en: Time for action – creating a recipe viewer application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——创建食谱查看器应用
- en: You'll notice that the following example doesn't use an XML layout resource,
    but rather creates the entire `Activity` in Java. In this example we use a `Recipe`
    object to generate HTML code into a `StringBuilder` for display. It's a simple
    but effective implementation. However, it requires that the Java code be modified
    if a change to the look and feel of the recipe is required.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，以下示例没有使用XML布局资源，而是完全在Java中创建了 `Activity`。在此示例中，我们使用 `Recipe` 对象生成HTML代码到
    `StringBuilder` 以显示。这是一个简单但有效的实现。然而，如果需要更改食谱的外观和感觉，它要求修改Java代码。
- en: 'Create a new project to contain the recipe reader application:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目以包含食谱阅读器应用程序：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a new `Ingredient.java` source file in the root package of the new application
    to hold information for a single required ingredient, and open this new file in
    your editor or IDE.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用程序的根包中创建一个新的 `Ingredient.java` 源文件，以保存单个所需成分的信息，并在你的编辑器或IDE中打开这个新文件。
- en: 'Declare fields for the `name`, `amount`, and `unit` required for a recipe:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `name`、`amount` 和 `unit` 字段，这些字段对于食谱是必需的：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a constructor to take the parameters and assign them to the fields:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数以接收参数并将它们赋值给字段：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a getter method for each of fields:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个字段创建一个获取器方法：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the root package of the project, create a new source file named `Recipe.java`
    to contain a single recipe, and open it in your editor or IDE.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根包中，创建一个名为 `Recipe.java` 的新源文件以包含一个单独的食谱，并在编辑器或IDE中打开它。
- en: 'Declare a field for the name of the `Recipe` object:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个字段用于 `Recipe` 对象的名称：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare another field to contain the list of ingredients required for this
    `Recipe`. We store these as an array of `Ingredient` objects:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明另一个字段以包含此 `Recipe` 所需的成分列表。我们将这些作为 `Ingredient` 对象的数组存储：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then declare an array of `String` objects that will contain the list of instructions
    that need to be followed for the `Recipe`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后声明一个 `String` 对象数组，该数组将包含需要遵循的 `Recipe` 指令列表：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a constructor to accept the field data and assign it for storage:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数以接受字段数据并将其赋值以存储：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a getter method for each of the three fields:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这三个字段创建一个获取器方法：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example the `Recipe` class is responsible for generating the HTML.
    Declare a new method named `toHtml`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，`Recipe` 类负责生成HTML。声明一个名为 `toHtml` 的新方法：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `DecimalFormat` object to handle the formatting of the volumes:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `DecimalFormat` 对象以处理体积的格式化：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new `StringBuilder` object to build the HTML into:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `StringBuilder` 对象以构建HTML：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Append the HTML headers:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追加HTML标题：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Append a first-level header element with the name of the recipe:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追加一个一级标题元素，其中包含食谱的名称：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Append a second-level header element to open the `ingredients` section:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追加一个二级标题元素以打开 `ingredients` 部分：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open an unordered list to list the ingredients required for the recipe:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个无序列表以列出食谱所需的成分：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For each `Ingredient` object open a list item for the new ingredient:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个 `Ingredient` 对象，为新的成分打开一个列表项：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Append the amount of the ingredient to the `StringBuilder` after formatting
    it with the `DecimalFormat` declared:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用声明的 `DecimalFormat` 格式化后，将成分的量追加到 `StringBuilder`：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then append the measurement unit for the ingredient:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后追加成分的测量单位：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now append the name of the ingredient to the `StringBuilder`, and close the
    `ingredient` list item:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将成分的名称追加到 `StringBuilder`，并关闭 `ingredient` 列表项：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After closing the for loop, close the unordered list:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭for循环后，关闭无序列表：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a second-lever header opening the `Instructions` section of the recipe:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个二级标题，打开食谱的 `Instructions` 部分：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open another unordered list to render the recipe instructions into:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个无序列表以将食谱指令渲染其中：
- en: '[PRE22]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use a for-each loop over the array of instructions to render them into the
    unordered list structure in the `StringBuilder`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用for-each循环遍历指令数组，将它们渲染成 `StringBuilder` 中的无序列表结构：
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Close the unordered list, and HTML headers, returning the `String` contents
    of the `StringBuilder` object:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭无序列表和HTML标题，返回 `StringBuilder` 对象的 `String` 内容：
- en: '[PRE24]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the `ViewRecipeActivity` Java source code in your editor or IDE.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器或IDE中打开 `ViewRecipeActivity` Java 源代码。
- en: 'In the `onCreate` method, directly after invoking `super.onCreate`, create
    a new `WebView` object passing `this` to it as its `Context`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中，在调用 `super.onCreate` 之后，创建一个新的 `WebView` 对象，将 `this` 作为它的 `Context`
    传递给它：
- en: '[PRE25]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set the `WebView LayoutParams` to take up all available screen space, since
    the `WebView` (much like a `ListView`) has built-in scrolling capabilities:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WebView LayoutParams`设置为占用所有可用的屏幕空间，因为`WebView`（与`ListView`类似）具有内置的滚动功能：
- en: '[PRE26]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a `Recipe` object to display in the `WebView`, the full recipe is at
    the end of this example section:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Recipe`对象以在`WebView`中显示，完整的食谱在本示例部分末尾：
- en: '[PRE27]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Load the HTML content generated by the `Recipe` object into the `WebView`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将由`Recipe`对象生成的HTML内容加载到`WebView`中：
- en: '[PRE28]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set the content view of the `Activity` to the `WebView` object we created:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Activity`的内容视图设置为创建的`WebView`对象：
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The recipe viewer example shows a simple structure which can be extended in
    many different ways to present large amounts of information to the user in an
    easy-to-use format. Thanks to the fact that `WebView` works with HTML, it makes
    presenting non-interactive lists of information more appealing than working with
    a `ListView` or similar structures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱查看器示例显示了一个简单的结构，可以通过多种不同的方式扩展，以易于使用的格式向用户呈现大量信息。由于`WebView`与HTML一起工作，使得呈现非交互式信息列表比使用`ListView`或类似结构更具吸引力。
- en: The `loadData` method used previously is limited in that it doesn't allow for
    your page to easily reference external structures such as style sheets or images.
    You can work around this limitation by using the `loadDataWithBaseURL` method
    which works in much the same way, but renders the page relative to a specified
    URL, which may be online or local on the device.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的`loadData`方法有限制，它不允许页面轻松引用外部结构，如样式表或图片。你可以通过使用`loadDataWithBaseURL`方法来绕过这个限制，该方法与`loadData`类似，但会相对于指定的URL渲染页面，该URL可能是线上的或设备本地的。
- en: 'The `Recipe` object is considered responsible for rendering its HTML, which
    works well in a pure Java situation. You could also pass the `Recipe` to a template
    engine, or use something like a visitor pattern to render the `Recipe` object
    as HTML code. The full code for the `Recipe` object in the previous example is
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recipe`对象被认为负责渲染其HTML，这在纯Java情况下工作良好。你也可以将`Recipe`传递给模板引擎，或者使用访问者模式将`Recipe`对象渲染为HTML代码。上一个示例中`Recipe`对象的完整代码如下：'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An unfortunate side effect of using the `WebView` object is that it doesn''t
    conform to the look and feel of other widgets. It is for this reason it doesn''t
    work well when you place it with other widgets on the same screen. The end effect
    of the previous example is effectively a non-interactive web page which looks
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WebView`对象的 一个不利的副作用是它不符合其他小部件的外观和感觉。这就是当你将其与其他小部件放在同一屏幕上时，它不能很好地工作的原因。上一个示例的最终效果实际上是一个非交互式的网页，如下所示：
- en: '![What just happened?](img/4484_08_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_08_02.jpg)'
- en: Have a go hero – improving the look of the recipe viewer
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手英雄——改进食谱查看器的观感
- en: 'The previous example generates a very simple HTML page and doesn''t include
    any styling. Including an inline CSS is a very simple operation, and could even
    be done by reading the styling content from an application resource. Create a
    CSS, include it inline in the HTML page, with rules such as:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例生成了一个非常简单的HTML页面，并且没有包含任何样式。内联包含CSS是一个非常简单的操作，甚至可以通过从应用资源中读取样式内容来完成。创建一个CSS，将其内联包含在HTML页面中，并包含如下规则：
- en: Color the background of first-level header and second-level header elements
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一级标题和二级标题元素背景颜色
- en: Change the font-color of the first and second-level headers to white
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一级标题和二级标题的字体颜色改为白色
- en: Round the corners of the header elements by five pixels
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将头部元素的圆角设置为五个像素
- en: Change the list bullet to a square instead of a circle
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表项目符号从圆形改为方形
- en: Taking WebView further
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步使用WebView
- en: The `WebView` class has significant functionality that can be very useful when
    dealing with content screens, for example, using hyperlinks to provide a **show**/**hide**
    disclosure section for less important content. This requires the use of JavaScript
    in the HTML page, at which point it's strongly advisable that your application
    use a template engine to produce the HTML pages instead of generating them in
    Java code (as the Java code will quickly become difficult to maintain).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView`类具有非常重要的功能，在处理内容屏幕时非常有用，例如，使用超链接为不太重要的内容提供一个**显示**/**隐藏**的披露部分。这需要HTML页面中使用JavaScript，此时强烈建议你的应用程序使用模板引擎来生成HTML页面，而不是在Java代码中生成（因为Java代码将很快变得难以维护）。'
- en: The `WebView` class also allows your application to interact with the JavaScript
    code on the page using a very simple mechanism by which you can expose Java objects
    to the JavaScript code. This is done with the `addJavascriptInterface` method.
    This allows the HTML page to invoke actions on a Java object that you provide,
    effectively allowing the page to take control of a part of your application. If
    your content screen needs to take a business action, such as **Buy** or **Cancel**,
    the required functionality can be exposed in a JavaScript interface object. When
    the **Book** HTML element is selected by the user, the JavaScript in the page
    can invoke the `appInterface.buy();` method which you defined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView`类还允许你的应用程序通过一种非常简单的机制与页面上的JavaScript代码交互，你可以通过这种方式将Java对象暴露给JavaScript代码。这是通过`addJavascriptInterface`方法实现的。这样，HTML页面就可以调用你提供的Java对象上的动作，从而有效地允许页面控制你应用程序的一部分。如果你的内容屏幕需要执行诸如**购买**或**取消**的业务动作，可以在JavaScript接口对象中公开所需的功能。当用户选择**书籍**HTML元素时，页面中的JavaScript可以调用你定义的`appInterface.buy();`方法。'
- en: 'Another important feature to consider with the `WebView` class is the "zoom"
    controls. When presenting your user with lots of information, it may be useful
    for the user to be able to zoom in or out in order to make some elements easier
    to read. To enable the built-in zoom controls of the `WebView`, you''ll need to
    access the `WebSettings` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑`WebView`类时，另一个重要的特性是“缩放”控件。当向用户展示大量信息时，用户可能需要放大或缩小以使某些元素更容易阅读。要启用`WebView`的内置缩放控件，你需要访问`WebSettings`对象：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `WebSettings` object can be used to enable and disable a large number of
    other features that are available in the WebKit browser component, and it's well
    worth reading through the available documentation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSettings`对象可以用来启用和禁用WebKit浏览器组件中可用的许多其他功能，阅读可用的文档是非常值得的。'
- en: The primary problem with the `WebView` class is its look and feel. Where an
    Android application with the default theme is light grey on a black background,
    the `WebView` class is black on a white background, which makes the screens driven
    by a `WebView` stand out to the user as though they are a separate application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView`类的主要问题是它的外观和感觉。默认主题的Android应用程序在黑色背景上是浅灰色，而`WebView`类在白色背景上是黑色，这使得由`WebView`驱动的屏幕在用户看来就像是一个单独的应用程序。'
- en: The simplest way around the styling problem would appear to be to style the
    HTML pages to look just like the rest of the application. The problem is that
    some device manufacturers have their own Android application styling, so you can't
    really be sure what the rest of your application is going to look like. Changing
    the background and foreground of the HTML page to be in line with the standard
    Android theme could well make it stand out against the rest of your application
    when run on manufacturer-themed devices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解决样式问题的最简单方法似乎是将HTML页面样式设计得与应用程序的其他部分一样。问题是，一些设备制造商有自己的Android应用程序样式，所以你无法确定应用程序的其余部分看起来会是什么样子。将HTML页面的背景和前景改为符合标准的Android主题，在制造商主题的设备上运行时，可能会使其与应用程序的其他部分形成鲜明对比。
- en: Pop quiz
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: What is the best way to render large object graphs to HTML for rendering in
    a `WebView`?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染大型对象图以在`WebView`中显示的最佳方式是什么？
- en: Convert them to XML and run them through XSLT
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其转换为XML并通过XSLT处理
- en: Send them to an external web service to be rendered
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其发送到外部网络服务以进行渲染
- en: Hard code the HTML generation
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬编码HTML生成
- en: With a simple template engine
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的模板引擎
- en: How can you access external CSS and images with a `WebView`?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何通过`WebView`访问外部CSS和图片？
- en: Use the `loadDataWithBaseURL` method
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`loadDataWithBaseURL`方法
- en: Specify the full URL path in the HTML page
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML页面中指定完整的URL路径
- en: Generate HTML code that includes the in line data
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成包含内联数据的HTML代码
- en: What rendering engine does Android use for `WebView`?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android的`WebView`使用什么渲染引擎？
- en: Gecko
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gecko
- en: MSIE/Trident
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MSIE/Trident
- en: KHTML
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: KHTML
- en: WebKit
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebKit
- en: Creating relative layouts for content display
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为内容显示创建相对布局
- en: The `WebView` offers an easy way by which large amount of content can be displayed
    to the user in an easy-to-read format. It also has many built-in features designed
    specifically for viewing content. However, it doesn't always offer the easy way
    out and often doesn't allow for functionality that other widgets provide out-of-the-box.
    The `RelativeLayout` class provides much of the same layout functionality that
    the `WebView` class provides you with.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView`提供了一种简单的方式，可以轻松地向用户展示大量内容，并以易于阅读的格式呈现。它还内置了许多专为查看内容而设计的功能。然而，它并不总是提供简单的解决方案，通常不允许使用其他小部件提供的现成功能。`RelativeLayout`类提供了与`WebView`类相同的布局功能。'
- en: As we just discussed, the `WebView` stands out almost as though it were a separate
    application. Working with a `RelativeLayout`, you'll be populating your screen
    with standard Android widgets, which in turn means that there will be no change
    in the look and feel from one screen to the next. While `WebView` requires some
    form of template engine (whether it be in an API or simply a `StringBuilder` as
    in the example), a `RelativeLayout` can be declared in an application resource
    as an XML file. Using a layout file also means that the screen layout will be
    selected through the resource selection process, allowing for sophisticated customizations
    that are difficult to achieve with the `WebView` class and HTML code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚讨论的，`WebView`几乎像一个独立的应用程序一样突出。使用`RelativeLayout`，你将使用标准的Android小部件来填充你的屏幕，这意味着从一屏切换到另一屏时，外观和感觉不会有任何变化。而`WebView`需要某种模板引擎（无论是API中的，还是在示例中简单的`StringBuilder`），`RelativeLayout`可以声明为应用程序资源中的XML文件。使用布局文件还意味着屏幕布局将通过资源选择过程进行选择，从而可以实现难以用`WebView`类和HTML代码实现的复杂自定义。
- en: Using a `RelativeLayout` in a way provides a form of template engine. By only
    giving IDs to `View` objects that you will need to populate with data, you can
    populate the screen by injecting the relevant content into these exposed objects.
    When we built the HTML-based view, we needed to create header elements for the
    ingredients list and list of instructions, with a coded layout structure those
    headers would be loaded from within the layout file, or from a string bundle resource.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，使用`RelativeLayout`提供了一种模板引擎的形式。只需为需要用数据填充的`View`对象提供ID，就可以通过将这些暴露的对象注入相关内容来填充屏幕。当我们构建基于HTML的视图时，我们需要为成分列表和说明列表创建标题元素，如果使用编码的布局结构，这些标题将从布局文件中加载，或从字符串束资源中加载。
- en: When dealing with lists of information, which is a common requirement of a content
    layout, you can provide the data in several different ways. You could use a `ListView`
    object, or you could use an embedded `LinearLayout` to act as a list. When working
    with either of them, it's advisable to have a layout resource that can be reused
    for each of the items in the list. Making use of a `ListView` means you have an
    `Adapter` through which you can convert your data objects into `View` objects
    that can be displayed on the screen. However, `ListView` objects have various
    other constraints (such as the size of the contained items) and are best used
    when the items they display are interactive in some way. If you need a non-interactive
    list (or grid) of items, it's a good idea to follow the `Adapter` mechanism by
    creating a separate class that is responsible for creating `View` objects based
    on your data objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理信息列表时，这是内容布局的常见要求，你可以以多种不同的方式提供数据。你可以使用`ListView`对象，或者你可以使用嵌入式`LinearLayout`作为列表。在使用它们中的任何一个时，建议有一个可以重复用于列表中每个项目的布局资源。使用`ListView`意味着你有了一个`Adapter`，通过它你可以将数据对象转换为可以在屏幕上显示的`View`对象。然而，`ListView`对象还有各种其他限制（如包含项目的大小），最好在它们显示的项目以某种方式交互时使用。如果你需要一个非交互式的项目列表（或网格），最好通过创建一个负责根据你的数据对象创建`View`对象的单独类来遵循`Adapter`机制。
- en: Taking full advantage of RelativeLayout
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 充分利用RelativeLayout
- en: '`RelativeLayout` structures have the major advantage that they offer direct
    integration with the rest of your application. They can also be more easily localized
    than an HTML page. The event structures provided by a direct `ViewGroup` structure
    are more versatile than those provided by a `WebView` object via its specialized
    event listeners and JavaScript.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`结构的主要优势在于它们可以直接与你的应用程序的其余部分集成。它们比HTML页面更容易本地化。直接`ViewGroup`结构提供的事件结构比通过其专用的事件监听器和JavaScript的`WebView`对象提供的事件结构更为灵活。'
- en: The XML layout structures also provide much the same effect as a template engine,
    avoiding the need to import an external API such as an XSLT engine, a Java template
    engine, or hard coding the HTML generation. Standard Android `Activity` classes
    also have the built-in Android animation structures to work with. While the `WebView`
    class allows for CSS animations or could run JavaScript animations, this requires
    re-layout of the HTML structure for each frame in the animation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: XML布局结构也提供了与模板引擎类似的效果，无需导入像XSLT引擎、Java模板引擎这样的外部API，或者硬编码HTML生成。标准的Android `Activity`
    类也内置了与Android动画结构工作的功能。虽然 `WebView` 类允许使用CSS动画或运行JavaScript动画，但这需要为动画的每一帧重新布局HTML结构。
- en: An Android `Activity` class implementing the entire content screen also has
    the advantage that it can load its external resources from the application resource
    structure. This not only allows you to do things such as localize your images
    more easily, but also means that all of the resources are run through the resource
    compiler and as such can be optimized by the Android tool chain. With a `WebView`
    you would need a base URL to load such resources from, or be able to encode them
    inline in the HTML page.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实现了整个内容屏幕的Android `Activity` 类还有个优点，那就是它可以从应用程序资源结构中加载外部资源。这不仅使得你能够更容易地本地化图像等资源，也意味着所有资源都会通过资源编译器处理，因此可以通过Android工具链进行优化。而使用
    `WebView` 的话，你需要一个基本URL来加载这些资源，或者能够将它们内嵌编码在HTML页面中。
- en: Considering Android layout constraints
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑到Android布局的限制
- en: There are some drawbacks to developing the entire content view as an Android
    layout. From a skills point-of-view, only a developer can build and maintain the
    user interface. It also means that any styling done to individual widgets must
    be managed by a developer. With a `WebView` based layout, much of the creation
    work on the layout could be handled by a web developer and graphic designer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完全将内容视图开发为Android布局有一些缺点。从技能角度来看，只有开发者能够构建和维护用户界面。这也意味着任何针对单个小部件的样式设计都必须由开发者管理。而基于
    `WebView` 的布局，布局的大部分创建工作可以由网页开发人员和图形设计师来处理。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding more widgets to your screen comes with another problem—performance. Not
    only can larger, more complex layouts lead to a very slow user experience, it
    can cause your `Activity` to crash entirely.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 向屏幕上添加更多小部件会带来另一个问题——性能。不仅更大、更复杂的布局可能导致用户体验非常缓慢，还可能导致你的 `Activity` 完全崩溃。
- en: Keeping fewer widgets on the screen means that the interface will have less
    information for the user to absorb in one hit, and will be easier to work with.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上保持较少的小部件意味着用户一次需要吸收的信息量会减少，界面也将更容易操作。
- en: Layouts with either too much length, or too much depth will cause an application
    to crash. If you need to animate a single word in the middle of a sentence, you'll
    have to define two additional `TextView` widgets that will display the non-animated
    text on either side of the animated word. This increases the length of your layout.
    If you also needed a horizontal `LinearLayout` in which to place these three `TextView`
    objects, you would be increasing the depth of your layout structure. By factoring
    in both of these constraints, you can imagine how quickly you can run out of memory
    or processing power when it comes to layout rendering. Each of the widgets must
    be measured for layout before being rendered. Each measurement, layout step, or
    rendering step makes use of the language stack (by recursively invoking methods)
    in order to make sure all of the widgets are correctly rendered at the correct
    point on the screen (or not rendered if they are off screen). The software stack
    size in Android is limited, and each method call requires each of its parameters
    to be pushed onto the stack for the invocation. On top of that, all of the measurement
    information needs to be stored in the heap space, which is another seriously limited
    resource on the Android platform (by default the Dalvik VM only allocates 8 MB
    of heap space to begin with).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 过长或过深的布局会导致应用程序崩溃。如果你需要让句子中的一个单词动起来，你将不得不定义两个额外的 `TextView` 小部件，用来显示动画单词两侧的非动画文本。这增加了你的布局长度。如果你还需要一个水平
    `LinearLayout` 来放置这三个 `TextView` 对象，你将增加布局结构的深度。考虑到这两个限制，你可以想象在布局渲染时，你很快就会耗尽内存或处理能力。每个小部件在渲染之前都必须进行布局测量。每次测量、布局步骤或渲染步骤都会通过递归调用方法来使用语言堆栈，以确保所有小部件在屏幕上的正确位置正确渲染（或者如果它们在屏幕外则不渲染）。Android
    中的软件堆栈大小是有限的，每次方法调用都需要将其参数推送到堆栈上以进行调用。除此之外，所有测量信息都需要存储在堆空间中，这也是 Android 平台上另一个严重受限的资源（默认情况下，Dalvik
    VM 只分配了 8 MB 的堆空间开始）。
- en: 'The following diagram illustrates the difference between the length and depth
    of a layout structure. The left screen illustrates a long layout, while the right
    screen illustrates a deep layout:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了布局结构的长度和深度的区别。左边的屏幕展示了一个长布局，而右边的屏幕展示了一个深布局：
- en: '![Considering Android layout constraints](img/4484OS_08_03.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![考虑 Android 布局限制](img/4484OS_08_03.jpg)'
- en: Styling TextView objects
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 `TextView` 对象的样式
- en: At this point it's rather concerning to think about how you might make a single
    word in a sentence bold, or give it a shadow. In the `WebView` it's as easy as
    adding a `<span>` element with some special styling on it, but in a native layout,
    wouldn't you need to add separate `TextView` objects for each section of the text?
    If this were so, you would be dramatically limited in the amount of text you would
    be able to display to the user, since you would be creating thousands of almost
    useless objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，考虑如何让句子中的一个单词变粗体，或者给它加个阴影，这似乎令人担忧。在 `WebView` 中，只需添加一个带有特殊样式的 `<span>`
    元素就很容易实现，但在原生布局中，难道你需要为文本的每个部分添加单独的 `TextView` 对象吗？如果是这样，你将极大地限制能够向用户显示的文本量，因为你将创建成千上万的几乎无用的对象。
- en: Fortunately, Android makes it very easy to mark up the text in all of its default
    widgets. Any class that extends from `TextView` can handle text with style information
    or even images. Generally the classes available in the `android.text.style` package
    can be used to style sub-segments of the text strings you want to display.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android 非常容易地对所有默认小部件中的文本进行标记。任何从 `TextView` 继承的类都可以处理带有样式信息或甚至图片的文本。通常，`android.text.style`
    包中可用的类可以用来设置你想要显示的文本字符串的子片段的样式。
- en: In order to use these different styling structures, you will need to use a `SpannableString`
    object. A `SpannableString` is a specialized type of Android string that keeps
    track of styling information in relation to a normal `CharSequence` of text that
    needs to be displayed. There are several other similar classes (such as `SpannableStringBuilder`)
    which handle easy modification of the text, and are thus suited to text that will
    be edited. For our current purposes, a `SpannableString` is perfect, and much
    simpler to work with. A `SpannableString` has a method that it's required to implement,
    based on the `Spannable` interface—`setSpan`. The `setSpan` method allows you
    to add markup structures to the `SpannableString`, which affect how a specific
    part of the text is rendered.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些不同的样式结构，你需要使用一个`SpannableString`对象。`SpannableString`是Android字符串的一种特殊类型，它记录了一个需要显示的正常`CharSequence`文本的样式信息。还有其他一些类似的类（如`SpannableStringBuilder`），它们处理文本的简单修改，因此适合于将被编辑的文本。出于我们当前的目的，`SpannableString`是完美的，而且更简单易用。`SpannableString`有一个基于`Spannable`接口需要实现的方法——`setSpan`。`setSpan`方法允许你向`SpannableString`添加标记结构，这些标记结构影响文本特定部分的渲染方式。
- en: 'If we simply wanted to write the text **There is nothing to fear!** on the
    screen, you would normally just use a `TextView` object with the specified string.
    What if we wanted to strike the **nothing** out of that string? The way forward
    now is to use a `StrikethroughSpan` object for characters 9 through 16\. In this
    case, the string can''t just be defined in the layout file anymore, a `SpannableString`
    needs to be created in the Java code. The following is a simple example of how
    this can be done, and what the resulting `TextView` would look like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在屏幕上写下**There is nothing to fear!**这个文本，你通常会使用一个指定字符串的`TextView`对象。但如果我们想将字符串中的**nothing**划掉呢？现在的方法是使用`StrikethroughSpan`对象来处理第9到16个字符。在这种情况下，字符串不能只在布局文件中定义，需要在Java代码中创建一个`SpannableString`。以下是实现此操作的一个简单示例，以及结果`TextView`的外观：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of this little snippet of Java code is a `TextView` widget displaying
    styled content instead of a plain `String`, as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Java代码的结果是一个`TextView`小部件，它显示的是样式化的内容，而不是普通的`String`，如下面的截图所示：
- en: '![Styling TextView objects](img/4484_08_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![样式化TextView对象](img/4484_08_04.jpg)'
- en: As you can see, using this type of markup is brilliantly effective, and really
    quite easy to work with. This sample is also very quick to execute when compared
    to the `WebView` rendering, since it doesn't include any form of parsing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用这种标记非常有效，而且实际上非常容易操作。与`WebView`渲染相比，这个示例的执行速度也非常快，因为它不包含任何形式的解析。
- en: There are a few problems with the mechanism though. The most important one being
    the index handling. In order to know when to start or stop a `Span` of markup
    rendering, you need to specify the first and last character that needs to be rendered
    with the given `Span`. Not a problem unless you plan on changing your text, or
    even worse—internationalizing it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种机制存在一些问题。最重要的是索引处理。为了知道何时开始或结束标记渲染的`Span`，你需要指定需要用给定`Span`渲染的第一个和最后一个字符。除非你计划更改文本，甚至更糟——国际化它，否则这不是问题。
- en: Fortunately, once again Android already has a built-in solution, although it
    comes at the expense of performance. You can convert almost any HTML text into
    a `Spannable` object which can in turn be passed directly to any `TextView` object
    for rendering. The class to use is the `android.text.Html` class, which includes
    utility methods for parsing HTML code into a `Spannable` object, and also for
    converting a `Spannable` object into a HTML code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android已经有一个内置的解决方案，尽管这会牺牲一些性能。你可以将几乎任何HTML文本转换成一个`Spannable`对象，然后这个对象可以直接传递给任何`TextView`对象进行渲染。要使用的类是`android.text.Html`类，它包括用于将HTML代码解析为`Spannable`对象的实用方法，以及将`Spannable`对象转换为HTML代码的方法。
- en: If you need to internationalize strings that you plan on rendering with additional
    style attributes, the `Html` class is probably the only sensible way to do it.
    It also has the added advantage that the loading of images can be handled by your
    application (through use of the `Html.ImageGetter` interface). Additionally, the
    `TextView` will still look and feel like a normal Android widget, which enhances
    the users' experience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要国际化打算用额外样式属性渲染的字符串，`Html`类可能是唯一合理的做法。它还有一个额外的好处，即图片加载可以由你的应用程序处理（通过使用`Html.ImageGetter`接口）。此外，`TextView`仍然看起来和感觉像一个正常的Android小部件，这增强了用户的体验。
- en: Most HTML tags are handled by the `Html` class, but not quite all of them. For
    one thing—CSS styles are ignored, so colors and borders are out of the question.
    However, great styling is still possible, and at least you don't need to record
    the character index values somewhere in an application resource so that all of
    the styling lines up.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Html`类处理大多数HTML标签，但并非所有。一方面，CSS样式被忽略，因此颜色和边框不在考虑之列。然而，仍然可以实现很好的样式，至少你不需要在应用程序资源中记录字符索引值，以便所有样式对齐。'
- en: 'If you wanted to format some text in a `Button` label as bold, it''s really
    easy to do with the `Html` class. It''s much quicker to just pass the result of
    the `fromHtml` method directly to the `TextView` object. For example, the following
    code snippet would yield a `Button` object with the word **Hello** in italic script,
    while the word **World** would have a bold weight to it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将`Button`标签中的文本设置为粗体，使用`Html`类可以轻松实现。直接将`fromHtml`方法的结果传递给`TextView`对象要快得多。例如，以下代码片段将生成一个`Button`对象，其中单词**Hello**会以斜体显示，而单词**World**则具有粗体权重：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can also specify HTML content in a layout resource XML file, and it will
    be parsed with the `Html` class before being passed into the `TextView` object's
    `setText` method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在布局资源XML文件中指定HTML内容，它将在传递给`TextView`对象的`setText`方法之前通过`Html`类进行解析。
- en: 'The above Java snippet creates a `Button` widget that would look as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的Java代码片段创建了一个`Button`小部件，其外观如下所示：
- en: '![Styling TextView objects](img/4484_08_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![设置TextView对象的样式](img/4484_08_05.jpg)'
- en: 'HTML tags can also be used to render mini-documents into a `TextView` object,
    and while they carry their own styling, they also adhere to the styling of the
    `TextView` object. This means that if you''re looking for a solution that''s quicker
    to work with than a `WebView` for carrying some static text (and no hyperlinks),
    then a `TextView` can actually serve as a good alternative. For example, consider
    the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标签也可以用于将迷你文档渲染到`TextView`对象中，尽管它们具有自己的样式，但也会遵循`TextView`对象的样式。这意味着，如果你需要一个比`WebView`更快速处理静态文本（且不含超链接）的解决方案，`TextView`实际上可以作为一个很好的替代品。例如，考虑以下代码片段：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will render the `TextView` with a first-level header and a single-lined
    paragraph element. Both of which will include some padding in order to space them
    apart from the other elements on the screen. The resulting image should look quite
    familiar:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染一个带有第一级标题和单行段落元素的`TextView`。两者都将包含一些内边距，以便与屏幕上的其他元素保持距离。生成的图像应该看起来相当熟悉：
- en: '![Styling TextView objects](img/4484_08_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![设置TextView对象的样式](img/4484_08_06.jpg)'
- en: As you can see, a correctly styled `TextView` makes a great alternative to a
    `WebView`, especially if you are fitting it inline with a series of native widgets.
    However, the black-on-white styling does bring back the inconsistency problem.
    So unless you entire application follows this model, it's a better idea to leave
    the styling as default.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，正确设置了样式的`TextView`可以成为`WebView`的优秀替代品，特别是当你将其与一系列原生小部件并列使用时。然而，黑底白字的样式确实带来了不一致的问题。因此，除非你的整个应用程序遵循这种模式，否则最好将样式保留为默认。
- en: 'If you are planning on using a `TextView` for longer content, it''s important
    to consider some additional factors:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用`TextView`显示较长的内容，需要考虑一些额外的因素：
- en: Make sure that the user will be able to scroll if the text runs longer than
    the size of their screen. This is easily done by placing the `TextView` in a `ScrollView`
    object.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保如果文本长度超过用户屏幕尺寸，用户将能够滚动。这很容易做到，只需将`TextView`放置在`ScrollView`对象中。
- en: If your text is very long, consider styling the content, either making the text
    brighter white or working with a black on white background. While it is very inconsistent
    with other Android applications, and other screens in your own application, it
    is much easier on the eyes and your users will thank you for that.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的文本非常长，考虑对内容进行样式设计，要么使文本更亮白，要么使用黑底白字。虽然这与其他Android应用程序以及你自己的应用程序中的其他屏幕非常不一致，但它对眼睛来说要轻松得多，你的用户会为此感谢你。
- en: Consider allowing the user to change the font size with a long touch or a menu.
    If their screen is low density, or they don't have perfect vision, you may be
    making their lives a little easier.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑允许用户通过长按或菜单更改字体大小。如果他们的屏幕是低密度的，或者他们视力不佳，你可能使他们的生活变得稍微轻松一些。
- en: Pop quiz
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: If you need to display a non-interactive bullet point list, which of these is
    preferable?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要显示一个非交互式的项目符号列表，以下哪个更合适？
- en: A `WebView` with an unordered list
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有无序列表的`WebView`
- en: A specially styled `ListView` object
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个特别样式的`ListView`对象
- en: A `TextView` object with HTML content
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个带有HTML内容的`TextView`对象
- en: 'With regards to hyperlinks, you might use a `WebView` instead of a `TextView`
    because:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于超链接，你可能使用`WebView`而不是`TextView`，因为：
- en: '`TextView` cannot handle hyper links'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TextView`不能处理超链接'
- en: They look better in a `WebView`
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WebView`中显示效果更佳
- en: A `WebView` has built-in history management
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebView`具有内置的历史管理功能'
- en: 'A native interface works better for animation intensive applications because:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于动画密集型应用，原生接口效果更好，因为：
- en: You can use Android animation resource files
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用Android动画资源文件
- en: The `WebView` class doesn't handle animations
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebView`类不处理动画'
- en: HTML animations are more expensive to run
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML动画运行成本更高
- en: Time for action – developing specialized content views
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——开发专用内容视图
- en: In many situations, you'll need a specific type of interactive logic that you
    would want to reuse in many parts of your application. On a content screen, some
    parts of the display will need to be updated, driven by changes that are made
    to other parts of the display. This is often because while some area of the screen
    is giving the user information, the other parts are capturing new data from them.
    Next, we'll build a simple widget responsible for displaying an amount of money
    to the user. Its main reason for its existence is the fact that it not only animates
    between changes, but also feeds back to the user whether the amount has gone up
    or down by changing its color.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要一种特定的交互逻辑，以便在应用程序的许多部分重复使用。在内容屏幕上，某些显示区域将需要更新，由显示的其他部分的变化来驱动。这通常是因为屏幕的一部分在向用户传递信息，而其他部分则在从用户那里捕获新数据。接下来，我们将构建一个简单的控件，负责向用户显示金额。它存在的主要原因是它不仅在变化之间进行动画处理，而且通过改变颜色来反馈给用户金额是上升还是下降。
- en: Create a new Java source file named `AmountBox.java` for the new class, and
    open the new file in an editor or IDE.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AmountBox.java`的新Java源文件用于新类，并在编辑器或IDE中打开新文件。
- en: 'The new class should extend the `TextSwitcher` class and implement the `ViewSwitcher.ViewFactory`
    interface:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新类应扩展`TextSwitcher`类并实现`ViewSwitcher.ViewFactory`接口：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare a field for the `DecimalFormat` to be used to render the amount:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个字段用于`DecimalFormat`，以便渲染金额：
- en: '[PRE36]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also declare a field to store the current numeric value displayed:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时声明一个字段来存储当前显示的数值：
- en: 'Declare copies of the two constructors made available from the `TextSwitcher`
    class in order to allow the `LayoutInflator` class to instantiate the `AmountBox`
    class from resource files:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明从`TextSwitcher`类提供的两个构造函数的副本，以允许`LayoutInflator`类从资源文件实例化`AmountBox`类：
- en: '[PRE37]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Declare the `init()` method to take care of "common constructor" requirements:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`init()`方法以处理“常见构造函数”的要求：
- en: '[PRE38]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set the "in" and "out" animations to the fade animations provided by Android:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“进入”和“退出”动画设置为Android提供的淡入淡出动画：
- en: '[PRE39]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, set the `ViewFactory` to the `AmountBox`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`ViewFactory`设置为`AmountBox`：
- en: '[PRE40]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, invoke `setAmount(0)` to ensure the displayed amount is specified:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`setAmount(0)`以确保显示的金额已指定：
- en: '[PRE41]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Declare a setter method to allow overriding of the default `DecimalFormat`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个setter方法，以允许覆盖默认的`DecimalFormat`：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Declare a getter method to allow easy access to the current numeric value:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个getter方法，以便轻松访问当前数值：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Override the `makeView()` method from `ViewFactory`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`ViewFactory`的`makeView()`方法：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a new `TextView` object with the context given to this `AmountBox`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用传递给此`AmountBox`的上下文创建一个新的`TextView`对象：
- en: '[PRE45]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Specify a large text size since the amount will represent money, and then return
    the `TextView` object for display:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个较大的文本大小，因为该数量将表示货币，然后返回`TextView`对象以显示：
- en: '[PRE46]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now declare a setter method to allow the amount value to be changed:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明一个设置器方法，以允许更改金额值：
- en: '[PRE47]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This method will change the color of the text, so declare a variable for the
    new text `color` that will be displayed:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法将改变文本的颜色，因此声明一个变量来显示新的文本`颜色`：
- en: '[PRE48]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'First check to see what `color` we should change the text to:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先检查我们应该将文本更改为哪种`颜色`：
- en: '[PRE49]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Fetch the off screen `TextView` object:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取屏幕外的`TextView`对象：
- en: '[PRE50]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Set the font color based on the change to the numeric value:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据数值的变化设置字体颜色：
- en: '[PRE51]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Render a shadow around the text in order to create a "halo" effect:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本周围渲染阴影以产生“光晕”效果：
- en: '[PRE52]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Set the text of the `TextView` to the new value:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TextView`的文本设置为新的值：
- en: '[PRE53]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Display the off screen `TextView` and remember the new value:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示屏幕外的`TextView`并记住新值：
- en: '[PRE54]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*What just happened?*'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `AmountBox` class is a great example of a small unit of content that needs
    to be updated. This class provides information to the user, but also provides
    a form of feedback. When the user does something which affects the amount displayed,
    the `AmountBox` reacts by updating the font color to reflect the direction of
    the change—green for the amount going down, and red for an amount going up.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`AmountBox`类是一个需要更新内容的小单元的很好例子。这个类向用户提供信息，同时也提供了一种反馈形式。当用户执行影响显示金额的操作时，`AmountBox`通过更新字体颜色来反映变化的方向——金额减少时为绿色，金额增加时为红色。'
- en: The example makes use of the standard Android fade through animations as discussed
    in [Chapter 7](ch07.html "Chapter 7. Animating Widgets and Layouts"), A*nim*ating
    *Widgets and Layouts*. The speed of the animations provides a great cross fade
    effect between the two amounts. Notice that in the `setAmount` method, the updating
    of the text content and switching the `View` objects is handled manually.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用了第[7章](ch07.html "第7章. 动画小部件和布局")讨论的标准Android淡入淡出动画，即*动画小部件和布局*。动画的速度为两个金额之间的交叉淡入效果提供了很好的效果。注意在`setAmount`方法中，文本内容的更新和`View`对象的切换是手动处理的。
- en: You could potentially replace the `offscreen.setText` and `showNext` method
    calls with a call to `setText`, but it's nice to see how it works under the hood.
    This method is also not subject to future implementation changes that may occur.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以用一个`setText`方法的调用替换`offscreen.setText`和`showNext`方法的调用，但了解它内部的工作原理很有趣。此方法也不受未来实现变更的影响。
- en: '![What just happened?](img/4484_08_07.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/4484_08_07.jpg)'
- en: Developing an online music store
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发在线音乐商店
- en: A great example of a content-centric layout is a music store built into a media
    player application. The ability to buy music directly from the media player is
    a massively user-friendly feature, and also fits nicely with the way Android applications
    behave as "connected" applications instead of purely offline systems. Android
    also makes it very easy to truly include the shop as part of the application instead
    of simply providing a link to an appropriate website. Generally, users are more
    inclined to feel a sense of trust if they pick the **Buy Music** button and are
    not suddenly whisked off to their web browser. Having both online and offline
    parts of your application properly integrated can also go a long way for your
    sales statistics.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以内容为中心的布局的绝佳例子是嵌入媒体播放器应用程序中的音乐商店。直接从媒体播放器购买音乐的能力是一个极大提升用户体验的功能，并且与Android应用程序作为“连接”应用程序的行为而非纯粹的离线系统相得益彰。Android还使得将商店真正集成到应用程序中变得非常简单，而不仅仅是提供到适当网站的链接。通常，如果用户点击**购买音乐**按钮而没有突然跳转到网页浏览器，他们会更有信任感。将应用程序的在线和离线部分正确集成，对于你的销售统计也能起到很大的作用。
- en: Buying music online is very different to purchasing it in a store. The availability
    of additional information about the songs, artists, or albums the user is looking
    at is part of the appeal. For this reason, an online music store for a mobile
    device must be carefully designed to provide as much information as possible without
    either cluttering the screen, or detracting from the fact that the user is there
    to purchase music. The feeling of integration with the application also helps
    build trust with the user, so the look and feel is very important. Another advantage
    of buying music online is you pay only for what you want to purchase. For this
    the user interface needs to allow the user to select which tracks from an album
    the users would like to purchase, and which they either don't want or plan to
    buy later. Also, how do they know which ones they like? They also need to be able
    to play a sample (whether it be time limited, or just a lower quality) of each
    track.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在线购买音乐与在商店购买音乐非常不同。关于用户正在查看的歌曲、艺术家或专辑的附加信息是吸引人的部分。因此，一个针对移动设备的在线音乐商店必须精心设计，以提供尽可能多的信息，同时不使屏幕显得杂乱，也不偏离用户购买音乐的初衷。与应用程序的整合感也有助于建立用户信任，因此外观和感觉非常重要。在线购买音乐的另一个优点是，你只需为你想购买的内容付费。为此，用户界面需要允许用户选择他们想从专辑中购买的曲目，以及他们不想购买或计划以后购买的曲目。另外，他们如何知道哪些是他们喜欢的？他们还需要能够播放每首曲目的样本（无论是限时播放，还是只是低质量的）。
- en: Designing the music store
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计音乐商店
- en: To really illustrate how a content-centric design fits together, you need to
    build one. For this example we'll be working through the design process, and then
    the implementation of that design. Since the design and its implementation are
    the important parts here, we won't go into building a functional example. It'll
    really just be a pretty screen.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正说明以内容为中心的设计是如何结合在一起的，你需要构建一个。在这个例子中，我们将通过设计过程以及该设计的实现来工作。由于设计和实现是这里的重要部分，我们不会深入构建一个功能性的示例。它只是一个漂亮的屏幕。
- en: To begin with, we need to have a basic user interface design. I find it best
    to start with a whiteboard or a piece of paper and a pen. While there are plenty
    of tools for drawing mock screens out there, none of them really approach the
    user interface of a paper and pen. To start off, we draw a high level wireframe
    of the overall screen design. This is simply a series of boxes that will tell
    us what type of information to show in what parts of the screen.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要有一个基本的用户界面设计。我发现最好是从一块白板或一张纸和一支笔开始。尽管市面上有很多绘制模拟屏幕的工具，但没有一个能真正接近纸和笔的用户界面。首先，我们绘制一个高级线框，展示整个屏幕设计。这只是一系列告诉我们在屏幕的哪些部分显示什么类型信息的盒子。
- en: '![Designing the music store](img/4484OS_08_08.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![设计音乐商店](img/4484OS_08_08.jpg)'
- en: 'In the diagram, we''ve divided the user interface into three parts:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，我们将用户界面分成了三个部分：
- en: 'Album and Artist Information area: This area displays the name and cover art
    of the album the user is looking to buy'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专辑和艺术家信息区域：这一区域显示用户想要购买专辑的名称和封面艺术。
- en: 'Track List area: In this area, users can listen to samples and select which
    tracks they want to purchase'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲目列表区域：在这个区域，用户可以试听样本，并选择他们想要购买的曲目。
- en: 'Purchasing Area: This area displays the total amount users will be paying,
    and also a button to buy their selected tracks'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买区域：这一区域显示用户将支付的总金额，以及一个购买选定曲目的按钮。
- en: In the previous diagram, I've stuck to the size of the screen, but depending
    on the screen size and number of tracks available, the user interface may need
    a scrollbar to be fully accessible.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个图表中，我遵循了屏幕的大小，但根据屏幕大小和可用的曲目数量，用户界面可能需要一个滚动条才能完全访问。
- en: The next bit of work is to look at each of the sections of the user interface
    that we've defined and decide what widgets will go into each of them. Firstly
    we'll need to look at the album and artist information. The album information
    will be displayed as the album cover artwork and the album name. We'll include
    an image area for an artist logo, and also include a text block with the name
    of the recording label.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的工作是对我们定义的用户界面的每个部分进行查看，并决定将哪些小部件放入它们中。首先，我们需要查看专辑和艺术家信息。专辑信息将作为专辑封面艺术和专辑名称显示。我们将包括一个用于艺术家标志的图像区域，并包括一个带有录音标签名称的文本块。
- en: '![Designing the music store](img/4484OS_08_09.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![设计音乐商店](img/4484OS_08_09.jpg)'
- en: A simple block diagram like this lets you visually consider the various elements.
    It also allows you to start thinking about things such as font size, borders,
    and spacing. In the previous diagram, we want the three elements on the right
    to be roughly the same size as the cover art on the left. Unfortunately the Android
    `RelativeLayout` class doesn't currently allow us to directly stipulate this as
    a contract. The next element of the design we need to consider is the track listing
    box. For this, instead of drawing everything in the box, we'll focus on what a
    single line will look like and what information it will contain.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个简单的块状图可以让你直观地考虑各种元素。它还允许你开始考虑诸如字体大小、边框和间距等因素。在上述图表中，我们希望右侧的三个元素大致与左侧的封面艺术大小相同。不幸的是，Android的
    `RelativeLayout` 类目前不允许我们直接规定这一点作为约定。接下来我们需要考虑的设计元素是音轨列表框。对于这个，我们不是在框中绘制所有内容，而是专注于单行外观及其包含的信息。
- en: '![Designing the music store](img/4484OS_08_10.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![设计音乐商店](img/4484OS_08_10.jpg)'
- en: The preceding structure is a very simple one line structure for displaying the
    details of a single track. The `CheckBox` on the left can be used to select those
    tracks that the user wants to purchase, while the button on the right side can
    be used to play a sample of the given track. The two button-like elements on either
    side create a kind of framing for the plain text elements in the middle of the
    line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构是一个非常简单的单行结构，用于显示单个音轨的详细信息。左侧的 `CheckBox` 可用于选择用户想要购买的音轨，而右侧的按钮可用于播放给定音轨的样本。两侧类似按钮的元素为中间的纯文本元素创建了一种框架。
- en: Finally, we need to consider how we plan on asking the user to send their money.
    This is a very important part of the user interface, it needs to be obvious—the
    amount of money they will be expected to pay. We also need to make it really easy
    for the user to actually make the transaction, so a single **Purchase** or **Buy
    Selected Tracks** button is needed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要考虑我们打算如何让用户支付他们的钱。这是用户界面非常重要的部分，它需要清晰明了——他们预期要支付的金额。我们还需要让用户实际进行交易变得非常容易，所以需要一个单一的
    **购买** 或 **购买选定音轨** 按钮。
- en: '![Designing the music store](img/4484OS_08_11.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![设计音乐商店](img/4484OS_08_11.jpg)'
- en: The final section of the user interface simply has two widgets in it, one on
    the left for purchasing, and the total amount the user is expected to pay on the
    right. For the left side button, we'll work with a simple Android `Button` widget,
    while on the right side we'll make use of the new `AmountBox` written in the previous
    part of this chapter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的最后一部分仅包含两个小部件，左侧用于购买，右侧显示用户预期支付的总金额。对于左侧的按钮，我们将使用一个简单的Android `Button`
    小部件，而在右侧，我们将使用本章前一部分编写的新的 `AmountBox`。
- en: Developing the music store
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发音乐商店
- en: 'We''ll start with the new example by building a new series of model classes,
    but first you''ll need to create a new project for our conceptual media player.
    To do this, run the following command on a command line or console:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建一系列新的模型类开始新的示例，但首先你需要为我们的概念性媒体播放器创建一个新项目。为此，在命令行或控制台上运行以下命令：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After creating the new project, copy the `AmountBox` source code into the root
    package of the new project. You then need to create a class to contain the data
    for a single track. This simply needs to have the name of the track and the duration
    of the track stored as the number of seconds. We'll also include utility methods
    to calculate the minutes:seconds values that we can use to display the duration
    data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目后，将 `AmountBox` 源代码复制到新项目的根包中。然后，你需要创建一个类来包含单个音轨的数据。这只需存储音轨的名称和以秒为单位的音轨时长。我们还将包括一些实用方法，用于计算我们可以用来显示时长数据的分：秒值。
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `Track` class is a very simple structure which could easily be parsed from
    XML or deserialized from a binary stream. We also need another class to hold the
    information about a single artist. While the following class is really nothing
    more than a form of data store, it could easily be extended to store things like
    biography information if needed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track` 类是一个非常简单的结构，可以很容易地从XML解析或从二进制流反序列化。我们还需要另一个类来保存关于单个艺术家的信息。虽然以下类实际上不过是数据存储的一种形式，但很容易扩展以存储如需的生物信息：'
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, on the data class front, we''ll need a class for linking the two previous
    classes to a single album. This class will be used as a single point which can
    be handed to an `Activity`. Copy the following code into a new file named `Album.java`
    in the root package of your project:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在数据类方面，我们需要一个类来将前两个类连接到一个单一的专辑。这个类将被用作可以传递给`Activity`的单一点。将以下代码复制到项目根包中名为`Album.java`的新文件中：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Time for action – building a track item
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——构建一个轨道条目
- en: To get working on the new user interface, you'll need a few images. For this
    next section, you'll need an image for the play buttons. The play image should
    be a simple "play" arrow, the button we place it in will provide a background
    and border. The lines in the list structure will be placed into a `TableLayout`
    in order to align all of the sub-structures.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始新的用户界面工作，你需要一些图片。在接下来的部分，你需要一个用于播放按钮的图片。播放图片应该是一个简单的“播放”箭头，我们将它放入的按钮会提供背景和边框。列表结构中的行将被放入一个`TableLayout`中，以便对齐所有子结构。
- en: Create a new layout resource file in the `res/layouts` directory of the project,
    and name the new file `track.xml`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`res/layouts`目录中创建一个新的布局资源文件，并将新文件命名为`track.xml`。
- en: 'Declare the root element of the new file as a `TableRow` element consuming
    all of the available width and only the required height:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件的根元素声明为一个`TableRow`元素，占用所有可用宽度和所需高度：
- en: '[PRE59]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As the first element of the `TableRow`, create a `CheckBox` the user can use
    to select and unselect the tracks they want to buy:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`TableRow`的第一个元素，创建一个`CheckBox`，用户可以使用它来选择和取消选择他们想要购买的轨道：
- en: '[PRE60]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare a `TextView` element to display the name of the track with a larger-than-usual
    font, and a pure-white font color:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`TextView`元素，以比通常更大的字体显示轨道名称，并使用纯白色字体颜色：
- en: '[PRE61]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Follow the track name `TextView` with another right-aligned `TextView` object
    to be used to display the duration of the track:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextView`轨道名称后面跟随另一个右对齐的`TextView`对象，用于显示轨道的时长：
- en: '[PRE62]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'End the `TableRow` element with an `ImageButton` element, which can be used
    by the user to sample the track before buying it:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以一个`ImageButton`元素结束`TableRow`元素，用户可以使用它来在购买前试听轨道：
- en: '[PRE63]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*What just happened*'
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么*'
- en: The above layout resource file will handle the layout of the track list items
    for the second part of the user interface. We need to be able to create several
    of these structures to handle all of the tracks available in an album. We wrap
    them in a `TableRow` element which when placed in a `TableLayout` object, will
    automatically align each of its sub-elements with those in the other rows.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的布局资源文件将处理用户界面第二部分轨道列表项的布局。我们需要能够创建几个这样的结构，以处理专辑中所有可用的轨道。我们将它们包裹在一个`TableRow`元素中，当它被放入一个`TableLayout`对象时，会自动将其子元素与其他行中的元素对齐。
- en: 'Later, in the Java code we''ll use the `LayoutInflator` to load this resource,
    populate it with the name and duration of a track, and then add it to a `TableLayout`
    object that we will declare as part of the main user interface. Once this new
    item has been populated with some data, it''ll look something like the following
    screenshot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在Java代码中，我们将使用`LayoutInflator`加载这个资源，用轨道的名称和时长填充它，然后将其添加到一个`TableLayout`对象中，这个对象我们将作为主用户界面的一部分进行声明。一旦这个新项目被填充了一些数据，它看起来将类似于以下的截图：
- en: '![What just happened](img/4484_08_12.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么](img/4484_08_12.jpg)'
- en: Time for action – developing the main user interface layout
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——开发主用户界面布局
- en: Having built the layout resource file that will become track items in a list
    later, we now need to define the remaining elements of this user interface. While
    this structure is relatively simple, it's also very easily extended and has a
    few minor details that keep it looking really good. It also needs some Java code
    in order to be correctly populated, but we'll get into that after we've finished
    with the resource file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 建立了后来将变成列表中轨道条目的布局资源文件后，我们现在需要定义这个用户界面的其余元素。虽然这个结构相对简单，但它也非常容易扩展，并且有一些小细节让它看起来非常棒。它还需要一些Java代码才能正确填充，但我们在完成资源文件后会涉及到这些内容。
- en: '![Time for action – developing the main user interface layout](img/4484OS_08_13.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![动手时间——开发主用户界面布局](img/4484OS_08_13.jpg)'
- en: Create or open the `res/layout/main.xml` file in the new project.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或打开新项目中的`res/layout/main.xml`文件。
- en: 'The root element of the main layout needs to be a `ScrollView` in order to
    handle the possibility that the interface runs longer than the available screen
    space. The `ScrollView` should take up all available screen space:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理主布局可能超出可用屏幕空间的情况，主布局的根元素需要是一个`ScrollView`。`ScrollView`应占据所有可用屏幕空间：
- en: '[PRE64]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As the only element to the `ScrollView`, declare a `RelativeLayout` which consumes
    the available width, but only the required height. The `RelativeLayout` should
    include some padding at the top and bottom to provide a little "breathing room"
    so that its contents don''t look to cramped:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`ScrollView`的唯一元素，声明一个`RelativeLayout`，它占据可用宽度，但只有所需的高度。`RelativeLayout`应在顶部和底部包含一些内边距，以提供一些“呼吸空间”，使其内容不会显得过于拥挤：
- en: '[PRE65]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The first element of the `RelativeLayout` is the album art, a fixed size `ImageView`
    object that will fit the album cover art in the available space:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RelativeLayout`的第一个元素是专辑封面，这是一个固定大小的`ImageView`对象，它将适应可用空间中的专辑封面艺术：'
- en: '[PRE66]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The second element after the album art is the artist''s logo image, also an
    `ImageView`. This element is required to center the logo in the available space:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专辑封面之后的第二个元素是艺术家的标志图像，也是一个`ImageView`。这个元素需要将标志在可用空间中居中显示：
- en: '[PRE67]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After the artist''s logo, we need a plain `TextView` object with some font
    styling to hold the name of the album we''re trying to sell. We''ll place this
    below the artist''s logo in the user interface as per the image we saw earlier:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在艺术家标志之后，我们需要一个简单的`TextView`对象，并应用一些字体样式来显示我们试图销售的专辑名称。我们将按照之前看到的图像，在用户界面中将此放置在艺术家标志下方：
- en: '[PRE68]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Below the `TextView` with the album name, we have a small non-styled `TextView`
    to hold the name of the record label under which the album is released:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在带有专辑名称的`TextView`下方，我们有一个小的非样式的`TextView`来显示发行专辑的唱片公司名称：
- en: '[PRE69]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As promised, we follow these elements with a `TableLayout` which will hold
    the available track information. We layout the `TableLayout` element against the
    album art rather than the record label `TextView`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如承诺的那样，在这些元素之后，我们使用一个`TableLayout`来保存可用的曲目信息。我们将`TableLayout`元素与专辑艺术相对齐，而不是与唱片公司`TextView`相对齐：
- en: '[PRE70]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Underneath the track list, we start by placing the **Buy Selected Tracks**
    button element on the left side of the screen:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在曲目列表下方，我们首先将**购买选定曲目**的按钮元素放置在屏幕左侧：
- en: '[PRE71]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, on the right side of the screen, we add our custom `AmountBox` widget
    where we will tell the user how much they will be paying:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在屏幕右侧，我们添加了自定义的`AmountBox`小部件，在这里我们将告诉用户他们将支付多少费用：
- en: '[PRE72]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*What just happened?*'
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In the preceding layout, each of the specified widgets has an important part
    to play by either providing the user with information, or gathering new information
    from them. As far as possible, we have given the user only the information that
    is important to them. The cover art and artist's logo are often the first way
    people recognize a specific album, while the name may well be a secondary recognition.
    The colors and shapes in the album cover art are generally recognized faster by
    a person's brain than the text indicating the album's name.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的布局中，每个指定的部件都通过提供信息给用户或从用户那里收集新信息来发挥重要作用。尽可能的，我们只给用户提供了对他们来说重要的信息。封面艺术和艺术家标志通常是人们识别特定专辑的第一方式，而名称可能是第二识别方式。专辑封面艺术中的颜色和形状通常比表明专辑名称的文本更快被人的大脑识别。
- en: 'All of the top elements: Cover art, artist logo, album name, and record label,
    could be made into interactive elements, taking the user to screens with more
    information about the selected element. The linked information could include reviews,
    discussion forums, and rating widgets. Another great addition would be linking
    to music videos from the selected album or artist (if there are some available).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 所有顶部元素：封面艺术、艺术家标志、专辑名称和唱片公司，都可以做成交互式元素，将用户带到包含所选元素更多信息屏幕。链接的信息可能包括评论、讨论论坛和评分小部件。另一个很好的补充是将所选专辑或艺术家的音乐视频链接过来（如果有）。
- en: Also notice at the bottom in our purchasing area. The `AmountBox` has been aligned
    with the "baseline" of the `purchase Button` widget. In this case, it aligns the
    baseline of the text in these two widgets, making them looked centered in relation
    to each other, although it's an aesthetic centering rather than an exact computation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意我们在购买区域的底部。`AmountBox`已经与“购买按钮”小部件的“基线”对齐。在这种情况下，它将这些两个小部件中的文本基线对齐，使它们相互看起来居中，尽管这是一种美学上的居中，而不是精确的计算。
- en: Time for action – developing the main user interface Java code
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——开发主要用户界面Java代码
- en: In order to put this example together entirely and have a working content-centric
    screen (although only in the example sense), we need some Java code. This code
    will handle populating the user interface layout with an `Album` object. For this
    next piece of code, you'll need images for the cover art and for the artist's
    logo.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个例子完整地组合在一起，并拥有一个以内容为中心的屏幕（尽管仅在示例意义上），我们需要一些Java代码。这段代码将处理用`Album`对象填充用户界面布局。对于接下来的这段代码，你需要封面艺术和艺术家标志的图片。
- en: Open the `ShopActivity` Java source file in an editor or IDE.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`ShopActivity` Java源文件。
- en: 'In the `onCreate` method, ensure that the `main.xml` layout resource is being
    set as the content view for the `ShopActivity`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，确保将`main.xml`布局资源设置为`ShopActivity`的内容视图：
- en: '[PRE73]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Fetch the application resources and invoke a new `setAlbum` method with the
    contents of your favorite music album:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应用资源，并用你最喜欢的音乐专辑的内容调用一个新的`setAlbum`方法：
- en: '[PRE74]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Declare the `setAlbum` method to accept an `Album` object:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`setAlbum`方法以接受一个`Album`对象：
- en: '[PRE75]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Fetch the `track_listing` part of the user interface and use a new `addTrackView`
    method to add each of the tracks to the display:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户界面的`track_listing`部分，并使用新的`addTrackView`方法将每个音轨添加到显示中：
- en: '[PRE76]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Fetch the album cover art widget and set its content:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取专辑封面艺术部件并设置其内容：
- en: '[PRE77]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Fetch the artist''s logo widget and set its content:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取艺术家的标志部件并设置其内容：
- en: '[PRE78]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Fetch the album name widget and set its content:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取专辑名称部件并设置其内容：
- en: '[PRE79]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Fetch the record label widget and set its content:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取唱片公司部件并设置其内容：
- en: '[PRE80]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Fetch the `AmountBox` widget and set its format to a money format before setting
    its value to `1.99` multiplied by the number of tracks:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`AmountBox`部件，并将其格式设置为货币格式，然后将其值设置为`1.99`乘以音轨的数量：
- en: '[PRE81]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Declare the `addTrackView` method and use it as it was used previously:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`addTrackView`方法，并像之前一样使用它：
- en: '[PRE82]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Use a `LayoutInflator` to inflate the `track` layout resource:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`LayoutInflator`来填充`track`布局资源：
- en: '[PRE83]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Fetch the track name widget from the new `ViewGroup` and set its content:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的`ViewGroup`中获取音轨名称部件，并设置其内容：
- en: '[PRE84]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Fetch the track duration widget from the new `ViewGroup`, and create a `StringBuilder`
    with which to display the track duration:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的`ViewGroup`中获取音轨时长部件，并创建一个`StringBuilder`用来显示音轨时长：
- en: '[PRE85]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Append the minutes and a separator to the `StringBuilder`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分钟数和一个分隔符追加到`StringBuilder`中：
- en: '[PRE86]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If the number of seconds is less than `10`, we need a prefix `''0''` character:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果秒数小于`10`，我们需要一个前缀`'0'`字符：
- en: '[PRE87]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Append the number of seconds in the duration:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时长中的秒数追加：
- en: '[PRE88]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set the text of the duration widget and add the new line to the "tracks" list:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置时长部件的文本，并将新行添加到“音轨”列表中：
- en: '[PRE89]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '*What just happened?*'
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'The preceding Java code is enough to copy the data given in the `Album` object
    into the user interface. Once on the screen, it looks like a simple music store
    page, but themed as an Android application. This provides much of the benefit
    of a web page in terms of layout structures and the easy maintenance that comes
    with an XML layout and at the same time integrates entirely with whatever branding
    and styling may exist on the end user''s device. Once on the screen, the previous
    example will present you with something looking like the following screenshot:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Java代码足以将`Album`对象中的数据复制到用户界面。一旦显示在屏幕上，它看起来像一个简单的音乐商店页面，但主题为Android应用程序。这提供了与网页在布局结构和易于维护方面的许多好处，同时完全集成到最终用户设备上可能存在的任何品牌和样式。一旦显示在屏幕上，之前的示例将呈现给你类似以下截图的东西：
- en: '![What just happened?](img/4484_08_14.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/4484_08_14.jpg)'
- en: Have a go hero – updating the total price
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手英雄——更新总价
- en: To really make the previous example feel more real, it needs to update the total
    amount at the bottom of the screen when the user selects or unselects tracks from
    the album listing. It should also disable the **Buy Selected Tracks** button if
    there are no tracks selected.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让之前的例子感觉更加真实，当用户从专辑列表中选择或取消选择音轨时，它需要更新屏幕底部的总金额。如果没有任何音轨被选择，它还应该禁用**购买选定音轨**按钮。
- en: Try adding an event listener to each of the `CheckBox` elements in the track
    layouts, and keep a track of which are selected. For the total amount to display,
    multiply `1.99` with the number of selected tracks.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为音轨布局中的每个`CheckBox`元素添加一个事件监听器，并跟踪哪些被选中。为了显示总金额，将`1.99`乘以被选中的音轨数量。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've delved into many important areas and techniques used
    when presenting the user with lots of information or content. It's important to
    think through your interfaces carefully before you start building them, but also
    try not to take up too much time before you put fingers to the keyboard and start
    coding. Sometimes having a simple user interface up and running can tell you far
    more than your diagrams and mock-ups ever will about how users will work with
    the screen.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经深入探讨了在向用户展示大量信息或内容时使用的许多重要领域和技术。在开始构建之前，仔细考虑你的界面是很重要的，但同时也不要在动手编码之前花费太多时间。有时，一个简单的用户界面运行起来能告诉你的东西，比你的图表和模型所能展示的要多得多。
- en: We've completed an example of displaying recipes to the user with the `WebView`
    class, demonstrating how easy it is to use HTML on the Android platform. We've
    also looked at the native alternative to an HTML view by building an online music
    store using a `RelativeLayout` to display the content. With these two examples,
    we've compared the differences between the two mechanisms giving insight into
    where each can best be used.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`WebView`类完成了一个显示食谱给用户的示例，展示了在Android平台上使用HTML是多么简单。我们还通过构建一个在线音乐商店，使用`RelativeLayout`来显示内容，探讨了与HTML视图相对的原生替代方案。通过这两个示例，我们比较了两种机制之间的差异，并洞察了各自最佳使用场景。
- en: Always consider your performance and user experience when deciding on how to
    display your content. While a `WebView` may be more flexible in some regards,
    allowing you to change the content view depending on what content you are displaying,
    it may also lead to inconsistencies and an irritated user. A `RelativeLayout`
    provides a more rigid structure, and will also ensure a more consistent code base.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何展示内容时，请务必考虑性能和用户体验。虽然`WebView`在某些方面可能更具灵活性，允许你根据显示的内容改变视图，但也可能导致不一致性，并让用户感到烦恼。`RelativeLayout`提供了更刚性的结构，并且还将确保代码库更加一致。
- en: In the next chapter, we'll be looking in more detail at how you can go about
    adding more style to your Android application. We'll also look at how best to
    go about handling changes to the device and configuration (such as the changing
    language or a change from portrait to landscape mode).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨如何为你的Android应用程序添加更多样式。我们还将研究如何最佳地处理设备和配置的变化（例如语言变化或从竖屏模式切换到横屏模式）。
