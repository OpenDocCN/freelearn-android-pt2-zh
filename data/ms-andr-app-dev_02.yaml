- en: Chapter 2. Designing our App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 设计我们的应用
- en: In this chapter, we will think of an idea for an app and transform that idea
    into a real app, create a basic structure to be displayed on the screen, and choose
    an appropriate navigation pattern to move between them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为应用想出一个点子，并将这个点子转化为真实的应用，创建要在屏幕上显示的基本结构，并选择一个合适的导航模式在它们之间移动。
- en: After taking a look at the most commonly used navigation pattern, we will proceed
    with implementing the tabs pattern composed by fragment and `ViewPager`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看最常用的导航模式之后，我们将继续实现由片段和`ViewPager`组成的标签模式。
- en: During this, we will do a review of our knowledge of fragments to be able to
    explain the advanced concepts. We will also discuss the importance of `FragmentManager`
    and the fragments back-stack.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们将回顾关于片段的知识，以便能够解释高级概念。我们还将讨论`FragmentManager`和片段后退栈的重要性。
- en: 'To finish, we will add some good-looking animations to our screen transitions.
    Therefore, we will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在屏幕过渡中添加一些美观的动画。因此，本章我们将涵盖以下主题：
- en: Selecting an app navigation pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择应用导航模式
- en: Mastering fragments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通片段
- en: Implementing tabs and ViewPager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现标签和ViewPager
- en: Animated transitions between screens
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕之间的动画过渡
- en: Selecting an app-navigation pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择应用导航模式
- en: Let's imagine that one day you wake up feeling inspired; you have an idea for
    an app that you believe can become more popular than WhatsApp. Without losing
    time, you would want to turn this app idea into reality! This is why it's important
    for you to learn how to design an app and choose the most appropriate navigation
    pattern. Not to sound uninspiring, but you'll find that 99 percent of your ideas
    will already be on Google Play Store. It's simply a fact that there are hundreds
    of thousands of apps available, and the number is always increasing! So, you can
    either decide to improve upon the already existing ones or keep brainstorming
    until you have something original.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一天你醒来时感到很有灵感；你有一个应用点子，你认为它可能比WhatsApp还要受欢迎。不要浪费时间，你会想要将这个应用点子变为现实！这就是为什么你需要学习如何设计应用并选择最合适的导航模式。不是要让你失去信心，但你会发现你的99%的点子已经在Google
    Play商店里了。事实上，有数十万个应用可供选择，而且这个数字还在不断增加！所以，你可以选择改进已有的应用，或者继续头脑风暴，直到你有一个原创的点子。
- en: In order to make the app a reality, the first step is to visualize the app in
    your mind; for this, we need to identify the basic components. We need to simplify
    the idea on screen, and we need to move between screens.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将应用变为现实，第一步是在脑海中可视化应用；为此，我们需要确定基本组件。我们需要在屏幕上简化想法，并且需要在屏幕之间移动。
- en: Bear in mind that you are creating this app for Android users. These users are
    used to using navigation patterns such as the sliding panel, which is used in
    apps such as Gmail, Facebook, and Spotify.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你正在为Android用户创建这个应用。这些用户习惯于使用如Gmail、Facebook和Spotify等应用中的滑动面板这样的导航模式。
- en: We will take a look at three different and commonly used navigation patterns
    that guarantee that the user won't get lost in our app and will understand the
    app structure instantly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看三种不同的常用导航模式，这些模式保证用户在我们的应用中不会迷失方向，并能立即理解应用结构。
- en: Basic structure
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本结构
- en: In order to draw our screens (note that I am not referring to activities or
    fragments yet; by screen I mean what the user can literally see on screen at any
    point during the execution of our app), we need to identify the key points of
    our idea. We need to establish the use cases, speaking in software development
    terms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制我们的屏幕（请注意，我这里不是指活动或片段；所谓屏幕是指用户在我们的应用执行期间任何时候实际可以看到的内容），我们需要确定我们想法的关键点。我们需要用软件开发术语来建立用例。
- en: 'Let''s start by giving shape to the app that we will build during the course
    of this book: **MasteringAndroidApp**. It''s difficult to visualize all the details
    in your mind at first, so we will start by identifying the components that we
    know we need for sure and later fill in the gaps if there are any.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从确定本书学习过程中要构建的应用的形状开始：**MasteringAndroidApp**。一开始很难在脑海中想象出所有细节，所以我们将从确定我们肯定需要的组件开始，稍后再填补可能存在的空白。
- en: We know from the previous chapter that we have a presentation screen, which
    shows the logo of the app for a few seconds while downloading data from the Internet
    if needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从上一章知道，我们有一个演示屏幕，它会在需要时从互联网下载数据的同时显示应用的徽标几秒钟。
- en: In this app, we will also have a screen with a list of the information coming
    from the Internet, with individual items that the user can click on to get more
    detailed information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们还将有一个包含来自互联网的信息列表的屏幕，用户可以点击单个项目获取更详细的信息。
- en: As the main option, we will show a contact screen with `MapView` showing my
    location and contact data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主要选项，我们将展示一个带有`MapView`显示我的位置和联系数据的联系人屏幕。
- en: To finish, we need a **Preferences** or **Settings** screen, where we can turn
    on and off the notifications and deactivate ads or purchase extras.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个**偏好设置**或**设置**屏幕，在这里我们可以打开或关闭通知，以及禁用广告或购买额外内容。
- en: 'Now, we are ready to create a mock-up. Have a look at the following image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建一个草图。请看以下图片：
- en: '![Basic structure](img/B04887_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![基本结构](img/B04887_02_01.jpg)'
- en: At the top, we have the entry point of our application, which is the splash
    screen. The navigation here is straightforward; we can navigate to the next screen
    in a straight line, and there are no buttons or any other possible flow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有应用程序的入口点，即启动屏幕。这里的导航很直接；我们可以直接导航到下一个屏幕，并且没有按钮或任何其他可能的流程。
- en: On the next level, we have a screen with the list of items (which is a screen
    with contact information), a map view, and a settings screen. These three screens
    are at the same level in our app, so they have the same importance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一级，我们有一个项目列表的屏幕（即带有联系信息的屏幕）、一个地图视图和一个设置屏幕。这三个屏幕在我们的应用程序中处于同一级别，因此它们具有同等的重要性。
- en: Finally, we have a third level of navigation, which is the detailed view of
    an item of the list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个第三层导航，即列表项的详细视图。
- en: The only way we can open this screen is by clicking on an element of the list;
    so, the entry point of this screen is the list screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开这个屏幕的唯一方式是点击列表中的一个元素；因此，这个屏幕的入口点是列表屏幕。
- en: Now that we have a basic structure and flow created, we will look through the
    different extensively used navigation patterns in order to decide which one would
    work best for our app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经建立了一个基本的结构和流程，接下来我们将研究各种广泛使用的导航模式，以决定哪一种最适合我们的应用程序。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the app structure and similar information on material
    design, refer to the following links:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有关应用程序结构和有关材料设计类似信息的更多信息，请参考以下链接：
- en: '[https://developer.android.com/design/patterns/app-structure.html](https://developer.android.com/design/patterns/app-structure.html)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/design/patterns/app-structure.html](https://developer.android.com/design/patterns/app-structure.html)'
- en: '[http://www.google.com/design/spec/patterns/app-structure.html#](http://www.google.com/design/spec/patterns/app-structure.html#)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.google.com/design/spec/patterns/app-structure.html#](http://www.google.com/design/spec/patterns/app-structure.html#)'
- en: The dashboard pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板模式
- en: 'The dashboard pattern is one of the first patterns used in Android. It consists
    of a set of elements displayed on the main screen as a matrix of icons. In the
    following image, we can see one of the first versions of the Facebook app on the
    left-hand side, and to the right, a customization of the pattern from Motor Trend:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板模式是Android中最早使用的模式之一。它由一组在主屏幕上以图标矩阵形式显示的元素组成。在以下图片中，我们可以看到左侧是Facebook应用程序的早期版本，右侧是Motor
    Trend对该模式的定制：
- en: '![The dashboard pattern](img/B04887_02_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![仪表板模式](img/B04887_02_02.jpg)'
- en: This view is great for apps that aim to display a very limited number of options
    clearly; there are no more than two elements per row with a number of rows that
    fits on the screen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视图非常适合那些旨在清晰显示非常有限的选项的应用程序；每行不超过两个元素，行数适合屏幕显示。
- en: These icons clearly display symbols of the main functionality with all the options
    at the same level. It's an ideal pattern for apps that have a large target audience;
    it's straightforward and self explanatory, so anyone can navigate it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图标清晰地展示了主要功能的符号，所有选项都在同一级别。这对于拥有大量目标受众的应用程序来说是一个理想的模式；它简单明了，一目了然，任何人都可以进行导航。
- en: Even though this design seems old, given that it was extensively used in the
    first versions of Android and is used less nowadays, its usage depends on your
    needs, so don't let this put you off. The Motor Trends app shown in the preceding
    image had a very original implementation of this pattern.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个设计看起来很古老，考虑到它曾在Android的第一个版本中被广泛使用，现在使用得较少，但它的使用取决于您的需求，因此不要因此而放弃。前面图片中显示的Motor
    Trends应用程序对这个模式有一个非常原始的实现。
- en: If the elements don't fit on the screen and we need to scroll in order to discover
    them, we need to reconsider the pattern. The same thing applies when we have too
    few elements; there are better options for these cases. In our particular example,
    we have three main elements, so we will not use this pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素不适合屏幕显示，我们需要滚动才能发现它们，那么我们需要重新考虑这个模式。当我们元素太少时也同样适用；这些情况下有更好的选择。在我们的具体示例中，我们有三个主要元素，因此我们将不使用此模式。
- en: The sliding panel
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动面板
- en: This pattern is well known thanks to apps such as Gmail and Facebook. It presents
    a layout at the top level of the UI; screens come out from the left or right when
    we perform a swipe gesture or click on the top left or right button, which usually
    is an icon displayed with three horizontal lines—also know as the Hamburger icon.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式因如Gmail和Facebook等应用而广为人知。它在用户界面的顶层展示一个布局；当我们执行滑动手势或点击左上或右上按钮时，屏幕会从左或右滑出，这个按钮通常是一个显示三条水平线的图标，也被称为汉堡图标。
- en: This pattern is perfect if we have a large number of options at the same level
    in our app, and it can be combined with other patterns, such as **the tabs pattern**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用在同一层级有大量选项，这个模式是完美的，并且它可以与其他模式结合使用，比如**选项卡模式**。
- en: 'The implementation of this panel can be done with the `DrawerLayout` class,
    which is composed of two child views: a `FrameLayout` with the content and the
    navigation drawer, which can be `ListView` or any other custom layout containing
    the options.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板的实现可以通过`DrawerLayout`类完成，它由两个子视图组成：包含内容和导航抽屉的`FrameLayout`，导航抽屉可以是`ListView`或包含选项的任何其他自定义布局。
- en: 'For this, execute the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，执行以下代码：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we select an element in this side panel, a child appears in the middle
    of the screen; this child can help you navigate to a subchild but never to an
    element of the main menu. The child and sub child navigation can be managed with
    the back button or the up navigation in the action bar.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在侧面板中选择了一个元素，屏幕中间就会出现一个子元素；这个子元素可以帮助你导航到子子元素，但绝不能导航到主菜单的元素。子元素和子子元素的导航可以通过后退按钮或操作栏中的向上导航来管理。
- en: We can close the panel by clicking on an item and know whether the panel is
    closed or open by setting a drawer listener, `ActionBarDrawerToggle`, which contains
    the `onDrawerClosed(View drawerView)` and `onDrawerOpened(View drawerView)` methods.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击一个条目来关闭面板，并通过设置一个抽屉监听器`ActionBarDrawerToggle`来知道面板是关闭还是打开，它包含`onDrawerClosed(View
    drawerView)`和`onDrawerOpened(View drawerView)`方法。
- en: Ensure that you use `ActionBarDrawerToggle` from `android.support.v7.app`; the
    one included in v4 is deprecated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的是`android.support.v7.app`中的`ActionBarDrawerToggle`，v4中的已弃用。
- en: 'Another big advantage of this pattern is that it allows group navigation via
    a main item on the menu that can be expanded into subitems. As you can see in
    the following example, Item 4 has three options inside it in a drop-down menu:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的另一个大优点是它允许通过菜单上的主项目进行分组导航，可以展开成子项目。正如以下示例所示，项目4在下拉菜单中有三个选项：
- en: '![The sliding panel](img/B04887_02_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![滑动面板](img/B04887_02_03.jpg)'
- en: An example of a drawer layout
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉布局的一个示例
- en: This would not be suitable for our app as we don't have enough options to make
    the most of this pattern. Also, as this pattern can be combined with the tabs
    pattern, it makes more sense from an educational perspective to develop our example
    with this pattern.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的应用程序来说并不合适，因为我们没有足够的选项来充分利用这个模式。此外，由于这个模式可以与选项卡模式结合，从教育角度来看，用这个模式开发我们的示例更有意义。
- en: Tabs
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项卡
- en: The tabs pattern is a pattern that you have probably seen and used before.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡模式是一种你可能之前见过并使用过的模式。
- en: It shows a fixed menu with components at the same level. Note that when we have
    tabs, the menu is always visible, which doesn't happen in the sliding and dashboard
    patterns. This looks very similar to a web interface and is very user friendly
    considering that the user probably already knows this pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了一个具有同一层级组件的固定菜单。注意，当我们有选项卡时，菜单总是可见的，这在滑动和仪表板模式中不会发生。这看起来与网页界面非常相似，并且考虑到用户可能已经熟悉这个模式，它非常用户友好。
- en: 'The following pattern has two variants: fixed and sliding tabs. If we only
    have a small number of menu items that can fit on the screen, the first variant
    will be the most suitable as it shows the users all the items at once.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式有两个变体：固定和滑动选项卡。如果我们只有少量可以适应屏幕的菜单项，第一个变体将是最合适的，因为它一次向用户展示所有项目。
- en: '![Tabs](img/B04887_02_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![选项卡](img/B04887_02_04.jpg)'
- en: Sliding tabs are usually used when all the items don't fit on the screen or
    when they do fit but we know that more items will be added and won't fit in the
    future.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有项目不适合屏幕或适合但知道将来会添加更多项目而无法容纳时，通常会使用滑动标签页。
- en: 'The implementation of the two variants is slightly different, so we need to
    consider future changes when deciding the variant. Here, we can see an implementation
    of a sliding variant:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变体的实现略有不同，因此我们需要在决定变体时考虑未来的变化。在这里，我们可以看到一个滑动变体的实现：
- en: '![Tabs](img/B04887_02_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![标签页](img/B04887_02_05.jpg)'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that for platform consistency, we must place the tabs at the top of
    the screen; otherwise, people will think that you are an iOS developer!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了平台一致性，我们必须将标签放在屏幕顶部；否则，人们会认为你是iOS开发者！
- en: 'Here are some features and formatting specifications from the material design
    guidelines for you to follow:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供你遵循的材料设计指南中的功能和格式规范：
- en: Present tabs as a single row. Wrap tab labels to a second line if needed and
    then truncate.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标签作为单行呈现。如果需要，将标签文字换行到第二行，然后截断。
- en: Do not include a set of tabbed content within a tab.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在标签页内包含一组标签化内容。
- en: Highlight the tab corresponding to the visible content.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高亮显示与可见内容对应的标签页。
- en: Group tabs together hierarchically. Connect a group of tabs with its content.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按层次结构将标签页分组。将一组标签与其内容连接起来。
- en: Keep tabs adjacent to their content. It helps maintain the relationship between
    the two with less ambiguity.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持标签与其内容相邻。这有助于减少两者之间的歧义，保持关系。
- en: 'In the following image, we can see an example of scrolling/sliding tabs with
    a submenu:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图片中，我们可以看到一个带有子菜单的滚动/滑动标签页的例子：
- en: '![Tabs](img/B04887_02_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![标签页](img/B04887_02_06.jpg)'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The graphic specifications while designing tabs along with more information
    about label specs can be found at [http://www.google.com/design/spec/components/tabs.html#](http://www.google.com/design/spec/components/tabs.html#).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设计标签时图形规格以及有关标签规范更多信息可以在[http://www.google.com/design/spec/components/tabs.html#](http://www.google.com/design/spec/components/tabs.html#)找到。
- en: Now that we know the basics of app navigation, we can explore the components
    that we need to implement these patterns. The main components, as you know, are
    activities and fragments. We are going to implement an example of sliding tabs
    with three fragments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了应用导航的基础知识，我们可以探索实现这些模式所需的组件。正如你所知，主要组件是活动和片段。我们将实现一个带有三个片段的滑动标签页的例子。
- en: Fragments
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段
- en: In this section, we are going to review briefly the key concepts of fragments
    to explain advanced features and components, such as Fragment Manager and the
    fragments back stack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾片段的关键概念，以解释高级功能和组件，如片段管理器和片段回退栈。
- en: 'In our example, we will create an activity called `MainActivity` and four fragments:
    `ListFragment`, `ContactFragment`, `SettingsFragment`, and `DetailsFragment`.
    For this, you can create a `fragments` package and double-click on the package
    to go to **New** | **Fragment** | **Blank Fragment**. Take a look at the following
    dialog box:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将创建一个名为`MainActivity`的活动和四个片段：`ListFragment`、`ContactFragment`、`SettingsFragment`和`DetailsFragment`。为此，你可以创建一个`fragments`包，双击该包装进入**新建**
    | **片段** | **空白片段**。看看以下对话框：
- en: '![Fragments](img/B04887_02_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![片段](img/B04887_02_07.jpg)'
- en: For now, you can create them without the fragment factory methods and the interface
    callbacks. We will cover these later in the chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以不使用片段工厂方法和接口回调来创建它们。我们将在本章后面介绍这些内容。
- en: 'Our project so far should look like this in the **Project** view:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的项目在**项目**视图中应该看起来像这样：
- en: '![Fragments](img/B04887_02_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![片段](img/B04887_02_08.jpg)'
- en: Understanding the importance of fragments
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解片段的重要性
- en: A fragment represents a behavior or a portion of the user interface in an activity.
    You can combine multiple fragments in a single activity to build a multipane UI
    and reuse a fragment in multiple activities. You can think of a fragment as a
    modular section of an activity that has its own lifecycle and receives its own
    input events, which you can add or remove while the activity is running (sort
    of like a *subactivity* that you can reuse in different activities).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 片段代表活动中的行为或用户界面的一部分。你可以在单个活动中组合多个片段来构建多窗格UI，并在多个活动中重用片段。你可以将片段视为活动的模块化部分，它有自己的生命周期并接收自己的输入事件，你可以在活动运行时添加或移除（有点像可以在不同活动中重用的*子活动*）。
- en: '![Understanding the importance of fragments](img/B04887_02_09.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![理解片段的重要性](img/B04887_02_09.jpg)'
- en: The fragment lifecycle is slightly different from the activity lifecycle. The
    first difference we notice is the use of the `OnAttach()` and `OnDetach()` methods,
    which connect the fragment to the activity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 片段的生命周期与活动的生命周期略有不同。我们注意到的第一个区别是使用了`OnAttach()`和`OnDetach()`方法，它们将片段与活动连接起来。
- en: Using `onCreate()`, we can create the view in `OnCreateView()`; after this we
    can call `getView()` in our fragment, and it won't be null.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate()`中使用，我们可以在`OnCreateView()`中创建视图；在这之后，我们可以在片段中调用`getView()`，它不会是null。
- en: The `onActivityCreated()` method tells the fragment that its activity has been
    completed on its own `Activity.onCreate()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`onActivityCreated()`方法告诉片段其活动在其自身的`Activity.onCreate()`中已完成。'
- en: 'There are two ways to display a fragment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以显示一个片段：
- en: 'The first way is to have the fragment in our layout XML. This will create our
    fragment when the view containing it is inflated. Execute the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是在我们的布局XML中拥有片段。这将创建我们的片段，当包含它的视图被填充时。执行以下代码：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second way is to create our fragment programmatically and tell Fragment
    Manager to display it in a container. For this, you can use the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是程序化创建我们的片段，并告诉片段管理器在容器中显示它。为此，你可以使用以下代码：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After this, inflate a `FrameLayout` container where the fragment will be inserted
    using the following lines of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用以下代码行填充一个`FrameLayout`容器，片段将被插入到其中：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To finish with the key concepts, it is important to explain why Android examples
    create the fragments using the `MyFragment.newInstance(params)` factory method
    instead of using the default new `MyFragment(params)` constructor. Take a look
    at the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束关键概念，解释为什么Android示例使用`MyFragment.newInstance(params)`工厂方法创建片段而不是使用默认的`new
    MyFragment(params)`构造函数是很重要的。请看以下代码：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason behind this pattern is that Android only recreates Fragments using
    the default constructor; therefore, if we have a constructor with parameters,
    it will be ignored, and the parameters will be lost.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式背后的原因是，Android只使用默认构造函数重新创建片段；因此，如果我们有一个带参数的构造函数，它将被忽略，参数将丢失。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we send the parameters in a bundle as arguments, allowing the fragment
    to retrieve the parameter if it has to be recreated (due to a device orientation
    change, we use the back navigation).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将参数作为bundle中的参数传递，这样如果片段需要被重新创建（由于设备方向改变，我们使用后退导航），片段就可以检索参数。
- en: The Fragment Manager
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段管理器
- en: The Fragment Manager is an interface used to interact with the fragments inside
    an activity. This means that any operation, such as adding, replacing, removing,
    or finding a fragment, has to be done through it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 片段管理器是一个接口，用于与活动内的片段交互。这意味着任何操作，如添加、替换、移除或查找片段，都必须通过它来完成。
- en: To obtain Fragment Manager, our `Activity` needs to extend from `FragmentActivity`,
    which will allows us to call `getFragmentManager()` or `getSupportFragmentManager()`
    preferably that maintain backwards compatibility using the Fragment Manager included
    in `Android.support.v4`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取片段管理器，我们的`Activity`需要继承自`FragmentActivity`，这将允许我们调用`getFragmentManager()`或`getSupportFragmentManager()`，优先选择后者因为它使用了`Android.support.v4`中包含的向后兼容的片段管理器。
- en: If we want to use nested fragments, we can manage them with `getChildFragmentManager()`.
    You cannot inflate a layout into a fragment when this layout includes `<fragment>`.
    Nested fragments are only supported when added to a fragment dynamically.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用嵌套片段，可以用`getChildFragmentManager()`来管理它们。当布局包括`<fragment>`时，你不能将布局填充到片段中。只有当动态地将嵌套片段添加到片段中时，才支持嵌套片段。
- en: Now, we will discuss some scenarios that we will face sooner or later while
    working with fragments. Imagine that we have an activity with two fragments, A
    and B.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论在使用片段时迟早会遇到的一些场景。设想我们有一个带有两个片段A和B的活动。
- en: A typical scenario is that we are in a fragment and we want to execute a method
    from the activity. In this case, we have two options; one is to implement a `public`
    method in `MyActivity`, for instance `doSomething()`, so that we can cast `getActivity`
    to our activity and call the `((MyActivity)getActivity).doSomething();` method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的情况是，我们处于一个片段中，并希望执行活动中的方法。在这种情况下，我们有两个选择；一个是 在`MyActivity`中实现一个`public`方法，例如`doSomething()`，这样我们可以将`getActivity`强转为我们的活动，并调用`((MyActivity)getActivity).doSomething();`方法。
- en: 'The second way is to make our activity implement an interface defined in our
    fragment, and make the instance of the activity a listener of this interface in
    our fragment during the `onAttach(Activity)` method. We will explain this software
    pattern in [Chapter 4](ch04.html "Chapter 4. Concurrency and Software Design Patterns"),
    *Concurrency and Software Design Patterns*. For the other way around, to get an
    Activity to communicate with a fragment (if we don''t have fragment A instantiated
    in a variable in our activity), we can find the fragment in the manager. A fragment
    can be found using the ID of the container or a tag that we will take a look at
    in the following section:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是让我们的活动实现碎片中定义的接口，并在`onAttach(Activity)`方法中将活动的实例设置为该接口的监听器。我们将在[第4章](ch04.html
    "第4章. 并发与软件设计模式") *并发与软件设计模式*中解释这种软件模式。反过来，如果要让活动与碎片通信（如果我们没有在活动的变量中实例化碎片A），我们可以找到管理器中的碎片。我们将在下一节中查看如何使用容器ID或标签查找碎片：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final scenario would be in fragment A and speaking to B; for this, we just
    need to retrieve the manager from the activity and find the fragment. Run the
    following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是在碎片A中与B对话；为此，我们只需从活动中获取管理器并查找碎片。运行以下代码：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fragments stack
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碎片堆栈
- en: We have been speaking about finding a fragment in fragment manager and this
    is possible thanks to the Fragment Manager stack of fragments where we can add
    or remove fragments during transactions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论在碎片管理器中查找碎片，这要归功于碎片管理器的碎片堆栈，我们可以在事务期间添加或移除碎片。
- en: When we want to display a fragment dynamically, we can decide whether we want
    to add the fragment to the stack or not. Having the fragment on the stack allows
    us to navigate back to the previous fragment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要动态显示一个碎片时，我们可以决定是否要将碎片添加到堆栈中。将碎片放在堆栈上允许我们导航回上一个碎片。
- en: 'This is important for our example; if the user is on the first tab and clicks
    on an item on the list, we want him/her to see the details screen, `DetailsFragment`.
    Now, if the user is on `DetailsFragment` and clicks on the back button, we don''t
    want him/her to leave the App; we want the app to navigate back to the fragment
    stack. This is why when we add `DetailsFragment`, we have to include the `addToBackStack(String
    tag)` option. The tag can either be null, or it can be a `String` type that will
    allow us to find this new fragment by the tag. It will look similar to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们的示例非常重要；如果用户在第一个标签页上，点击列表中的项目，我们希望他能看到详情屏幕，`DetailsFragment`。现在，如果用户在`DetailsFragment`上，点击返回按钮，我们不希望他离开应用；我们希望应用能导航回碎片堆栈。这就是为什么我们在添加`DetailsFragment`时，必须包含`addToBackStack(String
    tag)`选项。标签可以为null，也可以是一个`String`类型，这将允许我们通过标签找到这个新碎片。它将类似于以下内容：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To clarify further, if we wanted to navigate between three fragments, *A to
    B to C*, and then navigate back, having a stack will allow us to go *C to B to
    A*. However, if we don't add the fragments to the back stack or if we add or replace
    them in the same container, *A to B to C*, this will leave us with only the C
    fragment and without the back navigation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步说明，如果我们想在三个碎片之间导航，*从A到B再到C*，然后返回，拥有一个堆栈将允许我们从*C到B再到A*。然而，如果我们不将碎片添加到返回堆栈，或者如果我们在同一个容器中添加或替换它们，*从A到B再到C*，这将只留下C碎片，并且无法进行返回导航。
- en: 'Now, to implement the back navigation in `DetailsFragment`, we have to let
    the activity know that when I click on back, I want to first navigate back in
    the fragment before quitting the app, as it does by default. This can be done
    by overriding `onKeyDown` and handling the fragment navigation if there is more
    than one fragment in the back stack. Run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在`DetailsFragment`中实现返回导航，我们必须让活动知道，当我点击返回时，我想首先在碎片中导航回退，然后才退出应用，这是默认的行为。如果堆栈中有一个以上的碎片，可以通过覆盖`onKeyDown`并处理碎片导航来实现。运行以下命令：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ViewPager
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图翻页器
- en: 'Continuing with our example, we have two ways of navigating between fragments
    on `MainActivity`: either by tapping on the tabs or by swiping between the fragments.
    To achieve this, we will use `ViewPager`, including the sliding tabs inside it,
    which is a very elegant solution with minimal code and includes synchronization
    between swipe and tabs.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的示例，在`MainActivity`上有两种在碎片之间导航的方法：通过点击标签或通过在碎片间滑动。为了实现这一点，我们将使用`ViewPager`，包括其中的滑动标签，这是一个非常优雅的解决方案，代码量最少，并包括滑动与标签之间的同步。
- en: '`ViewPager` can be used to slide any kind of view. We could create a gallery
    of images with `ViewPager`; it is very common to see tutorials in the first run
    of some apps where you can slide the screen with instructions on how the app works,
    and this is achieved with `ViewPager`. To add `ViewPager` to `MainActivity`, we
    can simply copy and paste the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPager`可用于滑动任何类型的视图。我们可以用`ViewPager`创建一个图片画廊；在一些应用首次运行时，常见到使用滑动屏幕来展示如何使用应用的教程，这是通过`ViewPager`实现的。要将`ViewPager`添加到`MainActivity`，我们可以简单复制并粘贴以下代码：'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the end of the *ViewPager* section, we will see how to use different third
    party libraries to improve the experience with tabs and also how to create these
    tabs manually in case we want our custom solution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ViewPager*部分最后，我们将了解如何使用不同的第三方库来改善标签页的体验，以及如果我们想要自定义解决方案，如何手动创建这些标签页。
- en: Adapter
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: '`ViewPager` works with an adapter; the adapter is the element in charge of
    creating every *page* that we swipe. In the particular case of swiping fragments,
    there are extensions of the `Adapter` class called `FragmentPagerAdapter` and
    `FragmentStatePagerAdapter` that we can use:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPager`与适配器一起工作；适配器是负责创建我们滑动的每个*页面*的元素。在滑动片段的特殊情况下，我们可以使用`Adapter`类的扩展，称为`FragmentPagerAdapter`和`FragmentStatePagerAdapter`：'
- en: '`FragmentStatePagerAdapter` saves the state of the page, destroys it when it
    does not appear on screen, and recreates it when necessary, similar to what `ListView`
    does with its rows.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FragmentStatePagerAdapter`保存页面的状态，在屏幕上不显示时销毁它，并在需要时重新创建，类似于`ListView`对其行所做的处理。'
- en: '`FragmentPagerAdapter` keeps all the pages in memory; therefore, it doesn''t
    have the computing cost associated with saving and restoring the state while swiping.
    The number of pages we can have depends on the memory.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FragmentPagerAdapter`将所有页面保存在内存中；因此，在滑动时没有与保存和恢复状态相关的计算成本。我们可以拥有的页面数量取决于内存。'
- en: Depending on the number of elements, we can choose one or the other. If we were
    creating an app to read the news, where you could swipe between lots of news articles
    with images and different content, we wouldn't try to have all of them in the
    memory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据元素的数量，我们可以选择其中一种。如果我们正在创建一个阅读新闻的应用，用户可以在带有图片和不同内容的新闻文章之间滑动，我们不会尝试将所有内容都保存在内存中。
- en: We have three fixed tabs, so we will choose `FragmentPagerAdapter`. We will
    create a package adapter and create a `MyPagerAdapter` class that will extend
    `FragmentPagerAdapter`. While extending it, we are asked to override the `getCount()`
    and `getItem(int i)` methods, which return the count of the items and return an
    item in a given position.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个固定标签，因此我们将选择`FragmentPagerAdapter`。我们将创建一个包适配器，并创建一个扩展`FragmentPagerAdapter`的`MyPagerAdapter`类。在扩展它时，我们需要覆盖`getCount()`和`getItem(int
    i)`方法，这些方法返回项目的数量和给定位置的项目。
- en: 'After creating a constructor and completing the methods, our class will look
    similar to the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建构造函数并完成方法后，我们的类将类似于以下代码：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To finish, we need to set the adapter to the pager in `MainActivity`. Execute
    the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`MainActivity`中将适配器设置到页面。执行以下代码：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sliding tabs
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动标签
- en: At this point in our example, we are able to swipe between our fragments. Now,
    we will add tabs using `PagerTabStrip` or `PagerTitleStrip`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，此时我们已经能够在片段之间滑动。现在，我们将使用`PagerTabStrip`或`PagerTitleStrip`添加标签。
- en: 'There is a very elegant way to achieve this, which is including `PageTabStrip`
    in the XML tag of `ViewPager`. Execute the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种非常优雅的实现方式，即在`ViewPager`的XML标签中包含`PageTabStrip`。执行以下代码：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `PagerTabStrip` will find the tile of the page, and for each page, it
    will display a tab. We need to add the `getPageTitle` method in `MyPagerAdapter`,
    which will return a string for every page. In our case, this would be the name
    of the sections: list, contacts, and settings. For this, you can use the following
    code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PagerTabStrip`会找到页面的标题，并为每个页面显示一个标签。我们需要在`MyPagerAdapter`中添加`getPageTitle`方法，这将返回每个页面的字符串。在我们的案例中，这将是部分名称：列表、联系人及设置。为此，你可以使用以下代码：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the app, and voila! We have a fluent tab and sliding navigation supporting
    Android 1.6 (API 4) implemented really easily:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用，瞧！我们轻松实现了一个流畅的标签页和滑动导航支持，支持Android 1.6（API 4）：
- en: '![Sliding tabs](img/B04887_02_10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![滑动标签](img/B04887_02_10.jpg)'
- en: Customizing tabs
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义标签
- en: There is a long story behind tabs in Android; initially, tabs were implemented
    with `TabActivity` but this was deprecated in API 13 and evolved into `FragmentTabHost`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的标签有一段很长的历史；最初，标签是通过`TabActivity`实现的，但在API 13中被废弃，并演变成了`FragmentTabHost`。
- en: So, I happily developed an app with `TabHost` following the Android documentation,
    and I realized this had to be changed. At first, I crossed my fingers hoping that
    the deprecation wouldn't affect my app until some users complained about crashes.
    Then, inevitably, I had to remove my deprecated `TabHost` and find a new way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我按照Android文档，开心地使用`TabHost`开发了一个应用，并意识到这必须改变。起初，我抱着侥幸心理，希望废弃不会影响我的应用，直到一些用户抱怨崩溃问题。然后，不可避免地，我必须移除废弃的`TabHost`并寻找新方法。
- en: At first, `FragmentTabHost` seemed a good way to have fixed tabs, but it didn't
    allow tabs with icons on them. Upon having this problem and finding other people
    with the same problem in Stack Overflow at [http://stackoverflow.com/](http://stackoverflow.com/)
    (a website where we can ask questions and find answers on Android and other topics),
    I decided to find another way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，`FragmentTabHost`似乎是拥有固定标签的好方法，但它不允许标签上带有图标。在遇到这个问题，并在Stack Overflow上发现其他人也有同样的问题时（一个我们可以提问和找到关于Android和其他主题答案的网站），我决定寻找其他方法。
- en: In API 11, the concept of `ActionBar.Tab` appeared, which was a class that allowed
    us to add tabs to the action bar. Finally, I found a way to have tabs in my app,
    which resulted in happy users! But this joy didn't last for long; `ActionBar.Tab`
    was deprecated again!!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在API 11中，出现了`ActionBar.Tab`的概念，这是一个允许我们向操作栏添加标签的类。最终，我找到了一种在应用中添加标签的方法，这让用户很开心！但这种喜悦并未持续太久；`ActionBar.Tab`又被废弃了！
- en: This is something that would end up the patience of any developer; this made
    me create my own tabs as buttons in `LinearLayout`. Setting a click listener on
    the buttons and when clicking on a tab I was swiping the `ViewPager` to the right
    page, and the other way around, when detecting a page swipe on the `ViewPager`
    I was selecting the right tab. It was worth the effort because it allowed me to
    have all the freedom that I wanted with the tabs design, and more importantly
    gave me the satisfaction that it would always work (unless one day they deprecate
    `LinearLayout` or `Button`!).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这件事会让任何开发者的耐心耗尽；这让我创建了在`LinearLayout`中以按钮形式呈现的标签。在按钮上设置点击监听器，点击标签时，我会将`ViewPager`滑动到正确的页面，反之亦然，当检测到`ViewPager`页面滑动时，我会选择正确的标签。努力是值得的，因为它让我在设计标签时有完全的自由度，更重要的是，它给了我满足感，除非有一天`LinearLayout`或`Button`被废弃，否则它总是能工作！
- en: You can always leave your own implementation as the last option. Nowadays, if
    you don't like the sliding tabs design, you have other alternatives from third-party
    libraries, such as `ViewPagerIndicator` and `PagerSlidingTabStrip`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你总可以将自己的实现作为最后的选择。如今，如果你不喜欢滑动标签的设计，还有第三方库的其他选择，比如`ViewPagerIndicator`和`PagerSlidingTabStrip`。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about this, you can check out the following links:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多信息，你可以查看以下链接：
- en: '[https://github.com/JakeWharton/ViewPagerIndicator](https://github.com/JakeWharton/ViewPagerIndicator)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[ViewPagerIndicator的GitHub仓库](https://github.com/JakeWharton/ViewPagerIndicator)'
- en: '[https://github.com/astuetz/PagerSlidingTabStrip](https://github.com/astuetz/PagerSlidingTabStrip)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[PagerSlidingTabStrip的GitHub仓库](https://github.com/astuetz/PagerSlidingTabStrip)'
- en: Transitions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡效果
- en: Small details such as creating our own animations from the screen transitions
    will polish our app and really make it look more professional.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 比如创建我们自己的屏幕过渡动画等小细节，这些都能让我们的应用更加精致，看起来更加专业。
- en: 'Our example is perfect to talk about transitions as we have two types of screen
    transitions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例非常适合讨论过渡，因为我们有两种类型的屏幕过渡：
- en: The first one is a transition between Activities, from `SplashActivity` to `MainActivity`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个转换是活动之间的转换，从`SplashActivity`到`MainActivity`
- en: The second one (not implemented yet) is a transition between fragments, where
    `ListFragment` is replaced with `DetailsFragment`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个转换（尚未实现）是片段之间的转换，其中`ListFragment`被`DetailsFragment`替换。
- en: 'For the transitions between activities, we need to call `overridePendingTransition`
    just before starting the new activity. The method receives two animations as parameters,
    and these animations can be in an XML file created by us or be chosen from the
    already created animations in Android. Run the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于活动之间的过渡，我们需要在启动新活动之前调用`overridePendingTransition`。该方法接收两个动画作为参数，这些动画可以是我们创建的XML文件中的，也可以是Android中已经创建的动画。运行以下命令：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our example, we don''t allow back navigation to `SplashActivity`; however,
    if we were in a transition between activities where we wanted to have the same
    transition when we click on back, we would have to override the back key press
    and set our transition there. For this, you can run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们不允许可返回导航到`SplashActivity`；然而，如果我们处于活动之间的过渡，并希望在点击返回时拥有相同的过渡效果，我们就必须重写返回键并在此处设置我们的过渡效果。为此，你可以运行以下命令：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the case of fragments, we need to specify the transition in the `FragmentTransaction`
    object. Using the object animator, we can define this in two files: `enter.xml`
    and `exit.xml`. Execute the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段的情况下，我们需要在`FragmentTransaction`对象中指定过渡。使用对象动画师，我们可以在两个文件中定义这一点：`enter.xml`和`exit.xml`。执行以下代码：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For Android Lollipop and the later versions, you can set the transition directly
    to the Fragment. Use the following snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android Lollipop及其之后的版本，你可以直接为Fragment设置过渡。使用以下代码片段：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the end of this chapter, you should have an understanding of the basic navigation
    patterns and be able to translate the idea of an app in your mind into the real
    structure of an Android app. Fragments are a key concept in Android development,
    and we have spent enough time in this chapter mastering them with a review of
    Fragment Manager and the fragments back stack and by learning how to face common
    problems such as communication between them. We considered a working example of
    `ViewPager` with `PagerTabStrip` showing the tile of the pages as tabs, which
    you now know how to customize if needed. We have a skeleton of an app; this project
    can be saved at this stage and used as a template for your future developments.
    We are ready to continue evolving our app.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该了解基本的导航模式，并能将你心中应用程序的想法转化为Android应用程序的实际结构。Fragments是Android开发中的关键概念，我们在本章中已经花费足够的时间通过复习Fragment
    Manager和片段回退栈来掌握它们，并学习如何面对诸如它们之间的通信等常见问题。我们考虑了一个带有`PagerTabStrip`的`ViewPager`的工作示例，它将页面标题作为标签显示，你现在知道如果需要如何自定义它。我们有一个应用程序的框架；这个项目可以在这一阶段保存，并用作你未来开发的模板。我们已经准备好继续发展我们的应用程序。
- en: In the next chapter, we will see how to create and access the content that will
    populate our fragments and `ViewPager` to bring our app to life.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建和访问将填充我们片段和`ViewPager`的内容，以使我们的应用程序生动起来。
