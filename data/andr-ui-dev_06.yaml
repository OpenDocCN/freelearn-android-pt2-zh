- en: Chapter 6. Validating and Handling Input Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 验证和处理输入数据
- en: '*Unfortunately, the validation and handling of input in an application is often
    an afterthought in the design process. These should be at the forefront of your
    thoughts during the second round of drafts for the user interface. A touchscreen
    device offers many more opportunities to streamline the capturing of data from
    the user, in many cases removing the need for sanitation or validation, while
    at the same time massively improving the user''s experience with the application.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，在应用程序中验证和处理输入通常在设计过程中是一个后顾之忧。这些应该在用户界面第二轮草稿中的首要考虑事项。触摸屏设备提供了许多机会来简化从用户那里捕获数据的流程，在许多情况下，无需进行数据清理或验证，同时大幅提升用户的应用体验。*'
- en: Android provides an excellent toolset to capture many different types of data
    from the user, while also providing loose coupling between your application components
    in the form of `Intent` structures. By using several smaller `Activity` classes
    to capture data, while at the same time abstracting the functionality to capture
    different types of input, you'll be able to more easily reuse the input capturing
    `Activity` classes, not just within the application, but in other applications
    as well. Further, by registering the `Activity` correctly, you'll allow other
    applications to override, or make use of your `Activity` implementation, allowing
    the users to select their preferred capturing mechanism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了一个优秀的工具集，以捕获用户的各种不同类型的数据，同时以`Intent`结构的形式为应用程序组件之间的松耦合提供支持。通过使用几个较小的`Activity`类来捕获数据，同时抽象出捕获不同类型输入的功能，你将能够更容易地重用输入捕获`Activity`类，不仅在应用程序内，也可以在其他应用程序中使用。此外，通过正确注册`Activity`，你将允许其他应用程序覆盖或使用你的`Activity`实现，让用户选择他们偏好的捕获机制。
- en: Dealing with undesirable input
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不期望的输入
- en: Often applications require specific types of input from their users. An application
    captures input from its user in order for the user to tell it something about
    the world. This could be anything, from what the user is looking for (that is,
    a search term), to something about the users themselves (that is, their age).
    In most of these cases, the users can be guided in the way they give the input
    using mechanisms, such as an auto-completion box. However, if a user can give
    you "undesirable" input, then somewhere along the line one of them will.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应用程序需要其用户输入特定类型的数据。应用程序从用户那里捕获输入是为了让用户告诉它关于世界的一些信息。这可以是任何东西，从用户正在寻找的内容（即一个搜索词），到关于用户自己的信息（即他们的年龄）。在大多数这些情况下，可以使用诸如自动完成框之类的机制引导用户输入。然而，如果用户可以给你“不期望”的输入，那么在某些环节中就会发生。
- en: 'Undesirable input can be anything ranging from text where a number is expected,
    through to a search term that yields no results. In both cases, you need to do
    three things:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不期望的输入可以是任何从预期数字却输入文本，到搜索词没有结果的各种情况。在这两种情况下，你需要做三件事：
- en: Inform the user about the format you expect the data to be in
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉用户你期望数据以何种格式输入
- en: Let them know that they entered undesirable data
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让他们知道他们输入了不期望的数据
- en: Let them re-enter the data
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让他们重新输入数据
- en: Correctly labeling input
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确标记输入
- en: 'Your first defense against undesirable input from your users is to correctly
    label of an input widget. This doesn''t just mean, having a label that reads as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 防止用户输入不期望数据的第一道防线是正确标记输入控件。这不仅仅意味着，有一个如下所示的标签：
- en: '`Date of Birth (dd/mm/yy):`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`出生日期（dd/mm/yy）：`'
- en: It means using the correct widget to capture the data. Your input widgets are
    a form of a label, they indicate to the user what sort of data you expect them
    to enter. In many cases, they can be used to stop the user from entering invalid
    data, or at least make it less likely.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用正确的控件来捕获数据。你的输入控件是一种标签，它们向用户指示你期望他们输入哪种类型的数据。在许多情况下，它们可以用来阻止用户输入无效数据，或者至少降低这种可能性。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind the way that users expect things to work, and that they expect
    to be able to select things quickly. If you need them to give your application
    the name of a country, don't use a `Spinner` and force them to scroll through
    a seemingly endless list of names.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要牢记用户期望事物的工作方式，以及他们期望能够快速选择事物。如果你需要他们为你的应用程序提供一个国家的名字，不要使用`Spinner`并强迫他们浏览看似无尽的名称列表。
- en: Signaling undesirable input
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号不期望的输入
- en: If the user does enter something unwanted or useless, you need to tell them,
    and fast! The sooner you let the user know that they've given you something useless,
    the sooner they can correct it and get back to using your application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确实输入了不希望或无用的内容，你需要迅速告诉他们！你越早让用户知道他们给了你无用的东西，他们就能越快地改正并回到使用你的应用程序。
- en: A common mistake is to simply `Toast` the user when they press a **Save** or
    **Submit** button. While this is okay if you can only determine their mistake
    at that point, but you can almost always figure it out beforehand.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是在用户按下**保存**或**提交**按钮时简单地`Toast`通知用户。虽然如果你只能在那时确定他们的错误，这样做是可以的，但你几乎总是可以提前弄清楚。
- en: Bear in mind that on a touchscreen device, while you have a "focused" widget,
    it doesn't play the same role as on a desktop system, and the user isn't going
    to "tab" off the widget. This means that as far as possible, your user interface
    should respond live to the user's actions, not wait for them to do something else
    (that is, select another widget) before giving them some feedback. If they do
    something that makes another form element invalid to use, disable it. If they
    do something that makes a group of widgets invalid, hide the entire group from
    them or put it on a different screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在触摸屏设备上，虽然你有一个“聚焦”的小部件，但它并不像在桌面系统上那样发挥作用，用户不会“跳转”离开小部件。这意味着，只要可能，你的用户界面就应该实时响应用户的操作，而不是等待他们做其他事情（即选择另一个小部件）后才给予反馈。如果他们做了使另一个表单元素无效的事情，就禁用它。如果他们做了使一组小部件无效的事情，就将整个组从他们那里隐藏或放在另一个屏幕上。
- en: '![Signaling undesirable input](img/4484_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![表示不希望的输入](img/4484_06_01.jpg)'
- en: Coloring and icons are both great ways to quickly tell the user they've got
    something wrong. You can take the additional step of disabling any sort of **Save**,
    **Next**, or **Submit** button when you realize that some of the user's input
    is wrong. However, if you do disable such a button, ensure that it is clear which
    form element has undesirable data on it, and make sure it is on their screen.
    A great alternative is to `Toast` the user when they select a **Next** button,
    and scroll to the invalid element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用颜色和图标是快速告诉用户他们做错了事情的好方法。当你意识到用户的某些输入是错误的时候，你可以采取额外的步骤，禁用任何**保存**、**下一步**或**提交**按钮。但是，如果你禁用这样的按钮，请确保清楚哪个表单元素上有不理想的数据，并确保它显示在屏幕上。一个很好的替代方法是当用户选择**下一步**按钮时`Toast`通知用户，并滚动到无效元素。
- en: Make use of background (or asynchronous) messages if you need to check the users'
    input against some remote service. This will allow you to validate the user's
    content as they are using the application. It'll also allow you to signal that
    something is wrong without stopping them from using the rest of the form. They
    can always come back to the invalid field and correct it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要检查用户的输入是否与某些远程服务相匹配，请使用后台（或异步）消息。这将允许你在用户使用应用程序时验证用户的内容。它还允许你在不阻止他们使用表单的其余部分的情况下，指出某些地方出了问题。他们总是可以回到无效字段并进行更正。
- en: Recovering from undesirable input
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从不受欢迎的输入中恢复。
- en: Always ensure that fixing a mistake is as painless as possible for the user.
    The more work they have to do to correct a misspelled word (or similar), the more
    likely it is that they will stop using the application. The easiest way to recover
    from undesirable input (which happens to fit nicely with the above comments) is
    to tell the user about it before they have a chance to move to another part of
    the process. However, this isn't always possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要确保用户纠正错误尽可能无痛。他们为了改正一个拼写错误（或类似的错误）而需要做的工作越多，他们停止使用应用程序的可能性就越大。从不受欢迎的输入中恢复（这与上述评论非常契合）的最简单方法是在用户有机会进入流程的另一部分之前告诉他们。然而，这并不总是可能的。
- en: 'There are times when you need to pop up a **Please Wait** dialog during a process
    that will (generally as a side effect) validate the users input. In these cases,
    it''s wise to use a `ProgressDialog` so you don''t move the user away from your
    current `Activity` during this phase. This will have two important side effects:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些流程中，你可能需要弹出一个**请等待**对话框，这通常会（作为副作用）验证用户的输入。在这种情况下，使用`ProgressDialog`是明智的，这样你就不会在这个阶段将用户从当前`Activity`中移开。这将带来两个重要的副作用：
- en: You don't add unnecessary layers to the activity stack
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不要向活动堆栈中添加不必要的层次。
- en: The input the user gave is still available when you close the `ProgressDialog`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你关闭`ProgressDialog`时，用户给出的输入仍然可用。
- en: Giving users direct feedback
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给用户提供直接反馈。
- en: When accepting text or other keyboard input from the users, it's best to signal
    its validity to the users while they are still entering it. A common method is
    to use an `ImageView` to the right of the `EditText` widget, and changing the
    image content to signal whether the user has entered valid or invalid content.
    The image displayed in the `ImageView` can be set, based on whether the input
    is currently valid or not. This gives the user a live view of the validation process.
    This mechanism also works well for signaling variable levels of validation (that
    is, when the input is not strictly valid or invalid, but rather good quality or
    undesirable quality), such as in the case of a password input.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当接受用户输入文本或其他键盘输入时，最好在用户输入过程中向他们指示输入的有效性。一个常见的方法是在`EditText`组件右边使用一个`ImageView`，并通过更改图像内容来指示用户输入的是有效还是无效内容。`ImageView`中显示的图像可以根据输入当前是否有效来设置。这使用户能够实时查看验证过程。这种机制也适用于指示不同级别的验证（即输入不是严格的有效或无效，而是良好质量或不良质量），如在密码输入的情况下。
- en: You can either make use of image icons, or simply use an Android drawable XML
    resource to represent the validity (that is, green for valid, red for invalid).
    This also means that your icon will scale to any size that you prescribe to it
    in your layout XML file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用图像图标，或者简单使用一个Android可绘制XML资源来表示有效性（即绿色表示有效，红色表示无效）。这也意味着你的图标会根据你在布局XML文件中指定的任何大小进行缩放。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Colors and icons**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色和图标**'
- en: It's often a good idea to use a non-color indicator to differentiate icons.
    Someone who is color blind may find it difficult or impossible to tell the difference
    between two icons unless you change the shape as well as the color. Having your
    "valid" icon as a green circle, and your "invalid" icon as a red hexagon will
    make your application more usable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用非颜色指示器来区分图标是一个好主意。色盲的人可能很难或无法区分两个仅颜色不同的图标，除非你同时改变形状和颜色。将“有效”图标设为绿色圆形，而“无效”图标设为红色六边形，将使你的应用程序更具可用性。
- en: In order to avoid cluttering your screen with icons, you may want to display
    only the validation icon next to the field the user is currently working with.
    It's a good idea however, to make use of the `INVISIBLE View` state instead of
    `GONE` in order to avoid changing the layout when the user changes the focus of
    the user interface. At the same time, please ensure that validation icons are
    the same size.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免屏幕上图标过多，你可能只想在用户当前操作的领域旁边显示验证图标。然而，使用`INVISIBLE View`状态而不是`GONE`是一个好主意，以避免用户改变用户界面焦点时改变布局。同时，请确保验证图标大小一致。
- en: Avoiding invalid input entirely
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全避免无效输入
- en: Remember that with a mobile device, time is often a constraint for the user.
    For this reason (and for simple usability reasons) you should generally strive
    to avoid invalid input from your users entirely. Android provides you with several
    mechanisms with which to do this, and it's wise to make use of them at every opportunity.
    Generally, you will want to make use of widgets that avoid validation requirements.
    This is almost always an option in Android, and even when your requirements are
    more complex than simple type information, you can generally customize the widget
    to stop the user from breaking your validation rules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在使用移动设备时，时间往往对用户是一种限制。因此（出于简单易用的原因），你通常应该尽力避免用户输入无效内容。Android为你提供了多种机制来实现这一点，在每一个机会都利用它们是明智的。通常，你会想要使用那些避免验证需求的组件。在Android中这几乎总是一个选项，即使你的需求比简单的类型信息更复杂，你也可以通常自定义组件，以阻止用户违反你的验证规则。
- en: Capturing date and time
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获日期和时间
- en: As we've already discussed, when inputting date and time you should make use
    of `DatePicker` and `TimePicker` widgets, or the `DatePickerDialog` and `TimePickerDialog`
    to avoid the layout issues that the primitive widgets introduce.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已讨论的，在输入日期和时间时，你应该使用`DatePicker`和`TimePicker`组件，或使用`DatePickerDialog`和`TimePickerDialog`以避免基本组件引入的布局问题。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid creating your own calendar widget unless it's a hard requirement of your
    application. You may not like how a `DatePickerDialog` looks, but users have seen
    them in other Android applications and know how to use them. It's also possible
    that these standard widgets are improved in future Android releases, giving your
    application an improvement with no work from your side.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的应用程序有严格的要求，否则不要创建自己的日历小部件。你可能不喜欢`DatePickerDialog`的外观，但用户在其他Android应用程序中已经见过它们，并且知道如何使用。这些标准小部件还可能在未来的Android版本中得到改进，从而让你的应用程序在不做任何修改的情况下得到提升。
- en: '![Capturing date and time](img/4484_06_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![捕获日期和时间](img/4484_06_02.jpg)'
- en: You may find that you need additional validation for date and time inputs, especially
    when capturing date or time ranges. For example, if you ask a user for a date
    of birth, the user shouldn't be able to enter a field that indicates any time
    later than "today" (unless it's an expected date of birth). While the `DatePicker`
    class has an event listener which allows you to listen for changes to its data
    (and `DatePickerDialog` implements this event listener), you cannot use this event
    listener to cancel the change event.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，对于日期和时间输入，你需要额外的验证，特别是在捕获日期或时间范围时。例如，如果你要求用户输入出生日期，用户不应该能够输入晚于“今天”的任何时间（除非是预期的出生日期）。虽然`DatePicker`类有一个事件监听器，允许你监听对其数据的更改（`DatePickerDialog`实现此事件监听器），但你不能使用此事件监听器来取消更改事件。
- en: Therefore, in order to **Cancel** the event, you need to change the input back
    to something valid while the event is executing. This is a surprisingly simple
    trick in Android. Since the events are executed on the same thread that does the
    painting, it allows you to change the value before the invalid data is rendered
    on the screen. The following is a simple example of a `ValidatingDatePickerDialog`
    which you can use in order to implement a simple level of date validation in your
    application. Another such class could be easily written for `TimePickerDialog`
    if you needed one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了**取消**事件，你需要在事件执行期间将输入改回有效的值。这是Android中一个出奇简单的技巧。由于事件是在进行绘制的同一线程上执行的，这允许你在无效数据在屏幕上渲染之前更改值。以下是一个`ValidatingDatePickerDialog`的简单示例，你可以使用它来实现应用程序中简单的日期验证级别。如果你需要，也可以轻松地为`TimePickerDialog`编写类似的类。
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method of handling validation can be used in most Android widgets that
    don't offer implicit validation of their events, and it offers a much better user
    experience than giving the user a `Toast` with the text **Please enter a valid
    date of birth**. It also avoids the need for additional layers of validation in
    your application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理验证的方法适用于大多数不提供事件隐式验证的Android小部件，并且它比给用户一个带有文本 **请输入一个有效的出生日期** 的`Toast`
    提供了更好的用户体验。它还避免了在应用程序中增加额外验证层的需要。
- en: Using spinners and ListView for selection
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用下拉菜单和列表视图进行选择
- en: There are many times when the user needs to select something from a list of
    possible values in an application. We've already discussed `Spinner` and `ListView`
    widgets in [Chapter 2](ch02.html "Chapter 2. Presenting Data for Views"), *Presenting
    Data for Views*. However, they offer several features that can be very useful
    when it comes to validation. They are implicitly validated widgets, that is, it's
    impossible for the user to enter incorrect data since the possible values for
    input are defined by the application. However, what about when the set of valid
    items changes based on other user input, or some external source of information?
    In these cases, several options are available to you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，用户经常需要从可能的值列表中选择某项。我们在[第2章](ch02.html "第2章. 视图的展示数据") *视图的数据展示* 中已经讨论了`Spinner`和`ListView`小部件。然而，当涉及到验证时，它们提供的几个特性非常有用。它们是隐式验证的小部件，也就是说，由于输入的可能值是由应用程序定义的，用户不可能输入错误的数据。但是，当有效项目集基于其他用户输入或某些外部信息源改变时该怎么办呢？在这些情况下，你有几个选项可用。
- en: Changing the data set
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改数据集
- en: The simplest method of stopping the user from selecting a value that is no longer
    valid is to remove it from the data set. We've already done a similar thing in
    `BurgerAdapter`, in [Chapter 2](ch02.html "Chapter 2. Presenting Data for Views"),
    *Presenting Data for Views,* where we modified the data set when the user touched
    certain items. Modifying the data set of an `AdapterView` is a good idea because
    it "takes the option off the menu". However, it doesn't work well with the `Spinner`
    class, since, if the item is removed off the screen, the user will be left wondering
    what happened to the item that was there just a second ago (and may be concerned
    that they are going mad).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止用户选择不再有效的值的简单方法是将其从数据集中移除。我们在`BurgerAdapter`中已经做过类似的事情，在[第2章](ch02.html "第2章.
    为视图提供数据")，*为视图提供数据*，当用户触摸某些项目时，我们修改了数据集。修改`AdapterView`的数据集是一个好主意，因为它“从菜单中移除了选项”。然而，它并不适用于`Spinner`类，因为如果项目从屏幕上移除，用户会想知道刚才还在那里的项目去哪了（可能会担心自己是否疯了）。
- en: In order not to confuse or frustrate your users, you should only remove items
    from a `Spinner` or `ListView` data set if the item will probably not be added
    back into the data set. A good example of this requirement is a list of Wi-Fi
    networks available, or Bluetooth devices within range. In both of these cases,
    the list of available items is defined by the environment. The user will accept
    that the displayed options are not always going to be available to them, and new
    items may appear from time to time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆或让用户感到沮丧，只有当某个项目可能不会重新添加到数据集中时，才应该从`Spinner`或`ListView`数据集中移除项目。一个符合这一要求的好例子是可用的Wi-Fi网络列表或范围内的蓝牙设备列表。在这两种情况下，可用的项目列表由环境定义。用户会接受显示的选项并不总是对他们可用，而且新的项目可能会时不时出现。
- en: Disabling selections
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用选择
- en: An alternative and usually more user-friendly method of stopping certain items
    from being selected is to disable them. You can make the `ListView` or `Spinner`
    ignore items by overriding the `isEnabled(int)` method in the `ListAdapter` class.
    However, this method will only disable the item at the event level, the item will
    still appear as enabled (it's primary purpose is to define separator views).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代的、通常对用户更友好的阻止某些项目被选中的方法是禁用它们。你可以通过覆盖`ListAdapter`类中的`isEnabled(int)`方法，让`ListView`或`Spinner`忽略项目。然而，这种方法只会在事件级别上禁用项目，项目仍然会显示为启用状态（它的主要目的是定义分隔视图）。
- en: In order to visually disable an item, you'll need to disable the `View` that
    the item is displayed in. This is a very effective way of telling the user, "You've
    changed something that has made this item unavailable". Graphically disabling
    an item also lets the user know that it may become available in the future.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在视觉上禁用一个项目，你需要禁用显示该项目的`View`。这是告诉用户“你改变了某些东西，使得这个项目不可用”的一种非常有效的方式。图形化地禁用一个项目也让用户知道它将来可能会变得可用。
- en: Capturing text input
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获文本输入
- en: The most difficult inputs to work with are the various forms of text input.
    I find that working with a soft keyboard may not be as quick as working with a
    hardware keyboard, but from a development point of view it offers something that
    a hardware keyboard does not—flexibility. When I want to enter text into a field,
    a soft keyboard's state will indicate the type of input that is valid for that
    field. If I'm supposed to enter a phone number, the keyboard can display only
    numbers, or even change into a dial pad. This not only indicates to me what I'm
    supposed to do, but also stops me from inputting anything that would cause a validation
    error.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最难处理的输入是各种文本输入形式。我发现使用软键盘可能不如使用硬件键盘快，但从开发角度来看，它提供了硬件键盘所不具备的东西——灵活性。当我想要在字段中输入文本时，软键盘的状态将指示该字段有效的输入类型。如果我需要输入电话号码，键盘可以只显示数字，甚至变成拨号盘。这不仅告诉我应该做什么，还阻止我输入可能导致验证错误的内容。
- en: The Android `TextView` (and thus the `EditText`) widgets provide you with a
    host of different options and methods by which you can define complex validation
    rules for text input. Many of these options are also understood by various soft
    keyboards, allowing them to display subsets of the full keyboard based on how
    the `TextView` widget has been configured. Even if not fully understood by the
    soft keyboard (or if a hardware keyboard is in use), the rules of the specified
    option must be adhered to. The easiest way to tell the `EditText` what type of
    data you want it to capture is with the `inputType` XML attribute.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓的`TextView`（以及`EditText`）控件为你提供了众多不同的选项和方法，通过这些你可以为文本输入定义复杂的验证规则。这些选项中的许多也被各种软键盘所理解，使得它们可以根据`TextView`控件的配置显示完整键盘的子集。即使软键盘不完全理解（或使用硬件键盘时），也必须遵守指定选项的规则。最简单的方法是使用`inputType`
    XML属性来告诉`EditText`你希望它捕获的数据类型。
- en: As you'll see from the `inputType` documentation, all of its possible values
    are different combinations of the bit masks available in the `android.view.inputmethod.InputType`
    interface. The options available as values to the `inputType` attribute will cover
    most cases where you need to capture a specific type of input. You can also create
    your own, more complex input types by using the `TextView.setRawInput` or `TextView.setKeyboardListener`
    methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从`inputType`的文档中，你可以看到其所有可能的值都是`android.view.inputmethod.InputType`接口中可用的位掩码的不同组合。`inputType`属性可用的选项将涵盖大多数需要捕获特定类型输入的情况。你也可以通过使用`TextView.setRawInput`或`TextView.setKeyboardListener`方法创建自己的更复杂的输入类型。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Keyboard listeners**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**键盘监听器**'
- en: As far as possible, you should either use the input type or a standard `KeyListener`
    to handle your text validation. Writing a `KeyListener` is a non-trivial task,
    and in some cases may see you implementing a custom soft keyboard. A `KeyListener`
    in Android, which defines an input type other than `TYPE_NULL`, may not have its
    listener events (`onKeyDown`, `onKeyUp`, and `onKeyOther`) invoked at all if a
    soft keyboard is present. The key events of a `KeyListener` are only used to accept
    or reject events from a hardware keyboard. Software keyboards use the input type
    attribute of a `TextView` to decide what functionality they should provide to
    the user.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，你应该使用输入类型或标准的`KeyListener`来处理你的文本验证。编写一个`KeyListener`并非易事，在某些情况下，你可能需要实现一个自定义软键盘。在安卓中，如果一个软键盘存在，定义了除`TYPE_NULL`之外输入类型的`KeyListener`可能根本不会调用其监听事件（`onKeyDown`、`onKeyUp`和`onKeyOther`）。`KeyListener`的按键事件仅用于接受或拒绝来自硬件键盘的事件。软件键盘使用`TextView`的输入类型属性来决定应向用户提供哪些功能。
- en: Autocompleting text input
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动完成文本输入
- en: The `Spinner` and `ListView` widgets are great ways to ask your user to select
    from a predefined list of options. However, both have a major flaw in that they
    don't scale well to very long lists. While the implementation and performance
    are both very good, users just don't like looking through massive lists of data.
    The standard way to solve this problem is to provide an auto completed text input
    widget.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spinner`和`ListView`控件是让用户从预定义选项列表中选择的好方法。然而，它们的主要缺点是不适合非常长的列表。尽管实现和性能都很好，用户只是不喜欢查看大量数据列表。解决这个问题的标准方法是提供一个自动完成的文本输入控件。'
- en: '![Autocompleting text input](img/4484_06_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![自动完成文本输入](img/4484_06_03.jpg)'
- en: Autocompleted input widgets are also often used with a history of past options
    that the user has given, or to suggest possible ways the user may want to "complete"
    their input. The Android `AutoCompleteTextView` widget is an `EditText` with autocompletion
    capabilities. It uses a `ListAdapter` (which must also implement the `Filterable`
    interface) to find and display the list of possible suggestions to the user.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 带有自动完成功能的输入控件也常与用户过去提供的选项历史一起使用，或者建议用户可能想要“完成”输入的可能方式。安卓的`AutoCompleteTextView`控件是一个带有自动完成功能的`EditText`。它使用一个`ListAdapter`（也必须实现`Filterable`接口）来查找并显示可能的建议列表给用户。
- en: 'However, an `AutoCompleteTextView` has two major flaws:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`AutoCompleteTextView`存在两个主要缺陷：
- en: It's still a `TextView` and the user is not forced to select one of the suggested
    items, this means that its content must be validated separately.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仍然是一个`TextView`，并且用户并不需要选择建议项之一，这意味着它的内容必须单独验证。
- en: The suggestion list is displayed directly below the widget, consuming a fair
    amount of screen space. Combined with a soft keyboard for input, the user interface
    may become cluttered or almost unusable on a small screen
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示列表直接显示在小部件下方，占用了相当大的屏幕空间。结合软键盘输入，用户界面可能会在小屏幕上变得杂乱无章或几乎无法使用。
- en: Both of these issues can be solved by using the `AutoCompleteTextView` class
    carefully and sparingly. They are brilliantly useful when you need a search box,
    URL input, or something similar but they are often not suitable for placing in
    the middle of the screen (they are best placed at the top where they have plenty
    of space for the suggestion list).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过谨慎和适度地使用`AutoCompleteTextView`类，可以解决这两个问题。当你需要一个搜索框、URL输入或类似的东西时，它们非常有用，但它们通常不适合放在屏幕中间（最好放在顶部，这样它们有足够的空间显示提示列表）。
- en: Pop quiz
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: When does the `onKeyDown` event in `KeyboardListener` get invoked?
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`KeyboardListener`中的`onKeyDown`事件何时被调用？'
- en: When a system-wide key down event is broadcast
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当广播系统范围内的按键按下事件时
- en: Depends on whether the system has a hardware keyboard
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取决于系统是否有硬件键盘
- en: When a hardware keyboard key is pressed
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下硬件键盘按键时
- en: When one of the hardware interface control buttons is pressed
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下硬件接口控制按钮之一时
- en: When would you use a `Toast` to notify the user of a validation error?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你何时会使用`Toast`通知用户验证错误？
- en: When they make a mistake (that is, check a checkbox that shouldn't be checked)
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当他们犯了一个错误（也就是说，勾选了不应该勾选的复选框）
- en: After they tab off the invalid widget
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当他们从无效小部件上移开焦点后
- en: After receiving a validation error from an external service
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从外部服务接收到验证错误之后
- en: In an IM (Instant Messaging) application, if one of the user's contacts goes
    offline, how do you update the `ListView` of contacts to reflect this change?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个即时通讯（IM）应用中，如果用户的其中一个联系人下线了，你如何更新联系人`ListView`以反映这一变化？
- en: Graphically disable the users icon in the `ListView` and move it to the bottom
    of the `ListView`
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ListView`中图形化地禁用用户图标，并将其移动到`ListView`底部
- en: Remove the user from the `ListView`
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ListView`中移除用户
- en: Disable the users icon in the `ListView`
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ListView`中禁用用户的图标
- en: Building activities for results
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为结果构建活动
- en: There are times when none of the default widgets in Android will fulfill your
    input requirements on their own, and you need some sort of composite input structure.
    In these cases, you can either create a `Dialog` widget, or build a new `Activity`.
    `Dialog` widgets are useful when their content is kept small (two or three lines
    of widgets at maximum) because they visually remain on top of the current `Activity`.
    However, this means that they consume additional resources (since their calling
    `Activity` cannot be swapped out into the background), and because they have their
    own decorations they don't have as much available screen space to work on as an
    `Activity`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，Android中的默认小部件单独无法满足你的输入需求，你需要某种复合输入结构。在这种情况下，你可以创建一个`Dialog`小部件，或者构建一个新的`Activity`。当`Dialog`小部件的内容保持简短（最多两到三行小部件）时，它们非常有用，因为它们在视觉上保持在当前`Activity`的顶部。然而，这意味着它们会消耗额外的资源（因为它们的调用`Activity`不能被换到后台），并且由于它们有自己的装饰，它们没有像`Activity`那样多的可用屏幕空间。
- en: 'In [Chapter 4](ch04.html "Chapter 4. Leveraging Activities and Intents"), *Leveraging
    Activities and Intents,* we discussed the notion of `Activity` classes that hand
    data back to their callers. This is a great technique to use when you need some
    additional form of validation or you want to isolate a particular input widget
    (or group of widgets). You can specify some result data in the `Activity.setResult`
    methods. Generally, an `Acitivity` would just specify a success or failure result
    (using the `RESULT_OK` and `RESULT_CANCELLED` constants). It''s also possible
    to hand back data by populating an `Intent` for the purpose:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章. 利用活动和意图")，*利用活动和意图*中，我们讨论了`Activity`类将数据返回给调用者的概念。当你需要某种额外的验证形式或想要隔离特定的输入小部件（或小部件组）时，这是一个很好的技术。你可以在`Activity.setResult`方法中指定一些结果数据。通常，一个`Activity`只需指定成功或失败的结果（使用`RESULT_OK`和`RESULT_CANCELLED`常量）。也可以通过填充`Intent`来返回数据：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Intent` data will be passed into the parent `Activity` object's `onActivityResult`
    method when you invoke the `finish()` method, along with the result code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`finish()`方法时，`Intent`数据会被传递给父`Activity`对象的`onActivityResult`方法，以及结果代码。
- en: Generic filtering search Activity
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用筛选搜索Activity
- en: As discussed earlier in the chapter, there are times where you have a predefined
    list of objects and you want your user to select one of them. The list is too
    large for the user to scroll through (for example, a list of all the countries
    in the world), but it's also a defined list, so you don't want them to be able
    to select free text.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面所讨论的，有时你有一个预定义的对象列表，并希望用户选择其中一个。这个列表对于用户来说太大，无法滚动浏览（例如，世界上所有国家的列表），但它也是一个定义好的列表，所以你不希望他们能够选择自由文本。
- en: In this case, a filterable `ListView` is generally the best suited option. While
    the `ListView` class has filtering capabilities, it doesn't work very well (if
    at all) on devices without hardware keyboards. For this reason, it's wise to make
    use of an `EditText` widget to allow the user to filter the contents of the `ListView`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个可过滤的`ListView`通常是最合适的选择。尽管`ListView`类具有过滤功能，但在没有硬件键盘的设备上，它工作得并不是很好（如果有的话）。因此，利用`EditText`小部件让用户过滤`ListView`的内容是明智的。
- en: This sort of requirement is a very common one, and so in this section we'll
    look at building an `Activity` that is almost entirely generic in its capability
    to filter and select data. This example will provide two mechanisms for displaying
    the data to the user. One through a `Cursor`, and another through a simple `Object`
    array. In both cases, the task of filtering the `ListView` is left up to the `ListAdapter`
    implementation, keeping the implementation relatively simple.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种需求非常常见，因此在本节中，我们将研究构建一个几乎完全通用的`Activity`，用于过滤和选择数据。这个例子将为用户提供两种显示数据的方式。一种是通过`Cursor`，另一种是通过简单的`Object`数组。在这两种情况下，过滤`ListView`的任务都留给`ListAdapter`实现，使得实现相对简单。
- en: Time for action – creating the ListItemSelectionActivity
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建`ListItemSelectionActivity`
- en: This is a fairly large and somewhat complex example to work through, so I'll
    break it into bite size chunks, each with a goal. The first thing we want is an
    `Acitivity` class with a nice looking layout. The layout we'll build is an `EditText`
    above a `ListView`, each one with an ID that can be used by the `Acitivity`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大且有些复杂的例子，因此我会将其分解成易于消化的部分，每个部分都有一个目标。我们首先想要的是一个具有美观布局的`Activity`类。我们将构建的布局是一个`EditText`在上，一个`ListView`在下，每个都有可以被`Activity`使用的ID。
- en: 'Create a new project to contain your `ListItemSelectionActivity` class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目来包含你的`ListItemSelectionActivity`类：
- en: '[PRE2]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the `res/layout/main.xml` file in an editor or IDE.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`res/layout/main.xml`文件。
- en: Remove any of the default layout code.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除任何默认的布局代码。
- en: 'Ensure that the root element is a `LinearLayout` consuming the available screen
    space in the `Activity`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保根元素是一个在`Activity`中占用可用屏幕空间的`LinearLayout`：
- en: '[PRE3]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the root element, declare an `EditText` with an ID of `input` and an
    `inputType` of `textFilter` to indicate that it will filter another widget''s
    content:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根元素内部，声明一个ID为`input`，`inputType`为`textFilter`的`EditText`，以表示它将过滤另一个小部件的内容：
- en: '[PRE4]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the `EditText`, we declare a `ListView` which consumes the remaining
    space:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditText`之后，我们声明一个`ListView`，它将占用剩余的空间：
- en: '[PRE5]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the `ListItemSelectionActivity` Java source file in an editor or IDE.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`ListItemSelectionActivity` Java源文件。
- en: 'Declare a `ListAdapter` field at the top of the class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部声明一个`ListAdapter`字段：
- en: '[PRE6]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the `ListAdapter` field, declare a `Filter` field:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ListAdapter`字段之后，声明一个`Filter`字段：
- en: '[PRE7]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `onCreate` method, make sure you are loading the `main.xml` as the content
    view for the `ListItemSelectionActivity`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，确保你将`main.xml`加载为`ListItemSelectionActivity`的内容视图：
- en: '[PRE8]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then fetch the `ListView` declared in the XML file for our later use:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后获取在XML文件中声明的`ListView`，以供我们稍后使用：
- en: '[PRE9]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, fetch the `EditText` declared in the XML file for our later use:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，获取在XML文件中声明的`EditText`，以供我们稍后使用：
- en: '[PRE10]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You've now got a skeleton of the `ListItemSelectionActivity` class. The application
    will be able to run at this point, presenting you with an empty `ListView` and
    an `EditText`. The `ListAdapter` and `Filter` fields declared at the top of the
    class will be used in later stages to hold the list information, and filter what
    is visible on the screen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经得到了`ListItemSelectionActivity`类的框架。此时应用程序能够运行，向你展示一个空的`ListView`和一个`EditText`。稍后阶段将使用类顶部声明的`ListAdapter`和`Filter`字段来保存列表信息，并过滤屏幕上可见的内容。
- en: Time for action – creating an ArrayAdapter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——创建一个`ArrayAdapter`
- en: The `ListItemSelectionActivity` class will accept list content from two different
    sources. You can either specify a database query `Uri` that will be used to select
    two columns from an external source, or you can specify an `Object` array as extra
    data in the `Intent` object. For the next task, we'll write a private utility
    method to create an `ArrayAdapter` from the `Intent` object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItemSelectionActivity`类将接受来自两个不同来源的列表内容。你可以指定一个数据库查询`Uri`，用于从外部源选择两列，或者可以在`Intent`对象中指定一个`Object`数组作为额外数据。对于下一个任务，我们将编写一个私有实用方法，从`Intent`对象创建一个`ArrayAdapter`。'
- en: Open the `ListItemSelectionActivity` Java source file in your editor or IDE.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或IDE中打开`ListItemSelectionActivity`的Java源文件。
- en: 'Declare a new utility method to create a `ListAdapter` for `Intent`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的实用方法，用于为`Intent`创建`ListAdapter`：
- en: '[PRE11]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Fetch an `Object` array from the extra data in `Intent`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Intent`的额外数据中获取`Object`数组：
- en: '[PRE12]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the array is not `null`, and not empty, return a new `ArrayAdapter` object
    which will display the contents of the array in the standard list item resources
    defined by Android:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组不为`null`且不为空，返回一个新的`ArrayAdapter`对象，该对象将显示数组内容在Android定义的标准列表项资源中：
- en: '[PRE13]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the array is either null or empty, throw an `IllegalArgumentException`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组为`null`或为空，抛出`IllegalArgumentException`异常：
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*What just happened?*'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You just wrote a very basic utility method to extract an `Object` array from
    an `Intent`, and return it. The method throws an `IllegalArgumentException` if
    the array doesn't exist, or if it's empty. This is a valid response since we will
    look for the array *after* looking for a database query. If we aren't given any
    data from outside, then this `Activity` cannot be executed. It's useless to ask
    a user to select an item from a blank list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写了一个非常基本的实用方法，从`Intent`中提取`Object`数组并返回它。如果数组不存在或为空，该方法会抛出`IllegalArgumentException`。这是一个有效的响应，因为我们在查找数据库查询*之后*会查找数组。如果我们没有从外部获取任何数据，那么这个`Activity`无法执行。让用户从空白列表中选择项目是没有意义的。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that it's intended that this `Activity` be started by another `Activity`,
    not directly by the user through the applications menu. For that reason, we want
    to give useful feedback to ourselves or other developers when the `Activity` is
    not used in the way it's intended.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个`Activity`旨在由另一个`Activity`启动，而不是通过应用程序菜单直接由用户启动。因此，当`Activity`的使用方式不符合预期时，我们希望给自己或其他开发者提供有用的反馈。
- en: Time for action – creating the CursorAdapter
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——创建`CursorAdapter`
- en: The `CursorAdapter` is much more complex to set up than the `ArrayAdapter`.
    For one thing, we offer more options with the `CursorAdapter` than we did with
    the `ArrayAdapter`. Our `CursorAdapter` can be made to display either one or two
    line list items, based on whether there are one or two columns specified. While
    the `ArrayAdapter` includes some default filtering logic, we need to provide a
    little more support for the `CursorAdapter`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`CursorAdapter`的设置比`ArrayAdapter`复杂得多。一方面，`CursorAdapter`提供的选项比`ArrayAdapter`多。我们的`CursorAdapter`可以根据指定一列或两列来显示单行或双行列表项。尽管`ArrayAdapter`包含一些默认的过滤逻辑，但我们需要为`CursorAdapter`提供更多的支持。'
- en: 'To start with, we allow for two different column naming conventions to be used,
    along with some defaults. Declare a utility method to find the expected column
    names from the `Intent`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们允许使用两种不同的列命名约定，并附带一些默认值。声明一个实用方法，从`Intent`中查找预期的列名：
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, try and use the `primary` attribute name to get a column name:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，尝试使用`primary`属性名获取列名：
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the column name is `null`, try the `secondary` attribute name:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列名为`null`，尝试使用`secondary`属性名：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the column name is still `null`, use the default value:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列名仍然是`null`，使用默认值：
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`return` the column name:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回列名：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, declare another utility method that will create the actual `CursorAdapter`
    to be used in the `ListView`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，声明另一个实用方法，该方法将创建实际的`CursorAdapter`，以便在`ListView`中使用：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Find the name of the first column to be displayed:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找要显示的第一列的名称：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Find the name of the optional second column to be displayed:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找要显示的可选第二列的名称：
- en: '[PRE22]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now have two possible paths—a single line list item, or a double line list
    item. These are very similar in their construction, so we declare some variables
    to hold those values that are different between the two paths:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有两种可能的路径——单行列表项或双行列表项。它们的构建非常相似，因此我们声明一些变量来保存这两条路径之间的不同值：
- en: '[PRE23]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the `line2` column name has been specified, we use the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已指定`line2`列名，我们使用以下代码：
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will be using a two-line list item resource:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个两行列表项资源：
- en: '[PRE25]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The database query needs to select the `_id` column, and both columns that
    were specified in the `Intent`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库查询需要选择`_id`列以及`Intent`中指定的两列：
- en: '[PRE26]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, the list items will only display the two specified columns:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，列表项将只显示两个指定的列：
- en: '[PRE27]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `CursorAdapter` needs to know the resource IDs of the `TextView` widgets
    declared in the `two_line_list_item` resource:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CursorAdapter`需要知道在`two_line_list_item`资源中声明的`TextView`小部件的资源ID：'
- en: '[PRE28]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the second column name was not specified in the `Intent`, the `ListView`
    should have single-line items:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`Intent`中没有指定第二列的名称，则`ListView`应该有单行项目：
- en: '[PRE29]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We only need to request the `_id` column, and the single column name:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要请求`_id`列和单个列名：
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The items in the list should have the contents of the requested column in them:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表中的项目应该包含请求列的内容：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We don''t need to tell the `CursorAdapter` which widget ID to look for in a
    single-line list item resource:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要告诉`CursorAdapter`在单行列表项资源中查找哪个小部件ID：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After the `else` clause, we will have the required variables populated. We
    can run our initial database query and get the full list of data for presenting
    it to the user:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`else`子句之后，我们将拥有所需的变量填充。我们可以运行初始的数据库查询并获得数据的完整列表以展示给用户：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now create the `CursorAdapter` to wrap the database `Cursor` object
    for the `ListView`. We use the `SimpleCursorAdapter` implementation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建`CursorAdapter`来包装数据库`Cursor`对象，供`ListView`使用。我们使用`SimpleCursorAdapter`的实现：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order for the user to filter the list, we need to give the `CursorAdapter`
    a `FilterQueryProvider`. Declare the `FilterQueryProvider` as an anonymous inner
    class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让用户过滤列表，我们需要给`CursorAdapter`一个`FilterQueryProvider`。将`FilterQueryProvider`声明为一个匿名内部类：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside the anonymous `FilterQueryProvider`, declare the `runQuery` method which
    will be called each time the user types a key:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在匿名`FilterQueryProvider`内部，声明`runQuery`方法，该方法将在用户每次按键时被调用：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can return a `managedQuery` which simply performs an SQL `LIKE` on the first
    column that we are rendering in the `ListView`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以返回一个`managedQuery`，它只对我们将在`ListView`中渲染的第一列执行SQL `LIKE`操作：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, the `createCursorAdapter` method can return the `CursorAdapter`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`createCursorAdapter`方法可以返回`CursorAdapter`：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*What just happened?*'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This utility method handles the creation of the `CursorAdapter` for the time
    when a query `Uri` is specified in our `Intent`. This structure allows filtering
    of very large data sets, since it's (generally) built on top of the SQL Lite database.
    Its performance is directly related to the structure of the database table it
    will query.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用方法处理在`Intent`中指定了查询`Uri`时创建`CursorAdapter`的情况。这种结构允许对非常大的数据集进行过滤，因为它通常是建立在SQL
    Lite数据库之上的。其性能与它将查询的数据库表结构直接相关。
- en: As a result of the potentially enormous size of a database query, the `CursorAdapter`
    classes don't do any filtering of the data set themselves. Instead, you are required
    to implement the `FilterQueryProvider` interface to create and run a new query
    for each change to the filter. In the preceding example, we created a `Cursor`
    which is exactly the same as the default `Cursor`, but we add `selection` and
    `selectionArgs` to the query. This `LIKE` clause will tell SQL Lite to only return
    rows starting with the filter that the user has typed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库查询可能非常大，`CursorAdapter`类本身不执行任何数据集过滤。相反，您需要实现`FilterQueryProvider`接口，为每次过滤更改创建并运行新的查询。在上述示例中，我们创建了一个与默认`Cursor`完全相同的`Cursor`，但我们为查询添加了`selection`和`selectionArgs`。这个`LIKE`子句将告诉SQL
    Lite只返回以用户输入的过滤条件开头的行。
- en: Time for action – setting up the ListView
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——设置`ListView`：
- en: We now have implementations to create both types of `ListAdapter` that this
    `Activity` can filter. Now we need a utility method to figure out which one to
    use, and return it; and then we want to use the new utility method to set the
    `ListAdapter` on the `ListView` widget.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建此`Activity`可以过滤的两种类型`ListAdapter`的实现。现在我们需要一个实用方法来确定使用哪一个并返回它；然后我们希望使用新的实用方法在`ListView`小部件上设置`ListAdapter`。
- en: 'Declare a new method to create the desired `ListAdapter` object:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新方法来创建所需的`ListAdapter`对象：
- en: '[PRE39]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Fetch the `Intent` object that was used to start the `Activity`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用于启动`Activity`的`Intent`对象：
- en: '[PRE40]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the data `Uri` in the `Intent` is not `null`, return a `CursorAdapter` for
    the given `Intent`. Otherwise, return an `ArrayAdapter` for the given `Intent`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Intent`中的数据`Uri`不为`null`，则返回给定`Intent`的`CursorAdapter`。否则，返回给定`Intent`的`ArrayAdapter`：
- en: '[PRE41]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `onCreate` method, after finding the two `View` objects from the layout,
    create the desired `ListAdapter` with the new utility method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，从布局中找到两个`View`对象之后，使用新的实用方法创建所需的`ListAdapter`：
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Assign the `Filter` field to the `Filter` given by the `ListAdapter`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Filter`字段分配给`ListAdapter`给出的`Filter`：
- en: '[PRE43]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Set the `ListAdapter` on the `ListView`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ListView`上设置`ListAdapter`：
- en: '[PRE44]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What just happened?*'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This code now references both the created `ListAdapter` object and the `Filter`
    that it works with. You'll notice that if you run the application now, you'll
    get a **Force Close** dialog when you open it. That's because the code now requires
    some sort of data to populate the `ListView` with. While not desirable for a normal
    application, this is really a reusable component which could be used in a variety
    of situations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在引用了创建的`ListAdapter`对象及其配合使用的`Filter`。如果你现在运行应用程序，会发现打开时会弹出**强制关闭**对话框。这是因为现在代码需要某种数据来填充`ListView`。虽然对于一个正常的应用程序来说这并不理想，但这实际上是一个可重用的组件，可以在多种情况下使用。
- en: Time for action – filtering the list
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——过滤列表
- en: Although the code is all set up to display the list, and even to filter it,
    we haven't yet attached the `EditText` box to the `ListView`, so typing in the
    `EditText` will have absolutely no effect at the moment. We need to listen for
    changes to the `EditText` box, and request that the `ListView` be filtered based
    on what is typed. This will involve the `ListItemSelectionActivity` class listening
    for events on the `EditText` and then asking the `Filter` object to narrow the
    available set of items.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码已经设置好了显示列表，甚至可以过滤它，但我们还没有将`EditText`框与`ListView`关联起来，因此在`EditText`中输入目前将完全不起作用。我们需要监听`EditText`框的变化，并根据输入的内容请求过滤`ListView`。这将涉及`ListItemSelectionActivity`类监听`EditText`上的事件，然后请求`Filter`对象缩小可用的项目集合。
- en: 'The `ListItemSelectionActivity` should be made to implement the `TextWatcher`
    interface:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该让`ListItemSelectionActivity`实现`TextWatcher`接口：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After setting the `ListAdapter` on the `ListView` in the `onCreate` method,
    add the `ListItemSelectionActivity` as a `TextWatcher` on the `EditText` widget:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中在`ListView`上设置`ListAdapter`后，将`ListItemSelectionActivity`作为`TextWatcher`添加到`EditText`组件上：
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You''ll need to declare empty implementations of the `beforeTextChanged` and
    `onTextChanged` methods, since we''re not really interested in these events:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要声明`beforeTextChanged`和`onTextChanged`方法的空实现，因为我们实际上并不关心这些事件：
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then declare the `afterTextChanged` method, which we are interested in:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后声明我们感兴趣的`afterTextChanged`方法：
- en: '[PRE48]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `afterTextChanged` method, we simply ask the `Filter` of the current
    `ListAdapter` to filter the `ListView`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`afterTextChanged`方法中，我们只需请求当前`ListAdapter`的`Filter`过滤`ListView`：
- en: '[PRE49]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*What just happened?*'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `TextWatcher` interface is used in order to track changes to a `TextView`
    widget. Implementations will be able to listen for any changes to the actual content
    of the `TextView`, regardless of the source of the change. While the `OnKeyListener`
    and `KeyboardListener` interfaces are mostly there to handle hardware keyboard
    events, the `TextWatcher` handles changes from hardware keyboards, soft keyboards,
    and even internal calls to `TextView.setText`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextWatcher`接口用于追踪`TextView`组件的变化。实现该接口可以监听到`TextView`实际内容的任何改变，无论这些改变来自何处。尽管`OnKeyListener`和`KeyboardListener`接口主要用于处理硬件键盘事件，但`TextWatcher`可以处理来自硬件键盘、软键盘甚至内部调用`TextView.setText`的变化。'
- en: Time for action – returning the selection
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——返回选择项
- en: The `ListItemSelectionActivity` can now be used to display a list of possible
    items, and filter through them by typing in an `EditText` above the `ListView`.
    However, we have no way of letting the user actually select one of the options
    from the `ListView` in order to pass it back to our parent `Activity`. This requires
    nothing more than a simple implementation of the `OnItemClickListener` interface.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItemSelectionActivity`现在可以用来显示可能的条目列表，并通过在`ListView`上方的`EditText`中输入来过滤它们。然而，我们还没有办法让用户从`ListView`中实际选择一个选项，以便将其传递回我们的父`Activity`。这只需要实现一个简单的`OnItemClickListener`接口。'
- en: 'The `ListItemSelectionActivity` class now needs to implement the `OnItemClickListener`
    interface:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ListItemSelectionActivity`类现在需要实现`OnItemClickListener`接口：'
- en: '[PRE50]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After registering as a `TextWatcher` in the `onCreate` method, register as
    an `OnItemClickListener` on the `ListView`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中注册为`TextWatcher`之后，在`ListView`上注册为`OnItemClickListener`：
- en: '[PRE51]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Override the `onItemClick` method to listen for the user''s selection:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onItemClick`方法以监听用户的选择：
- en: '[PRE52]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an empty `Intent` object to pass back to our parent `Activity`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的`Intent`对象，以便传回我们的父`Activity`：
- en: '[PRE53]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the `ListAdapter` is a `CursorAdapter`, the `id` passed into the `onItemClick`
    will be the database `_id` column value for the selection. Add this value to the
    `Intent`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`ListAdapter`是`CursorAdapter`，传递给`onItemClick`的`id`将是选择的数据的数据库`_id`列值。将这个值添加到`Intent`中：
- en: '[PRE54]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the `ListAdapter` is not a `CursorAdapter`, we add the actual selected `Object`
    to the `Intent`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`ListAdapter`不是`CursorAdapter`，我们将实际选择的`Object`添加到`Intent`中：
- en: '[PRE55]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set the result code to `RESULT_OK`, and pass the `Intent` back:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果代码设置为`RESULT_OK`，并将`Intent`传回：
- en: '[PRE56]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The user has made their selection, so we''re now finished with this part:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户已经做出了他们的选择，所以这部分我们已经完成了：
- en: '[PRE57]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*What just happened?*'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `ListItemSelectionActivity` is now complete and ready for use. It offers
    much the same functionality as an `AutoCompleteTextView`, except that being an
    independent `Activity`, it offers the user a much larger list of suggestions,
    and the user must select an item from the `ListView` instead of being able to
    simply type their input data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItemSelectionActivity`现在已完成并准备使用。它提供了与`AutoCompleteTextView`非常相似的功能，但作为一个独立的`Activity`，它为用户提供了更大的建议列表，并且用户必须从`ListView`中选择一个项目，而不是简单地输入他们的数据。'
- en: Using the ListItemSelectionActivity
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ListItemSelectionActivity
- en: 'You will need to specify what data you want the user to select from, as part
    of the `Intent` that starts a `ListItemSelectionActivity`. As already discussed,
    there are effectively two paths:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要指定用户要从哪个数据中选择，这是启动`ListItemSelectionActivity`的`Intent`的一部分。如已经讨论过的，实际上有两种路径：
- en: Pass in an array of some sort (which is perfect for use within your own application)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传入某种类型的数组（非常适合在您自己的应用程序中使用）
- en: Give it a database query `Uri` and the column names you want displayed (which
    is great if you want to use it from another application)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个数据库查询`Uri`以及您想要显示的列名（如果您想从另一个应用程序中使用它，这非常方便）
- en: 'Since the `ListItemSelectionActivity` returns its selection (and it''s not
    much use if it doesn''t), you need to start it with the `startActivityForResult`
    method instead of the normal `startActivity` method. If you want to pass it an
    array of `String` objects to select from, you could use something similar to the
    following intent = new Intent(this, ListItemSelectionActivity.class):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ListItemSelectionActivity`返回其选择（如果它不这样做，那就没有多大用处），因此您需要使用`startActivityForResult`方法而不是正常的`startActivity`方法来启动它。如果您想传递一个`String`对象数组供选择，可以使用类似于以下意图的代码：`new
    Intent(this, ListItemSelectionActivity.class)`：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Given enough colors in the above `data` array, you would be presented with
    a `ListItemSelectionActivity` screen which could be filtered for the user''s desired
    color. The following is a screenshot of how the resulting screen would look:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述`data`数组中有足够的颜色，您将看到一个可以按用户所需颜色进行筛选的`ListItemSelectionActivity`屏幕。以下是结果屏幕外观的截图：
- en: '![Using the ListItemSelectionActivity](img/4484_06_04.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![使用ListItemSelectionActivity](img/4484_06_04.jpg)'
- en: 'In order to receive the results back from the `ListItemSelectionActivity`,
    you will need to listen for the results in the `onActivityResult` method (as discussed
    in [Chapter 4](ch04.html "Chapter 4. Leveraging Activities and Intents"), *Leveraging
    Activities and Intents*). If, for example, you simply wanted to `Toast` the result
    of the confirmed selection, you could use the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`ListItemSelectionActivity`接收结果，您需要在`onActivityResult`方法中监听结果（如[第4章](ch04.html
    "第4章. 利用活动和意图")所述，*利用活动和意图*）。例如，如果您只是想`Toast`确认选择的结果，可以使用以下代码：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, how would you use a database query with the `ListItemSelectionActivity`?
    This is amazingly easy to show, and is probably the most exciting feature of the
    `ListItemSelectionActivity`. The following code snippet will let the user select
    one of the contacts from their phone book:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您会如何在`ListItemSelectionActivity`中使用数据库查询呢？这非常容易展示，可能是`ListItemSelectionActivity`最激动人心的功能。以下代码段将允许用户从他们的电话簿中选择一个联系人：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Have a go hero!
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手试试吧！
- en: The `ListItemSelectionActivity` can filter and select almost anything. Try building
    up a list of all the countries in the world (many such lists are available online),
    and then create an `Activity` which asks you to select one using a `ListItemSelectionActivity`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItemSelectionActivity` 可以过滤和选择几乎任何内容。尝试构建一个包含世界上所有国家（网上有许多这样的列表）的列表，然后创建一个
    `Activity`，使用 `ListItemSelectionActivity` 让你选择其中一个。'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: How you accept input from your users, and how you validate that input plays
    a crucial part in the overall experience your users will have with your application.
    Software should help the users along and tell them what it expects at each step.
    This not only makes an application easier to use, but also much faster to work
    with.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何接受用户的输入，以及如何验证这些输入，这在用户使用你的应用程序的整体体验中起着至关重要的作用。软件应该帮助用户，并在每一步告诉他们它需要什么。这不仅使应用程序更容易使用，而且还能让用户更快地操作。
- en: Using the `ListItemSelectionActivity`, will often help your users trawl through
    large data sets, while protecting them from making a choice that they don't want
    to, or is invalid. It's a very commonly used type of widget and is seen in many
    different applications (in various forms). Android, at present, doesn't have a
    generic class to perform this job quite as easily.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ListItemSelectionActivity` 常常可以帮助用户浏览大量数据集，同时防止他们做出不想要或无效的选择。这是一种非常常用的控件类型，在许多不同的应用程序中以各种形式出现。目前，Android
    没有一个通用的类能像这样轻松地执行这项任务。
- en: 'In the next chapter, we''ll start taking a look at a fairly modern form of
    user feedback: animation. Android has excellent support, not just for animating
    parts of your user interface, but also for composing complex custom animations.
    Animation can play a vital part in a user''s enjoyment of an application. This
    is not only because it looks great, but also because it gives visual queues of
    what the application is currently doing, and what effect their actions are having.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始了解一种相当现代的用户反馈形式：动画。Android 不仅仅支持动画化用户界面的部分元素，还支持组合复杂的自定义动画。动画在用户享受应用程序的过程中起着至关重要的作用。这不仅仅因为它看起来很棒，还因为它提供了视觉线索，让用户了解应用程序当前正在做什么，以及他们的操作产生了什么效果。
