- en: Chapter 7. Intent Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 意图过滤器
- en: Intent filters are the advanced step to understand the minor significant details
    of Android Intents. In this chapter, we will take a look at the basics of intent
    filters and how they can be used effectively in an Android application. The chapter
    also deals with various kinds of tests that an intent should pass before it is
    delivered to the desired component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 意图过滤器是理解安卓意图微小但重要细节的高级步骤。在本章中，我们将了解意图过滤器的基础知识以及如何在安卓应用程序中有效使用它们。本章还处理意图在传递到期望组件之前应通过的各类测试。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Intent filters can be found inside the `AndroidManifest.xml` file, under the
    `activity` tag.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 意图过滤器可以在`AndroidManifest.xml`文件中的`activity`标签下找到。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Intent object and its categorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图对象及其分类
- en: Understanding what intent filters are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解意图过滤器是什么
- en: Understanding what intent tests are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解意图测试是什么
- en: Implementing an intent filter for a particular task
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定任务实现意图过滤器
- en: Intent object and its categorization
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图对象及其分类（重复，不翻译）
- en: Intent objects come with a whole lot of information. This bundle of information
    will help the component to extract knowledge from it. For example, what kind of
    action should be taken on the data that is coming with the intent object; similarly,
    there is the information that is about the Android system. This information about
    the Android system is required when the system doesn't know the component that
    will handle the upcoming intent.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 意图对象附带大量信息。这个信息包将帮助组件从中提取知识。例如，应该对随意图对象传递的数据采取什么类型的操作；同样，还有关于安卓系统的信息。当系统不知道将处理即将到来的意图的组件时，需要关于安卓系统的信息。
- en: In order to have a better understanding about the example mentioned in the preceding
    paragraph, consider a scenario in which the intent is transferred in order to
    start a movie. In this case, the operating system must know which software is
    needed to perform this action.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解前一段提到的示例，考虑一个意图被传递以启动电影的场景。在这种情况下，操作系统必须知道执行此动作需要哪个软件。
- en: The categories contained in the Android intent object are discussed in the following
    sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下文将讨论安卓意图对象中包含的分类。
- en: Component name
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件名称
- en: The intent object contains information about the component name which will be
    handling the data. Mostly, this component consists of the full class name. For
    example, `com.app.demoactivity.MyActivity` or `com.example.demoactivity.MainActivity`.
    This information about the component is optional for the intent object. If it
    is known to the intent object, Android will divert the data handling towards that
    particular component; if it is unknown, Android will identify what the best component
    is to handle this event.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 意图对象包含将处理数据的相关组件名称信息。通常，此组件由完整的类名组成，例如`com.app.demoactivity.MyActivity`或`com.example.demoactivity.MainActivity`。对于意图对象来说，此组件信息是可选的。如果意图对象知道该组件，安卓会将数据处理指向那个特定的组件；如果不知道，安卓会确定哪个组件最适合处理此事件。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The package part of the component name isn't necessarily the same as the project
    name in the `AndroidManifest.xml` file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 组件名称中的包部分不一定与`AndroidManifest.xml`文件中的项目名称相同。
- en: The component name is set by `setComponent()` or `setClassName()` methods that
    are provided by the Android APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 组件名称通过安卓API提供的`setComponent()`或`setClassName()`方法设置。
- en: Intent resolution
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 意图解析
- en: Android intents are categorized into two parts (as described in [Chapter 3](ch03.html
    "Chapter 3. Intent and Its Categorization"), *Intent and Its Categorization* ),
    **implicit intents** and **explicit intents**. For explicit intents, not assigning
    a component name to it does not cause any problems as the component has to be
    included in the intent object, and then Android will automatically direct the
    explicit intent towards the described component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓意图分为两部分（如[第3章](ch03.html "第3章. 意图及其分类")所述，*意图及其分类*），**隐式意图**和**显式意图**。对于显式意图，不为其分配组件名称并不会造成问题，因为必须将组件包含在意图对象中，然后安卓会自动将显式意图指向所描述的组件。
- en: On the other hand, in implicit intents, if the component name is not given to
    the Android system, it will direct it automatically towards all the possible applications
    that can handle this incoming intent. This action will only take place if the
    intent has an intent filter, otherwise Android will not direct it. This term is
    called **Android intent resolution**; it is when you need not define the component
    for implicit intent, and it will automatically show a list of all the possible
    applications that can receive this intent.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在隐式意图中，如果没有向 Android 系统提供组件名称，它将自动将其指向所有可能处理此传入意图的应用程序。只有当意图具有意图过滤器时，此操作才会发生，否则
    Android 不会引导它。这个术语称为 **Android 意图解析**；当你不需要为隐式意图定义组件时，它将自动显示所有可能接收此意图的应用程序列表。
- en: Action
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作
- en: Action is a string that describes the action to to be taken on an intent. For
    example, `ACTION_CALL`, `ACTION_BATTERY_LOW`, and `ACTION_SCREEN_ON`. You can
    find various other constants for actions at [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html).
    You can also make your own intent actions, but make sure to add the project name
    before it, for example, `com.example.myproject.SHOW_CONTACT`. The custom action
    is required when the developer wants to make an event that has not been previously
    added to Android SDK. This requirement can also occur when the developer wants
    to trigger/check an action which is closely related to that application only.
    Hence, it is not present in Android SDK.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是一个描述在意图上要执行操作的字符串。例如，`ACTION_CALL`、`ACTION_BATTERY_LOW` 和 `ACTION_SCREEN_ON`。你可以在
    [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html)
    找到其他各种动作的常量。你也可以创建自己的意图动作，但请确保在前面加上项目名称，例如 `com.example.myproject.SHOW_CONTACT`。当开发者想要创建一个之前未添加到
    Android SDK 的事件时，需要自定义动作。当开发者想要触发/检查与该应用程序紧密相关且不在 Android SDK 中的动作时，也可能出现这个需求。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`com.example.XXX` is the package name that is discouraged by Java and Android
    application development. It makes sure that the use of this package is mostly
    due to understanding the purpose of it in this example.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.example.XXX` 是在 Java 和 Android 应用程序开发中不推荐使用的包名。这确保了使用这个包大多是因为理解了本例中的用途。'
- en: Action normally tells you how your intent is structured, especially the data
    and the extras. It is like a phenomenon of methods, where there are arguments
    and it returns values. It is a good practice to always use your action name as
    specifically as possible, and tightly couple them with the intent. Intent action
    can be set by using the Android API's method `setAction()`, and you can get it
    by using the `getAction()` method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 动作通常可以告诉你意图是如何构建的，尤其是数据和额外信息。它就像方法的现象，有参数并且返回值。最佳实践是始终尽可能具体地使用你的动作名称，并与意图紧密耦合。意图动作可以通过使用
    Android API 的 `setAction()` 方法来设置，你可以通过 `getAction()` 方法获取它。
- en: 'Some of the predefined constants for the intent action are given in the following
    table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下表给出了一些预定义的意图动作常量：
- en: '| Constants | Component relation | Action |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 组件关系 | 动作 |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ACTION_CALL` | Activity | Initiate a phone call |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_CALL` | 活动 | 初始化一个电话通话 |'
- en: '| `ACTION_EDIT` | Activity | Display data from the user to edit |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_EDIT` | 活动 | 显示用户数据以进行编辑 |'
- en: '| `ACTION_MAIN` | Activity | Start up as an initial activity with no data input
    and no returned output |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_MAIN` | 活动 | 作为初始活动启动，无需数据输入，也没有返回输出 |'
- en: '| `ACTION_SYNC` | Activity | Synchronized data on the server with the data
    on a mobile device |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_SYNC` | 活动 | 在服务器上与移动设备上的数据同步 |'
- en: '| `ACTION_BATTERY_LOW` | Broadcast receiver | A warning that the battery is
    low |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_BATTERY_LOW` | 广播接收器 | 电池电量低的警告 |'
- en: '| `ACTION_HEADSET_PLUG` | Broadcast receiver | A headset is plugged into the
    device |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_HEADSET_PLUG` | 广播接收器 | 耳机插入设备 |'
- en: '| `ACTION_SCREEN_ON` | Broadcast receiver | The screen has turned on |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `ACTION_SCREEN_ON` | 广播接收器 | 屏幕已开启 |'
- en: Data
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: In Android intents, different types of actions are taken on the basis of the
    different types of data that are provided. Data is one of the fundamental parts
    on Android intents, especially in the implicit category. Let us look at some examples
    in order to have a better understanding of how to use data with its relevant action
    in Android intents.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android意图中，根据提供的数据类型，采取不同类型的动作。数据是Android意图的基本部分之一，尤其是在隐式类别中。让我们通过一些例子来更好地了解如何在Android意图中使用与其相关动作的数据。
- en: Use of data in ACTION_EDIT
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`ACTION_EDIT`中使用数据
- en: Consider an example of `ACTION_EDIT`. Whenever we call this action into intent,
    it is obvious that the edit functionality is to be implemented in a sort of the
    document. This document path is to be given in the form of a URI, which will then
    be handled by the Android intent. This URI is basically the part of the data that
    we put inside the intent object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`ACTION_EDIT`的例子。每当我们在意图中调用这个动作时，很明显，编辑功能需要在某种文档中实现。这个文档路径应以URI的形式给出，然后由Android意图处理。这个URI实际上是我们要放入意图对象中的数据部分。
- en: '`ACTION_EDIT` can be used in a scenario where a developer wants to open the
    default Android''s **Add new contact** screen in which the developer expects the
    user to edit. In this case, the intent which is called to open the **Add new contact**
    screen should have the `ACTION_EDIT` action defined.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者希望打开默认的Android的**添加新联系人**屏幕并期待用户进行编辑时，可以使用`ACTION_EDIT`。在这种情况下，用于打开**添加新联系人**屏幕的意图应该定义`ACTION_EDIT`动作。
- en: Use of data in ACTION_CALL
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`ACTION_CALL`中使用数据
- en: Consider another example of `ACTION_CALL`. This action is used when we need
    to perform the call functionality through intent. So, in order to complete the
    task, we need to provide a telephone number by referencing it using a `tel://`
    URI. This is the part of the data set that is to be provided with the intent so
    that Android may know on what data does it need to perform the dialling functionality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个`ACTION_CALL`的例子。当我们需要通过意图执行呼叫功能时，使用此动作。因此，为了完成这项任务，我们需要通过使用`tel://` URI引用来提供电话号码。这是需要与意图一起提供的数据集，以便Android知道需要执行拨号功能的数据。
- en: Use of data in ACTION_VIEW
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`ACTION_VIEW`中使用数据
- en: Moving towards our third example, that is `ACTION_VIEW`. In most cases, when
    this action is called, there is a website linked to it via a URI. This helps Android
    to understand the data on which the view action is to be performed. Normally,
    with `ACTION_VIEW` action, an `http://` URI is attached, so that Android may process
    the functionality of viewing any web page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的第三个例子，即`ACTION_VIEW`。在大多数情况下，当调用此动作时，会通过URI链接到一个网站。这帮助Android了解要在其上执行查看动作的数据。通常，`ACTION_VIEW`动作会附加一个`http://`
    URI，以便Android可以处理查看任何网页的功能。
- en: Category
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别
- en: It is the additional information given to the intent in order to know the best
    kind of component required to perform that specific intent. For example, if there
    is a webpage that we want to view using `ACTION_VIEW` action, we can specify its
    category as `CATEGORY_BROWSABLE`, in order to let Android know that the data associated
    with the intent is safe and can easily be executed using the Android browser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向意图提供的信息，以便了解执行该特定意图所需的最佳组件类型。例如，如果我们想使用`ACTION_VIEW`动作查看一个网页，我们可以将其类别指定为`CATEGORY_BROWSABLE`，以让Android知道与意图关联的数据是安全的，并且可以通过Android浏览器轻松执行。
- en: 'Some constants of categories that can be easily used in any Android program
    are listed in the following table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Android程序中都可以轻松使用的类别常量列表如下：
- en: '| Constants | Explanation |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 说明 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CATEGORY_BROWSABLE` | The activity is safe to be executed on an Android
    browser using the data associated with the intent. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `CATEGORY_BROWSABLE` | 活动可以在与意图关联的数据的Android浏览器上安全执行。 |'
- en: '| `CATEGORY_GADGET` | The activity is associated with another activity that
    is hosted by any Android gadget. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `CATEGORY_GADGET` | 活动与任何Android设备托管的另一个活动相关联。 |'
- en: '| `CATEGORY_HOME` | The activity displays the home screen, or it is the first
    screen that the user sees when the **Home** button is pressed. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `CATEGORY_HOME` | 活动显示主屏幕，或者当按下**主页**按钮时用户看到的第一个屏幕。 |'
- en: '| `CATEGORY_LAUNCHER` | The category of a particular activity is launcher,
    which means it is going to be the top of the stack activity. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `CATEGORY_LAUNCHER` | 特定活动的类别是启动器，这意味着它将成为堆栈顶部的活动。 |'
- en: '| `CATEGORY_PREFERENCE` | The destination activity is from the preference panel.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `CATEGORY_PREFERENCE` | 目的地活动来自偏好设置面板。 |'
- en: Extras
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加项
- en: In the previous chapters, we had a good look in the extras feature and how can
    we can use it with intents. Just like the data, some extras are bound with the
    intent that is to be launched. For example, the `ACTION_HEADSET_PLUG` action has
    the extra "State" to indicate whether your headphones are connected to the cell
    phone or not.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经详细了解了extras功能以及如何与意图一起使用。与数据类似，一些extras与将要启动的意图绑定在一起。例如，`ACTION_HEADSET_PLUG`动作具有额外的"State"，用以指示耳机是否已连接到手机。
- en: These methods are parallel to those for bundle objects. So, the extras can be
    installed and read as a bundle using the `putExtras()` and `getExtras()` methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与bundle对象的方法类似。因此，可以使用`putExtras()`和`getExtras()`方法将extras安装和读取为bundle。
- en: Intent filters
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图过滤器
- en: At this moment, we have a perfect understanding of Android intents and its implementation.
    Android intents are responsible for telling Android that a certain event has occurred,
    it is also used to give additional data on which a certain action should be taken.
    But how would Android know which component can facilitate the execution of any
    intent? For this, the concept of Intent filters comes in. Intent filters identify
    which component can react to a particular call to activities, services or broadcast
    intents.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时刻，我们对Android意图及其实现有了完美的理解。Android意图负责告诉Android已经发生了某个事件，它也用于提供额外数据，以执行某些特定动作。但是Android如何知道哪个组件可以促进任何意图的执行呢？为此，引入了意图过滤器的概念。意图过滤器用于识别哪些组件可以响应活动、服务或广播意图的特定调用。
- en: Typically, intent filters are given to an activity or a service via `AndroidManifest.xml`
    file that consists of action, data, and category tests. In the case of broadcast
    receiver, intent filters can also be defined via code, dynamically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，意图过滤器通过`AndroidManifest.xml`文件提供给活动或服务，该文件包含动作、数据和类别测试。对于广播接收器，意图过滤器也可以通过代码动态定义。
- en: 'For an implicit intent, it is necessary for it to pass all the three tests
    in order to deliver it to the particular component. Now, there can be two conditions
    based on these cases: one is when the intent does not pass any one of the tests,
    the intent will not be passed to the component. The other case is, when it has
    got its tests passed, it will directly be handed over to the respective component.
    In the first case, there is an exception that if it does not pass the test, it
    can be handed over to the next intent filter of the same activity. By this, it
    will be possible that it might be executed as per the expectation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于隐式意图，为了将其传递给特定组件，必须通过所有三个测试。基于这些情况，可能会出现两种条件：一种情况是意图没有通过任何一项测试，那么它将不会被传递给组件。另一种情况是，当它通过了所有测试，它将直接移交给相应的组件。在第一种情况下，有一个例外，如果没有通过测试，它可以被传递给同一活动的下一个意图过滤器。通过这种方式，它有可能按照预期执行。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can have multiple intent filters inside one activity in the `AndroidManifest.xml`
    file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，我们可以在一个活动中拥有多个意图过滤器。
- en: 'A normal XML tag of an activity having an intent filter inside looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有内部意图过滤器的活动的普通XML标签如下所示：
- en: '![Intent filters](img/9639_07_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![意图过滤器](img/9639_07_01.jpg)'
- en: 'As you can see in the code, it consists of one activity tag which has everything
    inside it. This activity consists of only one intent filter that has two main
    components in it: **action** and **category**. The action to be taken at the execution
    of this intent is `android.intent.action.MAIN`, by calling this action any previous
    reference to the activity is removed, and the activity is executed with a fresh
    start. With this, the category is set as `android.intent.category.LAUNCHER`; this
    shows that the activity that is written inside the `AndroidManifest` file is the
    launcher''s `activity` tag. That means, it is the first activity to be launched
    once the application is executed. If there are two or more activities described
    as launcher in the `AndroidManifest.xml` file, the Android operating system will
    ask the user which activity to start with.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，它由一个包含所有内容的activity标签组成。这个活动仅包含一个意图过滤器，其中包含两个主要组件：**动作**和**类别**。此意图执行时要采取的动作是
    `android.intent.action.MAIN`，通过调用此动作，任何对活动的先前引用都会被移除，活动会以全新的启动执行。这样，类别被设置为 `android.intent.category.LAUNCHER`；这表明在
    `AndroidManifest` 文件中编写的活动是启动器的 `activity` 标签。这意味着，一旦执行应用程序，它就是第一个要启动的活动。如果在 `AndroidManifest.xml`
    文件中有两个或更多描述为启动器的活动，Android操作系统将询问用户要从哪个活动开始。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`<intent-filter>` is part of the `AndroidManifest.xml` file and not of the
    Java code, because the information it contains is required before the project
    application is launched. For example, the category is to be determined if it is
    a launcher activity or not, before the start of the project application. As the
    `AndroidManifest.xml` file is executed before the start of the project application
    in order to extract the information about the project, intent filters are part
    of this file. The only exception is in the case of broadcast intent, in which
    the information can be modified dynamically from the Java code and not from the
    `AndroidManifest.xml` file.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`<intent-filter>` 是 `AndroidManifest.xml` 文件的一部分，而不是Java代码，因为它包含的信息需要在项目应用程序启动之前获取。例如，在项目应用程序启动之前，需要确定它是否为启动器活动。由于
    `AndroidManifest.xml` 文件在项目应用程序启动之前执行，以便提取有关项目的信息，意图过滤器是此文件的一部分。唯一的例外是在广播意图的情况下，其信息可以从Java代码动态修改，而不是从
    `AndroidManifest.xml` 文件。'
- en: Handling multiple intent filters
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个意图过滤器
- en: 'It is not a compulsion that any Android activity may have only one intent filter.
    One activity may incorporate various intent filters which occupy many sub components
    such as category, data, and actions. Take a look at the following screenshot which
    shows the two intent filters present with different types of parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 并非强制要求任何Android活动只能有一个意图过滤器。一个活动可能包含多个意图过滤器，这些过滤器占据了诸如类别、数据和动作等多个子组件。请看下面的截图，展示了带有不同类型参数的两个意图过滤器：
- en: '![Handling multiple intent filters](img/9639_07_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![处理多个意图过滤器](img/9639_07_02.jpg)'
- en: The explanation of the code mentioned in the preceding screenshot will be covered
    in the upcoming topics of this chapter. For the time being, it is important to
    know the implementation of various intent filters inside an activity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前述截图中提到的代码解释将在本章后续内容中介绍。目前，了解活动内部各种意图过滤器的实现是重要的。
- en: Test components of an intent filter
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图过滤器的测试组件
- en: Filters are the representative of action, data, and category field of an intent
    object. Whenever an implicit intent is called, it is tested against these filters
    in order to get executed. If that intent does not fulfill any one of the test
    components, it will not be executed, or rather, it will be directed to a separate
    intent filter of the same activity (if it exists).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是意图对象中动作、数据和类别字段的代表。每当调用隐式意图时，都会针对这些过滤器进行测试，以便执行。如果该意图不满足任何一个测试组件，它将不会执行，或者更确切地说，它将被引导到同一活动的另一个意图过滤器（如果存在的话）。
- en: 'Now, in order to have a proper understanding of the intent filters, we need
    to go through a step-by-step evaluation of each test component associated with
    the intent filter. There are three test components present:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了正确理解意图过滤器的意图，我们需要逐步评估与意图过滤器相关的每个测试组件。存在三个测试组件：
- en: Action test
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作测试
- en: Data test
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据测试
- en: Category test
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别测试
- en: Action test
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作测试
- en: Action describes what kind of action is to be executed by the coming intent.
    The `AndroidManifest.xml` file determines the requirements that are to be fulfilled
    by the incoming intent. If any intent is unable to match the specified action
    in the `AndroidManifest.xml` file, it will not be executed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 操作描述了即将由传入意图执行的操作类型。`AndroidManifest.xml`文件确定了传入意图需要满足的要求。如果任何意图无法匹配`AndroidManifest.xml`文件中指定的操作，它将不会被执行。
- en: 'Action test is basically a test that is executed by the information given inside
    the manifest file of the project. All the action components are defined inside
    the `<intent-filter>` tags, and then matched in order to execute the intent. In
    the following screenshot, you can see how the `intent-filter` tag looks while
    having action tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 操作测试基本上是由项目清单文件中提供的信息来执行的一个测试。所有的操作组件都在`<intent-filter>`标签内定义，然后通过匹配来执行意图。在下面的截图中，你可以看到操作测试时`intent-filter`标签的样子：
- en: '![Action test](img/9639_07_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![操作测试](img/9639_07_03.jpg)'
- en: 'In the code given in the preceding screenshot, there are three actions listed
    inside the `intent-filter` tags. These action tests will be determined by the
    Android operating system if the incoming intent is be able to do these actions.
    There are three tests listed in the preceding code, descriptions of which you
    can see in the table given in the *Action* section. The following two conditions
    are to be followed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个截图中给出的代码中，`intent-filter`标签内列出了三个操作。这些操作测试将由Android操作系统确定，如果传入的意图能够执行这些操作。在前面的代码中列出了三个测试，你可以在*Action*部分给出的表格中看到它们的描述。需要遵循以下两个条件：
- en: If there is no action written inside the `intent-filter` tags, the Android operating
    system will refuse to process the intent as there is nothing available for matching.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`intent-filter`标签内没有写入操作，Android操作系统将拒绝处理意图，因为没有可匹配的内容。
- en: If the `intent-filter` tag contains more than one action, but there is no action
    listed in the incoming intent, the intent will go through with it without any
    problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`intent-filter`标签包含多个操作，但传入意图中没有列出任何操作，意图仍将毫无问题地继续执行。
- en: Writing conventions for <action>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<action>`的编写约定'
- en: There are certain conventions that Android follows while defining the actions.
    It should be kept in mind, for default actions we have to use the predefined constants
    that are given in the Android API. In the Android library, it is a convention
    that every action string starts with `ACTION_`, after which the real action name
    is written. For example, `ACTION_MAIN`, `ACTION_TIME_ZONE_CHANGED`, and `ACTION_WEB_SEARCH`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义操作时，Android遵循一些约定。需要记住，对于默认操作，我们必须使用Android API中给出的预定义常量。在Android库中，每个操作字符串都以`ACTION_`开头，然后是实际的操作名称，例如`ACTION_MAIN`、`ACTION_TIME_ZONE_CHANGED`和`ACTION_WEB_SEARCH`。
- en: 'Similarly, when it comes to the convention that is required to mention this
    string inside the `AndroidManifest.xml` file, Android follows the `android.intent.action.STRING`
    pattern. In this statement, the word *STRING* is replaced by the particular action
    that is to be matched but without the word *ACTION*. In order to understand the
    given statement, take the example of the `ACTION_MAIN` constant. If we want to
    mention it inside the `AndroidManifest.xml` file, we will not write `ACTION_`,
    instead we will write something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在提到需要在`AndroidManifest.xml`文件中包含此字符串的约定时，Android遵循`android.intent.action.STRING`模式。在这个语句中，单词*STRING*被替换为要匹配的具体操作，但不包含单词*ACTION*。为了理解这个语句，以`ACTION_MAIN`常量为例。如果我们想在`AndroidManifest.xml`文件中提到它，我们不会写`ACTION_`，而是会这样写：
- en: '![Writing conventions for <action>](img/9639_07_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![<action>的编写约定](img/9639_07_04.jpg)'
- en: 'It is the same case with `ACTION_EDIT`, which enables the Android to edit any
    document whose reference is given in the URI. We will write the code, shown in
    the following screenshot, to make it understandable in the `AndroidManifest.xml`
    file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACTION_EDIT`也是同样的情况，它使Android能够编辑URI中给出的任何文档的引用。我们将在下面的截图中编写代码，以便在`AndroidManifest.xml`文件中容易理解：'
- en: '![Writing conventions for <action>](img/9639_07_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![<action>的编写约定](img/9639_07_05.jpg)'
- en: 'When it comes to the custom action, the action is defined by the user and not
    the Android API. There is a best practice that before writing it always starts
    with your package name in order to keep it unique. For example, if you want to
    make an action called `HIDE_OBJECTS`, you will have to write code, as shown in
    the following screenshot, in your XML file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到自定义动作时，动作是由用户定义而不是Android API。有一个最佳实践是在编写之前始终以您的包名开始，以保持其唯一性。例如，如果您想创建一个名为`HIDE_OBJECTS`的动作，您必须在XML文件中编写如下截图所示的代码：
- en: '![Writing conventions for <action>](img/9639_07_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![为 <action> 编写约定](img/9639_07_06.jpg)'
- en: Category test
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别测试
- en: In order to pass the category test, it is necessary that the incoming intent
    category should be matched with at least one of the categories mentioned inside
    the `<category>` tag in `AndroidManifest.xml`. If an intent object is created
    without any knowledge of the category in it, it should always pass, no matter
    what categories are defined in the manifest file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过类别测试，必须确保传入的意图类别与`AndroidManifest.xml`中的`<category>`标签内至少提到的一个类别相匹配。如果在不知道其中类别的情况下创建意图对象，它应该总是通过，无论清单文件中定义了哪些类别。
- en: Keeping in mind that if we want to move between one activity to another using
    the `startActivity()` method, it is necessary that the activity that is willing
    to receive the implicit intent must have one default category mentioned in the
    `AndroidManifest.xml` file, which is `CATEGORY_DEFAULT` (as mentioned in Android
    API).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住，如果我们想使用`startActivity()`方法在活动之间移动，那么愿意接收隐式意图的活动在`AndroidManifest.xml`文件中必须有一个默认类别，即`CATEGORY_DEFAULT`（如Android
    API中所提及）。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is the same as writing the convention for action, the category should be
    written as `android.intent.category.DEFAULT`, without mentioning the `CATEGORY_`
    string in `AndroidManifest.xml`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这与为动作编写约定一样，类别应该写成`android.intent.category.DEFAULT`，在`AndroidManifest.xml`中不提`CATEGORY_`字符串。
- en: 'Although, this is not the case with launcher category; it is an exception.
    We mention `android.intent.category.LAUNCHER` in the launcher activity tags. The
    representation of the category test is shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于启动类别来说，这不是情况；它是一个例外。我们在启动活动标签中提到`android.intent.category.LAUNCHER`。类别测试的表示在下图中显示：
- en: '![Category test](img/9639_07_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![类别测试](img/9639_07_07.jpg)'
- en: In the code given in the preceding screenshot, there are two categories mentioned.
    The first category is `android.intent.category.DEFAULT`, which is because this
    particular activity is all set to receive the implicit intent. The other category
    that is mentioned in the manifest file is `android.intent.category.BROWSABLE`,
    which enables this activity to browse through the native Android browser present
    in the phone or any other applications that are for browsing websites.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个截图给出的代码中，提到了两个类别。第一个类别是`android.intent.category.DEFAULT`，这是因为这个特定的活动已经准备好接收隐式意图。在清单文件中提到的另一个类别是`android.intent.category.BROWSABLE`，它使此活动能够浏览手机中的本地Android浏览器或其他用于浏览网站的应用程序。
- en: Setting up the launcher activity
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置启动活动
- en: Setting up the launcher activity is primarily a part of the category. In this,
    we need to make sure that we completely understand the exception of the launcher
    activity with respect to intent. Since it is known that launcher activity is the
    one which is started just after the application is started for the first time,
    we can now move forward with its concept in category. The `DEFAULT` category is
    used if it is known that the activity will receive some implicit intent, but on
    the other hand, the `LAUNCHER` activity is the one that was started for the first
    time in any application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 设置启动活动主要是类别的一部分。在这里，我们需要确保我们完全理解了与意图相比启动活动的异常情况。由于众所周知，启动活动是在应用程序首次启动后立即启动的活动，因此我们现在可以在此基础上深入了解其类别概念。如果已知活动将接收某些隐式意图，则使用`DEFAULT`类别；另一方面，`LAUNCHER`活动是在任何应用程序中首次启动的活动。
- en: 'In this sense, no launcher activity can be a default one at the same time.
    The result concludes that no activity can have `android.intent.category.DEFAULT`
    and `android.intent.category.LAUNCHER` at the same time in `AndroidManifest.xml`.
    The launcher activity presented in the manifest looks like the code shown in the
    following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，没有一个启动活动可以同时是默认的。结论是，在`AndroidManifest.xml`中，没有任何活动可以同时具有`android.intent.category.DEFAULT`和`android.intent.category.LAUNCHER`。在清单中呈现的启动活动看起来像下面截图中的代码：
- en: '[PRE0]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In code given in the preceding screenshot, the activity `com.example.android.application.MyList`
    is the launcher activity that will produce a list at the start of the application.
    Since this is the main entry point of the application, we provide `ACTION_MAIN`
    as the action in the manifest. While you can see the second tag, the category
    that is provided is given the name of `android.intent.category.LAUNCHER`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述截图给出的代码中，活动`com.example.android.application.MyList`是启动活动，它将在应用程序开始时生成一个列表。由于这是应用程序的主要入口点，我们在清单中提供了`ACTION_MAIN`作为动作。而你可以看到第二个标签，提供的类别名称为`android.intent.category.LAUNCHER`。
- en: Data test
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据测试
- en: 'Data tags are mentioned in order to facilitate the action taken on the executed
    activity. That is the reason why there can be multiple data tags inside one `<activity>`
    tag. The `<data>` tag consists of the information on a specific URI or MIME media
    type. For example, an activity may have the data tags, shown in the following
    screenshot, in it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提到数据标签是为了便于对执行的活动采取行动。这就是为什么在`<activity>`标签内可以有多个数据标签的原因。<data>标签包含有关特定URI或MIME媒体类型的信息。例如，一个活动可能包含如下截图所示的数据标签：
- en: '![Data test](img/9639_07_09.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![数据测试](img/9639_07_09.jpg)'
- en: In the code given in the preceding screenshot, the intent filter contains two
    data tags. In each one of them, the MIME media type that is given under the `android:mimeType`
    attribute is the one that specifies the data format supported by the activity
    for a certain action. The `video/avi` value describes the video format of `.avi`
    files, which is supported by the activity. Similarly, if there is a need for mentioning
    the audio file type, we can use `audio/mpeg`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述屏幕截图给出的代码中，意图过滤器包含两个数据标签。在每一个标签中，`android:mimeType`属性下给出的MIME媒体类型指定了活动支持特定操作的数据格式。`video/avi`值描述了`.avi`文件的视频格式，这是活动所支持的。同样，如果需要提及音频文件类型，我们可以使用`audio/mpeg`。
- en: 'It is also possible that we put an asterisk after the video or audio MIME Type.
    For example, see the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在视频或音频MIME类型后加上星号。例如，请看以下截图：
- en: '![Data test](img/9639_07_10.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![数据测试](img/9639_07_10.jpg)'
- en: This code is the same as the previous one, apart from the `video/*` and `audio/*`
    MIME types. The asterisk indicates that all possible subtypes of them are supported
    by this activity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的相同，除了`video/*`和`audio/*` MIME类型。星号表示此活动支持它们所有可能的子类型。
- en: 'Now, there are some points that we need to make sure of:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一些要点我们需要确保：
- en: An intent object that does not contain any particular information about URI
    will only pass through the `intent-filter` tag if, and only if, there is no information
    of data is provided in the `AndroidManifest.xml` file
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个意图对象不包含有关URI的任何特定信息，它只会在`AndroidManifest.xml`文件中没有提供数据信息的情况下通过`intent-filter`标签。
- en: An intent object that only contains the URI but not the data MIME type will
    only be passed if, and only if, it is matched with the URI specified in the filter
    and there is no filter specified for the data type
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个意图对象只包含URI但不包含数据MIME类型，只有当它与过滤器中指定的URI匹配并且没有为数据类型指定过滤器时，它才会被传递。
- en: An intent object that only contains the MIME type, but not the URI, will only
    be passed if, and only if, it is matched with the MIME type specified in the filter
    and there is no filter specified for the URI
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个意图对象只包含MIME类型，但不包含URI，只有当它与过滤器中指定的MIME类型匹配并且没有为URI指定过滤器时，它才会被传递。
- en: In the case where an intent object contains the URI, as well as the MIME type,
    it will only be passed if they are matched with the corresponding values of intent-filters
    specified in `AndroidManifest.xml`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个意图对象包含URI以及MIME类型时，只有当它们与`AndroidManifest.xml`中指定的意图过滤器对应值匹配时，它才会被传递。
- en: Typical representation of the <data> tag
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <data>标签的典型表示
- en: 'The `<data>` tag contains many attributes in order to make it complete information.
    The following syntax contains all the attributes that can be defined in the `<data>`
    tag, which will increase the knowledge of the activity while the processing of
    intent is happening:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`<data>`标签包含许多属性以使其信息完整。以下语法包含了可以在`<data>`标签中定义的所有属性，这将在处理意图时增加对活动的了解：'
- en: '![Typical representation of the <data> tag](img/9639_07_11.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![典型的<data>标签表示](img/9639_07_11.jpg)'
- en: 'In the code given in the preceding screenshot, there are various attributes
    which are all optional, yet they are more mutually dependent on one another. The
    list of the optional attributes is given as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图给出的代码中，有各种属性，它们都是可选的，但它们相互之间更为依赖。以下是可选属性的列表：
- en: '`scheme`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheme`'
- en: '`host`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`'
- en: '`port`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`'
- en: '`path`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`'
- en: '`pathPrefix`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathPrefix`'
- en: '`pathPattern`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathPattern`'
- en: Now, let's talk about their dependencies with one another. If the scheme is
    not mentioned in the data tag, no URI will remain valid after that. Similarly,
    if the host element is not defined, all the path tags and host tag values will
    be voided.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈它们之间的相互依赖关系。如果在数据标签中没有提到方案，那么在此之后将没有有效的URI。同样，如果没有定义主机元素，所有的路径标签和主机标签值将无效。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we had a detailed look at the intent filter and intent object.
    We saw the basic building blocks of the intent object, in which we define elements
    in the Java code, and on the other hand there are intent filters, which give knowledge
    to the Android OS about the activities present inside the application. We learned
    how `intent-filters` tags do their work by matching the incoming intent object
    and its attribute. Then, they decide whether or not the intent should be executed
    or not.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细地查看了意图过滤器和意图对象。我们了解了意图对象的基本构建块，在其中我们在Java代码中定义元素，而在另一方面，意图过滤器让Android
    OS了解应用程序内部的活动。我们学习了`intent-filters`标签如何通过匹配传入的意图对象及其属性来工作。然后，它们决定是否应该执行意图。
- en: We also took a look on the action, data, and category, and how these work. How
    different data, categories, and actions are incorporated within a single activity
    in different intent filters, and what the main mechanism is if there are various
    filter choices available. We also looked at some writing conventions, the typical
    way of writing a launcher activity in the Android Manifest and how many MIME types
    are incorporated over when the data is valid for different subtypes of a format.
    In the next chapter, we will see how intents can be used with broadcast receivers,
    their practical examples, and the kind of issues that can arise because of them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了动作、数据和类别以及它们是如何工作的。不同的数据、类别和动作如何在单个活动的不同意图过滤器中合并，以及如果存在多种过滤器选择，主要机制是什么。我们还研究了某些写作约定，在Android
    Manifest中编写启动活动的典型方式，以及当数据对格式的不同子类型有效时包含多少MIME类型。在下一章中，我们将看到意图如何与广播接收器一起使用，它们的实际示例以及可能因为它们而产生的问题类型。
