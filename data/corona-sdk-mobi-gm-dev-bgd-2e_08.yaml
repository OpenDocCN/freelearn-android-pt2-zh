- en: Chapter 8. Operation Composer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 操作编排器
- en: '*We''ve taken our game, Egg Drop, and explored ways to create game physics
    to react with collision detection and track other useful data, such as lives and
    a points system. We also worked with customizing physical bodies and created names
    for our display objects that apply to the game score count.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们已经将游戏Egg Drop进行了探索，创建了游戏物理以反应碰撞检测并跟踪其他有用的数据，如生命值和积分系统。我们还处理了自定义物理实体，并为我们的显示对象创建了名称，这些名称适用于游戏分数计数。*'
- en: Next, we'll add a menu system that incorporates the introduction to the game,
    apply a pause menu during game play, and save high scores when the game is over.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个菜单系统，其中包括游戏介绍，游戏中应用暂停菜单，并在游戏结束时保存高分。
- en: We're on our way to completing an application that has the necessary elements
    to make it ready for the App Store and Google Play Store.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在完成一个应用程序，它具备了发布到App Store和Google Play Store所需的必要元素。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Save and load high scores
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载高分
- en: Add a pause menu
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加暂停菜单
- en: Manage scenes with the Composer API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Composer API管理场景
- en: Add a loading screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加加载屏幕
- en: Add a main menu, options menu, and credits screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加主菜单、选项菜单和制作人员屏幕
- en: So, let's get going!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Continuation of Egg Drop
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续鸡蛋掉落游戏（Egg Drop）
- en: We have finished the main game portion of Egg Drop as the main base of our application.
    Now, it's time for us to include how to pause action midgame and also save high
    scores. We will also add some new scenes that will help us introduce and transition
    to the game in an easy and quick fashion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了Egg Drop的主要游戏部分，作为我们应用程序的基础。现在，是时候让我们加入如何在游戏中途暂停动作以及保存高分的方法了。我们还将添加一些新场景，帮助我们轻松快速地介绍和过渡到游戏。
- en: In the `Resources` folder of `Chapter 8`, grab all the image and file assets
    inside and copy them to your current `Egg Drop` project folder. You can download
    the project files accompanying this book from the Packt Publishing website. We
    will use these files to add the final touches to our game.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在`第8章`的`Resources`文件夹中，获取所有图像和文件资源，并将它们复制到当前的`Egg Drop`项目文件夹中。你可以从Packt Publishing网站下载伴随这本书的项目文件。我们将使用这些文件为我们的游戏添加最后的润色。
- en: Data saving
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据保存
- en: Saving file information is used in many aspects of game development. We use
    it to save high scores and game settings, such as sound on/off, locking/unlocking
    levels, and so on. It is not necessary to have these features, but as they are
    good to have, maybe you'd like to include them in your applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件信息在游戏开发的许多方面都有应用。我们用它来保存高分和游戏设置，如声音开关、锁定/解锁关卡等。这些功能并非必须，但既然它们很好，也许你希望在应用程序中包含它们。
- en: In Corona SDK, applications are sandboxed; this means that your files (application
    images, data, and preferences) are stored in a location that no other application
    can access. Your files will reside in an app-specific directory for documents,
    resources, or temporary files. This restriction is related to the files on your
    device, not when you are coding on your Mac or PC.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Corona SDK中，应用程序是沙盒化的；这意味着你的文件（应用程序图片、数据和个人偏好设置）存储在一个其他应用程序无法访问的位置。你的文件将驻留在特定于应用程序的目录中，用于文档、资源或临时文件。这个限制与你在Mac或PC上编程时的文件有关，而不是设备上的文件。
- en: BeebeGames class for saving and loading values
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BeebeGames类用于保存和加载值
- en: We'll be using the BeebeGames class created by Jonathan Beebe. It provides many
    easy and useful functions to use for games. Some of the notable functions included
    incorporate a simple way of saving and loading data that we'll be able add into
    our game. More documentation on the BeebeGames class can be found in the `Chapter
    8` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由Jonathan Beebe创建的BeebeGames类。它提供了许多简单且实用的游戏功能。其中一些值得注意的功能包括一种简单保存和加载数据的方法，我们可以将其加入到我们的游戏中。关于BeebeGames类的更多文档可以在`第8章`文件夹中找到。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also refer to [https://github.com/lewisNotestine/luaCorona/blob/master/justATest/code/beebegames.lua](https://github.com/lewisNotestine/luaCorona/blob/master/justATest/code/beebegames.lua)
    to track updates on the class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以参考[https://github.com/lewisNotestine/luaCorona/blob/master/justATest/code/beebegames.lua](https://github.com/lewisNotestine/luaCorona/blob/master/justATest/code/beebegames.lua)，以跟踪类的更新。
- en: You can take a look at other methods relating to animation, transitions, timers,
    and so on if you would like to use them for future use. For now, we'll focus on
    the methods we can use to easily save and load values for our game.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将来使用它们，可以查看其他与动画、过渡、定时器等相关的方法。现在，我们将专注于可以使用这些方法轻松地为我们的游戏保存和加载值。
- en: 'Here is an example of saving and loading values:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个保存和加载值的示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting paths to files
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文件的路径
- en: 'The paths to these files are unique to your application. To create file paths,
    you can use the `system.pathForFile` function. This function generates an absolute
    path to the icon file for your application, using the application''s resource
    directory as the base directory for `Icon.png`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的路径对于你的应用程序来说是唯一的。要创建文件路径，你可以使用`system.pathForFile`函数。这个函数会生成一个绝对路径到应用程序的图标文件，以应用程序的资源目录作为`Icon.png`的基础目录：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In general, your files must reside in one of the three possible base directories:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的文件必须位于三个可能的基础目录之一：
- en: '`system.DocumentsDirectory`: This should be used for files that need to persist
    between application sessions.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.DocumentsDirectory`：这应该用于需要在应用程序会话之间持久存在的文件。'
- en: '`system.TemporaryDirectory`: This is a temporary directory. Files written to
    this directory are not guaranteed to exist in subsequent application sessions.
    They may or may not exist.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.TemporaryDirectory`：这是一个临时目录。写入这个目录的文件不能保证在后续的应用程序会话中存在。它们可能存在，也可能不存在。'
- en: '`system.ResourceDirectory`: This is the directory where all application assets
    exist. Note that you should never create, modify, or add files to this directory.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.ResourceDirectory`：这是所有应用程序资源的目录。注意，你不应该在这个目录中创建、修改或添加文件。'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on files can be found at [http://docs.coronalabs.com/api/library/system/index.html](http://docs.coronalabs.com/api/library/system/index.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件的更多信息可以在[http://docs.coronalabs.com/api/library/system/index.html](http://docs.coronalabs.com/api/library/system/index.html)找到。
- en: Reading files
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件
- en: To read files, the `io` library is used. This library allows you to manage files,
    given an absolute path.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，使用`io`库。这个库允许你管理文件，给定一个绝对路径。
- en: Writing files
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件
- en: To write files, you follow many of the steps that are the same as for reading
    a file. Instead of using a read method, you write data (strings or numbers) to
    a file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，你可以按照很多与读取文件相同的步骤进行。不同的是，你不是使用读取方法，而是将数据（字符串或数字）写入文件。
- en: Time for action – saving and loading the high score
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——保存和加载最高分
- en: 'When the **Game Over** screen displays, we will save and load the values of
    our final score and highest score. For this perform the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当**游戏结束**屏幕显示时，我们将保存并加载最终得分和最高分值。为此，执行以下步骤：
- en: Open up your `main.lua` file that we created for Egg Drop. We'll continue using
    the same file and add in more code with the new alterations to the game.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开为Egg Drop创建的`main.lua`文件。我们将继续使用同一个文件，并添加更多代码以及对游戏的新的修改。
- en: 'Add in two new variables, `local highScoreText` and `local highScore` where
    all the other initialized variables are located, near the top of the code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码顶部，所有其他初始化变量的位置加入两个新的变量，`local highScoreText`和`local highScore`：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Introduce the `saveValue()` function after the preloaded sound files:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预加载的音频文件后引入`saveValue()`函数：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add in the `loadValue()` function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入`loadValue()`函数：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At the end of the `callGameOver()` function, create an `if` statement to compare
    `gameScore` and `highScore`. Save the highest score by using the `saveValue()`
    function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`callGameOver()`函数的最后，创建一个`if`语句来比较`gameScore`和`highScore`。使用`saveValue()`函数保存最高分：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, add in the `highScoreText` display text in the same `callGameOver()`
    function, to show the high score at the end of the game:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在同一个`callGameOver()`函数中加入`highScoreText`显示文本，以便在游戏结束时显示最高分：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the end of the `gameStart()` function, have the high score loaded by using
    the `loadValue()` function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameStart()`函数的最后，使用`loadValue()`函数加载最高分：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Time for action – saving and loading the high score](img/9343OT_08_01.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![是时候行动了——保存和加载最高分](img/9343OT_08_01.jpg)'
- en: '*What just happened?*'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: After initializing the `saveValue()` and `loadValue()` functions at the game
    level, we created an `if` statement to compare `gameScore`, which is the current
    score during game play, and `highScore`, which is the highest score accrued so
    far. When the outcome of `gameScore` is higher, then it replaces the `highScore`
    data saved.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏级别初始化了`saveValue()`和`loadValue()`函数后，我们创建了一个`if`语句来比较`gameScore`（游戏进行时的当前得分）和`highScore`（迄今为止获得过的最高得分）。当`gameScore`的结果更高时，它就会替换保存的`highScore`数据。
- en: In order to save the value, a data file needs to be created. We created a variable
    called `local highScoreFilename = "highscore.data"`. We called the `saveValue()`
    function using `highScoreFilename` as a parameter. The `tostring(highScore)` parameter
    will convert the numeric value of `highScore` to a string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存这个值，需要创建一个数据文件。我们创建了一个名为`local highScoreFilename = "highscore.data"`的变量。我们使用`highScoreFilename`作为参数调用了`saveValue()`函数。`tostring(highScore)`参数会将`highScore`的数值转换为字符串。
- en: When the **Game Over** screen is visible, `highScoreText` displays the value
    saved from `highScore` above the `gameScore` that is achieved. Adding a high score
    gives the player an incentive to top the highest score and adds the replay value
    to the game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当**游戏结束**屏幕可见时，`highScoreText`会显示从`highScore`保存的值，位于达到的`gameScore`上方。添加高分可以激励玩家争取最高分，并增加游戏的重复可玩性。
- en: In the `gameStart()` function, it's important to have the value of `highScore.data`
    loaded at the start of game play. Using the same data file we created to save
    `highScore`, we can also load the value throughout the game. To load the value,
    `local highScore` calls `loadValue(highScoreFileName)`. This takes the information
    from `highScore.data`. To obtain the value, `tonumber(loadedHighScore)` converts
    it to an integer from a string and can be used to display the value of `highScore`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gameStart()`函数中，重要的是要在游戏开始时加载`highScore.data`的值。使用我们创建的用来保存`highScore`的同一个数据文件，我们也可以在游戏中加载这个值。为了加载这个值，`local
    highScore`调用`loadValue(highScoreFileName)`。这会从`highScore.data`获取信息。为了得到这个值，`tonumber(loadedHighScore)`将其从字符串转换为整数，并可以用来显示`highScore`的值。
- en: Pausing the game
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: Have you ever found yourself in the middle of playing a game and all of a sudden
    you have to take a bathroom break or your hand cramps up? Obviously, any of these
    situations require you to deter your attention from your game progress, and you
    need to stop the current action temporarily to attend to those needs. This is
    when a pause button comes in handy so that you can stop the action in that moment
    in time and then continue where you left off when you're ready to play again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾在玩游戏时突然需要去洗手间或者手抽筋？显然，这些情况都需要你暂时将注意力从游戏进度上转移，并且需要暂时停止当前动作来处理这些需求。这时暂停按钮就显得非常方便，这样你就可以在那一刻停止动作，并在准备好再次游戏时从停止的地方继续。
- en: Time for action – pausing the game
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——暂停游戏
- en: 'It''s more than just making a button; it''s also pausing all the action on
    screen, including physics and timers by performing the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是制作一个按钮；还包括通过执行以下步骤暂停屏幕上的所有动作，包括物理效果和计时器：
- en: 'Add in the `local pauseBtn` and `local pauseBG` variables where all the other
    variables are initialized near the beginning of the code. Preload the `btnSound`
    audio after `gameOverSound` near the top of the script:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码开始部分初始化其他变量时，添加`local pauseBtn`和`local pauseBG`变量。在脚本顶部`gameOverSound`之后预加载`btnSound`音频：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within the `hud()` function and after the `scoreText` chunk, create another
    function that will run the event for the pause button. Call the `onPauseTouch(event)`
    function. Pause the physics in the game by setting `gameIsActive` to `false` and
    have the pause elements appear on screen:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hud()`函数内，在`scoreText`部分之后创建另一个函数，用于运行暂停按钮的事件。调用`onPauseTouch(event)`函数。通过将`gameIsActive`设置为`false`来暂停游戏中的物理效果，并让暂停元素在屏幕上显示：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the game is unpaused, have the physics become active again and remove
    all the pause display objects:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏取消暂停时，让物理效果再次激活，并移除所有暂停显示对象：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the `pauseBtn` UI button and `pauseBG` display object after the `onPauseTouch()`
    function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onPauseTouch()`函数后添加`pauseBtn` UI按钮和`pauseBG`显示对象：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order for `pauseBtn` to display during game play, make it visible and active
    in the `gameActivate()` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让`pauseBtn`在游戏过程中显示，需要在`gameActivate()`函数中使其可见并激活：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the game is over, disable `pauseBtn` in the `callGameOver()` function
    Place the code right after the `physics.pause()` line:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏结束时，在`callGameOver()`函数中禁用`pauseBtn`，将代码放在`physics.pause()`行之后：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Time for action – pausing the game](img/9343OT_08_02.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间——暂停游戏](img/9343OT_08_02.jpg)'
- en: '*What just happened?*'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the `onPauseTouch(event)` function to control all the pause events
    that occur within the game play. To pause all the motion in the game, we changed
    the Boolean of `gameIsActive` to `false` and the `physics.pause()` function to
    stop all the eggs that are falling from moving. Next, the timer is paused for
    `startDrop` so that any eggs falling from the sky won't accumulate over time as
    long as the pause function is still active.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`onPauseTouch(event)`函数，以控制游戏过程中发生的所有暂停事件。为了暂停游戏中的所有动作，我们将`gameIsActive`的布尔值改为`false`，并使用`physics.pause()`函数停止所有正在下落的鸡蛋。接下来，`startDrop`的计时器暂停，只要暂停功能仍然有效，从天空中下落的鸡蛋就不会随时间累积。
- en: A slightly transparent overlay called `shade` is called to appear when the pause
    button is pressed. This will deter the attention from the game scene and allow
    the user to differentiate when the game play is not active.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下暂停按钮时，会出现一个名为`shade`的略微透明的覆盖层。这将分散玩家对游戏场景的注意力，并让用户区分游戏是否处于非活动状态。
- en: The **Game Paused** banner also displays on the top of the screen by making
    it visible and active. The `pauseBG` object is pushed ahead of the display hierarchy
    by `pauseBG:toFront()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏暂停**横幅也会在屏幕顶部显示，通过设置为可见和活动状态。`pauseBG`对象通过`pauseBG:toFront()`被推到显示层次结构的前面。'
- en: To unpause the game, we reversed the process of how the pause display items
    appeared. When `pauseBtn` is pressed for the second time, `shade` is taken away
    by `display.remove(shade); shade = nil`. The `pauseBG.isVisible` and `pauseBG.isActive`
    properties are both set to `false`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了取消暂停游戏，我们反向执行了暂停显示项出现的过程。当`pauseBtn`第二次被按下时，通过`display.remove(shade); shade
    = nil`移除`shade`。`pauseBG.isVisible`和`pauseBG.isActive`属性都被设置为`false`。
- en: Remember that we had set `gameIsActive` to `false` earlier Well, it's now time
    to set it back to true. This also means resuming physics with `physics.start()`.
    The timer is resumed by the `resumeGame()` local function and calls `timer.resume(startDrop)`
    within the function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前将`gameIsActive`设置为`false`，现在是将它设回`true`的时候了。这也意味着通过`physics.start()`恢复物理效果。计时器通过`resumeGame()`本地函数恢复，并在函数中调用`timer.resume(startDrop)`。
- en: The `pauseBtn` and `pauseBG` display objects are inserted at the end of the
    `if` statement block. The `pauseBtn` object is then shown as visible and active
    once the game is playable. It is invisible and inactive when the **Game Over**
    screen appears so that there are no other touch events that can interfere when
    the game is over.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pauseBtn`和`pauseBG`显示对象被插入到`if`语句块的末尾。一旦游戏可以玩，`pauseBtn`对象就会显示为可见和活动状态。当**游戏结束**屏幕出现时，它是不可见和非活动的，这样当游戏结束时就不会有其他触摸事件干扰。'
- en: The Composer API
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Composer API
- en: The Composer API provides an easy solution for developers to control scenes
    with or without transitions. This is a great scene-management library to display
    menu systems and even managing multiple levels in a game. Composer also comes
    with a variety of transition effects. More information can be found on the Corona
    Docs at [http://docs.coronalabs.com/api/library/composer/index.html](http://docs.coronalabs.com/api/library/composer/index.html).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Composer API为开发者提供了一个简单的解决方案，用于控制具有或不具有过渡效果的场景。这是一个很棒的场景管理库，可以显示菜单系统，甚至管理游戏中的多个关卡。Composer还附带多种过渡效果。更多信息可以在Corona文档中找到，地址是[http://docs.coronalabs.com/api/library/composer/index.html](http://docs.coronalabs.com/api/library/composer/index.html)。
- en: Our scene management will look similar to the scene template displayed at [http://docs.coronalabs.com/api/library/composer/index.html#scene-template](http://docs.coronalabs.com/api/library/composer/index.html#scene-template).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的场景管理与在[http://docs.coronalabs.com/api/library/composer/index.html#scene-template](http://docs.coronalabs.com/api/library/composer/index.html#scene-template)展示的场景模板相似。
- en: Game development with the Composer API
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Composer API进行游戏开发
- en: You may wonder how we're going to apply Composer with Egg Drop. It's really
    simple. We'll have to alter some lines in our game code to make it compatible
    with Composer and create some new scenes for the menu system that is applied before
    game splay.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇我们如何将Composer应用于Egg Drop。这真的很简单。我们只需修改游戏代码中的一些行，使其与Composer兼容，并为游戏开始前应用的菜单系统创建一些新场景。
- en: Time for action – altering the game file
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——修改游戏文件
- en: 'We will rename our current `main.lua` file to `maingame.lua` and add some additional
    lines to our game code. Be sure to *change* the file name within your `Egg Drop`
    project folder. To rename the file follow these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前的`main.lua`文件重命名为`maingame.lua`，并在游戏代码中添加一些额外的行。确保在`Egg Drop`项目文件夹中*更改*文件名。按照以下步骤重命名文件：
- en: 'Remove the following lines near the top of the code. We''ll hide the status
    bar in another scene that we''ll create later on in this chapter. The `gameGroup`
    display group will be altered to fit within the Composer parameters:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除代码顶部附近的以下行。我们将在本章后面创建的另一个场景中隐藏状态栏。`gameGroup`显示组将被修改以适应Composer参数：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the very top of the code, implement Composer by adding `local composer =
    require( "composer" )` and `local scene = composer.newScene()` so that we can
    call the scene events:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码的最顶部，通过添加`local composer = require( "composer" )`和`local scene = composer.newScene()`来实现Composer，这样我们就可以调用场景事件：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After `local loadValue = function( strFilename )`, add in the `create()` event.
    We will also add back in our `gameGroup` display group, but under the scene''s
    view property. Also, add in `composer.removeScene( "loadgame" )`. The `"loadgame"`
    scene will be introduced later on in this chapter:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local loadValue = function( strFilename )`之后，在`create()`事件中添加。我们还将重新添加我们的`gameGroup`显示组，但位于场景的view属性下。同时，加入`composer.removeScene(
    "loadgame" )`。本章后面将介绍`"loadgame"`场景：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the `create()` event, create the `show()` event and add it before the
    `gameActivate()` function. The `show()` event will transition all our game play
    functions onscreen. Include `gameGroup` in the scene''s view property as well:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create()`事件之后，创建`show()`事件，并将其放在`gameActivate()`函数之前。`show()`事件将过渡我们所有的游戏玩法功能到屏幕上。同时，也将`gameGroup`包含在场景的view属性中：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the `gameStart()` function, remove the `return gameGroup` line:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gameStart()`函数之后，删除`return gameGroup`行：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, close `function scene: show( event )` with `end`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，用`end`关闭`function scene: show( event )`：'
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `hide()` and `destroy()` events:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`hide()`和`destroy()`事件：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, create event listeners for all the scene events and add `return scene`
    at the end of the code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为所有场景事件创建事件监听器，并在代码末尾添加`return scene`：
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*What just happened?*'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Using the Composer API will help us transition scenes a lot easier and quicker.
    Every time you want to load a new scene into view, `require("composer")` needs
    to be added. The `local scene = composer.newScene()` statement will allow us to
    call the scene events, `create()`, `show()`, `hide()`, and `destroy()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composer API将帮助我们更容易、更快速地过渡场景。每次你想将一个新场景加载到视图中时，需要添加`require("composer")`。`local
    scene = composer.newScene()`声明将允许我们调用场景事件，`create()`，`show()`，`hide()`，和`destroy()`。
- en: At the very end of the game code, we added event listeners for all the scene
    events and for `return scene`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏代码的最后，我们为所有场景事件和`return scene`添加了事件监听器。
- en: The format of how each scene is managed with Composer will look similar to the
    preceding code. Most of the game code will be dispatched when a scene is displayed
    by the `create()` and `show()` events. When you want to clean or unload listeners,
    audio, assets, and so on, the `hide()` and `destroy()` events are used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composer管理每个场景的格式将与前面的代码类似。大部分游戏代码将在`create()`和`show()`事件显示场景时派发。当你想要清理或卸载监听器、音频、资源等时，将使用`hide()`和`destroy()`事件。
- en: Organizing the game
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织游戏
- en: We've been used to having `main.lua` as our main source file to show every detail
    of our game code. It's time to organize it efficiently with the help of the Composer
    API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于将`main.lua`作为我们的主源文件，以显示游戏代码的每个细节。现在是时候通过Composer API有效地组织它了。
- en: Time for action – adding the new main.lua file
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加新的main.lua文件
- en: 'While using Composer, our `main.lua` file is still vital since it is the first
    thing that Corona SDK looks at to launch an application in the simulator. We''re
    going to add some lines of code that will change scenes for our game:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composer时，我们的`main.lua`文件仍然至关重要，因为它是Corona SDK启动模拟器中的应用程序时首先要查看的内容。我们将添加一些代码行，这些代码行将改变我们游戏的场景：
- en: 'Create a brand new file called `main.lua` and let''s add it back in our status
    bar:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.lua`的新文件，并将其重新添加到我们的状态栏中：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Import Composer and load the first scene called `loadmainmenu`. We will create
    this scene in the next couple of sections:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Composer并加载名为`loadmainmenu`的第一个场景。我们将在接下来的几节中创建这个场景：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*What just happened?*'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In order to incorporate Composer throughout the application, we called the `local
    composer = require ( "composer" )` module. The scene will be changed with `composer.gotoScene(
    "loadmainmenu" )`, which is a loading screen directing the user to the main menu
    screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序中整合Composer，我们调用了`local composer = require ( "composer" )`模块。场景将使用`composer.gotoScene(
    "loadmainmenu" )`进行更改，这是一个引导用户进入主菜单屏幕的加载屏幕。
- en: New game transitions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的游戏过渡
- en: Now that we have introduced the Composer API, we can apply some long-awaited
    transitions that will be helpful for our game. One way to approach this is by
    transitioning out of the game once it is over.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了Composer API，我们可以应用一些期待已久的过渡效果，这将对我们的游戏有所帮助。一种方法是游戏结束后退出游戏。
- en: Time for action – changing screens after the game is over
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——游戏结束后切换屏幕
- en: 'Now that we have renamed our game file, let''s add in a scene transition so
    that our game is not stuck at the **Game** **Over** screen once game play is over.
    To change the screen, perform the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经重命名了游戏文件，让我们添加一个场景过渡，这样游戏结束后就不会停留在**游戏结束**屏幕了。要更改屏幕，请执行以下步骤：
- en: 'In our `maingame.lua` file, add in a new variable called `local menuBtn`, where
    all the other variables are initialized in the beginning of the code. Inside the
    `callGameOver()` function, add the following lines after the `highScoreText` code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`maingame.lua`文件中，加入一个名为`local menuBtn`的新变量，其他所有变量都在代码开始时初始化。在`callGameOver()`函数内，在`highScoreText`代码之后添加以下几行：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Time for action – changing screens after the game is over](img/9343OT_08_03.jpg)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手时间——游戏结束后切换屏幕](img/9343OT_08_03.jpg)'
- en: '*What just happened?*'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In order to transition out of the game over screen, a menu button was created
    to change scenes. Inside the `onMenuTouch()` function, upon the release of the
    button, we called `composer.gotoScene( "mainmenu", "fade", 500 )`. This will allow
    the application to transition to the main menu in 500 milliseconds using a fade,
    which we will create later on in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从游戏结束屏幕过渡出去，我们创建了一个菜单按钮来更改场景。在`onMenuTouch()`函数中，在按钮释放时，我们调用了`composer.gotoScene(
    "mainmenu", "fade", 500 )`。这将允许应用程序在500毫秒内使用淡入淡出效果过渡到主菜单，我们将在本章后面创建这个效果。
- en: Have a go hero – restarting the game
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手英雄——重新开始游戏
- en: Now that you're well aware of how the Composer API works with changing scenes
    and using UI buttons to transition between them, how about creating a button that
    restarts the game after the game over screen appears? So far, the application
    allows the user to go back to the menu screen once the game has reached an end.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经充分了解Composer API如何与更改场景以及使用UI按钮在它们之间过渡，那么何不创建一个按钮，在游戏结束屏幕出现后重新开始游戏呢？到目前为止，该应用程序允许用户在游戏结束时返回菜单屏幕。
- en: Within the `callGameOver()` function, a new local function needs to be created
    that will run an event using the UI button system to change scenes with Composer.
    Note that you can't call the same scene over if you're currently in it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`callGameOver()`函数内，需要创建一个新的本地函数，该函数将使用UI按钮系统运行事件，通过Composer更改场景。注意，如果你当前已经在该场景中，则不能再次调用同一场景。
- en: Creating a loading screen
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个加载屏幕
- en: Loading screens provide feedback that the program is in the process of loading.
    This is helpful by informing the user that the next screen is underway, so that
    they don't assume that the application has crashed, especially if the next screen
    is loading a large amount of data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加载屏幕提供了程序正在加载过程中的反馈。这有助于告知用户下一个屏幕正在加载，这样他们就不会认为应用程序已经崩溃了，尤其是如果下一个屏幕正在加载大量数据时。
- en: Time for action – adding the loading screen
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——添加加载屏幕
- en: We'll place loading screens when the application launches and before the game
    level starts. This tells the user that more content or information is on its way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序启动和游戏关卡开始之前放置加载屏幕。这告诉用户更多内容或信息即将到来。
- en: Create a new file called `loadmainmenu.lua` in your project folder.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中创建一个名为`loadmainmenu.lua`的新文件。
- en: 'Import Composer and add in the `composer.newScene()` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Composer并在其中加入`composer.newScene()`函数：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create two local variables called `myTimer` and `loadingImage`. Add in the
    `create()` event and a `sceneGroup` display group:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`myTimer`和`loadingImage`的本地变量。加入`create()`事件和一个`sceneGroup`显示组：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `show()` event and add in a `sceneGroup` display group:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`show()`事件并加入一个`sceneGroup`显示组：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Introduce the `loadingImage` display object:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入`loadingImage`显示对象：
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create another local function called `goToMenu()` and call `composer.gotoScene(
    "mainmenu", "zoomOutInFadeRotate", 500 )` to change the scene to `"mainmenu"`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`goToMenu()`的本地函数，并调用`composer.gotoScene( "mainmenu", "zoomOutInFadeRotate",
    500 )`以将场景更改为`"mainmenu"`：
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use the `timer` function and have it call `goToMenu()`once every 1,000 milliseconds.
    Define it with the `myTimer` timer ID. Close the `show()` event with `end`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`timer`函数，每1,000毫秒调用一次`goToMenu()`。使用`myTimer`计时器ID定义它。使用`end`结束`show()`事件：
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Call the `hide()` and `destroy()` events. In the `hide()` event, cancel `myTimer`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`hide()`和`destroy()`事件。在`hide()`事件中，取消`myTimer`：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add event listeners for all the scene events and for `return scene`. Save and
    close the file:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有场景事件和`return scene`添加事件监听器。保存并关闭文件：
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a new file called `loadgame.lua` in your project folder. We''ll make
    another loading screen that occurs right before the game scene, `maingame.lua`.
    Use `composer.gotoScene( "maingame", "flipFadeOutIn", 500 )` to transition scenes.
    Save and close your file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中创建一个名为`loadgame.lua`的新文件。我们将制作一个在游戏场景`maingame.lua`之前出现的加载屏幕。使用`composer.gotoScene(
    "maingame", "flipFadeOutIn", 500 )`进行场景过渡。保存并关闭你的文件：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Time for action – adding the loading screen](img/9343OT_08_04.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 添加加载屏幕](img/9343OT_08_04.jpg)'
- en: '*What just happened?*'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In the `loadmainmenu.lua` file, once `loadingImage` was added to the screen,
    we created the `goToMenu()` function to change scenes to `"mainmenu"` and use
    the `"zoomOutInFadeRotate"` transition that zooms out and rotates the loading
    screen image as it fades to the background. The `myTimer = timer.performWithDelay(
    1000, goToMenu, 1 )` statement performs the function in 1,000 milliseconds (one
    second) and runs it once. This is long enough to view the image and have it fade
    out.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadmainmenu.lua`文件中，一旦`loadingImage`被添加到屏幕上，我们就创建了`goToMenu()`函数，以将场景更改为`"mainmenu"`，并使用`"zoomOutInFadeRotate"`过渡，让加载屏幕图像在淡出至背景时缩小并旋转。`myTimer
    = timer.performWithDelay( 1000, goToMenu, 1 )`语句在1,000毫秒（一秒）后执行该函数，并且只运行一次。这足够时间查看图像并让它淡出。
- en: All display objects enter the scene by `function scene:show( event )`. The `loadingImage`
    object is placed in `sceneGroup`. To make sure we have no timers running after
    the scene change, `myTime`r stops running with the use of `timer.cancel(myTimer)`
    under `function scene:hide()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有显示对象通过`function scene:show( event )`进入场景。`loadingImage`对象被放置在`sceneGroup`中。为了确保场景更改后没有定时器在运行，`myTimer`在`function
    scene:hide()`下使用`timer.cancel(myTimer)`停止运行。
- en: The code for `loadgame.lua` is similar to `loadmainmenu.lua`. For this file,
    Composer transitions scenes to `maingame.lua`, the game play file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadgame.lua`的代码与`loadmainmenu.lua`类似。对于这个文件，Composer将场景过渡到`maingame.lua`，即游戏玩法文件。'
- en: Creating a main menu
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主菜单
- en: A main menu or title screen is one of the first impressions a player sees before
    playing the game. It usually shows small snippets of images or scenery that correlate
    with the actual game and also displays the title of the application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单或标题屏幕是玩家在玩游戏之前看到的第一印象之一。它通常显示与实际游戏相关的小图像或风景片段，并显示应用程序的标题。
- en: There are buttons such as **Start** or **Play** that urge the player to go into
    the game if they choose to and some secondary buttons such as **Options** to view
    settings and other information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些如**开始**或**播放**的按钮，鼓励玩家如果他们选择的话进入游戏，还有一些次要的按钮如**选项**查看设置和其他信息。
- en: Time for action – adding a main menu
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加主菜单
- en: We will create the frontend of our game by introducing the game title and the
    **Play** and **Options** buttons that will transition throughout different scenes
    in the application with ease.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过引入游戏标题和**播放**和**选项**按钮来创建游戏的前端，这些按钮将在应用程序的不同场景中轻松过渡。
- en: 'Create a new file called `mainmenu.lua` and import Composer and the UI modules,
    the `composer.newScene()` function, and the variables for timer and audio:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mainmenu.lua`的新文件，并导入Composer和UI模块，`composer.newScene()`函数，以及定时器和音频的变量：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the `create()` event. Add in the `composer.removeScene( "maingame" )`
    and `composer.removeScene( "options" )` lines, which will remove the `"maingame"`
    and `"options"` scenes. You can remove `"maingame"` after the player has transitioned
    from the main game screen and is sent to the main menu screen. You can remove
    `"options"` after the player has transitioned from the options screen and is sent
    to the main menu screen:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`create()`事件。添加`composer.removeScene( "maingame" )`和`composer.removeScene(
    "options" )`行，这将移除`"maingame"`和`"options"`场景。可以在玩家从主游戏屏幕过渡并返回主菜单屏幕后移除`"maingame"`。可以在玩家从选项屏幕过渡并返回主菜单屏幕后移除`"options"`：
- en: '[PRE35]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add in the `show()` event and the `backgroundImage` display object;
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`show()`事件中添加`backgroundImage`显示对象；
- en: '[PRE36]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Introduce the `playBtn` display object and create a function called `onPlayTouch(event)`
    that uses `composer.gotoScene()` to change the scene to `"loadgame"`. Use the
    `"fade"` effect to change scenes:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入`playBtn`显示对象，并创建一个名为`onPlayTouch(event)`的函数，该函数使用`composer.gotoScene()`将场景更改为`"loadgame"`。使用`"fade"`效果进行场景变换：
- en: '[PRE37]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Transition the `playBtn` display object to y = 260 in 500 milliseconds using
    the `easing.inOutExpo` transition. Have it initialized through `btnAnim`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`easing.inOutExpo`过渡，在500毫秒内将`playBtn`显示对象转换到y=260的位置。通过`btnAnim`进行初始化：
- en: '[PRE38]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Introduce the `optBtn` display object and create a function called `onOptionsTouch(event)`.
    Use `composer.gotoScene()` to transition the scene to `"options"` using the `"crossFade"`
    effect:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入`optBtn`显示对象，并创建一个名为`onOptionsTouch(event)`的函数。使用`composer.gotoScene()`以`"crossFade"`效果将场景过渡到`"options"`：
- en: '[PRE39]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Transition the `optBtn` display object to `y = 280` in 500 milliseconds using
    the `easing.inOutExpo` transition. Have it initialized through `btnAnim`. Close
    the `scene:show( event )` function with `end`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`easing.inOutExpo`过渡，在500毫秒内将`optBtn`显示对象转换到`y = 280`的位置。通过`btnAnim`进行初始化。使用`end`结束`scene:show(
    event )`函数：
- en: '[PRE40]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the `hide()` event and cancel the `btnAnim` transition. Also, create
    the `destroy()` event:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`hide()`事件并取消`btnAnim`过渡。同时，创建`destroy()`事件：
- en: '[PRE41]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the event listeners for all the scene events and for `return scene`. Save
    and close your file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有场景事件和`return scene`添加事件监听器。保存并关闭你的文件：
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Time for action – adding a main menu](img/9343OT_08_05.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 添加主菜单](img/9343OT_08_05.jpg)'
- en: '*What just happened?*'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: On the main menu screen, we added an image that displayed the game title and
    the **Play** and **Options** buttons. The **Options** button is still not functional
    at this time. The `onPlayTouch()` function transitions the scene to `"loadgame"`.
    This will change scenes to `loadgame.lua`. The **Play** button is placed at `x
    = 240`; `y = 440`, (middle and offscreen). When the scene loads, `playBtn` transitions
    to `y = 260`, so it pops up from the bottom of the screen in 1000 milliseconds.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在主菜单屏幕上，我们添加了一个显示游戏标题和**播放**及**选项**按钮的图像。此时的**选项**按钮还不起作用。`onPlayTouch()`函数将场景过渡到`"loadgame"`。这将改变到`loadgame.lua`场景。**播放**按钮位于`x
    = 240`; `y = 440`（居中和屏幕外）。当场景加载时，`playBtn`过渡到`y = 260`，因此它会从屏幕底部向上弹出，耗时1000毫秒。
- en: The **Options** button does a similar thing. The `optBtn` object is placed to
    the right of the stage and pops up at `y = 280` in 500 milliseconds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项**按钮执行类似操作。`optBtn`对象放置在舞台右侧，并在500毫秒内弹出至`y = 280`。'
- en: The `btnAnim` transition is cancelled by `transition.cancel( btnAnim )` through
    the `scene:hide()` function. It is important to clean timers, transitions, and
    event listeners every time you change scenes so that potential memory leaks do
    not occur while in the application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`btnAnim`过渡通过`scene:hide()`函数中的`transition.cancel( btnAnim )`被取消。每次更改场景时清理定时器、过渡和事件监听器，以防止应用程序中可能发生的内存泄漏，这是非常重要的。'
- en: Creating an options menu
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个选项菜单
- en: An options menu allows users to change various settings in the game or include
    other information that can't be displayed in the main menu. Games can vary from
    having many options to only having a few. Sometimes, an options menu can be called
    a settings menu, which offers the same type of customization to the player's experience.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选项菜单允许用户在游戏中更改各种设置或包含无法在主菜单中显示的其他信息。游戏可以拥有许多选项，也可能只有几个。有时，选项菜单也可以称为设置菜单，为玩家的体验提供相同类型的自定义。
- en: Time for action – adding an options menu
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加一个选项菜单
- en: 'We''ll add an options menu that can be accessed through the main menu. We''re
    going to add a new UI button called **Credits**, which will direct the user to
    the credits screen once it is pressed. To add an option menu perform the following
    steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过主菜单添加一个可以访问的选项菜单。我们将添加一个新的UI按钮，名为**积分**，一旦按下，它将引导用户进入积分屏幕。要添加选项菜单，请执行以下步骤：
- en: 'Create a new file called `options.lua` and import Composer and the UI modules,
    the `composer.newScene()` function, and the variables for timer and audio:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`options.lua`的新文件，并导入Composer和UI模块，`composer.newScene()`函数，以及定时器和音频的变量：
- en: '[PRE43]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the `create()` event. Add in `composer.removeScene( "mainmenu" )`, which
    will remove the `"mainmenu"` scene. This will occur after the player has transitioned
    from the main menu screen and is sent to the options screen. Next, add in `composer.removeScene(
    "creditsScreen" )`. This will remove `"creditsScreen"` after the player has transitioned
    from the credits screen back to the options screen:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`create()`事件。加入`composer.removeScene( "mainmenu" )`，这将移除`"mainmenu"`场景。这会在玩家从主菜单屏幕过渡到选项屏幕后发生。接下来，加入`composer.removeScene(
    "creditsScreen" )`。这将会在玩家从积分屏幕返回到选项屏幕后移除`"creditsScreen"`：
- en: '[PRE44]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add in the `show()` event and the `backgroundImage` display object:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`show()`事件和`backgroundImage`显示对象：
- en: '[PRE45]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a button for the credits screen. Transition the `creditsBtn` display
    object to `y = 260` in 1000 milliseconds using the `easing.inOutExpo` transition.
    Have it initialized through `btnAnim`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为信用屏幕创建一个按钮。在1000毫秒内使用`easing.inOutExpo`过渡将`creditsBtn`显示对象过渡到`y = 260`。通过`btnAnim`初始化它：
- en: '[PRE46]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the **Close** button that loads the main menu. Close the `scene:show(
    event )` with `end`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个加载主菜单的**关闭**按钮。通过`end`结束`scene:show( event )`：
- en: '[PRE47]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the `hide()` event and cancel the `btnAnim` transition. Also, create
    the `destroy()` event. Add the event listeners for all the scene events and the
    `return scene` statement. Save and close your file:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`hide()`事件并取消`btnAnim`过渡。同时，创建`destroy()`事件。为所有场景事件和`return scene`语句添加事件监听器。保存并关闭你的文件：
- en: '[PRE48]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Time for action – adding an options menu](img/9343OT_08_06.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 添加选项菜单](img/9343OT_08_06.jpg)'
- en: '*What just happened?*'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In this scene, `creditsBtn` will operate in a manner similar to how our main
    menu was created. The **Credits** button is still not functional at this time.
    In the `onCreditsTouch()` function, the scene is transitioned to `"creditsScreen"`
    and uses `"crossFade"` as the effect. From the off-screen position, `creditsBtn`
    transitions to y=260 in 1,000 milliseconds when the scene is loaded.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，`creditsBtn`的操作方式与创建主菜单类似。此时的**信用**按钮尚不可用。在`onCreditsTouch()`函数中，场景过渡到`"creditsScreen"`并使用`"crossFade"`作为效果。当场景加载时，`creditsBtn`从屏幕外位置过渡到y=260，耗时1,000毫秒。
- en: A **Close** button is created for this scene so that the user will have a way
    to go back to the previous screen. With the `onCloseTouch()` function, Composer
    changes the scene to `"mainmenu"` upon the release of `closeBtn`. The main menu
    screen will display when you press the close button. The `btnAnim` transition
    is canceled through the `scene:hide()` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个场景创建了一个**关闭**按钮，以便用户有一个返回上一个屏幕的方法。通过`onCloseTouch()`函数，当释放`closeBtn`时，Composer将场景更改为`"mainmenu"`。按下关闭按钮时，将显示主菜单屏幕。`scene:hide()`函数取消了`btnAnim`过渡。
- en: Creating a credits screen
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建信用屏幕
- en: A credits screen usually shows and lists all the people involved in the production
    of the game. It can include other information in the form of thanking certain
    individuals and programs used to create the final project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 信用屏幕通常会显示并列出参与游戏制作的所有人员。它还可以包括感谢某些个人和程序的信息，这些程序用于创建最终项目。
- en: Time for action – adding a credits screen
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加信用屏幕
- en: 'The credits screen that we''ll create will be based on a touch event that transitions
    to the previous screen from which it was introduced. To add a credits screen,
    perform the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的信用屏幕将基于一个触摸事件，该事件从引入它的上一个屏幕过渡回来。要添加信用屏幕，请执行以下步骤：
- en: 'Create a new file called `creditsScreen.lua` and import Composer, the `composer.newScene()`
    function, and the `backgroundImage` variable:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`creditsScreen.lua`的新文件，并导入Composer、`composer.newScene()`函数和`backgroundImage`变量：
- en: '[PRE49]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create the `create()` event. Add in the `composer.removeScene("options")` line,
    which will remove the `"options"` scene. This will occur after the player has
    transitioned from the options screen and is sent to the credits screen:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`create()`事件。添加`composer.removeScene("options")`行，这将移除`"options"`场景。这将在玩家从选项屏幕过渡到信用屏幕后发生：
- en: '[PRE50]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add in the `show()` event and the `backgroundImage` display object:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`show()`事件和`backgroundImage`显示对象：
- en: '[PRE51]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a local function called `changeToOptions()` with an event parameter.
    Have the function change the scene with Composer back to the options screen, using
    a touch event on `backgroundImage`. Close the `scene:show(event)` function with
    `end`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`changeToOptions()`的本地函数，带有一个事件参数。让该函数通过在`backgroundImage`上的触摸事件，使用Composer将场景改回选项屏幕。通过`end`结束`scene:show(event)`函数：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create the `hide()` and `destroy()` events. Add the event listeners for all
    the scene events and the `return scene` statement. Save and close your file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`hide()`和`destroy()`事件。为所有场景事件和`return scene`语句添加事件监听器。保存并关闭你的文件：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Time for action – adding a credits screen](img/9343OT_08_07.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 添加信用屏幕](img/9343OT_08_07.jpg)'
- en: '*What just happened?*'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The credits screen works with an event listener. The `changeToOptions(event)`
    function will tell Composer to change the scene to `"options"` using `composer.gotoScene(
    "options", "crossFade", 500 )`. At the end of the function, `backgroundImage`
    will activate the event listener when the screen is touched. The `backgroundImage`
    object is inserted into the `sceneGroup` under the `scene:show( event )` function.
    Egg Drop is now fully operable using Composer. Run the game in the simulator.
    You'll be able to transition to all the scenes that we created in this chapter,
    as well as play the game.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 信用屏幕与事件监听器一起工作。`changeToOptions(event)`函数将告诉Composer使用`composer.gotoScene( "options",
    "crossFade", 500 )`更改场景为 `"options"`。在函数的末尾，`backgroundImage`将在屏幕被触摸时激活事件监听器。`backgroundImage`对象在`scene:show(
    event )`函数下的`sceneGroup`中插入。现在，Egg Drop完全可以通过Composer操作。在模拟器中运行游戏。你将能够过渡到我们在本章中创建的所有场景，还可以玩游戏。
- en: Have a go hero – adding more levels
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——添加更多关卡
- en: Now that Egg Drop is completed and has a working menu system, challenge yourself
    by creating more levels. Minor alterations will have to be added to add some placement
    for additional levels. Remember to apply Composer when changing scenes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Egg Drop已经完成，并且拥有一个工作的菜单系统，通过创建更多关卡来挑战自己。为了添加额外的关卡位置，将需要增加一些小的修改。在更改场景时请记得应用Composer。
- en: 'Try creating the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建以下内容：
- en: Level select screen
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡选择屏幕
- en: Level number buttons to add additional levels
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外关卡的关卡编号按钮
- en: When creating new levels, refer to the format shown in `maingame.lua`. New levels
    can be altered by changing the interval of how fast the egg falls from the sky,
    or maybe by adding other game assets that fall but have to be dodged in order
    to avoid getting a penalty. There are so many possibilities of adding your own
    spin with this game framework. Give it a try!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新关卡时，请参考`maingame.lua`中显示的格式。新关卡可以通过改变蛋从天而降的速度间隔来改变，或者也许可以通过添加其他游戏资源来躲避以免受到惩罚。有如此多的可能性可以在这个游戏框架中添加你自己的创意。试一试吧！
- en: Pop quiz – game transitions and scenes
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验——游戏过渡和场景
- en: Q1\. What function do you call to change scenes with Composer?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 你调用哪个函数使用Composer更改场景？
- en: '`composer()`'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`composer()`'
- en: '`composer.gotoScene()`'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`composer.gotoScene()`'
- en: '`composer(changeScene)`'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`composer(changeScene)`'
- en: None of the above
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Q2\. What function converts any argument into a number or nil?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 有哪个函数可以将任何参数转换成数字或nil？
- en: '`tonumber()`'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tonumber()`'
- en: '`print()`'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print()`'
- en: '`tostring()`'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tostring()`'
- en: '`nil`'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nil`'
- en: Q3\. How do you pause a timer?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 你如何暂停一个计时器？
- en: '`timer.cancel()`'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timer.cancel()`'
- en: '`physics.pause()`'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`physics.pause()`'
- en: '`timer.pause( timerID )`'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timer.pause( timerID )`'
- en: None of the above
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Q4\. How do you resume a timer?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 你如何恢复一个计时器？
- en: '`resume()`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`resume()`'
- en: '`timer.resume( timerID )`'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timer.resume( timerID )`'
- en: '`timer.performWithDelay()`'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timer.performWithDelay()`'
- en: None of the above
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! We have a game that is complete and can go into the App Store
    or Google Play Store. Of course, we will not use this exact game, but you have
    learned enough to create one. It's a great accomplishment to have completed the
    game framework, especially in the short amount of time it took to create something
    so simple.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！我们已经完成了一个完整的游戏，可以进入App Store或Google Play商店。当然，我们不会使用这个确切的游戏，但你已经学到了足够多的知识去创造一个。在如此短的时间内完成游戏框架是一个了不起的成就，尤其是创造出如此简单的东西。
- en: 'Here are some skills you learned in this chapter:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你学会了以下技能：
- en: Saving high scores using saveValue() and loadValue()
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用saveValue()和loadValue()保存高分
- en: Understanding how to pause physics/timers
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何暂停物理/计时器
- en: Displaying the pause menu
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示暂停菜单
- en: Change scenes with the Composer API
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Composer API更改场景
- en: Creating transitions between scenes using loading screens
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载屏幕在场景间创建过渡
- en: Using a main menu to introduce the game title and submenus
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主菜单介绍游戏标题和子菜单
- en: We have achieved an important milestone in this chapter. Everything that we
    have gone over in the previous chapters was applied to this sample game. The great
    thing about it is that it took us less than a day's worth of development to code.
    The art assets, on the other hand, are a different story.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经取得了重要的里程碑。我们在之前章节中讨论的所有内容都被应用到了这个示例游戏中。关于它最好的事情是，我们花了不到一天的开发时间来编写代码。而艺术资源则是另一回事了。
- en: We still have a few more things to learn with regard to what Corona SDK is capable
    of. In the next chapter, we'll go into more detail on how to optimize our game
    assets for high-resolution devices. We will also see how to post messages on Facebook
    and Twitter through your application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要学习更多关于 Corona SDK 的功能。在下一章中，我们将详细探讨如何为高分辨率设备优化游戏资源。我们还将了解如何通过应用程序在 Facebook
    和 Twitter 上发布消息。
